### Title
Quadratic Complexity in Vote Threshold Checking Enables Governance DoS via Large Member Lists

### Summary
The Association contract's vote threshold checking uses a quadratic O(N*M) algorithm that iterates through all votes and checks each against the full member list using linear search. With no upper limit on organization member count, an attacker can create organizations with thousands of members, causing proposal release operations to exceed AElf's execution limits (15,000 call threshold) and rendering the organization's governance non-functional.

### Finding Description

The vulnerability exists in the threshold checking logic that determines if a proposal can be released. The core issue is in three functions: [1](#0-0) [2](#0-1) [3](#0-2) 

Each uses `Count(organization.OrganizationMemberList.Contains)` which has O(N*M) complexity where N is the number of votes and M is the number of members. The `Contains` method performs linear search: [4](#0-3) 

This expensive computation is triggered in two critical paths:

**Path 1: Release() method** - Called by proposer to execute approved proposals: [5](#0-4) 

**Path 2: GetProposal() view method** - Called by anyone to query proposal status: [6](#0-5) 

The root cause is the absence of maximum member list size validation. The validation only checks for non-empty and no duplicates: [7](#0-6) 

Anyone can create an organization with an arbitrarily large member list: [8](#0-7) 

### Impact Explanation

**Operational DoS of Governance**: Organizations with large member lists become non-functional. With M=10,000 members and N=100 votes per type (approval/rejection/abstention), the threshold check performs 3,000,000 Contains operations. This exceeds AElf's execution limits: [9](#0-8) 

**Specific Impacts**:
1. **Release DoS**: Legitimate proposers cannot release approved proposals because `IsReleaseThresholdReached` exceeds execution limits, causing transaction failure
2. **View Method DoS**: `GetProposal` becomes unusable, preventing UI/tooling from querying proposal status
3. **Resource Exhaustion**: Even if below hard limits, excessive computation degrades node performance

**Affected Parties**: Any users attempting to create multi-signature organizations with legitimate large membership (e.g., DAOs with hundreds of members) will unknowingly create broken organizations where governance cannot function.

### Likelihood Explanation

**Feasibility: High**
- **Reachable Entry Point**: `CreateOrganization` is public with no authorization checks
- **Attack Cost**: Minimal - only requires transaction fees to create organization with large member list
- **No Special Privileges**: Any user can execute the attack
- **Realistic Scenario**: Can occur unintentionally when organizations grow or intentionally by malicious actors

**Attack Complexity: Low**
1. Call `CreateOrganization` with `OrganizationMemberList` containing 10,000+ unique addresses
2. Create a proposal and have members vote
3. When anyone calls `Release()` or `GetProposal()`, execution fails or hangs

**Detection**: The issue may go unnoticed until organizations reach critical size, as smaller organizations function normally.

### Recommendation

**Immediate Fix**: Add maximum member list size validation in the `Validate` method:

```csharp
private bool Validate(Organization organization)
{
    const int MaxMemberCount = 100; // Or appropriate limit based on execution constraints
    
    var organizationMemberCount = organization.OrganizationMemberList.Count();
    
    if (organizationMemberCount > MaxMemberCount)
        return false;
        
    // ... existing validation logic
}
```

**Optimal Fix**: Replace linear search with hash-based lookup:
- Use `HashSet<Address>` for member list storage
- Change `Contains` to O(1) lookup
- Update validation to check for duplicates using hash set construction

**Additional Safeguards**:
1. Add similar limits to `ProposerWhiteList` which has the same pattern
2. Consider caching member set as hash set when organization is created/modified
3. Add integration tests with large member lists (1000+ members) to verify execution limits
4. Document maximum recommended organization size in API documentation

### Proof of Concept

**Initial State**: Empty Association contract deployed

**Attack Sequence**:
1. Attacker prepares 10,000 unique addresses
2. Calls `CreateOrganization` with:
   - `organization_member_list` containing all 10,000 addresses
   - Valid `proposal_release_threshold` (e.g., MinimalApprovalThreshold=5000)
   - Valid `proposer_white_list`
3. Organization is successfully created (passes validation)
4. Proposer creates a proposal
5. 100 members vote (approve/reject/abstain)
6. Proposer calls `Release(proposalId)`

**Expected Result**: Proposal is released if threshold met

**Actual Result**: Transaction fails with execution limit exceeded because:
- 100 approvals × 10,000 members = 1,000,000 iterations in `CheckEnoughVoteAndApprovals`
- 100 rejections × 10,000 members = 1,000,000 iterations in `IsProposalRejected`  
- 100 abstentions × 10,000 members = 1,000,000 iterations in `IsProposalAbstained`
- Total: 3,000,000 operations >> 15,000 ExecutionCallThreshold

**Alternative Impact**: Even calling `GetProposal(proposalId)` (a view method) triggers the same expensive computation, making proposal status queries fail.

**Success Condition**: Organization governance is permanently broken - no proposals can be released regardless of approval status.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L18-42)
```csharp
    public override ProposalOutput GetProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        if (proposal == null) return new ProposalOutput();

        var organization = State.Organizations[proposal.OrganizationAddress];
        var readyToRelease = IsReleaseThresholdReached(proposal, organization);

        return new ProposalOutput
        {
            ProposalId = proposalId,
            ContractMethodName = proposal.ContractMethodName,
            ExpiredTime = proposal.ExpiredTime,
            OrganizationAddress = proposal.OrganizationAddress,
            Params = proposal.Params,
            Proposer = proposal.Proposer,
            ToAddress = proposal.ToAddress,
            ToBeReleased = readyToRelease,
            ApprovalCount = proposal.Approvals.Count,
            RejectionCount = proposal.Rejections.Count,
            AbstentionCount = proposal.Abstentions.Count,
            Title = proposal.Title,
            Description = proposal.Description
        };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-7)
```csharp
    public const int ExecutionCallThreshold = 15000;

    public const int ExecutionBranchThreshold = 15000;
```
