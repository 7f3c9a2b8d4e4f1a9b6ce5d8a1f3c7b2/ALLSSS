### Title
NextTerm Consensus Transaction Bypasses Critical Field Validation Allowing Consensus State Corruption

### Summary
The `NextTerm` consensus behavior lacks validation for critical Round fields including `ConfirmedIrreversibleBlockHeight`, `ConfirmedIrreversibleBlockRoundNumber`, and `IsMinerListJustChanged`. A malicious miner can craft a `NextTermInput` transaction with manipulated values for these unvalidated fields while maintaining valid consensus header data. The post-execution validation only checks a subset of fields through hash comparison, allowing corrupted consensus state to persist on-chain and breaking LIB (Last Irreversible Block) finality guarantees.

### Finding Description

The vulnerability exists in the validation pipeline for `NextTerm` consensus transactions:

**Missing Pre-Execution Validation:**
The `ValidateBeforeExecution` method only adds `RoundTerminateValidationProvider` for NextTerm behavior, unlike UpdateValue which includes `LibInformationValidationProvider`. [1](#0-0) 

This means LIB-related fields are never validated before execution for NextTerm transactions. [2](#0-1) 

**Incomplete Post-Execution Validation:**
The `GetCheckableRound` method used for hash comparison only includes four fields: `RoundNumber`, `TermNumber`, `RealTimeMinersInformation`, and `BlockchainAge`. [3](#0-2) 

The Round protobuf message contains 10 fields total, meaning 6 critical fields are excluded from validation. [4](#0-3) 

**Vulnerable Execution Path:**
When `ProcessNextTerm` executes, it converts the `NextTermInput` to a Round object and stores it directly to state without validating the excluded fields. [5](#0-4) 

The Round is then persisted via `AddRoundInformation` which stores the complete object including all unvalidated fields. [6](#0-5) 

**Post-Execution Check Bypass:**
The `ValidateConsensusAfterExecution` compares header Round hash with state Round hash, but this comparison excludes the manipulated fields. [7](#0-6) 

### Impact Explanation

**Consensus Integrity Compromise:**
- **ConfirmedIrreversibleBlockHeight Manipulation**: An attacker can set this to a lower value than the actual LIB, causing the chain to falsely report finality status. This field is used by `IrreversibleBlockFoundLogEventProcessor` to update the chain's irreversible block state, directly breaking finality guarantees. [8](#0-7) 

- **IsMinerListJustChanged Manipulation**: This boolean controls whether secret sharing information events are fired. A manipulated value can skip critical `SecretSharingInformation` events or cause them to fire incorrectly, disrupting the random number generation mechanism. [9](#0-8) 

- **Protocol-Wide Impact**: The corrupted Round state affects all subsequent consensus operations as miners rely on stored Round information for decision-making, block validation, and LIB calculations.

**Severity Justification:**
This is HIGH severity because it violates the critical invariant "Correct round transitions and time-slot validation, miner schedule integrity, LIB height rules" and allows a single malicious miner to corrupt consensus state permanently.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an active miner with block production rights
- Requires ability to craft custom transactions (readily available to any miner running custom node software)
- No special cryptographic capabilities needed beyond normal mining operations

**Attack Complexity:**
The attack is straightforward:
1. Use `GetConsensusExtraData` to generate valid consensus header information [10](#0-9) 
2. Manually construct `NextTermInput` using the `Create` method but with modified excluded fields [11](#0-10) 
3. Create and sign transaction calling `NextTerm` with malicious input
4. Include transaction in block with valid consensus header
5. Block passes all validations despite corrupted state

**Feasibility Conditions:**
- Attacker timing must coincide with term transition (occurs periodically based on `PeriodSeconds` configuration)
- No economic cost beyond normal block production
- Detection is difficult as the block appears valid to all validation checks
- Exploit succeeds with 100% probability once conditions are met

**Probability Assessment:**
MEDIUM-HIGH likelihood. While requiring miner status, the attack is deterministic, has no detection mechanism, and term transitions occur regularly in the consensus protocol.

### Recommendation

**Immediate Fix:**
Add `LibInformationValidationProvider` to the NextTerm validation pipeline:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

**Enhanced Validation:**
Extend `GetCheckableRound` to include all critical consensus fields or create a separate validation method for NextTerm that checks:
- `ConfirmedIrreversibleBlockHeight` does not decrease
- `ConfirmedIrreversibleBlockRoundNumber` does not decrease  
- `IsMinerListJustChanged` matches actual miner list change status
- `RoundIdForValidation` is correctly calculated
- `MainChainMinersRoundNumber` is valid (for side chains)

**Additional Safeguards:**
In `ProcessNextTerm`, add explicit assertions before storing the Round:
```csharp
Assert(nextRound.ConfirmedIrreversibleBlockHeight >= currentRound.ConfirmedIrreversibleBlockHeight,
    "LIB height cannot decrease");
```

**Test Cases:**
1. Attempt NextTerm with decreased `ConfirmedIrreversibleBlockHeight` - should fail
2. Attempt NextTerm with manipulated `IsMinerListJustChanged` - should fail
3. Verify UpdateValue behavior with same manipulations still passes (to ensure no regression)

### Proof of Concept

**Initial State:**
- Chain operating normally with current term N
- Current LIB at height H with round R
- Malicious miner M has block production rights
- Term transition conditions met (time elapsed >= PeriodSeconds)

**Attack Steps:**

1. **Generate Valid Header:**
   - Malicious miner calls contract method to get consensus trigger for NextTerm behavior
   - Contract returns valid `AElfConsensusHeaderInformation` with correct Round data including `ConfirmedIrreversibleBlockHeight = H`

2. **Craft Malicious Transaction:**
   - Create `NextTermInput` with:
     - Valid: `RoundNumber`, `TermNumber`, `RealTimeMinersInformation`, `BlockchainAge`
     - Malicious: `ConfirmedIrreversibleBlockHeight = H - 100` (or any value < H)
   - Serialize to protobuf bytes
   - Create transaction calling `NextTerm` method with malicious input
   - Sign transaction with miner's key

3. **Produce Block:**
   - Include valid consensus header (passes `ValidateConsensusBeforeExecution`)
   - Include malicious NextTerm transaction
   - Sign block and broadcast

4. **Validation Bypass:**
   - Pre-execution: Only `RoundTerminateValidationProvider` runs - checks term/round increment only
   - Execution: `ProcessNextTerm` stores malicious Round to `State.Rounds[newRoundNumber]`
   - Post-execution: Hash comparison only checks 4 fields, excludes manipulated LIB value
   - Block accepted

**Expected vs Actual Result:**
- **Expected:** Block rejected due to invalid LIB height
- **Actual:** Block accepted, consensus state now shows incorrect `ConfirmedIrreversibleBlockHeight = H - 100`

**Success Condition:**
Query `GetCurrentRoundInformation` after block execution - the returned Round has corrupted `ConfirmedIrreversibleBlockHeight` value that differs from the actual chain's LIB, proving consensus state corruption.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** protobuf/aedpos_contract.proto (L243-264)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producersâ€™ expecting time (second).
    int64 round_id_for_validation = 10;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-115)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L244-245)
```csharp
        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```
