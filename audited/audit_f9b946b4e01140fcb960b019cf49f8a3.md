### Title
Secret Sharing Revealed In Values Discarded and Recomputed on Every Call, Wasting Gas

### Summary
The `RevealSharedInValues()` function performs expensive cryptographic secret sharing reconstruction to reveal miners' previous in values, but these revealed values are written to a non-persisted in-memory copy of the current round and are completely lost. Additionally, each call to `GetConsensusExtraData()` or `GenerateConsensusTransactions()` redoes the entire computation, wasting gas without achieving any useful result.

### Finding Description

The vulnerability exists in the NextRound consensus behavior flow: [1](#0-0) 

At line 176, `GenerateNextRoundInformation` creates a new `nextRound` object. At line 189, `RevealSharedInValues(currentRound, pubkey)` is called to reconstruct miners' in values via secret sharing: [2](#0-1) 

The function performs expensive cryptographic operations (line 50: `SecretSharingHelper.DecodeSecret`) and writes the revealed in values to `currentRound` at line 52. However, `currentRound` is retrieved from state as a deserialized copy: [3](#0-2) 

The modifications to `currentRound` are never persisted to state, and `GetConsensusExtraDataForNextRound` returns only `nextRound` (which doesn't contain the revealed in values). The `nextRound` object is generated before the call to `RevealSharedInValues` and doesn't copy `PreviousInValue` fields: [4](#0-3) 

Furthermore, these public methods can be called multiple times for the same round: [5](#0-4) 

Each invocation retrieves a fresh copy of `currentRound` from state and recomputes the secret sharing reconstruction from scratch.

### Impact Explanation

**Consensus Integrity Impact**: The secret sharing mechanism is designed to prevent miners from withholding their in values, which are critical for consensus randomness generation. When the revealed in values are discarded, the anti-withholding protection is completely broken. Miners who don't reveal their in values cannot be held accountable through secret sharing reconstruction.

**Gas Waste Impact**: Every NextRound transition wastes gas performing secret sharing reconstruction (involving multiple cryptographic operations across all miners' secret pieces) that produces no useful result. The computation at line 40-50 in SecretSharing iterates through all miners, reconstructs orders, and decodes secret shares - all of which is immediately discarded.

**Repeated Call Impact**: Each call to `GetConsensusExtraData` or `GenerateConsensusTransactions` for the same round triggers the full secret sharing reconstruction again, multiplying the gas waste. This can occur during normal consensus operation retries or when miners request consensus data multiple times.

### Likelihood Explanation

**Reachability**: The issue is triggered on every NextRound consensus transition through the public `GetConsensusExtraData` and `GenerateConsensusTransactions` methods, which are called by miners during normal block production flow.

**Frequency**: NextRound transitions occur regularly (every round) when miners produce blocks. If secret sharing is enabled, every such transition wastes gas on useless computation.

**Multiple Calls**: The consensus service or miners may legitimately call these methods multiple times for various reasons (retries, different code paths, etc.), causing redundant recomputation. There is no protection preventing multiple calls for the same round.

**Preconditions**: Only requires secret sharing to be enabled (checked via configuration) and normal consensus operation. No special attacker capabilities needed - this is broken by design.

### Recommendation

**Immediate Fix**: Modify `GetConsensusExtraDataForNextRound` to either:

1. Call `RevealSharedInValues(nextRound, pubkey)` instead of `RevealSharedInValues(currentRound, pubkey)` so revealed in values are written to the round being returned, OR

2. Copy the revealed `PreviousInValue` fields from the modified `currentRound` to `nextRound` after calling `RevealSharedInValues`, OR  

3. Persist the modified `currentRound` back to state before generating `nextRound`, OR

4. Remove the call entirely if revealed in values should only come from `triggerInformation.RevealedInValues` as in UpdateValue behavior

**Additional Protection**: Add a flag or cache to prevent redundant secret sharing reconstruction when the same round is queried multiple times.

**Test Cases**: Add tests verifying that revealed in values from secret sharing reconstruction are actually present in the persisted round state and are used for subsequent signature calculations.

### Proof of Concept

**Setup**: Configure a test chain with secret sharing enabled and multiple miners with encrypted/decrypted secret pieces accumulated in previous rounds.

**Attack Steps**:
1. Miner reaches NextRound consensus behavior
2. Call `GetConsensusExtraData` with NextRound trigger information
3. Observe that `RevealSharedInValues` executes secret sharing reconstruction (gas consumed)
4. Check the returned round data - revealed `PreviousInValue` fields are absent
5. Query the persisted round state - confirmed that no `PreviousInValue` fields were updated
6. Call `GetConsensusExtraData` again for the same round
7. Observe that the entire secret sharing reconstruction runs again (duplicate gas cost)

**Expected**: Revealed in values should be persisted to state after first call, subsequent calls should reuse them.

**Actual**: Revealed in values are computed but discarded on each call, wasting gas on redundant cryptographic operations without achieving the security goal of the secret sharing mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-75)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }

    public override TransactionList GenerateConsensusTransactions(BytesValue input)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);
        // Some basic checks.
        Assert(triggerInformation.Pubkey.Any(),
            "Data to request consensus information should contain pubkey.");

        var pubkey = triggerInformation.Pubkey;
        var randomNumber = triggerInformation.RandomNumber;
        var consensusInformation = new AElfConsensusHeaderInformation();
        consensusInformation.MergeFrom(GetConsensusBlockExtraData(input, true).Value);
        var transactionList = GenerateTransactionListByExtraData(consensusInformation, pubkey, randomNumber);
        return transactionList;
    }
```
