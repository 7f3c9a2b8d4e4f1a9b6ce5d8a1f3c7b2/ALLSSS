# Audit Report

## Title
Solitary Miner Detection Logic Error Causes False Positive and Potential Chain Halt

## Summary
The `SolitaryMinerDetection()` function contains a critical logic error that incorrectly identifies a legitimate miner as solitary when a new consensus round begins. This occurs because the function checks if `GetMinedMiners()` returns an empty list and treats this as evidence of solitary mining, but at the start of every new round all miners have `SupposedOrderOfNextRound = 0` by default, causing the method to always return empty. If a miner was the only one successfully mining during the previous 2 rounds due to network issues, they will be blocked from mining at the start of the new round, potentially causing complete chain halt.

## Finding Description

The vulnerability exists in the `SolitaryMinerDetection()` private method which is called from `GetConsensusCommand()` before any consensus behavior is determined. [1](#0-0) 

The root cause is at line 75 where `isAlone` is set to true when the count of miners returned by `GetMinedMiners()` is zero. [2](#0-1) 

The `GetMinedMiners()` method filters miners based on whether their `SupposedOrderOfNextRound` field is non-zero. [3](#0-2) 

When a new round is created via `GenerateNextRoundInformation()`, new `MinerInRound` objects are instantiated without explicitly setting the `SupposedOrderOfNextRound` field. [4](#0-3) 

Since `SupposedOrderOfNextRound` is defined as `int32` in the protobuf definition, it defaults to 0 when not explicitly set. [5](#0-4) 

The `SupposedOrderOfNextRound` field is only set to a non-zero value when a miner produces a block and the value is processed through `ProcessUpdateValue()`. [6](#0-5) 

The value is calculated during block production via `ApplyNormalConsensusData()` using the miner's signature hash. [7](#0-6) 

**Why existing protections fail:**

The logic error treats two fundamentally different states identically:
1. "No one has mined yet in the current round" (empty list at round start)
2. "Only this miner is actively mining" (legitimate solitary mining detection)

At the start of any new round, before any miner produces a normal block, `GetMinedMiners()` will always return an empty list because all `SupposedOrderOfNextRound` values are 0. The subsequent checks at lines 78-83 and 86-92 validate that only this specific miner mined in the previous 2 rounds, but this doesn't confirm the miner is currently mining alone—it only confirms past behavior during a network partition period. [8](#0-7) 

## Impact Explanation

**Harm:** Complete consensus halt (DoS) preventing any block production across the entire blockchain network.

**Scenario:**
1. During rounds N-2 and N-1, a network partition or infrastructure failure causes only MinerA to successfully produce blocks while other miners are offline or partitioned
2. MinerA produces a NextRound block to transition to round N
3. The new round N is created via `GenerateNextRoundInformation()` with all miners having `SupposedOrderOfNextRound = 0`
4. MinerA (the only operational miner) attempts to produce the first normal block in round N
5. When `GetConsensusCommand()` is called, `SolitaryMinerDetection()` checks the current round (N) and finds `GetMinedMiners()` returns empty (because no one has mined yet)
6. The function incorrectly concludes MinerA is mining alone and returns true, causing `GetConsensusCommand()` to return `InvalidConsensusCommand`
7. MinerA is now blocked from producing blocks
8. If the network partition persists and other miners remain offline, no miner can produce blocks
9. The chain halts completely until manual intervention or network recovery

**Who is affected:** The entire blockchain network—all users, dApps, validators, and any services depending on the chain lose access to a functioning blockchain. Transactions cannot be processed, state cannot be updated, and the network becomes completely unavailable.

**Severity justification:** HIGH - This is a critical operational DoS vulnerability affecting consensus availability. While it requires specific preconditions (sustained network partition affecting all but one miner for 2+ rounds), such conditions are realistic in distributed systems. The impact is catastrophic—complete chain halt with no automatic recovery mechanism. The vulnerability breaks the fundamental security guarantee that legitimate miners with valid credentials should be able to produce blocks when it's their turn.

## Likelihood Explanation

**Attacker capabilities:** No malicious attacker is required—this vulnerability triggers automatically through natural network conditions and operational failures.

**Preconditions:**
- Multi-miner network with more than 2 miners (enforced by check at line 70)
- Chain must be past round 3 (enforced by check at line 70) [9](#0-8) 
- Network partition, infrastructure failure, or synchronized miner downtime affecting all but one miner for 2 consecutive rounds
- The operational miner continues to be the only one available at the start of the next round

**Execution practicality:** The vulnerability triggers automatically through the normal consensus flow when a miner requests a consensus command via the public `GetConsensusCommand()` method. [10](#0-9) 

There is no special action required—the solitary detection runs before any block is produced in the new round as part of the standard consensus command generation process.

**Feasibility conditions:** Network partitions, infrastructure failures, and coordinated miner downtime are documented occurrences in distributed blockchain systems. While a partition affecting all but one miner for 2+ consecutive rounds is not frequent, it is realistic enough to represent a genuine operational risk. The probability is MEDIUM—not common but plausible enough to warrant serious concern given the catastrophic impact.

## Recommendation

The fix should distinguish between "no one has mined yet in the current round" and "this miner is the only one actively mining". Consider modifying the `SolitaryMinerDetection()` logic to:

1. **Skip detection for brand new rounds:** Check if the current round has just started (e.g., by verifying if any miner has produced a block in the current round before applying the solitary detection logic)

2. **Alternative approach - check actual mining activity:** Instead of relying solely on `GetMinedMiners().Count == 0`, verify that other miners have attempted but failed to produce blocks, rather than simply not having produced any yet

Suggested code modification:

```csharp
private bool SolitaryMinerDetection(Round currentRound, string pubkey)
{
    var isAlone = false;
    if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
    {
        var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
        
        // FIX: Only set isAlone if there are miners who have mined in current round
        // AND only this miner is among them. If count is 0, skip the check entirely
        // as the round just started and we can't determine solitary mining yet.
        if (minedMinersOfCurrentRound.Count > 0)
        {
            isAlone = minedMinersOfCurrentRound.Count == 1 && 
                      minedMinersOfCurrentRound.Select(m => m.Pubkey).Contains(pubkey);
        }
        
        // Rest of the logic remains the same
        if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
        {
            // ... existing checks
        }
    }
    return isAlone;
}
```

This ensures the detection only triggers when there is actual evidence of solitary mining (one miner has mined while others haven't), rather than when no one has mined yet.

## Proof of Concept

The vulnerability can be demonstrated with the following scenario:

```csharp
// Simplified test demonstrating the logic error
[Fact]
public void SolitaryMinerDetection_FalsePositive_AtRoundStart()
{
    // Setup: Create a new round N where no one has mined yet
    var round = new Round
    {
        RoundNumber = 4,
        RealTimeMinersInformation = 
        {
            ["MinerA"] = new MinerInRound { Pubkey = "MinerA", Order = 1 },
            ["MinerB"] = new MinerInRound { Pubkey = "MinerB", Order = 2 },
            ["MinerC"] = new MinerInRound { Pubkey = "MinerC", Order = 3 }
        }
    };
    
    // All SupposedOrderOfNextRound default to 0 (no one has mined yet)
    
    // Act: Call GetMinedMiners() at start of round
    var minedMiners = round.GetMinedMiners();
    
    // Assert: Returns empty list (FALSE POSITIVE TRIGGER)
    Assert.Empty(minedMiners); // Count == 0
    
    // This triggers isAlone = true in SolitaryMinerDetection
    // even though multiple miners exist and are ready to mine
    
    // If MinerA was the only one mining in previous 2 rounds:
    // - SolitaryMinerDetection returns true
    // - MinerA gets blocked with InvalidConsensusCommand
    // - Chain halts if other miners remain unavailable
}
```

The test demonstrates that `GetMinedMiners()` returns an empty list at the start of a new round, which causes the false positive in the solitary miner detection logic.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L20-24)
```csharp
    private ConsensusCommand GetConsensusCommand(AElfConsensusBehaviour behaviour, Round currentRound,
        string pubkey, Timestamp currentBlockTime = null)
    {
        if (SolitaryMinerDetection(currentRound, pubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L70-70)
```csharp
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L74-75)
```csharp
            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L78-92)
```csharp
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }

            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** protobuf/aedpos_contract.proto (L205-206)
```text
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 6;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-247)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-24)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```
