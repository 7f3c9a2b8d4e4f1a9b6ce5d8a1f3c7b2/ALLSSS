### Title
Initial Miner Pubkey Collision Allows Voting System DOS via Incorrect RemoveOption/AddOption Invocation

### Summary
The `PerformReplacement()` function only validates whether the OLD pubkey is an initial miner before calling `RemoveOption`/`AddOption`, but fails to check if the NEW pubkey is already an existing initial miner. An attacker controlling any candidate can exploit this by replacing their candidate with an existing initial miner's pubkey, causing the initial miner to incorrectly receive a voting option and enter an inconsistent state where it exists in both `InitialMiners` and `Candidates` lists. Subsequent replacements of this corrupted initial miner will skip voting option updates, permanently breaking the voting system's integrity.

### Finding Description

The vulnerability exists in the `PerformReplacement()` function's conditional check that determines whether to update voting options. [1](#0-0) 

The check at line 306 only validates if `oldPubkey` is in `InitialMiners`, but does not verify if `newPubkey` is already an existing initial miner. This allows an attacker to create a pubkey collision scenario.

The attack exploits the replacement flow in `ReplaceCandidatePubkey()`: [2](#0-1) 

The validation checks only verify that `newPubkey` is not already in the `Candidates` list, but critically miss checking against `InitialMiners`: [3](#0-2) 

When a regular candidate (not in `InitialMiners`) is replaced with a pubkey that IS in `InitialMiners`, the check at line 306 evaluates to true (since the old candidate is not an initial miner), causing `RemoveOption` and `AddOption` to be invoked for the initial miner's pubkey. This violates the core invariant that initial miners should never have voting options.

The code then updates both `Candidates` and `InitialMiners` lists: [4](#0-3) 

However, since the old pubkey is not in `InitialMiners`, this block is skipped, leaving the initial miner in `InitialMiners` while also being added to `Candidates` at line 195.

Initial miners are explicitly prevented from announcing election to maintain this separation: [5](#0-4) 

When the corrupted initial miner is later replaced, the check correctly identifies it as an initial miner and skips `RemoveOption`/`AddOption`, but the voting option from the first replacement remains orphaned, breaking the voting system.

### Impact Explanation

**Operational Impact - Voting System DOS:**
1. **Voting Integrity Corruption**: The replacement candidate cannot receive votes despite being in the `Candidates` list because no voting option exists for it. Users attempting to vote for this candidate will fail.

2. **Phantom Voting Options**: The replaced initial miner retains its voting option even after being removed from `Candidates`, allowing votes to accumulate for non-existent candidates, corrupting election results. [6](#0-5) 

3. **Election Result Manipulation**: The `GetVictories()` function relies on `CandidateVotes` and voting results to select miners. Phantom votes for replaced initial miners could influence miner selection, while legitimate candidates cannot receive votes.

4. **Multi-Target Attack**: An attacker can repeat this attack for multiple initial miners, systematically breaking the voting system for each critical miner position.

The Vote contract enforces that options must exist before removal: [7](#0-6) 

This means the broken state cannot be easily recovered without contract upgrades.

**Severity Justification**: High - This breaks core consensus mechanism (miner election) integrity without requiring privileged access, affecting all network participants who rely on fair elections.

### Likelihood Explanation

**Reachable Entry Point**: The attack starts from `ReplaceCandidatePubkey()`, a public method callable by any candidate admin. [8](#0-7) 

**Attacker Capabilities Required**:
1. Announce election to create a candidate (requires locking tokens defined in the contract)
2. Set self as admin (automatic during announcement)
3. Know the pubkey of any initial miner (publicly visible in `InitialMiners` state)

Initial miners are stored in a publicly readable state: [9](#0-8) 

**Execution Practicality**: The attack is straightforward:
- Cost: Only the candidate announcement lock amount (standard for any candidate)
- Complexity: Two simple transaction calls
- Detection: Difficult to detect before damage occurs; state inconsistency only visible after the fact

**Economic Rationality**: The attack cost (candidate lock amount) is minimal compared to the impact of disrupting the entire miner election system. A malicious actor or competitor could execute this to manipulate election results or cause protocol instability.

**Feasibility**: All preconditions are easily satisfied in normal network operation. No special timing, state conditions, or privileged access required.

### Recommendation

Add an explicit check in `ReplaceCandidatePubkey()` to prevent using an existing initial miner's pubkey as the replacement target:

```csharp
// After line 191, add:
var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));
Assert(!State.InitialMiners.Value.Value.Contains(newPubkeyBytes), 
    "Cannot replace with an existing initial miner's pubkey.");
```

**Invariant to Enforce**: A pubkey cannot simultaneously exist in both `InitialMiners` and `Candidates` lists. These should be mutually exclusive sets.

**Test Cases**:
1. Attempt to replace a regular candidate with an existing initial miner's pubkey → should revert
2. Attempt to replace an initial miner with another existing initial miner's pubkey → should revert  
3. Verify that after any replacement, the target pubkey exists in at most one of {`InitialMiners`, `Candidates`}
4. Verify voting options always match the `Candidates` list (excluding initial miners)

### Proof of Concept

**Initial State**:
- Initial miner IM with pubkey "0xABC..." exists in `State.InitialMiners`
- IM is not in `State.Candidates`
- IM has no voting option
- Attacker controls address A with sufficient tokens

**Step 1**: Attacker announces election
```
Transaction: AnnounceElection(admin: A)
Result: 
- Candidate C (attacker's pubkey) added to Candidates
- Voting option created for C
- A set as admin of C
```

**Step 2**: Attacker replaces their candidate with initial miner's pubkey
```
Transaction: ReplaceCandidatePubkey(oldPubkey: C, newPubkey: IM)
Result:
- Line 306 check: C not in InitialMiners → TRUE
- RemoveOption(C) called
- AddOption(IM) called ← IM now has voting option (INCORRECT)
- IM added to Candidates (line 195)
- IM remains in InitialMiners (line 221 check fails)
- State: IM in BOTH InitialMiners and Candidates (INCONSISTENT)
```

**Step 3**: Attacker replaces the corrupted initial miner
```
Transaction: ReplaceCandidatePubkey(oldPubkey: IM, newPubkey: K)
Result:
- Line 306 check: IM in InitialMiners → FALSE
- RemoveOption/AddOption NOT called
- IM removed from Candidates and InitialMiners
- K added to Candidates and InitialMiners
- Voting option for IM remains orphaned
- K has no voting option despite being in Candidates
```

**Final State (BROKEN)**:
- IM has voting option but is not in Candidates or InitialMiners
- K is in Candidates and InitialMiners but has no voting option
- Users cannot vote for K (option doesn't exist)
- Votes for IM accumulate for non-existent candidate
- Election integrity compromised

**Success Condition**: Query voting options shows IM but not K; query Candidates shows K but not IM; voting system state is inconsistent and DOS'd.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L34-38)
```csharp
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L186-197)
```csharp
        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L304-318)
```csharp
        var oldPubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(oldPubkey));
        // Notify Vote Contract to replace option if this is not the initial miner case.
        if (!State.InitialMiners.Value.Value.Contains(oldPubkeyByteString))
        {
            State.VoteContract.RemoveOption.Send(new RemoveOptionInput
            {
                VotingItemId = State.MinerElectionVotingItemId.Value,
                Option = oldPubkey
            });
            State.VoteContract.AddOption.Send(new AddOptionInput
            {
                VotingItemId = State.MinerElectionVotingItemId.Value,
                Option = newPubkey
            });
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L149-150)
```csharp
        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L303-312)
```csharp
    public override Empty RemoveOption(RemoveOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
        votingItem.Options.Remove(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```
