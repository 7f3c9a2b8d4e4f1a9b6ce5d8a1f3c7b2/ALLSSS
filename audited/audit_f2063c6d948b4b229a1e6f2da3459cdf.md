### Title
Incorrect Term Number Calculation in Side Chain Round Generation Causes Consensus Divergence

### Summary
The `GenerateFirstRoundOfNewTerm()` function has two overloads that produce inconsistent results when the first overload is called with only 3 arguments. Side chains incorrectly invoke the first overload without passing the `currentTermNumber` parameter, causing it to default to 0 and resulting in term number always being reset to 1 instead of correctly incrementing. This breaks term sequencing and causes consensus divergence when the Round object is serialized into block headers.

### Finding Description
The vulnerability exists in how the two overloads of `GenerateFirstRoundOfNewTerm()` are invoked across the codebase. [1](#0-0) 

The first overload has a default parameter `currentTermNumber = 0`, and sets `round.TermNumber = currentTermNumber.Add(1)` at line 41, which equals 1 when the parameter is not provided. [2](#0-1) 

The second overload correctly passes both `currentRound.RoundNumber` and `currentRound.TermNumber` to the first overload, and additionally sets the LIB-related fields.

The critical bug occurs in `GenerateNextRoundInformation()` when side chains detect main chain miner list changes: [3](#0-2) 

Line 290-291 calls the first overload with only 3 arguments, omitting `currentTermNumber`. This causes the term number to always be set to 1 regardless of the actual current term.

The Round object is then serialized into block headers: [4](#0-3) [5](#0-4) 

The Round message includes the term_number field which is part of the consensus data: [6](#0-5) [7](#0-6) 

### Impact Explanation
**Consensus Integrity Violation:** Side chains will generate Round objects with incorrect term numbers (always 1) when the main chain miner list changes, breaking the term number sequence. For example, if a side chain is at term 5, it should transition to term 6, but instead resets to term 1.

**Serialization Divergence:** The incorrect term_number in the Round object gets serialized into the block's consensus extra data via `AElfConsensusHeaderInformation`. Different term numbers produce different serialized bytes, leading to different block hashes.

**State Corruption:** The incorrectly generated Round may be persisted to state, causing subsequent consensus logic that relies on correct term sequencing to fail. This affects term-based validation, reward distribution, and miner election cycles.

**Affected Parties:** All side chain nodes are affected when main chain miner list updates occur. The severity is Medium-to-High because it disrupts side chain consensus integrity whenever main chain elections complete.

### Likelihood Explanation
**Attack Complexity:** No attacker action is required. This is a natural execution bug that triggers automatically when specific conditions are met.

**Trigger Conditions:** The vulnerability activates when:
1. The node is a side chain (`!IsMainChain`)
2. The main chain miner list has changed (`IsMainChainMinerListChanged(currentRound)` returns true) [8](#0-7) 

**Frequency:** This occurs periodically when main chain elections complete and the miner list changes, which happens every term (typically days to weeks based on governance settings).

**Detection:** The bug executes deterministically on all side chain nodes simultaneously when the condition is met, making it highly likely to occur in production.

**Feasibility:** The execution path is straightforward and requires no special setup, transaction crafting, or timing attacks. It's a guaranteed execution whenever the main chain updates its miner list.

### Recommendation
**Immediate Fix:** Modify line 290-291 in `AEDPoSContract_ViewMethods.cs` to pass the fourth parameter explicitly:

```csharp
nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
    currentRound.GetMiningInterval(), currentBlockTime, 
    currentRound.RoundNumber, currentRound.TermNumber);
```

Alternatively, use the second overload which correctly handles all parameters:

```csharp
var tempRound = new Round 
{ 
    RoundNumber = currentRound.RoundNumber, 
    TermNumber = currentRound.TermNumber,
    ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight,
    ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber
};
nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
    currentRound.GetMiningInterval(), currentBlockTime, tempRound);
```

**Invariant Checks:** Add validation that term numbers monotonically increase:
```csharp
Assert(nextRound.TermNumber > currentRound.TermNumber || 
       nextRound.TermNumber == currentRound.TermNumber, 
       "Term number must not decrease");
```

**Test Cases:** Add unit tests covering:
1. Side chain round generation when main chain miner list changes
2. Verification that term numbers correctly increment across term transitions
3. Consistency tests comparing both overload invocations with equivalent parameters

### Proof of Concept
**Initial State:**
- Side chain deployed and running
- Current term number: 5
- Current round number: 100
- Main chain has updated its miner list

**Execution Steps:**
1. Side chain node enters block production for the next round
2. `GetConsensusBlockExtraData()` is called with `AElfConsensusBehaviour.NextRound`
3. This invokes `GetConsensusExtraDataForNextRound()` which calls `GenerateNextRoundInformation()`
4. Condition `!IsMainChain && IsMainChainMinerListChanged(currentRound)` evaluates to true
5. Line 290-291 executes: `GenerateFirstRoundOfNewTerm(miningInterval, currentBlockTime, 100)` (only 3 args)
6. Function uses default `currentTermNumber = 0`, calculates `TermNumber = 0 + 1 = 1`
7. Resulting Round has `RoundNumber = 101`, `TermNumber = 1` (incorrect, should be 6)

**Expected Result:**
- Round with `RoundNumber = 101`, `TermNumber = 6`

**Actual Result:**
- Round with `RoundNumber = 101`, `TermNumber = 1`

**Success Condition:**
Compare the serialized `AElfConsensusHeaderInformation` from the buggy path versus a correctly generated Round with term 6. The protobuf serialization will differ in the `term_number` field, demonstrating the inconsistency.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-45)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L47-54)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval, Timestamp currentBlockTime, Round currentRound)
    {
        var round = GenerateFirstRoundOfNewTerm(miningInterval, currentBlockTime, currentRound.RoundNumber,
            currentRound.TermNumber);
        round.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        round.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-294)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L349-354)
```csharp
    private bool IsMainChainMinerListChanged(Round currentRound)
    {
        return State.MainChainCurrentMinerList.Value.Pubkeys.Any() &&
               GetMinerListHash(currentRound.RealTimeMinersInformation.Keys) !=
               GetMinerListHash(State.MainChainCurrentMinerList.Value.Pubkeys.Select(p => p.ToHex()));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L13-52)
```csharp
    private BytesValue GetConsensusBlockExtraData(BytesValue input, bool isGeneratingTransactions = false)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);

        Assert(triggerInformation.Pubkey.Any(), "Invalid pubkey.");

        TryToGetCurrentRoundInformation(out var currentRound);

        var publicKeyBytes = triggerInformation.Pubkey;
        var pubkey = publicKeyBytes.ToHex();

        var information = new AElfConsensusHeaderInformation();
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
        }

        if (!isGeneratingTransactions) information.Round.DeleteSecretSharingInformation();

        return information.ToBytesValue();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** protobuf/aedpos_contract.proto (L243-264)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producersâ€™ expecting time (second).
    int64 round_id_for_validation = 10;
}
```

**File:** protobuf/aedpos_contract.proto (L303-310)
```text
message AElfConsensusHeaderInformation {
    // The sender public key.
    bytes sender_pubkey = 1;
    // The round information.
    Round round = 2;
    // The behaviour of consensus.
    AElfConsensusBehaviour behaviour = 3;
}
```
