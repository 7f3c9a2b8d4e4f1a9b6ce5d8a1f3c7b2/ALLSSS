### Title
Unauthorized Round Termination Due to Missing Extra Block Producer Validation in Side Chain Consensus

### Summary
The `SideChainConsensusBehaviourProvider` unconditionally returns `NextRound` behavior for any miner whose time slot has passed, without verifying if that miner is the designated extra block producer. The subsequent validation in `ValidateBeforeExecution` fails to enforce that only the extra block producer can execute `NextRound` transactions. This allows any miner in the current round to prematurely terminate the round, violating the fundamental consensus invariant that only one designated miner should produce the extra block that transitions to the next round.

### Finding Description

**Root Cause:**

The `SideChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` method unconditionally returns `NextRound`: [1](#0-0) 

This method is invoked by the base class `ConsensusBehaviourProviderBase.GetConsensusBehaviour()` when a miner's time slot has passed: [2](#0-1) 

The behavior is then used to generate a consensus command: [3](#0-2) 

When `NextRound` behavior is generated, it creates a `TerminateRoundCommandStrategy` without checking if the miner is the designated extra block producer: [4](#0-3) 

**Why Validation Fails:**

The consensus protocol designates exactly one miner per round as the extra block producer through `CalculateNextExtraBlockProducerOrder()`: [5](#0-4) 

The system has an `IsCurrentMiner()` method that correctly validates extra block producer authority: [6](#0-5) 

However, this check is **never invoked** during consensus validation. The `ValidateBeforeExecution` method for `NextRound` behavior only adds: [7](#0-6) 

The `MiningPermissionValidationProvider` only checks if the sender is in the miner list, not if they're the extra block producer: [8](#0-7) 

The `TimeSlotValidationProvider` validates the new round's time slots structure but doesn't check sender authority: [9](#0-8) 

The `ProcessNextRound` method's `PreCheck()` also only verifies miner list membership: [10](#0-9) 

### Impact Explanation

**Consensus Integrity Violation:**

This vulnerability breaks the fundamental AEDPoS consensus invariant that each round must be terminated by exactly one designated extra block producer. The protocol's design ensures ordered block production: all miners produce in their time slots, then the extra block producer terminates the round and confirms the next round's mining order.

**Concrete Harm:**

1. **Blockchain Forks**: Multiple miners can simultaneously produce valid `NextRound` blocks, causing competing chain branches
2. **Premature Round Transitions**: Non-designated miners can terminate rounds before the legitimate extra block producer, disrupting the intended mining sequence
3. **Consensus Protocol Breakdown**: The deterministic round progression mechanism becomes unpredictable when any miner can force transitions
4. **Network Instability**: Different nodes may accept different `NextRound` blocks, leading to temporary chain inconsistency

**Affected Parties:**

- All side chain participants experience consensus disruption
- Miners lose predictability in their scheduled time slots
- Applications relying on deterministic block times are impacted
- Cross-chain mechanisms depending on stable round progression may fail

**Severity Justification:**

HIGH severity due to:
- Direct violation of consensus protocol invariants (Critical Invariant #2: "Correct round transitions and miner schedule integrity")
- Enables any current miner to disrupt consensus flow
- No economic barriers to exploitation (mining is normal operation)
- Impact affects entire side chain network

### Likelihood Explanation

**Attacker Capabilities:**

The attacker only needs to be a current miner in the side chain. No special privileges, tokens, or governance authority required. The attack occurs naturally when any non-extra-block-producer miner's time slot passes.

**Attack Complexity:**

Minimal complexity:
1. Miner's normal time slot passes
2. Miner calls `GetConsensusCommand` (standard consensus operation)
3. Receives `NextRound` command instead of `Nothing` 
4. Produces block with `NextRound` behavior (standard block production)
5. Network accepts the block (validation passes)

**Feasibility Conditions:**

- Miner is in current round's miner list (normal state)
- Miner's expected mining time has passed (inevitable during normal operation)
- Miner is not the designated extra block producer (75%+ probability in typical 4+ miner networks)

**Detection/Operational Constraints:**

The attack is nearly undetectable because:
- All operations use standard consensus contract methods
- No abnormal transaction patterns
- Validation passes all checks
- Appears as legitimate consensus operation

**Probability:**

VERY HIGH - This occurs automatically in normal side chain operation whenever a non-extra-block-producer miner queries for their next consensus command after their time slot passes. The vulnerability is structural, not requiring active exploitation.

### Recommendation

**Immediate Fix:**

Modify `SideChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` to check if the miner is the designated extra block producer:

```csharp
protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
{
    // Check if this miner is the designated extra block producer
    var extraBlockProducer = CurrentRound.RealTimeMinersInformation
        .FirstOrDefault(m => m.Value.IsExtraBlockProducer);
    
    if (extraBlockProducer.Key != Pubkey)
    {
        // Not the extra block producer, should wait
        return AElfConsensusBehaviour.Nothing;
    }
    
    return AElfConsensusBehaviour.NextRound;
}
```

**Defense-in-Depth:**

Add validation in `ValidateBeforeExecution` to enforce extra block producer authority for `NextRound`:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new ExtraBlockProducerValidationProvider());
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

Create `ExtraBlockProducerValidationProvider`:

```csharp
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var extraBlockProducer = validationContext.BaseRound.RealTimeMinersInformation
            .FirstOrDefault(m => m.Value.IsExtraBlockProducer);
        
        if (extraBlockProducer.Key != validationContext.SenderPubkey)
        {
            return new ValidationResult 
            { 
                Message = $"Only the extra block producer can execute NextRound. " +
                         $"Expected: {extraBlockProducer.Key}, Got: {validationContext.SenderPubkey}" 
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

**Test Cases:**

1. Test that non-extra-block-producer miners receive `Nothing` behavior after their time slots pass
2. Test that only the designated extra block producer receives `NextRound` behavior
3. Test that `NextRound` transactions from non-extra-block-producers are rejected during validation
4. Test fork resolution when multiple miners attempt `NextRound` simultaneously

### Proof of Concept

**Initial State:**
- Side chain with 3 miners: MinerA (order 1), MinerB (order 2, extra block producer), MinerC (order 3)
- Currently in round N
- MinerC has mined their block for round N
- MinerC's time slot has passed

**Attack Sequence:**

1. MinerC calls `GetConsensusCommand(BytesValue{Value=MinerC_Pubkey})`
   - Expected: Returns `InvalidConsensusCommand` (behavior should be `Nothing`)
   - Actual: Returns valid consensus command with `NextRound` behavior

2. MinerC produces block with consensus transaction calling `NextRound()`
   - Expected: Validation fails because MinerC is not the extra block producer
   - Actual: Validation passes all checks

3. `NextRound` transaction executes successfully via `ProcessNextRound()`
   - State transitions to round N+1
   - MinerC (non-extra-block-producer) has terminated the round

4. MinerB (the legitimate extra block producer) also attempts to produce extra block
   - Now sees round number already incremented
   - Either fails validation or creates competing chain branch

**Success Condition:**

Round N transitions to round N+1 via MinerC's `NextRound` transaction, even though MinerB was the designated extra block producer. This violates the consensus invariant that only the extra block producer should terminate rounds.

**Verification:**

Check state after MinerC's block:
- `State.CurrentRoundNumber` incremented to N+1 (should still be N)
- MinerC's block contains `NextRound` consensus transaction (should be impossible)
- No block from MinerB with `NextRound` in the canonical chain (legitimate producer was bypassed)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-23)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L39-53)
```csharp
        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L39-44)
```csharp
            case AElfConsensusBehaviour.NextRound:
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L13-19)
```csharp
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```
