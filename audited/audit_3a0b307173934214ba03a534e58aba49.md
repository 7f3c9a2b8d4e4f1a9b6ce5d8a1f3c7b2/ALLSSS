### Title
Delegation Asymmetry in Fee Charging Causes Users to Lose More Funds Than Delegations on Failed Transactions

### Summary
When base fee charging fails, the `ChargeTransactionFeesToBill` function exhibits asymmetric behavior: for delegations it returns immediately without attempting size fee charging, while for regular users it continues to attempt size fee charging potentially in alternative tokens. Since `ModifyBalance` is called regardless of charging success and pre-transaction state changes persist even when the transaction fails, users lose more funds than delegations for identical failed transactions.

### Finding Description

The vulnerability exists in the `ChargeTransactionFeesToBill` function due to an asymmetric early return pattern: [1](#0-0) 

For delegations, when base fee charging fails, the function returns immediately without attempting to charge size fees. However, for regular users (when `delegations == null`), the function always attempts both base and size fee charging: [2](#0-1) 

The critical issue is that `ModifyBalance` is called unconditionally in `TryToChargeTransactionFee` regardless of whether charging succeeded: [3](#0-2) 

When `ChargeBaseFee` fails, it still adds partial amounts to the bill: [4](#0-3) 

For users, `ChargeSizeFee` is then called and can add additional charges in alternative tokens via `SymbolsToPayTxSizeFee`: [5](#0-4) 

The vulnerability is exploitable because in AElf's execution model, pre-transaction state changes persist even when the transaction returns failure. The pre-plugin execution explicitly commits state changes before checking if execution should stop: [6](#0-5) 

The comment at line 290 confirms: "If pre-tx fails, still commit the changes, but return false to notice outside to stop the execution."

### Impact Explanation

**Direct Fund Loss**: Users suffer discriminatory fund loss compared to delegations for identical failed transactions. When a user has insufficient balance for base fees but possesses alternative tokens configured in `SymbolsToPayTxSizeFee`, they lose both:
- Partial base fee (all available balance in base fee token)
- Partial size fee (deducted from alternative tokens)

In contrast, delegations only lose the partial base fee.

**Quantified Example**: 
- User/Delegatee has: 5 ELF, 10 TSA tokens
- Required: 10 ELF base fee + 2 ELF size fee (payable in TSA at 1:1 ratio)
- User loses: 5 ELF + 2 TSA = 7 tokens equivalent
- Delegation loses: 5 ELF only
- Differential: 2 TSA tokens per failed transaction

**Affected Users**: All regular users with insufficient base fee balance but available alternative size fee tokens. Delegations receive preferential treatment.

**Severity**: Medium - Creates systematic discrimination in fee charging, enables repeated drainage through transaction spam, violates fairness invariants, but requires pre-existing insufficient balance condition.

### Likelihood Explanation

**Reachable Entry Point**: The `ChargeTransactionFees` method is called automatically as a pre-execution plugin for all transactions: [7](#0-6) 

**Feasible Preconditions**: 
- User has insufficient balance for base fee (common scenario)
- User holds alternative tokens configured in `SymbolsToPayTxSizeFee` (standard chain configuration)
- No special attacker capabilities required

**Execution Practicality**: Occurs naturally during normal transaction submission when users have insufficient primary token balance. Can be triggered repeatedly by submitting transactions with insufficient funds, intentionally or unintentionally.

**Economic Rationality**: For malicious actors, minimal cost to spam failed transactions to drain user alternative token holdings. For users, happens unintentionally when balance runs low.

**Detection**: Difficult to detect as failed transactions are expected behavior; the discriminatory charging appears legitimate within transaction fee events.

**Probability**: Medium-High - Common in periods of high transaction activity or when users' primary token balance depletes while retaining secondary tokens.

### Recommendation

**Code-Level Mitigation**: Eliminate the asymmetry by applying consistent early return behavior for both delegation and user paths when base fee fails:

```csharp
// In ChargeTransactionFeesToBill, after line 283:
if (!successToChargeBaseFee)
{
    return false;  // Early return for both users and delegations when base fee fails
}
```

**Alternative Approach**: Only call `ModifyBalance` when charging fully succeeds:
```csharp
// In TryToChargeTransactionFee:
if (chargingResult)
{
    ModifyBalance(fromAddress, bill, allowanceBill);
}
```

**Invariant Check**: Add assertion that partial charges are never applied when overall charging fails, or modify the execution model to ensure failed pre-transactions don't persist state changes that represent incomplete fee collection.

**Test Cases**:
1. Test user with 5 ELF (needs 10) and 10 TSA - verify only 5 ELF charged, not additional TSA
2. Test delegation with same setup - verify consistent behavior
3. Test that failed transactions never result in partial multi-token fee deduction
4. Add integration test confirming pre-transaction rollback on failure scenarios

### Proof of Concept

**Initial State**:
- User address: `0xUSER`
- User balance: 5 ELF, 10 TSA tokens
- Base fee requirement: 10 ELF
- Size fee requirement: 2 ELF (or 2 TSA with 1:1 weight ratio)
- `SymbolsToPayTxSizeFee` configured with TSA token

**Transaction Steps**:
1. User submits any transaction to trigger `ChargeTransactionFees`
2. `ChargeBaseFee` executes, finds insufficient ELF (5 < 10)
3. `ChargeBaseFee` adds 5 ELF to bill and returns false
4. Since `delegations == null` (regular user), execution continues
5. `ChargeSizeFee` executes, finds TSA as alternative via `GetAvailableSymbolToPayTxFee`
6. `ChargeSizeFee` adds 2 TSA to bill
7. `ModifyBalance` executes, deducting 5 ELF + 2 TSA from user
8. Returns `Success = false`
9. Main transaction execution stops (Prefailed status)
10. Pre-transaction state changes persist per AElf execution model

**Expected vs Actual Result**:
- **Expected (fair behavior)**: Failed transaction charges 5 ELF only (partial base fee)
- **Actual (discriminatory)**: Failed transaction charges 5 ELF + 2 TSA (partial base + partial size)

**Success Condition**: 
Post-transaction user balance shows 0 ELF and 8 TSA (losing 2 TSA unnecessarily), while equivalent delegation scenario would show 0 ELF and 10 TSA (no TSA loss). Transaction status shows Failed/Prefailed but the discriminatory charges persist in blockchain state.

### Notes

This vulnerability demonstrates a subtle but impactful inconsistency in fee charging logic that creates unfair treatment between user types. The issue is exacerbated by AElf's execution model where pre-transaction state changes persist even on failure, which is an intentional design choice but creates unexpected consequences when combined with asymmetric charging logic.

The vulnerability is particularly concerning because:
1. It affects normal users more than delegations without clear justification
2. Failed transactions should ideally not result in any charges, or at minimum should charge consistently
3. The partial multi-token charging for failed transactions can be exploited through transaction spam
4. Users may not notice the discriminatory treatment as failed transactions are expected to have some cost

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-53)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L118-121)
```csharp
        ModifyBalance(fromAddress, bill, allowanceBill);
        var chargingOutput = new ChargeTransactionFeesOutput { Success = chargingResult };
        if (!chargingResult)
            chargingOutput.ChargingInformation = "Transaction fee not enough.";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L285-289)
```csharp
        //For delegation, if the base fee fails to be charged, the size fee will not be charged
        if (delegations != null && !successToChargeBaseFee)
        {
            return false;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L291-299)
```csharp
        var successToChargeSizeFee = true;
        if (!isSizeFeeFree)
        {
            // If IsSizeFeeFree == true, do not charge size fee.
            successToChargeSizeFee =
                ChargeSizeFee(input, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }

        return successToChargeBaseFee && successToChargeSizeFee;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L347-355)
```csharp
        {
            Context.LogDebug(() => "Failed to charge first sufficient token.");
            if (symbolToChargeBaseFee != null)
            {
                bill.FeesMap.Add(symbolToChargeBaseFee, existingBalance);
                allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);
            } // If symbol == 

            return false;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L393-414)
```csharp
        if (input.SymbolsToPayTxSizeFee.Any())
        {
            var allSymbolToTxFee = input.SymbolsToPayTxSizeFee.ToList();
            var availableSymbol = GetAvailableSymbolToPayTxFee(allSymbolToTxFee, fromAddress, txSizeFeeAmount,
                transactionFeeFreeAllowancesMap, symbolChargedForBaseFee, amountChargedForBaseFee,
                amountChargedForBaseAllowance, delegations);

            if (availableSymbol != null && availableSymbol.TokenSymbol != symbolToPayTxFee)
            {
                symbolToPayTxFee = availableSymbol.TokenSymbol;
                txSizeFeeAmount = txSizeFeeAmount.Mul(availableSymbol.AddedTokenWeight)
                    .Div(availableSymbol.BaseTokenWeight);
                GetAvailableBalance(symbolToPayTxFee, fromAddress, bill, transactionFeeFreeAllowancesMap, allowanceBill,
                    out symbolChargedForBaseFee, out amountChargedForBaseFee, out amountChargedForBaseAllowance,
                    out availableBalance, out availableAllowance);
            }

            //For delegation,if there is no available token,return false,no need to generate bill
            if (delegations != null && availableSymbol == null)
            {
                return false;
            }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L283-293)
```csharp
                var stateSets = preTrace.GetStateSets().ToList();
                internalStateCache.Update(stateSets);
                var parentStateCache = txContext.StateCache as TieredStateCache;
                parentStateCache?.Update(stateSets);

                if (!plugin.IsStopExecuting(preTrace.ReturnValue, out var error)) continue;

                // If pre-tx fails, still commit the changes, but return false to notice outside to stop the execution.
                preTrace.Error = error;
                preTrace.ExecutionStatus = ExecutionStatus.Executed;
                return false;
```
