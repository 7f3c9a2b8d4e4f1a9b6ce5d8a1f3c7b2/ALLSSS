### Title
Authorization Check After Expensive Loop Enables DOS Attack in SetMethodFee

### Summary
The `SetMethodFee()` function validates all entries in the `input.Fees` array through expensive external contract calls before checking if the caller is authorized. An attacker can submit transactions with thousands of fee entries, forcing the contract to perform extensive validation work before rejecting the unauthorized request, enabling a denial-of-service attack that wastes network resources.

### Finding Description

The vulnerability exists in the `SetMethodFee()` function where the order of operations creates a DOS vector: [1](#0-0) 

At line 13, the function iterates through every entry in `input.Fees` and calls `AssertValidToken()`, which makes an external cross-contract call to the TokenContract: [2](#0-1) 

This external call to `IsTokenAvailableForMethodFee` retrieves token information from state: [3](#0-2) 

The `GetTokenInfo` method performs 1-3 state reads per call: [4](#0-3) 

The authorization check only occurs AFTER all this expensive work completes (line 16), meaning unauthorized callers can force the contract to perform thousands of external calls and state reads before being rejected.

The `MethodFees` protobuf message allows a repeated `Fees` field with no inherent size restrictions: [5](#0-4) 

While AElf has execution limits, they don't prevent this attack:
- Transaction size limit: 5MB allows ~10,000-50,000 entries
- Call count threshold: 15,000 means ~10,000+ iterations are feasible [6](#0-5) [7](#0-6) 

The array validator only restricts arrays created WITHIN contract code during deployment, not input parameters: [8](#0-7) 

This pattern exists across ALL 15+ ACS1 implementations in the codebase, making it a systemic issue: [9](#0-8) 

### Impact Explanation

**Operational DOS Impact:**
- Unauthorized users can force expensive computation by submitting transactions with large `Fees` arrays (5,000-10,000 entries)
- Each iteration requires an external cross-contract call plus multiple state reads, consuming significant computational resources
- The transaction will ultimately fail at authorization, but only after wasting resources
- Multiple attackers could spam such transactions to congest the network, delaying legitimate transactions
- Even legitimate authorized SetMethodFee calls suffer from unnecessary expense when setting multiple fees

**Quantified Resource Waste:**
- With 10,000 entries: 10,000 external calls + 10,000-30,000 state reads before rejection
- Within the 15,000 call threshold but represents massive wasted computation
- Attack cost: single transaction fee per attempt
- Defense cost: network resources processing thousands of pointless operations

**Affected Parties:**
- Network validators processing these transactions
- Legitimate users experiencing delayed transactions due to congestion
- All 15+ system contracts implementing ACS1 are vulnerable

### Likelihood Explanation

**High Likelihood - All Conditions Met:**

1. **Attacker Capabilities**: Any user can call the public `SetMethodFee()` method without restrictions
2. **Attack Complexity**: Trivial - construct a `MethodFees` object with a large `Fees` array and submit
3. **Feasibility Conditions**: 
   - No authentication required to trigger expensive loop
   - Transaction size limit (5MB) easily accommodates thousands of entries
   - Each MethodFee entry ~50-100 bytes, allowing 10,000-50,000 entries
   - Stays under call threshold with 10,000-14,000 entries
4. **Economic Rationality**: Attack cost is minimal (standard transaction fee), while impact on network is significant
5. **Detection**: Difficult to distinguish from legitimate usage attempting to set multiple fees

**Practical Exploitation:**
An attacker simply needs to:
1. Create a `MethodFees` message with 10,000 duplicate or varied entries
2. Submit via `SetMethodFee()` transaction
3. Loop executes 10,000 iterations with external calls
4. Transaction fails at line 16 with "Unauthorized" but resources already wasted

### Recommendation

**Immediate Fix:**
Move the authorization check before the validation loop in all ACS1 implementations:

```csharp
public override Empty SetMethodFee(MethodFees input)
{
    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
    
    foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
    State.TransactionFees[input.MethodName] = input;
    
    return new Empty();
}
```

**Additional Protections:**
1. Add input validation for reasonable array sizes (e.g., max 100 fees per method)
2. Implement rate limiting for failed authorization attempts
3. Add monitoring/alerting for transactions with unusually large Fees arrays

**Affected Files to Patch:**
- EconomicContract_ACS1_TransactionFeeProvider.cs
- TokenContract_ACS1_MethodFeeProvider.cs
- All other *_ACS1_TransactionFeeProvider.cs files (15+ contracts)

**Test Cases:**
1. Verify authorization check occurs before validation with large arrays
2. Test that unauthorized calls with 10,000 entries fail immediately
3. Measure gas consumption before/after fix to confirm improvement

### Proof of Concept

**Initial State:**
- Attacker has any valid account with transaction fee balance
- SetMethodFee method fee controller is set to Parliament (default)
- Attacker is NOT the controller owner

**Attack Steps:**

1. Attacker constructs malicious transaction:
```
MethodFees input = {
    MethodName: "SomeMethod",
    Fees: [
        { Symbol: "ELF", BasicFee: 100 },
        { Symbol: "ELF", BasicFee: 100 },
        ... (repeat 10,000 times)
    ]
}
```

2. Submit transaction: `EconomicContract.SetMethodFee(input)`

3. **Expected behavior (with fix)**: Immediate failure at authorization check with minimal resource consumption

4. **Actual behavior (current)**: 
   - Loop executes 10,000 iterations (line 13)
   - Makes 10,000 external calls to TokenContract.IsTokenAvailableForMethodFee
   - Performs 10,000-30,000 state reads via GetTokenInfo
   - Consumes ~10,000 of the 15,000 call threshold
   - THEN fails at line 16 with "Unauthorized to set method fee."

**Success Condition:** 
The transaction fails as expected, but only after consuming massive computational resources. Monitoring shows high call counts and state reads for a transaction that should fail immediately. Multiple such transactions can measurably congest the network.

### Citations

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L11-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
```

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L78-87)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L252-257)
```csharp
    private bool IsTokenAvailableForMethodFee(string symbol)
    {
        var tokenInfo = GetTokenInfo(symbol);
        if (tokenInfo == null) throw new AssertionException("Token is not found.");
        return tokenInfo.IsBurnable;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** protobuf/acs1.proto (L40-46)
```text
message MethodFees {
    // The name of the method to be charged.
    string method_name = 1;
    // List of fees to be charged.
    repeated MethodFee fees = 2;
    bool is_size_fee_free = 3;// Optional based on the implementation of SetMethodFee method.
}
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L1-6)
```csharp
namespace AElf.Kernel.TransactionPool;

public class TransactionPoolConsts
{
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
}
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L1-13)
```csharp
namespace AElf.Kernel.SmartContract;

public class SmartContractConstants
{
    public const int ExecutionCallThreshold = 15000;

    public const int ExecutionBranchThreshold = 15000;

    public const int StateSizeLimit = 128 * 1024;

    // The prefix `vs` occupies 2 lengths.
    public const int StateKeyMaximumLength = 255 - 2;
}
```

**File:** src/AElf.CSharp.CodeOps/Validators/Method/ArrayValidator.cs (L13-16)
```csharp
public class ArrayValidator : IValidator<MethodDefinition>, ITransientDependency
{
    private const long AllowedTotalSize = 40 * 1024; // Byte per array when limiting by total array size

```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```
