### Title
Authorization Escalation via Method Fee Controller Downgrade to Weak Organization

### Summary
The `ChangeMethodFeeController` function lacks validation of the security properties of the new controller organization, allowing Parliament (requiring majority miner approval) to be replaced with a single-member Association organization. After this downgrade, a single attacker-controlled address gains arbitrary control over method fees for all contract operations, enabling economic manipulation and DoS attacks.

### Finding Description

**Exact Code Location:** [1](#0-0) 

**Root Cause:**
The `ChangeMethodFeeController` function performs only three checks: (1) controller initialization, (2) sender authorization from current controller, and (3) existence of the new organization. There is **no validation** that the new organization maintains equal or stronger security thresholds than the current controller. [2](#0-1) 

The `CheckOrganizationExist` method only verifies the organization exists via `ValidateOrganizationExist`, without examining its approval thresholds, member count, or proposer whitelist restrictions.

**Why Protections Fail:**
Association organizations can be created with minimal security requirements - a single member and approval threshold of 1: [3](#0-2) 

The validation only requires that `MinimalApprovalThreshold > 0` and member count is non-empty, allowing trivially weak organizations.

**Execution Path:**
1. Default controller is Parliament default organization requiring ~80% miner approval: [4](#0-3) 

2. Attacker creates Association organization with single member: [5](#0-4) 

3. Parliament proposal to change controller to weak Association passes: [6](#0-5) 

4. Single attacker address now controls all method fees: [7](#0-6) 

### Impact Explanation

**Concrete Harm:**
- **Economic Manipulation**: Attacker sets method fees to 0, enabling spam attacks and blockchain bloat, or sets fees prohibitively high, blocking legitimate users
- **Persistent Control**: Once controller is changed, attacker can modify fees repeatedly and change controller again to maintain control
- **System-Wide Impact**: This vulnerability affects ALL ACS1-implementing system contracts (MultiToken, Treasury, Parliament, Election, Consensus, Configuration, etc.), not just TokenHolder

**Quantified Damage:**
- DoS Attack: Zero fees enable unlimited transaction spam
- Economic Attack: Arbitrary fees drain user funds or block operations
- Governance Bypass: Single address replaces decentralized miner consensus

**Affected Parties:**
All users interacting with any system contract requiring method fees

**Severity Justification: HIGH**
Violates critical "Authorization & Governance" and "Token Supply & Fees" invariants by allowing unilateral fee control after governance downgrade.

### Likelihood Explanation

**Attacker Capabilities:**
- Must create Association organization (public method, no special privileges required)
- Must convince Parliament miners to approve controller change proposal

**Attack Complexity:**
Demonstrated by existing test case that successfully executes full attack path: [8](#0-7) 

**Feasibility Conditions:**
- Initial Parliament approval required (miners may approve unknowingly if proposal appears legitimate)
- No subsequent restrictions once controller changed
- All contracts implementing ACS1 standard vulnerable identically

**Detection Constraints:**
- Controller changes are permanent state modifications visible on-chain
- No built-in alerting for governance strength downgrades
- Social engineering may hide true intent during proposal phase

**Probability:** Moderate to High - requires initial governance approval but straightforward execution with permanent consequences.

### Recommendation

**Code-Level Mitigation:**
Add organization strength validation in `ChangeMethodFeeController`:

1. Compare new organization's approval thresholds against current controller
2. Enforce that new organization requires equal or greater security:
   - If current is Parliament: new organization must be Parliament with >= current thresholds
   - If current is Association: new Association must have >= current member count and thresholds
   - If current is Referendum: new must have >= current token threshold

**Invariant Checks to Add:**
```
// In ChangeMethodFeeController
Assert(ValidateOrganizationStrength(currentController, newController), 
       "New controller must have equal or stronger security properties");
```

**Implementation Pattern:** [3](#0-2) 

Add similar validation logic that compares organizational security parameters between current and proposed controllers.

**Test Cases:**
1. Test rejection when changing Parliament to single-member Association
2. Test acceptance when changing to equal or stronger Parliament organization
3. Test rejection when reducing Association member count or approval thresholds
4. Test across all ACS1-implementing contracts (Token, Treasury, Election, etc.)

### Proof of Concept

**Initial State:**
- TokenHolder contract initialized with Parliament default organization as method fee controller
- Parliament default requires ~80% miner approval (MinimalApprovalThreshold = 6667/10000)

**Attack Steps:**

1. **Create Weak Association Organization:**
   - Call `AssociationContract.CreateOrganization` with:
     - `MinimalApprovalThreshold = 1`
     - `MinimalVoteThreshold = 1`
     - `OrganizationMembers = [AttackerAddress]`
     - `ProposerWhiteList = [AttackerAddress]`
   - Returns: weak_organization_address

2. **Create Parliament Proposal to Change Controller:**
   - Call `ParliamentContract.CreateProposal` targeting `TokenHolderContract.ChangeMethodFeeController`
   - Parameters: `AuthorityInfo { OwnerAddress: weak_organization_address, ContractAddress: AssociationContract }`

3. **Get Miner Approval:**
   - Miners approve proposal (may approve unknowingly)
   - Call `ParliamentContract.Approve` from majority of miners

4. **Release Proposal:**
   - Call `ParliamentContract.Release` on approved proposal
   - Controller changed to weak Association organization

5. **Exploit Arbitrary Fee Control:**
   - As AttackerAddress (single Association member)
   - Create proposal via `AssociationContract.CreateProposal` to call `TokenHolderContract.SetMethodFee`
   - Immediately approve own proposal (single member = instant approval)
   - Release and execute to set arbitrary fees
   - Repeat for all methods, set fees to 0 or extremely high values

**Expected Result:**
Transaction should fail with "New controller must have equal or stronger security properties"

**Actual Result:**
Transaction succeeds, attacker gains unilateral fee control

**Success Condition:**
Demonstrated by existing test showing successful controller change from Parliament to single-member Association: [8](#0-7)

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L50-64)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L1273-1315)
```csharp
    public async Task ChangeMethodFeeControllerByAssociation_Test()
    {
        var createOrganizationResult = await Tester.ExecuteContractWithMiningAsync(AssociationContractAddress,
            nameof(AssociationContractImplContainer.AssociationContractImplStub.CreateOrganization),
            new Association.CreateOrganizationInput
            {
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { AnotherMinerAddress }
                },
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { AnotherMinerAddress }
                }
            });

        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.ReturnValue);

        var methodFeeController = await GetMethodFeeController(Tester, BasicContractZeroAddress);
        const string proposalCreationMethodName =
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ChangeMethodFeeController);
        var proposalId = await CreateProposalAsync(Tester, methodFeeController.ContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName,
            new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = AssociationContractAddress
            });
        await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
        var txResult2 = await ReleaseProposalAsync(Tester, ParliamentAddress, proposalId);
        txResult2.Status.ShouldBe(TransactionResultStatus.Mined);

        var methodFeeControllerAfterChange =
            await GetMethodFeeController(Tester, BasicContractZeroAddress);

        methodFeeControllerAfterChange.ContractAddress.ShouldBe(AssociationContractAddress);
        methodFeeControllerAfterChange.OwnerAddress.ShouldBe(organizationAddress);
    }
```
