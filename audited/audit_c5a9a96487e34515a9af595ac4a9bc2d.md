# Audit Report

## Title
Missing LIB Height Validation During NextTerm Transition Enables Chain Reorganization

## Summary
The AEDPoS consensus contract fails to validate Last Irreversible Block (LIB) height during term transitions, allowing miners to include stale consensus data with lower LIB values. While `UpdateValue` operations correctly validate that LIB never decreases, `NextTerm` operations omit this critical check, breaking blockchain finality guarantees.

## Finding Description

The vulnerability stems from inconsistent application of LIB validation across consensus behaviors. The system implements `LibInformationValidationProvider` to prevent LIB rollback during normal block production, but this validation is explicitly excluded for `NextTerm` operations.

**Vulnerable Code Flow:**

1. When a miner needs to produce a NextTerm block, they call `GetConsensusExtraData` which invokes `GetConsensusExtraDataForNextTerm`. [1](#0-0) 

2. This calls `GenerateFirstRoundOfNextTerm` which directly copies the LIB height from the current round without any validation. [2](#0-1) 

3. The same unvalidated copy occurs in the `MinerList.GenerateFirstRoundOfNewTerm` extension method. [3](#0-2) 

4. During validation, `UpdateValue` behavior includes `LibInformationValidationProvider` to prevent LIB rollback. [4](#0-3) 

5. However, `NextTerm` behavior only includes `RoundTerminateValidationProvider`, completely excluding LIB validation. [5](#0-4) 

6. The `LibInformationValidationProvider` checks that provided LIB heights do not decrease from the base round, but this protection is never applied to NextTerm. [6](#0-5) 

7. The `RoundTerminateValidationProvider` only validates round and term number increments, with no LIB checks. [7](#0-6) 

**Attack Scenario:**

A malicious miner scheduled for a NextTerm block can:
1. Call `GetConsensusExtraData` (a view method with no restrictions) when LIB is at height X
2. Wait for other miners to advance LIB to height Y > X through normal block production
3. Produce their NextTerm block using the cached data with stale LIB = X
4. The block passes validation because NextTerm lacks LIB height validation
5. The blockchain's LIB is rolled back from Y to X, un-finalizing previously confirmed blocks

This can also occur accidentally through race conditions where consensus data is generated at time T1 but the block is produced at T2 after LIB has increased.

## Impact Explanation

This vulnerability violates the fundamental security property of blockchain finality, with severe consequences:

**Direct Integrity Breach:**
- Previously irreversible blocks become reversible, breaking the core guarantee that confirmed transactions are permanent
- Transactions that users and exchanges considered finalized can be reorganized
- The blockchain's consensus security model is fundamentally compromised

**Double-Spending Risk:**
- If blocks become un-finalized, their transactions can potentially be reorganized
- Attackers could execute double-spending attacks by reversing confirmed transactions
- Exchanges accepting deposits based on finality could suffer direct financial losses

**Cross-Chain Security:**
- LIB height is used for cross-chain indexing and operations
- Rolling back LIB affects parent-side chain synchronization
- Cross-chain asset transfers relying on finality could be compromised

**Systemic Economic Damage:**
- Loss of confidence in blockchain finality
- Exchanges may require significantly more confirmations
- DApp developers cannot rely on transaction permanence
- Potential for cascading failures across dependent systems

The severity is CRITICAL because this breaks a core blockchain invariant that all other security properties depend upon.

## Likelihood Explanation

**Attacker Prerequisites:**
1. Must be a valid miner in the current round
2. Must be scheduled to produce a NextTerm block

These prerequisites are achievable:
- Any party can run for election and become a miner by obtaining votes
- Term transitions occur at regular, predictable intervals
- Any miner in rotation will eventually be scheduled for a NextTerm block

**Attack Complexity:** MODERATE
- `GetConsensusExtraData` is a public view method callable at any time with no restrictions [8](#0-7) 
- No cryptographic complexity required
- Simple timing manipulation (cache early data, use later)
- Zero validation prevents detection

**Feasibility Factors:**
- Term transitions provide regular exploitation windows
- Can occur accidentally through legitimate race conditions (node generates data at T1, produces block at T2)
- No monitoring or alerting mechanism exists to detect this
- Complete absence of validation makes exploitation trivial

**Probability Assessment:** HIGH

The combination of regular opportunities (term transitions), simple execution (no complex exploit chain), achievable prerequisites (becoming a miner), and zero validation makes this highly likely to occur either through malicious action or accidental race conditions.

## Recommendation

Add `LibInformationValidationProvider` to the NextTerm validation logic to ensure consistency with UpdateValue behavior:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    // Add LIB validation to prevent rollback during term transitions
    validationProviders.Add(new LibInformationValidationProvider());
    break;
```

This ensures that:
1. NextTerm blocks cannot include LIB heights lower than the current state
2. The validation is consistent across all consensus behaviors
3. Blockchain finality guarantees are maintained during term transitions
4. Both malicious attacks and accidental race conditions are prevented

Additionally, consider implementing monitoring to detect and alert on any LIB height decreases across all consensus operations.

## Proof of Concept

```csharp
// Test demonstrating NextTerm accepts stale LIB while UpdateValue rejects it
[Fact]
public async Task NextTerm_Accepts_Stale_LIB_Without_Validation()
{
    // Setup: Initialize chain with current LIB at height 100
    var currentRound = new Round 
    { 
        RoundNumber = 5, 
        TermNumber = 1,
        ConfirmedIrreversibleBlockHeight = 100,
        ConfirmedIrreversibleBlockRoundNumber = 4
    };
    
    // Step 1: Miner calls GetConsensusExtraData early when LIB = 100
    var staleConsensusData = GetConsensusExtraDataForNextTerm(
        minerPubkey, 
        miningInterval);
    
    // Verify stale data contains LIB = 100
    Assert.Equal(100, staleConsensusData.Round.ConfirmedIrreversibleBlockHeight);
    
    // Step 2: Other miners advance LIB to 120 through UpdateValue operations
    AdvanceLIBThroughNormalBlocks(currentHeight: 120);
    
    // Step 3: Attacker produces NextTerm block with stale LIB = 100
    var nextTermInput = NextTermInput.Create(
        staleConsensusData.Round, 
        randomNumber);
    
    // Step 4: Validation PASSES (vulnerability - should reject)
    var validationResult = ValidateConsensusBeforeExecution(
        nextTermInput.ToByteString());
    
    Assert.True(validationResult.Success); // BUG: Should fail but passes
    
    // Step 5: Execute NextTerm - LIB rolls back from 120 to 100
    await NextTerm(nextTermInput);
    
    // Step 6: Verify LIB was rolled back (finality breach)
    var newRound = GetCurrentRoundInformation(new Empty());
    Assert.Equal(100, newRound.ConfirmedIrreversibleBlockHeight); // Rolled back!
    
    // For comparison: UpdateValue correctly rejects stale LIB
    var updateValueWithStaleLIB = CreateUpdateValueWithStaleLIB(libHeight: 100);
    var updateValidation = ValidateConsensusBeforeExecution(
        updateValueWithStaleLIB.ToByteString());
    
    Assert.False(updateValidation.Success); // Correctly rejected
    Assert.Contains("Incorrect lib information", updateValidation.Message);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L45-47)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L244-245)
```csharp
        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L51-52)
```csharp
        round.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        round.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-20)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-46)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```
