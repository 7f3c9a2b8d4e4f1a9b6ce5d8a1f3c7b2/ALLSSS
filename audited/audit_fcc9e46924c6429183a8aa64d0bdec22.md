### Title
Miners Can Manipulate Mining Order by Providing Arbitrary SupposedOrderOfNextRound Values

### Summary
The AEDPoS consensus contract accepts `SupposedOrderOfNextRound` values from miners in `UpdateValueInput` without validating that they were correctly calculated from the miner's signature. This allows malicious miners to arbitrarily choose their mining position in the next round, breaking the fairness and randomness guarantees of the consensus mechanism.

### Finding Description

The consensus mechanism calculates each miner's position in the next round based on their signature using the formula `GetAbsModulus(signature.ToInt64(), minersCount) + 1` in `ApplyNormalConsensusData`. [1](#0-0) 

However, this calculation only occurs in `GetConsensusBlockExtraData`, which is a view function that generates consensus extra data but does not enforce the result. [2](#0-1) 

When miners submit `UpdateValue` transactions, the contract directly assigns the `SupposedOrderOfNextRound` value from the input without recalculation or validation: [3](#0-2) 

The validation phase only checks that `OutValue` and `Signature` are non-null and non-empty, and validates the `PreviousInValue` relationship, but does NOT verify the `SupposedOrderOfNextRound` calculation: [4](#0-3) 

The `NextRoundMiningOrderValidationProvider` that validates mining order is only applied for `NextRound` behavior, not for `UpdateValue` behavior, and it only checks counts, not individual value correctness: [5](#0-4) 

This validator is not included in the validation providers for UpdateValue: [6](#0-5) 

### Impact Explanation

This vulnerability allows miners to control their mining position in subsequent rounds, breaking the core fairness guarantees of the AEDPoS consensus mechanism. A malicious miner can consistently choose to be first in mining order, which provides several advantages:

1. **Extra Block Production**: The first miner can produce extra blocks if subsequent miners are late or offline, earning additional rewards
2. **Random Number Influence**: Mining order affects the sequence of random number generation, potentially enabling prediction or manipulation of consensus randomness
3. **Priority Rewards**: First miners receive block rewards before others in the round
4. **Consensus Control**: Systematic manipulation by multiple colluding miners could destabilize round transitions

The impact is severe because it fundamentally breaks the unpredictability and fairness properties that the signature-based ordering mechanism is designed to provide. All miners are affected as the consensus mechanism becomes deterministically controllable rather than cryptographically random.

### Likelihood Explanation

The attack is highly practical with low complexity:

**Attacker Capabilities**: Any miner in the consensus set can execute this attack without special privileges.

**Attack Complexity**: 
1. Miner calls `GetConsensusBlockExtraData` (view function) to obtain valid `OutValue` and `Signature` for their `InValue`
2. Miner constructs a custom `UpdateValueInput` transaction with the valid `OutValue` and `Signature` but replaces `SupposedOrderOfNextRound` with their desired value (e.g., 1 for first position)
3. Miner signs and submits the modified transaction

**Feasibility**: The attack requires no special conditions - just normal miner participation. The cost is minimal (standard transaction gas), while the benefit is continuous preferential mining positions.

**Detection**: While the manipulation could be detected by comparing submitted `SupposedOrderOfNextRound` values against what should have been calculated from signatures, there is no automatic enforcement, and miners are economically incentivized to exploit this.

### Recommendation

Add validation in `ProcessUpdateValue` to verify that `SupposedOrderOfNextRound` was correctly calculated from the signature:

```csharp
// In ProcessUpdateValue, before line 246, add:
var minersCount = currentRound.RealTimeMinersInformation.Count;
var sigNum = updateValueInput.Signature.ToInt64();
var expectedOrder = GetAbsModulus(sigNum, minersCount) + 1;
Assert(updateValueInput.SupposedOrderOfNextRound == expectedOrder, 
    "SupposedOrderOfNextRound does not match signature calculation.");
```

Additionally, add the `GetAbsModulus` method to the contract scope if not already accessible, or move the validation logic to a shared helper that both `ApplyNormalConsensusData` and `ProcessUpdateValue` can use.

Include test cases that:
1. Verify rejection of UpdateValueInput with manipulated SupposedOrderOfNextRound
2. Confirm acceptance only when SupposedOrderOfNextRound matches the signature-based calculation
3. Test edge cases with different miner counts and signature values

### Proof of Concept

**Initial State**: 
- Consensus round is active with N miners
- Attacker is a legitimate miner in the consensus set
- Attacker's signature would normally place them at position 5 in next round

**Attack Steps**:

1. Attacker calls `GetConsensusBlockExtraData` with their `InValue` via trigger information
   - Contract calculates `OutValue = Hash(InValue)`
   - Contract calculates `Signature` based on previous round XOR operations
   - Contract calculates `supposedOrderOfNextRound = GetAbsModulus(Signature.ToInt64(), N) + 1 = 5`

2. Attacker constructs custom `UpdateValueInput`:
   - `out_value`: valid value from step 1
   - `signature`: valid value from step 1  
   - `supposed_order_of_next_round`: **1** (manipulated, instead of 5)
   - Other required fields filled correctly

3. Attacker submits `UpdateValue` transaction with modified input

4. Validation phase accepts transaction (OutValue and Signature are valid)

5. Execution phase stores `SupposedOrderOfNextRound = 1` and `FinalOrderOfNextRound = 1`

**Expected Result**: Transaction should be rejected for providing incorrect `SupposedOrderOfNextRound`

**Actual Result**: Transaction is accepted, attacker is assigned first position in next round instead of fifth position

**Success Condition**: Query the round information after the transaction - attacker's `FinalOrderOfNextRound` is 1 instead of the signature-calculated value of 5

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-21)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```
