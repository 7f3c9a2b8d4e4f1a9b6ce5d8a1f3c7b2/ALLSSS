### Title
Unbounded Token Symbol List Enables Denial of Service on Profit Claims

### Summary
The `ContributeProfits()` function allows any user to inject arbitrary valid token symbols into a scheme's `ReceivedTokenSymbols` list without authorization or size limits. This creates a denial-of-service vulnerability where attackers can bloat the symbol list, causing legitimate users' profit claiming transactions to exceed gas limits or become prohibitively expensive.

### Finding Description

The vulnerability exists in the profit distribution mechanism across multiple functions:

**Root Cause**: The `ContributeProfits()` function is publicly accessible without authorization checks and unconditionally adds new token symbols to the scheme's `ReceivedTokenSymbols` list. [1](#0-0) [2](#0-1) 

The only validation is that the token must exist on-chain: [3](#0-2) 

**Exploitation Path**: When users claim profits via `ClaimProfits()` or query profits via `GetAllProfitsMap()`, the code calls `ProfitAllPeriods()` which iterates through all symbols in `ReceivedTokenSymbols`: [4](#0-3) 

For each symbol, the function loops through multiple periods, performing state reads and calculations: [5](#0-4) 

The `AddProfitToDict()` helper function mentioned in the prompt simply merges dictionaries and is not the root cause: [6](#0-5) 

**Why Protections Fail**: 
- No authorization check on who can contribute profits
- No maximum limit on the number of symbols in `ReceivedTokenSymbols`
- No cleanup mechanism to remove symbols with zero balances
- The protobuf definition uses `repeated string` without bounds: [7](#0-6) 

### Impact Explanation

**Operational Impact - Denial of Service**:
1. **Manager Operations**: When schemes have `IsReleaseAllBalanceEveryTimeByDefault` enabled, the `DistributeProfits()` function queries balances for all symbols in the list, making distribution transactions expensive or impossible. [8](#0-7) 

2. **User Profit Claims**: Beneficiaries calling `ClaimProfits()` must iterate through all symbols × all claimable periods, causing:
   - If attacker injects 100 symbols and there are 10 periods: 1,000 state read operations
   - Transactions may exceed gas limits
   - Even if successful, claiming becomes prohibitively expensive [9](#0-8) 

3. **View Method Degradation**: `GetAllProfitsMap()` and similar view methods become slow or timeout, breaking frontend integrations. [10](#0-9) 

**Affected Parties**: All beneficiaries of the targeted profit schemes, including critical system schemes used for consensus rewards, staking dividends, and treasury distributions.

**Severity Justification**: High/Medium - While funds are not directly stolen, the protocol's core reward distribution mechanism can be rendered inoperable, preventing legitimate users from accessing earned profits indefinitely.

### Likelihood Explanation

**Reachable Entry Point**: `ContributeProfits()` is a public method callable by anyone: [11](#0-10) 

**Feasible Preconditions**:
- Attacker needs minimal amounts (1 unit each) of multiple valid tokens
- Most blockchains have numerous low-value or dust tokens available
- Attacker must approve token transfers to the contract (standard operation)

**Execution Practicality**:
1. For each token symbol, attacker calls: `ContributeProfits(scheme_id, 1, 0, symbol)`
2. Each call adds the symbol to `ReceivedTokenSymbols`
3. Can be executed in a loop or script
4. No special permissions or complex setup required

**Economic Rationality**:
- **Attack Cost**: Gas for N `ContributeProfits()` calls + 1 unit of N different tokens
  - If using 100 low-value tokens at $0.01 each: ~$1 in tokens + gas costs
- **Victim Cost**: Claiming profits becomes 100x more expensive or impossible
- **Attacker Advantage**: Can target high-value schemes (consensus rewards, treasury) where victim losses are substantial

**Detection/Operational Constraints**: Attack is easily detectable in transaction history, but remediation requires contract upgrade since no cleanup mechanism exists.

### Recommendation

**Immediate Mitigations**:

1. **Add Authorization Check** in `ContributeProfits()`:
```csharp
// Only allow scheme manager or whitelisted contributors
Assert(Context.Sender == scheme.Manager || 
       scheme.AuthorizedContributors.Contains(Context.Sender),
       "Not authorized to contribute.");
```

2. **Implement Symbol Count Limit**:
```csharp
// Before adding symbol at line 716
Assert(scheme.ReceivedTokenSymbols.Count < MAX_SYMBOLS_PER_SCHEME,
       "Maximum token symbols limit reached.");
```

3. **Add Symbol Cleanup Method** (callable by manager):
```csharp
public Empty RemoveTokenSymbol(RemoveTokenSymbolInput input) {
    var scheme = State.SchemeInfos[input.SchemeId];
    Assert(Context.Sender == scheme.Manager, "Only manager.");
    // Verify zero balance before removal
    var balance = State.TokenContract.GetBalance(scheme.VirtualAddress, input.Symbol);
    Assert(balance == 0, "Symbol has non-zero balance.");
    scheme.ReceivedTokenSymbols.Remove(input.Symbol);
    State.SchemeInfos[input.SchemeId] = scheme;
}
```

4. **Filter Zero-Balance Symbols** in iteration loops (optimization):
```csharp
// In ProfitAllPeriods, before iterating symbols
var symbols = targetSymbol == null 
    ? scheme.ReceivedTokenSymbols
        .Where(s => HasNonZeroBalance(scheme.VirtualAddress, s))
        .ToList() 
    : new List<string> { targetSymbol };
```

**Test Cases**:
- Verify unauthorized users cannot contribute profits
- Test symbol count limit enforcement
- Validate cleanup of zero-balance symbols
- Confirm gas consumption remains bounded with maximum symbols

### Proof of Concept

**Required Initial State**:
- A profit scheme exists with ID `scheme_id`
- Attacker has access to 50+ different valid token symbols on-chain
- Each token has minimal approval granted to the Profit contract

**Attack Steps**:
1. Attacker identifies target scheme (e.g., consensus reward scheme)
2. For i = 1 to 100:
   - Call `ContributeProfits(scheme_id, 1, 0, token_symbol[i])`
   - Transaction succeeds, symbol added to `ReceivedTokenSymbols`
3. Verify: `GetScheme(scheme_id).ReceivedTokenSymbols.Count == 100`

**Victim Impact**:
4. Legitimate beneficiary calls `ClaimProfits(scheme_id, beneficiary_address)`
5. Transaction loops through 100 symbols × 10 periods = 1,000 iterations
6. **Expected**: Profit claimed successfully
7. **Actual**: Transaction fails with "out of gas" or requires 100x normal gas cost

**Success Condition**: 
- Attacker successfully injects 100 symbols with minimal cost
- Victim's claim transaction becomes economically infeasible
- Scheme operations (distribution and claiming) are effectively DoS'd

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L449-459)
```csharp
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L501-508)
```csharp
    private void AssertTokenExists(string symbol)
    {
        if (string.IsNullOrEmpty(State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput { Symbol = symbol })
                .TokenName))
        {
            throw new AssertionException($"Token {symbol} not exists.");
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-660)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L716-716)
```csharp
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L784-784)
```csharp
            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L851-851)
```csharp
        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-874)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L130-134)
```csharp
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
            AddProfitToDict(allProfitsDict, totalProfitsDictForEachProfitDetail);
            if(i >= profitableDetailCount) continue;
            var claimableProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount,true, symbol);
            AddProfitToDict(claimableProfitsDict, claimableProfitsDictForEachProfitDetail);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L144-151)
```csharp
    private void AddProfitToDict(Dictionary<string, long> profitsDict, Dictionary<string,long> profitsToAdd)
    {
        foreach (var kv in profitsToAdd)
            if (profitsDict.ContainsKey(kv.Key))
                profitsDict[kv.Key] = profitsDict[kv.Key].Add(kv.Value);
            else
                profitsDict[kv.Key] = kv.Value;
    }
```

**File:** protobuf/profit_contract.proto (L158-159)
```text
    // The received token symbols.
    repeated string received_token_symbols = 12;
```
