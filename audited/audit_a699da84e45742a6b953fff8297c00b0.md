### Title
Duplicate Welcome Rewards via Pubkey Replacement During Non-Mining Periods

### Summary
The `LatestMinedTerm` tracking in the Treasury contract can be bypassed to allow miners to receive welcome rewards multiple times. When a candidate replaces their pubkey while not actively mining, the Treasury contract is not notified, leaving the new pubkey with `LatestMinedTerm == 0`. This causes the system to incorrectly identify the replacement pubkey as a "new" miner, granting duplicate welcome rewards to the same entity.

### Finding Description

The vulnerability exists in the interaction between three contracts: Election, AEDPoS (Consensus), and Treasury.

**Root Cause:**

The AEDPoS contract's `RecordCandidateReplacement` method only notifies the Treasury contract if the old pubkey is currently an active miner in the current round: [1](#0-0) 

When the condition fails (old pubkey not in current round), the method returns early without calling Treasury's `RecordMinerReplacement`: [2](#0-1) 

This leaves the Treasury contract's `LatestMinedTerm` state unchanged - the old pubkey retains its mining history, but the new pubkey has `LatestMinedTerm[newPubkey] == 0`.

**Detection of New Miners:**

During reward distribution in the `Release` method, miners are identified as "new" if their `LatestMinedTerm` equals 0 and they're not in the initial miner list: [3](#0-2) 

**Welcome Reward Distribution:**

New miners identified by this check receive welcome rewards through the `UpdateWelcomeRewardWeights` method: [4](#0-3) 

**Why Protections Fail:**

The Election contract's `ReplaceCandidatePubkey` method processes the replacement regardless of current mining status, only checking that the old pubkey is a candidate or initial miner: [5](#0-4) 

The old pubkey is banned to prevent reuse: [6](#0-5) 

However, this doesn't prevent the new pubkey from being treated as new by the Treasury contract.

### Impact Explanation

**Direct Financial Impact:**
- Attackers can drain welcome rewards from the `VotesWeightRewardHash` profit scheme by receiving rewards multiple times
- Each duplicate welcome reward grants shares in the welcome reward distribution for an entire term
- The welcome reward pool is funded by the Treasury's mining reward allocation (weighted by `MinerRewardWeightSetting.WelcomeRewardWeight`)

**Who Is Affected:**
- Legitimate new miners receive reduced welcome rewards due to pool dilution
- The Treasury's reward distribution becomes unfair and violates the intended "one-time welcome incentive" design
- The overall economic model of the blockchain is compromised

**Severity Justification:**
This is HIGH severity because:
1. It directly misallocates economic rewards designed for new miner onboarding
2. The attack is repeatable - a single attacker can exploit this multiple times with different pubkeys
3. It requires no special privileges beyond normal candidate admin rights
4. The cost is minimal (just transaction fees for pubkey replacement)

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a registered candidate with a candidate admin address
- Must have previously received welcome rewards as a miner
- Must not be currently in the active miner list during replacement
- Must be able to get the new pubkey elected in a future term

**Attack Complexity:**
The attack is straightforward:
1. Register as candidate, get elected, receive welcome rewards (legitimate)
2. Mine for several terms to establish mining history
3. When not elected in a term, call `ReplaceCandidatePubkey` with a new pubkey
4. Get the new pubkey elected in a future term
5. Receive welcome rewards again for the "new" pubkey

**Feasibility Conditions:**
- Elections happen regularly (every 7 days based on term duration)
- Candidates frequently rotate in/out of the active miner set based on votes
- Pubkey replacement is a legitimate operation for key rotation/security
- The attack leaves minimal audit trail since replacement is a normal operation

**Detection Constraints:**
- The exploitation is difficult to distinguish from legitimate pubkey rotation
- No on-chain validation prevents this pattern
- Multiple candidates could independently discover and exploit this

**Probability:**
High - the conditions are naturally occurring in normal blockchain operation, and the attack requires only standard candidate privileges.

### Recommendation

**Fix 1: Always Notify Treasury on Pubkey Replacement**

Modify `AEDPoSContract.RecordCandidateReplacement` to always call `RecordMinerReplacement` regardless of current mining status, but add a flag to indicate the old pubkey's status: [7](#0-6) 

Update the call to include information about whether the pubkey was currently mining.

**Fix 2: Transfer Mining History in Treasury**

Modify `TreasuryContract.RecordMinerReplacement` to always transfer `LatestMinedTerm` history from old to new pubkey when `IsOldPubkeyEvil == false`, even if not currently in the active miner list: [8](#0-7) 

Change the logic to query the old pubkey's `LatestMinedTerm` from state and transfer it to the new pubkey, regardless of whether the call came from an active miner replacement.

**Fix 3: Add Invariant Checks**

Add a check in the `Release` method that looks up replacement history from the Election contract to verify if a "new" miner is actually a replacement: [3](#0-2) 

Cross-reference with `CandidateReplacementMap` in the Election contract before granting welcome rewards.

**Test Cases:**
1. Test pubkey replacement while actively mining (existing behavior)
2. Test pubkey replacement while NOT actively mining (new scenario to prevent)
3. Verify new pubkey after replacement does not receive welcome rewards
4. Verify legitimate new miners still receive welcome rewards
5. Test evil miner replacement scenario separately

### Proof of Concept

**Required Initial State:**
- Candidate "A" registered with admin address X
- "A" has been elected and mined in previous terms
- `LatestMinedTerm["A"] = 5` (mined up to term 5)
- Current term is 6, and "A" is NOT in the active miner list (only candidate/backup)

**Transaction Steps:**

1. **Step 1 - Verify Initial State:**
   - Query `TreasuryContract.LatestMinedTerm["A"]` → Returns 5
   - Query `AEDPoSContract.GetCurrentMinerList()` → Does not contain "A"

2. **Step 2 - Execute Pubkey Replacement:**
   - Admin X calls `ElectionContract.ReplaceCandidatePubkey(oldPubkey: "A", newPubkey: "B")`
   - Election contract bans "A" and updates candidate lists
   - AEDPoS contract checks if "A" is in current round → NO
   - AEDPoS returns early without notifying Treasury

3. **Step 3 - Verify State After Replacement:**
   - Query `TreasuryContract.LatestMinedTerm["A"]` → Still returns 5 (unchanged!)
   - Query `TreasuryContract.LatestMinedTerm["B"]` → Returns 0 (never set)
   - Query `ElectionContract.BannedPubkeyMap["A"]` → Returns true

4. **Step 4 - New Pubkey Gets Elected:**
   - "B" accumulates votes and gets elected in term 7
   - At end of term 7, `TreasuryContract.Release(periodNumber: 7)` is called

5. **Step 5 - Verify Duplicate Welcome Rewards:**
   - Release method identifies "B" as new miner (LatestMinedTerm["B"] == 0)
   - `UpdateWelcomeRewardWeights` adds "B" as beneficiary to welcome reward scheme
   - "B" receives welcome rewards despite the entity already receiving them for "A"
   - Query profit scheme shows "B" added with 1 share to `VotesWeightRewardHash`

**Expected vs Actual Result:**
- **Expected:** "B" should NOT receive welcome rewards (entity already received them)
- **Actual:** "B" receives welcome rewards as if genuinely new miner

**Success Condition:**
The exploit succeeds if `LatestMinedTerm["B"]` remains 0 after replacement while "A" is not mining, causing "B" to be treated as a new miner and receive duplicate welcome rewards.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L155-156)
```csharp
        maybeNewElectedMiners = maybeNewElectedMiners
            .Where(p => State.LatestMinedTerm[p] == 0 && !GetInitialMinerList().Contains(p)).ToList();
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L583-588)
```csharp
        if (!input.IsOldPubkeyEvil)
        {
            var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
            State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
            State.LatestMinedTerm.Remove(input.OldPubkey);
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L864-879)
```csharp
        if (newElectedMiners.Any())
        {
            Context.LogDebug(() => "Welcome reward will go to new miners.");
            var newBeneficiaries = new AddBeneficiariesInput
            {
                SchemeId = State.VotesWeightRewardHash.Value,
                EndPeriod = previousTermInformation.TermNumber.Add(1)
            };
            foreach (var minerAddress in newElectedMiners.Select(GetProfitsReceiver))
                newBeneficiaries.BeneficiaryShares.Add(new BeneficiaryShare
                {
                    Beneficiary = minerAddress,
                    Shares = 1
                });

            if (newBeneficiaries.BeneficiaryShares.Any()) State.ProfitContract.AddBeneficiaries.Send(newBeneficiaries);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L175-181)
```csharp
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L246-246)
```csharp
        State.BannedPubkeyMap[input.OldPubkey] = true;
```
