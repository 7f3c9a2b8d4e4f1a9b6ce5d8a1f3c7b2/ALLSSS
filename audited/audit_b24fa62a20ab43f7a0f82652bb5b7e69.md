### Title
Case-Insensitive Token Duplicate Registration via CrossChainCreateToken Bypass

### Summary
The `CrossChainCreateToken` method fails to validate case-insensitive token uniqueness before calling `RegisterTokenInfo`, allowing attackers to register duplicate tokens with different casing (e.g., "ABC" and "abc") as separate entities. This violates the protocol's case-insensitive token uniqueness invariant enforced by the `InsensitiveTokenExisting` state map.

### Finding Description

The vulnerability exists in how `CrossChainCreateToken` validates token existence before registration: [1](#0-0) 

This check only validates case-sensitive uniqueness via `State.TokenInfos[tokenInfo.Symbol]`, bypassing the case-insensitive duplicate check that should occur through `CheckTokenExists`.

In contrast, the normal token creation path properly prevents duplicates: [2](#0-1) 

The `CheckTokenExists` method enforces case-insensitive uniqueness: [3](#0-2) 

The `RegisterTokenInfo` method itself performs no duplicate checkingâ€”it only validates symbol format and sets the insensitive existence flag: [4](#0-3) 

Since `CrossChainCreateToken` skips `CheckTokenExists`, an attacker can register case variants (e.g., "ABC" after "abc" already exists) by providing valid cross-chain proofs.

### Impact Explanation

**Protocol Integrity Violation:**
- Breaks the fundamental invariant that token symbols must be case-insensitively unique
- Creates data inconsistency where multiple `TokenInfos` entries map to the same `InsensitiveTokenExisting` key

**User Confusion & Phishing Risk:**
- Users cannot distinguish between "ABC" and "abc" tokens visually
- Attackers can create malicious lookalike tokens to deceive users
- Token operations (transfers, approvals, burns) may target unintended symbols

**Operational Impact:**
- Future legitimate token creators may be incorrectly blocked if attempting to register a symbol whose case-variant was maliciously registered
- Token metadata queries become unreliable when multiple case-variants exist

**Severity: High** - Violates a core security invariant with concrete exploitation path, though requires cross-chain infrastructure access.

### Likelihood Explanation

**Reachable Entry Point:**
`CrossChainCreateToken` is a public method callable by any address with valid cross-chain proofs: [5](#0-4) 

**Preconditions:**
1. Source chain must be registered in `State.CrossChainTransferWhiteList` (requires governance, but once set up for legitimate cross-chain operations, remains accessible)
2. Attacker must provide valid merkle proof of a `ValidateTokenInfoExists` transaction from the source chain
3. Target symbol must not already exist with exact case in `State.TokenInfos`

**Attack Complexity:**
- **Moderate**: Requires cross-chain infrastructure setup but no special privileges beyond standard cross-chain operations
- Attacker can create token "XYZ" on source chain, then register "xyz" on target chain via `CrossChainCreateToken`
- No rate limiting or cooldown mechanisms prevent repeated exploitation

**Detection Difficulty:**
- Attack blends with legitimate cross-chain token registrations
- No events distinguish malicious from benign case-variant registrations

**Economic Rationality:**
- Cost limited to cross-chain transaction fees plus token creation costs on source chain
- High payoff if attacker creates phishing tokens mimicking high-value assets

**Likelihood: Medium** - Requires cross-chain access but is otherwise straightforward to execute once infrastructure is available.

### Recommendation

**Immediate Fix:**
Add case-insensitive duplicate check in `CrossChainCreateToken` before calling `RegisterTokenInfo`:

```csharp
// In CrossChainCreateToken, before line 506
CheckTokenExists(tokenInfo.Symbol); // Add this line

if (State.TokenInfos[tokenInfo.Symbol] == null)
{
    RegisterTokenInfo(tokenInfo);
    // ... rest of code
}
```

**Alternative: Strengthen RegisterTokenInfo**
Move the case-insensitive check into `RegisterTokenInfo` itself to ensure all callers are protected:

```csharp
private void RegisterTokenInfo(TokenInfo tokenInfo)
{
    Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
        "Invalid symbol.");
    Assert(!State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()], 
        "Token already exists (case-insensitive)."); // Add this check
    // ... rest of validation
    State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
    State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
}
```

**Test Cases:**
1. Create token "ABC" via `Create`, then attempt `CrossChainCreateToken` with "abc" - should fail
2. Create token "xyz" via `CrossChainCreateToken`, then attempt another `CrossChainCreateToken` with "XYZ" - should fail
3. Verify both `TokenInfos` and `InsensitiveTokenExisting` checks are enforced in all registration paths

### Proof of Concept

**Initial State:**
- Cross-chain transfer whitelist configured with valid source chain ID
- No token "ABC" or "abc" exists on target chain

**Exploitation Steps:**

1. **Attacker creates token "ABC" on target chain** (normal path):
   - Call `Create` with symbol "ABC"
   - Sets `State.TokenInfos["ABC"]` and `State.InsensitiveTokenExisting["ABC"] = true`

2. **Attacker registers token "abc" via cross-chain** (bypass path):
   - On source chain: Create token "abc" and call `ValidateTokenInfoExists`
   - On target chain: Call `CrossChainCreateToken` with:
     - Valid merkle proof from source chain
     - Symbol "abc" in transaction params
   - Line 506 check passes: `State.TokenInfos["abc"] == null` (true, since only "ABC" exists)
   - Line 508 executes: `RegisterTokenInfo(tokenInfo)` with symbol "abc"
   - Sets `State.TokenInfos["abc"]` and overwrites `State.InsensitiveTokenExisting["ABC"] = true`

**Result:**
- Both `State.TokenInfos["ABC"]` and `State.TokenInfos["abc"]` exist
- Only one entry `State.InsensitiveTokenExisting["ABC"] = true` exists
- Case-insensitive uniqueness invariant violated

**Success Condition:**
Query both `GetTokenInfo("ABC")` and `GetTokenInfo("abc")` - both return valid, distinct `TokenInfo` objects, proving duplicate case-variant tokens were successfully registered.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L87-88)
```csharp
        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-488)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-508)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```
