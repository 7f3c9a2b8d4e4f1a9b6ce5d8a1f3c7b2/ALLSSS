### Title
Missing Minimum Miner Participation Check in NextRound Validation Allows Premature Round Transitions Without Byzantine Fault Tolerance Consensus

### Summary
The `ValidationForNextRound()` function lacks validation to ensure that a minimum threshold of miners (MinersCountOfConsent = 2/3 + 1) have participated in the current round before allowing transition to the next round. This allows a single miner or minority coalition to force round transitions without achieving the Byzantine Fault Tolerance consensus threshold that is enforced elsewhere in the consensus system, undermining consensus integrity.

### Finding Description

The vulnerability exists in the round termination validation logic: [1](#0-0) 

The `ValidationForNextRound()` method only validates two aspects:
1. Round number increments by exactly 1
2. All `InValue` fields in the next round are null

While additional validation exists via `NextRoundMiningOrderValidationProvider`: [2](#0-1) 

This only checks that miners with `FinalOrderOfNextRound > 0` match those with `OutValue != null`, ensuring consistency between who mined and who set orders, but does NOT enforce a minimum participation threshold.

The system defines `MinersCountOfConsent` as the 2/3 + 1 threshold: [3](#0-2) 

This threshold is enforced for:
- **LIB calculation**: Requires at least MinersCountOfConsent miners before calculating Last Irreversible Block height [4](#0-3) 

- **Term changes**: Requires at least MinersCountOfConsent miners to agree on term change timing [5](#0-4) 

However, this critical threshold is **NOT enforced** in the NextRound validation flow: [6](#0-5) 

The validation providers added for NextRound behavior do not include any check that `BaseRound.GetMinedMiners().Count >= BaseRound.MinersCountOfConsent`.

### Impact Explanation

**Consensus Integrity Compromise:**
- Round transitions can occur with participation from as few as 1-2 miners in a multi-miner network
- Bypasses the fundamental Byzantine Fault Tolerance requirement of 2/3 + 1 consensus
- Creates inconsistency where LIB and term changes require 2/3 consensus but round transitions do not

**Concrete Scenario (7-miner network):**
- MinersCountOfConsent = 7 * 2/3 + 1 = 5 miners required for BFT consensus
- Only 2 miners produce blocks in round N
- These 2 miners can force transition to round N+1
- System operates with 2/7 participation (28%) instead of required 5/7 (71%)
- LIB height cannot advance (insufficient participation)
- Network effectively degraded to non-BFT operation

**Affected Parties:**
- All network participants relying on BFT consensus guarantees
- Honest miners excluded from round progression
- Applications depending on irreversible block finality (LIB cannot advance without sufficient participation)

**Severity Justification:**
This is **CRITICAL** because it directly undermines the core Byzantine Fault Tolerance properties of the consensus mechanism, allowing minority control over round progression and potentially enabling consensus manipulation attacks.

### Likelihood Explanation

**Attacker Capabilities:**
- Any miner in the network can initiate the attack
- No special privileges beyond being in the miner list
- Can coordinate with small minority coalition (e.g., 2 out of 7 miners)

**Attack Complexity:**
- LOW: Simply requires miners to produce blocks and call NextRound
- Entry point is the public `NextRound()` method: [7](#0-6) 

**Feasibility Conditions:**
- Natural network partitions or targeted DoS on majority of miners
- Coordinated collusion among minority miners
- Network conditions where majority miners are offline/unreachable
- No additional authorization required beyond miner status

**Detection Constraints:**
- System continues to function, making detection difficult
- Evil miner detection only triggers after 60*24*3 missed slots: [8](#0-7) 

- No immediate alerts for insufficient round participation
- Degraded consensus properties not explicitly monitored

**Probability:** HIGH - The attack is straightforward, requires minimal coordination, and can occur naturally during network issues.

### Recommendation

**Code-Level Mitigation:**

Add minimum participation validation in `ValidationForNextRound()`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Check round number increment
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // NEW: Check minimum miner participation (2/3 + 1 threshold)
    var minedMinersCount = validationContext.BaseRound.GetMinedMiners().Count;
    var minersCountOfConsent = validationContext.BaseRound.MinersCountOfConsent;
    if (minedMinersCount < minersCountOfConsent)
        return new ValidationResult { 
            Message = $"Insufficient miner participation: {minedMinersCount}/{minersCountOfConsent} miners required for round transition." 
        };
    
    // Check InValues are null
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

**Invariant to Enforce:**
- `GetMinedMiners().Count >= MinersCountOfConsent` before allowing NextRound transitions
- Exception: Single-node networks (Count == 1) should bypass this check

**Test Cases:**
1. Test NextRound rejection when < 2/3 miners participated
2. Test NextRound success when >= 2/3 miners participated  
3. Test single-node scenario still functions
4. Test that insufficient participation properly increments missed time slots

### Proof of Concept

**Initial State:**
- Network configured with 7 miners (Miner A, B, C, D, E, F, G)
- MinersCountOfConsent = 7 * 2/3 + 1 = 5
- Current round N with all 7 miners scheduled

**Attack Steps:**
1. Round N starts at time T0
2. Only Miner A produces a block at their time slot (T0 + interval_A)
   - Miner A's `OutValue`, `Signature` set
   - Miner A's `SupposedOrderOfNextRound` set to 1
3. Miners B, C, D, E, F miss their time slots (network partition/DoS)
4. Miner G (extra block producer) reaches their time slot at T0 + (7 * interval)
5. Miner G calls `NextRound()` with next round information showing:
   - Only Miners A and G have `FinalOrderOfNextRound` > 0
   - Only Miners A and G have non-null `OutValue` in current round
6. Validation executes:
   - `ValidationForNextRound()`: Passes (round number +1, InValues null)
   - `NextRoundMiningOrderValidationProvider`: Passes (2 miners with FinalOrderOfNextRound = 2 with OutValue)
   - Time slot validation: Passes (Miner G in valid time slot)
7. Round transitions to N+1

**Expected Result:** NextRound should be REJECTED due to insufficient miner participation (2 < 5)

**Actual Result:** NextRound SUCCEEDS, bypassing the 2/3 consensus requirement

**Success Condition:** Round N+1 is added to state with only 2/7 miners having participated in round N, violating Byzantine Fault Tolerance consensus guarantees.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L37-40)
```csharp
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```
