### Title
Blockchain Start Timestamp Manipulation via Unvalidated ActualMiningTime in Round 1

### Summary
The first miner in round 1 can provide an arbitrary future timestamp as `ActualMiningTime` in their `UpdateValue` transaction, which bypasses all validation checks and becomes the permanent blockchain start timestamp. This manipulated timestamp disrupts term transition calculations in `NeedToChangeTerm`, potentially causing premature or delayed term changes that affect governance, reward distribution, and election cycles.

### Finding Description

The vulnerability exists in the consensus timestamp initialization flow:

**Root Cause:** The contract accepts user-provided `actual_mining_time` from `UpdateValueInput` [1](#0-0)  without validating it matches the actual block production time (`Context.CurrentBlockTime`).

**Validation Bypass:** During round 1, `TimeSlotValidationProvider.CheckMinerTimeSlot` returns `true` immediately without any timestamp validation [2](#0-1) , allowing arbitrary timestamps to pass.

**Timestamp Propagation:** When generating consensus extra data, the contract adds `Context.CurrentBlockTime` to `ActualMiningTimes` in the in-memory round object [3](#0-2) . However, the actual transaction can contain different values, which get stored via `ProcessUpdateValue` [4](#0-3) .

**Hash Verification Bypass:** The round hash verification explicitly clears `ActualMiningTimes` before computing the hash [5](#0-4) , meaning manipulated timestamps won't be detected by the `ValidateConsensusAfterExecution` hash comparison [6](#0-5) .

**Permanent Impact:** During the round 1 to round 2 transition, `ProcessNextRound` permanently sets the blockchain start timestamp using the first miner's first `ActualMiningTime` [7](#0-6) , which then affects all subsequent term transition logic via `NeedToChangeTerm` [8](#0-7) .

### Impact Explanation

**Term Transition Disruption:** The `NeedToChangeTerm` function calculates: `(blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1` [9](#0-8) . With a future blockchain start timestamp, this calculation produces negative or incorrect values, causing:
- Premature term transitions (if the calculation triggers the condition incorrectly)
- Delayed term transitions (if real time must catch up to the manipulated timestamp)
- Broken term boundary detection affecting the entire consensus lifecycle

**Governance Impact:** Term transitions trigger critical governance operations including treasury releases [10](#0-9)  and election snapshots [11](#0-10) . Disrupted term timing affects:
- Miner reward distribution schedules
- Election snapshot timing and vote weight calculations  
- Treasury fund release periods

**Consensus Behavior:** The manipulated timestamp affects consensus command generation [12](#0-11)  by altering when the system decides between `NextRound` and `NextTerm` behaviors.

### Likelihood Explanation

**Attacker Capabilities:** Any miner scheduled as the first producer in round 1 can execute this attack. This is a privileged but realistic position in a bootstrapping blockchain.

**Attack Complexity:** The attack is straightforward:
1. Miner receives normal consensus command for round 1
2. Miner modifies the `actual_mining_time` field in `UpdateValueInput` to a future date
3. Miner signs and includes the modified transaction in their block
4. Validation passes due to round 1 exemption

**Execution Practicality:** The attack requires no special capabilities beyond being the first block producer. The modified transaction passes all validation because:
- `TimeSlotValidationProvider` exempts round 1
- `UpdateValueValidationProvider` only checks `OutValue`, `Signature`, and `PreviousInValue` [13](#0-12) 
- No validator compares `actual_mining_time` with `Context.CurrentBlockTime`

**Detection Constraints:** The attack is difficult to detect because the manipulated timestamp is only visible in stored state, and the system has no mechanism to verify it against real-world time or block timestamps.

### Recommendation

**Immediate Fix:** Add validation in `ProcessUpdateValue` to ensure the provided `actual_mining_time` matches `Context.CurrentBlockTime`:

```csharp
// In ProcessUpdateValue, after line 243
Assert(updateValueInput.ActualMiningTime == Context.CurrentBlockTime, 
    "Actual mining time must match block time.");
```

**Additional Safeguards:**
1. Add the same validation in `ProcessTinyBlock` for consistency
2. Include `ActualMiningTimes` in the round hash calculation or add a separate validation that checks the timestamp is within acceptable bounds of `Context.CurrentBlockTime`
3. Add a sanity check in `SetBlockchainStartTimestamp` to ensure the timestamp is not in the future relative to `Context.CurrentBlockTime`

**Test Cases:**
1. Verify that `UpdateValue` transactions with future `actual_mining_time` are rejected
2. Verify that the blockchain start timestamp cannot be set to a future date
3. Test term transition logic with edge case timestamps to ensure correct behavior

### Proof of Concept

**Initial State:**
- Blockchain is starting, round 1, term 1
- First miner (order 1) is preparing to produce the first block
- Current real time: 2024-01-01 00:00:00 (timestamp: 1704067200)

**Attack Steps:**
1. Miner requests consensus command via `GetConsensusCommand`, receives `UpdateValue` behavior
2. Miner calls `GenerateConsensusTransactions` to get suggested transaction with `actual_mining_time = Context.CurrentBlockTime = 1704067200`
3. **Attack:** Miner modifies the `UpdateValueInput.actual_mining_time` to `1735689600` (2025-01-01, one year in future)
4. Miner signs and includes modified transaction in block at height 1
5. `ValidateConsensusBeforeExecution` passes (round 1 exemption)
6. `ValidateConsensusAfterExecution` passes (ActualMiningTimes excluded from hash)
7. `ProcessUpdateValue` executes, storing future timestamp in state
8. Block proceeds to height 2, triggering round transition
9. `ProcessNextRound` calls `SetBlockchainStartTimestamp(1735689600)` - **one year in the future**
10. All subsequent `NeedToChangeTerm` calculations use this manipulated timestamp, causing incorrect term transition timing

**Expected Result:** System rejects the transaction or prevents setting a future blockchain start timestamp

**Actual Result:** Manipulated future timestamp is permanently stored and affects all future term transitions

### Citations

**File:** protobuf/aedpos_contract.proto (L194-204)
```text
message UpdateValueInput {
    // Calculated from current in value.
    aelf.Hash out_value = 1;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 2;
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
    // Publish previous in value for validation previous signature and previous out value.
    aelf.Hash previous_in_value = 4;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    google.protobuf.Timestamp actual_mining_time = 5;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L117-123)
```csharp
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-243)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-243)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }

    /// <summary>
    ///     If periodSeconds == 7:
    ///     1, 1, 1 => 0 != 1 - 1 => false
    ///     1, 2, 1 => 0 != 1 - 1 => false
    ///     1, 8, 1 => 1 != 1 - 1 => true => term number will be 2
    ///     1, 9, 2 => 1 != 2 - 1 => false
    ///     1, 15, 2 => 2 != 2 - 1 => true => term number will be 3.
    /// </summary>
    /// <param name="blockchainStartTimestamp"></param>
    /// <param name="termNumber"></param>
    /// <param name="blockProducedTimestamp"></param>
    /// <param name="periodSeconds"></param>
    /// <returns></returns>
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```
