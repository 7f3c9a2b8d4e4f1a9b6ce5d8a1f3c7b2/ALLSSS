### Title
State Corruption via Unauthorized EnableConnector Leading to Negative DepositBalance and Invalid Accounting

### Summary
The `EnableConnector` method lacks access control and overwrites `State.DepositBalance` with a recalculated value, ignoring accumulated balances from prior trading activity. This enables any user to corrupt the deposit accounting, causing `DepositBalance` to become negative during subsequent `Sell` operations. The view function `GetDepositConnectorBalance` reports these invalid states without validation or error.

### Finding Description

The vulnerability exists in the `EnableConnector` method which OVERWRITES the deposit balance instead of validating or incrementing it: [1](#0-0) 

Unlike other connector management methods (`UpdateConnector`, `AddPairConnector`, `ChangeConnectorController`), `EnableConnector` has NO access control check: [2](#0-1) 

Compare with protected methods: [3](#0-2) [4](#0-3) 

The `GetNeededDeposit` calculation determines deposit requirements based on circulating token supply, NOT existing accumulated balance: [5](#0-4) 

When `EnableConnector` is called on already-active connectors with accumulated `DepositBalance` from prior `Buy` operations: [6](#0-5) 

The overwritten value is typically LOWER than the actual accumulated balance. Subsequent `Sell` operations decrement this corrupted balance: [7](#0-6) 

The `Sub()` method uses `checked` arithmetic which only prevents overflow beyond `long.MinValue`, NOT negative values within the valid long range: [8](#0-7) 

The view function returns the invalid state without validation: [9](#0-8) 

### Impact Explanation

**Direct Fund Impact**: The corrupted accounting enables users to withdraw more base tokens than the accounting system tracks, eventually driving `DepositBalance` negative. While actual token transfers are constrained by real contract balance, the accounting corruption breaks critical invariants:

1. **Reserve Tracking Failure**: Negative `DepositBalance` causes `GetDepositConnectorBalance` to report incorrect reserve levels (VirtualBalance + negative value), breaking Bancor pricing assumptions
2. **Protocol Insolvency Risk**: If `DepositBalance` becomes sufficiently negative, the reported balance could go below zero or significantly understated, potentially blocking legitimate `Sell` operations when pricing calculations fail
3. **Trust Compromise**: External integrations and dashboards relying on `GetDepositConnectorBalance` receive invalid data without error indication

**Affected Parties**: All users relying on TokenConverter pricing accuracy, protocol treasury operations, and external systems querying connector balances.

**Severity**: HIGH - While not direct theft, accounting corruption undermines the entire Bancor pricing mechanism and can cause cascading protocol failures.

### Likelihood Explanation

**Attacker Capabilities**: Any EOA or contract can call `EnableConnector` - no special privileges required. The method is completely unrestricted.

**Attack Complexity**: Trivial - single transaction calling `EnableConnector` with appropriate parameters after normal trading activity has accumulated deposit balance.

**Feasibility Conditions**: 
- Connector pair must be already enabled with active trading
- Prior `Buy` operations must have accumulated `DepositBalance`
- Attack succeeds whenever calculated `needDeposit` is less than existing `DepositBalance`

**Detection Difficulty**: The attack transaction appears legitimate (enabling a connector), making it hard to distinguish from normal operations. State corruption manifests gradually through subsequent `Sell` operations.

**Probability**: HIGH - The vulnerability is always exploitable once connectors are active and trading occurs.

### Recommendation

**Immediate Fix**: Add access control and prevent re-enabling active connectors:

```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    AssertPerformedByConnectorController(); // Add authorization check
    
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
    
    // Prevent re-enabling active connectors
    Assert(!fromConnector.IsPurchaseEnabled, "Connector already enabled");
    Assert(!toConnector.IsPurchaseEnabled, "Connector already enabled");
    
    // ... rest of method
}
```

**Additional Safeguards**:

1. Add explicit validation before decrementing `DepositBalance` in `Sell`:
```csharp
Assert(State.DepositBalance[toConnector.Symbol] >= amountToReceive, 
    "Insufficient deposit balance");
State.DepositBalance[toConnector.Symbol] = 
    State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

2. Add validation in view function:
```csharp
public override Int64Value GetDepositConnectorBalance(StringValue symbolInput)
{
    var connector = State.Connectors[symbolInput.Value];
    Assert(connector != null && !connector.IsDepositAccount, "token symbol is invalid");
    var ntSymbol = connector.RelatedSymbol;
    var depositBalance = State.DepositBalance[ntSymbol];
    Assert(depositBalance >= 0, "Invalid deposit balance state");
    return new Int64Value
    {
        Value = State.Connectors[ntSymbol].VirtualBalance + depositBalance
    };
}
```

**Test Cases**:
- Verify `EnableConnector` requires authorization
- Verify `EnableConnector` fails on already-enabled connectors  
- Verify `Sell` fails if `DepositBalance` would go negative
- Verify `GetDepositConnectorBalance` reports errors for negative states

### Proof of Concept

**Initial State**:
1. TokenConverter initialized with WRITE/NT_WRITE connector pair (VirtualBalance=1,000,000, Weight=0.5)
2. 1,000,000 WRITE tokens issued to contract
3. `EnableConnector(TokenSymbol="WRITE", AmountToTokenConvert=1,000,000)` called
4. Initial `State.DepositBalance[NT_WRITE] = 0` (no circulating tokens)

**Normal Trading Phase**:
5. User1: `Buy(Symbol="WRITE", Amount=200,000)` - deposits 100,000 ELF
   - `State.DepositBalance[NT_WRITE] = 100,000`
6. User2: `Buy(Symbol="WRITE", Amount=200,000)` - deposits 150,000 ELF (higher price)
   - `State.DepositBalance[NT_WRITE] = 250,000`
   - Contract holds 250,000 ELF actual balance

**Attack Transaction**:
7. Attacker: `EnableConnector(TokenSymbol="WRITE", AmountToTokenConvert=0)`
   - Current: 400,000 WRITE circulating, 600,000 in contract
   - `GetNeededDeposit` calculates: `amountOutOfTokenConvert = 1,000,000 - 600,000 - 0 = 400,000`
   - Bancor calculates `needDeposit ≈ 80,000` (to back 400,000 circulating tokens)
   - Line 297: `State.DepositBalance[NT_WRITE] = 80,000` (OVERWRITES 250,000!)
   - Actual balance remains 250,000 ELF

**Exploitation**:
8. User3: `Sell(Symbol="WRITE", Amount=200,000)`
   - `GetSelfBalance(NT_WRITE) = 1,000,000 + 80,000 = 1,080,000`
   - Bancor calculates `amountToReceive = 120,000` ELF
   - Transfer succeeds (contract has 250,000 actual ELF)
   - Line 193-194: `State.DepositBalance[NT_WRITE] = 80,000 - 120,000 = -40,000` ❌

**Result Verification**:
9. Call `GetDepositConnectorBalance(Symbol="WRITE")`
   - Returns: `1,000,000 + (-40,000) = 960,000` (invalid negative accounting)
   - NO error thrown despite corrupted state

**Expected**: `DepositBalance` should never go negative; operations should fail with explicit errors

**Actual**: `DepositBalance` becomes `-40,000`, view function reports invalid state without error

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-60)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-81)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L141-141)
```csharp
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-300)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-84)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L93-102)
```csharp
    public override Int64Value GetDepositConnectorBalance(StringValue symbolInput)
    {
        var connector = State.Connectors[symbolInput.Value];
        Assert(connector != null && !connector.IsDepositAccount, "token symbol is invalid");
        var ntSymbol = connector.RelatedSymbol;
        return new Int64Value
        {
            Value = State.Connectors[ntSymbol].VirtualBalance + State.DepositBalance[ntSymbol]
        };
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```
