# Audit Report

## Title
User Contract Authorization Bypass via isUserContract Flag Manipulation During Updates

## Summary
User contract authors can bypass the stricter miner-based authorization model by updating their contracts through `ProposeUpdateContract` instead of `UpdateUserSmartContract`. This permanently flips the `isUserContract` flag from `true` to `false`, allowing all future updates to bypass miner approval and use only Parliament governance instead.

## Finding Description

The vulnerability exists in the contract update flow within the Genesis contract (Contract Zero). User contracts are designed with a stricter authorization model that requires current miner approval for updates. However, contract authors can subvert this model by using the wrong update path.

**Root Cause:**

When `ProposeUpdateContract` is called, it only preserves the `IsSystemContract` flag but completely ignores the `isUserContract` flag [1](#0-0) . The method routes to `UpdateSmartContract` as the code check release method [2](#0-1) .

The authorization check only validates that the sender is the contract author, with no validation preventing user contracts from being updated through this path [3](#0-2) .

When the public `UpdateSmartContract` method executes, it calls the private helper with `isUserContract` hardcoded to `false` [4](#0-3) .

The private helper unconditionally overwrites the contract info with this value [5](#0-4) , permanently changing the contract from a user contract to a regular contract.

**Bypassed Security Model:**

User contracts are designed to require miner authorization through `ReleaseApprovedUserSmartContract`, which enforces `AssertCurrentMiner()` [6](#0-5) .

Once the flag is flipped, subsequent updates use `ReleaseCodeCheckedContract` instead, which only validates the proposer matches [7](#0-6)  with no miner authorization requirement.

The correct path for user contract updates through `PerformUpdateUserSmartContract` properly preserves the flag by passing `true` [8](#0-7) .

## Impact Explanation

This is a **High** severity governance vulnerability because:

1. **Authorization Model Bypass**: User contracts were intentionally designed with stricter authorization requiring miner approval. This vulnerability allows authors to unilaterally downgrade this security model to Parliament-only governance.

2. **Permanent State Corruption**: Once the `isUserContract` flag is flipped to `false`, the contract permanently loses its user contract status. All future updates will bypass miner authorization.

3. **Protocol Invariant Violation**: Contract types should be immutable after deployment. Users deploying user contracts expect the stricter miner-based governance model to remain in place permanently.

4. **Trust Violation**: Stakeholders who interact with or depend on a user contract make decisions based on its governance model. Silent alteration of this model betrays their trust and security assumptions.

5. **Wide Attack Surface**: Any user contract author can execute this attack, affecting all user contracts on the chain.

## Likelihood Explanation

**High Likelihood** - The attack is easily executable with minimal prerequisites:

**Attacker Capabilities:**
- Must be the author of a user contract (obtainable by deploying one via `DeployUserSmartContract`)
- Requires Parliament approval for the update (same governance process as legitimate updates)

**Attack Complexity:**
- **Low** - The attacker simply calls `ProposeUpdateContract` instead of `UpdateUserSmartContract`
- Both methods are public and accessible to contract authors
- No technical sophistication required

**Feasibility:**
1. Deploy a user contract via standard mechanisms
2. Call `ProposeUpdateContract(userContractAddress, newCode)`
3. Obtain Parliament approval (standard governance)
4. Pass code check
5. Flag automatically flips during `UpdateSmartContract` execution

**Detection Constraints:**
- The flag change happens silently within state updates
- No events or logs indicate the contract type has changed
- Users have no way to detect this has occurred until examining contract state directly

## Recommendation

Add validation in `ProposeUpdateContract` to prevent user contracts from being updated through this path:

```csharp
public override Hash ProposeUpdateContract(ContractUpdateInput input)
{
    var proposedContractInputHash = CalculateHashFromInput(input);
    RegisterContractProposingData(proposedContractInputHash);

    var contractAddress = input.Address;
    var info = State.ContractInfos[contractAddress];
    Assert(info != null, "Contract not found.");
    
    // ADD THIS CHECK:
    Assert(!info.IsUserContract, "User contracts must use UpdateUserSmartContract method.");
    
    AssertAuthorityByContractInfo(info, Context.Sender);
    // ... rest of method
}
```

Alternatively, preserve the `isUserContract` flag in `ProposeUpdateContract` similar to how `IsSystemContract` is preserved:

```csharp
Params = new ContractCodeCheckInput
{
    ContractInput = input.ToByteString(),
    CodeCheckReleaseMethod = nameof(UpdateSmartContract),
    ProposedContractInputHash = proposedContractInputHash,
    Category = info.Category,
    IsSystemContract = info.IsSystemContract,
    IsUserContract = info.IsUserContract  // ADD THIS
}.ToByteString(),
```

And modify `UpdateSmartContract` to use this flag instead of hardcoding `false`.

## Proof of Concept

```csharp
[Fact]
public async Task UserContract_CanBypassMinerAuthorization_ViaWrongUpdatePath()
{
    // 1. Deploy a user contract
    var userContractCode = ByteString.CopyFrom(/* valid contract code */);
    var deployInput = new UserContractDeploymentInput
    {
        Category = 0,
        Code = userContractCode
    };
    
    var deployResult = await ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.DeployUserSmartContract),
        deployInput
    );
    
    var contractAddress = GetContractAddressFromDeploymentResult(deployResult);
    
    // Verify it's a user contract
    var info1 = await CallContractMethodAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.GetContractInfo),
        contractAddress
    );
    var contractInfo1 = ContractInfo.Parser.ParseFrom(info1);
    Assert.True(contractInfo1.IsUserContract); // Should be true
    
    // 2. Update via WRONG path (ProposeUpdateContract instead of UpdateUserSmartContract)
    var newCode = ByteString.CopyFrom(/* updated contract code */);
    var updateInput = new ContractUpdateInput
    {
        Address = contractAddress,
        Code = newCode
    };
    
    var updateResult = await ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.ProposeUpdateContract),
        updateInput
    );
    
    // 3. Approve through Parliament (NOT miner approval)
    var proposalId = GetProposalIdFromResult(updateResult);
    await ApproveWithParliamentAsync(proposalId);
    
    // 4. Release via ReleaseCodeCheckedContract (NOT ReleaseApprovedUserSmartContract)
    var releaseResult = await ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.ReleaseCodeCheckedContract),
        new ReleaseContractInput { ProposalId = proposalId, /* ... */ }
    );
    
    // 5. Verify the flag was flipped
    var info2 = await CallContractMethodAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.GetContractInfo),
        contractAddress
    );
    var contractInfo2 = ContractInfo.Parser.ParseFrom(info2);
    Assert.False(contractInfo2.IsUserContract); // Flag is now FALSE - VULNERABILITY CONFIRMED
    
    // 6. Future updates will bypass miner authorization
    // All subsequent updates can now use Parliament-only governance
}
```

**Notes:**
- The vulnerability is confirmed through direct code analysis showing the flag manipulation path
- Tests in `GenesisContractAuthTest.cs` show expected behavior maintains `IsUserContract = true` through proper update path [9](#0-8) 
- No existing tests validate the security invariant that user contracts cannot be updated via `ProposeUpdateContract`
- The authorization model difference between `ReleaseApprovedUserSmartContract` and `ReleaseCodeCheckedContract` is the core security boundary being bypassed

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L183-183)
```csharp
        AssertAuthorityByContractInfo(info, Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L212-212)
```csharp
                    CodeCheckReleaseMethod = nameof(UpdateSmartContract),
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L215-215)
```csharp
                    IsSystemContract = info.IsSystemContract
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L299-299)
```csharp
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L334-334)
```csharp
        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L485-485)
```csharp
        AssertCurrentMiner();
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L514-514)
```csharp
        UpdateSmartContract(input.Address, input.Code.ToByteArray(), proposingInput.Author, true);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L110-110)
```csharp
        info.IsUserContract = isUserContract;
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L1812-1819)
```csharp
        contractInfo.IsUserContract.ShouldBeTrue();
        contractInfo.IsSystemContract.ShouldBeFalse();
        contractInfo.Author.ShouldBe(Address.FromPublicKey(CreatorKeyPair.PublicKey));
        
        registration = await SideChainTester.CallContractMethodAsync(SideBasicContractZeroAddress,
            nameof(ACS0Container.ACS0Stub.GetSmartContractRegistrationByCodeHash), contractInfo.CodeHash);
        smartContractRegistration = SmartContractRegistration.Parser.ParseFrom(registration);
        smartContractRegistration.IsUserContract.ShouldBeTrue();
```
