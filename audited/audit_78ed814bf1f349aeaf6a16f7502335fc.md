### Title
Invalid FinalOrderOfNextRound Values Enable Consensus Disruption Through Malicious Order Assignment

### Summary
Miners can inject arbitrary `FinalOrderOfNextRound` values (including 0, duplicates, or values exceeding `minersCount`) via the `UpdateValue` method's `TuneOrderInformation` parameter without validation. These invalid values are used directly in `GenerateNextRoundInformation()` to assign mining orders for the next round, creating invalid consensus states with duplicate orders, missing miners, or out-of-range order values that can crash consensus execution or exclude legitimate miners from block production.

### Finding Description

**Root Cause - Unvalidated Order Assignment:**

In `ProcessUpdateValue`, the `TuneOrderInformation` from user input is applied directly to `FinalOrderOfNextRound` without any bounds checking or duplicate validation: [1](#0-0) 

The `UpdateValueInput` protobuf allows arbitrary `int32` values in the `tune_order_information` map: [2](#0-1) 

**Vulnerable Code Path:**

When `GenerateNextRoundInformation()` processes the next round, it uses these unvalidated `FinalOrderOfNextRound` values directly: [3](#0-2) 

The `occupiedOrders` calculation simply collects whatever values exist, including invalid ones: [4](#0-3) 

**Why Existing Protections Fail:**

The `NextRoundMiningOrderValidationProvider` only checks that the count of miners with `FinalOrderOfNextRound > 0` matches miners who mined, using `Distinct()` on `MinerInRound` objects (not on order values), which fails to detect duplicate order values or out-of-range values: [5](#0-4) 

**Downstream Crash Points:**

The `BreakContinuousMining` function expects specific orders to exist and uses `First()` which throws exceptions if orders 1, 2, or `minersCount-1` are missing: [6](#0-5) [7](#0-6) 

### Impact Explanation

**Consensus Integrity Violation:**

1. **Duplicate Orders**: Two miners assigned the same order compete for the same time slot, causing conflicting block production and consensus ambiguity.

2. **Missing Orders**: Valid orders (1 through `minersCount`) are skipped, causing gaps in the mining schedule. The `ableOrders` calculation becomes incorrect when `occupiedOrders` contains 0 or values > `minersCount`, preventing proper assignment of remaining miners.

3. **Invalid Order Values**: 
   - Order = 0: Creates a miner scheduled to mine at the current block timestamp (in the past), bypassing time-slot validation
   - Order > `minersCount`: Creates out-of-range orders that break schedule integrity

4. **Consensus Execution Crashes**: The `BreakContinuousMining` function will crash with `InvalidOperationException` if expected orders (1, 2, `minersCount`, or `minersCount-1`) don't exist due to malicious assignments.

5. **Miner Exclusion**: Dictionary key-based assignment in the generation loop means miners with duplicate orders overwrite each other, causing legitimate miners who successfully mined to be excluded from the next round.

**Affected Components:**
- All miners attempting to participate in consensus
- Block production scheduling and time-slot validation  
- Round transition logic and irreversible block height calculation
- Cross-chain verification that depends on valid consensus state

**Severity:** HIGH - Directly compromises consensus integrity, a critical invariant. Can cause DoS of consensus or exclude legitimate miners from block production.

### Likelihood Explanation

**Attacker Capabilities:**
- Any active miner in the current miner list can call `UpdateValue` (public method with only miner-list permission check) [8](#0-7) [9](#0-8) 

**Attack Complexity:** LOW
1. Malicious miner calls `UpdateValue` with crafted `TuneOrderInformation` containing invalid values
2. Values are stored immediately without validation
3. Next round generation uses these invalid values
4. Consensus breaks or miners are excluded

**Feasibility Conditions:**
- Attacker must be an active miner (elected to consensus participation)
- Single transaction execution required
- No special timing or state requirements
- Economically rational for miners to attack competitors or disrupt consensus

**Detection Constraints:**
- No events or logs indicate malicious `FinalOrderOfNextRound` assignment
- Validation only occurs when `NextRound` is called, after damage is done
- Existing validation is insufficient to catch the exploit

**Probability:** HIGH - Any malicious miner can execute this attack with a single transaction at any time during their mining slot.

### Recommendation

**Immediate Mitigation:**

Add strict validation in `ProcessUpdateValue` before applying `TuneOrderInformation`:

```csharp
// In ProcessUpdateValue, before line 259
var minersCount = currentRound.RealTimeMinersInformation.Count;
var usedOrders = new HashSet<int>();

foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    // Validate order is within valid range [1, minersCount]
    Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount,
        $"Invalid order value {tuneOrder.Value}. Must be between 1 and {minersCount}.");
    
    // Validate no duplicate orders
    Assert(!usedOrders.Contains(tuneOrder.Value),
        $"Duplicate order value {tuneOrder.Value} detected.");
    
    usedOrders.Add(tuneOrder.Value);
    
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

**Additional Hardening:**

Enhance `NextRoundMiningOrderValidationProvider` to validate order value ranges and uniqueness:

```csharp
// Check for valid order range and uniqueness
var orders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();

var minersCount = providedRound.RealTimeMinersInformation.Count;
var distinctOrders = orders.Distinct().ToList();

if (orders.Count != distinctOrders.Count)
{
    validationResult.Message = "Duplicate FinalOrderOfNextRound values detected.";
    return validationResult;
}

if (distinctOrders.Any(o => o < 1 || o > minersCount))
{
    validationResult.Message = "FinalOrderOfNextRound values out of valid range.";
    return validationResult;
}
```

**Test Cases:**
1. Attempt to set `FinalOrderOfNextRound = 0` via `TuneOrderInformation` → should fail
2. Attempt to set `FinalOrderOfNextRound > minersCount` → should fail  
3. Attempt to set duplicate `FinalOrderOfNextRound` values for different miners → should fail
4. Verify all miners receive unique orders in range [1, minersCount] after round generation

### Proof of Concept

**Initial State:**
- 5 active miners in current round: M1, M2, M3, M4, M5
- M1, M2, M3 have mined blocks (have `OutValue != null`)
- M4, M5 have not mined

**Attack Sequence:**

**Step 1:** Malicious miner M2 calls `UpdateValue` with crafted input:
```
UpdateValueInput {
  TuneOrderInformation: {
    "M1_pubkey": 2,
    "M2_pubkey": 2,  // Duplicate order
    "M3_pubkey": 0   // Invalid order
  }
}
```

**Step 2:** Values are stored in current round without validation (line 259-260 of ProcessUpdateValue).

**Step 3:** When `NextRound` is called, `GenerateNextRoundInformation` executes:
- M3 gets Order = 0 (invalid, scheduled for past time)
- M1 and M2 both get Order = 2 (duplicate time slot)
- `occupiedOrders` = [0, 2, 2]
- `ableOrders` = Range(1,5).Where(i => ![0,2,2].Contains(i)) = [1, 3, 4, 5]
- M4 assigned Order = 1
- M5 assigned Order = 3

**Expected Result:** All 5 miners should have unique orders in range [1, 5].

**Actual Result:** 
- M3 has invalid Order = 0
- M1 and M2 both have Order = 2 (collision)
- Orders 4 and 5 are never assigned
- When `BreakContinuousMining` tries to find a miner with Order = 5, it returns null (line 94), causing subsequent logic errors
- Consensus round is corrupted with invalid miner schedule

**Success Condition:** The attack succeeds if the next round contains duplicate orders, invalid orders (0 or > 5), or missing orders, breaking the consensus invariant that each miner must have a unique order in [1, minersCount].

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-330)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-84)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L93-101)
```csharp
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
