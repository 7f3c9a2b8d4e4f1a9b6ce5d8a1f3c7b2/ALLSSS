### Title
Users Lose 100 ELF When Calling Create on Sidechains Due to Chain-Agnostic Fee Configuration

### Summary
The `GetMethodFee()` function returns a hardcoded fee of 100 ELF for the `Create` method regardless of which chain it is called from, while the `Create()` method itself is restricted to execute only on the AELF mainchain. This mismatch causes users on sidechains to lose 100 ELF in transaction fees even though the Create operation is guaranteed to fail due to the chain ID assertion.

### Finding Description

The vulnerability exists due to inconsistent cross-chain handling between the fee configuration and method execution logic:

**Fee Configuration (Chain-Agnostic):**
The `GetMethodFee()` function returns a hardcoded fee of 100_00000000 (100 ELF) for the Create method without checking the current chain context. [1](#0-0) 

**Method Restriction (Mainchain-Only):**
The `Create()` method has an assertion that restricts execution to the AELF mainchain only, failing immediately on sidechains. [2](#0-1) 

**Fee Charging Mechanism:**
In AElf's fee system, before any transaction executes, a pre-execution plugin generates a fee charging transaction that calls `ChargeTransactionFees`, which in turn calls the target contract's `GetMethodFee()` to determine the fee amount. [3](#0-2) 

The pre-execution flow generates fee charging transactions before the main transaction executes. [4](#0-3) 

**Execution Flow on Sidechains:**
1. User calls `Create()` on a sidechain
2. Pre-execution plugin generates a fee charging transaction
3. `ChargeTransactionFees` calls `GetMethodFee("Create")` â†’ returns 100 ELF
4. 100 ELF is successfully charged from the user's account
5. Main transaction executes: `Create()` immediately fails at chain ID assertion
6. User has lost 100 ELF with no benefit

**Why Existing Protections Fail:**
- `GetMethodFee()` does not check `Context.ChainId` before returning the fee
- The fee is charged in the pre-execution phase before the mainchain restriction is evaluated
- There is no refund mechanism for failed transactions after successful fee charging

### Impact Explanation

**Direct Financial Loss:**
Users on sidechains lose exactly 100_00000000 base units (100 ELF with 8 decimals) per failed Create attempt. This is a significant financial loss with no corresponding service provided.

**Affected Users:**
Any user attempting to create an NFT protocol on a sidechain will experience this loss. This particularly affects:
- Users who are unaware of the mainchain-only restriction
- Users who accidentally call Create from a sidechain wallet
- Developers testing NFT creation on sidechains

**Protocol Damage:**
This creates a poor user experience and erodes trust in the platform. Users may perceive it as a bug or fee trap, especially since the alternative `CrossChainCreate()` method exists for sidechains but doesn't charge this fee through `GetMethodFee()`.

### Likelihood Explanation

**Attack Complexity:** 
No attack is required - this is a design flaw that affects normal user behavior. Users simply need to call the public `Create()` method from a sidechain.

**Attacker Capabilities:**
No special privileges or knowledge required. Any regular user can trigger this by calling Create on a sidechain.

**Feasibility Conditions:**
- User must be on a sidechain (not mainchain)
- User must have at least 100 ELF balance for the fee charge to succeed
- No other preconditions required

**Probability:**
Moderate to high probability of occurrence:
- The Create method is a primary entry point for NFT protocol creation
- Users on sidechains may naturally attempt to create protocols there
- The error message only appears after fee is charged, providing no prevention
- The NFT contract proto file exposes Create as a normal RPC without indicating mainchain restriction [5](#0-4) 

### Recommendation

**Immediate Fix:**
Modify `GetMethodFee()` to check the chain context and return zero fees for the Create method when called on sidechains:

```csharp
public override MethodFees GetMethodFee(StringValue input)
{
    if (input.Value == nameof(Create))
    {
        // Only charge fee on mainchain where Create can actually execute
        if (Context.ChainId != ChainHelper.ConvertBase58ToChainId("AELF"))
        {
            return new MethodFees();
        }
        
        return new MethodFees
        {
            MethodName = input.Value,
            Fees =
            {
                new MethodFee
                {
                    Symbol = Context.Variables.NativeSymbol,
                    BasicFee = 100_00000000
                }
            }
        };
    }

    return new MethodFees();
}
```

**Additional Improvements:**
1. Add a view method to check if Create is available on the current chain
2. Update documentation and proto comments to clearly indicate the mainchain restriction
3. Add integration tests that verify no fees are charged on sidechains for mainchain-only methods
4. Consider adding a general pattern for chain-specific method fees across all contracts

### Proof of Concept

**Initial State:**
- Sidechain network is operational
- User has NFT contract address and 100+ ELF balance
- User wants to create an NFT protocol

**Transaction Steps:**
1. User on sidechain calls `NFTContract.Create(CreateInput)`
2. Pre-execution plugin generates fee charging pre-transaction
3. TokenContract.ChargeTransactionFees executes successfully
4. User's balance is reduced by 100 ELF
5. Main transaction executes: Create() method runs
6. Assertion fails at line 16: "NFT Protocol can only be created at aelf mainchain."
7. Transaction completes with failure

**Expected Result:**
Either fees should not be charged on sidechains, or Create should succeed.

**Actual Result:**
User loses 100 ELF and Create fails. The fee is not refunded.

**Success Condition:**
User balance decreases by 100 ELF, but no NFT protocol is created. Transaction fee events are fired, but the Create operation fails.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L16-17)
```csharp
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-39)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L58-113)
```csharp
    public async Task<IEnumerable<Transaction>> GetPreTransactionsAsync(IReadOnlyList<ServiceDescriptor> descriptors,
        ITransactionContext transactionContext)
    {
        try
        {
            var chainContext = new ChainContext
            {
                BlockHash = transactionContext.PreviousBlockHash,
                BlockHeight = transactionContext.BlockHeight - 1
            };

            var tokenContractAddress = await _smartContractAddressService.GetAddressByContractNameAsync(
                chainContext,
                TokenSmartContractAddressNameProvider.StringName);

            if (transactionContext.BlockHeight < AElfConstants.GenesisBlockHeight + 1 ||
                tokenContractAddress == null)
                return new List<Transaction>();

            if (!IsApplicableToTransaction(descriptors, transactionContext.Transaction, tokenContractAddress))
                return new List<Transaction>();

            var tokenStub = _contractReaderFactory.Create(new ContractReaderContext
            {
                Sender = transactionContext.Transaction.From,
                ContractAddress = tokenContractAddress,
                RefBlockNumber = transactionContext.Transaction.RefBlockNumber
            });

            if (IsExemptedTransaction(transactionContext.Transaction, tokenContractAddress, tokenStub))
                return new List<Transaction>();

            var txCost = await _txFeeService.CalculateFeeAsync(transactionContext, chainContext);
            var chargeTransactionFeesInput = new ChargeTransactionFeesInput
            {
                MethodName = transactionContext.Transaction.MethodName,
                ContractAddress = transactionContext.Transaction.To,
                TransactionSizeFee = txCost
            };

            var transactionSizeFeeSymbols =
                await _transactionSizeFeeSymbolsProvider.GetTransactionSizeFeeSymbolsAsync(chainContext);
            if (transactionSizeFeeSymbols != null)
                foreach (var transactionSizeFeeSymbol in transactionSizeFeeSymbols.TransactionSizeFeeSymbolList)
                    chargeTransactionFeesInput.SymbolsToPayTxSizeFee.Add(new SymbolToPayTxSizeFee
                    {
                        TokenSymbol = transactionSizeFeeSymbol.TokenSymbol,
                        BaseTokenWeight = transactionSizeFeeSymbol.BaseTokenWeight,
                        AddedTokenWeight = transactionSizeFeeSymbol.AddedTokenWeight
                    });

            var chargeFeeTransaction = GetTransaction(tokenStub, chargeTransactionFeesInput);
            return new List<Transaction>
            {
                chargeFeeTransaction
            };
```

**File:** protobuf/nft_contract.proto (L22-24)
```text
    // Create a new nft protocol.
    rpc Create (CreateInput) returns (google.protobuf.StringValue) {
    }
```
