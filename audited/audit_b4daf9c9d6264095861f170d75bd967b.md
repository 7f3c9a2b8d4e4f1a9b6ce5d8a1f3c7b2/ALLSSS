# Audit Report

## Title
First Round Mining Logic Uses Wrong Reference Point, Allowing Unauthorized Block Production

## Summary
The `IsCurrentMiner` function contains a critical logic error in its first round special case handling. When determining if a miner is authorized to produce blocks during round 1, the code incorrectly orders miners by their `Order` field (a predetermined positional value) instead of their actual mining timestamps. This causes the time-slot authorization calculation to use the wrong reference point, allowing miners to produce blocks and claim transaction fees when they should not be authorized.

## Finding Description

The vulnerability exists in the first round special case logic within the `IsCurrentMiner` function. [1](#0-0) 

**Root Cause:**

The code attempts to find the "latest mined" miner by ordering miners by their `Order` field in descending order. [2](#0-1) 

However, the `Order` field represents a miner's predetermined sequence position in the round (assigned during round generation), not the actual chronological time when they mined. [3](#0-2) 

The `ActualMiningTimes` field is a chronological list that records the actual timestamps when blocks were produced. Each time a miner produces a block (normal or tiny block), a timestamp is added to this list. [4](#0-3) [5](#0-4) 

**Why This Matters:**

The code uses the wrong miner's `ActualMiningTimes.Last()` as the reference point for calculating how many time slots have passed. This calculation then determines if the current miner is authorized to produce a block. If the reference point is wrong (using a miner with high Order but earlier mining time instead of the chronologically most recent miner), the `passedSlotsCount` calculation becomes incorrect, potentially authorizing miners when insufficient time has actually elapsed since the last block.

**Why Normal Protections Don't Apply:**

The first round logic exists specifically because `ExpectedMiningTimes` are unreliable when the blockchain starts with a misconfigured `StartTimestamp`. [6](#0-5)  This special case bypasses the normal time-slot validation checks, relying instead on this flawed calculation.

## Impact Explanation

**Direct Impact:**
1. **Unauthorized Block Production**: Miners can produce blocks in round 1 when they should not be authorized based on proper time-slot rules, earning block rewards they don't deserve.

2. **Unauthorized Transaction Fee Claiming**: The `ClaimTransactionFees` function in the MultiToken contract uses `IsCurrentMiner` to validate authorization. [7](#0-6) [8](#0-7)  If `IsCurrentMiner` returns true incorrectly, unauthorized miners can claim transaction fees.

3. **Consensus Integrity**: The fundamental guarantee that only the authorized miner for each time slot can produce blocks is violated during round 1 of every term.

**Affected Parties:**
- Honest miners who lose their fair share of block rewards and transaction fees
- The protocol's consensus fairness is compromised at every term transition
- With typical configurations (21+ miners, ~4 second intervals), unauthorized blocks can represent significant value

**Severity:** High - This breaks core consensus authorization guarantees and enables concrete fund extraction (block rewards + transaction fees) at predictable intervals (every term change).

## Likelihood Explanation

**Triggering Conditions:**
1. Round 1 of any term begins (happens at every term transition)
2. Multiple miners produce blocks, including tiny blocks (normal operation)
3. Miners produce blocks in an order different from their positional `Order` values (highly likely with 21+ miners)

**Attack Complexity:** Low to Medium. The vulnerability can manifest naturally without intentional exploitation. When a miner with a lower `Order` number produces a block after a miner with a higher `Order` number (which happens frequently in round 1), the flawed logic selects the wrong reference point.

**Feasibility:** Very high. Round 1 occurs at every term transition. The first round special case logic is documented to be active on AElf Main Chain due to the `Timestamp{Seconds=0}` configuration. With multiple miners producing tiny blocks, the scenario where the highest-Order miner is not the chronologically latest miner occurs regularly.

**Detection Difficulty:** High. The blocks appear valid and all nodes execute the same flawed logic, so the incorrect authorizations are consensus-wide and difficult to detect without careful analysis.

**Overall Likelihood:** High - Occurs naturally during every round 1 of each term.

## Recommendation

Fix the reference point selection to use chronological order instead of positional Order:

```csharp
// Instead of ordering by Order (positional), order by ActualMiningTimes.Last() (chronological)
var latestMinedInfo =
    currentRound.RealTimeMinersInformation.Values
        .Where(i => i.ActualMiningTimes.Any() && i.Pubkey != pubkey)
        .OrderByDescending(i => i.ActualMiningTimes.Last())
        .FirstOrDefault();
```

This ensures that `latestMinedSlotLastActualMiningTime` correctly reflects the most recent block production time, making the `passedSlotsCount` calculation accurate.

## Proof of Concept

```csharp
// Scenario demonstrating the vulnerability:
// - 3 miners with Orders 1, 2, 3
// - Mining interval: 4000ms
// - Miner 3 (Order=3) mines at T=0
// - Miner 1 (Order=1) mines at T=8000 (most recent chronologically)
// - Current time: T=12000
// - Checking if Miner 2 (Order=2) can mine

// Current (buggy) behavior:
// - Selects Miner 3 (highest Order=3)
// - Uses T=0 as reference
// - passedSlotsCount = (12000 - 0) / 4000 = 3
// - Check: 3 == (2 - 3 + 1 + 3) = 3 ✓ (INCORRECTLY RETURNS TRUE)

// Correct behavior should be:
// - Select Miner 1 (most recent at T=8000)
// - Use T=8000 as reference
// - passedSlotsCount = (12000 - 8000) / 4000 = 1
// - Check: 1 == (2 - 1 + 1 + 3) = 5 ✗ (correctly returns false)
// - Only 4000ms have passed since last block, not enough for authorization

// Result: Miner 2 is incorrectly authorized to mine at T=12000 when only
// 4000ms have elapsed since the actual last block (from Miner 1 at T=8000)
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L191-216)
```csharp
        // If current round is the first round of current term.
        if (currentRound.RoundNumber == 1)
        {
            Context.LogDebug(() => "First round");

            var latestMinedInfo =
                currentRound.RealTimeMinersInformation.Values.OrderByDescending(i => i.Order)
                    .FirstOrDefault(i => i.ActualMiningTimes.Any() && i.Pubkey != pubkey);
            if (latestMinedInfo != null)
            {
                var minersCount = currentRound.RealTimeMinersInformation.Count;
                var latestMinedSlotLastActualMiningTime = latestMinedInfo.ActualMiningTimes.Last();
                var latestMinedOrder = latestMinedInfo.Order;
                var currentMinerOrder =
                    currentRound.RealTimeMinersInformation.Single(i => i.Key == pubkey).Value.Order;
                var passedSlotsCount =
                    (Context.CurrentBlockTime - latestMinedSlotLastActualMiningTime).Milliseconds()
                    .Div(miningInterval);
                if (passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(1).Add(minersCount) ||
                    passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(minersCount))
                {
                    Context.LogDebug(() => "[CURRENT MINER]FIRST ROUND");
                    return true;
                }
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L304-304)
```csharp
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/FirstRoundCommandStrategy.cs (L13-19)
```csharp
    /// <summary>
    ///     Why implement a strategy only for first round?
    ///     Because during the first round, the ExpectedMiningTimes of every miner
    ///     depends on the StartTimestamp configured before starting current blockchain,
    ///     (which AElf Main Chain use new Timestamp {Seconds = 0},)
    ///     thus we can't really give mining scheduler these data.
    ///     The ActualMiningTimes will based on Orders of these miners.
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-869)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L897-906)
```csharp
    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```
