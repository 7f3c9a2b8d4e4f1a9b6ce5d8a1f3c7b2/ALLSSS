# Audit Report

## Title
Insufficient Miner Count Enforcement Allows Network to Operate Below Security Threshold

## Summary
The Election contract's `GetVictories()` function can return fewer miners than the configured `MinersCount` due to two issues: (1) a coding bug that artificially limits the backup pool size, and (2) complete absence of minimum miner count validation. This allows the consensus system to operate with reduced Byzantine fault tolerance, violating the security guarantees encoded in `MinersCount`.

## Finding Description

The vulnerability exists in the miner selection logic that determines which nodes participate in consensus for each term. The security property being violated is that `MinersCount` represents the minimum number of miners required to maintain the network's Byzantine fault tolerance threshold.

**Root Cause 1 - Artificial Backup Pool Limitation:**

When there are insufficient valid candidates (candidates with votes), the system attempts to fill the gap using backup miners from `currentMiners` and `InitialMiners`. [1](#0-0) 

The bug occurs where the code takes `Math.Min(diff, currentMiners.Count)` backups instead of `Math.Min(diff, backups.Count)`. Since `backups` includes both current miners AND initial miners (after filtering), `backups.Count` can exceed `currentMiners.Count`. This artificial cap prevents the system from using all available backup miners.

**Root Cause 2 - No Minimum Enforcement:**

The `GetVictories()` function returns whatever miners it can gather without validating that the count meets `MinersCount`. [2](#0-1) 

The consensus contract calls this during term transitions via `TryToGetVictories()`, which only checks if any miners are returned (`victories.Pubkeys.Any()`), not whether enough miners are returned. [3](#0-2) 

The returned miner list is directly used to generate the new consensus round without minimum validation. [4](#0-3) 

**Why Existing Protections Fail:**

The `SolitaryMinerDetection` mechanism only catches extreme cases where a single miner operates alone for 2+ consecutive rounds. [5](#0-4) 

This does not protect against scenarios where the network operates with multiple miners but still fewer than `MinersCount`.

## Impact Explanation

The impact is **critical** because it directly undermines Byzantine fault tolerance, the fundamental security property of the consensus mechanism.

**Security Model Violation:**
Byzantine fault tolerance requires that the system can tolerate up to `f` malicious nodes when there are `3f + 1` total nodes (or `2f + 1` for a 2/3 majority). If `MinersCount = 17` (designed to tolerate 5 Byzantine nodes with 2/3 majority = 12/17), but the system operates with only 14 miners, the tolerance drops to 4 Byzantine nodes (2/3 majority = 10/14). This represents a 20% reduction in security margin.

**Affected Parties:**
- The entire network operates with degraded security
- Token holders and stakeholders who voted expecting `MinersCount`-level security guarantees
- Applications relying on consensus finality are exposed to increased attack risk
- The `MinersCount` configuration becomes meaningless if not enforced

**Consensus Vulnerability:**
Critical consensus operations like term transitions and secret sharing that require 2/3 majority become more vulnerable to failure or manipulation when the actual miner count is below the designed threshold.

## Likelihood Explanation

The likelihood is **medium to high** over the blockchain's lifetime due to the following factors:

**Automatic Trigger:**
The `MinersCount` value automatically increases over time based on blockchain age through the auto-increment mechanism. [6](#0-5) 

The consensus contract calls `UpdateMinersCountToElectionContract()` during term transitions to keep the Election contract's `MinersCount` synchronized with the auto-incremented value. [7](#0-6) 

**Realistic Preconditions:**
1. As blockchain ages, `MinersCount` increases automatically (2 miners per configured interval)
2. Candidate participation depends on economic incentives and may not keep pace
3. If `validCandidates + availableBackups < MinersCount`, the vulnerability triggers
4. No active attack is required - this occurs through natural system progression

**Detection Difficulty:**
The network continues operating normally, making this security degradation difficult to detect without explicitly monitoring actual vs. expected miner counts.

## Recommendation

**Fix 1 - Correct the Backup Pool Bug:**
```csharp
// Line 72 in ViewMethods.cs should be:
victories.AddRange(backups.OrderBy(p => p)
    .Take(Math.Min(diff, backups.Count))  // Use backups.Count instead of currentMiners.Count
    .Select(v => ByteStringHelper.FromHexString(v)));
```

**Fix 2 - Add Minimum Miner Count Validation:**
In `GetVictories()`, add validation before returning:
```csharp
Assert(victories.Count >= State.MinersCount.Value, 
    $"Insufficient miners: {victories.Count} < {State.MinersCount.Value}");
return victories;
```

Alternatively, in the consensus contract's `TryToGetVictories()` or `GenerateFirstRoundOfNextTerm()`, validate the returned miner count:
```csharp
if (victories.Pubkeys.Count < GetExpectedMinersCount()) {
    // Fall back to current miners or revert term transition
    return false;
}
```

**Fix 3 - Governance Alert:**
Consider emitting an event when the actual miner count falls below `MinersCount` so stakeholders can take corrective action (adjust incentives, temporarily reduce `MaximumMinersCount`, etc.).

## Proof of Concept

The vulnerability can be demonstrated by creating a scenario where:
1. Set `MinersCount` to a value (e.g., 10)
2. Ensure only 5 candidates have votes (`validCandidates.Count = 5`)
3. Ensure `currentMiners.Count = 3` (fewer than the `diff = 5`)
4. Add `InitialMiners` such that `backups.Count = 6` after combining
5. Call `GetVictories()` during term transition

Expected behavior: Should return 10 miners (5 valid + 5 from backups)
Actual behavior: Returns only 8 miners (5 valid + 3 capped by `currentMiners.Count`)

This can be tested by:
```csharp
[Fact]
public async Task GetVictories_ReturnsFewer_ThanMinersCount()
{
    // Setup: Create scenario with insufficient candidates
    // Set MinersCount = 10
    // Create only 5 valid candidates with votes
    // Set currentMiners = 3 miners
    // Set InitialMiners = 4 miners (different from currentMiners)
    // backups.Count will be 4 after adding InitialMiners
    
    // Execute: Call GetVictories during term transition
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    
    // Assert: victories.Count < MinersCount (should be 9, but MinersCount = 10)
    victories.Value.Count.ShouldBeLessThan(10);
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L66-96)
```csharp
    private bool SolitaryMinerDetection(Round currentRound, string pubkey)
    {
        var isAlone = false;
        // Skip this detection until 4th round.
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
        {
            // Not single node.

            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;

            // If only this node mined during previous round, stop mining.
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }

            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
        }

        return isAlone;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```
