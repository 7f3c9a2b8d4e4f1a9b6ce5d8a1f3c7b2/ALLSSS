### Title
Governance Bypass via Malicious Contract Address in Authority Validation

### Summary
The `CheckOrganizationExist()` method fails to validate that the `input.ContractAddress` is one of the legitimate governance contracts (Parliament, Association, or Referendum) before calling `ValidateOrganizationExist` on it. An attacker can deploy a malicious contract implementing a permissive `ValidateOrganizationExist` method and gain unauthorized control over critical system parameters including method fees, contract deployment, and code check controllers through governance proposal execution.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist()` method [1](#0-0)  which is called by `ChangeMethodFeeController()` [2](#0-1) , `ChangeContractDeploymentController()` [3](#0-2) , and `ChangeCodeCheckController()` [4](#0-3) .

The root cause is that `CheckOrganizationExist()` directly calls `ValidateOrganizationExist` on the provided `authorityInfo.ContractAddress` without verifying it's one of the three legitimate governance system contracts. The legitimate governance contracts implement this method as a simple state check [5](#0-4)  and [6](#0-5) .

The codebase has the capability to validate system contracts using `Context.GetSystemContractNameToAddressMapping()` [7](#0-6) , but this validation is NOT performed in `CheckOrganizationExist()`.

The legitimate governance contracts are defined in system constants [8](#0-7)  but there is no enforcement that only these contracts can be used as authority contract addresses.

### Impact Explanation

**Auth/Governance Impact**: Complete bypass of governance constraints. An attacker who successfully executes a malicious proposal gains unauthorized control over:

1. **Method Fee Controller**: Can set arbitrary transaction fees or disable fees entirely, breaking economic model
2. **Contract Deployment Controller**: Can manipulate contract deployment authorization, potentially allowing deployment of malicious contracts
3. **Code Check Controller**: Can bypass code quality/security checks for contract updates

The attack affects the entire protocol as these controllers govern fundamental system operations. Once compromised, the attacker can:
- Drain value through manipulated fees
- Deploy unauthorized malicious contracts
- Bypass security validations for contract code
- Permanently damage protocol governance integrity

This violates the critical invariant that "method-fee provider authority" must be controlled only by legitimate governance organizations.

### Likelihood Explanation

**Reachable Entry Point**: The vulnerability is exploitable through the public `ChangeMethodFeeController()` method when called via proposal execution from legitimate governance contracts.

**Attack Sequence**:
1. Attacker deploys a malicious contract with a `ValidateOrganizationExist` method that returns `BoolValue{Value = true}` for any input
2. Attacker creates a governance proposal in Parliament/Association/Referendum calling `ChangeMethodFeeController` with `AuthorityInfo{ContractAddress = malicious_contract, OwnerAddress = attacker_address}`
3. If proposal passes governance voting and is released, it executes with the organization's virtual address as sender (authorized) [9](#0-8) 
4. `CheckOrganizationExist()` calls `malicious_contract.ValidateOrganizationExist()` which returns true
5. Controller is updated to attacker's malicious authority
6. Attacker now controls the fee/deployment/code-check mechanism

**Feasibility**: Attack is technically straightforward. Main barrier is getting the malicious proposal approved through legitimate governance, which could occur via:
- Social engineering (disguising malicious parameters in complex proposals)
- Governance participant compromise
- Low participation/attention in governance voting
- Bundling with legitimate changes

Test evidence shows the pattern is used across multiple contracts without validation [10](#0-9) , confirming the validation gap.

### Recommendation

Add validation to verify `authorityInfo.ContractAddress` is one of the legitimate governance system contracts before calling `ValidateOrganizationExist`:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a legitimate governance contract
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemHashName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemHashName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemHashName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid authority contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

Apply this fix to all contracts with similar patterns (Economic, Election, Profit, TokenConverter, CrossChain, etc.) that have the same vulnerable `CheckOrganizationExist` implementation.

Add integration tests that verify controller change attempts with non-governance contract addresses are rejected with "Invalid authority contract address" error.

### Proof of Concept

**Initial State**: Genesis contract initialized with default Parliament controller [11](#0-10) 

**Attack Steps**:
1. Deploy malicious contract `MaliciousAuth` with method:
   ```csharp
   public BoolValue ValidateOrganizationExist(Address input) {
       return new BoolValue { Value = true };
   }
   ```

2. Create Parliament proposal to call `ChangeMethodFeeController` with:
   ```
   input = AuthorityInfo {
       ContractAddress = MaliciousAuth_Address,
       OwnerAddress = Attacker_Address
   }
   ```

3. Approve and release proposal through legitimate Parliament voting

4. Proposal executes with `Context.Sender = Parliament_Organization_Address` (passes authorization check)

5. `CheckOrganizationExist()` calls `MaliciousAuth.ValidateOrganizationExist(Attacker_Address)` → returns true

6. `State.MethodFeeController.Value` updated to malicious authority

**Expected Result**: Transaction should fail with "Invalid authority contract address"

**Actual Result**: Transaction succeeds, attacker gains method fee controller access

**Success Verification**: Call `GetMethodFeeController()` → returns `AuthorityInfo{ContractAddress = MaliciousAuth_Address, OwnerAddress = Attacker_Address}`

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L59-71)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        RequireParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L366-372)
```csharp
    public override Empty ChangeContractDeploymentController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.ContractDeploymentController.Value = input;
        return new Empty();
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L375-382)
```csharp
    public override Empty ChangeCodeCheckController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.CodeCheckController.Value.OwnerAddress);
        Assert(CheckOrganizationExist(input),
            "Invalid authority input.");
        State.CodeCheckController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L196-203)
```csharp
    private void AssertSystemContractOrLockWhiteListAddress(string symbol)
    {
        var symbolState = State.LockWhiteLists[symbol];
        var isInWhiteList = symbolState != null && symbolState[Context.Sender];
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Values;
        var isSystemContractAddress = systemContractAddresses.Contains(Context.Sender);
        Assert(isInWhiteList || isSystemContractAddress, "No Permission.");
    }
```

**File:** src/AElf.Sdk.CSharp/SmartContractConstants.cs (L18-36)
```csharp
    public static readonly Hash ParliamentContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Parliament");

    public static readonly Hash VoteContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Vote");
    public static readonly Hash ProfitContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Profit");

    public static readonly Hash CrossChainContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.CrossChain");

    public static readonly Hash TokenConverterContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.TokenConverter");

    public static readonly Hash EconomicContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Economic");

    public static readonly Hash ReferendumContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Referendum");

    public static readonly Hash AssociationContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Association");
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L1208-1239)
```csharp
    public async Task ChangeMethodFeeController_Test()
    {
        var createOrganizationResult = await Tester.ExecuteContractWithMiningAsync(ParliamentAddress,
            nameof(ParliamentContractImplContainer.ParliamentContractImplStub.CreateOrganization),
            new CreateOrganizationInput
            {
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1000,
                    MinimalVoteThreshold = 1000
                }
            });

        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.ReturnValue);

        var methodFeeController = await GetMethodFeeController(Tester, BasicContractZeroAddress);
        const string proposalCreationMethodName =
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ChangeMethodFeeController);
        var proposalId = await CreateProposalAsync(Tester, methodFeeController.ContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName,
            new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = ParliamentAddress
            });
        await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
        var txResult2 = await ReleaseProposalAsync(Tester, ParliamentAddress, proposalId);
        txResult2.Status.ShouldBe(TransactionResultStatus.Mined);

        var newMethodFeeController = await GetMethodFeeController(Tester, BasicContractZeroAddress);
        Assert.True(newMethodFeeController.OwnerAddress == organizationAddress);
    }
```
