### Title
IssueChainId Manipulation Allows Unauthorized Token Issuance on Side Chains

### Summary
The `Create` method in TokenContract lacks validation that `IssueChainId` must equal the current chain ID, allowing attackers to create tokens on the main chain with `IssueChainId` pointing to a side chain. While the specific values mentioned (0 or negative) are not exploitable, an attacker can set `IssueChainId` to a different legitimate chain's ID, register the token cross-chain, and bypass the side chain's token creation restrictions to issue tokens directly on the side chain.

### Finding Description

The vulnerability exists in the token creation logic where `IssueChainId` validation is missing. [1](#0-0) 

When `input.IssueChainId == 0`, it defaults to `Context.ChainId`. However, when `input.IssueChainId` is any other value (including a different legitimate chain ID), it's accepted without validation. There is no assertion that `input.IssueChainId == Context.ChainId` (except for the 0 special case).

Side chains have a protection mechanism to prevent direct token creation: [2](#0-1) 

This check ensures tokens cannot be created directly on side chains (where `State.SideChainCreator.Value` is set during initialization): [3](#0-2) 

However, an attacker can bypass this by:
1. Creating a token on the main chain with `IssueChainId` set to a side chain's ID
2. Using `CrossChainCreateToken` to register it on the side chain
3. Issuing tokens directly on the side chain since the validation check passes: [4](#0-3) 

**Regarding the specific question about 0 or negative values:**
- **IssueChainId = 0**: NOT exploitable - automatically converted to `Context.ChainId`
- **IssueChainId = negative**: NOT exploitable - no legitimate chain has negative ID, making the token unusable

**The actual vulnerability**: Setting `IssueChainId` to a **different legitimate chain's ID** bypasses validation.

### Impact Explanation

**Direct Fund Impact & Economic Manipulation:**
- Attackers can create tokens on the main chain with arbitrary `IssueChainId` values pointing to side chains
- After cross-chain registration, attackers can issue unlimited tokens (up to `TotalSupply`) directly on side chains without any corresponding economic activity on the main chain
- This violates the cross-chain security model where tokens should only be issued on their origin chain and transferred via burn/mint mechanisms

**Circumvents Side Chain Restrictions:**
- Normal users cannot create tokens directly on side chains due to the `SideChainCreator` check
- This exploit allows attackers to effectively create and issue tokens on side chains through the backdoor of cross-chain token registration

**Supply Inconsistency:**
- Token supply on the side chain can be inflated without corresponding issuance on the main chain
- Breaks accounting invariants and economic assumptions about token origins

**Deception & False Legitimacy:**
- Tokens appear to have been "officially" created via the `CrossChainCreateToken` mechanism, giving false legitimacy
- Users may trust these tokens believing they originated properly from the main chain

### Likelihood Explanation

**Reachable Entry Point:**
The `Create` method is public and callable by any user (with appropriate seed NFT or whitelist access): [5](#0-4) 

**Feasible Preconditions:**
- Attacker needs access to create tokens on the main chain (via seed NFT purchase or being in whitelist)
- Attacker needs to know a valid side chain's ID (publicly available information)
- Cross-chain infrastructure must be operational (standard configuration)

**Execution Practicality:**
1. **Main Chain - Create Token**: Call `Create` with `IssueChainId` set to target side chain ID, setting attacker as `Issuer`
2. **Main Chain - Validate**: Call `ValidateTokenInfoExists` to prepare for cross-chain registration
3. **Side Chain - Register**: Call `CrossChainCreateToken` with merkle proof to register token
4. **Side Chain - Issue**: Call `Issue` to mint tokens (validation passes since `IssueChainId == Context.ChainId`)

Each step uses standard, documented contract methods. The exploit path is straightforward with no complex timing or race conditions.

**Economic Rationality:**
- Cost: Seed NFT purchase + transaction fees
- Benefit: Ability to issue unlimited tokens on side chain up to `TotalSupply`
- Highly profitable for attackers creating malicious tokens or conducting scams

### Recommendation

**Code-Level Mitigation:**

Add validation in the `CreateToken` method to ensure `IssueChainId` matches the current chain:

```csharp
// In CreateToken method, after line 76:
Assert(tokenInfo.IssueChainId == Context.ChainId,
    "Token can only be created on the chain where it will be issued.");
```

**Alternative approach** - only allow 0 (auto-assign) for `IssueChainId`:

```csharp
// Line 76 modification:
Assert(input.IssueChainId == 0, "IssueChainId must be 0 to auto-assign current chain ID.");
IssueChainId = Context.ChainId,
```

**Invariant Checks to Add:**
- During `Create`: `Assert(IssueChainId == Context.ChainId)`
- During `CrossChainCreateToken`: Optionally validate that the token's `IssueChainId` matches the source chain (where it was created)

**Test Cases:**
- Attempt to create token with `IssueChainId != Context.ChainId` - should fail
- Attempt to create token with `IssueChainId = 0` - should succeed with auto-assignment
- Verify cross-chain token registration only allows tokens where `IssueChainId` matches the origin chain

### Proof of Concept

**Required Initial State:**
- Main chain (ChainId: 9992731 / "AELF") operational
- Side chain (ChainId: 1866392 / "tDVV") operational and indexed
- Cross-chain infrastructure configured
- Attacker has seed NFT or is in create whitelist

**Transaction Steps:**

1. **On Main Chain - Create Malicious Token:**
```
Create({
  Symbol: "FAKE",
  TokenName: "Fake Token",
  TotalSupply: 10000000,
  Decimals: 8,
  Issuer: AttackerAddress,
  IsBurnable: true,
  IssueChainId: 1866392,  // Side chain ID!
  Owner: AttackerAddress
})
```
**Expected:** Token created successfully with `IssueChainId = 1866392`
**Actual:** Token created (NO validation error)

2. **On Main Chain - Validate Token Info:**
```
ValidateTokenInfoExists({
  Symbol: "FAKE",
  IssueChainId: 1866392,
  ...
})
```
**Expected:** Transaction succeeds and is indexed
**Actual:** Success

3. **On Side Chain - Register Token:**
```
CrossChainCreateToken({
  FromChainId: 9992731,
  ParentChainHeight: <height>,
  TransactionBytes: <ValidateTokenInfoExists tx>,
  MerklePath: <proof>
})
```
**Expected:** Token registered with `IssueChainId = 1866392`
**Actual:** Success - token registered on side chain

4. **On Side Chain - Issue Tokens:**
```
Issue({
  Symbol: "FAKE",
  Amount: 10000000,
  To: AttackerAddress
})
```
**Expected by security model:** Should FAIL because token wasn't created on side chain
**Actual:** SUCCESS - validation passes (`IssueChainId == Context.ChainId` both equal 1866392)

**Clear Success Condition:**
Attacker successfully issues 10,000,000 FAKE tokens on the side chain without any corresponding token issuance or economic activity on the main chain, violating the cross-chain security model and bypassing side chain token creation restrictions.

### Notes

The specific question mentions "IssueChainId = 0 or negative value" - these particular values are NOT exploitable:
- Zero is auto-converted to the current chain's ID
- Negative values make tokens unusable on any legitimate chain

However, the broader vulnerability of IssueChainId manipulation using legitimate chain IDs from other chains is VALID and HIGH severity. The missing validation allows attackers to subvert the entire cross-chain token security model.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L14-25)
```csharp
    public override Empty InitializeFromParentChain(InitializeFromParentChainInput input)
    {
        Assert(!State.InitializedFromParentChain.Value, "MultiToken has been initialized");
        State.InitializedFromParentChain.Value = true;
        Assert(input.Creator != null, "creator should not be null");
        foreach (var pair in input.ResourceAmount) State.ResourceAmount[pair.Key] = pair.Value;

        foreach (var pair in input.RegisteredOtherTokenContractAddresses)
            State.CrossChainTransferWhiteList[pair.Key] = pair.Value;

        SetSideChainCreator(input.Creator);
        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L54-55)
```csharp
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L76-76)
```csharp
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L159-159)
```csharp
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
```
