### Title
Division by Zero in Consensus Round Processing Causes Blockchain Halt

### Summary
The `Ceiling()` function in `AEDPoSContract_GetMaximumBlocksCount.cs` performs division without checking if the divisor is zero. A malicious miner can exploit insufficient validation in round transitions to inject a round with zero miners, causing all subsequent consensus operations to fail with division by zero exception, effectively halting the blockchain.

### Finding Description

The vulnerability exists in multiple interconnected components:

**Primary Issue - Unchecked Division:** [1](#0-0) 

The `Ceiling()` function performs modulo and division operations on line 83-84 without checking if `num2` is zero. The `Div()` method directly performs integer division: [2](#0-1) 

**Critical Call Path - Ignored Return Value:** [3](#0-2) 

At line 24, `TryToGetCurrentRoundInformation(out var currentRound)` is called but the return value is NOT checked. The function continues to use `currentRound` regardless. When blockchain status is Abnormal (line 42), it calls `Ceiling(factor, currentRound.RealTimeMinersInformation.Count)` at line 52, passing zero as the divisor if the round has no miners.

**Failed Validation - Empty Miners Allowed:** [4](#0-3) 

The validation only checks if InValues are null, but does NOT verify that `RealTimeMinersInformation` is non-empty. For an empty collection, `Any(m => m.InValue != null)` returns false, so validation passes.

**Attack Vector - Round Storage:** [5](#0-4) 

The `ProcessNextRound` method at line 156 calls `AddRoundInformation(nextRound)` without validating that the round contains miners, storing the malicious empty round.

**Trigger Point:** [6](#0-5) 

Every consensus operation calls `GetMaximumBlocksCount()` at line 68, ensuring the vulnerability is triggered immediately after the malicious round is stored.

### Impact Explanation

**Critical Consensus Halt:**
- Division by zero exception causes contract execution failure
- All subsequent block production attempts fail at consensus processing
- The blockchain is completely halted - no new blocks can be produced
- Network-wide DoS affecting all validators and users

**Scope:**
- Affects entire blockchain once triggered
- No transactions can be processed
- Requires manual intervention or hard fork to recover
- All network participants impacted simultaneously

**Severity Justification:**
- Complete loss of liveness (blockchain cannot produce blocks)
- Irreversible without manual state intervention
- Single attack can halt million-dollar blockchain infrastructure
- Violates critical consensus integrity invariant

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a valid miner in current or previous round to pass authorization check: [7](#0-6) 

**Attack Complexity:**
- Low - requires only crafting a `NextRoundInput` with empty `RealTimeMinersInformation` map
- Round number must be current + 1 (trivial to calculate)
- No complex timing or state manipulation required

**Feasibility:**
- NextRound is a standard consensus method called regularly
- Validation explicitly allows empty miner lists (design flaw)
- Attack succeeds deterministically once submitted

**Detection/Operational Constraints:**
- Attack transaction appears valid until executed
- No early warning or prevention mechanism exists
- Blockchain halts immediately upon execution
- Recovery requires coordinated manual intervention

**Probability:** High - any compromised or malicious miner can execute this attack with minimal effort and guaranteed success.

### Recommendation

**1. Add Zero-Check in Ceiling Function:**
```csharp
private static int Ceiling(int num1, int num2)
{
    Assert(num2 > 0, "Divisor must be positive.");
    var flag = num1 % num2;
    return flag == 0 ? num1.Div(num2) : num1.Div(num2).Add(1);
}
```

**2. Check Return Value in GetMaximumBlocksCount:**
```csharp
private int GetMaximumBlocksCount()
{
    if (!TryToGetCurrentRoundInformation(out var currentRound))
        return AEDPoSContractConstants.MaximumTinyBlocksCount;
    
    Assert(currentRound.RealTimeMinersInformation.Count > 0, 
        "Round must contain at least one miner.");
    // ... rest of function
}
```

**3. Add Validation for Empty Miners in Round Transitions:**
```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Add this check
    if (extraData.Round.RealTimeMinersInformation.Count == 0)
        return new ValidationResult { Message = "Round must contain at least one miner." };
    
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

**4. Add Test Cases:**
- Test `Ceiling()` with zero divisor (should fail)
- Test `NextRound` with empty `RealTimeMinersInformation` (should be rejected)
- Test `GetMaximumBlocksCount()` with invalid round state (should handle gracefully)

### Proof of Concept

**Initial State:**
- Blockchain is running with valid consensus rounds
- Attacker is a valid miner (has mining permissions)

**Attack Sequence:**

1. **Attacker crafts malicious NextRoundInput:**
   - `RoundNumber` = current round + 1 (valid)
   - `RealTimeMinersInformation` = empty map
   - `RoundIdForValidation` = any non-zero value
   - All other fields copied from legitimate round generation

2. **Attacker calls NextRound transaction:**
   - Passes `PreCheck()` authorization (attacker is valid miner)
   - Passes validation in `RoundTerminateValidationProvider` (empty map causes `Any()` to return false)
   - `ProcessNextRound` stores empty round via `AddRoundInformation()`
   - Empty round becomes current round

3. **Any miner attempts to produce next block:**
   - Consensus processing calls `GetMaximumBlocksCount()` 
   - `TryToGetCurrentRoundInformation()` returns false but sets `currentRound` to empty round
   - Return value not checked, execution continues
   - Blockchain status becomes Abnormal (common scenario)
   - Code reaches `Ceiling(factor, 0)` at line 52
   - Division by zero exception at line 83 or 84

**Expected Result:** Block production succeeds, consensus continues normally

**Actual Result:** Division by zero exception, transaction reverts, all subsequent consensus operations fail, blockchain halts

**Success Condition:** No new blocks can be produced after attack, network monitoring shows consensus failure across all validators

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-52)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L81-85)
```csharp
    private static int Ceiling(int num1, int num2)
    {
        var flag = num1 % num2;
        return flag == 0 ? num1.Div(num2) : num1.Div(num2).Add(1);
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L21-24)
```csharp
    public static int Div(this int a, int b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L67-69)
```csharp
        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```
