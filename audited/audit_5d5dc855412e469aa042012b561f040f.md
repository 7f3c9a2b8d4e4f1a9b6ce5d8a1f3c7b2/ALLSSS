### Title
Consensus Mining Schedule Corruption via Broken Validation and Cross-Miner Data Injection in RecoverFromUpdateValue

### Summary
The `RecoverFromUpdateValue()` function contains a critical vulnerability that allows any miner to corrupt the entire mining schedule by injecting malicious order values and PreviousInValues for all other miners. The vulnerability stems from a broken hash validation check that compares an object to itself, combined with the function's design that overwrites consensus-critical fields for all miners without proper validation.

### Finding Description

The vulnerability exists in the `RecoverFromUpdateValue()` function where lines 22-30 iterate through ALL miners and overwrite their `SupposedOrderOfNextRound`, `FinalOrderOfNextRound`, and `PreviousInValue` fields from the attacker-provided round data: [1](#0-0) 

The root cause is a fundamentally broken validation flow in `ValidateConsensusAfterExecution()`. When the function calls `RecoverFromUpdateValue()`, it assigns the return value to `headerInformation.Round`: [2](#0-1) 

Since `RecoverFromUpdateValue()` modifies `this` (the `currentRound` object) and returns `this`, both `headerInformation.Round` and `currentRound` now reference the **same object**. When the subsequent hash comparison occurs at lines 100-101, it compares this same object to itself: [3](#0-2) 

The hashes will always match because both sides of the comparison reference the identical object, making the validation check completely meaningless.

The `UpdateValueValidationProvider` only validates the sender's own fields and does not validate the cross-miner data: [4](#0-3) 

The malicious values from the header are then extracted via `ExtractInformationToUpdateConsensus()` which creates `TuneOrderInformation` and `MinersPreviousInValues` dictionaries containing the attacker-controlled values: [5](#0-4) 

During execution, `ProcessUpdateValue()` writes these malicious values to the state for all affected miners: [6](#0-5) [7](#0-6) 

### Impact Explanation

**Consensus Integrity Destruction**: The `FinalOrderOfNextRound` values directly control the mining order in the next round. When `GenerateNextRoundInformation()` is called, it orders miners by their `FinalOrderOfNextRound` values and assigns their time slots accordingly: [8](#0-7) 

An attacker can:
1. **Control entire mining schedule**: Set arbitrary mining orders for all miners, giving themselves favorable positions or creating collisions
2. **Exclude legitimate miners**: Set `SupposedOrderOfNextRound` to 0 for honest miners, causing them to be treated as non-participants: [9](#0-8) 

3. **Corrupt random number generation**: Inject fake `PreviousInValue` data used in consensus signature calculations and random hash generation
4. **Disrupt LIB calculation**: Manipulate the `ImpliedIrreversibleBlockHeight` values used in last irreversible block height computation

The severity is **Critical** because it completely undermines the consensus mechanism's fairness and security, affecting all network participants.

### Likelihood Explanation

**Highly Exploitable**: Any active miner can execute this attack with 100% success rate:

1. **Attacker Capabilities**: Only requires being an authorized miner in the current round (standard participant)
2. **Attack Complexity**: Low - attacker simply crafts a malicious `Round` object in their block header with arbitrary values for all miners
3. **Feasibility**: The broken validation check guarantees the attack will succeed every time
4. **Detection**: Difficult to detect in real-time as the malicious values appear in normal UpdateValue transactions
5. **Cost**: Minimal - just the cost of producing a single block

The attack is executed through the standard consensus flow via the public `ValidateConsensusAfterExecution` method, requiring no privilege escalation beyond normal miner status.

### Recommendation

**Immediate Fix**: Correct the validation logic to prevent object aliasing:

In `ValidateConsensusAfterExecution()`, do NOT assign the return value back to `headerInformation.Round`. Instead, keep the original `headerInformation.Round` separate from `currentRound` for proper comparison:

```csharp
if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
{
    var recoveredRound = currentRound.Clone(); // Create a copy
    recoveredRound.RecoverFromUpdateValue(headerInformation.Round, 
        headerInformation.SenderPubkey.ToHex());
    // Now compare original headerInformation.Round to recoveredRound
    if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
        recoveredRound.GetHash(isContainPreviousInValue))
    {
        // validation failure
    }
}
```

**Additional Protections**:
1. Add validation in `UpdateValueValidationProvider` to check that `TuneOrderInformation` and `MinersPreviousInValues` contain only valid, justified values
2. Verify that miners can only modify `FinalOrderOfNextRound` for miners who have actually mined (have valid OutValue)
3. Add bounds checking: ensure all `FinalOrderOfNextRound` values are within valid range [1, minersCount] and no duplicates exist
4. Validate that `PreviousInValue` changes are cryptographically justified based on the previous round's consensus data

**Test Cases**:
- Test that malicious FinalOrderOfNextRound values in header are rejected
- Test that duplicate order assignments are caught
- Test that out-of-bounds order values fail validation
- Verify hash comparison works correctly when rounds differ

### Proof of Concept

**Initial State**: 
- Network has 5 active miners: A, B, C, D, E
- Current round number: 100
- Miner A (attacker) is scheduled to produce next block

**Attack Steps**:

1. **Attacker constructs malicious Round object** in block header with:
   - For Miner B: `FinalOrderOfNextRound = 5` (should be 2)
   - For Miner C: `FinalOrderOfNextRound = 1` (should be 3)  
   - For Miner D: `FinalOrderOfNextRound = 3` (should be 4)
   - For Miner E: `FinalOrderOfNextRound = 2` (should be 5)
   - For Miner A: `FinalOrderOfNextRound = 4` (giving themselves advantageous position)
   - Sets `SupposedOrderOfNextRound = 0` for Miner B (falsely marking them as non-participant)

2. **Block validation occurs**:
   - `ValidateConsensusAfterExecution` calls `RecoverFromUpdateValue()`
   - Malicious values copied to `currentRound` for all miners
   - Hash comparison: `headerInformation.Round.GetHash()` == `currentRound.GetHash()` 
   - **Validation PASSES** (both reference same object with same hash)

3. **Transaction execution**:
   - `ExtractInformationToUpdateConsensus()` extracts malicious values
   - `ProcessUpdateValue()` writes corrupted values to state
   - **State now contains attacker's malicious mining schedule**

4. **Next round generation**:
   - `GenerateNextRoundInformation()` uses corrupted `FinalOrderOfNextRound` values
   - Mining order becomes: C(1), E(2), D(3), A(4), B(5)
   - Miner B is excluded from first positions due to manipulated order
   - Time slots assigned based on corrupted order

**Expected Result**: Validation should reject the malicious header

**Actual Result**: Validation passes; entire mining schedule for round 101 is corrupted; Miner B is disadvantaged; Attacker gains favorable position

**Success Condition**: Attacker successfully manipulates mining order for all participants in next round through a single malicious block header

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-92)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-49)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-47)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);

        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L128-129)
```csharp
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```
