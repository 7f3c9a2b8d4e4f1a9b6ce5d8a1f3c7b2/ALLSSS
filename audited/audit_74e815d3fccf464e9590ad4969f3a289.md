# Audit Report

## Title
TokenHolder Scheme Overwrite Causes Permanent Token Lock for Registered Users

## Summary
The `CreateScheme` method in TokenHolderContract unconditionally overwrites scheme state without validation, enabling a critical vulnerability where users' locked tokens become permanently inaccessible when a manager creates a second scheme with a different symbol. The withdrawal logic attempts to unlock tokens using the new scheme's symbol with lockIds that reference tokens locked under the original scheme's symbol, resulting in complete fund loss.

## Finding Description

The vulnerability stems from three interconnected contract methods that create a state inconsistency between scheme metadata and locked token records.

**Root Cause - State Overwrite Without Validation:**
The `CreateScheme` method unconditionally overwrites `State.TokenHolderProfitSchemes[Context.Sender]` without checking if a scheme already exists for the manager. [1](#0-0) 

Meanwhile, the underlying Profit contract properly supports multiple schemes per manager by appending each new scheme to a list. [2](#0-1) 

**User Registration - Token Locking:**
When users call `RegisterForProfits`, the contract generates a deterministic lockId and locks tokens using the scheme's symbol at that point in time. [3](#0-2) 

The lockId is stored in state per manager address, creating a mapping between the user, manager, and their locked tokens. [4](#0-3) 

**Withdrawal Failure - Symbol Mismatch:**
When the manager creates a second scheme with a different symbol, the `TokenHolderProfitSchemes` state is overwritten. During withdrawal, `GetValidScheme` retrieves this overwritten scheme data. [5](#0-4) 

The `UpdateTokenHolderProfitScheme` helper fetches the first scheme ID from the Profit contract but uses the overwritten symbol from TokenHolderProfitSchemes state. [6](#0-5) 

The `Withdraw` method then queries `GetLockedAmount` with the new symbol and the old lockId, which returns 0 since no tokens of the new symbol were ever locked under that lockId. [7](#0-6) 

Finally, the contract unlocks 0 tokens and permanently removes the lockId mapping, making the original locked tokens irrecoverable. [8](#0-7) 

## Impact Explanation

**Direct Fund Loss:** This vulnerability causes complete and permanent loss of user funds. When a manager creates a second scheme with a different token symbol:
- All users who registered under the original scheme lose access to their locked tokens
- The tokens remain locked in the MultiToken contract but become inaccessible
- The lockId deletion prevents any future recovery attempts

**Scale of Impact:** If a popular scheme has thousands of registered users with locked tokens, a single `CreateScheme` transaction by the manager renders all those tokens permanently inaccessible. For example:
- User locks 1,000 ELF tokens under Scheme A (Symbol: "ELF")
- Manager creates Scheme B with Symbol: "USDT"
- User's withdrawal attempts query for locked USDT with the ELF lockId â†’ returns 0
- User's 1,000 ELF remains permanently locked with no recovery path

**Severity Assessment:** HIGH - This breaks the fundamental security guarantee that users can withdraw their locked tokens after the lock period expires. The vulnerability causes irreversible financial loss to innocent users through either accidental misconfiguration or malicious exploitation.

## Likelihood Explanation

**Attack Surface:** `CreateScheme` is a public method with no access controls - any address can call it to manage their own schemes. [9](#0-8) 

**Execution Simplicity:** The vulnerability requires only:
1. Manager creates initial scheme (legitimate operation)
2. Users register and lock tokens (legitimate operation)
3. Manager calls `CreateScheme` again with different symbol (single transaction)

**Realistic Scenarios:**
- **Accidental Trigger:** A manager attempting to "update" scheme parameters may unknowingly call `CreateScheme` again, not realizing it overwrites critical state
- **Contract Upgrade Confusion:** During protocol upgrades, managers might recreate schemes thinking it's necessary
- **Malicious Exploitation:** A malicious manager can intentionally lock all user funds as an exit scam with zero cost

**No Protective Barriers:** 
- No duplicate scheme validation exists in CreateScheme
- No warning mechanisms alert users when scheme state changes
- The RegisterForProfits duplicate check only prevents users from registering twice, but doesn't protect against scheme overwrites [10](#0-9) 

**Likelihood Assessment:** MEDIUM to HIGH - The vulnerability can manifest through normal operational mistakes or deliberate exploitation, with no technical barriers preventing either scenario.

## Recommendation

Add validation to prevent scheme overwrites in the `CreateScheme` method:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add validation to prevent overwriting existing schemes
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this manager. Cannot create duplicate scheme.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, implement a separate `UpdateScheme` method with proper migration logic that:
1. Validates no users have active locked tokens before allowing symbol changes
2. Provides a safe migration path for updating scheme parameters without breaking existing locks

## Proof of Concept

```csharp
[Fact]
public async Task SchemeOverwrite_CausesPermanentTokenLock_Test()
{
    // Setup: Manager creates first scheme with ELF
    const long lockAmount = 1000_00000000; // 1000 ELF
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    // User registers and locks 1000 ELF tokens
    var userStub = GetTokenHolderContractStub(UserKeyPair);
    await userStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = Starter,
        Amount = lockAmount
    });
    
    // Verify tokens are locked
    var userBalanceBefore = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddress,
        Symbol = "ELF"
    });
    
    // Attack: Manager creates second scheme with different symbol
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT", // Different symbol overwrites scheme state
        MinimumLockMinutes = 1
    });
    
    // Wait for lock period to expire
    await BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddMinutes(2));
    
    // User attempts to withdraw - this will fail silently
    await userStub.Withdraw.SendAsync(Starter);
    
    // Verify: User's ELF tokens remain locked (balance unchanged)
    var userBalanceAfter = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddress,
        Symbol = "ELF"
    });
    
    // VULNERABILITY: Balance unchanged - tokens permanently locked
    userBalanceAfter.Balance.ShouldBe(userBalanceBefore.Balance);
    
    // Verify: LockId has been removed from state (no recovery possible)
    var lockId = await TokenHolderContractStub.GetLockId.CallAsync(new GetLockIdInput
    {
        Manager = Starter,
        User = UserAddress
    });
    lockId.ShouldBeNull(); // LockId removed, tokens irrecoverable
}
```

---

## Notes

This vulnerability is confirmed valid through complete code path analysis. The issue affects the production TokenHolder contract and represents a critical threat to user funds. The root cause is the unconditional state overwrite in `CreateScheme` combined with the symbol-based token lookup in `Withdraw`, creating a permanent mismatch between locked token metadata and retrieval logic.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-14)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L151-151)
```csharp
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-166)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L220-225)
```csharp
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L230-238)
```csharp
        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L290-298)
```csharp
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L12-15)
```csharp
    /// <summary>
    ///     Contract address (Manager address) -> Beneficiary address -> Lock id.
    /// </summary>
    public MappedState<Address, Address, Hash> LockIds { get; set; }
```
