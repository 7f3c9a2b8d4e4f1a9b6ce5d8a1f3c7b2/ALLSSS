### Title
Unreleased Periods Can Permanently Lock Beneficiary Profits

### Summary
The Profit contract allows contributions to future periods via `ContributeProfits`, but these periods can only be released by calling `DistributeProfits` sequentially. If a scheme manager stops distributing profits before reaching a contributed period, those profits remain with `IsReleased=false` and beneficiaries can never claim them, resulting in permanent fund loss.

### Finding Description

The vulnerability exists due to a critical design mismatch between three functions:

**1. ContributeProfits allows contributions to ANY future period:** [1](#0-0) 

When contributing to a specific period, a new `DistributedProfitsInfo` is created with profits but `IsReleased` defaults to `false`: [2](#0-1) 

**2. DistributeProfits can ONLY release the current period sequentially:** [3](#0-2) 

After distribution, the period is incremented by exactly 1: [4](#0-3) 

This means periods must be released in strict sequential order (1, 2, 3, 4...) with no ability to skip ahead.

**3. ProfitAllPeriods only transfers profits if IsReleased is true:** [5](#0-4) 

Critically, even when `IsReleased=false` and the transfer is skipped, the beneficiary's `LastProfitPeriod` is still updated: [6](#0-5) 

This means the beneficiary permanently loses access to that period's profits.

**Root Cause:** The contract allows profit contributions to periods that may never be released, combined with updating `LastProfitPeriod` regardless of whether the transfer succeeded, creates an irreversible loss scenario.

### Impact Explanation

**Direct Fund Impact - Permanent Loss:**
- Any tokens contributed to unreleased periods become permanently locked in the period's virtual address
- Beneficiaries cannot claim these profits because the transfer only executes when `IsReleased=true`
- Once `LastProfitPeriod` advances past an unreleased period, that period can never be claimed again

**Who is Affected:**
- All beneficiaries of a profit scheme where the manager stops calling `DistributeProfits` before reaching contributed periods
- The entire profit amount in unreleased periods is lost to ALL beneficiaries proportional to their shares

**Quantified Impact:**
- If period 10 has 10,000 tokens contributed but is never released, and there are beneficiaries with 100 total shares, each beneficiary loses their proportional amount permanently
- This can happen for multiple periods simultaneously if contributions were made to periods 10, 15, 20, etc.

**Severity Justification - HIGH:**
- Permanent, irreversible loss of funds
- Affects protocol's core profit distribution mechanism
- No recovery mechanism exists
- Can affect large amounts accumulated in future periods

### Likelihood Explanation

**Reachable Entry Point:**
The attack uses three standard public methods:
- `ContributeProfits` (callable by anyone, as confirmed by tests)
- `DistributeProfits` (callable only by manager)
- `ClaimProfits` (callable by beneficiaries)

**Attack Scenarios:**

1. **Accidental Scenario (High Likelihood):**
   - Current period is 5
   - User mistakenly contributes to period 50 instead of period 5
   - Manager continues normally through periods 5-10 then stops managing the scheme (abandonment, lost keys, death)
   - Period 50's profits are permanently locked

2. **Malicious Manager Scenario (Medium Likelihood):**
   - Manager accepts contributions to future periods
   - Deliberately stops calling `DistributeProfits` 
   - All future period profits are locked, harming beneficiaries

3. **Griefing Attack (Low-Medium Likelihood):**
   - Attacker contributes small amounts to very far future periods (e.g., period 1000)
   - This creates complexity and potential for permanent loss if scheme is abandoned

**Feasible Preconditions:**
- A profit scheme exists (common)
- Anyone can contribute profits to future periods (confirmed in tests: [7](#0-6) )
- Manager fails to call `DistributeProfits` for all periods up to contributed periods

**Execution Practicality:**
- All steps use standard contract methods with no special permissions required
- No complex timing or state manipulation needed
- Economically viable - attacker risk is minimal (just the contributed amount)

### Recommendation

**Immediate Mitigation:**

1. **Restrict future period contributions in ContributeProfits:**
```
Assert(input.Period >= scheme.CurrentPeriod && 
       input.Period <= scheme.CurrentPeriod + MAX_FUTURE_PERIOD_CONTRIBUTION,
       "Can only contribute to current period or near future periods.");
```
Add a constant like `MAX_FUTURE_PERIOD_CONTRIBUTION = 10` to limit how far ahead contributions can go.

2. **Fix ProfitAllPeriods to not update LastProfitPeriod for unreleased periods:**
Move line 908 inside the `if (distributedProfitsInformation.IsReleased && amount > 0)` block at line 881, so `LastProfitPeriod` is only updated when profits are actually transferred.

3. **Add emergency release mechanism:**
Allow scheme manager to mark unreleased periods as `IsReleased=true` even if they're not the current period, to enable recovery of locked funds.

**Invariant Checks to Add:**
- Verify that all periods with contributed profits are eventually released before scheme becomes inactive
- Add a view function to query all unreleased periods with profits to detect this condition

**Test Cases:**
- Test contributing to period N+10 where N is current, then stopping distributions at N+5
- Test beneficiary claiming and verify they cannot access period N+10's profits
- Test the fix ensures LastProfitPeriod is not updated for unreleased periods

### Proof of Concept

**Initial State:**
- Profit scheme created with ID `scheme_A` at period 1
- Beneficiary Alice added with 100 shares out of 100 total shares
- Manager is Bob

**Attack Steps:**

1. **Contribute to future period:**
   - Current period: 5
   - Anyone calls `ContributeProfits(scheme_A, amount=10000, period=10, symbol="ELF")`
   - Result: Period 10's virtual address receives 10,000 ELF tokens
   - `DistributedProfitsInfo` for period 10 has `AmountsMap["ELF"]=10000`, `IsReleased=false`, `TotalShares=0`

2. **Manager distributes some periods then stops:**
   - Bob calls `DistributeProfits(scheme_A, period=5)` → CurrentPeriod becomes 6
   - Bob calls `DistributeProfits(scheme_A, period=6)` → CurrentPeriod becomes 7
   - Bob calls `DistributeProfits(scheme_A, period=7)` → CurrentPeriod becomes 8
   - Bob stops managing (lost keys/abandons project)
   - CurrentPeriod is now 8, will never reach 10

3. **Alice attempts to claim:**
   - Alice calls `ClaimProfits(scheme_A, beneficiary=Alice)`
   - In `ProfitAllPeriods`, loop reaches period 10
   - Line 873-874: Calculates `amount = 10000 * 100 / 100 = 10000` tokens owed to Alice
   - Line 881: Check `if (IsReleased && amount > 0)` → FALSE (IsReleased=false)
   - Lines 887-895: Transfer is SKIPPED
   - Line 908: `LastProfitPeriod = 11` (updated anyway!)
   - Result: Alice receives 0 tokens, but her LastProfitPeriod moves past period 10

4. **Alice tries to claim again:**
   - Alice calls `ClaimProfits` again
   - Period 10 is skipped because `LastProfitPeriod=11 > 10`
   - Result: Period 10's 10,000 tokens are permanently locked

**Expected vs Actual Result:**
- Expected: Alice should receive 10,000 ELF tokens from period 10
- Actual: Alice receives 0 tokens, and can never claim them again

**Success Condition:**
Verify that 10,000 ELF tokens remain locked in period 10's virtual address indefinitely, and Alice's `LastProfitPeriod` has moved past period 10, preventing any future claims.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L478-480)
```csharp
        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L684-684)
```csharp
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L689-694)
```csharp
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L881-881)
```csharp
                    if (distributedProfitsInformation.IsReleased && amount > 0)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L908-908)
```csharp
                    lastProfitPeriod = period + 1;
```

**File:** test/AElf.Contracts.Profit.Tests/ProfitTests.cs (L138-144)
```csharp
        await thirdParty.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeId = schemeId,
            Amount = amountAddedByThirdParty,
            Symbol = ProfitContractTestConstants.NativeTokenSymbol,
            Period = 1
        });
```
