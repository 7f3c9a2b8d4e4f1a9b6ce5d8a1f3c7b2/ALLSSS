### Title
Authorization Bypass Allows Unauthorized NextRound Block Production by Any Miner

### Summary
The `TerminateRoundCommandStrategy` generates `ConsensusCommand` for NextRound transitions without binding to a specific authorized miner, and the validation in `ValidateBeforeExecution` does not verify that the sender is the designated extra block producer. This allows any miner in the current round to produce NextRound blocks prematurely, disrupting the intended consensus round rotation and potentially causing premature round termination before all miners have had their turn.

### Finding Description

**Root Cause:**
The vulnerability exists in the consensus validation flow where NextRound blocks are not properly authorized. The `TerminateRoundCommandStrategy.GetAEDPoSConsensusCommand()` generates a command containing only behavioral hints and timing information, but no binding to a specific authorized miner. [1](#0-0) 

When a miner produces a NextRound block, the `ValidateBeforeExecution` method validates it using several providers: [2](#0-1) 

The critical issue is in `TimeSlotValidationProvider` which, for new rounds (NextRound/NextTerm), only validates that the new round's time slots are properly structured, but does NOT check if the current sender is authorized to produce the extra block: [3](#0-2) 

The `MiningPermissionValidationProvider` only checks if the sender is in the miner list, not if they are the designated extra block producer: [4](#0-3) 

While the `IsCurrentMiner` method DOES check if a miner is the designated extra block producer and if the current time is in the extra block time slot: [5](#0-4) 

This method is NEVER called during `ValidateBeforeExecution`. It is only used by other system contracts for authorization purposes.

**Exploitation Path:**
1. Any miner whose time slot has passed can call `GetConsensusCommand` and receive NextRound behavior: [6](#0-5) 

2. The miner produces a NextRound block with fresh round information generated from current state: [7](#0-6) 

3. Validation passes all checks without verifying the sender is the designated extra block producer
4. The `NextRound` transaction executes, advancing to the next round: [8](#0-7) 

**Note on "Replay Attack":** This is NOT a traditional replay attack where the same ConsensusCommand is reused. The node-level `ValidateBlockMiningTime` prevents using commands with past timestamps. However, the authorization bypass allows ANY miner to generate and use fresh NextRound commands, which is equally disruptive.

### Impact Explanation

**Consensus Integrity Compromise:**
- Any miner can terminate the current round prematurely, before all miners have had a chance to produce their blocks in their designated time slots
- This violates the fundamental consensus invariant that each miner should have their turn in a deterministic, orderly fashion
- Multiple miners could simultaneously produce competing NextRound blocks, causing temporary forks

**Affected Parties:**
- Honest miners who haven't yet produced their blocks in the current round lose their mining opportunity
- The network suffers from reduced block production efficiency
- The deterministic extra block producer rotation mechanism (calculated via `CalculateNextExtraBlockProducerOrder`) is effectively bypassed [9](#0-8) 

**Severity Justification:**
HIGH - This breaks a critical consensus invariant (miner schedule integrity and round transition correctness). While it doesn't directly steal funds, it fundamentally undermines the consensus mechanism's ability to fairly allocate mining opportunities and maintain orderly round progression.

### Likelihood Explanation

**Attacker Capabilities:**
The attacker must be a miner in the current round, which is a reasonable assumption for evaluating consensus vulnerabilities. No additional privileges are required beyond normal miner status.

**Attack Complexity:**
LOW - The attacker simply needs to:
1. Wait until their own time slot passes
2. Call `GetConsensusCommand` to receive NextRound behavior
3. Produce and broadcast a NextRound block
4. The validation logic will accept it

**Feasibility:**
HIGHLY FEASIBLE - All consensus methods are publicly accessible, and miners regularly call these methods as part of normal operation. The attack requires no special tooling or coordination.

**Detection:**
The attack would be visible in block headers showing NextRound blocks produced by non-designated miners, but automated detection is not implemented in the validation logic.

**Probability:**
HIGH - A malicious miner can execute this attack with near certainty once their time slot passes in any round. The lack of authorization checks makes this trivially exploitable.

### Recommendation

**Primary Fix - Add Extra Block Producer Authorization Check:**

Add a new validation provider `ExtraBlockProducerValidationProvider` that validates NextRound/NextTerm blocks are produced by the designated extra block producer:

```csharp
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        
        if (extraData.Behaviour != AElfConsensusBehaviour.NextRound && 
            extraData.Behaviour != AElfConsensusBehaviour.NextTerm)
            return new ValidationResult { Success = true };
            
        // Get the designated extra block producer for current round
        var extraBlockProducer = validationContext.BaseRound.RealTimeMinersInformation
            .FirstOrDefault(m => m.Value.IsExtraBlockProducer).Key;
            
        if (extraBlockProducer != validationContext.SenderPubkey)
            return new ValidationResult 
            { 
                Message = $"Sender {validationContext.SenderPubkey} is not the designated extra block producer. Expected: {extraBlockProducer}" 
            };
            
        return new ValidationResult { Success = true };
    }
}
```

Add this provider to the validation pipeline in `ValidateBeforeExecution`: [10](#0-9) 

**Secondary Fix - Add Time Slot Validation for Extra Block:**

Modify `TimeSlotValidationProvider` to check that NextRound blocks are produced during the extra block time slot. Add `Context.CurrentBlockTime` to `ConsensusValidationContext` and validate:

```csharp
if (extraData.Behaviour == AElfConsensusBehaviour.NextRound || 
    extraData.Behaviour == AElfConsensusBehaviour.NextTerm)
{
    var extraBlockTime = validationContext.BaseRound.GetExtraBlockMiningTime();
    if (validationContext.CurrentBlockTime < extraBlockTime)
        return new ValidationResult 
        { 
            Message = "NextRound block produced before extra block time slot" 
        };
}
```

**Test Cases:**
1. Verify non-designated miner cannot produce NextRound block
2. Verify designated extra block producer can produce NextRound block
3. Verify NextRound block rejected before extra block time slot
4. Verify proper error messages for each validation failure

### Proof of Concept

**Initial State:**
- Blockchain at Round N with 7 miners (M1-M7)
- M5 is designated as extra block producer (via `CalculateNextExtraBlockProducerOrder`)
- M3's time slot has just ended
- Current time: 1000ms after round start
- Extra block time slot starts at: 4900ms after round start (7 miners × 700ms/slot)

**Attack Steps:**

1. **Malicious Miner M3 calls GetConsensusCommand:**
   - M3's time slot has passed
   - `GetConsensusBehaviour()` returns `NextRound`
   - M3 receives `ConsensusCommand` with NextRound hint

2. **M3 produces NextRound block prematurely:**
   - M3 calls `GetConsensusExtraData` which generates next round information
   - M3 produces block with `AElfConsensusBehaviour.NextRound`
   - Block includes round N+1 information

3. **Validation passes incorrectly:**
   - `MiningPermissionValidationProvider`: M3 is in miner list ✓
   - `TimeSlotValidationProvider`: New round time slots are valid ✓
   - `RoundTerminateValidationProvider`: Round number is N+1 ✓
   - **Missing check:** Is M3 the designated extra block producer? ✗

4. **NextRound transaction executes:**
   - Round advances from N to N+1
   - Miners M4, M5, M6, M7 lose their mining opportunity in round N
   - M5's designated extra block producer role is bypassed

**Expected Result:**
Validation should REJECT M3's NextRound block with message: "Sender [M3] is not the designated extra block producer. Expected: [M5]"

**Actual Result:**
Validation ACCEPTS M3's NextRound block, allowing premature round termination and disrupting consensus fairness.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-39)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-92)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```
