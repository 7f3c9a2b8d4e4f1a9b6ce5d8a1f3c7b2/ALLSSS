### Title
ActualMiningTime Manipulation via Hash Exclusion Allows Consensus Timing Fraud

### Summary
The `GetCheckableRound()` function excludes `ActualMiningTimes` from consensus round hash calculation, and there is no validation ensuring that `ActualMiningTime` in consensus extra data matches the block's actual timestamp. A malicious miner can modify `ActualMiningTime` values in consensus extra data after generation, allowing them to manipulate term change timing and bypass future time slot validations while the modified block passes all validation checks.

### Finding Description

The vulnerability exists in the consensus validation flow where multiple protections fail to ensure ActualMiningTime integrity:

**Root Cause 1 - Hash Exclusion:**
The `GetCheckableRound()` method explicitly clears `ActualMiningTimes` (along with `EncryptedPieces` and `DecryptedPieces`) before computing the round hash. [1](#0-0) 

**Root Cause 2 - Missing Timestamp Validation:**
When consensus extra data is generated, `ActualMiningTime` is set to `Context.CurrentBlockTime`, which comes from the block header's Time field. [2](#0-1) 

During transaction execution, `Context.CurrentBlockTime` is populated from the block header's Time: [3](#0-2) 

However, there is **no validation** in `ValidateConsensusAfterExecution` that verifies `ActualMiningTime` from the consensus extra data equals `Block.Header.Time`. The validation only compares round hashes after excluding ActualMiningTimes: [4](#0-3) 

**Root Cause 3 - Insufficient Time Slot Validation:**
The `TimeSlotValidationProvider` checks if the miner's latest `ActualMiningTime` falls within their assigned time slot, but does NOT validate it matches the block timestamp: [5](#0-4) 

**Attack Execution Path:**
1. Miner generates valid consensus extra data via `GetConsensusExtraData` with ActualMiningTime = Block.Header.Time = T1
2. Miner modifies the serialized consensus extra data, changing ActualMiningTime to T2 (where T2 is still within their time slot but ≠ T1)
3. Miner includes modified data in block header ExtraData field
4. During `ValidateBeforeExecution`, the modified T2 is recovered into the base round: [6](#0-5) 
5. TimeSlotValidationProvider checks if T2 is within time slot (passes)
6. During `ValidateAfterExecution`, hash comparison succeeds because ActualMiningTimes are excluded
7. Transaction execution stores the false T2 value in consensus state: [7](#0-6) 

### Impact Explanation

**Consensus Term Manipulation:**
The `NeedToChangeTerm` function uses stored `ActualMiningTimes` to determine when to transition to a new term. Manipulated timestamps can delay or accelerate term changes, affecting miner rotation and governance transitions: [8](#0-7) 

**Time Slot Validation Bypass:**
Future blocks' time slot validation checks the latest `ActualMiningTime` from state. False historical timestamps enable miners to bypass time slot restrictions in subsequent rounds: [9](#0-8) 

**Consensus Command Generation Manipulation:**
Block production decisions rely on `ActualMiningTimes` counts and values. Manipulated data affects whether miners can produce tiny blocks or must transition rounds: [10](#0-9) 

**Severity:** Critical - Undermines core consensus timing integrity, enables term manipulation affecting network governance, and allows systematic time slot validation evasion.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a valid miner in the current round (realistic - any elected miner)
- Must be able to modify serialized protobuf consensus extra data (trivial - standard protobuf manipulation)
- Must choose manipulated ActualMiningTime within their time slot range (easy constraint to satisfy)

**Attack Complexity:** Low
- Single-step modification of consensus extra data bytes between generation and block inclusion
- No need for coordination with other miners
- No complex transaction sequences required

**Feasibility Conditions:**
- Attacker produces a block during their assigned time slot (normal miner operation)
- Manipulated ActualMiningTime passes time slot validation (wide acceptable range)
- No cryptographic signatures protect consensus extra data integrity

**Detection Constraints:**
- Block appears valid to all validators (passes all validation checks)
- No on-chain evidence of manipulation (ActualMiningTime excluded from hash)
- Off-chain analysis would need to compare Block.Header.Time with stored ActualMiningTimes

**Probability:** High - Any elected miner can execute this attack on every block they produce with near-zero cost and no detection risk.

### Recommendation

**Primary Fix - Add Timestamp Validation:**
In `ValidateConsensusAfterExecution`, add validation that ActualMiningTime from consensus extra data equals the block's timestamp:

```csharp
// In ValidateConsensusAfterExecution after line 98
if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue ||
    headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
{
    var senderPubkey = headerInformation.SenderPubkey.ToHex();
    var headerActualMiningTime = headerInformation.Round
        .RealTimeMinersInformation[senderPubkey].ActualMiningTimes.LastOrDefault();
    
    // Validate ActualMiningTime matches block timestamp
    if (headerActualMiningTime != null && 
        headerActualMiningTime != Context.CurrentBlockTime)
    {
        return new ValidationResult
        {
            Success = false,
            Message = "ActualMiningTime in consensus extra data does not match block timestamp"
        };
    }
}
```

**Secondary Fix - Validate During Recovery:**
Add timestamp check in `RecoverFromUpdateValue` and `RecoverFromTinyBlock`: [11](#0-10) 

**Test Cases:**
1. Test that blocks with mismatched ActualMiningTime and Block.Header.Time are rejected
2. Test that valid blocks with matching timestamps pass validation
3. Test edge cases around time slot boundaries
4. Test that historical ActualMiningTimes cannot be manipulated in attack scenarios

### Proof of Concept

**Initial State:**
- Attacker is elected miner with time slot [T_start, T_end]
- Current term has N more blocks until term change threshold
- Attacker's goal: Delay term change by providing false ActualMiningTime

**Attack Steps:**

1. **Block Production (Normal):**
   - Attacker's time slot: 10:00:00 - 10:00:04
   - Actual block time: 10:00:02
   - Call `GetConsensusExtraData` → returns data with ActualMiningTime = 10:00:02

2. **Consensus Data Manipulation:**
   - Parse consensus extra data protobuf
   - Locate `MinerInRound.ActualMiningTimes` for attacker
   - Modify last entry from 10:00:02 to 10:00:00 (still within time slot)
   - Serialize modified data back

3. **Block Submission:**
   - Block.Header.Time = 10:00:02 (actual time)
   - Block.Header.ExtraData = modified consensus data (ActualMiningTime = 10:00:00)

4. **Validation (All Pass):**
   - `ValidateBeforeExecution`: TimeSlot check passes (10:00:00 within [10:00:00, 10:00:04])
   - `ValidateAfterExecution`: Hash comparison passes (ActualMiningTimes excluded)
   - No check that 10:00:00 ≠ 10:00:02

5. **State Update:**
   - `UpdateValue` transaction executes
   - Stores ActualMiningTime = 10:00:00 (false value) in consensus state

**Expected Result:** Block rejected due to ActualMiningTime mismatch
**Actual Result:** Block accepted, false timestamp stored, term change calculation now uses manipulated time

**Success Condition:** Query consensus state shows ActualMiningTime = 10:00:00 while Block.Header.Time = 10:00:02, enabling attacker to systematically manipulate term transitions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-99)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L61-68)
```csharp
                var singleTxExecutingDto = new SingleTransactionExecutingDto
                {
                    Depth = 0,
                    ChainContext = groupChainContext,
                    Transaction = transaction,
                    CurrentBlockTime = transactionExecutingDto.BlockHeader.Time,
                    OriginTransactionId = transaction.GetHash()
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L99-113)
```csharp
            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-47)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }

    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L57-80)
```csharp
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }
```
