### Title
Double Removal of Beneficiary Shares Via profitDetailId Bypass of IsWeightRemoved Flag

### Summary
The `RemoveProfitDetails` method contains logic that allows a `ProfitDetail` to be removed twice by specifying its `profitDetailId` in subsequent calls, bypassing the `IsWeightRemoved` flag protection. This causes `TotalShares` to be reduced twice for the same beneficiary, leading to incorrect profit distribution where remaining beneficiaries receive inflated shares.

### Finding Description

The vulnerability exists in the `RemoveProfitDetails` private method. The `TryAdd` accumulation itself works correctly within a single call [1](#0-0) , but the root cause is in how `ProfitDetail` entries are selected for removal.

The initial filtering at lines 321-324 correctly excludes details with `IsWeightRemoved = true` [2](#0-1) . However, special-case logic explicitly adds a detail by `profitDetailId` even if already marked as removed [3](#0-2) . This only checks if the detail exists and is not already in `detailsCanBeRemoved` within the *current* call—it does NOT verify `IsWeightRemoved` status.

When a detail has `LastProfitPeriod < scheme.CurrentPeriod`, it is not physically removed from the collection but kept with `IsWeightRemoved = true` and shortened `EndPeriod` [4](#0-3) . The shares are then added to `removedDetails` [5](#0-4) .

In `RemoveBeneficiary`, the returned `removedDetails` dictionary is used to reduce `TotalShares` [6](#0-5)  and `CachedDelayTotalShares` [7](#0-6) .

**Attack Path:**
1. First call: `RemoveBeneficiary(beneficiary, schemeId, null)` - detail marked `IsWeightRemoved = true`, kept in collection, `TotalShares` reduced by X
2. Second call: `RemoveBeneficiary(beneficiary, schemeId, detailId)` - bypasses flag check via lines 333-338, `TotalShares` reduced by X again

### Impact Explanation

**Direct Fund Impact**: The double reduction of `TotalShares` causes arithmetic corruption in profit distribution. When `DistributeProfits` is called, the artificially reduced `TotalShares` is captured [8](#0-7) . Future profit claims use the formula `(distributedAmount × beneficiaryShares) / TotalShares` [9](#0-8)  with this corrupted denominator.

**Concrete Example:**
- Initial: A (50 shares), B (100 shares), C (100 shares), TotalShares = 250
- Double-remove A: TotalShares becomes 150 (should be 200)
- Distribute 150 tokens: captured TotalShares = 150
- B claims: (100 × 150) / 150 = 100 tokens
- C claims: (100 × 150) / 150 = 100 tokens
- Total: 200 tokens claimed from 150 distributed = **33% theft/overdraw**

This causes either insufficient balance (one beneficiary fails to claim) or enables profit theft from other beneficiaries/sub-schemes sharing the scheme's funds.

**Affected Parties**: All remaining beneficiaries receive incorrect shares; legitimate beneficiaries may lose profits; the scheme's accounting becomes permanently corrupted.

### Likelihood Explanation

**Attacker Capabilities**: Only the scheme manager or TokenHolder contract can call `RemoveBeneficiary` [10](#0-9) . A malicious manager or exploitable TokenHolder contract can execute this attack.

**Attack Complexity**: LOW
1. Call `RemoveBeneficiary` without `profitDetailId` (standard removal)
2. Retrieve the detail's ID from state
3. Call `RemoveBeneficiary` again with the same beneficiary and `profitDetailId`
4. No complex timing, state manipulation, or multi-contract coordination required

**Feasibility Conditions**: The vulnerability triggers when the removed detail has `LastProfitPeriod < scheme.CurrentPeriod` (common when beneficiaries haven't claimed recent profits), causing it to remain in the collection for future claiming [4](#0-3) . Test evidence shows details persist with `IsWeightRemoved = true` in the collection [11](#0-10) .

**Detection**: No on-chain validation prevents this. The scheme manager's actions are not externally audited, and `TotalShares` corruption may go unnoticed until profit distribution fails.

### Recommendation

**Code-Level Mitigation**: Add an `IsWeightRemoved` check before adding the detail in the special-case logic:

```csharp
// Line 333-338 in ProfitContract.cs
if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
    detailsCanBeRemoved.All(d => d.Id != profitDetailId))
{
    var targetDetail = profitDetails.Details.Single(d => d.Id == profitDetailId);
    // ADD THIS CHECK:
    if (!targetDetail.IsWeightRemoved)
    {
        detailsCanBeRemoved.Add(targetDetail);
    }
}
```

**Invariant Check**: Add assertion that `TotalShares` equals the sum of all active (non-removed) beneficiaries' shares after any removal operation.

**Test Case**: Create a test that:
1. Adds a beneficiary with a specific detail ID
2. Calls `RemoveBeneficiary` without `profitDetailId`
3. Verifies `TotalShares` is reduced correctly
4. Calls `RemoveBeneficiary` again with the same `profitDetailId`
5. Asserts `TotalShares` remains unchanged (second call should be no-op)
6. Verifies profit distribution remains accurate

### Proof of Concept

**Initial State:**
- Scheme with beneficiaries: Alice (100 shares), Bob (100 shares)
- `TotalShares = 200`
- Alice has `ProfitDetail` with `id = Hash_A`, `StartPeriod = 1`, `EndPeriod = 10`, `LastProfitPeriod = 1`, `IsWeightRemoved = false`
- `CurrentPeriod = 2`

**Attack Steps:**
1. Manager calls `RemoveBeneficiary(Alice, schemeId, null)`
   - Alice's detail: `IsWeightRemoved = true`, `EndPeriod = 1` (shortened)
   - `TotalShares = 200 - 100 = 100`
   - Detail remains in collection because `LastProfitPeriod (1) < CurrentPeriod (2)`

2. Manager calls `RemoveBeneficiary(Alice, schemeId, Hash_A)`
   - Lines 334-337: Check passes (detail exists, not in current `detailsCanBeRemoved`)
   - Detail added to `detailsCanBeRemoved` despite `IsWeightRemoved = true`
   - `removedDetails.TryAdd(2, 100)` executes again
   - `TotalShares = 100 - 100 = 0`

3. Call `DistributeProfits(schemeId, 100 tokens, period 3)`
   - Captures `TotalShares = 0` (or throws exception if validation exists)
   - Division by zero in `SafeCalculateProfits` when Bob tries to claim

**Expected Result:** Second removal should be no-op; `TotalShares` should remain 100

**Actual Result:** `TotalShares` becomes 0, breaking all future distributions; Bob cannot claim profits despite having 100 shares

### Citations

**File:** contract/AElf.Contracts.Profit/Models/RemovedDetails.cs (L8-18)
```csharp
        public void TryAdd(long key, long value)
        {
            if (ContainsKey(key))
            {
                this[key] = this[key].Add(value);
            }
            else
            {
                this[key] = value;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L237-239)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L243-258)
```csharp
        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L260-260)
```csharp
        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L333-338)
```csharp
        // remove the profitDetail with the profitDetailId, and de-duplicate it before involving.
        if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
            detailsCanBeRemoved.All(d => d.Id != profitDetailId))
        {
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L346-356)
```csharp
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L358-358)
```csharp
                removedDetails.TryAdd(scheme.CurrentPeriod, profitDetail.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L567-567)
```csharp
        distributedProfitsInformation.TotalShares = totalShares;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** test/AElf.Contracts.Election.Tests/Full/BackupSubsidyTests.cs (L370-380)
```csharp
            var candidateShare =
                await GetBackupSubsidyProfitDetails(Address.FromPublicKey(announceElectionKeyPair.PublicKey));
            candidateShare.Details.Count.ShouldBe(1);
            candidateShare.Details.First().Shares.ShouldBe(1);
            candidateShare.Details.First().IsWeightRemoved.ShouldBeTrue();

            var profitReceiverBackShare =
                await GetBackupSubsidyProfitDetails(Address.FromPublicKey(profitReceiver.PublicKey));
            profitReceiverBackShare.Details.Count.ShouldBe(1);
            profitReceiverBackShare.Details.First().Shares.ShouldBe(1);
            profitReceiverBackShare.Details.First().IsWeightRemoved.ShouldBeTrue();
```
