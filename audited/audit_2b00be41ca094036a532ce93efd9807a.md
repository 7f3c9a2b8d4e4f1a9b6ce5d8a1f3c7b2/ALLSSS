### Title
Organization State Manipulation During Active Proposal Voting Enables Governance Attack

### Summary
The Association contract allows organization parameters (thresholds and member lists) to be modified through proposals while other proposals are still being voted on. Since threshold calculation functions (`IsProposalRejected`, `IsProposalAbstained`, `CheckEnoughVoteAndApprovals`) read the current organization state at evaluation time rather than capturing it at proposal creation, attackers can manipulate voting outcomes by changing thresholds or removing voters mid-vote, violating governance invariants.

### Finding Description

**Root Cause:** The Association contract's threshold evaluation functions always use the current organization state from storage, but organization modification methods have no checks preventing changes while active proposals exist.

The three threshold calculation functions all read organization data dynamically: [1](#0-0) [2](#0-1) [3](#0-2) 

These functions filter votes using `organization.OrganizationMemberList.Contains()` and compare counts against `organization.ProposalReleaseThreshold` values. Critically, they receive the organization object as a parameter, which is fetched fresh from state each time.

**Vulnerability Path:** The contract provides multiple methods that modify organization state without checking for active proposals: [4](#0-3) [5](#0-4) [6](#0-5) 

These methods can be invoked via proposals through the organization's virtual address: [7](#0-6) 

**Why Protections Fail:** None of the organization modification methods (`ChangeOrganizationThreshold`, `AddMember`, `RemoveMember`, `ChangeMember`) check whether active proposals exist. The `Validate()` function only checks structural correctness of the organization, not whether modifications would affect pending proposals.

**Proof from Test Suite:** The codebase's own test case demonstrates this behavior: [8](#0-7) 

This test shows a proposal that is `ToBeReleased = true` becoming `ToBeReleased = false` after threshold modification, proving that organization changes retroactively affect existing proposals.

### Impact Explanation

**Governance Manipulation Attacks:**

1. **Censorship Attack:** An attacker creates a proposal to increase `MinimalApprovalThreshold` from 3 to 5. While a competing legitimate proposal has 4 approvals (sufficient under current rules), the attacker passes their threshold-change proposal first. The legitimate proposal can no longer be released despite having received sufficient votes under the original threshold.

2. **Vote Invalidation Attack:** An attacker creates a proposal to remove specific members from `OrganizationMemberList`. Since vote counting uses `organization.OrganizationMemberList.Contains()`, removed members' votes are retroactively discounted, potentially changing proposals from passing to failing state.

3. **Threshold Lowering Attack:** An attacker with control over threshold-modification proposals can lower `MinimalApprovalThreshold` to push through malicious proposals that would otherwise fail.

4. **Member Addition for Vote Dilution:** Adding members changes the denominator for percentage-based threshold calculations (as validated in the `Validate()` function), potentially invalidating proposals that were close to threshold.

**Affected Parties:**
- All organizations using the Association contract
- Legitimate proposers whose proposals can be censored
- Organization members whose voting rights can be retroactively invalidated
- The entire governance system's integrity

**Severity Justification:** This is CRITICAL because it:
- Undermines the fundamental governance security model
- Enables unauthorized control over proposal outcomes
- Allows selective censorship of legitimate proposals
- Can be exploited deterministically by any proposer with threshold-passing capability
- Affects core system governance (Parliament, Association contracts control critical system operations)

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be in the organization's `ProposerWhiteList` (legitimate access)
- Must control enough votes to pass a threshold-modification or member-change proposal
- These are normal operational capabilities, not elevated privileges

**Attack Complexity:**
- Create proposal targeting `ChangeOrganizationThreshold` or member modification methods
- Vote to pass this proposal while target proposals are pending
- Release the modification proposal before target proposals are evaluated
- The attack is deterministic - no race conditions or timing windows needed

**Feasibility Conditions:**
- Multiple proposals must exist concurrently (common in active organizations)
- The attacker's modification proposal must reach threshold before target proposals are released
- This is easily achievable through coordination or in organizations with longer proposal periods

**Detection/Operational Constraints:**
- The attack appears as legitimate governance activity
- No abnormal transaction patterns
- Cannot be distinguished from normal threshold adjustments
- Once executed, changes are permanent until reversed through another proposal

**Economic Rationality:**
- Cost is only the standard proposal creation/voting cost
- Benefit is complete control over competing proposals
- Extremely high ROI for governance capture
- No financial loss risk for attacker

### Recommendation

**Immediate Mitigation:**

1. **Snapshot Organization State at Proposal Creation:** Modify proposal storage to capture organization thresholds and member list at creation time:

```csharp
// In CreateNewProposal method, store organization snapshot
var proposalId = GenerateProposalId(input);
var organization = State.Organizations[input.OrganizationAddress];
var proposal = new ProposalInfo
{
    // ... existing fields ...
    OrganizationSnapshot = new OrganizationSnapshot
    {
        ProposalReleaseThreshold = organization.ProposalReleaseThreshold,
        OrganizationMemberList = organization.OrganizationMemberList
    }
};
```

2. **Use Snapshot in Threshold Calculations:** Modify all threshold check functions to use the snapshotted organization state instead of current state:

```csharp
private bool IsProposalRejected(ProposalInfo proposal)
{
    var snapshot = proposal.OrganizationSnapshot;
    var rejectionMemberCount = 
        proposal.Rejections.Count(snapshot.OrganizationMemberList.Contains);
    return rejectionMemberCount > snapshot.ProposalReleaseThreshold.MaximalRejectionThreshold;
}
```

**Alternative Approach (Less Breaking):**

Add validation to organization modification methods to check for active proposals:

```csharp
public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
{
    var organization = State.Organizations[Context.Sender];
    Assert(organization != null, "Organization not found.");
    
    // NEW: Check for active proposals
    Assert(!HasActiveProposals(Context.Sender), 
        "Cannot modify organization while proposals are pending.");
    
    organization.ProposalReleaseThreshold = input;
    // ... rest of method
}
```

**Required Test Cases:**

1. Test that creating a proposal records organization snapshot
2. Test that threshold changes don't affect existing proposals
3. Test that member removal doesn't invalidate existing votes
4. Test concurrent proposal scenarios with organization modifications
5. Negative test: Verify organization modification fails when active proposals exist (for alternative approach)

### Proof of Concept

**Initial State:**
- Organization with 5 members: [A, B, C, D, E]
- Current thresholds: MinimalApprovalThreshold = 3, MinimalVoteThreshold = 3
- Proposal 1 (legitimate): Some standard governance action
- Proposal 2 (attacker): Call `ChangeOrganizationThreshold` to set MinimalApprovalThreshold = 5

**Attack Sequence:**

1. **T0:** Proposal 1 is created by legitimate proposer
2. **T1:** Members A, B, C approve Proposal 1 (3 votes, meets threshold)
3. **T2:** Attacker creates Proposal 2 targeting `ChangeOrganizationThreshold`
4. **T3:** Members A, B, C approve Proposal 2 (attacker controls these members)
5. **T4:** Attacker releases Proposal 2 via `Release(proposalId2)`
   - `Context.SendVirtualInlineBySystemContract` invokes `ChangeOrganizationThreshold`
   - Organization's `MinimalApprovalThreshold` changes from 3 to 5
6. **T5:** Legitimate proposer attempts to check Proposal 1 status via `GetProposal(proposalId1)`
   - `IsReleaseThresholdReached` is called with CURRENT organization state
   - `CheckEnoughVoteAndApprovals` checks: 3 approvals >= 5 threshold â†’ FALSE
   - Proposal 1 now shows `ToBeReleased = false`
7. **T6:** Legitimate proposer cannot release Proposal 1 despite having met the original threshold

**Expected Result (Secure):** Proposal 1 should remain releasable since it met the threshold at the time votes were cast.

**Actual Result (Vulnerable):** Proposal 1 becomes non-releasable retroactively, enabling censorship.

**Success Condition:** The attacker successfully prevents Proposal 1 from being released by manipulating organization state mid-vote.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-216)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L740-787)
```csharp
    public async Task Change_OrganizationThreshold_Test()
    {
        var minimalApproveThreshold = 1;
        var minimalVoteThreshold = 1;
        var maximalAbstentionThreshold = 1;
        var maximalRejectionThreshold = 1;
        var organizationAddress = await CreateOrganizationAsync(minimalApproveThreshold, minimalVoteThreshold,
            maximalAbstentionThreshold, maximalRejectionThreshold, Reviewer1);
        var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
        await ApproveAsync(Reviewer1KeyPair, proposalId);
        var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
        proposal.ToBeReleased.ShouldBeTrue();


        {
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 2
            };

            var associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
            var changeProposalId = await CreateAssociationProposalAsync(Reviewer1KeyPair,
                proposalReleaseThresholdInput,
                nameof(associationContractStub.ChangeOrganizationThreshold), organizationAddress);
            await ApproveAsync(Reviewer1KeyPair, changeProposalId);
            var result = await associationContractStub.Release.SendWithExceptionAsync(changeProposalId);
            result.TransactionResult.Error.ShouldContain("Invalid organization.");
        }

        {
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 2,
                MinimalApprovalThreshold = minimalApproveThreshold
            };

            var associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
            var changeProposalId = await CreateAssociationProposalAsync(Reviewer1KeyPair,
                proposalReleaseThresholdInput,
                nameof(associationContractStub.ChangeOrganizationThreshold), organizationAddress);
            await ApproveAsync(Reviewer1KeyPair, changeProposalId);
            var result = await associationContractStub.Release.SendAsync(changeProposalId);
            result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            proposal = await associationContractStub.GetProposal.CallAsync(proposalId);
            proposal.ToBeReleased.ShouldBeFalse();
        }
    }
```
