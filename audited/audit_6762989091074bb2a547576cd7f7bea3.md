### Title
Null Reference Exception in Cross-Chain Consensus Update Causes DoS on Side Chain Initialization

### Summary
The `DistributeResourceTokensToPreviousMiners()` function fails to check if `State.MainChainCurrentMinerList.Value` is null before accessing its `Pubkeys` property. On a side chain's first cross-chain consensus update, this state is uninitialized (null), causing a NullReferenceException that prevents all subsequent cross-chain consensus synchronization. This creates a permanent DoS condition for side chain consensus updates.

### Finding Description
The vulnerability exists in the `DistributeResourceTokensToPreviousMiners()` function which is called during every cross-chain consensus update. [1](#0-0) 

The root cause is at line 72 where the code directly accesses `State.MainChainCurrentMinerList.Value.Pubkeys` without checking if `Value` is null. [2](#0-1) 

When `UpdateInformationFromCrossChain` is invoked, it calls `DistributeResourceTokensToPreviousMiners()` before updating the miner list. [3](#0-2) 

For side chains, `MainChainCurrentMinerList` is only set through `UpdateInformationFromCrossChain` and is never initialized during side chain setup. [4](#0-3) 

When a `SingletonState` has never been set, accessing its `Value` property returns `default(T)` which is null for protobuf message types. [5](#0-4) 

The state provider returns null bytes for uninitialized state, which deserializes to null. [6](#0-5) 

Additionally, even if the null issue were fixed, line 81 performs division by `minerList.Count` without checking for zero, which would throw if an empty miner list were received. [7](#0-6) 

### Impact Explanation
This vulnerability causes a complete DoS of cross-chain consensus synchronization for side chains. On the first valid call to `UpdateInformationFromCrossChain` (when round number > 0), the transaction will throw a NullReferenceException, preventing:

1. **Miner list synchronization**: Side chain cannot receive updated miner lists from main chain
2. **Consensus integrity**: Side chain's consensus becomes desynchronized from main chain
3. **Cross-chain operations**: Any functionality depending on synchronized consensus state fails
4. **Token distribution**: Resource tokens cannot be distributed to miners

The impact affects every side chain in the AElf ecosystem, as this code path executes during normal cross-chain consensus updates. Since `UpdateInformationFromCrossChain` can only be called by the CrossChainContract, the side chain cannot work around this issue through alternative methods.

In production environments, the symbol lists for fee and rental tokens are configured with default values, ensuring the division operation at line 81 will be reached if the null issue is bypassed. [8](#0-7) 

### Likelihood Explanation
The null scenario has **100% likelihood** - it is guaranteed to occur on every side chain's first cross-chain consensus update. No attacker action is required; this is a natural consequence of the code logic.

**Preconditions:**
- Side chain is initialized with `IsSideChain=true`
- First cross-chain consensus update is received with `RoundNumber > 0`
- No special attacker capabilities needed

**Attack Complexity:** None - this is a logic bug that triggers automatically.

The "forcing empty miner lists" scenario mentioned in the question is less practical, as it would require the main chain to produce a consensus round with zero miners, which should not occur in a properly functioning blockchain. An attacker cannot force the main chain to send empty miner lists without compromising the main chain's consensus mechanism itself.

### Recommendation
Add null and zero checks before accessing the miner list:

```csharp
private void DistributeResourceTokensToPreviousMiners()
{
    if (State.TokenContract.Value == null)
        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

    // Add null check for MainChainCurrentMinerList
    if (State.MainChainCurrentMinerList.Value == null)
        return;

    var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
    
    // Add zero check for miner count
    if (minerList.Count == 0)
        return;

    foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                 .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
    {
        // ... rest of the function
    }
}
```

Add test cases to verify:
1. First cross-chain update with null MainChainCurrentMinerList succeeds
2. Cross-chain update with empty miner list (RealTimeMinersInformation.Keys) succeeds
3. Token distribution only occurs when previous miner list exists and is non-empty

### Proof of Concept
**Initial State:**
1. Deploy side chain with `IsSideChain=true`
2. `State.MainChainCurrentMinerList` is uninitialized (null)
3. `State.MainChainRoundNumber.Value = 0` (default)

**Exploit Steps:**
1. CrossChainContract calls `UpdateInformationFromCrossChain` with:
   - `Round.RoundNumber = 1` (or any value > 0)
   - `Round.RealTimeMinersInformation` containing valid miners
2. Function passes null/empty check (line 41-42)
3. Function passes round number check (1 > 0, line 46-47)
4. Line 53 calls `DistributeResourceTokensToPreviousMiners()`
5. Line 72 executes: `var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;`
6. `State.MainChainCurrentMinerList.Value` returns null
7. Accessing `.Pubkeys` on null throws `NullReferenceException`

**Expected Result:** Cross-chain consensus update succeeds and miner list is updated

**Actual Result:** Transaction fails with NullReferenceException, preventing all cross-chain consensus synchronization

**Success Condition:** Transaction reverts with NullReferenceException, can be verified by attempting the first cross-chain update on any newly deployed side chain.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-64)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L66-96)
```csharp
    private void DistributeResourceTokensToPreviousMiners()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
            Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
            if (amount <= 0) continue;
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L36-36)
```csharp
    public SingletonState<MinerList> MainChainCurrentMinerList { get; set; }
```

**File:** src/AElf.Sdk.CSharp/State/SingletonState.cs (L36-41)
```csharp
    internal override void Clear()
    {
        Loaded = false;
        _originalValue = default;
        _value = _originalValue;
    }
```

**File:** src/AElf.Types/Helper/SerializationHelper.cs (L88-91)
```csharp
        public static T Deserialize<T>(byte[] bytes)
        {
            if (bytes == null)
                return default;
```

**File:** src/AElf.Blockchains.BasicBaseChain/BasicBaseChainAElfModule.cs (L95-98)
```csharp
            options.ContextVariables["SymbolListToPayTxFee"] =
                newConfig.GetValue("Economic:SymbolListToPayTxFee", "WRITE,READ,STORAGE,TRAFFIC");
            options.ContextVariables["SymbolListToPayRental"] =
                newConfig.GetValue("Economic:SymbolListToPayRental", "CPU,RAM,DISK,NET");
```
