# Audit Report

## Title
Mining Order Manipulation via Unchecked FinalOrderOfNextRound in Consensus Extra Data

## Summary
The AEDPoS consensus validation system fails to verify `FinalOrderOfNextRound` values during `UpdateValue` behavior, allowing malicious miners to occupy future mining orders for other miners. This causes conflict resolution failures that result in multiple miners receiving identical orders in the next round, fundamentally breaking consensus integrity and enabling order manipulation attacks.

## Finding Description

The vulnerability exists in the consensus validation and processing pipeline for `UpdateValue` transactions.

**Root Cause**: When a miner produces a block with `UpdateValue` behavior, `RecoverFromUpdateValue` blindly copies all `FinalOrderOfNextRound` values from the consensus extra data to the base round without validation. [1](#0-0) 

The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`, but **does not validate** `FinalOrderOfNextRound` values. [2](#0-1) 

The `NextRoundMiningOrderValidationProvider` that performs order validation is only added for `NextRound` behavior, not for `UpdateValue`. [3](#0-2) 

**Exploitation Mechanism**:

1. Malicious Miner A crafts consensus extra data with arbitrary `FinalOrderOfNextRound` values for miners who haven't produced blocks yet (e.g., B's Final=2, C's Final=3)

2. During execution, `ExtractInformationToUpdateConsensus` extracts these as `TuneOrderInformation` [4](#0-3) 

3. `ProcessUpdateValue` applies these malicious values to state [5](#0-4) 

4. When Miner B produces their block and their signature happens to result in `SupposedOrderOfNextRound` = 1, `ApplyNormalConsensusData` attempts conflict resolution [6](#0-5) 

5. The conflict resolution fails to find an available order because A's malicious values occupy all orders (1, 2, 3), leaving both A and B with `FinalOrderOfNextRound` = 1

6. The `NextRoundMiningOrderValidationProvider` uses `.Distinct()` on `MinerInRound` **objects** (not order values), counting distinct miners rather than distinct orders [7](#0-6) 

7. `GenerateNextRoundInformation` assigns mining orders based on `FinalOrderOfNextRound`, resulting in multiple miners receiving the same `Order` in the next round [8](#0-7) 

## Impact Explanation

**CRITICAL Consensus Integrity Violation**: This vulnerability allows a single malicious miner to break the fundamental consensus invariant that mining orders must be unique. With multiple miners assigned to the same order in a round, the consensus mechanism cannot function correctly.

Specific impacts include:

1. **Consensus Failure**: Multiple miners attempting to mine at the same order/timeslot creates undefined behavior in block production
2. **Order Manipulation**: Attacker can force specific miners into order conflicts, affecting their ability to mine
3. **MEV Extraction**: Strategic order manipulation enables MEV opportunities across multiple blocks
4. **Miner Reputation Damage**: Honest miners may miss timeslots due to conflicts, being marked as "evil miners"
5. **Network Disruption**: Persistent order collisions can cause rounds to fail or require manual intervention

The severity is HIGH because it compromises the core consensus scheduling mechanism with a single malicious miner action.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attacker Requirements**: Only requires being an active miner (normal operational role)
- **Attack Complexity**: LOW - Simply modify consensus extra data before block publication
- **Detection Difficulty**: HIGH - Validation accepts malicious values as legitimate, no specific monitoring for order manipulation
- **Preconditions**: Always feasible when attacker is mining and multiple miners exist
- **Economic Incentive**: Strong (MEV opportunities, competitive advantages, ability to disrupt competitors)

The attack is straightforward to execute and difficult to attribute, making it highly likely to occur.

## Recommendation

Add validation for `FinalOrderOfNextRound` values during `UpdateValue` behavior:

1. **Immediate Fix**: Extend `UpdateValueValidationProvider` to verify that:
   - `FinalOrderOfNextRound` values are only set for miners who have produced blocks (`OutValue != null`)
   - All `FinalOrderOfNextRound` values are **distinct** (no duplicates)
   - Values are within valid range [0, minerCount]

2. **Enhanced Validation**: Modify `NextRoundMiningOrderValidationProvider` to check for distinct **order values**, not just distinct miners:
   ```csharp
   var distinctOrders = providedRound.RealTimeMinersInformation.Values
       .Where(m => m.FinalOrderOfNextRound > 0)
       .Select(m => m.FinalOrderOfNextRound)
       .Distinct()
       .Count();
   ```

3. **Cryptographic Protection**: Consider adding a signature or hash over the complete `TuneOrderInformation` to ensure miners cannot unilaterally modify other miners' orders

4. **State Consistency Check**: Add assertion in `GenerateNextRoundInformation` to detect and reject rounds with duplicate orders before applying them

## Proof of Concept

```csharp
// Scenario: 3 miners {A, B, C} in current round
// 
// Step 1: Miner A produces block
// - A's signature â†’ SupposedOrderOfNextRound = 1
// - A maliciously sets in consensus extra data:
//   * A's FinalOrderOfNextRound = 1 (legitimate)
//   * B's FinalOrderOfNextRound = 2 (malicious)
//   * C's FinalOrderOfNextRound = 3 (malicious)
//
// Step 2: Validation passes (no FinalOrderOfNextRound validation in UpdateValue)
//
// Step 3: TuneOrderInformation = {B: 2, C: 3} applied to state
//
// Step 4: Miner B produces block
// - B's signature happens to result in SupposedOrderOfNextRound = 1
// - ApplyNormalConsensusData conflict resolution:
//   * Finds A has FinalOrderOfNextRound = 1 (conflict)
//   * Tries to reassign A to order 2: occupied by B
//   * Tries to reassign A to order 3: occupied by C
//   * Tries to reassign A to order 1: occupied by A
//   * Reassignment fails, A remains at order 1
// - Line 44: B's FinalOrderOfNextRound = 1
//
// Result: Both A and B have FinalOrderOfNextRound = 1
//
// Step 5: NextRound triggered
// - NextRoundMiningOrderValidationProvider:
//   * distinctCount = 3 (counts distinct MinerInRound objects)
//   * minersWithOutValue = 3
//   * Validation PASSES (should fail!)
//
// Step 6: GenerateNextRoundInformation
// - Miners ordered by FinalOrderOfNextRound: A(1), B(1), C(3)
// - Both A and B assigned Order = 1 in next round
// - CONSENSUS INTEGRITY VIOLATED
```

**Test Verification**: This can be tested by modifying consensus extra data in a block to set `FinalOrderOfNextRound` values for non-mining miners, then observing that validation passes and duplicate orders are created in the next round.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-27)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-40)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
