# Audit Report

## Title
Quadratic Voting Amount Mismatch Causes Permanent Token Lock and Withdrawal DoS

## Summary
The Vote contract's quadratic voting implementation contains a critical arithmetic mismatch where voting results are updated with a value of `1` while the full calculated token amount is locked. This discrepancy causes all withdrawal attempts to fail with an overflow exception, permanently locking user funds.

## Finding Description

The vulnerability exists in the `Vote()` method's handling of quadratic voting amounts. The root cause is a mismatch between the amount recorded in voting results versus the amount stored in voting records and locked tokens.

**Vote Flow - Amount Calculation:**
For quadratic voting, the amount is calculated as `TicketCost * currentVotesCount`. [1](#0-0) 

**Vote Flow - Recording:**
The VotingRecord correctly stores the full calculated amount. [2](#0-1) 

**Vote Flow - Critical Bug:**
The `UpdateVotingResult` method receives `votingItem.IsQuadratic ? 1 : amount`, passing only `1` for quadratic votes instead of the full amount. [3](#0-2) 

**Vote Flow - Token Locking:**
Tokens are locked using the full calculated amount. [4](#0-3) 

**UpdateVotingResult Implementation:**
This method adds the passed amount to both `Results[option]` and `VotesAmount`. For quadratic votes, it only adds `1`. [5](#0-4) 

**Withdrawal Flow - Failure Point:**
During withdrawal, the code attempts to subtract `votingRecord.Amount` from `VotingResult` fields. [6](#0-5) 

**SafeMath Overflow Protection:**
The `Sub()` method uses checked arithmetic, which throws `OverflowException` on underflow. [7](#0-6) 

## Impact Explanation

**Direct Financial Impact:**
- All tokens locked through quadratic voting become permanently locked and unrecoverable
- Users lose access to their staked funds indefinitely  
- No recovery mechanism exists in the contract

**Operational Impact:**
- Complete denial-of-service for quadratic voting feature
- Users cannot withdraw after voting, making the feature completely unusable
- Voting results are corrupted (showing vote counts of 1 instead of actual token amounts)

**Severity: CRITICAL**
1. Results in permanent, irreversible loss of user funds
2. Affects 100% of quadratic voting participants
3. No workaround or recovery path exists
4. Breaks core contract invariant: all locked tokens must be unlockable

## Likelihood Explanation

**Exploitability: CERTAIN (100%)**

This vulnerability is triggered by normal user operations:
- No special permissions or attack setup required
- Any user participating in quadratic voting is affected
- Occurs through standard vote and withdraw calls

**Attack Complexity: Trivial**
Steps: 
1. Register a quadratic voting item (IsQuadratic=true)
2. User votes with any amount
3. User attempts withdrawal → guaranteed failure

**Execution Practicality:**
- Fully executable under normal AElf contract semantics
- No special preconditions beyond having a quadratic voting item
- Withdrawal attempts guaranteed to fail on first try due to arithmetic underflow (e.g., attempting `1 - 300`)

This is not a probabilistic vulnerability - it occurs with 100% certainty on every quadratic vote withdrawal attempt.

## Recommendation

Fix the amount passed to `UpdateVotingResult` for quadratic voting:

```csharp
// Line 119 - Change from:
UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);

// To:
UpdateVotingResult(votingItem, input.Option, amount);
```

The conditional `votingItem.IsQuadratic ? 1 : amount` should be removed entirely, as both quadratic and non-quadratic voting should track the actual token amounts in voting results to maintain consistency with voting records and token locks.

## Proof of Concept

```csharp
[Fact]
public async Task QuadraticVoting_Withdrawal_Fails_Due_To_Underflow()
{
    // Register quadratic voting item with TicketCost=100
    var votingItem = await RegisterVotingItemAsync(
        totalSnapshotNumber: 1, 
        isLockToken: true, 
        isQuadratic: true,
        ticketCost: 100
    );
    
    var voter = Accounts[1];
    
    // First vote: amount = 100 * 1 = 100 tokens locked
    // But VotingResult only records 1
    var vote1Result = await Vote(voter.KeyPair, votingItem.VotingItemId, votingItem.Options[0], 0);
    vote1Result.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Get vote ID from voted items
    var voteIds = await GetVoteIds(voter.KeyPair, votingItem.VotingItemId);
    var voteId = voteIds.ActiveVotes.First();
    
    // Verify voting record shows 100 tokens
    var votingRecord = await GetVotingRecord(voteId);
    votingRecord.Amount.ShouldBe(100);
    
    // Verify voting result only shows 1
    var votingResult = await GetVotingResult(votingItem.VotingItemId, 1);
    votingResult.Results[votingItem.Options[0]].ShouldBe(1); // BUG: Should be 100
    votingResult.VotesAmount.ShouldBe(1); // BUG: Should be 100
    
    // Attempt withdrawal - this will FAIL with overflow exception
    // Because it tries: votingResult.Results[option].Sub(100)
    // Which is: 1.Sub(100) → throws OverflowException
    var withdrawResult = await WithdrawWithException(voter.KeyPair, voteId);
    withdrawResult.Status.ShouldBe(TransactionResultStatus.Failed);
    withdrawResult.Error.ShouldContain("Overflow"); // Tokens permanently locked
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L98-103)
```csharp
        else
        {
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-117)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L119-119)
```csharp
        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L122-130)
```csharp
        if (votingItem.IsLockToken)
            // Lock voted token.
            State.TokenContract.Lock.Send(new LockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                LockId = input.VoteId,
                Amount = amount
            });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L214-220)
```csharp
        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```
