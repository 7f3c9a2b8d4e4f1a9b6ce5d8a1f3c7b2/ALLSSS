### Title
Period Boundary Validation Bypass Causing Permanent Profit Pool Dilution

### Summary
The `AddBeneficiary` and `FixProfitDetail` methods fail to validate that `StartPeriod <= EndPeriod`, allowing creation of invalid `ProfitDetail` entries where `StartPeriod > EndPeriod`. These invalid entries contribute shares to the scheme's `TotalShares` but can never claim profits (filtered out by period boundary checks), causing permanent dilution of the profit pool and reducing payouts to legitimate beneficiaries.

### Finding Description

**Root Cause:**

In `AddBeneficiary`, the method validates that `input.EndPeriod >= scheme.CurrentPeriod` but fails to validate against the calculated `StartPeriod`. [1](#0-0) 

The `StartPeriod` is calculated as `scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount)` and `EndPeriod` is set from input, with no check ensuring `StartPeriod <= EndPeriod`. [2](#0-1) 

Critically, shares are added to `TotalShares` BEFORE the `ProfitDetail` is created, meaning invalid entries still dilute the profit pool. [3](#0-2) 

Similarly, `FixProfitDetail` allows arbitrary modification of `StartPeriod` and `EndPeriod` without validation. [4](#0-3) 

**Why Protections Fail:**

When claiming profits, invalid details (where `EndPeriod < StartPeriod`) are filtered out by the condition `d.EndPeriod >= d.StartPeriod`, preventing them from ever claiming. [5](#0-4) 

The same filtering occurs in view methods used for profit calculations. [6](#0-5) 

**Execution Path:**
1. Scheme created with `DelayDistributePeriodCount = 3`, `CurrentPeriod = 5`
2. Manager calls `AddBeneficiary` with `EndPeriod = 5` (passes check `>= CurrentPeriod`)
3. `StartPeriod` calculated as `5 + 3 = 8`, `EndPeriod = 5` (INVALID: `8 > 5`)
4. Shares added to `TotalShares`, diluting all future distributions
5. Beneficiary attempts to claim but is filtered out (cannot claim)
6. Profits proportional to these shares remain locked in virtual addresses forever

### Impact Explanation

**Direct Fund Impact:**

For every distribution period, profits are calculated as `(beneficiary_shares / TotalShares) * amount`. Invalid beneficiaries with unclaimed shares artificially inflate `TotalShares`, reducing the share ratio for legitimate beneficiaries.

**Concrete Example:**
- Scheme has BeneficiaryA: 100 shares (valid)
- Manager adds BeneficiaryB: 100 shares (invalid periods)
- `TotalShares = 200`
- Distribution of 1000 tokens:
  - BeneficiaryA receives: `(100/200) * 1000 = 500` tokens (should be 1000)
  - BeneficiaryB filtered out, receives: 0 tokens
  - **500 tokens permanently locked** in virtual address

**Who is Affected:**
- All legitimate beneficiaries receive reduced profits (50% loss in example above)
- Accumulates over time as more distributions occur
- Protocol loses ability to properly distribute rewards

**Severity Justification:**
HIGH - Direct, quantifiable fund misallocation affecting all beneficiaries in the scheme, with permanent fund lockup.

### Likelihood Explanation

**Attacker Capabilities:**
Requires manager role of the profit scheme. However, this is not a malicious attack scenario but a design flaw allowing invalid state.

**Feasibility Conditions:**
- Normal operational scenario: Manager legitimately sets `EndPeriod = CurrentPeriod` (intending beneficiary receives profits from current period only)
- Not realizing that with `DelayDistributePeriodCount > 0`, this creates invalid state
- Common in schemes using delayed distribution (e.g., Treasury, TokenHolder schemes)

**Execution Practicality:**
Entry points `AddBeneficiary` and `FixProfitDetail` are standard operations. The existing test suite shows `EndPeriod = CurrentPeriod` is considered valid. [7](#0-6) 

**Detection/Operational Constraints:**
- Invalid state is not immediately visible
- Profit calculations appear correct (shares counted in `TotalShares`)
- Only manifests when beneficiary attempts to claim and receives nothing
- No revert or error, silent failure

**Probability:**
HIGH - Any scheme using `DelayDistributePeriodCount > 0` is vulnerable when managers set `EndPeriod` close to `CurrentPeriod`.

### Recommendation

**Code-level Mitigation:**

Add validation in `AddBeneficiary` after calculating `StartPeriod`:

```csharp
var profitDetail = new ProfitDetail
{
    StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
    EndPeriod = input.EndPeriod,
    Shares = input.BeneficiaryShare.Shares,
    Id = input.ProfitDetailId
};

Assert(profitDetail.StartPeriod <= profitDetail.EndPeriod, 
    $"Invalid period range. StartPeriod ({profitDetail.StartPeriod}) must be <= EndPeriod ({profitDetail.EndPeriod})");
```

Add validation in `FixProfitDetail` after setting new values:

```csharp
newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;

Assert(newDetail.StartPeriod <= newDetail.EndPeriod,
    $"Invalid period range. StartPeriod ({newDetail.StartPeriod}) must be <= EndPeriod ({newDetail.EndPeriod})");
```

**Invariant Check:**
Ensure `ProfitDetail.StartPeriod <= ProfitDetail.EndPeriod` holds for all details in `ProfitDetailsMap`.

**Test Cases:**
1. Test `AddBeneficiary` with `EndPeriod = CurrentPeriod` when `DelayDistributePeriodCount > 0` (should revert)
2. Test `FixProfitDetail` setting `StartPeriod > EndPeriod` (should revert)
3. Verify existing valid details remain claimable after fix

### Proof of Concept

**Initial State:**
1. Create scheme: `CurrentPeriod = 5`, `DelayDistributePeriodCount = 3`
2. Add BeneficiaryA: `Shares = 100`, `EndPeriod = 100`
   - Result: `StartPeriod = 8`, `EndPeriod = 100`, `TotalShares = 100` ✓

**Exploit Execution:**
3. Add BeneficiaryB: `Shares = 100`, `EndPeriod = 5`
   - Passes check: `5 >= 5` ✓
   - Result: `StartPeriod = 8`, `EndPeriod = 5`, `TotalShares = 200` 
   - **Invalid state created: `8 > 5`**

4. Distribute 1000 tokens for period 10:
   - `DistributedProfitsInfo.TotalShares = 200`
   - `DistributedProfitsInfo.Amount = 1000`

**Expected vs Actual Result:**

*Expected (if BeneficiaryB valid):*
- BeneficiaryA claims: `(100/200) * 1000 = 500` tokens
- BeneficiaryB claims: `(100/200) * 1000 = 500` tokens
- Total: 1000 tokens distributed

*Actual (with invalid BeneficiaryB):*
- BeneficiaryA claims: `(100/200) * 1000 = 500` tokens (reduced!)
- BeneficiaryB claim attempt:
  - Check `EndPeriod (5) >= StartPeriod (8)`: FALSE
  - Filtered out, receives: 0 tokens
- **500 tokens permanently locked in virtual address**

**Success Condition:**
Invalid `ProfitDetail` created with `StartPeriod > EndPeriod`, contributing shares to `TotalShares` but never eligible to claim profits, causing permanent dilution of legitimate beneficiaries' rewards.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L179-180)
```csharp
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-184)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L299-301)
```csharp
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-767)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L113-117)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod < scheme.CurrentPeriod && (d.LastProfitPeriod == 0
                ? d.EndPeriod >= d.StartPeriod
                : d.EndPeriod >= d.LastProfitPeriod)
        ).ToList();
```

**File:** test/AElf.Contracts.Profit.Tests/ProfitTests.cs (L502-509)
```csharp
            var executionResult = await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
            {
                SchemeId = schemeId,
                BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiary, Shares = shares },
                EndPeriod = 1
            });

            executionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
```
