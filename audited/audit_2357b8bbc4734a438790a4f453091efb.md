# Audit Report

## Title
Multi-Identity Continuous Block Limit Bypass via Controlled Miner Rotation

## Summary

An entity controlling multiple elected miner positions can bypass the 8-block continuous production limit by rotating between different public keys. The counter reset mechanism tracks limits per-pubkey rather than per-entity, allowing a coordinated attacker to produce N×8 continuous blocks instead of the intended maximum of 8, undermining the fork prevention design goal.

## Finding Description

The AEDPoS consensus implements a continuous block limit to prevent excessive fork creation. However, this protection operates at the individual public key level without detecting coordinated control across multiple miner identities.

The vulnerability exists in the interaction between three components:

**1. Validation Logic (Per-Pubkey Only):**
The continuous block validator only rejects blocks when the SAME pubkey exceeds the limit. [1](#0-0)  When a different pubkey produces a block, validation passes unconditionally.

**2. Counter Reset Mechanism (Exploitable):**
The counter reset logic treats different pubkeys as independent producers. [2](#0-1)  When a different pubkey produces a block, the counter resets to `minersCountInTheory - 1` (typically 7), rather than tracking cumulative continuous blocks across potentially related entities.

**3. No Multi-Identity Prevention:**
The election system allows a single admin to control multiple candidate pubkeys without restrictions. [3](#0-2) [4](#0-3) 

The election victory selection is purely vote-based with no same-controller detection: [5](#0-4) 

The `BreakContinuousMining` scheduling mechanism only prevents the SAME pubkey from mining consecutively across rounds, not different pubkeys controlled by the same entity: [6](#0-5) 

**Attack Execution:**
1. Entity X registers N candidates using `AnnounceElectionFor` with different pubkeys (requires N × 100,000 ELF) [7](#0-6) 
2. Gets them elected through voting
3. If scheduled consecutively or nearby, Miner A produces 8 blocks (counter: 7→6→...→0)
4. Miner B produces next 8 blocks (counter resets to 7 because different pubkey)
5. Miner C continues for another 8 blocks (counter resets again)
6. Total: 24 continuous blocks instead of intended 8

The maximum blocks constant is defined as 8: [8](#0-7) 

## Impact Explanation

**Severity: MEDIUM-HIGH**

The continuous block limit's explicit purpose is "to avoid too many forks" [9](#0-8) , making this bypass a direct consensus integrity violation.

**Concrete Harms:**
- **Fork Probability Multiplication:** With N controlled miners, fork risk increases by factor of N (3 miners = 3× risk with 24 blocks vs 8)
- **LIB Delay:** Excessive continuous blocks delay round progression, which is required for Last Irreversible Block height advancement
- **Consensus Dominance:** Coordinated miners can dominate block production within their collective time slots
- **Design Invariant Violation:** Breaks the fundamental assumption that no entity can produce more than 8 continuous blocks

**Affected Parties:** All network participants depending on timely finality and fair consensus operation.

## Likelihood Explanation

**Likelihood: MEDIUM**

**Required Capabilities:**
- Economic: N × 100,000 ELF deposit (e.g., 300,000 ELF for 3 miners)
- Governance: Maintain sufficient votes for multiple candidates to be elected
- Coordination: Time block production during respective time slots

**Feasibility Assessment:**
- Entry points are public and unrestricted (`AnnounceElectionFor`, consensus commands)
- No technical or cryptographic barriers
- High capital requirement limits casual exploitation
- However, achievable for well-funded entities, whale voters, or validator cartels
- No detection mechanism exists to identify related miner identities or admins

**Existing Mitigation (Insufficient):**
Dynamic adjustment during severe blockchain status reduces the limit to 1 block [10](#0-9) , but this is reactive (triggers after damage) rather than preventive.

## Recommendation

Implement entity-level or time-period-based continuous block tracking instead of per-pubkey tracking:

**Option 1: Cumulative Time Window Tracking**
Track total continuous blocks within a time window across all miners, regardless of pubkey. Reject blocks that exceed the cumulative limit within that window.

**Option 2: Admin-Aware Validation**
- Maintain mapping of candidate admins to their controlled pubkeys
- Track continuous blocks across all pubkeys controlled by the same admin
- Reject when cumulative admin-level limit is exceeded

**Option 3: Forced Round Progression**
After N continuous blocks (regardless of pubkey changes), mandate NextRound behavior to break continuity and recalculate LIB.

**Implementation Consideration:**
Modify `ResetLatestProviderToTinyBlocksCount` to maintain a rolling window or admin-aware counter instead of resetting on pubkey change.

## Proof of Concept

```csharp
// Test demonstrating the bypass
[Fact]
public async Task MultiIdentity_ContinuousBlock_Bypass()
{
    // Setup: Entity X registers 3 candidates with different pubkeys
    var adminAddress = Accounts[0].Address;
    var miner1Keypair = SampleAccount.Accounts[1].KeyPair;
    var miner2Keypair = SampleAccount.Accounts[2].KeyPair;
    var miner3Keypair = SampleAccount.Accounts[3].KeyPair;
    
    // Register all 3 candidates with same admin
    await AnnounceElectionFor(miner1Keypair.PublicKey.ToHex(), adminAddress);
    await AnnounceElectionFor(miner2Keypair.PublicKey.ToHex(), adminAddress);
    await AnnounceElectionFor(miner3Keypair.PublicKey.ToHex(), adminAddress);
    
    // Get them elected (simplified - requires voting in real scenario)
    await ElectMiners(new[] { miner1Keypair, miner2Keypair, miner3Keypair });
    
    // Simulate block production
    int totalContinuousBlocks = 0;
    
    // Miner 1 produces 8 blocks
    for (int i = 0; i < 8; i++) {
        await ProduceBlock(miner1Keypair);
        totalContinuousBlocks++;
    }
    // Counter for miner1 now at 0, next would fail
    
    // Miner 2 produces 8 blocks (counter RESETS because different pubkey)
    for (int i = 0; i < 8; i++) {
        await ProduceBlock(miner2Keypair); // Should ideally fail but passes
        totalContinuousBlocks++;
    }
    
    // Miner 3 produces 8 blocks (counter RESETS again)
    for (int i = 0; i < 8; i++) {
        await ProduceBlock(miner3Keypair); // Should ideally fail but passes
        totalContinuousBlocks++;
    }
    
    // Assert: 24 continuous blocks produced instead of intended max of 8
    totalContinuousBlocks.ShouldBe(24);
    // Expected to be <= 8, but bypass allows 24
}
```

**Notes**

The vulnerability is rooted in a fundamental design assumption: that the 8-block limit per pubkey would effectively limit continuous blocks. This assumption breaks when a single entity controls multiple elected miner identities. The lack of entity-level tracking or admin-to-miner correlation in the validation logic creates an exploitable gap between the intended security property (limit continuous blocks to prevent forks) and the actual implementation (limit per-pubkey only).

While the economic barrier is significant, the increasing stake of large validators and potential for validator coordination makes this a realistic concern for network stability and decentralization.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L358-363)
```csharp
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L104-106)
```csharp
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L129-131)
```csharp
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-81)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L18-19)
```csharp
    ///     Implemented GitHub PR #1952.
    ///     Adjust (mainly reduce) the count of tiny blocks produced by a miner each time to avoid too many forks.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```
