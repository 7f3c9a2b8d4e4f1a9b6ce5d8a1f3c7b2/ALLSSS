### Title
Missing Validation for Extra Block Producer Authority in NextRound Transitions

### Summary
The `ProcessNextRound` method accepts the `ExtraBlockProducerOfPreviousRound` field from `NextRoundInput` without validating that the transaction sender was actually the designated extra block producer (with `IsExtraBlockProducer = true`) in the current round. This validation gap allows non-designated miners to potentially claim extra block producer rights for the next round during abnormal network conditions, violating consensus integrity.

### Finding Description

The vulnerability exists in the NextRound consensus transition flow: [1](#0-0) 

When a miner produces a NextRound block, they set `nextRound.ExtraBlockProducerOfPreviousRound = pubkey` to their own public key. This value is then passed via `NextRoundInput`: [2](#0-1) 

The `ProcessNextRound` method accepts this input and stores it directly without validation: [3](#0-2) 

The validation providers used for NextRound behavior do not check if the sender was the designated extra block producer: [4](#0-3) 

The `RoundTerminateValidationProvider` only validates round number correctness and InValue nullness: [5](#0-4) 

The `MiningPermissionValidationProvider` only checks if the sender is in the miner list, not if they're the designated extra block producer: [6](#0-5) 

This allows the incorrectly recorded miner to produce blocks at the start of the next round: [7](#0-6) 

### Impact Explanation

This vulnerability allows a non-designated miner to gain unauthorized block production rights, causing:

1. **Consensus Integrity Violation**: The pseudo-random selection mechanism for extra block producers is bypassed, as any miner can claim this role instead of the algorithmically selected one
2. **Unfair Block Rewards**: The attacker gains additional block production opportunities at the start of the next round, earning mining rewards they shouldn't receive
3. **Round Transition Manipulation**: The intended consensus flow where specific miners terminate rounds is violated, potentially affecting timing and LIB height calculations
4. **Trust Degradation**: Honest miners lose confidence in consensus fairness when arbitrary miners can claim extra block producer status

The severity is HIGH because it directly violates the critical invariant "Correct round transitions and time-slot validation, miner schedule integrity" and allows unauthorized consensus state manipulation.

### Likelihood Explanation

**Attack Feasibility**: Medium-High

**Attacker Capabilities Required**:
- Must be an active miner in the current round
- Must be able to produce and broadcast blocks
- No privileged role compromise needed

**Execution Conditions**:
1. During abnormal network conditions (designated extra block producer offline/delayed)
2. When multiple miners reach the post-round timeout period
3. Race condition where attacker's NextRound block propagates first

**Attack Complexity**: Medium
- The attacker must time their NextRound block production when the legitimate extra block producer is slow/absent
- Requires understanding of round timing and consensus behavior
- The validation gap makes exploitation straightforward once conditions are met

**Detection Difficulty**: High - appears as normal round transition in logs, only detectable by comparing intended vs actual extra block producer

**Economic Rationality**: Profitable - attacker gains extra mining opportunities and rewards with minimal cost beyond normal mining operations

### Recommendation

**Primary Fix**: Add validation in `ValidateBeforeExecution` to verify the NextRound sender was the designated extra block producer:

1. In `RoundTerminateValidationProvider.ValidationForNextRound()`, add:
```csharp
// Verify sender was the designated extra block producer
var currentRound = validationContext.BaseRound;
var senderPubkey = validationContext.SenderPubkey;
var designatedProducer = currentRound.RealTimeMinersInformation.Values
    .FirstOrDefault(m => m.IsExtraBlockProducer)?.Pubkey;

if (designatedProducer != senderPubkey)
{
    return new ValidationResult 
    { 
        Message = $"Only designated extra block producer {designatedProducer} can produce NextRound, not {senderPubkey}" 
    };
}

// Verify ExtraBlockProducerOfPreviousRound matches sender
if (extraData.Round.ExtraBlockProducerOfPreviousRound != senderPubkey)
{
    return new ValidationResult 
    { 
        Message = "ExtraBlockProducerOfPreviousRound must match transaction sender" 
    };
}
```

**Secondary Fix**: Add assertion in `ProcessNextRound`:
```csharp
var currentRound = State.Rounds[State.CurrentRoundNumber.Value];
var designatedProducer = currentRound.RealTimeMinersInformation.Values
    .First(m => m.IsExtraBlockProducer).Pubkey;
Assert(_processingBlockMinerPubkey == designatedProducer, 
    "Only designated extra block producer can execute NextRound");
Assert(nextRound.ExtraBlockProducerOfPreviousRound == _processingBlockMinerPubkey,
    "ExtraBlockProducerOfPreviousRound must match sender");
```

**Test Cases**:
- Verify non-designated miner cannot produce valid NextRound block
- Verify ExtraBlockProducerOfPreviousRound field must match sender
- Verify designated extra block producer can still produce NextRound normally

### Proof of Concept

**Initial State**:
- Round N with miners: [A, B, C, D, E]
- E is designated extra block producer (E.IsExtraBlockProducer = true)
- All miners have completed their normal time slots
- Extra block mining time has arrived

**Attack Steps**:
1. Miner B (not designated) monitors network and detects E is offline/slow
2. B's node reaches timeout condition and generates NextRound consensus command
3. B produces NextRound block with:
   - `NextRoundInput.ExtraBlockProducerOfPreviousRound = B`
   - Valid round structure passing `CheckRoundTimeSlots()`
   - Correct round number (N+1)
4. B broadcasts this NextRound block
5. Validation executes:
   - `MiningPermissionValidationProvider`: PASS (B is in miner list)
   - `TimeSlotValidationProvider`: PASS (round structure valid)
   - `RoundTerminateValidationProvider`: PASS (round number correct, InValues null)
   - **MISSING CHECK**: No validation that B was designated extra block producer
6. `ProcessNextRound` stores the round with B as `ExtraBlockProducerOfPreviousRound`
7. Round N+1 begins with B incorrectly recorded as previous extra block producer

**Expected Result**: NextRound block validation should reject B's block because B.IsExtraBlockProducer = false

**Actual Result**: B's NextRound block is accepted, B gains unauthorized mining rights at the start of round N+1

**Success Condition**: In round N+1, before the official round start time, B can produce blocks via the check at lines 150-155 despite not being the legitimate previous round's extra block producer

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-179)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

```

**File:** protobuf/aedpos_contract.proto (L467-468)
```text
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-24)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L149-155)
```csharp
        // Check confirmed extra block producer of previous round.
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```
