### Title
Precision Loss in SafeCalculateProfits Causes Permanent Fund Lockup in Period-Specific Virtual Addresses

### Summary
The `SafeCalculateProfits` method in ProfitContract uses a truncating `(long)` cast that always rounds down profit calculations, causing dust amounts to accumulate in period-specific virtual addresses. Since each period has a unique virtual address generated via hash functions and no recovery mechanism exists, these dust amounts become permanently locked and unrecoverable, leading to cumulative fund loss over time.

### Finding Description

**Root Cause:**
The `SafeCalculateProfits` method performs profit distribution calculations using decimal arithmetic but truncates the result when casting back to long: [1](#0-0) 

This truncation always rounds DOWN, meaning each beneficiary receives slightly less than their exact proportional share.

**Two-Level Precision Loss:**

1. **First Level - Sub-scheme Distribution:**
When `DistributeProfits` is called, it distributes to sub-schemes using `SafeCalculateProfits`: [2](#0-1) 

The truncated amounts are sent to sub-schemes, and the remainder goes to the period-specific virtual address: [3](#0-2) 

2. **Second Level - Individual Claims:**
When beneficiaries claim profits via `ClaimProfits`, the same truncation occurs again: [4](#0-3) 

**Why Funds Become Permanently Locked:**

Each period uses a unique virtual address generated by XORing the scheme ID with a hash of the period number: [5](#0-4) 

This means:
- Period 1's dust remains in its unique virtual address
- Period 2's dust accumulates in a different unique virtual address  
- These addresses are never reused or swept

**No Recovery Mechanism:**
A comprehensive search of the ProfitContract revealed no admin functions, emergency withdrawal methods, or sweep mechanisms to recover dust from old period virtual addresses. The only balance-handling method is `BurnProfits`, which destroys tokens rather than recovering them.

**Evidence of Known Issue:**
Test files explicitly acknowledge and allow for rounding losses: [6](#0-5) [7](#0-6) 

These assertions allow individual claims to be 2 tokens short and total distributions to be 6 tokens short, proving developers are aware of precision loss but have not implemented recovery.

### Impact Explanation

**Direct Fund Loss:**
- Each distribution period loses approximately 1 token per beneficiary due to rounding
- For a TokenHolder scheme with 100 participants distributing daily:
  - Daily loss: ~1-2 tokens (depending on amount and share ratios)
  - Annual loss: 365-730 tokens permanently locked
  - Over 5 years: 1,825-3,650 tokens per scheme
  
**Systemic Impact:**
- Affects ALL profit schemes including Treasury, TokenHolder, and Election dividends
- TokenHolder contract delegates to ProfitContract, inheriting this vulnerability: [8](#0-7) [9](#0-8) 

**Worst-Case Scenario:**
- Distribution of 99 tokens among 3 beneficiaries with shares (3333, 3333, 3334):
  - Beneficiary 1: `(long)(99 * 3333 / 10000)` = 32 tokens
  - Beneficiary 2: `(long)(99 * 3333 / 10000)` = 32 tokens
  - Beneficiary 3: `(long)(99 * 3334 / 10000)` = 33 tokens
  - Total: 97 tokens distributed, **2 tokens permanently locked**

**Who Is Affected:**
- All scheme participants (lose proportional dust amounts)
- Protocol treasury (accumulates locked funds over time)
- Token holders in staking/dividend schemes

### Likelihood Explanation

**Probability: CERTAIN (100%)**
- Occurs automatically on EVERY profit distribution where shares don't divide evenly
- No attacker action required - this is a design flaw
- Guaranteed to happen with any non-trivial share distribution

**Reachability:**
`DistributeProfits` is publicly callable by scheme managers and the TokenHolder contract: [10](#0-9) 

**Execution Complexity: TRIVIAL**
- Normal protocol operation triggers the vulnerability
- No special conditions or timing requirements
- Works under all standard AElf contract semantics

**Economic Rationality:**
- While individual amounts are small, cumulative loss over hundreds of periods is significant
- For high-value schemes or tokens, even 0.01% loss per distribution becomes material
- No exploitation cost - happens automatically

### Recommendation

**Immediate Fix - Add Dust Recovery Mechanism:**

1. **Track Accumulated Dust:**
```
// Add to Scheme message
int64 accumulated_dust_amount = X;
map<string, int64> dust_by_symbol = Y;
```

2. **Implement Recovery Function:**
```csharp
public override Empty RecoverPeriodDust(RecoverPeriodDustInput input)
{
    // Only scheme manager can recover
    var scheme = State.SchemeInfos[input.SchemeId];
    Assert(Context.Sender == scheme.Manager, "Only manager can recover dust.");
    
    // Get period virtual address
    var periodVirtualAddress = GetDistributedPeriodProfitsVirtualAddress(
        input.SchemeId, input.Period);
    
    // Verify period is old enough (e.g., > ProfitReceivingDuePeriodCount)
    Assert(input.Period + scheme.ProfitReceivingDuePeriodCount < scheme.CurrentPeriod,
        "Period not eligible for dust recovery yet.");
    
    // Transfer remaining balance to scheme general ledger
    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
    {
        Owner = periodVirtualAddress,
        Symbol = input.Symbol
    }).Balance;
    
    if (balance > 0)
    {
        Context.SendVirtualInline(
            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, input.Period),
            State.TokenContract.Value,
            nameof(State.TokenContract.Transfer),
            new TransferInput
            {
                To = scheme.VirtualAddress,
                Symbol = input.Symbol,
                Amount = balance
            }.ToByteString());
    }
    
    return new Empty();
}
```

**Alternative Fix - Round Remaining Dust to Last Claimer:**

Modify `ClaimProfits` to allocate all remaining dust to the last claimer in a period, ensuring no permanent lockup.

**Long-term Fix - Use Higher Precision:**

Consider using a precision multiplier (e.g., 1e8) throughout calculations and only converting to token amounts at final transfer, similar to how TokenConverter handles Bancor calculations: [11](#0-10) 

**Test Cases to Add:**
1. Test with non-divisible amounts (99 tokens, 3 equal beneficiaries)
2. Test dust accumulation over 100+ periods
3. Test dust recovery mechanism
4. Verify total distributed + dust = total contributed

### Proof of Concept

**Initial State:**
- Create a profit scheme with SchemeId = SCHEME_A
- Add 3 beneficiaries with shares: 3333, 3333, 3334 (out of 10000 total)
- Set period = 1

**Exploitation Steps:**

1. **Contribute profits:**
   ```
   ContributeProfits(SchemeId: SCHEME_A, Amount: 99, Symbol: "ELF")
   ```

2. **Distribute profits for period 1:**
   ```
   DistributeProfits(SchemeId: SCHEME_A, Period: 1, AmountsMap: {"ELF": 99})
   ```

3. **All beneficiaries claim:**
   ```
   // Beneficiary 1 claims
   ClaimProfits(SchemeId: SCHEME_A, Beneficiary: ADDR_1)
   // Result: 32 ELF transferred
   
   // Beneficiary 2 claims
   ClaimProfits(SchemeId: SCHEME_A, Beneficiary: ADDR_2)
   // Result: 32 ELF transferred
   
   // Beneficiary 3 claims
   ClaimProfits(SchemeId: SCHEME_A, Beneficiary: ADDR_3)
   // Result: 33 ELF transferred
   ```

4. **Check virtual address balance:**
   ```
   GetBalance(
     Owner: GetSchemeAddress(SchemeId: SCHEME_A, Period: 1),
     Symbol: "ELF"
   )
   // Result: 2 ELF remains locked (99 - 32 - 32 - 33 = 2)
   ```

5. **Move to period 2 and verify dust is unrecoverable:**
   ```
   // Contribute and distribute for period 2
   ContributeProfits(SchemeId: SCHEME_A, Amount: 100, Symbol: "ELF")
   DistributeProfits(SchemeId: SCHEME_A, Period: 2, AmountsMap: {"ELF": 100})
   
   // Period 2's virtual address is DIFFERENT from period 1
   // The 2 ELF in period 1's address is NEVER accessed again
   ```

**Expected Result:**
Total claimed over all periods = Total contributed - Permanent dust lockup

**Actual Result:**
After 100 periods with average 1.5 tokens dust per period: 150 tokens permanently locked in 100 different virtual addresses with no recovery mechanism.

**Success Condition:**
Verify `GetBalance(PeriodVirtualAddress)` shows non-zero balance that cannot be claimed by any beneficiary and cannot be recovered by any contract function.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L417-428)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        if (input.AmountsMap.Any())
            Assert(input.AmountsMap.All(a => !string.IsNullOrEmpty(a.Key)), "Invalid token symbol.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L585-604)
```csharp
    private void PerformDistributeProfits(Dictionary<string, long> profitsMap, Scheme scheme, long totalShares,
        Address profitsReceivingVirtualAddress)
    {
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
            Context.LogDebug(() => $"Distributing {remainAmount} {symbol} tokens.");
            // Transfer remain amount to individuals' receiving profits address.
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L606-631)
```csharp
    private long DistributeProfitsForSubSchemes(string symbol, long totalAmount, Scheme scheme, long totalShares)
    {
        Context.LogDebug(() => $"Sub schemes count: {scheme.SubSchemes.Count}");
        var remainAmount = totalAmount;
        foreach (var subSchemeShares in scheme.SubSchemes)
        {
            Context.LogDebug(() => $"Releasing {subSchemeShares.SchemeId}");

            // General ledger of this sub profit scheme.
            var subItemVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeShares.SchemeId);

            if (State.TokenContract.Value == null)
                State.TokenContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

            var distributeAmount = SafeCalculateProfits(subSchemeShares.Shares, totalAmount, totalShares);
            if (distributeAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = subItemVirtualAddress,
                        Amount = distributeAmount,
                        Symbol = symbol
                    }.ToByteString());

            remainAmount = remainAmount.Sub(distributeAmount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L57-59)
```csharp
    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
```

**File:** test/AElf.Contracts.Election.Tests/Full/CitizenWelfareTests.cs (L716-716)
```csharp
            actualClaimed.ShouldBeInRange(shouldClaimed - 2, shouldClaimed);
```

**File:** test/AElf.Contracts.Election.Tests/Full/CitizenWelfareTests.cs (L724-724)
```csharp
        profitsList.Sum().ShouldBeInRange(totalAmount - 6, totalAmount);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L122-127)
```csharp
        State.ProfitContract.ContributeProfits.Send(new Profit.ContributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Symbol = input.Symbol,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L251-255)
```csharp
        State.ProfitContract.ClaimProfits.Send(new Profit.ClaimProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = beneficiary
        });
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-47)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
```
