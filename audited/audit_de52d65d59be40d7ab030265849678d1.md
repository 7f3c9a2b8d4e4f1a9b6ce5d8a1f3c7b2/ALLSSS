# Audit Report

## Title
Unvalidated Boolean Parsing in CrossChainCreate Enables NFT Protocol Creation DoS

## Summary
An attacker can create a token on mainchain with malicious `NftTokenIdReuseMetadataKey` values (e.g., "1", "yes", "TRUE") by directly calling the MultiToken contract's Create method. When cross-chained to sidechains and `CrossChainCreate()` is invoked, the unprotected `bool.Parse()` call throws a `FormatException`, permanently preventing NFT protocol creation for that symbol.

## Finding Description

The vulnerability exists in the NFT contract's `CrossChainCreate()` method which retrieves token information and directly parses the boolean metadata value without validation or error handling: [1](#0-0) 

C#'s `bool.Parse()` only accepts "True"/"False" (case-insensitive) and throws `FormatException` for any other input like "1", "yes", "TRUE", etc.

The root cause is that the MultiToken contract's `Create()` method accepts arbitrary ExternalInfo values without validating their content or format: [2](#0-1) 

While the NFT contract's `Create()` method properly sets this value using `bool.ToString()` which produces valid "True"/"False" strings: [3](#0-2) 

And protects reserved metadata keys through validation: [4](#0-3) 

An attacker can bypass the NFT contract entirely by calling MultiToken.Create directly. The only requirement is possessing a seed NFT for the target symbol or being whitelisted: [5](#0-4) 

Once created, the malicious token can be legitimately cross-chained via `CrossChainCreateToken`, which validates token existence but preserves the malicious ExternalInfo values: [6](#0-5) 

The sidechain's duplicate protocol check only prevents re-creation after success, not after repeated failures: [7](#0-6) 

## Impact Explanation

**Operational Impact - DoS of NFT Protocol Creation:**
- When `CrossChainCreate()` is called on a sidechain for a poisoned token symbol, the unhandled `FormatException` causes transaction failure
- Since the protocol state remains null, the duplicate check passes on subsequent attempts
- However, the parsing error recurs on every attempt, creating permanent DoS
- This blocks legitimate NFT functionality for that symbol namespace on affected sidechains
- Multiple symbols can be poisoned if the attacker obtains multiple seed NFTs
- No fund loss occurs, but NFT protocol deployment becomes impossible for affected symbols

**Severity Justification:** Medium - Operational DoS with no direct fund impact, but permanently damages protocol functionality on sidechains for affected symbols. The attack requires obtaining seed NFTs but is otherwise straightforward to execute.

## Likelihood Explanation

**Attacker Capabilities:**
- Must obtain seed NFTs for target symbols (e.g., "XX123456" with valid NFT type prefix like "XX")
- Seed NFTs can be purchased or obtained through normal protocol mechanisms
- No special privileges or compromised roles required beyond seed NFT ownership

**Attack Complexity:**
- Low - straightforward execution path:
  1. Obtain seed NFT for desired symbol
  2. Call `MultiToken.Create()` with malicious ExternalInfo containing invalid boolean strings
  3. Call `ValidateTokenInfoExists()` on mainchain to establish cross-chain proof
  4. Call `CrossChainCreateToken()` on sidechain with merkle proof
  5. Any call to `CrossChainCreate()` â†’ permanent transaction failure

**Economic Rationality:**
- Cost: Seed NFT acquisition price + transaction fees
- Detection: Malicious ExternalInfo visible on-chain but may not be detected before cross-chaining
- Attack is economically feasible for targeted DoS scenarios

**Probability:** High - All preconditions are realistic and execution is straightforward under normal AElf contract semantics. Seed NFTs are obtainable through standard mechanisms.

## Recommendation

Add validation and error handling in the `CrossChainCreate()` method:

```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    MakeSureTokenContractAddressSet();
    InitialNFTTypeNameMap();
    Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
    {
        Symbol = input.Symbol
    });
    if (string.IsNullOrEmpty(tokenInfo.Symbol))
        throw new AssertionException($"Token info {input.Symbol} not exists.");

    var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
    
    // ADD VALIDATION: Check if the value exists and can be parsed
    if (!tokenInfo.ExternalInfo.Value.TryGetValue(NftTokenIdReuseMetadataKey, out var reuseValue))
        throw new AssertionException($"Required metadata key {NftTokenIdReuseMetadataKey} not found.");
    
    if (!bool.TryParse(reuseValue, out var isTokenIdReuse))
        throw new AssertionException($"Invalid boolean value for {NftTokenIdReuseMetadataKey}: {reuseValue}");
    
    // Continue with validated value...
}
```

Additionally, consider adding ExternalInfo format validation in `MultiToken.Create()` for known reserved NFT metadata keys to prevent malicious values at the source.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreate_WithInvalidBooleanFormat_ShouldFail()
{
    // 1. Setup: Create token on mainchain with malicious ExternalInfo
    var symbol = "XX123456";
    var maliciousExternalInfo = new ExternalInfo();
    maliciousExternalInfo.Value["aelf_nft_token_id_reuse"] = "1"; // Invalid boolean format
    
    var createInput = new CreateInput
    {
        Symbol = symbol,
        TokenName = "Test NFT",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = DefaultSender,
        IsBurnable = true,
        ExternalInfo = maliciousExternalInfo
    };
    
    // Attacker creates token via MultiToken.Create (with seed NFT)
    await TokenContractStub.Create.SendAsync(createInput);
    
    // 2. Cross-chain the token to sidechain
    await CrossChainCreateTokenOnSideChain(symbol);
    
    // 3. Attempt to create NFT protocol on sidechain
    var crossChainInput = new CrossChainCreateInput { Symbol = symbol };
    
    // This should throw FormatException due to bool.Parse("1")
    var result = await NFTContractStub.CrossChainCreate.SendWithExceptionAsync(crossChainInput);
    
    // Verify: Transaction fails with FormatException
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("FormatException");
    
    // Verify: Protocol was not created
    var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = symbol });
    protocolInfo.Symbol.ShouldBeEmpty(); // Protocol creation failed
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L79-79)
```csharp
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L88-88)
```csharp
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L199-199)
```csharp
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L492-503)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L118-123)
```csharp
    private void AssertMetadataKeysAreCorrect(IEnumerable<string> metadataKeys)
    {
        var reservedMetadataKey = GetNftMetadataReservedKeys();
        foreach (var metadataKey in metadataKeys)
            Assert(!reservedMetadataKey.Contains(metadataKey), $"Metadata key {metadataKey} is reserved.");
    }
```
