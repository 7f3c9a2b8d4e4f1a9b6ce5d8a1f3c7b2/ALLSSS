### Title
Off-by-One Error in CheckResourceToken Blocks Solvent Contracts from Execution

### Summary
The `CheckResourceToken` function uses a strict greater-than comparison (`balance > owningBalance`) instead of greater-than-or-equal (`balance >= owningBalance`), causing contracts with exactly enough balance to match their accumulated resource token debt to be permanently blocked from executing transactions. This creates an artificial denial-of-service condition for contracts that have recovered to a break-even state.

### Finding Description

The vulnerability exists in the `CheckResourceToken` method [1](#0-0) , specifically at the assertion check [2](#0-1) .

**Root Cause**: The assertion requires `balance > owningBalance` (strictly greater), rejecting the edge case where `balance == owningBalance`.

**Owning Balance Semantics**: The `OwningResourceToken` state variable tracks cumulative resource token debt. When contracts lack sufficient balance to pay resource fees during `DonateResourceToken` execution, the deficit is recorded [3](#0-2) . Critically, this debt counter **never decreases** - it only accumulates over the contract's lifetime.

**Execution Flow**:
1. `CheckResourceToken` executes as a pre-plugin transaction [4](#0-3)  for all ACS8 contracts
2. Current logic blocks execution when `balance == owningBalance`
3. `ChargeResourceToken` separately validates the current transaction's resource needs [5](#0-4)  using `>=` comparison
4. Later, `PayResourceTokens` deducts actual balances

**Why Current Protection Fails**: A contract with `balance = 100` and `owningBalance = 100` has exactly enough balance to cover its historical maximum debt - it is solvent (break-even), not in deficit. However, the strict `>` check treats this as insufficient and blocks execution, requiring at least 101 tokens (1 extra token buffer) to pass validation.

### Impact Explanation

**Operational Impact - DoS of Contract Execution**:
- Contracts that receive exactly enough resource tokens to match their accumulated `owningBalance` are denied service
- Cannot execute any methods despite being in a solvent state
- Must receive at least 1 additional token beyond the break-even point to regain operability
- Creates artificial economic barrier: contracts must maintain permanent excess balance beyond debt recovery

**Affected Parties**:
- Any ACS8 contract (resource consumption contracts) that has historically gone into resource token debt
- Contract owners attempting to restore operations by topping up to exact debt amount
- Users unable to interact with contracts stuck at break-even balance

**Severity Justification**: Medium severity because:
- Causes operational denial-of-service but doesn't result in direct fund loss
- Affects contract availability and user experience
- Easy to trigger unintentionally during normal debt recovery operations
- Workaround exists (send 1 extra token), but represents flawed economic logic

### Likelihood Explanation

**High Likelihood**:

**Reachable Entry Point**: `CheckResourceToken` automatically executes as a pre-plugin transaction before every method call on ACS8 contracts [6](#0-5) . No special permissions required.

**Feasible Preconditions**:
1. Contract accumulates resource token debt (common when contract balance is insufficient)
2. Owner or user transfers exactly `owningBalance` amount to recover
3. This is a natural scenario - users calculating exact recovery amounts

**Execution Practicality**: 
- Happens automatically during normal contract operation
- No complex setup or exploitation steps required
- Example scenario:
  - Contract has 0 balance, owes 100 READ tokens (owningBalance = 100)
  - Owner transfers 100 READ tokens to contract
  - Contract now has balance = 100, owningBalance = 100
  - Next transaction attempt fails at `CheckResourceToken` pre-plugin
  - Contract remains blocked until receiving 101+ tokens

**Detection**: Contract owners attempting exact debt recovery will immediately encounter transaction failures with error message "Contract balance of {symbol} token is not enough. Owning {owningBalance}."

### Recommendation

**Code-Level Fix**: Change the assertion operator from `>` to `>=`:

```csharp
// In CheckResourceToken method, line 609
Assert(balance >= owningBalance,  // Changed from >
    $"Contract balance of {symbol} token is not enough. Owning {owningBalance}.");
```

**Rationale**:
- `balance >= owningBalance` correctly allows contracts at break-even state to execute
- `ChargeResourceToken` separately validates current transaction's resource requirements [7](#0-6) 
- Aligns with documentation stating contracts should execute after "top up" [8](#0-7) 
- Maintains security: contracts with `balance < owningBalance` (actual deficit) still blocked

**Test Cases to Add**:
1. Test contract with `balance == owningBalance` can execute transactions
2. Test contract with `balance == owningBalance - 1` is correctly blocked
3. Test contract with `balance == owningBalance + 1` can execute transactions
4. Verify `ChargeResourceToken` still enforces sufficient balance for current transaction

**Invariant to Enforce**: `balance >= owningBalance` represents minimum solvency threshold for contract execution eligibility.

### Proof of Concept

**Initial State**:
1. Deploy ACS8 contract at address `ContractA`
2. ContractA initial balance: 0 READ tokens
3. Initial `owningBalance[ContractA][READ]`: 0

**Exploitation Steps**:

**Step 1** - Create Debt:
- User calls ContractA method that consumes 100 READ tokens of resources
- `ChargeResourceToken` checks balance (0) >= 100? Fails
- Later, `DonateResourceToken` executes:
  - Tries to deduct 100 READ from ContractA
  - Balance insufficient (0 < 100)
  - Sets `owningBalance[ContractA][READ] = 0 + 100 = 100`
  - Deducts 0 (nothing available)

**Step 2** - Exact Recovery:
- Owner transfers exactly 100 READ tokens to ContractA
- Current state: `balance = 100`, `owningBalance = 100`

**Step 3** - Transaction Blocked:
- User attempts to call ContractA method
- Pre-plugin `CheckResourceToken` executes
- Checks: `100 > 100`? **FALSE**
- Transaction fails with error: "Contract balance of READ token is not enough. Owning 100."

**Expected vs Actual Result**:
- **Expected**: Contract with balance matching debt should be allowed to execute (semantic break-even)
- **Actual**: Contract is blocked, requires 101+ tokens (artificial 1-token buffer)

**Success Condition**: With `>=` operator, Step 3 check becomes `100 >= 100` → TRUE, allowing contract execution at break-even balance while maintaining security for actual deficit scenarios (`balance < owningBalance`).

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L579-581)
```csharp
            var existingBalance = GetBalance(Context.Sender, pair.Key);
            Assert(existingBalance >= pair.Value,
                $"Insufficient resource of {pair.Key}. Need balance: {pair.Value}; Current balance: {existingBalance}.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L602-614)
```csharp
    public override Empty CheckResourceToken(Empty input)
    {
        AssertTransactionGeneratedByPlugin();
        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayTxFeeSymbolListName))
        {
            var balance = GetBalance(Context.Sender, symbol);
            var owningBalance = State.OwningResourceToken[Context.Sender][symbol];
            Assert(balance > owningBalance,
                $"Contract balance of {symbol} token is not enough. Owning {owningBalance}.");
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L969-982)
```csharp
                var existingBalance = GetBalance(bill.ContractAddress, symbol);
                if (amount > existingBalance)
                {
                    var owned = amount.Sub(existingBalance);
                    var currentOwning = State.OwningResourceToken[bill.ContractAddress][symbol].Add(owned);
                    State.OwningResourceToken[bill.ContractAddress][symbol] = currentOwning;
                    Context.Fire(new ResourceTokenOwned
                    {
                        Symbol = symbol,
                        Amount = currentOwning,
                        ContractAddress = bill.ContractAddress
                    });
                    amount = existingBalance;
                }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee/ResourceConsumptionPreExecutionPlugin.cs (L31-67)
```csharp
    public async Task<IEnumerable<Transaction>> GetPreTransactionsAsync(
        IReadOnlyList<ServiceDescriptor> descriptors, ITransactionContext transactionContext)
    {
        if (!HasApplicableAcs(descriptors)) return new List<Transaction>();

        var chainContext = new ChainContext
        {
            BlockHash = transactionContext.PreviousBlockHash,
            BlockHeight = transactionContext.BlockHeight - 1
        };

        // Generate token contract stub.
        var tokenContractAddress =
            await _smartContractAddressService.GetAddressByContractNameAsync(chainContext,
                TokenSmartContractAddressNameProvider.StringName);
        if (tokenContractAddress == null) return new List<Transaction>();

        var tokenStub = _contractReaderFactory.Create(new ContractReaderContext
        {
            ContractAddress = tokenContractAddress,
            Sender = transactionContext.Transaction.To
        });

        if (transactionContext.Transaction.To == tokenContractAddress &&
            transactionContext.Transaction.MethodName == nameof(tokenStub.ChargeResourceToken))
            return new List<Transaction>();

        if (transactionContext.Transaction.MethodName ==
            nameof(ResourceConsumptionContractContainer.ResourceConsumptionContractStub.BuyResourceToken))
            return new List<Transaction>();

        var checkResourceTokenTransaction = tokenStub.CheckResourceToken.GetTransaction(new Empty());

        return new List<Transaction>
        {
            checkResourceTokenTransaction
        };
```

**File:** docs-sphinx/reference/acs/acs8.rst (L110-114)
```text
In addition, the method of the contract that has been owed cannot be
executed before the contract top up resource token. As a result, a
pre-plugin transaction is added, similar to the ACS5 pre-plugin
transaction, which checks the contract’s resource token balance, and the
transaction’s method name is ``CheckResourceToken`` :
```
