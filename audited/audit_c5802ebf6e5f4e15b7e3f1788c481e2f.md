# Audit Report

## Title
CachedDelayTotalShares Never Updated During Beneficiary Removal - Causing Permanent Fund Dilution

## Summary
The `RemoveBeneficiary` function in the Profit contract modifies the local `scheme.CachedDelayTotalShares` dictionary to subtract removed beneficiary shares, but never persists the updated scheme object back to state. This causes all future delayed profit distributions to use inflated total shares that still include removed beneficiaries, resulting in permanent underpayment to all remaining beneficiaries.

## Finding Description
The vulnerability exists in the `RemoveBeneficiary` function where state persistence is incomplete. The function loads the scheme object, modifies its `CachedDelayTotalShares` field (lines 243-258), but only persists the `TotalShares` field directly to state (line 260). [1](#0-0) 

The critical missing statement is `State.SchemeInfos[input.SchemeId] = scheme;` after line 258. This pattern is correctly implemented in other functions:

- `AddBeneficiary` correctly saves the entire scheme object at line 184 [2](#0-1) 
- `DistributeProfits` correctly saves the entire scheme object at line 496 [3](#0-2) 

The `RemovedDetails.TryAdd` method correctly accumulates shares using safe arithmetic [4](#0-3) , but these accumulated values are used to modify `CachedDelayTotalShares` which is never persisted.

When `DistributeProfits` executes for delayed schemes, it retrieves `CachedDelayTotalShares[input.Period]` to determine the total shares for that period's distribution [5](#0-4) . Since removed beneficiary shares were never subtracted from the cached totals, the inflated value is used for profit calculations, causing all remaining beneficiaries to receive proportionally less than they should.

The Treasury contract uses delayed distribution in production, setting `DelayDistributePeriodCount = 1` for the Citizen Welfare scheme (index 3) [6](#0-5) .

## Impact Explanation
This is a **CRITICAL** severity vulnerability causing permanent fund loss:

**Direct Financial Harm**: When profits are distributed using `SafeCalculateProfits`, each beneficiary receives `(their_shares * total_amount) / total_shares`. With inflated cached totals still containing removed shares, the denominator is incorrect, causing underpayment to all remaining beneficiaries.

**Quantified Loss**: If 100 shares are removed from a scheme with 1000 total shares:
- Remaining beneficiaries lose 10% of expected profits per affected period
- For consensus rewards distributing 100,000 tokens: 10,000 tokens remain undistributed
- Affects ALL future delayed distribution periods compoundingly

**Permanence**: Profits remain locked in period virtual addresses with no recovery mechanism. Once `DistributeProfits` completes for a period and increments `CurrentPeriod`, that period's distribution is finalized and cannot be corrected.

**Affected Systems**:
- Treasury profit distributions (Citizen Welfare)
- TokenHolder dividend schemes
- Any profit scheme with `DelayDistributePeriodCount > 0`

## Likelihood Explanation
**Certainty**: 100% - This is not an active exploit but a broken feature. ANY call to `RemoveBeneficiary` on schemes with `DelayDistributePeriodCount > 0` fails to update cached totals.

**Attacker Capabilities**: Requires scheme manager or TokenHolder contract privileges [7](#0-6) . However, this is a passive bug occurring during legitimate operations.

**Feasibility**: CERTAIN during normal operations:
- Removing expired beneficiaries
- Vote withdrawals in TokenHolder schemes
- Treasury management operations
- Schemes with delayed distribution are used in production

**Detection**: DIFFICULT - No transaction failure occurs, no event indicates the bug. Beneficiaries only notice reduced profits in future periods, requiring manual comparison of expected vs. actual amounts across multiple periods.

## Recommendation
Add the missing state persistence statement in `RemoveBeneficiary` after line 258:

```csharp
foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
{
    if (scheme.DelayDistributePeriodCount > 0)
    {
        for (var removedPeriod = removedMinPeriod;
             removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
             removedPeriod++)
        {
            if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
            {
                scheme.CachedDelayTotalShares[removedPeriod] =
                    scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
            }
        }
    }
}

// ADD THIS LINE:
State.SchemeInfos[input.SchemeId] = scheme;

State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

Alternatively, replace line 260 with saving the entire scheme object, ensuring both `TotalShares` and `CachedDelayTotalShares` are persisted together.

## Proof of Concept
```csharp
[Fact]
public async Task RemoveBeneficiary_DelayDistribution_CachedSharesNotPersisted_Test()
{
    const int delayDistributePeriodCount = 2;
    const int initialBeneficiaryShares = 100;
    const int contributeAmount = 10_000;
    
    var creator = Creators[0];
    var creatorAddress = Address.FromPublicKey(CreatorKeyPair[0].PublicKey);
    var beneficiary1 = Address.FromPublicKey(CreatorKeyPair[1].PublicKey);
    var beneficiary2 = Address.FromPublicKey(CreatorKeyPair[2].PublicKey);

    // Create scheme with delay distribution
    await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true,
        ProfitReceivingDuePeriodCount = 100,
        DelayDistributePeriodCount = delayDistributePeriodCount,
        CanRemoveBeneficiaryDirectly = true
    });

    var schemeId = (await creator.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = creatorAddress })).SchemeIds.First();

    // Add two beneficiaries
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiary1, Shares = initialBeneficiaryShares },
        EndPeriod = long.MaxValue
    });
    
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiary2, Shares = initialBeneficiaryShares },
        EndPeriod = long.MaxValue
    });

    // Distribute for period 1 - this caches total shares (200) for period 3
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Symbol = "ELF",
        Amount = contributeAmount,
        Period = 1
    });
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { { "ELF", contributeAmount } }
    });

    // Remove beneficiary1 - bug: CachedDelayTotalShares not updated
    await creator.RemoveBeneficiary.SendAsync(new RemoveBeneficiaryInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiary1
    });

    // Verify scheme shows correct TotalShares (100) but CachedDelayTotalShares still has old value (200)
    var scheme = await creator.GetScheme.CallAsync(schemeId);
    scheme.TotalShares.ShouldBe(initialBeneficiaryShares); // Correct: only beneficiary2 remains
    
    // Distribute for periods 2 and 3
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput { SchemeId = schemeId, Period = 2 });
    
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Symbol = "ELF",
        Amount = contributeAmount,
        Period = 3
    });
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 3,
        AmountsMap = { { "ELF", contributeAmount } }
    });

    // Check distributed info for period 3 - BUG: uses cached value of 200 instead of 100
    var distributedInfo = await creator.GetDistributedProfitsInfo.CallAsync(
        new SchemePeriod { SchemeId = schemeId, Period = 3 });
    
    // BUG: TotalShares is 200 (cached from period 1) instead of 100 (only beneficiary2)
    distributedInfo.TotalShares.ShouldBe(200); // This assertion PASSES, proving the bug
    // Expected: 100 (only beneficiary2's shares)
    
    // Result: beneficiary2 receives only 50% of profits instead of 100%
    // The other 50% remains locked in the period virtual address forever
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-184)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-496)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);

        State.SchemeInfos[input.SchemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/Models/RemovedDetails.cs (L8-18)
```csharp
        public void TryAdd(long key, long value)
        {
            if (ContainsKey(key))
            {
                this[key] = this[key].Add(value);
            }
            else
            {
                this[key] = value;
            }
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-67)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```
