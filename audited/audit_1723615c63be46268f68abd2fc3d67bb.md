# Audit Report

## Title
Vote Weight Proportion Changes Create Unfair Profit Distribution Without Retroactive Updates

## Summary
The `SetVoteWeightProportion()` function allows governance to change vote weight calculation parameters, but existing votes retain their original weight (shares in the profit scheme) while new votes use the updated proportion. This creates unfair profit distribution where identical economic commitments receive different rewards based solely on when the vote was cast, violating fundamental fairness principles in the reward distribution system.

## Finding Description

The vulnerability exists in the interaction between vote weight calculation and profit share allocation in the Election contract.

When governance calls `SetVoteWeightProportion()`, it only updates the state variable without any retroactive recalculation mechanism: [1](#0-0) 

The core issue is that vote weights are calculated exactly once during the `Vote()` operation. The `Vote()` function calls `GetVotesWeight()` to calculate the weight based on the current proportion settings: [2](#0-1) 

The `GetVotesWeight()` method retrieves the current `VoteWeightProportion` from state and applies it in the formula: [3](#0-2) 

This calculated weight is then permanently stored as "shares" in the Profit contract: [4](#0-3) 

The Profit contract stores these shares permanently in a `ProfitDetail` structure: [5](#0-4) 

All future profit distributions use these fixed shares in the calculation formula: [6](#0-5) 

Evidence that retroactive updates were intended but never implemented exists in the proto definition, which defines a `FixTotalWeightsInput` message: [7](#0-6) 

However, no C# implementation of this method exists in the codebase. There is no mechanism to remove and re-add voter beneficiaries with recalculated weights when proportions change. The `RemoveBeneficiary` functionality is only used for candidate subsidies, not voter welfare shares.

## Impact Explanation

**Concrete Harm:**

When `VoteWeightProportion` changes, users voting with identical parameters (same token amount and lock duration) receive significantly different profit shares. The vote weight formula includes a base component calculated as: `votesAmount * AmountProportion / TimeProportion`.

Test data confirms default proportions are `TimeProportion=2, AmountProportion=1`: [8](#0-7) 

Example calculation with 100,000 tokens locked for 365 days:
- **Before change** (TimeProportion=2, AmountProportion=1): base weight component = 100,000 × 1/2 = 50,000 shares
- **After change** (TimeProportion=1, AmountProportion=1): base weight component = 100,000 × 1/1 = 100,000 shares

This 50,000 share difference (plus compound interest which is identical) means User B receives approximately 2× the profit share compared to User A for identical economic commitment.

**Who is Affected:**
- All voters who vote after a proportion change relative to earlier voters
- Impact accumulates across all profit distributions over the vote's lifetime (potentially 1-3 years)
- Voters with longer lock periods suffer greater total profit loss

**Severity: MEDIUM** - While this doesn't enable direct fund theft or unauthorized access, it creates systematic reward misallocation that violates protocol fairness guarantees and can be intentionally exploited through timing manipulation.

## Likelihood Explanation

**Attacker Capabilities:**

The governance system (VoteWeightInterestController, which defaults to Parliament contract) can propose and execute `SetVoteWeightProportion()` changes. This requires standard governance authorization: [9](#0-8) 

**Attack Complexity: LOW**

The execution requires only a standard Parliament proposal. The attack path is:
1. Observe that favorable parties are about to vote (or coordinate timing)
2. Submit Parliament proposal to change VoteWeightProportion
3. Execute proposal before target votes are cast
4. Target parties vote and receive more favorable shares
5. Optionally change proportions back afterward

**Feasibility: MEDIUM to HIGH**

While governance changes are public on-chain, by the time the community reacts, votes have already been cast with the manipulated proportions and those shares are permanently fixed. The lack of any retroactive correction mechanism (despite the `FixTotalWeightsInput` proto definition suggesting it was intended) makes the impact irreversible.

**Probability: MEDIUM** - Requires governance coordination and timing, but the incentive exists when governance members or allies are significant voters.

## Recommendation

Implement the `FixTotalWeights` method that was defined in the proto but never implemented. This method should:

1. Accept a list of vote IDs to update
2. For each vote ID:
   - Retrieve the original vote amount and lock time
   - Recalculate the weight using the current `VoteWeightProportion`
   - Remove the old beneficiary entry from the Profit contract
   - Add a new beneficiary entry with the recalculated weight
3. Protect this method with appropriate authorization (VoteWeightInterestController)

Additionally, consider automatically calling this fix mechanism whenever `SetVoteWeightProportion()` is called, or at minimum, require governance to explicitly fix existing votes before the new proportion takes effect.

## Proof of Concept

The vulnerability can be demonstrated through the following test scenario:

1. User A votes with 100,000 tokens for 365 days under default proportions (T=2, A=1)
2. Governance changes proportions to (T=1, A=1) via Parliament proposal
3. User B votes with 100,000 tokens for 365 days under new proportions
4. Both users have identical economic commitments but receive different profit shares
5. User B receives approximately 2× the base weight component compared to User A

The test would verify:
- Default proportion is T=2, A=1 (confirmed in existing tests)
- SetVoteWeightProportion successfully changes the proportion
- First vote calculates weight with old proportion
- Second vote calculates weight with new proportion
- Both weights are permanently stored as different share amounts
- Profit distribution reflects this unfair difference

This demonstrates that the system lacks retroactive updates despite the `FixTotalWeightsInput` proto definition indicating such functionality was intended.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L210-216)
```csharp
    public override Empty SetVoteWeightProportion(VoteWeightProportion input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.TimeProportion > 0 && input.AmountProportion > 0, "invalid input");
        State.VoteWeightProportion.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L443-443)
```csharp
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** protobuf/election_contract.proto (L530-533)
```text
message FixTotalWeightsInput {
    repeated aelf.Hash vote_ids = 1;
    
}
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ElectionTests.cs (L1479-1482)
```csharp
        var defaultSetting = await ElectionContractStub.GetVoteWeightProportion.CallAsync(
            new Empty());
        defaultSetting.TimeProportion.ShouldBe(2);
        defaultSetting.AmountProportion.ShouldBe(1);
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ElectionTests.cs (L1488-1489)
```csharp
        await ExecuteProposalForParliamentTransaction(ElectionContractAddress,
            nameof(ElectionContractStub.SetVoteWeightProportion), defaultSetting);
```
