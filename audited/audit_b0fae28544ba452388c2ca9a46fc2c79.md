### Title
Zero Virtual Balance in AddPairConnector Causes Permanent Connector Failure

### Summary
The `AddPairConnector()` function does not validate that `NativeVirtualBalance` is greater than zero, allowing creation of deposit connectors with zero virtual balance. When combined with tokens having low circulation, `EnableConnector()` can succeed with zero deposit, resulting in a connector with both zero virtual and deposit balances. This causes all subsequent `Buy()` and `Sell()` operations to fail permanently, as `UpdateConnector()` cannot fix enabled connectors.

### Finding Description

The `AddPairConnector()` function creates a native deposit connector but lacks validation on the `NativeVirtualBalance` parameter: [1](#0-0) 

The function sets `VirtualBalance = input.NativeVirtualBalance` without checking if it's positive, only validating the weight parameter through `AssertValidConnectorWeight()`.

When `EnableConnector()` is called, it calculates the required deposit via `GetNeededDeposit()`: [2](#0-1) 

If `amountOutOfTokenConvert <= 0` (all tokens are in the contract or being converted), the BancorHelper calculation is skipped and `needDeposit` remains zero. This allows `EnableConnector()` to succeed with zero deposit: [3](#0-2) 

The resulting connector state has both `VirtualBalance = 0` and `DepositBalance[connector.Symbol] = 0`. When `Buy()` or `Sell()` operations call `GetSelfBalance()`: [4](#0-3) 

This returns `0 + 0 = 0`, which triggers a validation failure in BancorHelper: [5](#0-4) [6](#0-5) 

Once enabled, the connector cannot be fixed via `UpdateConnector()` because it explicitly prevents updating activated connectors: [7](#0-6) 

### Impact Explanation

This vulnerability causes **permanent denial of service** for the affected connector pair:

1. **Operational Failure**: All `Buy()` and `Sell()` operations for the connector permanently fail with "Connector balance needs to be a positive number"
2. **No Recovery Path**: The connector cannot be disabled or updated after activation, requiring a contract upgrade to fix
3. **Liquidity Impact**: Trading functionality for the token pair is completely broken, preventing users from converting between the resource token and base token
4. **Protocol Integrity**: The connector becomes dead code that cannot fulfill its intended Bancor pricing mechanism

The severity is **CRITICAL** because:
- The failure is permanent and irreversible without contract upgrade
- It affects core protocol functionality (token conversion)
- It can occur through admin configuration error, not just malicious intent
- No emergency recovery mechanism exists

### Likelihood Explanation

The vulnerability has **HIGH likelihood** of occurrence:

1. **Reachable Entry Point**: `AddPairConnector()` is accessible to the connector controller (governance/admin)

2. **Feasible Preconditions**:
   - Admin mistakenly sets `NativeVirtualBalance = 0` (configuration error)
   - Token has low or zero circulation outside the converter contract
   - `EnableConnector()` is called with appropriate `AmountToTokenConvert`

3. **Execution Practicality**:
   - No validation warnings during connector creation
   - Test suite does not cover zero virtual balance case (default test value is 100 million) [8](#0-7) 

4. **Detection Difficulty**: The issue only manifests after enabling, not during creation, making it hard to catch during configuration

5. **Economic Rationality**: This is a realistic configuration error scenario, not requiring malicious intent

### Recommendation

**Immediate Fix**: Add validation in `AddPairConnector()` to ensure `NativeVirtualBalance` is positive:

```csharp
public override Empty AddPairConnector(PairConnectorParam input)
{
    AssertPerformedByConnectorController();
    Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
        "resource token symbol should not be empty");
    Assert(input.NativeVirtualBalance > 0,
        "Native virtual balance must be greater than zero");
    // ... rest of function
}
```

**Additional Safeguards**:

1. Add validation in `EnableConnector()` to ensure total balance (virtual + deposit) will be positive:
```csharp
var totalBalance = toConnector.VirtualBalance + needDeposit.NeedAmount;
Assert(totalBalance > 0, "Total connector balance must be greater than zero");
```

2. Add a recovery method to reset broken connectors (emergency measure):
```csharp
public override Empty ResetConnector(TokenSymbol input)
{
    AssertPerformedByConnectorController();
    var connector = State.Connectors[input.Symbol];
    Assert(connector != null, "Connector not found");
    connector.IsPurchaseEnabled = false;
    // Allow UpdateConnector to fix it
}
```

3. Add test cases covering zero virtual balance scenarios to prevent regression

### Proof of Concept

**Initial State**:
- TokenConverter contract deployed and initialized
- Connector controller has governance authority

**Exploitation Steps**:

1. Admin calls `AddPairConnector()` with:
   ```
   ResourceConnectorSymbol: "TEST"
   ResourceWeight: "0.5"
   NativeVirtualBalance: 0  // Zero virtual balance
   NativeWeight: "0.5"
   ```
   Result: Connector created with `VirtualBalance = 0`

2. Create TEST token with 1,000,000 total supply

3. Transfer all 1,000,000 TEST tokens to TokenConverter contract

4. Call `EnableConnector()` with:
   ```
   TokenSymbol: "TEST"
   AmountToTokenConvert: 0
   ```
   Result: 
   - `amountOutOfTokenConvert = 1000000 - 1000000 - 0 = 0`
   - `needDeposit = 0` (BancorHelper call skipped)
   - `DepositBalance[(NT)TEST] = 0`
   - Both connectors enabled successfully

5. User attempts `Buy()`:
   ```
   Symbol: "TEST"
   Amount: 100
   PayLimit: 1000
   ```
   Result: Transaction fails with "Connector balance needs to be a positive number"

6. Attempt `UpdateConnector()` to fix:
   Result: Transaction fails with "connector can not be updated because it has been activated"

**Expected vs Actual**:
- Expected: `AddPairConnector()` should reject zero virtual balance OR `EnableConnector()` should ensure non-zero total balance
- Actual: Connector becomes permanently broken with no recovery path

**Success Condition**: The connector pair is permanently unusable, all trading operations fail, and no administrative function can repair it without contract upgrade.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L64-64)
```csharp
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L96-106)
```csharp
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L276-299)
```csharp
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-84)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L37-38)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L70-71)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L493-502)
```csharp
    private PairConnectorParam GetLegalPairConnectorParam(string tokenSymbol, long nativeBalance = 1_0000_0000,
        string resourceWeight = "0.05", string nativeWeight = "0.05")
    {
        return new PairConnectorParam
        {
            ResourceConnectorSymbol = tokenSymbol,
            ResourceWeight = resourceWeight,
            NativeWeight = nativeWeight,
            NativeVirtualBalance = nativeBalance
        };
```
