# Audit Report

## Title
Reentrancy Vulnerability in DistributeProfits Causes Lost Updates to Scheme State

## Summary
The `DistributeProfits` function suffers from a classic lost update vulnerability due to reentrancy. When distributing profits, the function reads the scheme into a local variable, makes external token transfers that can trigger callbacks, and then saves the local copy back to state. A malicious token with a transfer callback can reenter via `ClaimProfits`, modify `TotalShares` and `CachedDelayTotalShares`, and save these changes. However, when `DistributeProfits` resumes and saves its stale local copy, it overwrites these modifications, permanently corrupting the scheme's accounting state.

## Finding Description

The vulnerability exists in the profit distribution flow where the pattern violates the checks-effects-interactions principle.

In `DistributeProfits`, the scheme is read from state into a local variable at the beginning of the function. [1](#0-0) 

The function performs various operations on this local copy, including modifications to `CachedDelayTotalShares`. [2](#0-1) 

Then it calls `PerformDistributeProfits` which executes external token transfers using `Context.SendVirtualInline`. [3](#0-2) [4](#0-3) 

The MultiToken contract's `Transfer` method invokes `DealWithExternalInfoDuringTransfer` which checks if the token has `TransferCallbackExternalInfoKey` set in its `ExternalInfo` and executes the callback synchronously using `Context.SendInline`. [5](#0-4) [6](#0-5) 

During this callback, an attacker can invoke `ClaimProfits`, which reads a **fresh** copy of the scheme from state, removes expired profit details, subtracts their shares from `TotalShares` and `CachedDelayTotalShares`, and saves the modified scheme. [7](#0-6) [8](#0-7) [9](#0-8) 

After the callback returns and execution resumes in `DistributeProfits`, the function modifies the current period and saves its **stale** local scheme copy back to state, completely overwriting the changes made by `ClaimProfits`. [10](#0-9) 

The Profit contract has no reentrancy guards whatsoever, making this attack straightforward to execute.

## Impact Explanation

**Permanent Accounting Corruption:**

When `ClaimProfits` removes expired profit details during the reentrant call, it correctly decrements `TotalShares` by the removed shares. However, when `DistributeProfits` overwrites the scheme with its stale copy, this decrement is lost, leaving `TotalShares` artificially inflated.

**Consequences:**

1. **Diluted Future Distributions**: All subsequent profit distributions use the inflated `TotalShares` value in the calculation formula. [11](#0-10)  With a larger denominator, each beneficiary receives proportionally less than their entitled share.

2. **Permanent Value Leakage**: The phantom shares that should have been removed remain counted in `TotalShares` but have no actual beneficiary. In every distribution, the proportional amount allocated to these phantom shares accumulates as unclaimed tokens in the contract, representing lost value that can never be recovered.

3. **Delayed Distribution Corruption**: For schemes with `DelayDistributePeriodCount > 0`, the `CachedDelayTotalShares` map is also corrupted, causing compounding errors in delayed distribution calculations across multiple periods.

**Severity: Medium** - The vulnerability causes permanent corruption of critical accounting state, affecting all future distributions. While it doesn't enable immediate large-scale theft, it creates measurable, ongoing value leakage that compounds over time and cannot be corrected without contract upgrade.

## Likelihood Explanation

**Attack Prerequisites:**

1. **Token Creation**: An attacker needs to create a malicious token with `TransferCallbackExternalInfoKey` set in its `ExternalInfo` to point to their attack contract. Token creation in AElf accepts arbitrary `ExternalInfo` settings without validation. [12](#0-11)  The attacker needs either a SEED NFT or to be in the create whitelist, which is achievable.

2. **Contribute Token**: The attacker contributes this malicious token to a target profit scheme via `ContributeProfits`, which is a public function with no access controls. [13](#0-12) 

3. **Trigger Distribution**: If the scheme has `IsReleaseAllBalanceEveryTimeByDefault = true`, the malicious token will be automatically included in distribution. [14](#0-13) 

4. **Execute Attack**: When the scheme manager calls `DistributeProfits`, the callback triggers, the attacker calls `ClaimProfits` from the callback, and the lost update occurs automatically.

**Feasibility: High** - All preconditions are achievable by an unprivileged attacker. The attack requires no special permissions beyond normal token creation. The callback mechanism is a documented feature, and `ContributeProfits` intentionally accepts tokens from any source. The attack succeeds silently without reverting, making it difficult to detect.

**Likelihood: Medium-High** - Given the achievable preconditions, lack of defenses, and economic incentive to attack high-value profit schemes, this vulnerability is likely to be exploited.

## Recommendation

Implement one or more of the following mitigations:

1. **Add Reentrancy Guard**: Implement a reentrancy lock that prevents reentrant calls to state-modifying functions:

```csharp
// In ProfitContractState.cs
public BoolState ReentrancyLock { get; set; }

// In ProfitContract.cs at start of DistributeProfits
Assert(!State.ReentrancyLock.Value, "Reentrant call detected.");
State.ReentrancyLock.Value = true;

// At end of DistributeProfits before return
State.ReentrancyLock.Value = false;
```

2. **Follow Checks-Effects-Interactions Pattern**: Move all state writes before external calls. Reload the scheme from state after external calls and carefully merge only the intended changes.

3. **Whitelist Acceptable Tokens**: Add a token whitelist mechanism to `ContributeProfits` that only accepts tokens without callback functionality or from trusted sources.

4. **Validate ExternalInfo on Token Creation**: Add validation in the MultiToken contract to restrict or validate the `TransferCallbackExternalInfoKey` to prevent arbitrary callback contracts.

The most robust solution is option 1 (reentrancy guard) combined with option 2 (proper state management), as these address the root cause and protect against other potential reentrancy vectors.

## Proof of Concept

```csharp
// Test demonstrating the reentrancy attack
[Fact]
public async Task ReentrancyAttack_LostUpdate_Test()
{
    // Setup: Create a profit scheme
    var schemeId = await CreateSchemeAsync();
    
    // Attacker creates malicious token with transfer callback
    var maliciousToken = "EVIL";
    await CreateMaliciousTokenWithCallback(maliciousToken, attackCallbackContract);
    
    // Add legitimate beneficiary with shares
    await ProfitContractStub.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare 
        { 
            Beneficiary = beneficiaryAddress, 
            Shares = 1000 
        }
    });
    
    // Get initial TotalShares
    var schemeBefore = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    var initialTotalShares = schemeBefore.TotalShares; // 1000
    
    // Attacker contributes malicious token to scheme
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = ProfitContractAddress,
        Symbol = maliciousToken,
        Amount = 1000
    });
    await ProfitContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Symbol = maliciousToken,
        Amount = 1000
    });
    
    // Trigger distribution - this will call the malicious callback
    // The callback will call ClaimProfits which removes expired shares
    // Expected: TotalShares should decrease
    // Actual: TotalShares remains unchanged due to lost update
    await ProfitContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { { maliciousToken, 1000 } }
    });
    
    // Verify the bug: TotalShares should have decreased but didn't
    var schemeAfter = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    
    // Bug: TotalShares should be less than initialTotalShares
    // but due to lost update, it remains the same
    Assert.Equal(initialTotalShares, schemeAfter.TotalShares); // BUG CONFIRMED
}
```

**Notes:**
- The attack exploits the synchronous nature of `Context.SendVirtualInline` and `Context.SendInline` in the AElf runtime, which allows reentrant calls
- The lost update pattern (read → external call → write) is a well-known anti-pattern in smart contract security
- The vulnerability affects any profit scheme that accepts token contributions from untrusted sources
- The impact compounds over time as more distributions occur with corrupted `TotalShares` values

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L422-422)
```csharp
        var scheme = State.SchemeInfos[input.SchemeId];
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L449-459)
```csharp
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L466-466)
```csharp
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L492-492)
```csharp
        PerformDistributeProfits(profitsMap, scheme, totalShares, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-496)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);

        State.SchemeInfos[input.SchemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L596-602)
```csharp
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-651)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L752-752)
```csharp
        var scheme = State.SchemeInfos[input.SchemeId];
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L792-797)
```csharp
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L799-799)
```csharp
        State.SchemeInfos[scheme.SchemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L184-191)
```csharp
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L341-346)
```csharp
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
```
