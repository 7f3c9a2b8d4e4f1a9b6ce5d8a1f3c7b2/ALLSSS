### Title
Governance Bypass via Malicious Contract in Method Fee Controller Validation

### Summary
The `CheckOrganizationExist` method in `ChangeMethodFeeController` does not validate that the provided `ContractAddress` is a legitimate governance contract (Parliament, Association, or Referendum). An attacker with governance access can deploy a malicious contract that returns `true` for `ValidateOrganizationExist` calls, allowing them to set an arbitrary authority they control. This enables permanent bypass of governance requirements for all future method fee changes across system contracts.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist` helper method used by `ChangeMethodFeeController`: [1](#0-0) 

This method makes a cross-contract call to `authorityInfo.ContractAddress` without validating that it is a legitimate governance contract. The only validation performed is: [2](#0-1) 

The legitimate organization contracts (Parliament, Association, Referendum) implement `ValidateOrganizationExist` by checking if an organization exists in their state: [3](#0-2) 

However, an attacker can deploy a malicious contract with a `ValidateOrganizationExist` method that always returns `true`, bypassing this validation entirely.

The exploitation path:
1. Attacker with governance access creates a proposal to call `ChangeMethodFeeController`
2. Proposal parameters include `AuthorityInfo` with `ContractAddress` pointing to malicious contract
3. When proposal is released by governance, the authorization check passes (sender is the organization virtual address)
4. `CheckOrganizationExist` calls the malicious contract, which returns `true`
5. Method fee controller is changed to attacker-controlled authority
6. Attacker can now call `SetMethodFee` directly without governance approval: [4](#0-3) 

The check only verifies sender matches the `OwnerAddress`, which the attacker controls after the malicious controller is set.

### Impact Explanation

**Auth/Governance Impact**: Complete and permanent bypass of governance for method fee changes across all system contracts implementing ACS1 standard.

**Affected Contracts**: Genesis, Parliament, Association, Referendum, MultiToken, TokenConverter, Economic, Treasury, Profit, TokenHolder, Vote, Election, Consensus (AEDPoS), Configuration, and CrossChain contracts all use the same vulnerable pattern: [5](#0-4) [6](#0-5) 

**Concrete Damage**:
- Attacker can set transaction fees to zero, eliminating validator revenue
- Attacker can set fees to extremely high values, causing DoS on critical system operations
- Loss of democratic control over protocol economics
- Cannot be reverted without another governance action that the attacker could block by setting prohibitive fees on proposal methods

### Likelihood Explanation

**Attacker Capabilities**: Requires ability to get a proposal approved in the current governance organization (typically Parliament with miner voting).

**Attack Complexity**: Low once governance access is achieved:
1. Deploy malicious contract with `ValidateOrganizationExist` method returning `true`
2. Create proposal with malicious contract address
3. If proposal passes (requires compromised governance or social engineering), vulnerability is triggered

**Feasibility**: While requiring governance access increases the bar, this represents a single point of failure:
- Governance participants may not carefully inspect contract addresses in proposals
- A single malicious/compromised governance participant can permanently damage the system
- No technical safeguards exist to prevent this attack

**Detection Constraints**: Test cases only validate that organization addresses exist within legitimate contracts, not that contract addresses themselves are legitimate: [7](#0-6) 

The existing test uses `ParliamentContractAddress` as both `OwnerAddress` and `ContractAddress`, testing only that the address isn't a valid organization, not that the contract type is invalid.

### Recommendation

Add validation that `authorityInfo.ContractAddress` is a system contract before calling `ValidateOrganizationExist`. The system already provides this capability: [8](#0-7) 

**Mitigation Code**:
```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract is a system contract
    Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(authorityInfo.ContractAddress),
        "Invalid authority contract - must be a system contract.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Test Case**: Add test attempting to use non-system contract address, expecting "Invalid authority contract" error.

### Proof of Concept

**Initial State**: Parliament default organization controls method fee settings.

**Attack Steps**:
1. Deploy malicious contract:
   ```csharp
   public BoolValue ValidateOrganizationExist(Address input) 
   {
       return new BoolValue { Value = true };
   }
   ```

2. Create Parliament proposal with:
   - Target: Genesis contract `ChangeMethodFeeController` method
   - Parameters: `AuthorityInfo { OwnerAddress = attackerAddress, ContractAddress = maliciousContractAddress }`

3. Get proposal approved by miners

4. Release proposal - validation passes despite malicious contract

5. Call `SetMethodFee` directly as attacker:
   - Sender check passes (attacker is now `MethodFeeController.Value.OwnerAddress`)
   - No governance required

**Expected**: Proposal release should fail with "Invalid authority contract"

**Actual**: Proposal succeeds, attacker gains unilateral control over method fees

**Success Condition**: `GetMethodFeeController()` returns `AuthorityInfo` with attacker-controlled addresses, enabling direct fee manipulation without governance approval.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L9-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L39-48)
```csharp
    public override Address CreateOrganizationBySystemContract(CreateOrganizationBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Unauthorized to create organization.");
        var organizationAddress = CreateNewOrganization(input.OrganizationCreationInput);
        if (!string.IsNullOrEmpty(input.OrganizationAddressFeedbackMethod))
            Context.SendInline(Context.Sender, input.OrganizationAddressFeedbackMethod, organizationAddress);

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L1010-1034)
```csharp
    [Fact]
    public async Task ChangeMethodFeeController_With_Invalid_Authority_Test()
    {
        // await InitializeParliamentContracts();
        var parliamentContractStub = GetParliamentContractTester(InitialMinersKeyPairs[0]);


        var methodFeeController = await parliamentContractStub.GetMethodFeeController.CallAsync(new Empty());
        var defaultOrganization = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
        methodFeeController.OwnerAddress.ShouldBe(defaultOrganization);

        const string proposalCreationMethodName = nameof(parliamentContractStub.ChangeMethodFeeController);
        var proposalId = await CreateFeeProposalAsync(ParliamentContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName, new AuthorityInfo
            {
                OwnerAddress = ParliamentContractAddress,
                ContractAddress = ParliamentContractAddress
            });
        await ApproveAsync(InitialMinersKeyPairs[0], proposalId);
        await ApproveAsync(InitialMinersKeyPairs[1], proposalId);
        await ApproveAsync(InitialMinersKeyPairs[2], proposalId);

        var releaseResult = await parliamentContractStub.Release.SendWithExceptionAsync(proposalId);
        releaseResult.TransactionResult.Error.ShouldContain("Invalid authority input");
    }
```
