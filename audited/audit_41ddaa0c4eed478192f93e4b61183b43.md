### Title
Consensus Term Change Can Be Indefinitely Delayed Through Miner Availability Manipulation

### Summary
The AEDPoS consensus mechanism determines term changes based solely on a 2/3+1 consensus threshold of miners' ActualMiningTimes, without any fallback validation against absolute elapsed time. This allows attackers controlling 1/3+ of miners, or scenarios where 1/3+ miners are offline, to indefinitely delay term changes beyond the intended period, blocking treasury releases and governance operations.

### Finding Description

The vulnerability exists in the term change decision logic. When a round terminates, the `TerminateRoundCommandStrategy` sets the Behaviour to either NextTerm or NextRound based on the `_isNewTerm` parameter. [1](#0-0) 

This `_isNewTerm` flag is determined by checking if the behaviour equals NextTerm: [2](#0-1) 

The behaviour itself comes from `MainChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()`, which checks `NeedToChangeTerm()`: [3](#0-2) 

The critical flaw is in `NeedToChangeTerm()`, which requires at least `MinersCountOfConsent` (2/3+1) of miners to have their last ActualMiningTime indicating a term change: [4](#0-3) 

The MinersCountOfConsent threshold is calculated as: [5](#0-4) 

The check only filters out miners who have never mined (`ActualMiningTimes.Any()`), but includes miners with stale ActualMiningTimes. Miners who previously mined but are now offline remain in `RealTimeMinersInformation` and are counted with their old timestamps: [6](#0-5) 

Critically, the validation logic (`RoundTerminateValidationProvider`) does NOT verify that NextRound behaviour is appropriate based on elapsed time - it only validates that round/term numbers increment correctly: [7](#0-6) 

Evil miner detection only triggers after 3 days (4320 missed slots), allowing extended delays: [8](#0-7) 

### Impact Explanation

This vulnerability enables indefinite extension of terms beyond their intended duration, causing:

1. **Treasury Release Delays**: Term changes trigger treasury profit releases. Delayed term changes block fund distributions to the ecosystem: [9](#0-8) 

2. **Election Snapshot Delays**: Election snapshots are taken at term changes, delaying governance updates: [10](#0-9) 

3. **Miner List Update Delays**: Malicious miners can extend their tenure beyond the intended period: [11](#0-10) 

**Severity Justification**: This breaks the fundamental consensus invariant of correct round/term transitions, enabling governance manipulation and economic disruption.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control or coordinate 1/3+ of the miner set (approximately 6 out of 17 miners for the supposed miner count)
- Alternatively, exploit natural network partitions where 1/3+ miners are offline

**Attack Complexity:**
1. Attacker-controlled miners or offline miners avoid producing blocks after the term period elapses
2. Without 2/3+1 miners having recent ActualMiningTimes, `NeedToChangeTerm()` returns false
3. Rounds continue with NextRound behaviour instead of NextTerm
4. Term change is blocked until either: (a) sufficient miners come online and mine, or (b) 3 days pass and evil miner detection removes them

**Feasibility:**
- Entry point is the standard consensus flow via `GetConsensusCommand()`
- No special privileges required - any miner can trigger this by the natural consensus process
- Attack can persist for up to 3 days before evil miner detection
- In scenarios with genuine network issues (not malicious), the vulnerability triggers naturally

**Detection/Operational Constraints:**
- The attack is difficult to distinguish from legitimate network issues
- No on-chain monitoring exists to detect term delays versus expected periods
- Community would only notice when treasury releases or governance actions are delayed

### Recommendation

Implement absolute time-based enforcement for term changes:

1. **Add Validation in RoundTerminateValidationProvider**: Extend `ValidationForNextRound()` to check if the absolute time indicates a term change should occur. If `(currentBlockTime - blockchainStartTimestamp) / periodSeconds` indicates a new term period has started, reject NextRound behaviour and require NextTerm:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    // Existing round number and InValue checks...
    
    // NEW: Verify NextRound is not being used when term should change
    var blockchainStartTimestamp = GetBlockchainStartTimestamp();
    var periodSeconds = GetPeriodSeconds();
    var currentTermNumber = validationContext.CurrentTermNumber;
    
    var calculatedTermPeriod = (validationContext.CurrentBlockTime - blockchainStartTimestamp).Seconds
        .Div(periodSeconds);
    
    if (calculatedTermPeriod != currentTermNumber - 1)
    {
        return new ValidationResult 
        { 
            Message = "Term change required based on elapsed time. NextRound not allowed." 
        };
    }
    
    return new ValidationResult { Success = true };
}
```

2. **Alternative: Add Grace Period Check**: Modify `GetConsensusBehaviourToTerminateCurrentRound()` to force NextTerm if absolute time exceeds term period by a grace threshold, regardless of consensus:

```csharp
protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
{
    // Check absolute time first with grace period
    var elapsedTermPeriods = (Context.CurrentBlockTime - _blockchainStartTimestamp).Seconds
        .Div(_periodSeconds);
    var gracePeriodSeconds = _periodSeconds.Div(10); // 10% grace
    
    if ((Context.CurrentBlockTime - _blockchainStartTimestamp).Seconds > 
        CurrentRound.TermNumber.Mul(_periodSeconds).Add(gracePeriodSeconds))
    {
        return AElfConsensusBehaviour.NextTerm; // Force term change after grace period
    }
    
    // Then check consensus-based logic
    return CurrentRound.RoundNumber == 1 || 
           !CurrentRound.NeedToChangeTerm(...) ||
           CurrentRound.RealTimeMinersInformation.Keys.Count == 1
        ? AElfConsensusBehaviour.NextRound
        : AElfConsensusBehaviour.NextTerm;
}
```

3. **Test Cases**:
   - Test term change when exactly 1/3 of miners are offline with stale ActualMiningTimes
   - Test absolute time enforcement after grace period expires
   - Test that validation rejects NextRound when absolute time requires NextTerm

### Proof of Concept

**Initial State:**
- 10 miners in the consensus set (MinersCountOfConsent = 7)
- Term period = 7 days (604800 seconds)
- Current term = 1, started at day 0
- All miners have been producing blocks normally days 0-6

**Attack Sequence:**

1. **Day 6**: All 10 miners have ActualMiningTimes from day 0-6 (before term period)

2. **Day 7**: Term period elapses, term should change to term 2

3. **Day 7-10**: 4 miners go offline or are controlled by attacker and stop producing blocks
   - These 4 miners retain ActualMiningTimes from day 6 or earlier
   - 6 active miners produce blocks with ActualMiningTimes from day 7+

4. **Round Termination at Day 8**:
   - Extra block producer calls `GetConsensusCommand()`
   - `NeedToChangeTerm()` checks all 10 miners' ActualMiningTimes
   - Only 6 miners have ActualMiningTimes indicating term 2
   - Requires 7 miners, only has 6
   - Returns false

5. **Result**:
   - Behaviour set to NextRound instead of NextTerm
   - Validation passes (no absolute time check)
   - New round starts in term 1 instead of term 2
   - Treasury release for term 1 is not triggered
   - Term remains at 1 indefinitely until either:
     - More miners come online and mine (may never happen)
     - 3 days pass and evil miners are detected/replaced

**Expected vs Actual:**
- **Expected**: After day 7, term changes to 2, treasury released, election snapshot taken
- **Actual**: Term remains at 1, operations blocked, no validation error raised

**Success Condition**: Attacker successfully extends term 1 beyond day 7, delaying all term-dependent operations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-39)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L39-44)
```csharp
            case AElfConsensusBehaviour.NextRound:
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L39-56)
```csharp
        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L186-190)
```csharp

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```
