### Title
ImpliedIrreversibleBlockHeight Manipulation Enabling LIB Inflation Attack

### Summary
The AEDPoS consensus contract lacks validation to ensure `ImpliedIrreversibleBlockHeight` equals the actual block height during UpdateValue execution. A malicious miner can craft an UpdateValue transaction with an artificially inflated value, bypassing the intended flow that sets it to `Context.CurrentHeight`, thereby manipulating the Last Irreversible Block (LIB) calculation and potentially enabling premature finality or double-spend attacks.

### Finding Description

**Root Cause:**
At line 29 of `Round_Simplify.cs`, `ImpliedIrreversibleBlockHeight` is copied without validation: [1](#0-0) 

During execution, at line 248 of `ProcessUpdateValue`, the value is directly copied from the input without verifying it matches `Context.CurrentHeight`: [2](#0-1) 

**Why Protections Fail:**

1. The `UpdateValue` method is publicly accessible: [3](#0-2) 

2. The only validation in `LibInformationValidationProvider` checks monotonicity (non-decreasing), not equality with current height: [4](#0-3) 

3. While the intended flow sets the value correctly to `Context.CurrentHeight`: [5](#0-4) 

A malicious miner can craft their own `UpdateValueInput` message with arbitrary values, as the protobuf definition places no constraints: [6](#0-5) 

**Execution Path:**
1. Malicious miner creates custom `UpdateValueInput` with `ImpliedIrreversibleBlockHeight` set to an inflated value (e.g., currentHeight + 1000)
2. Passes `PreCheck()` because miner is in the authorized miner list
3. Passes `LibInformationValidationProvider` because value doesn't decrease
4. `ProcessUpdateValue` executes and stores the malicious value
5. This value is used in LIB calculation at position `(count-1)/3` of sorted heights: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Violation:**
The LIB calculation relies on collecting `ImpliedIrreversibleBlockHeight` values from miners who produced blocks in the current round. By injecting artificially high values, a malicious miner can:

1. **Inflate LIB Height**: Push the calculated LIB higher than the true 2/3 consensus threshold, marking blocks as irreversible prematurely
2. **Break Finality Guarantees**: Blocks declared irreversible before achieving true consensus cannot be reverted
3. **Enable Double-Spend Attacks**: If a malicious miner inflates LIB past a block containing their transaction, that transaction becomes irreversible even if other miners disagree
4. **Prevent Legitimate Finality**: Setting artificially low values could prevent LIB advancement, blocking finality indefinitely

**Severity Justification:**
This is **CRITICAL** because it directly compromises the blockchain's finality mechanism, which is fundamental to consensus security. Even a single malicious miner can influence the LIB calculation if they've produced blocks in the current round.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a block producer (elected miner)
- Must control block content and transaction inclusion
- Does not require compromising other miners or system components

**Attack Complexity:**
- **Low**: Simple protobuf message construction with arbitrary `ImpliedIrreversibleBlockHeight` value
- **No economic cost beyond normal mining**: Attacker uses their legitimate mining slot
- **Difficult to detect**: Value appears plausible if set slightly ahead (e.g., currentHeight + 10)

**Feasibility Conditions:**
- Attacker has mining privileges (prerequisite for any consensus manipulation)
- Transaction passes only monotonicity check, not equality check
- No cryptographic or multi-party approval required

**Execution Practicality:**
Confirmed executable under AElf contract semantics:
- `UpdateValue` is public and only checks miner list membership
- No signature verification on consensus values
- No cross-validation with `Context.CurrentHeight` during execution

**Probability Assessment:** 
**HIGH** - Any malicious miner can execute this attack with trivial technical effort once they have mining rights.

### Recommendation

**Immediate Fix:**
Add validation in `LibInformationValidationProvider` or `UpdateValueValidationProvider` to enforce the critical invariant:

```csharp
// In LibInformationValidationProvider.ValidateHeaderInformation() or UpdateValueValidationProvider
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0)
{
    // During validation, Context.CurrentHeight equals the block being validated
    if (providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != validationContext.ExtraData.BlockHeight)
    {
        validationResult.Message = "ImpliedIrreversibleBlockHeight must equal current block height.";
        return validationResult;
    }
}
```

**Alternative Fix Location:**
Add validation during execution in `ProcessUpdateValue`: [8](#0-7) 

Insert before line 248:
```csharp
Assert(updateValueInput.ImpliedIrreversibleBlockHeight == Context.CurrentHeight,
    "ImpliedIrreversibleBlockHeight must equal current block height.");
```

**Test Cases:**
1. Test UpdateValue with `ImpliedIrreversibleBlockHeight` < `Context.CurrentHeight` → should fail
2. Test UpdateValue with `ImpliedIrreversibleBlockHeight` > `Context.CurrentHeight` → should fail  
3. Test UpdateValue with `ImpliedIrreversibleBlockHeight` == `Context.CurrentHeight` → should succeed
4. Test LIB calculation with mixed legitimate and inflated values → verify only legitimate values used

### Proof of Concept

**Initial State:**
- Blockchain at height 100
- Miner M is in the active miner list for current round
- Current LIB height is 95

**Attack Steps:**

1. Miner M produces block 101 during their legitimate time slot

2. Instead of using system-generated UpdateValue transaction, miner M crafts malicious transaction:
   ```protobuf
   UpdateValueInput {
     out_value: <legitimate_value>
     signature: <legitimate_signature>
     previous_in_value: <legitimate_value>
     round_id: <current_round>
     produced_blocks: <correct_count>
     actual_mining_time: <current_time>
     supposed_order_of_next_round: <correct_order>
     implied_irreversible_block_height: 200  // Inflated value instead of 101
     random_number: <legitimate_random>
   }
   ```

3. Block 101 is propagated with this transaction

4. **Validation Phase** (ValidateConsensusBeforeExecution):
   - `MiningPermissionValidationProvider`: ✓ Pass (M is in miner list)
   - `TimeSlotValidationProvider`: ✓ Pass (correct time slot)
   - `LibInformationValidationProvider`: ✓ Pass (200 > previous value)
   - No validator checks equality with block height 101

5. **Execution Phase** (ProcessUpdateValue):
   - Line 248 executes: `minerInRound.ImpliedIrreversibleBlockHeight = 200`
   - Value stored in state without validation

6. **LIB Calculation** (next UpdateValue by another miner):
   - Collects implied heights from miners in current round
   - Sorted list includes the inflated value 200
   - LIB calculated at position (count-1)/3 is artificially elevated
   - Blocks 96-150 potentially marked irreversible prematurely

**Expected vs Actual Result:**
- **Expected**: UpdateValue rejected with "ImpliedIrreversibleBlockHeight must equal current height"
- **Actual**: UpdateValue succeeds, LIB calculation polluted, finality compromised

**Success Condition:**
Query `GetCurrentRoundInformation()` after block 101 and verify miner M's `ImpliedIrreversibleBlockHeight` equals 200 instead of 101, confirming the vulnerability exists.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L29-29)
```csharp
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** protobuf/aedpos_contract.proto (L217-218)
```text
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```
