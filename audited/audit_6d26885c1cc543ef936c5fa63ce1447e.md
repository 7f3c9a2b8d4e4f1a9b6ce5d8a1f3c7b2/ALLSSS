# Audit Report

## Title
Vote Contract Option Length Validation Bypass Causes Permanent Option Denial of Service

## Summary
The Vote contract's `Register` method fails to validate option lengths during voting item creation, allowing options exceeding 1024 bytes to be added. The `RemoveOption` and `RemoveOptions` methods then cannot remove these oversized options due to validation order issues, causing permanent denial of service on voting item management and state pollution.

## Finding Description

The vulnerability exists due to inconsistent option length validation across different methods in the Vote contract.

**Root Cause - Missing Validation in Register:**

The `Register` method directly copies options from input without any length validation. [1](#0-0) 

The validation helper `AssertValidNewVotingItem` only validates voting item ID, timestamp range, and snapshot number, but completely omits option length checks. [2](#0-1) 

The option length limit is defined as 1024 bytes in the constants file. [3](#0-2) 

**Blocking Validation in RemoveOption:**

The `RemoveOption` method validates option length BEFORE checking if the option exists. This validation order prevents removal of any option exceeding 1024 bytes, even if it legitimately exists in the voting item. [4](#0-3) 

**RemoveOptions Has the Same Issue:**

The `RemoveOptions` (plural) method checks existence first, then validates length. While the order differs, it still fails when attempting to remove oversized options because the length assertion executes before the actual removal. [5](#0-4) 

**Proper Validation in Other Methods:**

In contrast, `AddOption` properly validates option lengths through the `AssertOption` helper before adding options. [6](#0-5) 

Similarly, the `Vote` method validates option lengths before accepting votes. [7](#0-6) 

## Impact Explanation

**Operational Denial of Service:**
- Sponsors who create voting items with options exceeding 1024 bytes permanently lose the ability to remove those options
- The voting item becomes polluted with unremovable, invalid options
- No recovery mechanism exists since both `RemoveOption` and `RemoveOptions` enforce the length check before allowing removal

**Unusable Options:**
- Users cannot vote for options exceeding 1024 bytes because the `Vote` method rejects them
- These options exist in the voting item state but are completely non-functional for voting purposes

**State Pollution:**
- Invalid options persist indefinitely in contract state, incurring storage costs
- The maximum option count of 64 could be reached with invalid options, preventing addition of valid ones [8](#0-7) 

**Protocol Integrity:**
- The Vote contract is a system contract used across the AElf ecosystem
- Permanent unremovable options violate the expected contract behavior and sponsor control guarantees

## Likelihood Explanation

**High Likelihood:**
- Any user can become a sponsor and trigger this condition by calling `Register` with long option strings
- No special permissions or preconditions required beyond standard transaction fees
- The `Register` method is a public entry point accessible to all users [9](#0-8) 
- No validation error occurs during registration, making the issue non-obvious until removal is attempted

**Realistic Attack Scenarios:**

1. **Accidental Trigger:** Developers using programmatically generated option strings (e.g., serialized data structures, long descriptions, or encoded identifiers) may exceed the limit without realizing it due to lack of validation feedback during registration

2. **Intentional DoS:** A malicious sponsor could intentionally create voting items with oversized options to permanently lock them in an invalid state, consuming option slots and preventing proper voting item management

3. **Integration Errors:** When integrating with the Vote contract, external contracts or applications may pass option strings exceeding 1024 bytes without proper validation, resulting in permanently unmanageable voting items

## Recommendation

Add option length validation in the `Register` method before creating the voting item:

```csharp
public override Empty Register(VotingRegisterInput input)
{
    var votingItemId = AssertValidNewVotingItem(input);
    
    // Validate all option lengths before creating voting item
    foreach (var option in input.Options)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, 
            $"Option exceeds maximum length of {VoteContractConstants.OptionLengthLimit} bytes.");
    }
    
    // Rest of the method...
}
```

Alternatively, fix the validation order in `RemoveOption` to check existence before length:

```csharp
public override Empty RemoveOption(RemoveOptionInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
    Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
    Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
    votingItem.Options.Remove(input.Option);
    State.VotingItems[votingItem.VotingItemId] = votingItem;
    return new Empty();
}
```

However, the first approach (validation in Register) is preferred as it prevents the invalid state from occurring in the first place.

## Proof of Concept

```csharp
[Fact]
public async Task Register_WithOversizedOption_CreatesUnremovableOption()
{
    // Create a voting item with an option exceeding 1024 bytes
    var oversizedOption = new string('X', 1025); // 1025 bytes > 1024 limit
    
    var registerInput = new VotingRegisterInput
    {
        StartTimestamp = TimestampHelper.GetUtcNow(),
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(7),
        AcceptedCurrency = "ELF",
        IsLockToken = false,
        TotalSnapshotNumber = 1,
        Options = { oversizedOption }
    };
    
    // Register succeeds despite oversized option (VULNERABILITY)
    var registerResult = await VoteContractStub.Register.SendAsync(registerInput);
    registerResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var votingItemId = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(registerInput), 
        HashHelper.ComputeFrom(DefaultSender));
    
    // Verify the voting item was created with the oversized option
    var votingItem = await VoteContractStub.GetVotingItem.CallAsync(votingItemId);
    votingItem.Options.Count.ShouldBe(1);
    votingItem.Options[0].ShouldBe(oversizedOption);
    
    // Attempt to remove the oversized option
    var removeInput = new RemoveOptionInput
    {
        VotingItemId = votingItemId,
        Option = oversizedOption
    };
    
    // RemoveOption fails with "Invalid input" before checking existence (PERMANENT DOS)
    var removeResult = await VoteContractStub.RemoveOption.SendWithExceptionAsync(removeInput);
    removeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    removeResult.TransactionResult.Error.ShouldContain("Invalid input");
    
    // The oversized option remains permanently in the voting item
    var votingItemAfter = await VoteContractStub.GetVotingItem.CallAsync(votingItemId);
    votingItemAfter.Options.Count.ShouldBe(1); // Still contains unremovable option
}
```

**Notes:**

While the core technical vulnerability is valid, it's important to clarify that the Election contract integration scenario mentioned in the original claim is not accurate. The Election contract uses `AddOption` to add candidates [10](#0-9) , which properly validates option lengths, and never calls `Register` with options. Additionally, standard public keys in hex format are only 66-130 characters, far below the 1024 byte limit. The vulnerability primarily affects sponsors who directly call `Register` with unusually long option strings, which is a more limited scenario than the governance impact initially suggested.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-20)
```csharp
    public override Empty Register(VotingRegisterInput input)
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L49-49)
```csharp
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L285-286)
```csharp
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L292-296)
```csharp
    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L307-308)
```csharp
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L332-334)
```csharp
            Assert(votingItem.Options.Contains(option), "Option doesn't exist.");
            Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
            votingItem.Options.Remove(option);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L380-380)
```csharp
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L6-6)
```csharp
    public const int OptionLengthLimit = 1024;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L204-208)
```csharp
        State.VoteContract.AddOption.Send(new AddOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = publicKey
        });
```
