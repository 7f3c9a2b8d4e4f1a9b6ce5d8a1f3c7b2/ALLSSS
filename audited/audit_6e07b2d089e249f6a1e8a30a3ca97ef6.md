### Title
Permanent Denial-of-Service Through Severe Status Rollback Cycle

### Summary
The AEDPoS consensus contract can enter a permanent denial-of-service state when blockchain mining status reaches "Severe" level. The system attempts recovery by rolling back to the Last Irreversible Block (LIB), but if underlying miner participation issues persist, the chain enters an endless cycle of rollbacks while maintaining near-zero transaction throughput (1 block per miner per time slot). No automatic recovery mechanism exists to break this cycle.

### Finding Description

The vulnerability spans multiple components in the consensus system:

**Severe Status Detection:** [1](#0-0) 

When `currentRoundNumber >= libRoundNumber + SevereStatusRoundsThreshold` (threshold = 8), the system enters Severe status.

**Throughput Reduction:** [2](#0-1) 

In Severe status, `MaximumBlocksCount` returns 1, limiting each miner to producing only 1 block per time slot (8x reduction from the default of 8).

**Automatic Rollback Trigger:** [3](#0-2) 

The `IrreversibleBlockHeightUnacceptable` event with distance > 0 triggers an automatic rollback to LIB via `ResetChainToLibAsync`.

**Chain State Reversion:** [4](#0-3) 

The rollback discards all blocks above LIB height, reverting chain state including consensus round information.

**Root Cause:**
The system depends on LIB advancement to prevent Severe status. LIB can only advance when at least `MinersCountOfConsent` miners produce blocks: [5](#0-4) 

For 21 miners, this requires 15 miners (2/3 + 1). However:

1. **Rounds progress based on TIME** (fixed intervals), not block production
2. **LIB advances based on BLOCKS** (requires 2/3+1 miners to produce UpdateValue)
3. If fewer than 15 miners produce blocks consistently, LIB stalls while rounds continue
4. The gap between currentRound and libRound grows beyond threshold
5. System enters Severe status and rolls back
6. After rollback, if the underlying issue persists (insufficient miners), the cycle repeats

**Why Existing Protections Fail:**

The `IsPreviousBlockInSevereStatus` flag only manages state transitions but doesn't prevent the cycle: [6](#0-5) 

This merely fires a notification event with distance = 0 when exiting Severe status temporarily, but does nothing if the system re-enters Severe status due to persistent insufficient miner participation.

### Impact Explanation

**Operational Destruction:**
- Transaction throughput drops by ~87.5% (from 8 blocks per miner to 1 block per miner)
- Repeated rollbacks discard all blocks above LIB, requiring transaction re-execution
- Users experience complete loss of transaction finality
- The blockchain becomes operationally unusable

**Who Is Affected:**
- All network participants (users, dApps, validators)
- Cross-chain bridges relying on LIB confirmation
- Economic activities requiring transaction finality

**Severity Justification:**
This is a **Critical** vulnerability because:
1. It causes permanent network unavailability with no automatic recovery
2. It requires no attacker - emerges from natural system stress (network issues, miner outages)
3. It affects the entire blockchain operation, not just specific features
4. Recovery requires external intervention (bringing offline miners back online) which may not be possible

### Likelihood Explanation

**Triggering Conditions:**
- No attacker required - vulnerability emerges from operational conditions
- Requires < 2/3+1 miners (< 15 out of 21) to consistently produce blocks
- Can occur due to: network partitions, miner outages, infrastructure failures, economic disincentives during Severe status

**Attack Complexity:**
- **None** - this is a design flaw, not an attack
- System naturally enters this state under adverse but realistic conditions
- No special permissions or sophisticated techniques needed

**Feasibility:**
The consensus behavior provider shows miners produce blocks based on time slots: [7](#0-6) 

Even with MaximumBlocksCount = 1, miners must actively participate. If network conditions or economic incentives cause miner dropout below the 2/3+1 threshold, the DoS cycle begins automatically.

**Probability:**
- Medium to High in networks experiencing: prolonged network issues, validator set instability, or coordinated infrastructure problems
- Once entered, extremely difficult to exit without external coordination to restore miner participation

### Recommendation

**Immediate Mitigations:**

1. **Add Minimum Miner Participation Check Before Rollback:**
```
Before triggering ResetChainToLibAsync, verify that sufficient miners (â‰¥ MinersCountOfConsent) 
are actively producing blocks. If not, delay rollback and log critical alert instead.
```

2. **Implement Progressive Recovery Instead of Full Rollback:**
```
Instead of rolling back to LIB immediately, implement staged recovery:
    - First: Reduce MaximumBlocksCount gradually (e.g., to 4, then 2, then 1)
    - Second: Allow extended time for LIB to catch up before triggering rollback
    - Third: Only rollback if gap exceeds a much higher threshold (e.g., 16+ rounds)
```

3. **Add Circuit Breaker for Repeated Severe Status:**
```
Track number of Severe status entries within a time window.
If Severe status is entered more than N times in M rounds, halt automatic rollback
and require governance intervention instead of continuing the cycle.
```

4. **Implement Emergency Miner Set Reduction:**
```
If persistent insufficient participation, allow governance to temporarily reduce
MinersCountOfConsent threshold or miner set size to maintain liveness.
```

**Long-term Fix:**
Add to `GetMaximumBlocksCount`:
```
// After line 67, before return 1:
if (State.ConsecutiveSevereStatusCount.Value > 3) {
    // Block automatic rollback after 3 consecutive Severe status entries
    Context.Fire(new CriticalConsensusFailure { 
        Message = "Persistent insufficient miner participation detected" 
    });
    // Return higher count to maintain some throughput while alerting
    return 2; 
}
State.ConsecutiveSevereStatusCount.Value = State.ConsecutiveSevereStatusCount.Value.Add(1);
```

**Invariant to Enforce:**
- System MUST NOT rollback more than once within a configurable time window (e.g., 1 hour)
- System MUST verify active miner participation before each rollback decision
- System MUST provide escape mechanism when Severe status persists beyond threshold

### Proof of Concept

**Initial State:**
- 21 miners in validator set
- Normal operation with currentRound = 100, libRound = 95 (gap = 5, Normal status)
- Mining interval = 4 seconds, round duration = 88 seconds

**Exploitation Sequence:**

1. **Step 1 - Network Degradation:** Network issues cause 10 miners to go offline
   - Only 11 out of 21 miners continue producing blocks
   - Less than MinersCountOfConsent (15) required for LIB advancement

2. **Step 2 - LIB Stagnation:** Over next few rounds:
   - Round 101: 11 miners produce UpdateValue, LIB cannot advance (need 15)
   - Round 102: Same, LIB stuck at round 95
   - Round 103: Same, LIB stuck at round 95
   - Gap grows: 103 - 95 = 8

3. **Step 3 - Enter Severe Status:** Round 103 reaches threshold
   - `GetMaximumBlocksCount` detects: currentRound (103) >= libRound (95) + 8
   - Returns MaximumBlocksCount = 1
   - Fires `IrreversibleBlockHeightUnacceptable` event

4. **Step 4 - Automatic Rollback:**
   - Event processor triggers `ResetChainToLibAsync`
   - Chain rolls back from round 103 to round 95 (at LIB height)
   - All blocks from rounds 96-103 discarded
   - Current round reverts to ~95

5. **Step 5 - Cycle Repeats:** After rollback:
   - Still only 11 miners online (< 15 required)
   - Rounds continue progressing based on time
   - LIB still cannot advance (insufficient miners)
   - Gap grows again to 8
   - System enters Severe status again at round 103
   - Rollback happens again
   - **Infinite cycle continues**

**Expected Result:** System should maintain liveness with reduced throughput but eventual recovery

**Actual Result:** System enters permanent DoS cycle with repeated rollbacks, near-zero effective throughput, and no automatic recovery path

**Success Condition for Attack:** Network remains in rollback cycle for > 24 hours, demonstrating permanent DoS condition requiring external intervention to restore miner participation

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L69-78)
```csharp
        if (!State.IsPreviousBlockInSevereStatus.Value)
            return AEDPoSContractConstants.MaximumTinyBlocksCount;

        Context.Fire(new IrreversibleBlockHeightUnacceptable
        {
            DistanceToIrreversibleBlockHeight = 0
        });
        State.IsPreviousBlockInSevereStatus.Value = false;

        return AEDPoSContractConstants.MaximumTinyBlocksCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L127-128)
```csharp
            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockHeightUnacceptableLogEventProcessor.cs (L54-64)
```csharp
        if (distanceToLib.DistanceToIrreversibleBlockHeight > 0)
        {
            Logger.LogDebug($"Distance to lib height: {distanceToLib.DistanceToIrreversibleBlockHeight}");
            Logger.LogDebug("Will rollback to lib height.");
            _taskQueueManager.Enqueue(
                async () =>
                {
                    var chain = await _blockchainService.GetChainAsync();
                    await _blockchainService.ResetChainToLibAsync(chain);
                }, KernelConstants.UpdateChainQueueName);
        }
```

**File:** src/AElf.Kernel.Core/Blockchain/Domain/IChainManager.cs (L460-496)
```csharp
    public async Task<Chain> ResetChainToLibAsync(Chain chain)
    {
        var libHash = chain.LastIrreversibleBlockHash;
        var libHeight = chain.LastIrreversibleBlockHeight;

        foreach (var branch in chain.Branches)
        {
            var hash = Hash.LoadFromBase64(branch.Key);
            var chainBlockLink = await GetChainBlockLinkAsync(hash);

            while (chainBlockLink != null && chainBlockLink.Height > libHeight)
            {
                chainBlockLink.ExecutionStatus = ChainBlockLinkExecutionStatus.ExecutionNone;
                chainBlockLink.IsLinked = false;
                await SetChainBlockLinkAsync(chainBlockLink);

                chainBlockLink = await GetChainBlockLinkAsync(chainBlockLink.PreviousBlockHash);
            }
        }

        chain.Branches.Clear();
        chain.NotLinkedBlocks.Clear();

        chain.Branches[libHash.ToStorageKey()] = libHeight;

        chain.BestChainHash = libHash;
        chain.BestChainHeight = libHeight;
        chain.LongestChainHash = libHash;
        chain.LongestChainHeight = libHeight;

        Logger.LogInformation($"Rollback to height {chain.BestChainHeight}, hash {chain.BestChainHash}.");
        await _chains.SetAsync(chain.Id.ToStorageKey(), chain);

        // Update the cache.
        _chainCache[ChainId] = chain;

        return chain;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L57-62)
```csharp
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```
