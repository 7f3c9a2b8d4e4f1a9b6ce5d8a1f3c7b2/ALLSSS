# Audit Report

## Title
Miner Can Manipulate Next Round Order by Setting Invalid SupposedOrderOfNextRound Without Validation

## Summary
The AEDPoS consensus contract allows miners to manipulate their position in the next round's mining order by providing an arbitrary `SupposedOrderOfNextRound` value without validation. The `ProcessUpdateValue` method directly trusts the miner-provided value, and the `NextRoundMiningOrderValidationProvider` is broken as it validates the wrong round data. This enables miners to bypass deterministic order assignment and incorrectly be treated as "not mined", receiving arbitrary position assignments instead of their cryptographically-determined order.

## Finding Description

The vulnerability consists of two root causes working in combination:

**Root Cause 1: Missing Validation in ProcessUpdateValue**

The `ProcessUpdateValue` method directly assigns `SupposedOrderOfNextRound` from the miner-provided `UpdateValueInput` without validating that it matches the deterministic calculation. [1](#0-0) 

The correct calculation formula exists in `ApplyNormalConsensusData` where `SupposedOrderOfNextRound` should equal `GetAbsModulus(signature.ToInt64(), minersCount) + 1`. [2](#0-1) 

However, `UpdateValueValidationProvider` only checks that `OutValue` and `Signature` are non-empty, but never validates the `SupposedOrderOfNextRound` field matches the signature-derived calculation. [3](#0-2) 

**Root Cause 2: Broken NextRoundMiningOrderValidationProvider**

The `NextRoundMiningOrderValidationProvider` is supposed to validate mining order correctness, but it checks `providedRound` which represents the proposed NEXT round, not the current round. [4](#0-3) 

When `GenerateNextRoundInformation` creates the next round, it generates fresh `MinerInRound` objects that do not have `OutValue` or `FinalOrderOfNextRound` fields populated (they default to null/0). [5](#0-4) 

This causes both validation counts to be 0 (no miners with `FinalOrderOfNextRound > 0` and no miners with `OutValue != null` in the next round), making the validation always pass regardless of actual behavior in the current round.

**Exploitation Mechanism**

The attack exploits how `GetMinedMiners()` determines which miners successfully produced blocks. This method filters miners by checking `SupposedOrderOfNextRound != 0`. [6](#0-5) 

A malicious miner can:
1. Produce a valid block with correct `OutValue`, `Signature`, and other required fields
2. Set `SupposedOrderOfNextRound = 0` in their `UpdateValueInput`
3. Pass all validations since `ProcessUpdateValue` doesn't validate this field
4. When `GenerateNextRoundInformation` is called, they are classified as "not mined" (because `SupposedOrderOfNextRound == 0`)
5. Get assigned to an arbitrary available order slot instead of their deterministic `FinalOrderOfNextRound`
6. Have their `MissedTimeSlots` incorrectly incremented despite producing blocks [7](#0-6) 

## Impact Explanation

**Consensus Integrity Compromise:**
- Breaks the fundamental guarantee that mining order is deterministically calculated from unpredictable cryptographic signatures
- Enables miners to manipulate their position in the next round, selecting favorable time slots for block production
- Allows coordination with other malicious miners to cluster blocks at advantageous positions
- Incorrectly increments `MissedTimeSlots` for miners who actually produced blocks, corrupting reward calculations

**Protocol-Wide Effects:**
- Undermines the randomness of mining order assignment that is core to AEDPoS consensus fairness
- Can be used to manipulate Last Irreversible Block (LIB) calculation by controlling block production timing
- Affects evil miner detection mechanisms that rely on accurate `MissedTimeSlots` tracking
- Compromises cross-chain verification that assumes predictable consensus behavior

**Affected Parties:**
- Honest miners who follow deterministic ordering lose their guaranteed time slots
- Reward distribution mechanisms dependent on accurate mining statistics
- Cross-chain indexing relying on predictable consensus patterns
- Overall network security through consensus manipulation

## Likelihood Explanation

**Trivially Reachable:**
The attack uses the standard `UpdateValue` public method that all miners must call during normal block production. No special privileges beyond being an active miner are required.

**Low Execution Complexity:**
Exploitation requires only:
1. Modifying the consensus client to set `SupposedOrderOfNextRound = 0` in the `UpdateValueInput` structure
2. Keeping all other fields valid (`OutValue`, `Signature`, `PreviousInValue`)
3. No timing coordination, no collusion, no economic cost beyond standard block production

**Difficult to Detect:**
- The `UpdateValue` transaction passes all existing validations
- The miner's block is accepted into the chain normally  
- Only the next round generation treats them differently
- No error events or failed transactions signal the manipulation
- The deviation only appears in round transition logic

**High Probability:**
The vulnerability is deterministic - it works every time. Any miner can execute it with minimal sophistication. The benefit (order manipulation) is clear while the risk is essentially zero, making exploitation highly likely once discovered.

## Recommendation

**Fix 1: Validate SupposedOrderOfNextRound in ProcessUpdateValue**

Add validation after line 246 in `AEDPoSContract_ProcessConsensusInformation.cs`:

```csharp
minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;

// Validate the supposed order matches the signature-derived calculation
var expectedOrder = GetAbsModulus(updateValueInput.Signature.ToInt64(), 
    currentRound.RealTimeMinersInformation.Count) + 1;
Assert(updateValueInput.SupposedOrderOfNextRound == expectedOrder, 
    "Invalid SupposedOrderOfNextRound: does not match signature");

minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**Fix 2: Correct NextRoundMiningOrderValidationProvider**

Modify the validator to check the current round (`baseRound`) instead of `providedRound`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var currentRound = validationContext.BaseRound; // Use BaseRound instead of ProvidedRound
    
    var minersWithOrder = currentRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0).Distinct().Count();
    var minersWhoMined = currentRound.RealTimeMinersInformation.Values
        .Count(m => m.OutValue != null);
        
    if (minersWithOrder != minersWhoMined)
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound.";
        return validationResult;
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MinerCanManipulateNextRoundOrder_BySettingInvalidSupposedOrder()
{
    // Setup: Initialize consensus with multiple miners
    const int minersCount = 5;
    var initialMiners = GenerateInitialMiners(minersCount);
    await InitializeConsensus(initialMiners);
    
    // Miner produces a valid block
    var maliciousMiner = initialMiners[0];
    var signature = HashHelper.ComputeFrom("test_signature");
    var outValue = HashHelper.ComputeFrom("test_outvalue");
    
    // Calculate what the supposed order SHOULD be based on signature
    var expectedOrder = GetAbsModulus(signature.ToInt64(), minersCount) + 1;
    
    // Attack: Set SupposedOrderOfNextRound to 0 instead of expected value
    var maliciousInput = new UpdateValueInput
    {
        OutValue = outValue,
        Signature = signature,
        PreviousInValue = Hash.Empty,
        SupposedOrderOfNextRound = 0, // MALICIOUS: Should be expectedOrder
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        RandomNumber = HashHelper.ComputeFrom("random").ToByteString()
    };
    
    // Execute UpdateValue - should pass validation (demonstrates vulnerability)
    await ConsensusStub.UpdateValue.SendAsync(maliciousInput);
    
    // Verify: Check that miner was incorrectly classified as "not mined"
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var minerInfo = currentRound.RealTimeMinersInformation[maliciousMiner.PublicKey.ToHex()];
    
    // Miner produced a block (OutValue is set)
    minerInfo.OutValue.ShouldNotBeNull();
    
    // But SupposedOrderOfNextRound is 0, so GetMinedMiners() will exclude them
    minerInfo.SupposedOrderOfNextRound.ShouldBe(0);
    
    // Generate next round
    var nextRoundInput = await GenerateNextRoundInput();
    await ConsensusStub.NextRound.SendAsync(nextRoundInput);
    
    var nextRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var nextMinerInfo = nextRound.RealTimeMinersInformation[maliciousMiner.PublicKey.ToHex()];
    
    // Vulnerability: Miner was treated as "not mined" and assigned arbitrary order
    // Instead of their deterministic FinalOrderOfNextRound
    nextMinerInfo.MissedTimeSlots.ShouldBe(1); // Incorrectly incremented!
    
    // Their order is arbitrary (from available slots) not deterministic (from signature)
    // This proves the manipulation succeeded
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-21)
```csharp
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L42-56)
```csharp
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```
