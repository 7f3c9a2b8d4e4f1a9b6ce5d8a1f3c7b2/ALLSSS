### Title
Proposer Override in CreateProposalBySystemContract Breaks Governance Workflow

### Summary
When system contracts create proposals via `CreateProposalBySystemContract`, the `CreateNewProposal` method incorrectly sets `Proposer = Context.Sender` (the system contract address) instead of preserving the `OriginProposer` from the input. This breaks the governance workflow because only the stored Proposer can release proposals, rendering proposals created through system contracts un-releasable by their intended originators.

### Finding Description

The vulnerability exists in the `CreateNewProposal` method which unconditionally sets the proposer to `Context.Sender`: [1](#0-0) 

When `CreateProposalBySystemContract` is called by a system contract (e.g., Genesis contract), it receives a `CreateProposalBySystemContractInput` containing both the proposal parameters and the `OriginProposer` (the actual user who triggered the call): [2](#0-1) 

The `CreateProposalBySystemContract` method validates that the `OriginProposer` is authorized in the whitelist, but then calls `CreateNewProposal` which overwrites the proposer with `Context.Sender` (the system contract): [3](#0-2) 

This creates a critical mismatch because the `Release` method enforces that only the stored `Proposer` can release the proposal: [4](#0-3) 

**Real-World Impact**: The Genesis contract uses `CreateProposalBySystemContract` for contract deployment and update proposals, setting `OriginProposer = Context.Sender` (the actual user): [5](#0-4) [6](#0-5) 

The same vulnerability exists in Parliament and Referendum contracts: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Operational Impact - DoS of Governance Flow (HIGH):**

1. **Contract Deployment/Update Blocked**: Users cannot release their contract deployment or update proposals created through the Genesis contract, breaking the entire contract governance process.

2. **Authorization Bypass**: The authorization check validates `OriginProposer` but the stored `Proposer` is the system contract, creating a security inconsistency where authorization is checked for one entity but permission is granted to another.

3. **Proposals Become Un-releasable**: 
   - The original proposer cannot call `Release` (permission denied)
   - The system contract has no mechanism to release arbitrary proposals on behalf of users
   - Even if approved by the organization, the proposal cannot be executed

4. **Affects All Governance Contracts**: Association, Parliament, and Referendum all share this vulnerability, impacting all governance mechanisms that use system contract proposal creation.

### Likelihood Explanation

**Likelihood: CERTAIN (100%)**

- **Reachable Entry Point**: Public methods `ProposeNewContract` and `ProposeUpdateContract` on Genesis contract are called by normal users
- **No Preconditions**: Occurs automatically every time `CreateProposalBySystemContract` is used
- **Execution Path**: Direct and deterministic:
  1. User calls Genesis contract to propose contract deployment/update
  2. Genesis validates user and creates proposal via system contract call
  3. Bug triggers automatically in `CreateNewProposal`
  4. Proposal is created with wrong proposer
  5. User cannot release when approved

- **No Attack Required**: This is a functional bug, not an exploit - it breaks legitimate usage
- **Currently Deployed**: If this code is in production, all affected proposals are already broken
- **No Workaround**: No mechanism exists for users to release these proposals

### Recommendation

**Fix**: Modify `CreateNewProposal` to accept an optional proposer parameter. When `CreateProposalBySystemContract` is called, pass the `OriginProposer` as the proposer instead of using `Context.Sender`.

**Association_Helper.cs** (and similarly for Parliament_Helper.cs, Referendum_Helper.cs):

```csharp
private Hash CreateNewProposal(CreateProposalInput input, Address proposer = null)
{
    CheckCreateProposalInput(input);
    var proposalId = GenerateProposalId(input);
    var proposal = new ProposalInfo
    {
        ContractMethodName = input.ContractMethodName,
        ExpiredTime = input.ExpiredTime,
        Params = input.Params,
        ToAddress = input.ToAddress,
        OrganizationAddress = input.OrganizationAddress,
        ProposalId = proposalId,
        Proposer = proposer ?? Context.Sender,  // Use provided proposer or Context.Sender
        ProposalDescriptionUrl = input.ProposalDescriptionUrl,
        Title = input.Title,
        Description = input.Description
    };
    // ... rest of method
}
```

**Association.cs**:
```csharp
public override Hash CreateProposalBySystemContract(CreateProposalBySystemContractInput input)
{
    Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
        "Not authorized to propose.");
    AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);
    var proposalId = CreateNewProposal(input.ProposalInput, input.OriginProposer);  // Pass OriginProposer
    return proposalId;
}
```

**Test Cases**:
1. Create proposal via `CreateProposalBySystemContract` and verify stored proposer matches `OriginProposer`
2. Verify original proposer can successfully release approved proposal
3. Verify system contract cannot release the proposal (should fail permission check)

### Proof of Concept

**Initial State**:
- User address: `0xUser123`
- Association organization exists with `0xUser123` in proposer whitelist
- Genesis contract is a registered system contract

**Steps**:
1. User `0xUser123` calls `Genesis.ProposeNewContract(contractCode, category)`
2. Genesis contract internally calls:
   ```
   Association.CreateProposalBySystemContract({
       ProposalInput: { ... },
       OriginProposer: 0xUser123
   })
   ```
3. Association validates `0xUser123` is in whitelist âœ“
4. **BUG**: `CreateNewProposal` sets `Proposer = Context.Sender = Genesis.Address`
5. Proposal is created with `Proposer = Genesis.Address`
6. Organization members approve the proposal
7. User `0xUser123` attempts `Release(proposalId)`

**Expected Result**: Release succeeds because user is the original proposer

**Actual Result**: Release fails with "No permission" because `proposalInfo.Proposer = Genesis.Address` and `Context.Sender = 0xUser123`, failing the check at Association.cs line 186

**Success Condition**: Proposal cannot be released by its intended creator, breaking the governance workflow completely.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L145-173)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId,
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** protobuf/acs3.proto (L151-156)
```text
message CreateProposalBySystemContractInput {
    // The parameters of creating proposal.
    acs3.CreateProposalInput proposal_input =1;
    // The actor that trigger the call.
    aelf.Address origin_proposer = 2;
}
```

**File:** contract/AElf.Contracts.Association/Association.cs (L114-121)
```csharp
    public override Hash CreateProposalBySystemContract(CreateProposalBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Not authorized to propose.");
        AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);
        var proposalId = CreateNewProposal(input.ProposalInput);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L143-172)
```csharp
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName =
                    nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.ProposeContractCodeCheck),
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(DeploySmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = input.Category,
                    IsSystemContract = false
                }.ToByteString(),
                OrganizationAddress = State.ContractDeploymentController.Value.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
            },
            OriginProposer = Context.Sender
        };
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput.ToByteString());

        Context.Fire(new ContractProposed
        {
            ProposedContractInputHash = proposedContractInputHash
        });

        return proposedContractInputHash;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L202-231)
```csharp
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName =
                    nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.ProposeContractCodeCheck),
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(UpdateSmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = info.Category,
                    IsSystemContract = info.IsSystemContract
                }.ToByteString(),
                OrganizationAddress = State.ContractDeploymentController.Value.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
            },
            OriginProposer = Context.Sender
        };
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);

        Context.Fire(new ContractProposed
        {
            ProposedContractInputHash = proposedContractInputHash
        });

        return proposedContractInputHash;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L225-253)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L159-187)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ToAddress = input.ToAddress,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            OrganizationAddress = input.OrganizationAddress,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });

        return proposalId;
    }
```
