### Title
State Persistence Failure in RemoveBeneficiary Causes Share Accounting Loss in Delayed Distribution Schemes

### Summary
The `RemoveBeneficiary` function fails to persist modifications to `CachedDelayTotalShares` when removing beneficiaries from schemes with delayed distribution periods. While it correctly decrements `TotalShares`, the cached delay values remain unchanged in state, causing future profit distributions to use inflated share totals. This results in permanent dilution of profits for remaining beneficiaries.

### Finding Description

The vulnerability exists in the `RemoveBeneficiary` function where state persistence is incomplete. [1](#0-0) 

The function follows this flawed execution path:

1. Reads the scheme from state at line 229
2. Calls `RemoveProfitDetails` which returns removed share amounts
3. Correctly adjusts the local `scheme.CachedDelayTotalShares` map in the loop at lines 243-258
4. **CRITICAL BUG**: Only updates `TotalShares` directly in state at line 260, without writing back the entire modified scheme object
5. Returns without persisting the `CachedDelayTotalShares` modifications

This violates the consistent pattern used throughout the codebase. Every other function that modifies scheme state writes back the entire object. For example, `AddBeneficiary` correctly writes back the full scheme: [2](#0-1) 

Similarly, `RemoveSubScheme` also writes back the entire scheme object: [3](#0-2) 

The `CachedDelayTotalShares` mechanism is critical for delayed distribution. When profits are distributed, the system caches current total shares for future periods: [4](#0-3) 

The Scheme protobuf definition confirms `cached_delay_total_shares` is a mutable map field that must be persisted: [5](#0-4) 

A test case explicitly expects this functionality to work correctly, checking that `CachedDelayTotalShares` is properly adjusted after removal: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact**: When a beneficiary is removed from a scheme with `DelayDistributePeriodCount > 0`, their shares remain counted in the cached totals for future distribution periods. This causes:

- Future profit distributions use inflated `TotalShares` values (including removed beneficiaries)
- Each remaining beneficiary receives a smaller fraction than entitled: `beneficiary_amount = total_amount * shares / inflated_total`
- The "missing" allocation (corresponding to removed shares) is effectively lost/burned, as no beneficiary can claim it
- If 20% of shares are removed but cached values aren't updated, remaining beneficiaries lose approximately 20% of their rightful profits in affected periods

**Who is affected**: All legitimate beneficiaries in schemes with delayed distribution lose a portion of their profits whenever any beneficiary is removed.

**Severity**: HIGH - This causes direct, permanent loss of funds through incorrect profit distribution calculations, violating the critical "dividend distribution and settlement accuracy" invariant.

### Likelihood Explanation

**Reachable Entry Point**: `RemoveBeneficiary` is a public method callable by the scheme manager or TokenHolder contract. [7](#0-6) 

**Feasible Preconditions**: 
- Scheme must have `DelayDistributePeriodCount > 0` (a legitimate configuration for staking rewards)
- Manager removes beneficiaries (normal governance operation)
- No special attacker capabilities needed beyond being the scheme manager

**Execution Practicality**: The bug triggers automatically in normal operations:
1. Create scheme with delay distribution (e.g., 3-period delay for validator rewards)
2. Add beneficiaries and distribute profits in early periods (caches shares for future)
3. Remove any beneficiary (legitimate governance action)
4. Continue distributing profits - cached totals incorrectly include removed shares

**Detection Constraints**: The bug is silent - transactions succeed, but profit calculations are quietly incorrect. There's no revert or error to alert users.

**Probability**: VERY HIGH - Occurs on every `RemoveBeneficiary` call for schemes with delays, which are common in staking/reward systems.

### Recommendation

**Code-level Fix**: Add the missing state write-back in `RemoveBeneficiary`:

After line 260, add:
```csharp
State.SchemeInfos[input.SchemeId] = scheme;
```

This ensures all modifications to the scheme object (including `CachedDelayTotalShares`) are persisted to state, matching the pattern used consistently throughout the contract.

**Alternative Implementation**: Replace line 260's direct field update with:
1. Update the local `scheme.TotalShares` value
2. Write back the entire `scheme` object with all modifications

**Invariant Check**: Add assertion in `DistributeProfits` to verify that cached shares never exceed current total shares.

**Test Case**: Extend the existing test at line 267-273 of SchemeTests.cs to verify profits are correctly distributed after removal, not just that cached values are updated.

### Proof of Concept

**Initial State**:
- Create scheme with `DelayDistributePeriodCount = 3`
- Add 10 beneficiaries with 100 shares each (TotalShares = 1000)
- Distribute 1000 tokens in period 1 (caches TotalShares=1000 for period 4)

**Exploit Steps**:

Transaction 1 (Period 2):
- Add 5 more beneficiaries with 100 shares each
- TotalShares becomes 1500
- Distribute 1000 tokens (caches TotalShares=1500 for period 5)

Transaction 2 (Period 3):
- Remove 5 beneficiaries (500 shares)
- TotalShares correctly becomes 1000
- **BUG**: CachedDelayTotalShares[5] remains 1500 instead of being updated to 1000
- Distribute 1000 tokens (caches TotalShares=1000 for period 6)

Transaction 3 (Period 5):
- Distribute 1500 tokens
- **Expected**: Uses TotalShares=1000, each beneficiary gets: 1500 * 100 / 1000 = 150 tokens
- **Actual**: Uses cached TotalShares=1500, each beneficiary gets: 1500 * 100 / 1500 = 100 tokens
- **Loss**: Each of 10 beneficiaries loses 50 tokens (500 total lost/burned)

**Success Condition**: Beneficiaries receive less than their proportional share because the cached total incorrectly includes removed shares.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L152-153)
```csharp
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
        State.SchemeInfos[input.SchemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-184)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** protobuf/profit_contract.proto (L155-157)
```text
    int32 delay_distribute_period_count = 10;
    // Record the scheme's current total share for deferred distribution of benefits, period -> total shares.
    map<int64, int64> cached_delay_total_shares = 11;
```

**File:** test/AElf.Contracts.Profit.Tests/BVT/SchemeTests.cs (L267-273)
```csharp
        {
            await ContributeAndDistribute(creator, contributeAmountEachTime, 8);
            await RemoveBeneficiaryAsync(creator, Accounts[11].Address);
            var scheme = await creator.GetScheme.CallAsync(_schemeId);
            scheme.CachedDelayTotalShares.Values.ShouldAllBe(v => v == 12);
            scheme.TotalShares.ShouldBe(12);
        }
```
