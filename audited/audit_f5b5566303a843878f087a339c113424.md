### Title
Banned Candidates Can Become Miners Through Incomplete Duplicate Prevention in Snapshot Processing

### Summary
The `GetPreviousTermSnapshotWithNewestPubkey()` function contains a duplicate prevention check that fails when multiple banned candidates map to the same newest pubkey through replacement chains. Only the first banned candidate in the iteration is properly replaced and removed, while subsequent banned candidates with the same newest pubkey remain in the snapshot due to the premature `continue` statement. These remaining banned candidates can then be selected as alternative miners, violating consensus integrity.

### Finding Description

The vulnerability exists in the `GetPreviousTermSnapshotWithNewestPubkey()` function [1](#0-0) 

**Root Cause:**

When processing banned candidates, the function iterates through each banned candidate and attempts to replace it with its newest pubkey. The check at line 154 uses `snapshot.ElectionResult.ContainsKey(newestPubkey)` to prevent duplicates. However, this check causes the function to skip the removal of subsequent banned candidates that share the same newest pubkey.

**Execution Path:**

Consider a replacement chain where candidate A is replaced by B, then B is replaced by C. The `PerformReplacement` function [2](#0-1)  maintains mappings such that both A and B resolve to C via `GetNewestPubkey` [3](#0-2) 

When processing a snapshot containing both A and B:
1. First iteration (A): `newestPubkey = C`, check passes, C is added with A's votes, A is removed
2. Second iteration (B): `newestPubkey = C`, `snapshot.ElectionResult.ContainsKey(C)` returns true, execution hits `continue` at line 154
3. **Critical Issue**: The removal at line 157 is never executed for B, leaving B (a banned pubkey) in the snapshot

**Why Protections Fail:**

The `IsPubkeyBanned` check at line 145 [4](#0-3)  correctly identifies banned candidates, but the duplicate prevention logic prevents their removal. The banned pubkey remains in the snapshot's `ElectionResult` dictionary and can be selected by `GetMinerReplacementInformation` [5](#0-4) , which does not filter out banned pubkeys from the snapshot data.

### Impact Explanation

**Consensus Integrity Violation:**

Banned candidates can be selected as alternative miners through the consensus contract's miner replacement mechanism [6](#0-5) . The consensus contract directly uses candidates from `GetMinerReplacementInformation` without validating their banned status, allowing banned pubkeys to join the active miner set.

**Specific Harms:**
- **Consensus Security**: Previously banned candidates (potentially marked as evil nodes) can regain miner status and participate in block production
- **Reward Misallocation**: Banned candidates receive mining rewards they are not entitled to
- **Protocol Trust**: Undermines the pubkey replacement mechanism intended to remove compromised or misbehaving nodes

**Affected Parties:**
- Network security: Compromised if evil nodes regain miner status
- Legitimate miners: Diluted rewards and reduced mining opportunities
- Token holders: Reduced network security and value

**Severity Justification:**
This is a Medium severity issue because it directly violates the "Miner schedule integrity" invariant and can lead to consensus manipulation, though it requires specific preconditions (replacement chains and evil miner detection).

### Likelihood Explanation

**Attacker Capabilities:**
No special privileges required beyond normal candidate operations. Any candidate admin can create replacement chains through the public `ReplaceCandidatePubkey` method [7](#0-6) 

**Attack Complexity:**
Low to Medium. The scenario requires:
1. Multiple candidates in the same replacement chain (achievable through legitimate key rotation)
2. Snapshot taken before replacements (happens automatically each term)
3. Evil miner detection triggering replacement mechanism (occurs in normal operations)

**Feasibility Conditions:**
- Replacement chains occur naturally during key rotation or security updates
- Snapshots are taken automatically via `TakeSnapshot` [8](#0-7)  each term
- Evil miner detection is part of normal consensus operation

**Economic Rationality:**
Minimal cost - only standard transaction fees for pubkey replacements. Potential gain includes mining rewards and ability to influence consensus.

**Probability Assessment:**
Medium probability. Replacement chains are expected during normal operations (key rotation, security updates), making this vulnerability exploitable without suspicious activity.

### Recommendation

**Code-Level Mitigation:**

Modify the duplicate prevention logic to always remove banned candidates, even when their newest pubkey already exists in the snapshot:

```csharp
foreach (var bannedCandidate in bannedCandidates)
{
    var newestPubkey = GetNewestPubkey(bannedCandidate);
    
    // Always remove the banned candidate first
    if (snapshot.ElectionResult.ContainsKey(bannedCandidate))
    {
        // If newest pubkey doesn't exist yet, transfer the votes
        if (newestPubkey != null && newestPubkey != bannedCandidate && 
            !snapshot.ElectionResult.ContainsKey(newestPubkey))
        {
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
        }
        // Always remove the banned candidate
        snapshot.ElectionResult.Remove(bannedCandidate);
    }
}
```

**Invariant Checks:**

Add validation in `GetMinerReplacementInformation` to filter out banned candidates:
```csharp
var maybeNextCandidates = latestSnapshot.ElectionResult
    .Where(cs => !State.BannedPubkeyMap[cs.Key]) // Add banned check
    .Where(cs => !State.InitialMiners.Value.Value.Contains(...))
    .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
    .OrderByDescending(s => s.Value).ToList();
```

**Test Cases:**

1. Test replacement chain A→B→C with snapshot containing both A and B
2. Verify both A and B are removed from snapshot after processing
3. Verify banned candidates cannot be selected as alternative miners
4. Test with multiple replacement chains converging to same pubkey

### Proof of Concept

**Initial State:**
- Term N: Candidates A and B are active with votes
- Snapshot taken: `ElectionResult = {A: 1000, B: 800}`

**Transaction Sequence:**

1. **Setup Replacement Chain:**
   - Admin calls `ReplaceCandidatePubkey(A, C)`
   - Result: `BannedPubkeyMap[A] = true`, `InitialToNewestPubkeyMap[A] = C`
   
2. **Extend Chain:**
   - Admin calls `ReplaceCandidatePubkey(C, D)`  
   - Result: `BannedPubkeyMap[C] = true`, `InitialToNewestPubkeyMap[A] = D`
   - Now both `GetNewestPubkey(A) = D` and `GetNewestPubkey(C) = D`

3. **Trigger Vulnerability:**
   - Consensus contract calls `GetMinerReplacementInformation`
   - This internally calls `GetPreviousTermSnapshotWithNewestPubkey()`
   - Processing bannedCandidates = [A, C]:
     - Iteration 1 (A): Add D with 1000 votes, remove A
     - Iteration 2 (C): Skip due to `ContainsKey(D) == true`, **C NOT removed**

**Expected vs Actual Result:**

- **Expected**: `snapshot.ElectionResult = {D: 1000}` (both banned candidates removed)
- **Actual**: `snapshot.ElectionResult = {D: 1000, C: 800}` (C remains despite being banned)

**Success Condition:**

When evil miner replacement occurs, C (banned) appears in the `alternativeCandidates` list and can be selected as a replacement miner, violating the invariant that banned pubkeys cannot become miners.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L130-161)
```csharp
    private TermSnapshot GetPreviousTermSnapshotWithNewestPubkey()
    {
        var termNumber = State.CurrentTermNumber.Value.Sub(1);
        var snapshot = State.Snapshots[termNumber];
        if (snapshot == null) return null;
        var invalidCandidates = snapshot.ElectionResult.Where(r => r.Value <= 0).Select(r => r.Key).ToList();
        Context.LogDebug(() => $"Invalid candidates count: {invalidCandidates.Count}");
        foreach (var invalidCandidate in invalidCandidates)
        {
            Context.LogDebug(() => $"Invalid candidate detected: {invalidCandidate}");
            if (snapshot.ElectionResult.ContainsKey(invalidCandidate)) snapshot.ElectionResult.Remove(invalidCandidate);
        }

        if (!snapshot.ElectionResult.Any()) return snapshot;

        var bannedCandidates = snapshot.ElectionResult.Keys.Where(IsPubkeyBanned).ToList();
        Context.LogDebug(() => $"Banned candidates count: {bannedCandidates.Count}");
        if (!bannedCandidates.Any()) return snapshot;
        Context.LogDebug(() => "Getting snapshot and there's miner replaced during current term.");
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
        }

        return snapshot;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-399)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-257)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }

        var rankingList = State.DataCentersRankingList.Value;
        //the profit receiver is not exist but candidate in the data center ranking list
        if (rankingList.DataCenters.ContainsKey(input.OldPubkey))
        {
            rankingList.DataCenters.Add(input.NewPubkey, rankingList.DataCenters[input.OldPubkey]);
            rankingList.DataCenters.Remove(input.OldPubkey);
            State.DataCentersRankingList.Value = rankingList;

            // Notify Profit Contract to update backup subsidy profiting item.
            if (State.ProfitContract.Value == null)
                State.ProfitContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            
            var oldProfitReceiver = GetProfitsReceiverOrDefault(input.OldPubkey);
            var profitReceiver = oldProfitReceiver.Value.Any()
                ? oldProfitReceiver
                : null;
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
        }

        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }

        //     For CandidateVotes and CandidateInformation, just replace value of origin pubkey.
        var candidateVotes = State.CandidateVotes[input.OldPubkey];
        if (candidateVotes != null)
        {
            candidateVotes.Pubkey = newPubkeyBytes;
            State.CandidateVotes[input.NewPubkey] = candidateVotes;
            State.CandidateVotes.Remove(input.OldPubkey);
        }

        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }

        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;

        ReplaceCandidateProfitsReceiver(input.OldPubkey, input.NewPubkey);
        
        Context.Fire(new CandidatePubkeyReplaced
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-329)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;

        // Notify Consensus Contract to update replacement information. (Update from old record.)
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });

        var oldPubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(oldPubkey));
        // Notify Vote Contract to replace option if this is not the initial miner case.
        if (!State.InitialMiners.Value.Value.Contains(oldPubkeyByteString))
        {
            State.VoteContract.RemoveOption.Send(new RemoveOptionInput
            {
                VotingItemId = State.MinerElectionVotingItemId.Value,
                Option = oldPubkey
            });
            State.VoteContract.AddOption.Send(new AddOptionInput
            {
                VotingItemId = State.MinerElectionVotingItemId.Value,
                Option = newPubkey
            });
        }

        State.CandidateSponsorMap[newPubkey] = State.CandidateSponsorMap[oldPubkey];
        State.CandidateSponsorMap.Remove(oldPubkey);

        var managedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedPubkeys.Value.Remove(oldPubkeyByteString);
        managedPubkeys.Value.Add(ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(newPubkey)));
        State.ManagedCandidatePubkeysMap[Context.Sender] = managedPubkeys;

        Context.LogDebug(() => $"Pubkey replacement happened: {oldPubkey} -> {newPubkey}");
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L402-457)
```csharp
    public override Empty TakeSnapshot(TakeElectionSnapshotInput input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        Assert(State.AEDPoSContract.Value == Context.Sender, "No permission.");

        SavePreviousTermInformation(input);

        if (State.ProfitContract.Value == null)
        {
            var profitContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            // Return if profit contract didn't deployed. (Often in test cases.)
            if (profitContractAddress == null) return new Empty();
            State.ProfitContract.Value = profitContractAddress;
        }

        // Update snapshot of corresponding voting record by the way.
        State.VoteContract.TakeSnapshot.Send(new TakeSnapshotInput
        {
            SnapshotNumber = input.TermNumber,
            VotingItemId = State.MinerElectionVotingItemId.Value
        });

        State.CurrentTermNumber.Value = input.TermNumber.Add(1);

        var previousTermMinerList =
            State.AEDPoSContract.GetPreviousTermMinerPubkeyList.Call(new Empty()).Pubkeys.ToList();

        foreach (var pubkey in previousTermMinerList)
            UpdateCandidateInformation(pubkey, input.TermNumber, previousTermMinerList);

        if (State.DividendPoolContract.Value == null)
            State.DividendPoolContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);

        var symbolList = State.DividendPoolContract.GetSymbolList.Call(new Empty());
        var amountsMap = symbolList.Value.ToDictionary(s => s, s => 0L);
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.SubsidyHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.WelfareHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-339)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }
```
