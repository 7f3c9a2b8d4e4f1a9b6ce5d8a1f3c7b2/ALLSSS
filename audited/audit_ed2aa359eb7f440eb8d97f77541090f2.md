### Title
Authorization Bypass in NFT Protocol Creation Allows Creator Impersonation

### Summary
The `Create()` method in the NFT contract accepts an arbitrary `input.Creator` address without validating that the caller has permission to create on behalf of that address. This allows any attacker to create NFT protocols with a victim's address as the creator/issuer, add themselves to the minter list, and mint NFTs that falsely appear to be issued by the victim.

### Finding Description

**Root Cause:**

The vulnerability exists at line 22 of `NFTContract_Create.cs` where the creator is assigned without authorization validation: [1](#0-0) 

The code uses `input.Creator ?? Context.Sender`, which means if `input.Creator` is provided, it is used directly without checking whether `Context.Sender` has permission to create on behalf of that address.

**Why Protections Fail:**

1. No authorization check exists to verify that `Context.Sender == input.Creator` or that the sender has delegation rights.

2. The creator value is then used as the token `Issuer` and stored in the protocol info: [2](#0-1) 

3. The creator is automatically added to the minter list, and the attacker can include themselves in `input.MinterList`: [3](#0-2) 

4. The underlying MultiToken contract's validation only checks token parameters (name length, symbol, decimals), not the issuer authorization: [4](#0-3) 

5. The creator has privileged access to manage minters, as verified by this check in other methods: [5](#0-4) 

6. Minting requires being in the minter list: [6](#0-5) 

**Execution Path:**

The `Create()` method is publicly accessible on the mainchain (enforced at line 16), and the NFT contract is whitelisted in the TokenContract to enable protocol creation. [7](#0-6) 

### Impact Explanation

**Direct Harm:**

1. **Reputation Damage**: Victims are falsely associated with NFT collections they never authorized, potentially including malicious, low-quality, or offensive content.

2. **Unauthorized Minting**: Attackers can mint NFTs that appear to be officially issued by the victim, potentially selling them and profiting from the victim's reputation.

3. **Phishing Attacks**: Attackers can create NFT collections impersonating trusted brands, artists, or organizations to deceive users into purchasing fake NFTs.

4. **Supply Manipulation**: Attackers can mint up to the total supply limit before the victim discovers the unauthorized protocol.

**Who Is Affected:**

- High-profile creators, artists, and brands whose names can be exploited for financial gain
- Users who purchase NFTs believing they are from legitimate creators
- The overall trust and integrity of the NFT ecosystem on AElf

**Severity Justification:**

This is a **Critical** severity issue because:
- It bypasses fundamental authorization controls
- It enables direct financial harm through fraud and impersonation
- It has no preconditions beyond being on the mainchain
- The attack is trivial to execute with a single transaction
- It damages ecosystem trust and can enable large-scale phishing operations

### Likelihood Explanation

**Attacker Capabilities:**

Any user with an account on the AElf mainchain can execute this attack. No special privileges, tokens, or preliminary setup is required beyond basic transaction fees.

**Attack Complexity:**

The attack requires a single transaction calling `NFTContract.Create()` with:
- `input.Creator` set to the victim's address
- `input.MinterList` containing the attacker's address
- Standard protocol parameters (name, symbol, supply, etc.)

**Feasibility Conditions:**

- Attack works on mainchain (enforced by chain ID check)
- NFT contract must be whitelisted in TokenContract (standard production setup based on test configuration)
- No rate limiting or other protective measures exist

**Detection Constraints:**

The victim has no advance warning and may only discover the unauthorized protocol through:
- Monitoring NFT creation events manually
- Reports from confused users
- Damage to their reputation already occurring

The attacker can create multiple protocols before detection, and the victim must actively call `RemoveMinters()` for each one to regain control.

**Probability:**

Given the zero barriers to exploitation and high potential rewards from impersonating valuable brands, this vulnerability will be exploited if deployed.

### Recommendation

**Code-Level Mitigation:**

Add an authorization check in the `Create()` method to ensure only the sender can set themselves as creator:

```csharp
// In NFTContract_Create.cs, line 22, replace with:
var creator = input.Creator ?? Context.Sender;
Assert(creator == Context.Sender, 
    "Only the sender can be set as the creator. Cannot create on behalf of another address.");
```

If delegation functionality is intended, implement an explicit authorization mechanism:
- Add a state mapping for creator delegations
- Add a `DelegateCreatorRights()` method where addresses can explicitly authorize delegates
- Check this delegation before allowing `input.Creator != Context.Sender`

**Invariant Check:**

Add validation that the protocol creator address matches the transaction sender unless explicit delegation exists.

**Test Cases:**

1. Test that `Create()` succeeds when `input.Creator` is null (defaults to sender)
2. Test that `Create()` succeeds when `input.Creator == Context.Sender`
3. Test that `Create()` **fails** when `input.Creator != Context.Sender` without delegation
4. Test delegation mechanism if implemented

### Proof of Concept

**Initial State:**
- Attacker has address `0xAttacker` with sufficient ELF for transaction fees
- Victim has address `0xVictim` (a well-known artist/brand)
- NFT contract is deployed and whitelisted on mainchain

**Attack Steps:**

1. Attacker calls `NFTContract.Create()` with:
   ```
   CreateInput {
     Creator: 0xVictim,
     MinterList: { Value: [0xAttacker] },
     NftType: "ART",
     ProtocolName: "Victim's Official Collection",
     TotalSupply: 10000,
     IsBurnable: true,
     IssueChainId: <mainchain_id>,
     BaseUri: "ipfs://fake-uri/",
     IsTokenIdReuse: false
   }
   ```

2. Transaction executes successfully

3. Attacker calls `NFTContract.Mint()` with the returned symbol:
   ```
   MintInput {
     Symbol: <returned_symbol>,
     Owner: 0xBuyer,
     Uri: "ipfs://fake-nft",
     Alias: "Rare Item #1",
     Quantity: 1
   }
   ```

**Expected vs Actual:**

**Expected**: Transaction should fail with "No permission to set another address as creator"

**Actual**: 
- NFT protocol created with `Creator: 0xVictim` in protocol info
- `Issuer: 0xVictim` in token info
- `MinterList: [0xAttacker, 0xVictim]`
- Attacker successfully mints NFTs appearing to be issued by victim
- Public queries show victim as the creator/issuer

**Success Condition:**

The attack succeeds if `GetNFTProtocolInfo()` returns a protocol with `Creator == 0xVictim` while the transaction was submitted by `0xAttacker`, and the attacker can subsequently mint tokens under that protocol.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-17)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L22-22)
```csharp
        var creator = input.Creator ?? Context.Sender;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L23-34)
```csharp
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L36-38)
```csharp
        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L337-338)
```csharp
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-399)
```csharp
        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
```
