# Audit Report

## Title
Fixed Candidate Registration Cost Enables Predictable Candidate Pool Monopolization Attack

## Summary
The Election contract's fixed 100,000 ELF registration cost combined with the Vote contract's hard 64-candidate limit allows an attacker with 6.4M ELF to monopolize all candidate slots, creating a denial-of-service condition that blocks all new candidate registrations until the attacker voluntarily quits.

## Finding Description

The vulnerability arises from the interaction of three immutable design decisions:

**1. Fixed Registration Cost**

The Election contract hardcodes the candidate registration lock amount at 100,000 ELF with no mechanism for governance adjustment. [1](#0-0) 

**2. Hard Candidate Limit**

The Vote contract enforces a maximum of 64 voting options (candidates) per voting item. [2](#0-1) 

**3. Strict Limit Enforcement**

The `AddOption` method rejects any attempt to exceed the 64-option limit with an assertion. [3](#0-2) 

**Attack Execution Path:**

When a user announces their candidacy via `AnnounceElection` or `AnnounceElectionFor`, the system first locks 100,000 ELF from the sender. [4](#0-3) 

Then it adds the candidate as a voting option via cross-contract call. [5](#0-4) 

The Election contract developers explicitly acknowledged this limitation in comments. [6](#0-5) 

**Why Existing Protections Are Insufficient:**

The only economic barrier is the token lock requirement, but this provides inadequate defense because:

- The attacker's tokens are fully recoverable via `QuitElection`, making this a reversible investment rather than a sunk cost [7](#0-6) 

- The `RemoveEvilNode` governance mechanism exists but requires Emergency Response Organization permission and is designed for consensus misbehavior, not economic slot-filling attacks [8](#0-7) 

- No rate limiting, progressive pricing, or dynamic cost adjustment mechanisms exist to deter bulk registrations

## Impact Explanation

**Operational Denial of Service:**
Once an attacker fills all 64 candidate slots, the `AddOption` assertion will fail for any subsequent candidate registration attempts. This creates complete unavailability of the candidate registration system for all legitimate node operators, regardless of their stake or community support.

**Consensus Centralization Risk:**
While existing candidates can continue receiving votes and becoming miners, no new competition can emerge. The attacker maintains indefinite control over which 64 public keys occupy the entire candidate pool, undermining the permissionless and open nature of the AElf consensus mechanism.

**Quantified Damage:**
- Total attack capital: 6,400,000 ELF (64 × 100,000 ELF)
- Effective cost: Only opportunity cost of locked liquidity (principal is fully recoverable)
- Impact scope: All prospective validators attempting to register as candidates
- Duration: Until attacker voluntarily releases slots via `QuitElection`

**Severity: Medium** — Requires significant capital (6.4M ELF) but enables concrete operational disruption of a critical system component without permanent fund loss.

## Likelihood Explanation

**Attacker Capability Requirements:**
- Control of 6,400,000 ELF tokens plus transaction fees
- Ability to execute 64 transactions calling `AnnounceElection` or `AnnounceElectionFor`
- No special privileges, insider access, or compromised keys required

**Attack Complexity:**
Low complexity with deterministic outcome. The attack is a straightforward sequence of identical public method calls. No race conditions, timing dependencies, or complex state manipulation required.

**Economic Feasibility:**
For wealthy actors or entities with existing consensus/governance interests, the strategic value of controlling candidate pool composition may justify the opportunity cost of locking 6.4M ELF, especially since the principal is fully recoverable and the attack can be maintained indefinitely.

**Detection vs. Mitigation:**
The attack is easily detectable (sudden spike in candidate registrations), but detection provides no mitigation path. Once the 64 slots are filled, the damage is complete. Even the `RemoveEvilNode` governance mechanism would require 64 separate Emergency Response Organization actions while the DoS persists.

## Recommendation

Implement one or more of the following mitigations:

1. **Make Lock Amount Governance-Adjustable:** Convert `LockTokenForElection` from a hardcoded constant to a state variable that can be updated via Parliament governance proposal, allowing dynamic adjustment in response to token value changes or attacks.

2. **Implement Progressive Pricing:** Increase the lock requirement for each additional candidate registered within a time window, making bulk slot monopolization exponentially more expensive.

3. **Add Candidate Slot Reservation:** Reserve a percentage of candidate slots (e.g., 10-20%) that can only be filled through a higher-bar governance approval process, ensuring legitimate new candidates always have an entry path even during attacks.

4. **Introduce Time-Based Penalties:** Implement a decay mechanism where candidates who maintain registration without receiving significant votes gradually lose their slots, automating the removal of "placeholder" candidates.

## Proof of Concept

```csharp
[Fact]
public async Task CandidateSlotMonopolizationAttack()
{
    // Setup: Initialize contracts and prepare attacker with sufficient ELF
    const long lockAmount = 100_000_00000000; // 100,000 ELF
    const int maxCandidates = 64;
    var attackerBalance = lockAmount * maxCandidates;
    
    // Fund attacker account
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = AttackerAddress,
        Symbol = "ELF",
        Amount = attackerBalance
    });
    
    // Attacker fills all 64 candidate slots
    for (int i = 0; i < maxCandidates; i++)
    {
        var candidateKeyPair = CryptoHelper.GenerateKeyPair();
        await ElectionContractStub.AnnounceElectionFor.SendAsync(
            new AnnounceElectionForInput
            {
                Pubkey = candidateKeyPair.PublicKey.ToHex(),
                Admin = AttackerAddress
            });
    }
    
    // Verify: Legitimate candidate cannot register (DoS condition)
    var legitimateCandidate = CryptoHelper.GenerateKeyPair();
    var result = await ElectionContractStub.AnnounceElectionFor.SendWithExceptionAsync(
        new AnnounceElectionForInput
        {
            Pubkey = legitimateCandidate.PublicKey.ToHex(),
            Admin = LegitimateUserAddress
        });
    
    // Assert: Registration fails due to 64-candidate limit
    result.TransactionResult.Error.ShouldContain(
        "The count of options can't greater than 64");
    
    // Attack is reversible - attacker can recover all locked tokens
    for (int i = 0; i < maxCandidates; i++)
    {
        await ElectionContractStub.QuitElection.SendAsync(
            new StringValue { Value = attackerCandidates[i] });
    }
    
    // Verify: Attacker recovered all funds
    var finalBalance = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = AttackerAddress, Symbol = "ELF" });
    finalBalance.Balance.ShouldBe(attackerBalance); // Full recovery
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-5)
```csharp
    public const int MaximumOptionsCount = 64;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L285-286)
```csharp
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L87-88)
```csharp
    ///     Actually this method is for adding an option of the Voting Item.
    ///     Thus the limitation of candidates will be limited by the capacity of voting options.
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L197-209)
```csharp
    private void AddCandidateAsOption(string publicKey)
    {
        if (State.VoteContract.Value == null)
            State.VoteContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.VoteContractSystemName);

        // Add this candidate as an option for the the Voting Item.
        State.VoteContract.AddOption.Send(new AddOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = publicKey
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L240-249)
```csharp
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-350)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
```
