### Title
Circular Swap Logic in BreakContinuousMining Fails to Prevent Consecutive Block Production with Two Miners

### Summary
When the consensus has exactly two miners, the `BreakContinuousMining` function contains a logic flaw where two sequential swap operations cancel each other out, violating the consensus invariant that prevents the same miner from producing consecutive blocks across round boundaries. This allows a miner to produce both the extra block of round N and the first regular block of round N+1, undermining the fairness mechanism of the AEDPoS consensus.

### Finding Description

The vulnerability exists in the `BreakContinuousMining` method [1](#0-0) , which is called during next round generation [2](#0-1) .

**Root Cause**: The method performs two independent swap operations:

1. **First swap** [3](#0-2) : If the first miner of next round (order 1) is the same as the extra block producer of current round, it swaps miners at order 1 and order 2.

2. **Second swap** [4](#0-3) : If the last miner of next round (order `minersCount`) is the same as the extra block producer of next round, it swaps miners at order `minersCount` and order `minersCount-1`.

**Why Protections Fail**: When `minersCount = 2`:
- First miner = order 1
- Second miner = order 2  
- Last miner = order 2 (same as second)
- Last-but-one miner = order 1 (same as first)

Therefore, both swaps operate on the exact same pair of miners (order 1 ↔ order 2), causing them to cancel each other out.

**Execution Path**: When the pseudo-random extra block producer selection [5](#0-4)  chooses the same miner to be extra block producer in both current and next rounds:

1. Initial state: Miner A at order 1 (IsExtraBlockProducer=true), Miner B at order 2
2. First swap executes (line 81 condition true): Miner B → order 1, Miner A → order 2
3. Second swap executes (line 98 condition true): Miner B → order 2, Miner A → order 1  
4. Final state: Back to original - Miner A at order 1 (IsExtraBlockProducer=true), Miner B at order 2

This violates the stated invariant at line 78: "First miner of next round != Extra block producer of current round"

### Impact Explanation

**Consensus Integrity Violation**: The same miner produces consecutive blocks (extra block of round N followed immediately by first block of round N+1), defeating the explicit fairness mechanism designed to prevent this [6](#0-5) .

**Potential Manipulation**: Since the next round's extra block producer selection uses the first miner's signature [7](#0-6) , consecutive production by the same miner could provide undue influence over the pseudo-random selection process.

**Validation Conflicts**: The continuous blocks validator [8](#0-7)  may reject valid blocks produced under this scenario, causing consensus disruption.

**Affected Parties**: Any AElf chain operating with exactly 2 miners (e.g., during initial deployment, testing networks, or minimal validator configurations).

### Likelihood Explanation

**Reachable Entry Point**: `GenerateNextRoundInformation` is called automatically during normal consensus operation when transitioning between rounds [9](#0-8) .

**Feasible Preconditions**: Requires exactly 2 miners in the consensus. This is a valid configuration for:
- Initial network deployment
- Test networks
- Chains with minimal validator requirements
- Edge cases during validator set transitions

**Execution Practicality**: The bug triggers automatically when:
1. A chain operates with `minersCount = 2` [10](#0-9) 
2. The pseudo-random selection picks the same miner for extra block producer in consecutive rounds

**Probability**: With 2 miners, there's approximately 50% probability per round that the same miner will be selected as extra block producer for both current and next rounds (since the selection uses modulo 2 operation).

**No Attacker Control Required**: This occurs naturally through the consensus mechanism without any malicious action.

### Recommendation

**Fix the Swap Logic**: Modify `BreakContinuousMining` to handle the 2-miner edge case by checking if both swap conditions would trigger and preventing the double-swap:

```csharp
private void BreakContinuousMining(ref Round nextRound)
{
    var minersCount = RealTimeMinersInformation.Count;
    if (minersCount <= 1) return;

    var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
    var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
    var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
    
    // Special handling for 2 miners: check if both swaps would trigger
    if (minersCount == 2)
    {
        // Only perform swap if first miner equals current extra producer
        // but NOT if it also equals next extra producer (would cause double swap)
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey &&
            firstMinerOfNextRound.Pubkey != extraBlockProducerOfNextRound.Pubkey)
        {
            var secondMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            SwapMiners(firstMinerOfNextRound, secondMinerOfNextRound);
        }
        return; // Skip second check for 2-miner case
    }
    
    // Original logic for 3+ miners
    // ... existing swap logic ...
}
```

**Add Invariant Validation**: Add assertion after `BreakContinuousMining` to verify the invariant holds:
```csharp
// After line 67
Assert(nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1).Pubkey 
    != GetExtraBlockProducerInformation().Pubkey, 
    "First miner of next round must not be extra producer of current round");
```

**Test Coverage**: Add unit tests specifically for the 2-miner scenario where the same miner is selected as extra block producer in consecutive rounds.

### Proof of Concept

**Initial State (Round N)**:
- Miner A: pubkey="A", IsExtraBlockProducer=true (current round)
- Miner B: pubkey="B"

**Round Transition**:
1. `GenerateNextRoundInformation` is called
2. `CalculateNextExtraBlockProducerOrder` determines order=1 (pseudo-randomly selects Miner A again)
3. Next round initialized with: Miner A (order 1, IsExtraBlockProducer=true), Miner B (order 2)
4. `BreakContinuousMining` executes:
   - First check (line 81): Miner A == Miner A → TRUE → Swap: Miner B→order 1, Miner A→order 2
   - Second check (line 98): Miner A (order 2) == Miner A (IsExtraBlockProducer) → TRUE → Swap: Miner B→order 2, Miner A→order 1
5. Final next round state: Miner A (order 1, IsExtraBlockProducer=true), Miner B (order 2)

**Expected Result**: Miner A should NOT be first miner of next round (should be swapped to order 2)

**Actual Result**: Miner A IS first miner of next round AND was extra producer of current round (invariant violated)

**Success Condition**: Miner A produces the extra block of round N, then immediately produces the first regular block of round N+1, achieving consecutive block production that `BreakContinuousMining` was designed to prevent.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-12)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L67-67)
```csharp
        BreakContinuousMining(ref nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L8-28)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```
