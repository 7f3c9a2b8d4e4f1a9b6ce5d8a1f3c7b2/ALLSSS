### Title
Memory Exhaustion DoS via Unbounded RealTimeMinersInformation Dictionary in Consensus Validation

### Summary
The consensus validation process does not validate the size of the `ProvidedRound.RealTimeMinersInformation` dictionary before performing memory-intensive materialization operations. A malicious miner can craft a block with consensus extra data containing an excessively large Round object (e.g., 100,000+ miner entries instead of the expected ~17-21), causing OutOfMemoryException or severe memory pressure on all validating nodes, resulting in network-wide denial of service.

### Finding Description

The vulnerability exists in the consensus block validation flow. When `ValidateConsensusBeforeExecution` is called, it parses the `AElfConsensusHeaderInformation` from block header extra data without size validation: [1](#0-0) 

The parsed `extraData.Round` (ProvidedRound) is then used to create a `ConsensusValidationContext`: [2](#0-1) 

During validation, `TimeSlotValidationProvider` calls `CheckRoundTimeSlots()` on the ProvidedRound when it's a new round: [3](#0-2) 

The critical issue occurs in `CheckRoundTimeSlots()`, which unconditionally materializes **all** values from the `RealTimeMinersInformation` dictionary into memory: [4](#0-3) 

Additional materialization points exist in `NextRoundMiningOrderValidationProvider`: [5](#0-4) 

And in `ValidateConsensusAfterExecution`: [6](#0-5) 

**Root Cause:** There is no validation comparing `ProvidedRound.RealTimeMinersInformation.Count` against `BaseRound.RealTimeMinersInformation.Count` or checking it against reasonable bounds (expected miner count is 17 by default, growing slowly): [7](#0-6) 

The only authentication is that the sender must be an elected miner (validated by signature matching): [8](#0-7) 

Each `MinerInRound` entry is a complex protobuf message with multiple fields including maps and repeated timestamps: [9](#0-8) 

### Impact Explanation

**Concrete Harm:**
- **Memory Exhaustion:** Materializing hundreds of thousands or millions of `MinerInRound` objects into a sorted list causes OutOfMemoryException or severe memory pressure
- **Network-Wide DoS:** All nodes that receive and attempt to validate the malicious block will experience the same memory exhaustion, causing chain-wide consensus disruption
- **Block Validation Failure:** The affected nodes cannot process blocks, halting consensus progression
- **Resource Consumption:** Even if OutOfMemoryException doesn't occur, excessive memory allocation and sorting operations consume significant CPU and memory, degrading node performance

**Who is Affected:**
- All full nodes validating blocks
- Block producers attempting to continue the chain
- Network availability and consensus reliability

**Severity Justification:** 
This is a Medium severity vulnerability because while it requires the attacker to be an elected miner (limiting the attacker pool), the impact is severe (network-wide DoS) and execution is straightforward with low cost.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an elected miner in the current round (one of ~17-21 miners initially)
- Can sign blocks and include arbitrary consensus extra data
- Only needs to craft one malicious block to trigger the DoS

**Attack Complexity:**
- Low technical complexity - simply populate the `RealTimeMinersInformation` map with excessive entries in the Round protobuf message
- No complex state manipulation or timing requirements needed
- The malicious block will be propagated through the network normally

**Feasibility Conditions:**
- The attacker must maintain miner status (requires being elected/selected as a block producer)
- No apparent network-level block size limits prevent this attack based on code review
- Transaction size limit (5MB) doesn't apply to block header extra data [10](#0-9) 

**Detection Constraints:**
- The malicious block appears valid until validation processing begins
- Memory exhaustion occurs during validation, making it difficult to implement runtime detection
- The attack leaves minimal forensic traces

**Probability:** Medium-High given an elected miner turning malicious, as execution is straightforward and impactful.

### Recommendation

**Immediate Fix:**
Add size validation in `ValidateBeforeExecution` before creating the `ConsensusValidationContext`:

```csharp
// After line 19, before line 46 in AEDPoSContract_Validation.cs
var maxReasonableMinerCount = GetMinersCount(baseRound) * 2; // Allow some tolerance
if (extraData.Round.RealTimeMinersInformation.Count > maxReasonableMinerCount)
{
    return new ValidationResult 
    { 
        Success = false, 
        Message = $"ProvidedRound contains excessive miner count: {extraData.Round.RealTimeMinersInformation.Count}, expected around {baseRound.RealTimeMinersInformation.Count}" 
    };
}
```

**Additional Protections:**
1. Add early size comparison in `MiningPermissionValidationProvider`:
   - Compare `ProvidedRound.RealTimeMinersInformation.Count` with `BaseRound.RealTimeMinersInformation.Count`
   - Reject if deviation exceeds reasonable threshold (e.g., Â±50%)

2. Implement defensive size checks in `CheckRoundTimeSlots`:
   - Add maximum size guard before materialization
   - Return validation failure if count exceeds absolute maximum (e.g., 1000)

3. Add governance-configurable parameter for maximum allowed miner count in ProvidedRound

**Test Cases:**
1. Test with ProvidedRound containing 1000+ miners - should reject validation
2. Test with ProvidedRound miner count deviating significantly from BaseRound - should reject
3. Test with legitimate miner count variations during miner replacement - should pass
4. Load test with maximum allowable miner count to ensure no performance degradation

### Proof of Concept

**Initial State:**
- Attacker is an elected miner in the current round
- Network has 17 active miners (normal configuration)
- Chain is operating normally at height N

**Attack Steps:**

1. **Craft Malicious Round Object:**
   - Create a `Round` message with `RealTimeMinersInformation` containing 100,000 fabricated miner entries
   - Each entry has a valid `MinerInRound` structure with minimal data
   - Set round number to N+1 (next round)

2. **Create Malicious Block:**
   - Produce a valid block at height N+1 during attacker's time slot
   - Include the malicious Round in `AElfConsensusHeaderInformation` as consensus extra data
   - Sign the block with attacker's miner key

3. **Propagate Block:**
   - Broadcast the block through the P2P network
   - Nodes receive the block and begin validation

4. **Trigger Memory Exhaustion:**
   - Node calls `ValidateConsensusBeforeExecution`
   - Parsing succeeds (no size limit)
   - Validation reaches `TimeSlotValidationProvider`
   - `CheckRoundTimeSlots()` executes: `RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList()`
   - Memory exhaustion occurs as 100,000 `MinerInRound` objects are materialized and sorted

**Expected Result:** 
Block validation completes successfully with normal memory usage (~17 miner entries processed)

**Actual Result:**
- OutOfMemoryException during validation, OR
- Excessive memory allocation (gigabytes) causing node degradation/crash
- Validation fails but node stability is compromised
- All nodes attempting to validate the block experience the same issue
- Network consensus halts as nodes cannot progress past the malicious block

**Success Condition:** 
Observing memory usage spike to multiple gigabytes and/or OutOfMemoryException in node logs during block validation, affecting all nodes that receive the malicious block.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-80)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L103-113)
```csharp
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-38)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-21)
```csharp
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L29-32)
```csharp
        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L5-5)
```csharp
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
```
