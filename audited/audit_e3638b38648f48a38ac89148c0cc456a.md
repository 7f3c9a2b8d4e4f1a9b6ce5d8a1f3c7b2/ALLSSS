# Audit Report

## Title
Rounding Errors in Profit Distribution Cause Inaccessible Dust Accumulation in Period Virtual Addresses

## Summary
The `SafeCalculateProfits` function uses truncating division that systematically rounds down profit shares, causing remainder tokens (dust) to accumulate in period-specific virtual addresses. These period addresses are only accessible via `SendVirtualInline` during beneficiary claims, with no mechanism for scheme managers to recover unclaimed remainders after all beneficiaries have claimed their truncated shares.

## Finding Description

The Profit contract's distribution mechanism creates permanent token locks through three interconnected issues:

**Root Cause - Truncating Division:**
The `SafeCalculateProfits` function converts values to decimal for calculation but casts back to long, which truncates fractional amounts: [1](#0-0) 

**Distribution Flow:**
When `DistributeProfits` executes, it stores the total distributed amount in `AmountsMap` for the period: [2](#0-1) 

Sub-schemes receive truncated amounts calculated via `SafeCalculateProfits`: [3](#0-2) 

The remainder after sub-scheme distribution is transferred to the period virtual address: [4](#0-3) 

**Claiming Flow:**
Individual beneficiaries claim using the same truncating calculation based on the original `AmountsMap` amount: [5](#0-4) 

The calculation at line 873 uses `SafeCalculateProfits` which truncates again, ensuring each beneficiary receives a rounded-down amount. After all claims, dust remains in the period address.

**Why Dust is Inaccessible:**
Period virtual addresses are generated deterministically via XOR of scheme ID and period hash: [6](#0-5) 

The ONLY code path that transfers from period addresses is through `SendVirtualInline` during `ClaimProfits`: [7](#0-6) 

No public method exists for managers to withdraw remaining balances. The `BurnProfits` method only operates on the scheme's main virtual address, not period-specific addresses: [8](#0-7) 

The protocol definition confirms no withdrawal mechanism exists for period addresses: [9](#0-8) 

## Impact Explanation

**Quantified Loss:**
- Per-period dust: 0 to (totalShares - 1) tokens per symbol
- Example: 100 tokens distributed among 99 total shares (33+33+33) results in 3×33=99 claimed, leaving 1 token permanently locked
- Over 1,000 periods: thousands of tokens become inaccessible
- Affects ALL profit schemes: consensus mining rewards, treasury distributions, token holder dividends

**Severity Rationale (Medium):**
This represents genuine economic loss through fund locks rather than theft. While individual per-period amounts are small relative to total shares, the cumulative effect across hundreds of periods and multiple active schemes protocol-wide results in measurable value loss. The funds are not exploited by attackers but are permanently removed from circulation, reducing protocol economic efficiency.

## Likelihood Explanation

**Deterministic Occurrence:**
This is not an attack but a mathematical certainty. Whenever `totalAmount % totalShares ≠ 0`, truncation guarantees dust creation. For typical token distributions (e.g., distributing 1,000,000 tokens among 987,654 shares), the calculation produces fractional results that get truncated.

**Operational Reality:**
- Triggered by normal `DistributeProfits` calls from authorized managers
- No special preconditions required
- Affects every distribution period with non-divisible amounts
- Beneficiaries claim normally via `ClaimProfits`
- Schemes run continuously for hundreds or thousands of periods

The probability is effectively 100% for real-world profit distributions.

## Recommendation

Implement a dust recovery mechanism for period virtual addresses:

```csharp
// Add to ProfitContract.cs
public override Empty RecoverPeriodDust(RecoverPeriodDustInput input)
{
    var scheme = State.SchemeInfos[input.SchemeId];
    Assert(scheme != null, "Scheme not found.");
    Assert(Context.Sender == scheme.Manager, "Only manager can recover dust.");
    
    var periodInfo = State.DistributedProfitsMap[
        GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period)];
    
    // Ensure period is old enough (e.g., ProfitReceivingDuePeriodCount expired)
    Assert(input.Period.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod,
        "Period not yet expired.");
    
    // Transfer remaining balance to manager or scheme address
    var periodVirtualHash = GeneratePeriodVirtualAddressFromHash(input.SchemeId, input.Period);
    Context.SendVirtualInline(periodVirtualHash, State.TokenContract.Value,
        nameof(State.TokenContract.Transfer), new TransferInput
        {
            To = scheme.VirtualAddress, // or scheme.Manager
            Amount = input.Amount,
            Symbol = input.Symbol
        }.ToByteString());
    
    return new Empty();
}
```

Alternatively, modify `SafeCalculateProfits` to distribute the last beneficiary's share as the remaining balance rather than using the formula, ensuring zero dust.

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_DustAccumulation_Test()
{
    // Setup: Create scheme with 3 beneficiaries of 33 shares each (99 total)
    const long shares = 33;
    const long totalAmount = 100; // Not evenly divisible by 99
    
    var creator = Creators[0];
    var schemeId = await CreateSchemeAsync();
    
    var beneficiary1 = Address.FromPublicKey(NormalKeyPair[0].PublicKey);
    var beneficiary2 = Address.FromPublicKey(NormalKeyPair[1].PublicKey);
    var beneficiary3 = Address.FromPublicKey(NormalKeyPair[2].PublicKey);
    
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiary1, Shares = shares }
    });
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiary2, Shares = shares }
    });
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiary3, Shares = shares }
    });
    
    // Distribute 100 tokens
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        AmountsMap = { { "ELF", totalAmount } },
        Period = 1
    });
    
    // Get period address
    var periodAddress = await creator.GetSchemeAddress.CallAsync(new SchemePeriod
    {
        SchemeId = schemeId,
        Period = 1
    });
    
    // All beneficiaries claim
    await Normal[0].ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });
    await Normal[1].ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });
    await Normal[2].ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });
    
    // Check each beneficiary received 33 tokens (truncated)
    var balance1 = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = beneficiary1, Symbol = "ELF" });
    var balance2 = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = beneficiary2, Symbol = "ELF" });
    var balance3 = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = beneficiary3, Symbol = "ELF" });
    
    balance1.Balance.ShouldBe(33); // floor(100 * 33 / 99) = 33
    balance2.Balance.ShouldBe(33);
    balance3.Balance.ShouldBe(33);
    
    // Check period address has 1 token dust
    var periodBalance = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = periodAddress, Symbol = "ELF" });
    
    periodBalance.Balance.ShouldBe(1); // Dust: 100 - (33+33+33) = 1
    
    // Verify no mechanism exists to recover this 1 token
    // Manager cannot withdraw from period address - vulnerability confirmed
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L517-558)
```csharp
    private Empty BurnProfits(long period, Dictionary<string, long> profitsMap, Scheme scheme,
        Address profitsReceivingVirtualAddress)
    {
        scheme.CurrentPeriod = period.Add(1);

        var distributedProfitsInfo = new DistributedProfitsInfo
        {
            IsReleased = true
        };
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            if (amount > 0)
            {
                var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = symbol
                });
                if (balanceOfToken.Balance < amount)
                    continue;
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
                distributedProfitsInfo.AmountsMap.Add(symbol, -amount);
            }
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;
        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L585-604)
```csharp
    private void PerformDistributeProfits(Dictionary<string, long> profitsMap, Scheme scheme, long totalShares,
        Address profitsReceivingVirtualAddress)
    {
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
            Context.LogDebug(() => $"Distributing {remainAmount} {symbol} tokens.");
            // Transfer remain amount to individuals' receiving profits address.
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L606-649)
```csharp
    private long DistributeProfitsForSubSchemes(string symbol, long totalAmount, Scheme scheme, long totalShares)
    {
        Context.LogDebug(() => $"Sub schemes count: {scheme.SubSchemes.Count}");
        var remainAmount = totalAmount;
        foreach (var subSchemeShares in scheme.SubSchemes)
        {
            Context.LogDebug(() => $"Releasing {subSchemeShares.SchemeId}");

            // General ledger of this sub profit scheme.
            var subItemVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeShares.SchemeId);

            if (State.TokenContract.Value == null)
                State.TokenContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

            var distributeAmount = SafeCalculateProfits(subSchemeShares.Shares, totalAmount, totalShares);
            if (distributeAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = subItemVirtualAddress,
                        Amount = distributeAmount,
                        Symbol = symbol
                    }.ToByteString());

            remainAmount = remainAmount.Sub(distributeAmount);

            // Update current_period of detail of sub profit scheme.
            var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
            foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;

            State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress] = subItemDetail;

            // Update sub scheme.
            var subScheme = State.SchemeInfos[subSchemeShares.SchemeId];
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
        }

        return remainAmount;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L845-920)
```csharp
    private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
        bool isView = false, string targetSymbol = null)
    {
        var profitsMap = new Dictionary<string, long>();
        var lastProfitPeriod = profitDetail.LastProfitPeriod;

        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }

        profitDetail.LastProfitPeriod = lastProfitPeriod;

        return profitsMap;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L51-60)
```csharp
    private Address GetDistributedPeriodProfitsVirtualAddress(Hash schemeId, long period)
    {
        return Context.ConvertVirtualAddressToContractAddress(
            GeneratePeriodVirtualAddressFromHash(schemeId, period));
    }

    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
    }
```

**File:** protobuf/profit_contract.proto (L15-118)
```text
service ProfitContract {
    option (aelf.csharp_state) = "AElf.Contracts.Profit.ProfitContractState";

    // Create a scheme for profit distribution, and return the created scheme id.
    rpc CreateScheme (CreateSchemeInput) returns (aelf.Hash) {
    }
    
    // Add beneficiary to scheme.
    rpc AddBeneficiary (AddBeneficiaryInput) returns (google.protobuf.Empty) {
    }

    // Remove beneficiary from scheme.
    rpc RemoveBeneficiary (RemoveBeneficiaryInput) returns (google.protobuf.Empty) {
    }
    
    // Batch add beneficiary to scheme.
    rpc AddBeneficiaries (AddBeneficiariesInput) returns (google.protobuf.Empty) {
    }

    // Batch remove beneficiary from scheme.
    rpc RemoveBeneficiaries (RemoveBeneficiariesInput) returns (google.protobuf.Empty) {
    }

    rpc FixProfitDetail (FixProfitDetailInput) returns (google.protobuf.Empty) {
    }

    // Contribute profit to a scheme.
    rpc ContributeProfits (ContributeProfitsInput) returns (google.protobuf.Empty) {
    }
    
    // The beneficiary draws tokens from the scheme.
    rpc ClaimProfits (ClaimProfitsInput) returns (google.protobuf.Empty) {
    }

    // Distribute profits to schemes, including its sub scheme according to period and  token symbol, 
    // should be called by the manager. 
    rpc DistributeProfits (DistributeProfitsInput) returns (google.protobuf.Empty) {
    }
    
    // Add sub scheme to a scheme. 
    // This will effectively add the specified sub-scheme as a beneficiary of the parent scheme.
    rpc AddSubScheme (AddSubSchemeInput) returns (google.protobuf.Empty) {
    }
    
    // Remove sub scheme from a scheme.
    rpc RemoveSubScheme (RemoveSubSchemeInput) returns (google.protobuf.Empty) {
    }
    
    // Reset the manager of a scheme.
    rpc ResetManager (ResetManagerInput) returns (google.protobuf.Empty) {
    }
    
    rpc SetMaximumProfitReceivingPeriodCount(google.protobuf.Int32Value) returns (google.protobuf.Empty) {
    }

    // Get all schemes managed by the specified manager.
    rpc GetManagingSchemeIds (GetManagingSchemeIdsInput) returns (CreatedSchemeIds) {
        option (aelf.is_view) = true;
    }
    
    // Get scheme according to scheme id.
    rpc GetScheme (aelf.Hash) returns (Scheme) {
        option (aelf.is_view) = true;
    }
    
    // Get the virtual address of the number of period of the scheme.
    rpc GetSchemeAddress (SchemePeriod) returns (aelf.Address) {
        option (aelf.is_view) = true;
    }
    
    // Query the distributed profit information for the specified period.
    rpc GetDistributedProfitsInfo (SchemePeriod) returns (DistributedProfitsInfo) {
        option (aelf.is_view) = true;
    }
    
    // Query the beneficiary's profit information on the scheme.
    rpc GetProfitDetails (GetProfitDetailsInput) returns (ProfitDetails) {
        option (aelf.is_view) = true;
    }
    
    // Query the amount of profit according to token symbol. (up to 10 periods).
    rpc GetProfitAmount (GetProfitAmountInput) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    
    // Query the amount of profit according to token symbol.
    rpc GetAllProfitAmount (GetAllProfitAmountInput) returns (GetAllProfitAmountOutput) {
        option (aelf.is_view) = true;
    }

    // Query all profit (up to 10 periods).
    rpc GetProfitsMap (ClaimProfitsInput) returns (ReceivedProfitsMap) {
        option (aelf.is_view) = true;
    }
    
    // Query all profit.
    rpc GetAllProfitsMap (GetAllProfitsMapInput) returns (GetAllProfitsMapOutput) {
        option (aelf.is_view) = true;
    }
    
    rpc GetMaximumProfitReceivingPeriodCount(google.protobuf.Empty) returns (google.protobuf.Int32Value) {
        option (aelf.is_view) = true;
    }
}
```
