### Title
Vote Contract Option Length Validation Uses Character Count Instead of Byte Count, Enabling Storage Bloat via Multibyte UTF-8 Strings

### Summary
The VoteContract validates option length using `.Length` (character count) instead of `Encoding.UTF8.GetByteCount()` (byte count), inconsistent with the established pattern in EconomicContract and TokenContract. This allows Sponsors to create voting options with multibyte UTF-8 characters that consume 2-4x more storage than intended, causing system-wide storage bloat when multiplied across thousands of VotingRecords.

### Finding Description

The VoteContract validates option string length at four locations using character count: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) 

The limit is defined as: [5](#0-4) 

However, in C#, the `.Length` property counts UTF-16 code units (characters), not UTF-8 bytes. Since AElf serializes strings using UTF-8 encoding: [6](#0-5) 

A single character can occupy 1-4 bytes in UTF-8. This creates a discrepancy where 1024 characters using 4-byte UTF-8 sequences (emojis, certain CJK characters) consume 4,096 bytes instead of the presumed ~1,024 bytes.

**Root Cause - Pattern Deviation:**

The codebase establishes a clear pattern for byte-based string validation in both EconomicContract and TokenContract: [7](#0-6) [8](#0-7) 

Both contracts explicitly use `Encoding.UTF8.GetByteCount()` to validate byte limits. The VoteContract's use of `.Length` deviates from this established pattern, indicating this is likely an oversight rather than intentional design.

**Execution Path:**

1. Sponsor calls `Register` or `AddOption` with options containing 1024 multibyte UTF-8 characters
2. Validation at line 294 passes (character count â‰¤ 1024)
3. VotingItem is stored with bloated option strings: [9](#0-8) 

4. When users vote, each VotingRecord stores the full option string: [10](#0-9) 

5. VotingResult.Results map also stores option strings as keys: [11](#0-10) 

### Impact Explanation

**Storage Bloat Multiplication:**
- Single option with 1024 3-byte UTF-8 characters (common CJK): 3,072 bytes vs intended ~1,024 bytes (3x inflation)
- Single option with 1024 4-byte UTF-8 characters (emojis): 4,096 bytes vs intended ~1,024 bytes (4x inflation)

**System-Wide Amplification:**
With 40 options at 3KB each (total ~120KB, just under the 128KB state limit): [12](#0-11) 

If 10,000 users vote:
- 10,000 VotingRecords Ã— 3KB per option = 30MB storage
- Intended: 10,000 VotingRecords Ã— 1KB = 10MB storage
- **20MB excess storage bloat** from a single voting item

**Affected Parties:**
- **All validators and full nodes**: Must store bloated state
- **Voters**: Pay higher gas fees for larger transaction sizes
- **Network**: Increased sync times and state proof generation costs
- **System capacity**: Reduced effective storage capacity by 2-4x for voting data

**Severity Justification:**
While constrained by the 128KB per-write limit and 64 option maximum, the vulnerability enables measurable resource exhaustion affecting all network participants. The deviation from established coding patterns indicates unintended behavior.

### Likelihood Explanation

**Attacker Capabilities:**
- Sponsor role required (anyone can create a voting item and become Sponsor)
- Only needs knowledge of UTF-8 multibyte characters
- No special privileges beyond normal voting item creation

**Attack Complexity:**
- Trivial: Simply use CJK characters, emojis, or other multibyte UTF-8 sequences
- Example: `"ä½ å¥½".Length == 2` but `Encoding.UTF8.GetBytes("ä½ å¥½").Length == 6`
- No sophisticated exploitation techniques required

**Feasibility Conditions:**
- Normal transaction fees apply
- No special network conditions needed
- Works within standard AElf contract execution

**Detection:**
- Difficult to detect as malicious vs legitimate use of international characters
- No clear boundary between "reasonable" and "abusive" multibyte character usage

**Probability:**
High likelihood of occurrence either through:
- Malicious Sponsors deliberately inflating storage
- Legitimate users inadvertently using multibyte-heavy text (Asian language communities)

### Recommendation

**Code-Level Mitigation:**

Replace character-based validation with byte-based validation consistent with EconomicContract and TokenContract patterns:

```csharp
// In VoteContract.cs, lines 294, 307, 333, 380
// Change from:
Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");

// To:
Assert(Encoding.UTF8.GetByteCount(option) <= VoteContractConstants.OptionLengthLimit, 
    "Invalid option size.");
```

**Invariant Checks:**
- Add validation: `Encoding.UTF8.GetByteCount(option) <= 1024` at all option validation points
- Consider reducing OptionLengthLimit if 1024 was intended as byte limit
- Document whether limit is byte-based or character-based

**Test Cases:**
Add tests validating multibyte UTF-8 character handling:
```csharp
// Test with 3-byte UTF-8 characters (CJK)
var option = new string('ä½ ', 400); // 1200 bytes, 400 chars
// Should fail if byte limit is 1024

// Test with 4-byte UTF-8 characters (emojis)  
var option = new string('ðŸ˜€', 300); // 1200 bytes, 300 chars
// Should fail if byte limit is 1024
```

### Proof of Concept

**Initial State:**
- Deployed VoteContract
- Sponsor account with sufficient transaction fees

**Exploitation Steps:**

1. Sponsor creates voting item with options using 1024 3-byte UTF-8 characters:
```
Option: "ä½ å¥½ä½ å¥½ä½ å¥½..." (1024 Chinese characters = 3,072 bytes)
```

2. Validation passes:
    - `option.Length = 1024` â‰¤ `OptionLengthLimit (1024)` âœ“
    - VotingItem stored with 3,072-byte option string

3. 10,000 users vote for this option:
    - Each VotingRecord stores 3,072-byte option
    - Total: 30MB storage vs intended 10MB

**Expected Result:**
- Validation should reject options exceeding 1024 bytes
- Using byte count validation would catch: `Encoding.UTF8.GetByteCount(option) = 3072 > 1024`

**Actual Result:**
- Character-based validation allows 3,072-byte strings
- 3x storage bloat per vote
- System-wide storage inefficiency

**Success Condition:**
Measure VotingRecord state size before/after exploitation, demonstrating 2-4x inflation relative to ASCII-character baseline.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L54-54)
```csharp
        State.VotingItems[votingItemId] = votingItem;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-117)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-180)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L294-294)
```csharp
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L307-307)
```csharp
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L333-333)
```csharp
            Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L380-380)
```csharp
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L6-6)
```csharp
    public const int OptionLengthLimit = 1024;
```

**File:** src/AElf.CSharp.Core/Utils/EncodingHelper.cs (L15-17)
```csharp
    public static byte[] EncodeUtf8(string str)
    {
        return Encoding.UTF8.GetBytes(str);
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L262-265)
```csharp
    private void AssertValidMemo(string memo)
    {
        Assert(Encoding.UTF8.GetByteCount(memo) <= EconomicContractConstants.MemoMaxLength, "Invalid memo size.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L88-92)
```csharp
    private void AssertValidMemo(string memo)
    {
        Assert(memo == null || Encoding.UTF8.GetByteCount(memo) <= TokenContractConstants.MemoMaxLength,
            "Invalid memo size.");
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```
