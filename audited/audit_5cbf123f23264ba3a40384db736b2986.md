### Title
Systematic Token Loss Due to Truncation in Profit Distribution to Period Virtual Addresses

### Summary
The `SafeCalculateProfits()` function uses decimal arithmetic then casts to long, causing truncation of fractional token amounts. When individual beneficiaries claim profits, each claim loses the fractional part, resulting in systematic token loss where the sum of all claims is less than the total distributed amount. These leftover tokens remain permanently locked in period-specific virtual addresses with no recovery mechanism.

### Finding Description

**Root Cause:**

The `SafeCalculateProfits()` function performs the calculation `(long)(decimalTotalAmount * decimalShares / decimalTotalShares)`, which truncates any fractional result. [1](#0-0) 

**Execution Path:**

1. When `DistributeProfits()` is called, it records the total amount in `distributedProfitsInformation.AmountsMap[symbol]` and transfers tokens to a period-specific virtual address. [2](#0-1) 

2. The period virtual address is generated deterministically via `GetDistributedPeriodProfitsVirtualAddress()`. [3](#0-2) 

3. When beneficiaries call `ClaimProfits()`, the `ProfitAllPeriods()` function calculates each beneficiary's share using `SafeCalculateProfits(profitDetail.Shares, distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares)`. [4](#0-3) 

4. Each calculated amount is transferred from the period virtual address to the beneficiary. [5](#0-4) 

**Why Protections Fail:**

The Profit contract provides no mechanism to recover leftover tokens from period virtual addresses. The protobuf definition shows only `ClaimProfits` can withdraw from these addresses, and no admin/manager recovery function exists. [6](#0-5) 

### Impact Explanation

**Quantified Loss:**
For each beneficiary with shares S out of total shares T claiming from amount A:
- True share: A × S / T
- Received: floor(A × S / T)  
- Loss per beneficiary: up to 1 token (the fractional part)

With N beneficiaries, total loss per period can reach N tokens. Over multiple periods, schemes, and token symbols, this accumulates to significant locked value.

**Concrete Example:**
- 100 tokens distributed among 30 beneficiaries (1 share each, 30 total shares)
- Each beneficiary should receive: 100/30 = 3.333... tokens
- Each beneficiary claims: floor(3.333...) = 3 tokens
- Total distributed: 30 × 3 = 90 tokens
- **Permanently locked: 10 tokens in period virtual address**

**Affected Parties:**
All schemes and beneficiaries experience proportional value loss. The tokens remain in virtual addresses that no one controls or can access, effectively removing them from circulation.

### Likelihood Explanation

**Certainty:** This occurs deterministically in every profit distribution where share calculations don't divide evenly.

**No Attacker Required:** This is a design flaw that triggers through normal contract operation. Any scheme manager calling `DistributeProfits()` and beneficiaries calling `ClaimProfits()` will trigger the loss.

**Preconditions:** Simply requires:
1. A profit scheme with multiple beneficiaries
2. Token amount not perfectly divisible by share ratios
3. Normal profit distribution and claiming workflow

**Detection:** Test evidence shows developers are aware, using tolerance checks like `ShouldBeInRange(shouldClaimed - 2, shouldClaimed)` and `profitsList.Sum().ShouldBeInRange(totalAmount - 6, totalAmount)` to accommodate rounding losses. [7](#0-6) 

However, awareness in tests doesn't prevent the accumulation of locked tokens in production.

### Recommendation

**Immediate Fix:**
Implement a dust distribution mechanism in `DistributeProfits()`:

1. After recording distributed amounts, track the actual sum of all beneficiary calculations using the same `SafeCalculateProfits()` logic
2. Calculate the difference between recorded amount and sum of calculated claims
3. Distribute this "dust" amount to the first beneficiary or proportionally across top share holders
4. Alternatively, add the dust to the next period's distribution for the same scheme

**Code-Level Mitigation:**
Modify the distribution recording in `UpdateDistributedProfits()` to store the sum of calculated beneficiary shares (not the input amount) to ensure recorded amounts match claimable amounts.

**Recovery Function:**
Add a scheme manager function to withdraw unclaimed balances from period virtual addresses after a reasonable expiration period (e.g., after all beneficiaries have claimed or period has expired).

**Invariant Check:**
Add assertion: `sum(all calculated beneficiary shares) + dust <= recorded distribution amount`

**Test Cases:**
1. Test with amounts that don't divide evenly (e.g., 100 tokens, 30 equal shares)
2. Verify period virtual address balance equals zero after all claims
3. Test recovery function retrieves any remaining dust

### Proof of Concept

**Initial State:**
- Profit scheme created with SchemeId = SCHEME_X
- 30 beneficiaries added, each with 1 share (TotalShares = 30)
- No sub-schemes for simplicity

**Transaction Sequence:**

1. **Contribute Profits:**
   ```
   ContributeProfits(schemeId: SCHEME_X, amount: 100, symbol: "ELF")
   ```

2. **Distribute Profits (Period 1):**
   ```
   DistributeProfits(schemeId: SCHEME_X, period: 1, amountsMap: {"ELF": 100})
   ```
   - Records: AmountsMap["ELF"] = 100, TotalShares = 30
   - Transfers 100 ELF to period-1 virtual address

3. **All 30 Beneficiaries Claim:**
   ```
   For i = 1 to 30:
     ClaimProfits(schemeId: SCHEME_X, beneficiary: BENEFICIARY_i)
     // Each receives: floor(100 * 1 / 30) = floor(3.333...) = 3 ELF
   ```

**Expected Result:**
- Total claimed: 30 × 3 = 90 ELF
- All 100 ELF distributed to beneficiaries

**Actual Result:**
- Total claimed: 90 ELF transferred to beneficiaries
- Remaining: 10 ELF locked in period-1 virtual address (GetSchemeAddress with period=1)
- No method exists to recover the 10 ELF

**Success Condition:**
Query balance of period-1 virtual address after all claims shows non-zero balance:
```
GetBalance(owner: GetSchemeAddress(schemeId: SCHEME_X, period: 1), symbol: "ELF")
Returns: 10 ELF (locked permanently)
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L887-895)
```csharp
                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L51-60)
```csharp
    private Address GetDistributedPeriodProfitsVirtualAddress(Hash schemeId, long period)
    {
        return Context.ConvertVirtualAddressToContractAddress(
            GeneratePeriodVirtualAddressFromHash(schemeId, period));
    }

    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
    }
```

**File:** protobuf/profit_contract.proto (L15-118)
```text
service ProfitContract {
    option (aelf.csharp_state) = "AElf.Contracts.Profit.ProfitContractState";

    // Create a scheme for profit distribution, and return the created scheme id.
    rpc CreateScheme (CreateSchemeInput) returns (aelf.Hash) {
    }
    
    // Add beneficiary to scheme.
    rpc AddBeneficiary (AddBeneficiaryInput) returns (google.protobuf.Empty) {
    }

    // Remove beneficiary from scheme.
    rpc RemoveBeneficiary (RemoveBeneficiaryInput) returns (google.protobuf.Empty) {
    }
    
    // Batch add beneficiary to scheme.
    rpc AddBeneficiaries (AddBeneficiariesInput) returns (google.protobuf.Empty) {
    }

    // Batch remove beneficiary from scheme.
    rpc RemoveBeneficiaries (RemoveBeneficiariesInput) returns (google.protobuf.Empty) {
    }

    rpc FixProfitDetail (FixProfitDetailInput) returns (google.protobuf.Empty) {
    }

    // Contribute profit to a scheme.
    rpc ContributeProfits (ContributeProfitsInput) returns (google.protobuf.Empty) {
    }
    
    // The beneficiary draws tokens from the scheme.
    rpc ClaimProfits (ClaimProfitsInput) returns (google.protobuf.Empty) {
    }

    // Distribute profits to schemes, including its sub scheme according to period and  token symbol, 
    // should be called by the manager. 
    rpc DistributeProfits (DistributeProfitsInput) returns (google.protobuf.Empty) {
    }
    
    // Add sub scheme to a scheme. 
    // This will effectively add the specified sub-scheme as a beneficiary of the parent scheme.
    rpc AddSubScheme (AddSubSchemeInput) returns (google.protobuf.Empty) {
    }
    
    // Remove sub scheme from a scheme.
    rpc RemoveSubScheme (RemoveSubSchemeInput) returns (google.protobuf.Empty) {
    }
    
    // Reset the manager of a scheme.
    rpc ResetManager (ResetManagerInput) returns (google.protobuf.Empty) {
    }
    
    rpc SetMaximumProfitReceivingPeriodCount(google.protobuf.Int32Value) returns (google.protobuf.Empty) {
    }

    // Get all schemes managed by the specified manager.
    rpc GetManagingSchemeIds (GetManagingSchemeIdsInput) returns (CreatedSchemeIds) {
        option (aelf.is_view) = true;
    }
    
    // Get scheme according to scheme id.
    rpc GetScheme (aelf.Hash) returns (Scheme) {
        option (aelf.is_view) = true;
    }
    
    // Get the virtual address of the number of period of the scheme.
    rpc GetSchemeAddress (SchemePeriod) returns (aelf.Address) {
        option (aelf.is_view) = true;
    }
    
    // Query the distributed profit information for the specified period.
    rpc GetDistributedProfitsInfo (SchemePeriod) returns (DistributedProfitsInfo) {
        option (aelf.is_view) = true;
    }
    
    // Query the beneficiary's profit information on the scheme.
    rpc GetProfitDetails (GetProfitDetailsInput) returns (ProfitDetails) {
        option (aelf.is_view) = true;
    }
    
    // Query the amount of profit according to token symbol. (up to 10 periods).
    rpc GetProfitAmount (GetProfitAmountInput) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    
    // Query the amount of profit according to token symbol.
    rpc GetAllProfitAmount (GetAllProfitAmountInput) returns (GetAllProfitAmountOutput) {
        option (aelf.is_view) = true;
    }

    // Query all profit (up to 10 periods).
    rpc GetProfitsMap (ClaimProfitsInput) returns (ReceivedProfitsMap) {
        option (aelf.is_view) = true;
    }
    
    // Query all profit.
    rpc GetAllProfitsMap (GetAllProfitsMapInput) returns (GetAllProfitsMapOutput) {
        option (aelf.is_view) = true;
    }
    
    rpc GetMaximumProfitReceivingPeriodCount(google.protobuf.Empty) returns (google.protobuf.Int32Value) {
        option (aelf.is_view) = true;
    }
}
```

**File:** test/AElf.Contracts.Election.Tests/Full/CitizenWelfareTests.cs (L716-724)
```csharp
            actualClaimed.ShouldBeInRange(shouldClaimed - 2, shouldClaimed);
            profitsList.Add(actualClaimed);

            logEvents.First().TotalShares.ShouldBe(_profitShare.GetTotalSharesOfPeriod(period));
            logEvents.Select(l => l.ClaimerShares).Sum()
                .ShouldBe(_profitShare.GetSharesOfPeriod(period)[VoterKeyPairs[i].PublicKey.ToHex()]);
        }

        profitsList.Sum().ShouldBeInRange(totalAmount - 6, totalAmount);
```
