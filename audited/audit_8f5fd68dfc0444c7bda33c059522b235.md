### Title
Null Dereference in Profit Distribution Causes DoS When Sub-Scheme Beneficiary Details Are Removed

### Summary
The `DistributeProfitsForSubSchemes` method accesses `ProfitDetailsMap` for sub-scheme virtual addresses without null-checking, causing a NullReferenceException when profit details have been removed via `RemoveBeneficiary`. This creates a permanent DoS condition preventing all profit distributions for schemes with inconsistent sub-scheme state.

### Finding Description

The vulnerability exists in the profit distribution flow where sub-scheme profit details are accessed without null validation. [1](#0-0) 

The code unconditionally accesses `subItemDetail.Details` without checking if `subItemDetail` is null. This state can become null through the following path:

When a sub-scheme is added via `AddSubScheme`, two state updates occur:
1. The sub-scheme is added to the parent scheme's `SubSchemes` list
2. Profit details are created via `AddBeneficiary` for the sub-scheme's virtual address [2](#0-1) [3](#0-2) 

However, `RemoveBeneficiary` can remove profit details without updating the `SubSchemes` list. When all profit details are removed, the entry is deleted from `ProfitDetailsMap`: [4](#0-3) 

For schemes with `CanRemoveBeneficiaryDirectly = true`, profit details can be fully removed after distribution when `LastProfitPeriod >= CurrentPeriod`: [5](#0-4) [6](#0-5) 

The root cause is an inconsistency between two data structures: the `SubSchemes` list (only modified by `AddSubScheme`/`RemoveSubScheme`) and `ProfitDetailsMap` (modified by `AddBeneficiary`/`RemoveBeneficiary`). The contract allows these to become desynchronized.

### Impact Explanation

**DoS of Profit Distribution System:**
- Once triggered, the scheme permanently fails at profit distribution
- All beneficiaries of the affected scheme cannot receive their profits
- Funds remain locked in the scheme's virtual address indefinitely
- No recovery mechanism exists without contract upgrade

**Affected Parties:**
- All beneficiaries expecting profit distributions from the affected scheme
- Any parent schemes that have the affected scheme as a sub-scheme (cascading failure)
- Protocol treasury and reward distribution if system schemes are affected

**Severity: High** - This creates a permanent DoS condition that locks funds and breaks the core profit distribution mechanism. While it requires scheme manager access, the impact is severe and irreversible.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Scheme manager privileges (either malicious or compromised manager)
- Or accidental misconfiguration by legitimate manager using wrong API

**Attack Complexity: Low**
1. Create scheme with `can_remove_beneficiary_directly = true`
2. Add sub-scheme via `AddSubScheme`
3. Distribute profits once (sets `LastProfitPeriod`)
4. Call `RemoveBeneficiary` on sub-scheme's virtual address instead of `RemoveSubScheme`
5. Attempt next profit distribution triggers NullReferenceException

**Feasibility Conditions:**
- Scheme must have `CanRemoveBeneficiaryDirectly = true` (configurable at creation)
- Manager must call `RemoveBeneficiary` instead of `RemoveSubScheme` (API confusion)
- At least one distribution cycle must occur before removal

**Detection/Operational Constraints:**
- The dual-API design (`RemoveBeneficiary` vs `RemoveSubScheme`) creates confusion
- No validation prevents using the wrong removal method
- Error manifests as transaction failure, not immediately visible

**Probability: Medium-High** - The confusing dual-API design and lack of validation make accidental triggering likely, especially for complex schemes with multiple sub-schemes.

### Recommendation

**Immediate Fix:**
Add null-check before accessing profit details in `DistributeProfitsForSubSchemes`:

```csharp
var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
if (subItemDetail != null)
{
    foreach (var detail in subItemDetail.Details) 
        detail.LastProfitPeriod = scheme.CurrentPeriod;
    State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress] = subItemDetail;
}
```

**Invariant Checks:**
1. Add validation in `RemoveBeneficiary` to prevent removal of sub-scheme virtual addresses:
```csharp
// Check if beneficiary is a sub-scheme virtual address
var isSubScheme = scheme.SubSchemes.Any(s => 
    Context.ConvertVirtualAddressToContractAddress(s.SchemeId) == input.Beneficiary);
Assert(!isSubScheme, "Cannot remove sub-scheme beneficiary. Use RemoveSubScheme instead.");
```

2. Add consistency check in `DistributeProfits` before distribution
3. Consider merging removal APIs or adding better documentation

**Test Cases:**
1. Attempt to remove sub-scheme using `RemoveBeneficiary` - should fail
2. Remove sub-scheme using `RemoveSubScheme` then distribute - should succeed
3. Verify profit details exist for all sub-schemes before distribution

### Proof of Concept

**Initial State:**
- Deploy Profit contract
- Token contract available for transfers

**Attack Steps:**

1. **Create parent scheme with removable beneficiaries:**
   ```
   CreateScheme({
     can_remove_beneficiary_directly: true,
     profit_receiving_due_period_count: 100
   }) → SchemeA_ID
   ```

2. **Create sub-scheme:**
   ```
   CreateScheme({
     can_remove_beneficiary_directly: false
   }) → SchemeB_ID
   ```

3. **Add sub-scheme to parent:**
   ```
   AddSubScheme({
     scheme_id: SchemeA_ID,
     sub_scheme_id: SchemeB_ID,
     sub_scheme_shares: 100
   })
   ```
   *State: SchemeB virtual address now in both SubSchemes list AND ProfitDetailsMap*

4. **Distribute profits once:**
   ```
   ContributeProfits({scheme_id: SchemeA_ID, amount: 1000, symbol: "ELF"})
   DistributeProfits({scheme_id: SchemeA_ID, period: 1})
   ```
   *State: LastProfitPeriod set to 1 for SchemeB's profit details*

5. **Remove sub-scheme using wrong API:**
   ```
   RemoveBeneficiary({
     scheme_id: SchemeA_ID,
     beneficiary: SchemeB_VirtualAddress
   })
   ```
   *State: ProfitDetailsMap entry removed, but SchemeB still in SubSchemes list*

6. **Attempt second distribution:**
   ```
   DistributeProfits({scheme_id: SchemeA_ID, period: 2})
   ```

**Expected Result:** Distribution succeeds

**Actual Result:** Transaction fails with NullReferenceException when accessing `subItemDetail.Details` at line 635

**Success Condition:** Transaction reverts, all subsequent distributions for SchemeA fail permanently, funds locked in virtual address

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L109-118)
```csharp
        AddBeneficiary(new AddBeneficiaryInput
        {
            SchemeId = input.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = subSchemeVirtualAddress,
                Shares = input.SubSchemeShares
            },
            EndPeriod = long.MaxValue
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L121-125)
```csharp
        scheme.SubSchemes.Add(new SchemeBeneficiaryShare
        {
            SchemeId = input.SubSchemeId,
            Shares = input.SubSchemeShares
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L346-349)
```csharp
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L376-383)
```csharp
        if (profitDetails.Details.Count != 0)
        {
            State.ProfitDetailsMap[scheme.SchemeId][beneficiary] = profitDetails;
        }
        else
        {
            State.ProfitDetailsMap[scheme.SchemeId].Remove(beneficiary);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L634-635)
```csharp
            var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
            foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;
```
