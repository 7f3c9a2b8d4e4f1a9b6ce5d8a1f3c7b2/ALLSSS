### Title
Missing Validation of Decrypted Secret Shares Allows Consensus State Corruption

### Summary
The `UpdateLatestSecretPieces()` and `PerformSecretSharing()` functions accept decrypted secret shares from miners without validating that these shares were correctly decrypted from the corresponding encrypted pieces. This allows malicious miners to submit arbitrary fake decrypted shares, corrupting the secret sharing mechanism and enabling manipulation of revealed InValues used in consensus.

### Finding Description

The vulnerability exists in two entry points where decrypted pieces are processed:

**Entry Point 1:** `UpdateLatestSecretPieces()` directly accepts and stores decrypted pieces without any validation: [1](#0-0) 

**Entry Point 2:** `PerformSecretSharing()` in the UpdateValue transaction path also accepts decrypted pieces without validation: [2](#0-1) 

**Root Cause:** When `RevealSharedInValues()` attempts to reconstruct a miner's InValue from stored decrypted pieces, it uses Shamir's Secret Sharing decoding but never validates that the reconstructed value is correct: [3](#0-2) 

The reconstructed `revealedInValue` is directly stored as `PreviousInValue` without checking if `Hash(revealedInValue) == OutValue` from the previous round. The expected validation (comparing against the miner's previously committed OutValue) is completely absent.

**Why Existing Protections Fail:** While there is validation when a miner provides their own `PreviousInValue` directly: [4](#0-3) 

This validation only applies to self-reported PreviousInValue, not to values reconstructed from other miners' decrypted pieces. The secret sharing reconstruction path has zero cryptographic validation.

### Impact Explanation

**Consensus Integrity Compromise:**
- Malicious miners can provide arbitrary fake decrypted shares that get stored in round state
- When these fake shares are used to reconstruct InValues via `RevealSharedInValues()`, the result is a cryptographically invalid value
- This corrupts the PreviousInValue field for honest miners who don't self-reveal

**Secret Sharing Mechanism Breakdown:**
- The entire purpose of Shamir's Secret Sharing is to allow InValue recovery if a miner doesn't reveal
- With fake decrypted pieces, the recovered InValue is meaningless garbage
- This breaks the accountability and availability properties of the consensus mechanism

**State Corruption:**
- Fake decrypted pieces persist in contract state: [5](#0-4) 
- Corrupted PreviousInValues can affect signature calculations: [6](#0-5) 
- Multiple miners providing fake shares can completely disable InValue recovery

**Severity Justification:** HIGH - This directly violates the "Consensus & Cross-Chain Integrity" invariant by allowing corruption of consensus state through fake cryptographic shares.

### Likelihood Explanation

**Attacker Capabilities:** Any active miner in the current round can execute this attack. The attacker needs only:
1. Be authorized to produce blocks (normal miner capability)
2. Submit UpdateValue transactions or produce consensus blocks with trigger information

**Attack Complexity:** LOW
- No sophisticated cryptographic attacks required
- Simply provide arbitrary bytes as "decrypted pieces" instead of properly decrypting the encrypted shares
- The contract blindly accepts and stores these fake bytes

**Feasibility Conditions:** The attack works whenever secret sharing is enabled: [7](#0-6) 

**Detection Difficulty:** The attack is hard to detect because:
- Fake decrypted pieces look like valid byte arrays on-chain
- Only when reconstruction happens does the corruption become apparent
- No error is thrown - invalid InValues are silently stored

**Economic Rationality:** The attack costs only normal transaction fees. A malicious miner could:
- Disrupt consensus for competitor miners
- Force dependence on self-revealed PreviousInValues only
- Undermine trust in the secret sharing mechanism

### Recommendation

**Add Cryptographic Validation:** After reconstructing the InValue from decrypted pieces in `RevealSharedInValues()`, validate it against the miner's previously committed OutValue:

```csharp
var revealedInValue = HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// CRITICAL: Validate reconstructed InValue matches committed OutValue
if (HashHelper.ComputeFrom(revealedInValue) != anotherMinerInPreviousRound.OutValue)
{
    Context.LogDebug(() => $"Invalid decrypted pieces for {publicKeyOfAnotherMiner} - reconstruction failed");
    continue; // Skip this miner, don't set corrupted PreviousInValue
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**Add Validation in Storage Functions:** Both `UpdateLatestSecretPieces()` and `PerformSecretSharing()` should perform early validation:
- When enough decrypted pieces are collected for a miner, immediately attempt reconstruction
- Verify `Hash(reconstructed) == OutValue` before accepting the pieces
- Reject or flag transactions containing invalid decrypted pieces

**Test Cases:**
1. Submit UpdateValue with fake decrypted pieces - should be rejected
2. Verify InValue reconstruction only succeeds with valid pieces
3. Test that consensus continues correctly when some miners provide fake pieces
4. Ensure honest miners' InValues can still be revealed despite malicious participants

### Proof of Concept

**Initial State:**
- Round N with miners A, B, C
- Miner A publishes OutValue_A = Hash(InValue_A) and EncryptedPieces(InValue_A)
- Miner A's encrypted piece for miner B is stored on-chain

**Attack Steps:**

1. **Round N+1 - Malicious Submission:**
   - Miner B (attacker) produces a block or submits UpdateValue
   - Instead of decrypting the encrypted piece properly, B provides fake bytes: `DecryptedPieces[A] = 0x1234567890abcdef...` (arbitrary garbage)
   - The contract accepts this via: [1](#0-0) 

2. **State Corruption:**
   - Fake decrypted piece is stored: `Round.RealTimeMinersInformation[A].DecryptedPieces[B] = 0x1234...`
   - If miners B and C both provide fake pieces, reconstruction will use garbage data

3. **Round N+2 - Corruption Manifests:**
   - When producing NextRound block, `RevealSharedInValues()` is called
   - It attempts to decode secret using fake pieces: [8](#0-7) 
   - Result: `revealedInValue` = Hash(garbage) ≠ OutValue_A
   - This invalid value is stored as miner A's PreviousInValue

**Expected vs Actual Result:**
- **Expected:** Reconstruction should fail or be rejected because Hash(reconstructed) ≠ OutValue_A
- **Actual:** Invalid PreviousInValue is stored without any validation error

**Success Condition:** 
The attack succeeds if `Round.RealTimeMinersInformation[A].PreviousInValue` contains a value where `Hash(PreviousInValue) != OutValue_A`, demonstrating that fake decrypted pieces corrupted the consensus state without detection.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L122-125)
```csharp
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L48-48)
```csharp
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** protobuf/aedpos_contract.proto (L294-296)
```text
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
