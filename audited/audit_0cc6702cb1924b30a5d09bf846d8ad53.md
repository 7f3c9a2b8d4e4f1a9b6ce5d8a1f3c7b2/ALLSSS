### Title
Incorrect Byzantine Fault Tolerance Threshold Calculation Causes Consensus Liveness Degradation

### Summary
The `MinersCountOfConsent` property uses an incorrect mathematical formula that overestimates the number of miners required for Byzantine fault tolerance. [1](#0-0)  The current formula `Count.Mul(2).Div(3).Add(1)` calculates `floor(2n/3) + 1` instead of the correct BFT requirement `2f + 1` where `f = floor((n-1)/3)`, causing the system to require more consensus than mathematically necessary and reducing availability.

### Finding Description

The `MinersCountOfConsent` property is defined as `RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1)` in the Round class. [1](#0-0) 

This property is used in two critical consensus operations:

1. **LIB (Last Irreversible Block) Calculation**: The system checks if sufficient miners have confirmed blocks by comparing the count against `MinersCountOfConsent`. [2](#0-1)  If the count is less than the threshold, LIB is set to 0, preventing block finalization.

2. **Term Change Verification**: The system counts how many miners agree on term transition and compares against `MinersCountOfConsent`. [3](#0-2)  If insufficient miners meet the threshold, term changes are blocked.

**Root Cause:**
The current formula `floor(2n/3) + 1` does not match the Byzantine fault tolerance requirement of `2f + 1` where `f = floor((n-1)/3)`. The correct formula should be `2 * floor((n-1)/3) + 1`, which can be implemented as `Count.Sub(1).Div(3).Mul(2).Add(1)`.

**Mathematical Error Examples:**
- For n=17 miners (AElf's default [4](#0-3) ): Current requires 12, correct is 11 (+1 error)
- For n=21 miners: Current requires 15, correct is 13 (+2 error)
- For n=5 miners: Current requires 4, correct is 3 (+1 error)

The formula is only correct when n ≡ 1 (mod 3), but incorrect for n ≡ 0 (mod 3) by +2, and n ≡ 2 (mod 3) by +1.

### Impact Explanation

**Consensus Availability Degradation:**
With 17 miners where Byzantine fault tolerance allows up to f=5 faulty nodes, the system should remain operational with 11 honest/online miners (2*5+1=11). However, the incorrect formula requires 12 miners, meaning:

- If 6 miners are offline or Byzantine (one more than the theoretical tolerance), the system halts
- Block finalization fails even when BFT safety guarantees are met
- Term transitions cannot occur despite sufficient miner agreement

**Operational Impact:**
- **Block Finality Delay**: Blocks cannot be marked irreversible when they safely should be, delaying transaction finality and cross-chain operations
- **Term Transition Failure**: The consensus system cannot transition terms, potentially causing miners to get stuck in expired rounds
- **Reduced Network Resilience**: The network becomes less resilient to miner downtime than BFT mathematics guarantee

**Severity Justification:**
This is a HIGH severity issue because it affects core consensus operations in production. While it doesn't compromise safety (no double-spending or invalid state transitions), it significantly degrades liveness, which is equally critical for blockchain operation. The error margin increases with miner count (e.g., +2 for 21 miners), compounding the impact as the network grows.

### Likelihood Explanation

**Automatic and Guaranteed Occurrence:**
- No attacker action required; the miscalculation occurs automatically
- Affects all standard AElf configurations (n=17 default, growing to 19, 21, etc.)
- The error is present in every LIB calculation and term change check

**Realistic Scenarios:**
1. **Network Partitions**: With 17 miners and a network partition affecting 6 nodes, the system halts despite meeting BFT requirements (should tolerate 5 Byzantine)
2. **Maintenance Windows**: Planned downtime of 6 miners causes consensus failure when 11 should suffice
3. **Byzantine Nodes**: Exactly 5 Byzantine nodes + 1 offline node causes halt when system should tolerate 5 Byzantine

**Probability Assessment:**
HIGH - This is not a theoretical vulnerability but an active misconfiguration affecting every consensus round. In production networks with 17+ miners, any scenario requiring exactly the BFT minimum will fail due to the overcounting.

### Recommendation

**Code Fix:**
Replace the formula in `Round_ImpliedIrreversibleBlockHeight.cs`:
```csharp
// Current (INCORRECT):
public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);

// Corrected:
public int MinersCountOfConsent => RealTimeMinersInformation.Count.Sub(1).Div(3).Mul(2).Add(1);
```

**Invariant Validation:**
Add a test assertion to verify the formula matches BFT requirements:
- For all n, verify: `MinersCountOfConsent == 2 * floor((n-1)/3) + 1`
- Test edge cases: n=1,2,3,4,5,17,19,21
- Validate that n-f ≥ MinersCountOfConsent where f = floor((n-1)/3)

**Regression Prevention:**
Create comprehensive unit tests:
1. Test that with f Byzantine nodes and 2f+1 honest confirmations, LIB can be calculated
2. Test that with exactly 2f+1 miners agreeing on term change, transition succeeds
3. Test boundary conditions for all miner counts from 1-25

### Proof of Concept

**Initial State:**
- Network with n=17 miners (standard AElf configuration)
- Byzantine fault tolerance: f = floor(16/3) = 5
- Correct threshold: 2f+1 = 11 miners
- Actual threshold (buggy): 12 miners

**Scenario 1: LIB Calculation Failure**
1. Previous round: 11 miners produce blocks with confirmed heights
2. Current round: System calls `LastIrreversibleBlockHeightCalculator`
3. Check at line 26: `impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent`
4. Result: 11 < 12 → TRUE (fails check)
5. LIB set to 0 (line 28) → **Block finalization fails**
6. Expected: 11 ≥ 11 → Should succeed and calculate LIB

**Scenario 2: Term Change Blocking**
1. Network with 17 miners, 6 are temporarily offline
2. 11 miners agree it's time to change terms (sufficient for BFT)
3. System evaluates `NeedToChangeTerm()` at line 223
4. Check: `count >= MinersCountOfConsent` → 11 >= 12 → FALSE
5. Result: **Term change rejected**
6. Expected: 11 ≥ 11 → Should allow term transition

**Success Condition:**
With the corrected formula, both scenarios would succeed with exactly 11 miners, properly implementing Byzantine fault tolerance without unnecessary overcounting.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L26-30)
```csharp
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/AEDPoSContractTestConstants.cs (L13-13)
```csharp
    internal const int SupposedMinersCount = 17;
```
