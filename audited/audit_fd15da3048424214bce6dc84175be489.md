### Title
Missing Signature Correctness Validation in UpdateValue Allows Mining Order Manipulation

### Summary
The `UpdateValue` consensus operation accepts arbitrary signature values without validating that they match the expected calculation of `previousRound.CalculateSignature(previousInValue)`. Since signatures directly determine mining order in subsequent rounds, malicious miners can manipulate their position in the mining schedule to gain unfair advantages in block production frequency.

### Finding Description

The vulnerability exists in the signature validation flow for `UpdateValue` operations: [1](#0-0) 

The signature extracted here is assigned to `UpdateValueInput` without any subsequent verification. According to the protocol design, signatures should be deterministically calculated as: [2](#0-1) 

However, when `ProcessUpdateValue` processes the input, it blindly accepts the provided signature: [3](#0-2) 

The validation provider only checks that signatures are non-empty, not that they're correctly calculated: [4](#0-3) 

No comparison is ever made between the provided signature and what `CalculateSignature` would produce. The `UpdateValueInput.RoundId` field is also never validated against the current round.

**Why Existing Protections Fail:**
- `MiningPermissionValidationProvider` only verifies the miner is authorized, not that their signature is correct
- `UpdateValueValidationProvider` only validates that `hash(previousInValue) == previousOutValue`, which doesn't constrain the signature value
- `TimeSlotValidationProvider` checks timing but not signature correctness
- No validation compares the provided signature against the expected calculation

### Impact Explanation

The signature directly affects consensus-critical parameters through two mechanisms:

1. **Individual mining order calculation** - Each miner's position in the next round is determined by their signature: [5](#0-4) 

2. **Extra block producer selection** - The first miner's signature determines who produces extra blocks: [6](#0-5) 

A malicious miner can choose signature values that maximize their block production opportunities, violating the fairness property of the consensus mechanism. This allows them to:
- Gain disproportionate block rewards
- Increase their influence over transaction ordering
- Potentially coordinate with other malicious miners to dominate mining schedules

The severity is Medium because while it doesn't enable direct fund theft, it undermines consensus integrity and fairness, which are critical invariants.

### Likelihood Explanation

**Attacker Capabilities:** Any authorized miner in the current round can execute this attack by providing arbitrary signature values in their `UpdateValue` calls.

**Attack Complexity:** Low - the miner simply needs to calculate which signature value (as an int64) modulo the miner count gives them their desired position, then provide that signature instead of the correctly calculated one.

**Feasibility Conditions:** 
- Attacker must be an authorized miner (realistic threat model for consensus systems)
- No additional permissions or preconditions required
- Attack is undetectable since there's no validation to flag incorrect signatures

**Detection/Operational Constraints:** The attack is completely silent - there are no validation failures or events that would indicate a miner is using incorrect signatures.

**Probability:** HIGH - any miner can perform this on every block they produce with no risk of detection or penalty.

### Recommendation

**Add signature correctness validation in `UpdateValueValidationProvider`:**

After validating that the signature is non-empty, add verification that it matches the expected calculation:

```csharp
private bool ValidateSignatureCorrectness(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;
    
    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey))
        return true;
    
    var providedSignature = extraData.Round.RealTimeMinersInformation[publicKey].Signature;
    var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
    
    if (previousInValue == null || previousInValue == Hash.Empty)
        return true;
    
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    
    return providedSignature == expectedSignature;
}
```

**Additional validation:** Verify that `UpdateValueInput.RoundId` matches the expected round to prevent stale data usage.

**Test cases to add:**
1. Test that UpdateValue with incorrect signature fails validation
2. Test that UpdateValue with correct signature succeeds
3. Test that signature manipulation attempt is detected and rejected
4. Test that RoundId mismatch is detected

### Proof of Concept

**Initial State:**
- Network has 5 authorized miners
- Current round is round N
- Attacker is miner with pubkey "AttackerMiner"
- Attacker's natural signature would place them at position 3 in round N+1

**Attack Steps:**

1. Attacker calculates that to be at position 1 in next round, they need signature S where `S.ToInt64() % 5 == 0`

2. When producing their block in round N, attacker calls `UpdateValue` with:
   - Correct `OutValue` = hash(their InValue)
   - Correct `PreviousInValue` (passes hash validation)
   - **Manipulated** `Signature` = chosen value S (instead of `previousRound.CalculateSignature(previousInValue)`)

3. The `UpdateValueValidationProvider` validation passes because:
   - Signature is non-empty (line 31-32 check)
   - PreviousInValue hashes correctly to PreviousOutValue (line 48 check)

4. `ProcessUpdateValue` accepts the signature without validation (line 244)

5. When round N+1 is generated, `ApplyNormalConsensusData` uses the manipulated signature to calculate order (line 19-21)

**Expected Result:** Attacker's signature should be `previousRound.CalculateSignature(previousInValue)` placing them at position 3

**Actual Result:** Attacker uses manipulated signature S placing them at position 1, giving them priority in the mining schedule

**Success Condition:** Attacker successfully mines more frequently in round N+1 and subsequent rounds by consistently manipulating their signature to favorable values, with no validation failures or detection.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L38-38)
```csharp
            Signature = minerInRound.Signature,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-244)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L118-122)
```csharp
        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
```
