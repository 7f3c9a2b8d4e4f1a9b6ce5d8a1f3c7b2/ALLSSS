### Title
Arbitrary Contract Address Bypass in Controller Change Validation Allows Governance Circumvention

### Summary
The `ChangeSymbolsToPayTXSizeFeeController()` function and similar controller change functions use `CheckOrganizationExist()` to validate the new controller, but this validation makes a cross-contract call to an unvalidated contract address specified in the input. An attacker can deploy a malicious contract with a `ValidateOrganizationExist` method that always returns true, allowing them to set an arbitrary address as the controller and completely bypass governance requirements for protected operations.

### Finding Description

The vulnerability exists in the controller change functions in `TokenContract_Method_Authorization.cs`. The `ChangeSymbolsToPayTXSizeFeeController()` function performs validation of the new controller authority: [1](#0-0) 

The validation is performed by `CheckOrganizationExist()`, which is implemented as follows: [2](#0-1) 

**Root Cause**: The function makes a cross-contract call to `authorityInfo.ContractAddress` without validating that this address corresponds to one of the known governance contracts (Parliament, Association, or Referendum). It blindly trusts whatever contract address is provided in the `AuthorityInfo` input parameter.

**Why Existing Protections Fail**: 

1. The legitimate governance contracts implement `ValidateOrganizationExist` to check if an organization exists in their state: [3](#0-2) [4](#0-3) 

2. However, an attacker can deploy a malicious contract that implements the same interface but always returns true for any address.

3. The authorization check for protected functions like `SetSymbolsToPayTxSizeFee` only validates that the sender matches the controller's OwnerAddress: [5](#0-4) 

4. Once a controller is set with an EOA address as OwnerAddress (validated through the malicious contract), the attacker can directly call protected functions without any governance approval.

**Affected Functions**: The same vulnerability pattern exists in multiple controller change functions: [6](#0-5) 

### Impact Explanation

**Governance Bypass**: An attacker who successfully exploits this vulnerability gains the ability to call protected functions without any governance oversight. For `SymbolsToPayTxFeeController`, this includes: [7](#0-6) 

**Specific Harms**:
- **Fee Mechanism Manipulation**: Attacker can arbitrarily modify the list of tokens accepted for transaction size fees and their weights, disrupting the economic model
- **Economic Damage**: By setting favorable token weights, attacker can create scenarios where certain tokens are preferred over others, potentially manipulating markets
- **Protocol Integrity**: Complete circumvention of governance for critical protocol parameters undermines trust and security

**Affected Parties**: All network participants who rely on governance-controlled fee mechanisms, particularly users paying transaction fees and token holders affected by economic parameter changes.

**Severity Justification**: HIGH - This allows complete bypass of governance controls for critical economic parameters, enabling unauthorized configuration changes that affect the entire network.

### Likelihood Explanation

**Attacker Capabilities Required**:
1. Deploy a malicious contract (trivial - any user can deploy contracts)
2. Create or influence a governance proposal (requires being a proposer or social engineering)
3. Obtain governance approval for the proposal (requires social engineering or compromised governance members)

**Attack Complexity**: MEDIUM
- Technical execution is straightforward
- The main barrier is obtaining governance approval
- However, the validation check provides false security that may lower governance scrutiny

**Feasibility Conditions**:
- The test suite demonstrates that the check is intended to catch invalid controllers: [8](#0-7) 

- Governance members seeing this validation may incorrectly assume it ensures the controller is legitimate
- A sophisticated attacker could deploy a contract with similar naming/structure to legitimate governance contracts to pass casual inspection

**Detection Constraints**: The malicious contract address would be visible in the proposal parameters, but governance members may not recognize it as non-standard if not carefully reviewed.

**Probability Assessment**: MEDIUM - While requiring governance approval, the false security provided by the validation check makes approval more likely than a proposal with no validation at all.

### Recommendation

**Immediate Fix**: Add validation to ensure the `ContractAddress` in `AuthorityInfo` matches one of the known governance contracts before making the cross-contract call.

**Code-Level Mitigation**:
```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a known governance contract
    var validGovernanceContracts = new List<Address>
    {
        State.ParliamentContract.Value,
        State.AssociationContract.Value,
        State.ReferendumContract.Value
    };
    
    Assert(validGovernanceContracts.Contains(authorityInfo.ContractAddress), 
        "Invalid governance contract address");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Additional Invariant Checks**:
- Verify the contract at `ContractAddress` is actually deployed and is a system contract
- Consider adding a whitelist of approved governance contract addresses in state
- Add events when controllers are changed to improve transparency

**Regression Prevention**:
- Add test cases that attempt to set controllers with arbitrary contract addresses
- Add test cases that attempt to set controllers with EOA addresses as OwnerAddress
- Verify that only legitimate governance contract addresses pass validation

### Proof of Concept

**Initial State**: 
- Default Parliament organization controls `SymbolToPayTxFeeController`
- Attacker has deployed malicious contract at address `MALICIOUS_ADDR`

**Attack Steps**:

1. **Deploy Malicious Contract**:
```csharp
public class MaliciousGovernance {
    public BoolValue ValidateOrganizationExist(Address input) {
        return new BoolValue { Value = true }; // Always returns true!
    }
}
```

2. **Create Governance Proposal**:
```csharp
var maliciousAuthority = new AuthorityInfo {
    ContractAddress = MALICIOUS_ADDR,
    OwnerAddress = ATTACKER_EOA_ADDRESS
};

var proposal = new CreateProposalInput {
    ToAddress = TokenContractAddress,
    ContractMethodName = "ChangeSymbolsToPayTXSizeFeeController",
    Params = maliciousAuthority.ToByteString(),
    OrganizationAddress = defaultParliamentAddress,
    ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
};
```

3. **Obtain Approval and Release**: Governance members approve the proposal (believing the validation check ensures legitimacy)

4. **Validation Bypass**: When proposal executes:
   - `CheckOrganizationExist(maliciousAuthority)` is called
   - Makes call to `MALICIOUS_ADDR.ValidateOrganizationExist(ATTACKER_EOA_ADDRESS)`
   - Malicious contract returns `true`
   - Validation passes, controller is set

5. **Direct Governance Bypass**:
```csharp
// Attacker directly calls protected function from their EOA
var symbolList = new SymbolListToPayTxSizeFee { ... };
TokenContract.SetSymbolsToPayTxSizeFee(symbolList);
// Authorization check passes: Context.Sender == ATTACKER_EOA_ADDRESS == Controller.OwnerAddress
```

**Expected Result**: Transaction should fail with "Invalid governance contract address"

**Actual Result**: Controller is successfully changed to attacker's EOA address, and attacker can call `SetSymbolsToPayTxSizeFee` without any governance approval.

**Success Condition**: Attacker can repeatedly call `SetSymbolsToPayTxSizeFee` with arbitrary parameters directly from their EOA, completely bypassing the governance process that should control this critical parameter.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L45-51)
```csharp
    public override Empty ChangeSymbolsToPayTXSizeFeeController(AuthorityInfo input)
    {
        AssertControllerForSymbolToPayTxSizeFee();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.SymbolToPayTxFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L53-97)
```csharp
    public override Empty ChangeSideChainRentalController(AuthorityInfo input)
    {
        AssertControllerForSideChainRental();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.SideChainRentalController.Value = input;
        return new Empty();
    }

    public override Empty ChangeCrossChainTokenContractRegistrationController(AuthorityInfo input)
    {
        CheckCrossChainTokenContractRegistrationControllerAuthority();
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.CrossChainTokenContractRegistrationController.Value = input;
        return new Empty();
    }

    public override Empty ChangeUserFeeController(AuthorityInfo input)
    {
        AssertUserFeeController();
        Assert(CheckOrganizationExist(input), "Invalid authority input.");
        State.UserFeeController.Value.RootController = input;
        State.UserFeeController.Value.ParliamentController = null;
        State.UserFeeController.Value.ReferendumController = null;
        return new Empty();
    }

    public override Empty ChangeDeveloperController(AuthorityInfo input)
    {
        AssertDeveloperFeeController();
        Assert(CheckOrganizationExist(input), "Invalid authority input.");
        State.DeveloperFeeController.Value.RootController = input;
        State.DeveloperFeeController.Value.ParliamentController = null;
        State.DeveloperFeeController.Value.DeveloperController = null;
        return new Empty();
    }

    public override Empty ChangeTransferBlackListController(AuthorityInfo input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.TransferBlackListController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L399-405)
```csharp
    private void AssertControllerForSymbolToPayTxSizeFee()
    {
        if (State.SymbolToPayTxFeeController.Value == null)
            State.SymbolToPayTxFeeController.Value = GetDefaultSymbolToPayTxFeeController();

        Assert(State.SymbolToPayTxFeeController.Value.OwnerAddress == Context.Sender, "no permission");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L616-625)
```csharp
    public override Empty SetSymbolsToPayTxSizeFee(SymbolListToPayTxSizeFee input)
    {
        AssertControllerForSymbolToPayTxSizeFee();
        if (input == null)
            throw new AssertionException("invalid input");
        var isPrimaryTokenExist = false;
        var symbolList = new List<string>();
        var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty());
        Assert(!string.IsNullOrEmpty(primaryTokenSymbol.Value), "primary token does not exist");
        foreach (var tokenWeightInfo in input.SymbolsToPayTxSizeFee)
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/MultiTokenContractReferenceFeeTest.cs (L71-88)
```csharp
        //invalid new organization
        var defaultParliamentAddress = await GetDefaultParliamentAddressAsync();
        var invalidAuthority = new AuthorityInfo
        {
            OwnerAddress = newAuthority.OwnerAddress,
            ContractAddress = AssociationContractAddress
        };
        var createProposalInput = new CreateProposalInput
        {
            ToAddress = TokenContractAddress,
            Params = invalidAuthority.ToByteString(),
            OrganizationAddress = defaultParliamentAddress,
            ContractMethodName = nameof(TokenContractImplContainer.TokenContractImplStub
                .ChangeSymbolsToPayTXSizeFeeController),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
        };
        var ret = await MainChainTesterCreatApproveAndReleaseProposalForParliamentAsync(createProposalInput);
        ret.Error.ShouldContain("new controller does not exist");
```
