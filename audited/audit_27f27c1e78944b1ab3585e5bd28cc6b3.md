### Title
Integer Overflow in Miner Count Auto-Increase Calculation Leading to Consensus Failure

### Summary
The `GetAutoIncreasedMinersCount()` function performs an unsafe cast from `long` to `int` without overflow protection, which can result in integer overflow when the blockchain runs for extended periods (34+ years) with small `MinerIncreaseInterval` values. This vulnerability can cause negative miner counts to propagate through the consensus system, leading to consensus failure or division-by-zero errors if the interval is set to zero.

### Finding Description

The vulnerability exists in two locations where identical unsafe type casting occurs:

**Location 1**: [1](#0-0) 

**Location 2**: [2](#0-1) 

**Root Cause**: The calculation `(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds.Div(State.MinerIncreaseInterval.Value).Mul(2)` produces a `long` value (since all SafeMath operations on `long` return `long`), which is then explicitly cast to `int` without overflow checking. [3](#0-2) 

The `MinerIncreaseInterval` can be reduced through governance without any minimum bound validation: [4](#0-3) 

The validation only checks that the new value is less than or equal to the current value (`input.Value <= State.MinerIncreaseInterval.Value`), with no minimum bound or positive value check. Similarly, initialization lacks validation: [5](#0-4) 

**Why Existing Protections Fail**:
1. No minimum value validation in `SetMinerIncreaseInterval` or `InitialAElfConsensusContract`
2. Explicit cast `(int)` performs unchecked conversion (wraps on overflow)
3. Default interval of 31,536,000 seconds provides false sense of security
4. SafeMath's `Add` uses checked arithmetic but occurs AFTER the unsafe cast

**Overflow Calculation**:
- With `MinerIncreaseInterval = 1` second and blockchain running 34.08 years:
  - Time elapsed: 1,073,741,824 seconds
  - Calculation: (1,073,741,824 / 1) * 2 = 2,147,483,648
  - This exceeds `Int32.MaxValue` (2,147,483,647)
  - Cast wraps to negative: approximately -2,147,483,648
  - Result: `17 + (-2,147,483,648)` = negative miner count

**Execution Path**:
1. `GetAutoIncreasedMinersCount()` returns negative value
2. `GetMaximumMinersCount()` uses `Math.Min()` which returns the negative value
3. `SetMaximumMinersCount()` calls `UpdateMinersCount` with negative value
4. Election contract stores negative miner count without validation: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Violation**: Negative or zero miner counts break the fundamental consensus invariant that requires a positive number of block producers. This corrupts the consensus state across multiple contracts:
- AEDPoS consensus contract
- Election contract's `MinersCount` state
- Round generation and time-slot allocation logic

**Specific Harms**:
1. **Division by Zero DoS**: If `MinerIncreaseInterval` is set to 0, all calls to `GetAutoIncreasedMinersCount()` or `GetMinersCount()` fail with `DivideByZeroException`, completely breaking consensus operations.

2. **Negative Miner Count Corruption**: Integer overflow produces negative miner counts that propagate through:
   - Consensus round calculations expecting positive values
   - Election contract state corruption
   - Potential arithmetic errors in downstream logic using miner count

3. **Protocol Liveness Failure**: Consensus cannot function with invalid miner counts, halting block production and freezing the blockchain.

**Affected Parties**: All network participants - validators cannot produce blocks, users cannot transact, and the entire blockchain becomes inoperable.

**Severity Justification**: HIGH - Complete consensus failure constitutes a critical protocol-level vulnerability affecting all operations.

### Likelihood Explanation

**Attacker Capabilities Required**:
- Parliament/governance authorization to call `SetMinerIncreaseInterval`
- No malicious intent required - legitimate governance actions over time can trigger overflow

**Attack Complexity**: 
- **Scenario 1 (Division by Zero)**: LOW complexity
  - Single governance proposal to set `MinerIncreaseInterval = 0`
  - Immediate consensus failure on next calculation
  
- **Scenario 2 (Integer Overflow)**: MEDIUM complexity
  - Requires gradual reduction of `MinerIncreaseInterval` through multiple governance proposals
  - Natural occurrence after 34+ years with interval = 1 second
  - Could occur sooner with concurrent reductions (e.g., interval = 0.5 would trigger at 17 years, but minimum is 1)

**Feasibility Conditions**:
- Governance must control Parliament contract (normal operational state)
- For overflow: Blockchain must run long enough OR interval must be reduced aggressively
- Default interval (31,536,000s) provides protection initially but can be circumvented

**Detection Constraints**: 
- Overflow is silent until cast completes
- No monitoring for suspicious `MinerIncreaseInterval` values
- No alerts when calculated value approaches `Int32.MaxValue`

**Probability Reasoning**: 
- **Near-term (< 10 years)**: LOW - Requires deliberate malicious governance or extreme misconfiguration
- **Long-term (30+ years)**: MEDIUM - Natural occurrence if interval reduced for legitimate reasons
- **Overall**: MEDIUM - Governance attack surface is real, and long-running chains are vulnerable

### Recommendation

**Immediate Mitigations**:

1. **Add Minimum Bound Check in `SetMinerIncreaseInterval`**:
```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value >= 86400, "Miner increase interval must be at least 1 day."); // Prevent extreme values
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

2. **Add Overflow Protection in Calculations**:
```csharp
private int GetAutoIncreasedMinersCount()
{
    if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;
    
    var secondsElapsed = (Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds;
    var increments = secondsElapsed.Div(State.MinerIncreaseInterval.Value);
    
    // Check for overflow before multiplication and casting
    if (increments > Int32.MaxValue.Div(2))
    {
        return Int32.MaxValue; // Cap at maximum safe value
    }
    
    var additionalMiners = (int)increments.Mul(2);
    
    // Check for overflow before addition
    if (additionalMiners > Int32.MaxValue - AEDPoSContractConstants.SupposedMinersCount)
    {
        return Int32.MaxValue;
    }
    
    return AEDPoSContractConstants.SupposedMinersCount.Add(additionalMiners);
}
```

3. **Add Validation in `UpdateMinersCount`**:
```csharp
public override Empty UpdateMinersCount(UpdateMinersCountInput input)
{
    Assert(
        Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
        "Only consensus contract can update miners count.");
    Assert(input.MinersCount > 0, "Miners count must be positive.");
    State.MinersCount.Value = input.MinersCount;
    SyncSubsidyInfoAfterReduceMiner();
    return new Empty();
}
```

4. **Add Initialization Validation**:
```csharp
public override Empty InitialAElfConsensusContract(InitialAElfConsensusContractInput input)
{
    Assert(State.CurrentRoundNumber.Value == 0 && !State.Initialized.Value, "Already initialized.");
    Assert(input.MinerIncreaseInterval > 0, "Miner increase interval must be positive.");
    Assert(input.MinerIncreaseInterval >= 86400, "Miner increase interval must be at least 1 day.");
    // ... rest of initialization
}
```

**Test Cases to Prevent Regression**:
- Test `SetMinerIncreaseInterval` with zero value (should fail)
- Test `SetMinerIncreaseInterval` with negative value (should fail)
- Test `SetMinerIncreaseInterval` with value below minimum threshold (should fail)
- Test overflow scenario with mock blockchain time > 34 years and interval = 1
- Test that `GetAutoIncreasedMinersCount` never returns negative values

### Proof of Concept

**Required Initial State**:
- AEDPoS consensus contract initialized with default `MinerIncreaseInterval = 31536000` (1 year)
- Parliament governance contract functional and controlled by attacker/tester

**Transaction Steps**:

**Scenario 1 - Division by Zero (Immediate)**:
1. Submit Parliament proposal to call `SetMinerIncreaseInterval(0)`
2. Reach consensus and execute proposal
3. Call any method that invokes `GetAutoIncreasedMinersCount()` or `GetMinersCount()`
4. **Expected Result**: `DivideByZeroException` thrown, consensus operations fail

**Scenario 2 - Integer Overflow (Long-term)**:
1. Submit Parliament proposal to call `SetMinerIncreaseInterval(1)` (1 second)
2. Reach consensus and execute proposal
3. Fast-forward blockchain time by 34.08 years (1,073,741,824 seconds)
4. Call `GetMaximumMinersCount()` or trigger round generation
5. **Expected Result**: 
   - Calculation: (1,073,741,824 / 1) * 2 = 2,147,483,648 (overflow)
   - Cast wraps to negative value
   - Negative miner count stored in Election contract
   - Consensus operations fail or behave unpredictably

**Success Condition**: 
- Scenario 1: Transaction fails with division by zero error
- Scenario 2: `GetMaximumMinersCount()` returns negative value OR subsequent consensus operations fail with arithmetic errors

**Notes**:
This vulnerability has two critical attack vectors with different timelines. The division-by-zero scenario is immediately exploitable with governance control, while the overflow scenario is a time-bomb that naturally triggers after sufficient blockchain operation time with reduced intervals. Both scenarios violate the consensus integrity invariant requiring positive miner counts.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L92-94)
```csharp
        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L388-390)
```csharp
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L79-106)
```csharp
    public static long Mul(this long a, long b)
    {
        checked
        {
            return a * b;
        }
    }

    public static long Div(this long a, long b)
    {
        return a / b;
    }

    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }

    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L31-31)
```csharp
        State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L157-157)
```csharp
        State.MinersCount.Value = input.MinersCount;
```
