### Title
LibInformationValidationProvider Bypass Through Pre-Validation State Modification

### Summary
The `LibInformationValidationProvider` validation is completely bypassed due to `RecoverFromUpdateValue` modifying the `baseRound` object before validation occurs. This allows malicious miners to report artificially low `ImpliedIrreversibleBlockHeight` values that should fail monotonicity checks, potentially delaying Last Irreversible Block (LIB) advancement and affecting consensus finality guarantees.

### Finding Description

**Root Cause:**

In `ValidateBeforeExecution`, the `baseRound` object is modified by `RecoverFromUpdateValue` before being passed to validation providers. [1](#0-0) 

The `RecoverFromUpdateValue` method modifies `baseRound` in-place, specifically setting: [2](#0-1) 

The modified `baseRound` is then used to create the validation context: [3](#0-2) 

**Why Protection Fails:**

The `LibInformationValidationProvider` attempts to validate that the provided `ImpliedIrreversibleBlockHeight` is not lower than what's in `baseRound`: [4](#0-3) 

However, this check always passes because `baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` was already set equal to `providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` by `RecoverFromUpdateValue`. The comparison becomes `X > X`, which is always false, so the validation never rejects.

**Execution Path:**

1. `ValidateBeforeExecution` fetches `baseRound` from state
2. For `UpdateValue` behavior, calls `baseRound.RecoverFromUpdateValue()` which modifies it in-place
3. Creates validation context with the modified `baseRound`
4. Adds `LibInformationValidationProvider` to validators for `UpdateValue` behavior
5. All validators execute sequentially via `HeaderInformationValidationService`
6. `LibInformationValidationProvider` receives the pre-modified `baseRound` where values already match provided values
7. Validation passes inappropriately
8. The low value gets persisted to state during `ProcessUpdateValue` [5](#0-4) 

### Impact Explanation

**Consensus Finality Degradation:**

A malicious miner can report `ImpliedIrreversibleBlockHeight` values lower than previously recorded. These values are used in LIB calculation: [6](#0-5) 

The LIB calculator uses the previous round's implied heights from miners who mined in the current round: [7](#0-6) 

**Specific Harms:**

1. **Delayed Finality:** If one or more miners report artificially low values, they drag down the median calculation at position `(count-1)/3`, preventing proper LIB advancement
2. **Cross-Chain Impact:** LIB height is used for cross-chain transaction verification and finality guarantees
3. **Time-Sensitive Operations:** Any operations depending on block finalization (e.g., irreversible state transitions) are delayed
4. **Consensus Integrity:** Violates the monotonicity invariant that `ImpliedIrreversibleBlockHeight` should only increase

**Severity:** Medium-High - While no direct fund theft occurs, consensus finality is a critical security property. The bypass completely disables an important monotonicity check.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a consensus miner (privileged role but within scope)
- No additional permissions or exploits required
- Can execute during normal block production via `UpdateValue` behavior

**Attack Complexity:**
- Trivial: Simply provide a lower `ImpliedIrreversibleBlockHeight` value when producing blocks
- The expected value should be `Context.CurrentHeight`: [8](#0-7) 

- Attacker provides a value < their previous reported height
- Validation bypass is automatic due to the bug

**Feasibility:**
- Reachable: Through normal `UpdateValue` consensus transaction flow
- No race conditions or timing requirements
- Deterministic bypass
- Low economic cost (normal mining operations)

**Detection:**
- Requires monitoring historical `ImpliedIrreversibleBlockHeight` values per miner
- Not immediately detectable without comparing across rounds
- Could appear as "slow" or "buggy" miner rather than malicious

**Probability:** High likelihood of exploitation if a miner becomes malicious, as the attack is trivial to execute and provides strategic advantages in controlling finality.

### Recommendation

**Fix 1: Validate BEFORE Modification**

Store the original `baseRound` before calling `RecoverFromUpdateValue`:

```
var originalBaseRound = baseRound.Clone(); // or deep copy
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
    
var validationContext = new ConsensusValidationContext
{
    BaseRound = originalBaseRound, // Use unmodified version
    // ... other fields
};
```

Pass the unmodified `originalBaseRound` to validation context so `LibInformationValidationProvider` can properly detect decreases.

**Fix 2: Validate Monotonicity Earlier**

Add explicit monotonicity check before `RecoverFromUpdateValue`:

```
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
{
    var providedHeight = extraData.Round.RealTimeMinersInformation[extraData.SenderPubkey.ToHex()].ImpliedIrreversibleBlockHeight;
    var currentHeight = baseRound.RealTimeMinersInformation[extraData.SenderPubkey.ToHex()].ImpliedIrreversibleBlockHeight;
    
    if (providedHeight != 0 && currentHeight > providedHeight)
        return new ValidationResult { Success = false, Message = "Implied lib height decreased" };
        
    baseRound.RecoverFromUpdateValue(...);
}
```

**Invariant Check to Add:**

For each miner in each round: `ImpliedIrreversibleBlockHeight(round_N+1) >= ImpliedIrreversibleBlockHeight(round_N)`

**Test Cases:**

1. Test that providing a lower `ImpliedIrreversibleBlockHeight` than previous round is rejected
2. Test that validation detects decrease even when `RecoverFromUpdateValue` is called
3. Test that LIB calculation uses only valid (non-decreasing) implied heights
4. Integration test simulating malicious miner attempting to delay LIB

### Proof of Concept

**Initial State:**
- Miner M has `ImpliedIrreversibleBlockHeight = 10000` recorded in round N (in state)
- Round N+1 begins, miner M should report height â‰¥ 10000

**Attack Steps:**

1. Miner M produces block at height 10100 in round N+1
2. Instead of reporting `ImpliedIrreversibleBlockHeight = 10100`, miner M provides `ImpliedIrreversibleBlockHeight = 9000` in `UpdateValue` consensus data
3. `ValidateBeforeExecution` is called:
   - Fetches `baseRound` with M's height = 10000
   - Calls `baseRound.RecoverFromUpdateValue()` which sets M's height to 9000 in `baseRound`
   - Creates validation context with modified `baseRound` (now showing 9000)
4. `LibInformationValidationProvider.ValidateHeaderInformation()` executes:
   - Checks if `baseRound[M].ImpliedIrreversibleBlockHeight (9000) > providedRound[M].ImpliedIrreversibleBlockHeight (9000)`
   - Check is `9000 > 9000 = false`, so validation PASSES (incorrectly)
5. Block is accepted, `ProcessUpdateValue` persists the value 9000 to state
6. In round N+2, LIB calculation uses M's value of 9000 (instead of proper value)

**Expected Result:** Validation should reject miner M's block for providing decreasing `ImpliedIrreversibleBlockHeight`

**Actual Result:** Validation passes, allowing consensus finality degradation

**Success Condition:** After attack, miner M's `ImpliedIrreversibleBlockHeight` in state is 9000 (lower than previous 10000), and subsequent LIB calculations use this artificially low value.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L19-19)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```
