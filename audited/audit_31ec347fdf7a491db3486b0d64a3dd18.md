### Title
Contract Address Injection in Method Fee Controller Validation Allows Permanent Governance Bypass

### Summary
The `CheckOrganizationExist` function in TokenHolder (and other ACS1 contracts) fails to validate that the `AuthorityInfo.ContractAddress` parameter points to a legitimate system governance contract. An attacker can pass a malicious contract address that always returns `true` for organization validation, allowing the `MethodFeeController` to be set to a non-existent organization and permanently locking the contract into an ungovernable state.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist` helper function used by `ChangeMethodFeeController`: [1](#0-0) 

This function accepts an `AuthorityInfo` parameter containing two user-controlled fields: `ContractAddress` and `OwnerAddress` as defined in: [2](#0-1) 

The function blindly calls the contract at `authorityInfo.ContractAddress` without validating it's a legitimate system governance contract (Parliament, Association, or Referendum). The `AuthorityInfo` is passed as input to `ChangeMethodFeeController`: [3](#0-2) 

**Root Cause**: No validation that `ContractAddress` is a whitelisted system contract. While AElf provides `Context.GetSystemContractNameToAddressMapping()` to check system contracts (as used in other contexts): [4](#0-3) 

This validation is completely absent in `CheckOrganizationExist`. The same vulnerability pattern exists across all ACS1 implementations: [5](#0-4) [6](#0-5) 

### Impact Explanation

**Severity: HIGH**

1. **Permanent Loss of Governance**: Once `MethodFeeController` is set to a fake organization that doesn't exist in any legitimate governance contract, it cannot be changed back. The fake organization cannot execute proposals to restore control.

2. **Denial of Service**: All method fee management becomes permanently frozen. No legitimate organization can update fees to respond to economic conditions or security needs.

3. **Violation of System Invariants**: The governance model assumes `AuthorityInfo.ContractAddress` always points to a legitimate governance contract (Parliament/Association/Referendum). This assumption is violated, breaking cross-contract governance integrity.

4. **Systemic Risk**: This pattern affects ALL system contracts implementing ACS1 (Parliament, Association, Referendum, MultiToken, TokenHolder, Treasury, Profit, Economic, Election, Consensus, CrossChain, TokenConverter, Vote, Configuration). A single malicious proposal can lock multiple critical contracts.

### Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attack Path via Governance Proposal**:
1. Attacker deploys malicious contract implementing `ValidateOrganizationExist` method that always returns `BoolValue { Value = true }`
2. Creates governance proposal (Parliament/Association/Referendum) to call `ChangeMethodFeeController` with:
   - `ContractAddress` = malicious contract address  
   - `OwnerAddress` = arbitrary address
3. Proposal gets approved through legitimate governance votes
4. When proposal executes via virtual inline call: [7](#0-6) 

5. `CheckOrganizationExist` calls malicious contract, receives `true`
6. `MethodFeeController` permanently set to fake organization

**Feasibility Conditions**:
- Requires governance proposal approval (legitimate process)
- BUT: Could occur through insufficient proposal review/testing
- OR: During governance compromise window
- Economic cost: Just proposal creation and contract deployment fees

**Detection Difficulty**: Malicious `AuthorityInfo` in proposal parameters may not be caught during review without explicit contract address whitelisting checks.

### Recommendation

**Primary Fix**: Add contract address whitelist validation in `CheckOrganizationExist`:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a legitimate system governance contract
    var systemContracts = Context.GetSystemContractNameToAddressMapping();
    var validGovernanceContracts = new[] {
        Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName)
    };
    
    Assert(validGovernanceContracts.Contains(authorityInfo.ContractAddress), 
        "Invalid contract address: must be Parliament, Association, or Referendum contract.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Apply to all ACS1 implementations**: Parliament, Association, Referendum, MultiToken, TokenHolder, Treasury, Profit, Economic, Election, Consensus, CrossChain, TokenConverter, Vote, Configuration.

**Additional Test Cases**:
1. Test `ChangeMethodFeeController` with non-system contract address (should fail)
2. Test with invalid system contract (e.g., TokenContract) (should fail)
3. Test with each valid governance contract (should succeed if organization exists)

### Proof of Concept

**Initial State**:
- TokenHolder contract deployed with default Parliament MethodFeeController

**Attack Sequence**:
1. Deploy malicious contract:
```csharp
public class MaliciousGovernance {
    public BoolValue ValidateOrganizationExist(Address input) {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```

2. Create Parliament proposal targeting TokenHolder.ChangeMethodFeeController:
```csharp
var proposalInput = new CreateProposalInput {
    OrganizationAddress = parliamentDefaultOrg,
    ToAddress = tokenHolderContract,
    ContractMethodName = "ChangeMethodFeeController",
    Params = new AuthorityInfo {
        ContractAddress = maliciousContractAddress, // Attacker's contract
        OwnerAddress = attackerAddress  // Arbitrary address
    }.ToByteString()
};
```

3. Get proposal approved by Parliament members

4. Execute proposal via `Release`

**Expected Result**: Transaction fails with "Invalid contract address" error

**Actual Result**: Transaction succeeds, `MethodFeeController` set to fake organization, contract becomes permanently ungovernable

**Success Condition**: `GetMethodFeeController()` returns `AuthorityInfo` pointing to malicious contract, and no legitimate organization can change it back.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** protobuf/authority_info.proto (L5-10)
```text
message AuthorityInfo {
    // The contract address of the controller.
    aelf.Address contract_address = 1;
    // The address of the owner of the contract.
    aelf.Address owner_address = 2;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L196-203)
```csharp
    private void AssertSystemContractOrLockWhiteListAddress(string symbol)
    {
        var symbolState = State.LockWhiteLists[symbol];
        var isInWhiteList = symbolState != null && symbolState[Context.Sender];
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Values;
        var isSystemContractAddress = systemContractAddresses.Contains(Context.Sender);
        Assert(isInWhiteList || isSystemContractAddress, "No Permission.");
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L56-60)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L70-74)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```
