### Title
Missing Null Check for Current Round in GetConsensusBlockExtraData Causes Consensus DoS

### Summary
The `GetConsensusBlockExtraData` method fails to validate the return value of `TryToGetCurrentRoundInformation`, allowing it to proceed with a null `currentRound` object. This causes a NullReferenceException when accessing `currentRound.RealTimeMinersInformation`, resulting in denial-of-service of consensus block production functionality.

### Finding Description

The vulnerability exists in the consensus block extra data generation flow: [1](#0-0) 

At this location, `TryToGetCurrentRoundInformation(out var currentRound)` is called but its boolean return value is ignored. When the method returns false (indicating the round doesn't exist or is empty), `currentRound` is set to null: [2](#0-1) 

The code then proceeds to call `GetConsensusExtraDataToPublishOutValue` with the null `currentRound`: [3](#0-2) 

This immediately throws a NullReferenceException when trying to access `currentRound.RealTimeMinersInformation[pubkey]`.

**Important clarification**: The question asks if "RealTimeMinersInformation is null", but this is technically incorrect. In protobuf3, map fields like `RealTimeMinersInformation` are always initialized to empty dictionaries, never null. The actual issue is that the entire `Round` object (`currentRound`) is null, which causes the NullReferenceException before any property access occurs.

**Inconsistent defensive programming**: Other methods in the same contract properly check the return value: [4](#0-3) [5](#0-4) 

### Impact Explanation

**Denial-of-Service of Consensus Mechanism**: If triggered, the NullReferenceException would crash the consensus extra data generation process, preventing block production. This affects all miners attempting to produce blocks during the failure window.

**Affected functionality**: The vulnerability is reachable through the public ACS4 interface method `GetConsensusExtraData`: [6](#0-5) 

And also through `GenerateConsensusTransactions`: [7](#0-6) 

**Severity**: High impact (consensus halt) but low likelihood (requires uninitialized consensus state).

### Likelihood Explanation

**Low likelihood in normal operation**: The consensus is typically initialized via `InitialAElfConsensusContract` and `FirstRound` before any blocks are produced, ensuring the current round exists in state.

**Potential trigger scenarios**:
1. **State corruption**: Blockchain state database corruption causing round information loss
2. **Initialization race conditions**: Edge case during very early blockchain bootstrap if ACS4 methods are called before consensus initialization completes
3. **Manual state manipulation**: Testing/development scenarios where state is manually modified

**Attacker requirements**: An attacker cannot directly force this condition as it requires the blockchain's internal state to be corrupted or uninitialized. However, the vulnerability represents a fragility in the system's defensive programming.

**Inconsistency is the real issue**: The fact that other methods properly validate while this one doesn't indicates a code quality gap that should be addressed regardless of exploitation likelihood.

### Recommendation

**Immediate fix**: Add null check following the same pattern as other methods:

```csharp
// In GetConsensusBlockExtraData method, replace line 20-21 with:
if (!TryToGetCurrentRoundInformation(out var currentRound))
{
    // Return empty or error result instead of proceeding
    return new BytesValue(); // or appropriate error handling
}
```

**Additional defensive measures**:
1. Add similar null checks in all consensus data generation paths
2. Ensure consensus initialization is completed and verified before allowing ACS4 method calls
3. Add state consistency checks during blockchain startup
4. Include test cases that verify graceful handling of missing round information

**Test cases to add**:
- Call `GetConsensusExtraData` when `State.CurrentRoundNumber` is 0
- Call `GetConsensusExtraData` when round exists in number but not in state storage
- Verify all ACS4 methods handle missing round information consistently

### Proof of Concept

**Precondition**: Blockchain state where current round number exists but corresponding round data doesn't exist in `State.Rounds[roundNumber]`, OR `TryToGetRoundNumber` returns false (round number is 0).

**Exploitation steps**:
1. Achieve state where `TryToGetCurrentRoundInformation` returns false:
   - Option A: Corrupt state by removing round data while keeping round number
   - Option B: Call during early initialization before `FirstRound` is executed
   
2. Trigger the vulnerable code path:
   ```
   Call: GetConsensusExtraData(trigger_information_bytes)
   ```

3. Code execution flow:
   - Line 20: `TryToGetCurrentRoundInformation(out var currentRound)` returns false, `currentRound = null`
   - Line 29-30: Proceeds to call `GetConsensusExtraDataToPublishOutValue(currentRound, pubkey, triggerInformation)`
   - Line 58: Attempts `currentRound.RealTimeMinersInformation[pubkey]`
   - **Result**: NullReferenceException thrown

**Expected result**: Method should return gracefully or return an error result

**Actual result**: Unhandled NullReferenceException crashes the consensus block production process

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L20-20)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L55-63)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataToPublishOutValue(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L23-24)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L72-72)
```csharp
        consensusInformation.MergeFrom(GetConsensusBlockExtraData(input, true).Value);
```
