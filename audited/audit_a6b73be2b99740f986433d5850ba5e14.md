### Title
Solitary Miner Detection Logic Error Causes False Positive and Potential Chain Halt

### Summary
The `SolitaryMinerDetection()` function contains a logic error at line 75 where it checks if `GetMinedMiners()` returns an empty list (count == 0) and treats this as evidence of solitary mining. At the start of every new round, all miners have `SupposedOrderOfNextRound = 0` by default, causing `GetMinedMiners()` to return empty even when multiple miners exist. If a miner was the only one successfully mining for the previous 2 rounds due to network issues, they will be blocked from mining at the start of the new round, potentially causing a complete chain halt if the network partition persists.

### Finding Description

The vulnerability exists in the `SolitaryMinerDetection()` function [1](#0-0) 

The root cause is at line 75 where `isAlone` is set to true when `minedMinersOfCurrentRound.Count == 0` [2](#0-1) 

The `GetMinedMiners()` method returns miners where `SupposedOrderOfNextRound != 0` [3](#0-2) 

When a new round is created via `GenerateNextRoundInformation()`, new `MinerInRound` objects are instantiated without explicitly setting `SupposedOrderOfNextRound` [4](#0-3) 

Since `SupposedOrderOfNextRound` is defined as `int32` in the protobuf definition, it defaults to 0 [5](#0-4) 

The field is only set when a miner produces a block through `ProcessUpdateValue()` [6](#0-5) 

The detection is called from `GetConsensusCommand()` before determining consensus behavior [7](#0-6) 

**Why existing protections fail:**
The logic error treats "no one has mined yet in current round" (count == 0) identically to "only this miner is mining" (solitary mining). At the start of any new round, before any miner produces a block, `GetMinedMiners()` will always return empty. The subsequent checks at lines 78-83 and 86-92 validate that only this specific miner mined in the previous 2 rounds, but this doesn't confirm the miner is currently mining alone—it only confirms past solitary behavior during a period when a network partition may have existed.

### Impact Explanation

**Harm:** Complete consensus halt (DoS) preventing any block production.

**Scenario:** 
- During rounds N-2 and N-1, network partition or infrastructure issues cause only MinerA to successfully produce blocks
- Round N begins and `GenerateNextRoundInformation()` creates a new round with all `SupposedOrderOfNextRound` values at 0
- MinerA (the only miner that has been operational) attempts to produce the first block in round N
- `SolitaryMinerDetection()` returns true, blocking MinerA with `InvalidConsensusCommand`
- If network issues persist and other miners remain offline/partitioned, no miner can produce blocks
- Chain halts completely until manual intervention or network recovery

**Who is affected:** The entire blockchain network—all users, dApps, and validators lose access to a functioning chain.

**Severity justification:** HIGH - This is an operational DoS vulnerability affecting consensus integrity. While it requires specific preconditions (network partition), such conditions are realistic in distributed systems and the impact is catastrophic (complete chain halt).

### Likelihood Explanation

**Attacker capabilities:** No malicious attacker required—this triggers through natural network conditions.

**Preconditions:**
- Multi-miner network with >2 miners (checked at line 70) [8](#0-7) 
- After round 3 (checked at line 70)
- Network partition or miner downtime affecting all but one miner for 2 consecutive rounds
- The working miner continues to be the only operational miner into the next round

**Execution practicality:** The vulnerability triggers automatically through the normal consensus flow. When a miner requests a consensus command via the public `GetConsensusCommand()` method [9](#0-8) , the solitary detection runs before any block is produced in the new round.

**Feasibility conditions:** Network partitions, infrastructure failures, and miner downtime are common in distributed blockchain systems. The probability is MEDIUM—not frequent but realistic enough to warrant concern.

### Recommendation

**Code-level mitigation:**
Remove the flawed current round check at lines 74-75. The function should only examine the previous 2 rounds to determine if a miner was mining alone, consistent with the function's documentation comment "If current miner mined blocks only himself for 2 rounds".

Modify `SolitaryMinerDetection()` to:
```csharp
private bool SolitaryMinerDetection(Round currentRound, string pubkey)
{
    var isAlone = false;
    // Skip this detection until 4th round.
    if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
    {
        // Not single node.
        
        // Remove the current round check entirely - start directly with previous round
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            var minedMiners = previousRound.GetMinedMiners();
            isAlone = minedMiners.Count == 1 &&
                      minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            
            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners2 = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners2.Count == 1 &&
                          minedMiners2.Select(m => m.Pubkey).Contains(pubkey);
            }
        }
    }
    return isAlone;
}
```

**Invariant checks:**
- Solitary detection should only evaluate completed rounds, not the current round in progress
- A miner should only be blocked if they demonstrably mined alone in at least 2 consecutive COMPLETED rounds

**Test cases:**
1. Test that at round start (before any miner produces a block), no miner is blocked by solitary detection
2. Test that a miner who mined alone for 2 rounds can still mine if other miners were simply delayed but are now operational
3. Test that legitimate solitary mining (only one miner producing blocks while others exist) is still detected after blocks are produced

### Proof of Concept

**Initial State:**
- Network with 3 miners: MinerA, MinerB, MinerC
- Round 3: Network partition causes only MinerA to successfully mine
- Round 4: Network partition continues, only MinerA mines
- Round 5 starts via `NextRound()` transaction from MinerA

**Exploit Steps:**
1. Round 5 begins—`GenerateNextRoundInformation()` creates new round with all `SupposedOrderOfNextRound = 0`
2. MinerA attempts to mine first block: calls `GetConsensusCommand(minerA_pubkey)`
3. `SolitaryMinerDetection(round5, minerA_pubkey)` executes:
   - Line 74: `currentRound.GetMinedMiners()` returns empty list
   - Line 75: `isAlone = true` (count == 0)
   - Lines 78-83: Previous round check finds only MinerA mined → `isAlone` remains true
   - Lines 86-92: Round 3 check finds only MinerA mined → `isAlone` remains true
   - Returns true
4. Line 24: Returns `InvalidConsensusCommand`, blocking MinerA
5. Network partition persists—MinerB and MinerC still offline
6. No miner can produce blocks in round 5

**Expected Result:** MinerA should be allowed to mine at the start of round 5 since no evidence exists that they will mine alone in THIS round.

**Actual Result:** MinerA is blocked, causing complete chain halt.

**Success Condition:** Chain produces no blocks in round 5 despite MinerA being operational and attempting to mine.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L23-24)
```csharp
        if (SolitaryMinerDetection(currentRound, pubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L66-96)
```csharp
    private bool SolitaryMinerDetection(Round currentRound, string pubkey)
    {
        var isAlone = false;
        // Skip this detection until 4th round.
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
        {
            // Not single node.

            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;

            // If only this node mined during previous round, stop mining.
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }

            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
        }

        return isAlone;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** protobuf/aedpos_contract.proto (L287-288)
```text
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-18)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
```
