### Title
Unbounded Array Size in GetVotingRecords Causes Method Call Limit Exhaustion

### Summary
The `GetVotingRecords` method in the Vote contract lacks input validation on the `input.Ids` array size, allowing unbounded state reads that can exhaust the AElf execution call threshold of 15,000 method calls. This causes the method to fail when processing approximately 3,000-5,000 vote IDs, creating a DoS condition for querying voting records in the Election contract.

### Finding Description

The `GetVotingRecords` method performs no validation on the size of the input array: [1](#0-0) 

The method iterates through all provided IDs using LINQ `Select`, performing a state read for each ID via `State.VotingRecords[id]`. Each state read involves multiple method calls including property access, dictionary lookup, and deserialization operations.

AElf enforces an execution call threshold to prevent infinite loops and excessive computation: [2](#0-1) [3](#0-2) 

When the Election contract calls `GetVotingRecords` inline with accumulated vote IDs, it is subject to this limit: [4](#0-3) [5](#0-4) [6](#0-5) 

The Election contract accumulates vote IDs without bounds as users create multiple votes: [7](#0-6) 

### Impact Explanation

**Maximum Array Size:** With each state read consuming approximately 3-5 method calls (property access, state reader invocation, deserialization), the practical maximum is:
- Conservative estimate: 15,000 ÷ 5 = **3,000 IDs**
- Optimistic estimate: 15,000 ÷ 3 = **5,000 IDs**

**Operational Impact:**
- Users or candidates with more than ~3,000 voting records cannot query their complete voting history via `GetElectorVoteWithRecords`, `GetElectorVoteWithAllRecords`, or `GetCandidateVoteWithRecords`
- The Election contract's view methods fail when called with large voting record sets
- External applications (explorers, dApps) cannot retrieve complete voting data for high-activity electors or candidates
- This creates a **denial-of-service condition for query functionality** in the Election contract

Core voting operations (Vote, Withdraw) remain unaffected, but observability and transparency are compromised for active participants.

### Likelihood Explanation

**Attack Vector:** An attacker can deliberately accumulate thousands of voting records by:
1. Creating many small votes with minimum amounts
2. Using short lock periods to enable rapid vote cycling
3. Voting for themselves as a candidate or splitting votes across multiple voting items

**Preconditions:**
- Attacker needs sufficient tokens to create multiple votes (cost scales linearly with number of votes)
- Each vote incurs transaction fees
- Economic cost: (minimum_vote_amount × number_of_votes) + gas fees

**Feasibility:** High - The system allows unrestricted vote creation, and there are no limits on the number of votes per user. The Vote contract has explicit validation for other inputs (option length, maximum options count) but none for voting record accumulation: [8](#0-7) 

However, the economic rationality is questionable as this primarily impacts the attacker's own ability to query their records, unless targeting a specific candidate's visibility.

### Recommendation

**1. Add Input Validation:**
Add a maximum array size check in `GetVotingRecords`:

```csharp
public override VotingRecords GetVotingRecords(GetVotingRecordsInput input)
{
    const int MaxBatchSize = 1000; // Conservative limit
    Assert(input.Ids.Count <= MaxBatchSize, 
        $"Cannot retrieve more than {MaxBatchSize} records at once. Use pagination.");
    
    var votingRecords = new VotingRecords();
    votingRecords.Records.AddRange(input.Ids.Select(id => State.VotingRecords[id]));
    return votingRecords;
}
```

**2. Implement Pagination:**
Modify the protobuf to support pagination:

```protobuf
message GetVotingRecordsInput {
    repeated aelf.Hash ids = 1;
    int32 skip = 2;
    int32 limit = 3;
}
```

**3. Add Test Cases:**
Test with array sizes: 1,000, 3,000, 5,000, and 10,000 IDs to verify the actual threshold and ensure graceful degradation.

**4. Update Election Contract:**
Modify `GetElectorVoteWithRecords` and `GetCandidateVoteWithRecords` to handle pagination or implement chunked retrieval with maximum batch sizes.

### Proof of Concept

**Initial State:**
- A voting item is registered in the Vote contract
- An elector has sufficient tokens to create multiple votes

**Attack Steps:**
1. Create a voting item with 90-day lock period
2. Execute 4,000 Vote transactions with minimum amounts (e.g., 1 token each)
3. Call `GetElectorVoteWithRecords` for the elector's address

**Expected Result:**
The method returns all 4,000 voting records

**Actual Result:**
Transaction execution fails with "Execution call count exceeded" error when `GetVotingRecords` is called with 4,000 IDs, as the cumulative method calls exceed the 15,000 threshold

**Verification:**
Monitor execution call count during `GetVotingRecords` with progressively larger arrays (1,000 → 2,000 → 3,000 → 4,000 IDs) to identify the exact failure point, which should occur between 3,000-5,000 IDs depending on the actual overhead per state read.

### Citations

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L8-13)
```csharp
    public override VotingRecords GetVotingRecords(GetVotingRecordsInput input)
    {
        var votingRecords = new VotingRecords();
        votingRecords.Records.AddRange(input.Ids.Select(id => State.VotingRecords[id]));
        return votingRecords;
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-5)
```csharp
    public const int ExecutionCallThreshold = 15000;
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/others.rst (L13-13)
```text
- AElf's contract patcher will patch method call count observer for your contract. This is used to prevent infinitely method call like recursion. The number of method called in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L175-178)
```csharp
        var votedRecords = State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput
        {
            Ids = { votes.ActiveVotingRecordIds }
        }).Records;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L210-213)
```csharp
        var votedWithdrawnRecords = State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput
        {
            Ids = { votes.WithdrawnVotingRecordIds }
        }).Records;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L274-277)
```csharp
        var obtainedRecords = State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput
        {
            Ids = { votes.ObtainedActiveVotingRecordIds }
        }).Records;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L76-76)
```csharp
            newCandidateVotes.ObtainedActiveVotingRecordIds.Add(input.VoteId);
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-6)
```csharp
    public const int MaximumOptionsCount = 64;
    public const int OptionLengthLimit = 1024;
```
