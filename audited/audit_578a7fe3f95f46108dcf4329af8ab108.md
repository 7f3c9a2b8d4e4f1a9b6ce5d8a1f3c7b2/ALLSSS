### Title
No Recovery Mechanism for Compromised Method Fee Controller in TokenHolder Contract

### Summary
The TokenHolder contract's method fee controller, once changed from the default Parliament organization, cannot be reset back to default if the new controller is compromised or malicious. This creates a permanent governance lock-in with no emergency recovery path, allowing a compromised controller to indefinitely control method fee policy.

### Finding Description

The vulnerability exists in the interaction between `RequiredMethodFeeControllerSet()` and `ChangeMethodFeeController()` functions. [1](#0-0) 

The `RequiredMethodFeeControllerSet()` function contains a guard that prevents re-initialization once the controller is set. The check `if (State.MethodFeeController.Value != null) return;` ensures the function only initializes the controller when it's null, defaulting to Parliament's default organization. [2](#0-1) 

The `ChangeMethodFeeController()` function is the only way to modify the controller after initialization. It requires that `Context.Sender == State.MethodFeeController.Value.OwnerAddress`, meaning only the current controller can authorize a change.

**Root Cause:** There is no mechanism to:
1. Reset `State.MethodFeeController.Value` back to null to trigger re-initialization
2. Override the controller through an emergency procedure
3. Bypass the current controller's authorization requirement

**Why Protections Fail:**
- The lazy initialization guard prevents re-initialization
- The authorization check creates circular dependency (compromised controller must approve its own removal)
- Contract code updates preserve state, so updating the contract code doesn't reset the controller [3](#0-2) 

**Execution Path:**
1. Default Parliament organization proposes to change method fee controller (via `ChangeMethodFeeController`)
2. 2/3 of block producers approve the proposal
3. New controller (potentially malicious) is set via line 29: `State.MethodFeeController.Value = input;`
4. New controller can now set arbitrary method fees via `SetMethodFee()`
5. No path exists to revert to default Parliament without the compromised controller's approval [4](#0-3) 

### Impact Explanation

**Direct Governance Impact:**
A compromised method fee controller can:
- Set prohibitively high method fees to DoS the TokenHolder contract functions (CreateScheme, RegisterForProfits, Withdraw, etc.)
- Set zero fees to drain the fee collection mechanism
- Manipulate fee structures to favor specific actors
- Block legitimate fee policy updates indefinitely

**Affected Parties:**
- Users attempting to register for profit schemes will face arbitrary fee barriers
- DApp developers using TokenHolder for staking/dividend distribution
- The broader AElf ecosystem that relies on proper fee governance

**Severity Justification:** 
This is a **Medium severity** governance vulnerability because:
- It requires initial compromise through Parliament (high bar)
- Once compromised, the impact is permanent and irreversible
- Affects critical fee policy governance
- No funds are directly at risk, but contract usability can be severely degraded
- Pattern affects all 16 system contracts implementing ACS1 [5](#0-4) 

### Likelihood Explanation

**Initial Compromise Requirements:**
- Attacker must compromise the default Parliament organization OR
- 2/3 of block producers must be convinced to approve a malicious controller change
- This requires significant coordination or social engineering

**Post-Compromise Permanence:**
Once the controller is changed to a malicious organization:
- The compromise is immediately effective and permanent
- No technical mechanism exists for recovery
- Would require hard fork or contract migration to fix

**Feasibility Assessment:**
- **Attack Complexity:** High for initial compromise, but permanent once achieved
- **Detection:** Controller changes emit events and are publicly visible
- **Operational Constraints:** Initial change requires 2/3 miner approval, making it detectable
- **Economic Rationality:** High upfront cost (compromising Parliament), but unlimited duration of control

**Probability:** Medium likelihood because:
- Initial barrier is high (requires Parliament compromise)
- But precedent exists for governance attacks in blockchain systems
- No defense-in-depth once compromised
- Long-term governance evolution may increase risk (organizational changes, key management issues)

### Recommendation

**Immediate Fix - Add Emergency Reset Mechanism:**

Add a new function that allows the default Parliament organization to override and reset the controller:

```csharp
public override Empty ResetMethodFeeController(Empty input)
{
    // Get the current default Parliament organization
    if (State.ParliamentContract.Value == null)
        State.ParliamentContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    
    var defaultOrganization = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
    
    // Only default Parliament can reset
    Assert(Context.Sender == defaultOrganization, "Only default Parliament can reset controller.");
    
    // Reset to null to trigger re-initialization
    State.MethodFeeController.Value = null;
    
    // Re-initialize to default
    RequiredMethodFeeControllerSet();
    
    Context.Fire(new MethodFeeControllerReset
    {
        NewController = State.MethodFeeController.Value
    });
    
    return new Empty();
}
```

**Alternative Approach - Time-Bounded Override:**

Add a timelock mechanism where controller changes can be reverted by default Parliament within a grace period (e.g., 7 days).

**Invariant Checks:**
1. Add automated monitoring for controller change events
2. Implement circuit breaker if controller sets abnormal fees
3. Add governance delay for controller changes to allow intervention

**Test Cases:**
1. Test that ResetMethodFeeController can only be called by default Parliament
2. Test that reset properly re-initializes to default Parliament
3. Test that reset works even when current controller is unresponsive
4. Test that malicious controller cannot prevent reset

**Apply to All ACS1 Contracts:**
This fix should be applied uniformly across all 16 system contracts that implement ACS1 to maintain consistency.

### Proof of Concept

**Initial State:**
- TokenHolder contract deployed
- MethodFeeController not yet initialized (null)

**Attack Sequence:**

**Step 1:** Attacker creates malicious Parliament organization
```
ParliamentContract.CreateOrganization({
    ProposalReleaseThreshold: { MinimalApprovalThreshold: 1 },
    // Attacker controls this organization
})
→ Returns: maliciousOrgAddress
```

**Step 2:** Attacker compromises default Parliament (or convinces miners) to propose controller change
```
TokenHolderContract.ChangeMethodFeeController({
    OwnerAddress: maliciousOrgAddress,
    ContractAddress: ParliamentContractAddress
})
→ Requires approval from default Parliament
```

**Step 3:** Once approved and released, controller is permanently changed
```
TokenHolderContract.GetMethodFeeController() 
→ Returns: { OwnerAddress: maliciousOrgAddress, ... }
```

**Step 4:** Attacker sets prohibitive fees to DoS the contract
```
// Through maliciousOrg proposal:
TokenHolderContract.SetMethodFee({
    MethodName: "RegisterForProfits",
    Fees: [{ Symbol: "ELF", BasicFee: 1000000000000 }] // 10,000 ELF
})
→ Success (attacker controls maliciousOrg)
```

**Step 5:** Legitimate governance attempts to revert (FAILS)
```
TokenHolderContract.ChangeMethodFeeController({
    OwnerAddress: defaultParliamentAddress,
    ContractAddress: ParliamentContractAddress
})
→ Error: "Unauthorized behavior." 
// Current sender is not maliciousOrgAddress
```

**Expected Result:** Controller can be reset by default Parliament

**Actual Result:** Controller is permanently locked to maliciousOrgAddress with no recovery path

**Success Condition for Exploit:** Method fee controller permanently controlled by attacker, no mechanism for legitimate governance to recover control without attacker's approval.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L50-64)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L98-144)
```csharp
    private void UpdateSmartContract(Address contractAddress, byte[] code, Address author, bool isUserContract)
    {
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        Assert(author == info.Author, "No permission.");

        var oldCodeHash = info.CodeHash;
        var newCodeHash = HashHelper.ComputeFrom(code);
        Assert(oldCodeHash != newCodeHash, "Code is not changed.");
        AssertContractNotExists(newCodeHash);

        info.CodeHash = newCodeHash;
        info.IsUserContract = isUserContract;
        info.Version++;

        var reg = new SmartContractRegistration
        {
            Category = info.Category,
            Code = ByteString.CopyFrom(code),
            CodeHash = newCodeHash,
            IsSystemContract = info.IsSystemContract,
            Version = info.Version,
            ContractAddress = contractAddress,
            IsUserContract = isUserContract
        };

        var contractInfo = Context.UpdateSmartContract(contractAddress, reg, null, info.ContractVersion);
        Assert(contractInfo.IsSubsequentVersion,
            $"The version to be deployed is lower than the effective version({info.ContractVersion}), please correct the version number.");

        info.ContractVersion = contractInfo.ContractVersion;
        reg.ContractVersion = info.ContractVersion;

        State.ContractInfos[contractAddress] = info;
        State.SmartContractRegistrations[reg.CodeHash] = reg;

        Context.Fire(new CodeUpdated
        {
            Address = contractAddress,
            OldCodeHash = oldCodeHash,
            NewCodeHash = newCodeHash,
            Version = info.Version,
            ContractVersion = info.ContractVersion
        });

        Context.LogDebug(() => "BasicContractZero - update success: " + contractAddress.ToBase58());
    }
```

**File:** docs-sphinx/reference/acs/acs1.rst (L359-373)
```text
Of course, the authority of ``SetMethodFee`` can also be changed,
provided that the transaction to modify the authority is sent from the
default address of the ``Parliament contract``:

.. code:: c#

   public override Empty ChangeMethodFeeController(AuthorityInfo input)
   {
       RequiredMethodFeeControllerSet();
       AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
       var organizationExist = CheckOrganizationExist(input);
       Assert(organizationExist, "Invalid authority input.");
       State.MethodFeeController.Value = input;
       return new Empty();
   }
```
