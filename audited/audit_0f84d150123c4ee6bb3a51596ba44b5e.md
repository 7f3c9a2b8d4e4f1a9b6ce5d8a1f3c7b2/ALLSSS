### Title
Configuration Mismatch: Hardcoded TinyBlocksCount Causes Incorrect Mining Time Limits During Dynamic Block Count Adjustments

### Summary
The `TinyBlocksCount` constant is hardcoded to 8 in `CommandStrategyBase.cs` and used for timing calculations, while the actual maximum blocks count is dynamically determined by `GetMaximumBlocksCount()` based on blockchain status. This creates a critical mismatch during Severe or Abnormal blockchain status when miners are restricted to 1 or fewer blocks per time slot, but still receive mining time limits calculated assuming 8 tiny blocks, severely constraining block production time and preventing system recovery.

### Finding Description

The root cause lies in the separation between block count determination and timing calculations: [1](#0-0) 

The hardcoded `TinyBlocksCount = 8` is used to calculate `TinyBlockSlotInterval`: [2](#0-1) 

This interval is then used to derive mining time limits: [3](#0-2) 

However, the actual maximum blocks count is dynamically determined by `GetMaximumBlocksCount()`: [4](#0-3) 

During Severe blockchain status (when `R >= R_LIB + 8`), this method returns 1: [5](#0-4) 

The behavior provider correctly uses this dynamic value to limit block production: [6](#0-5) 

But when consensus commands are generated, the timing limits remain based on the hardcoded constant. For UpdateValue blocks (normal blocks), `DefaultBlockMiningLimit` is used: [7](#0-6) 

This limit is enforced by the consensus service: [8](#0-7) 

**Why existing protections fail:**
- The constant value is referenced from `AEDPoSContractConstants.MaximumTinyBlocksCount`: [9](#0-8) 

- There is no mechanism to synchronize this constant with the dynamic `GetMaximumBlocksCount()` return value
- The timing calculations in `CommandStrategyBase` have no awareness of the actual maximum blocks count being used

### Impact Explanation

**Concrete Harm:**
During Severe blockchain status, miners are restricted to producing 1 block per time slot, but receive only `(MiningInterval / 8) * 3/5` milliseconds for mining, which is approximately 7.5% of the full mining interval. This drastically reduces the time available for block production precisely when the blockchain needs maximum stability to recover from consensus issues.

**Quantified Impact:**
- Expected: If only 1 block is allowed, miners should receive a proportionally larger time allocation (e.g., at least `MiningInterval * 3/5` for consistency with the term-ending block limit)
- Actual: Miners receive `(MiningInterval / 8) * 3/5 = MiningInterval * 3/40` milliseconds
- Difference: 93% reduction in available mining time compared to proportional allocation

**Who is Affected:**
- All miners during Severe blockchain status
- The entire network's consensus stability during recovery from LIB lag

**Severity Justification:**
This operational impact directly affects consensus integrity. When the blockchain enters Severe status (designed as a protective measure), the mismatch prevents effective recovery by giving miners insufficient time to produce blocks. This can lead to prolonged consensus issues, extended chain unavailability, or requiring manual intervention to restart the network.

### Likelihood Explanation

**Preconditions:**
The vulnerability triggers automatically when blockchain status becomes Severe, which occurs when the confirmed irreversible block round number lags behind the current round by 8 or more rounds: [10](#0-9) 

**Feasibility:**
- Severe status can occur due to network latency, high transaction load, validator coordination problems, or temporary network partitions
- No attacker action required - this is an operational vulnerability
- The mismatch is automatically invoked through normal consensus flow: [11](#0-10) 

**Probability:**
- Medium to High during network stress conditions
- The blockchain is designed to enter Severe status as a protective measure, making this a realistic operational scenario
- Once triggered, the impact is immediate and affects all subsequent blocks until status improves

### Recommendation

**Code-Level Mitigation:**

1. Make `TinyBlocksCount` a parameter instead of a constant in `CommandStrategyBase`, passed from the consensus command generation logic:

```csharp
// In CommandStrategyBase constructor
protected CommandStrategyBase(Round currentRound, string pubkey, Timestamp currentBlockTime, int actualTinyBlocksCount)
{
    CurrentRound = currentRound;
    Pubkey = pubkey;
    CurrentBlockTime = currentBlockTime;
    _actualTinyBlocksCount = actualTinyBlocksCount;
}

private readonly int _actualTinyBlocksCount;
private int TinyBlockSlotInterval => MiningInterval.Div(_actualTinyBlocksCount);
```

2. Update all strategy constructors to accept and pass through the actual maximum blocks count from `GetMaximumBlocksCount()`

3. Modify `GetConsensusCommand()` to pass the dynamic value to all command strategies: [12](#0-11) 

Update this and similar strategy instantiations to pass `GetMaximumBlocksCount()` to the base class.

**Invariant Checks:**
- Add assertion: `TinyBlockSlotInterval` calculation should use the same value as behavior provider's `_maximumBlocksCount`
- Add validation: mining time limit should be proportional to actual maximum blocks allowed

**Test Cases:**
1. Simulate Severe blockchain status (LIB lag â‰¥ 8 rounds)
2. Verify `GetMaximumBlocksCount()` returns 1
3. Verify consensus command uses mining limit calculated with actual blocks count (1), not hardcoded 8
4. Verify miner receives adequate time for block production
5. Test Abnormal status with reduced block counts (2-7)
6. Ensure backward compatibility with Normal status (8 blocks)

### Proof of Concept

**Initial State:**
- Blockchain running normally with LIB advancing properly
- Current round R = 50, R_LIB = 40 (Normal status)
- MiningInterval = 4000ms (typical value)

**Sequence to Trigger:**
1. Network experiences high latency or coordination issues
2. LIB stops advancing while rounds continue
3. After 8 rounds: R = 58, R_LIB = 40
4. `GetMaximumBlocksCount()` returns 1 (Severe status)
5. Miner requests consensus command via `GetConsensusCommand()`
6. Behavior provider correctly limits to 1 block
7. `NormalBlockCommandStrategy` generates command with `DefaultBlockMiningLimit`

**Expected vs Actual Result:**

Expected (with fix):
- `TinyBlockSlotInterval = MiningInterval / 1 = 4000ms`
- `DefaultBlockMiningLimit = 4000 * 3/5 = 2400ms` per block
- Miner has adequate time for block production

Actual (current vulnerability):
- `TinyBlockSlotInterval = MiningInterval / 8 = 500ms`
- `DefaultBlockMiningLimit = 500 * 3/5 = 300ms` per block
- Miner receives only 300ms (7.5% of mining interval) despite being limited to 1 block
- Block production likely fails or times out
- Blockchain cannot recover from Severe status

**Success Condition:**
The vulnerability is confirmed when miners in Severe status receive `LimitMillisecondsOfMiningBlock = 300ms` instead of a proportionally larger value reflecting the restriction to 1 block per time slot.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L17-17)
```csharp
        private const int TinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L42-42)
```csharp
        private int TinyBlockSlotInterval => MiningInterval.Div(TinyBlocksCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L49-49)
```csharp
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-79)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }

        if (!State.IsPreviousBlockInSevereStatus.Value)
            return AEDPoSContractConstants.MaximumTinyBlocksCount;

        Context.Fire(new IrreversibleBlockHeightUnacceptable
        {
            DistanceToIrreversibleBlockHeight = 0
        });
        State.IsPreviousBlockInSevereStatus.Value = false;

        return AEDPoSContractConstants.MaximumTinyBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L117-128)
```csharp
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-62)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L39-39)
```csharp
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L98-100)
```csharp
        var limitMillisecondsOfMiningBlock = configuredMiningTime == 0
            ? _consensusCommand.LimitMillisecondsOfMiningBlock
            : configuredMiningTime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L68-69)
```csharp
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L34-37)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                TryToGetPreviousRoundInformation(out var previousRound);
                return new ConsensusCommandProvider(new NormalBlockCommandStrategy(currentRound, pubkey,
                    currentBlockTime, previousRound.RoundId)).GetConsensusCommand();
```
