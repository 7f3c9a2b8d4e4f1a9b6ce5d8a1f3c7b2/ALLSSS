### Title
Authorization Bypass in Cross-Chain Indexing Proposal Release Allows Any Miner to Force Debt onto Original Proposer

### Summary
The `ReleaseCrossChainIndexingProposal` function only validates that the caller is a current miner but never checks if they are the same miner who created the proposal. This allows any miner to release another miner's approved cross-chain indexing proposal, potentially forcing debt and arrears onto the original proposer when side chain balances are insufficient, creating an attack vector for economic griefing.

### Finding Description

The vulnerability exists in the cross-chain indexing proposal flow across two functions: [1](#0-0) 

When proposing, the system stores the proposer's address: [2](#0-1) 

However, when releasing: [3](#0-2) 

The release function only checks if the caller is **a** current miner via `AssertAddressIsCurrentMiner`, not whether they are **the same** miner who proposed: [4](#0-3) 

The consensus check validates any current miner for the time slot: [5](#0-4) 

The critical issue occurs during indexing where arrears/debt are recorded against the **original proposer**, not the releaser: [6](#0-5) [7](#0-6) 

### Impact Explanation

**Economic Griefing Attack:** A malicious miner can force debt onto other miners by strategically timing proposal releases:

1. Miner A proposes cross-chain data when a side chain has sufficient locked balance (e.g., 5 tokens, indexing price 1 token per block)
2. Governance approves the proposal
3. Time passes and the side chain balance depletes (through other indexing operations)
4. Malicious Miner B releases Miner A's stale proposal when balance is insufficient
5. Miner A is recorded with arrears/debt even though they didn't choose to release

The debt system changes the side chain status to `IndexingFeeDebt` and records arrears against the proposer's address, affecting their reputation and potentially requiring them to cover the debt through the recharge mechanism.

**Loss of Proposer Control:** Proposers lose control over when their approved proposals execute, which could result in:
- Suboptimal timing for fee collection
- Forced execution when conditions have changed
- Front-running by other miners

**Who is Affected:** All miners who propose cross-chain indexing are vulnerable to having their proposals released by other miners at inopportune times, potentially causing financial damage through forced arrears.

### Likelihood Explanation

**Attacker Capabilities:** Any miner in the current miner set can execute this attack. Requirements:
- Attacker must be a valid miner with time slot rights
- Target's proposal must be approved by governance
- No special privileges beyond being a miner

**Attack Complexity:** Low - single transaction call to `ReleaseCrossChainIndexingProposal` with target chain ID.

**Feasibility:** Highly feasible because:
- Miners rotate through time slots regularly in AEDPoS consensus
- Proposals remain pending after approval until released
- Side chain balance depletion is a normal occurrence as indexing fees are consumed
- No technical barriers prevent execution

**Detection:** Difficult to detect in advance as the transaction appears legitimate (releasing an approved proposal). The malicious intent is only evident through timing analysis and economic impact.

### Recommendation

Add proposer authorization check in `ReleaseCrossChainIndexingProposal`:

```csharp
public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
{
    Context.LogDebug(() => "Releasing cross chain data..");
    EnsureTransactionOnlyExecutedOnceInOneBlock();
    AssertAddressIsCurrentMiner(Context.Sender);
    Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
    
    // Add proposer validation
    foreach (var chainId in input.ChainIdList)
    {
        var proposedIndexingProposal = State.IndexingPendingProposal.Value;
        if (proposedIndexingProposal.ChainIndexingProposalCollections.TryGetValue(chainId, out var proposal))
        {
            Assert(proposal.Proposer == Context.Sender, 
                "Only the original proposer can release their proposal.");
        }
    }
    
    ReleaseIndexingProposal(input.ChainIdList);
    RecordCrossChainData(input.ChainIdList);
    return new Empty();
}
```

Add regression test cases:
1. Test that a different miner cannot release another miner's proposal
2. Test that only the original proposer can release even after governance approval
3. Test the arrears scenario to ensure proposers aren't forced into debt by other miners

### Proof of Concept

**Initial State:**
- Side chain created with 3 tokens locked, indexing price = 1 token per block
- Miner A (Proposer) at time slot T1
- Miner B (Attacker) at time slot T2

**Attack Sequence:**

1. At block height H1 (Miner A's time slot):
   - Miner A calls `ProposeCrossChainIndexing` with 5 blocks of side chain data
   - Proposal created with Proposer = Miner A
   - Governance approval obtained

2. At block heights H2-H4 (other miners' time slots):
   - Other cross-chain operations consume 2 tokens from side chain balance
   - Side chain now has only 1 token remaining

3. At block height H5 (Miner B's time slot):
   - Miner B calls `ReleaseCrossChainIndexingProposal` for Miner A's proposal
   - Check at line 297 passes (Miner B is current miner)
   - NO check that Miner B == Miner A
   - Indexing processes 5 blocks but only 1 token available
   - 4 tokens recorded as arrears against **Miner A** (not Miner B)

**Expected Result:** Only Miner A should be able to release their own proposal

**Actual Result:** Miner B successfully releases Miner A's proposal, forcing 4 tokens of debt onto Miner A's account and changing the side chain status to `IndexingFeeDebt`

**Success Condition:** After execution, verify that `State.SideChainInfo[chainId].ArrearsInfo[MinerA.Address]` contains the debt amount, demonstrating that Miner A was forced into arrears by Miner B's action.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-290)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L428-437)
```csharp
            var crossChainIndexingProposal = new ChainIndexingProposal
            {
                ChainId = chainId,
                Proposer = proposer,
                ProposedCrossChainBlockData = proposedCrossChainBlockData
            };
            var proposalId = Context.GenerateId(crossChainIndexingController.ContractAddress, proposalToken);
            crossChainIndexingProposal.ProposalId = proposalId;
            SetCrossChainIndexingProposalStatus(crossChainIndexingProposal,
                CrossChainIndexingProposalStatus.Pending);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L816-826)
```csharp
    private List<SideChainBlockData> IndexSideChainBlockData(IList<SideChainBlockData> sideChainBlockDataList,
        Address proposer, int chainId)
    {
        var indexedSideChainBlockData = new List<SideChainBlockData>();

        {
            var formattedProposerAddress = proposer.ToByteString().ToBase64();
            long indexingFeeAmount = 0;

            var sideChainInfo = State.SideChainInfo[chainId];
            var currentSideChainHeight = State.CurrentSideChainHeight[chainId];
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L870-876)
```csharp
            if (arrearsAmount > 0)
            {
                if (sideChainInfo.ArrearsInfo.TryGetValue(formattedProposerAddress, out var amount))
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = amount + arrearsAmount;
                else
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = arrearsAmount;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```
