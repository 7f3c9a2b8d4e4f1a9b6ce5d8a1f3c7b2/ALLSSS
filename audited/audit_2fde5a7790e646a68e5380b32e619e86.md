### Title
Negative DepositBalance Accounting Error in TokenConverter Sell Function

### Summary
The `Sell()` function in TokenConverter calculates withdrawal amounts using Bancor formula with `VirtualBalance + DepositBalance`, but only decrements the `DepositBalance` portion. When the calculated `amountToReceive` exceeds `DepositBalance` and the contract has sufficient total base tokens (from other connector pairs or direct transfers), `DepositBalance` becomes negative, causing `GetDepositConnectorBalance()` to return values lower than `VirtualBalance` alone and corrupting reserve accounting.

### Finding Description

The vulnerability exists in the interaction between three components:

1. **GetSelfBalance calculation** [1](#0-0) 
   - For deposit connectors with virtual balance enabled, returns `VirtualBalance + DepositBalance`

2. **Bancor calculation in Sell()** [2](#0-1) 
   - Uses `GetSelfBalance(toConnector)` which includes VirtualBalance in the calculation
   - Returns `amountToReceive` based on the total balance (VirtualBalance + DepositBalance)

3. **DepositBalance update** [3](#0-2) 
   - Decrements only `DepositBalance` by `amountToReceive`, not accounting for VirtualBalance

4. **Balance query** [4](#0-3) 
   - Returns `VirtualBalance + DepositBalance`, which becomes less than VirtualBalance when DepositBalance is negative

**Root Cause:** VirtualBalance is treated as real reserves in Bancor pricing but isn't backed by actual tokens. The Bancor formula in `GetReturnFromPaid` [5](#0-4)  calculates returns as a fraction of `toConnectorBalance` (which includes VirtualBalance), potentially producing `amountToReceive > DepositBalance`.

**Why Protections Fail:** 
- DepositBalance is a signed `long` type [6](#0-5) , allowing negative values
- SafeMath `.Sub()` uses checked arithmetic [7](#0-6)  but only prevents underflow, not negative results
- No validation ensures `amountToReceive <= DepositBalance` before subtraction
- Token transfer checks total contract balance, not per-connector DepositBalance

### Impact Explanation

**Direct Harm:**
- **Reserve Accounting Corruption:** DepositBalance for a connector becomes negative while VirtualBalance remains unchanged, breaking the invariant that tracked reserves represent actual holdings
- **Mispricing:** Future Bancor calculations use `VirtualBalance + (negative DepositBalance)`, producing artificially low total reserves and incorrect price curves
- **Arbitrage Exploitation:** Price discrepancies enable attackers to extract value through buy-low-sell-high cycles across different connectors
- **Reserve Depletion:** One connector's reserves can be drained beyond its actual DepositBalance while the contract still has tokens from other connectors

**Quantified Damage:**
Example scenario:
- Connector A: VirtualBalance = 100,000, DepositBalance = 5,000
- Connector B: VirtualBalance = 100,000, DepositBalance = 10,000
- Contract holds 15,000 total base tokens
- Attacker sells enough resource tokens on Connector A such that Bancor calculates amountToReceive = 8,000
- Transfer succeeds (contract has 15,000 total)
- Connector A DepositBalance = 5,000 - 8,000 = -3,000 (negative)
- GetDepositConnectorBalance returns 100,000 + (-3,000) = 97,000 < 100,000

**Affected Parties:**
- Future users trading on the affected connector face mispricing
- Protocol reserves become imbalanced across connectors
- Economic stability of the token converter is compromised

**Severity:** Medium-High. Corrupts critical accounting invariants and enables economic exploitation, though doesn't directly steal locked funds.

### Likelihood Explanation

**Attacker Capabilities:** Any user with resource tokens can call the public `Sell()` method [8](#0-7) . No special privileges required.

**Attack Complexity:** Low to moderate.
- Attacker needs to calculate when `amountToReceive > DepositBalance` using off-chain Bancor simulation
- Condition naturally occurs when VirtualBalance >> DepositBalance (common by design for price smoothing)
- Contract must have sufficient total base tokens (guaranteed in multi-connector deployments)

**Feasibility Conditions:**
1. VirtualBalance significantly exceeds DepositBalance (typical configuration)
2. Contract has total base tokens >= amountToReceive (met when multiple connectors exist or via direct transfers)
3. User has sufficient resource tokens to trigger large enough Bancor return

**Detection Constraints:** 
- Transactions appear normal; no failed assertions
- Negative DepositBalance only visible via state inspection
- Price manipulation may be gradual and initially unnoticed

**Probability:** High in production environments with multiple connector pairs or after sustained trading that depletes individual DepositBalance values while VirtualBalance remains constant.

### Recommendation

**Immediate Fix:**
Add validation in `Sell()` before DepositBalance update:

```csharp
// After line 192, before line 193
Assert(amountToReceive <= State.DepositBalance[toConnector.Symbol], 
       "Insufficient deposit balance to fulfill sale");
State.DepositBalance[toConnector.Symbol] = 
    State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**Alternative Design:**
Modify `GetSelfBalance()` to cap the effective balance at actual DepositBalance when calculating withdrawals:

```csharp
private long GetSelfBalance(Connector connector, bool forWithdrawal = false)
{
    long realBalance;
    if (connector.IsDepositAccount)
        realBalance = State.DepositBalance[connector.Symbol];
    else
        realBalance = State.TokenContract.GetBalance.Call(...).Balance;
    
    if (connector.IsVirtualBalanceEnabled && !forWithdrawal) 
        return connector.VirtualBalance.Add(realBalance);
    
    return realBalance; // For withdrawals, return only real balance
}
```

**Invariant Checks:**
- Assert `DepositBalance[symbol] >= 0` after all state modifications
- Add view method to verify `sum(DepositBalance) <= contract.GetBalance(BaseTokenSymbol)`

**Test Cases:**
1. Sell transaction where calculated `amountToReceive > DepositBalance` should revert
2. Multi-connector scenario where one connector's DepositBalance is low relative to VirtualBalance
3. Verify `GetDepositConnectorBalance() >= VirtualBalance` always holds

### Proof of Concept

**Initial State:**
- Connector A (WRITE): VirtualBalance = 100,000 ELF, DepositBalance = 5,000 ELF
- Connector B (READ): VirtualBalance = 100,000 ELF, DepositBalance = 10,000 ELF  
- Contract total base token balance: 15,000 ELF
- Resource token supply in contract for WRITE: 1,000,000 tokens

**Attack Steps:**
1. Attacker calculates off-chain: Selling X WRITE tokens yields amountToReceive = 8,000 ELF (via Bancor formula using toBalance = 105,000)
2. Attacker calls `Sell(Symbol: "WRITE", Amount: X, ReceiveLimit: 7,900)`
3. Bancor calculates amountToReceive = 8,000 using GetSelfBalance = 105,000
4. Transfer of 8,000 ELF succeeds (contract has 15,000 total)
5. DepositBalance["(NT)WRITE"] = 5,000 - 8,000 = -3,000

**Expected vs Actual:**
- **Expected:** Transaction should revert with "Insufficient deposit balance" 
- **Actual:** Transaction succeeds, DepositBalance becomes -3,000

**Success Verification:**
Call `GetDepositConnectorBalance("WRITE")` returns 100,000 + (-3,000) = 97,000, confirming the value is less than VirtualBalance (100,000) alone, violating the accounting invariant.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-212)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
        // Transfer sold token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
        Context.Fire(new TokenSold
        {
            Symbol = input.Symbol,
            SoldAmount = input.Amount,
            BaseAmount = amountToReceive,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L93-102)
```csharp
    public override Int64Value GetDepositConnectorBalance(StringValue symbolInput)
    {
        var connector = State.Connectors[symbolInput.Value];
        Assert(connector != null && !connector.IsDepositAccount, "token symbol is invalid");
        var ntSymbol = connector.RelatedSymbol;
        return new Int64Value
        {
            Value = State.Connectors[ntSymbol].VirtualBalance + State.DepositBalance[ntSymbol]
        };
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs (L19-19)
```csharp
    public MappedState<string, long> DepositBalance { get; set; }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```
