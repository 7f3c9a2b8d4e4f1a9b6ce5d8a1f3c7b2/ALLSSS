### Title
Missing Election Contract Availability Check Causes NextTerm Consensus Failure

### Summary
The AEDPoS consensus contract fails to verify Election contract availability before attempting to retrieve elected miners during term transitions. When `TryToGetVictories` is called during NextTerm operations, it directly invokes the Election contract without checking if the contract reference is null, causing exceptions that halt consensus progression at term boundaries.

### Finding Description

The vulnerability exists in multiple locations within the NextTerm execution flow:

**Primary Location**: The `TryToGetVictories` method directly calls the Election contract without null checking: [1](#0-0) 

This method checks if it's the main chain but fails to verify `State.ElectionContract.Value != null` before calling `State.ElectionContract.GetVictories.Call()`. When the contract address is null, the `Call` method attempts to invoke a method on a null address, throwing a `ContractCallException`.

**Execution Path**:
1. Term change is detected by `GetConsensusBehaviourToTerminateCurrentRound`: [2](#0-1) 

2. This triggers `GetConsensusExtraDataForNextTerm` which calls `GenerateFirstRoundOfNextTerm`: [3](#0-2) 

3. Which invokes the vulnerable `TryToGetVictories`: [4](#0-3) 

**Additional Vulnerable Locations** in `ProcessNextTerm`:
- `UpdateCurrentMinerInformationToElectionContract` calls Election contract without null check: [5](#0-4) 

- `TakeSnapshot` is called without null check: [6](#0-5) 

**Why Protections Fail**: The Election contract address is set during initialization but without verification: [7](#0-6) 

If `GetContractAddressByName` returns null (contract not deployed or not registered), the code continues with a null reference. An `EnsureElectionContractAddressSet` helper exists but is never called before these operations: [8](#0-7) 

**Inconsistent Pattern**: Other methods properly check for null, demonstrating the correct defensive approach: [9](#0-8) 

### Impact Explanation

**Consensus Halt**: When the Election contract is unavailable (null), attempting NextTerm operations throws unhandled exceptions, preventing term transitions. The blockchain becomes stuck at the term boundary, unable to:
- Update miner lists based on election results
- Rotate consensus participants
- Process subsequent rounds
- Continue block production after the current term expires

**Operational Impact**: This is a critical DoS condition affecting the entire network. Unlike the fallback logic that uses current miners when `TryToGetVictories` returns false, an exception prevents any fallback, completely halting consensus progression.

**Affected Parties**: All network participants are impacted as block production ceases when the term boundary is reached.

**Severity Justification**: HIGH - This violates the critical invariant "Correct round transitions and time-slot validation, miner schedule integrity" by making term transitions impossible when the Election contract is unavailable.

### Likelihood Explanation

**Preconditions**: The Election contract address (`State.ElectionContract.Value`) must be null when NextTerm operations execute. This occurs when:
1. `Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName)` returns null during initialization
2. The Election contract is not deployed before the first term transition
3. Incorrect contract registration/naming during chain setup
4. Test environments or development chains with incomplete contract deployments

**Reachability**: The vulnerable code path is reached through normal consensus operations when term change conditions are met (based on `PeriodSeconds` configuration, typically 7 days on main chain).

**Execution Practicality**: This is NOT an attack but a failure mode. No attacker action is required - the vulnerability manifests automatically when preconditions exist and the term boundary is reached.

**Probability Assessment**: MEDIUM likelihood:
- In production main chains with proper deployment procedures, Election contract should be available
- However, during chain initialization, upgrade scenarios, or configuration errors, the contract may be unavailable
- The lack of defensive checks means a single initialization error causes permanent consensus failure
- The inconsistency with other parts of the codebase (which do check for null) suggests this was an oversight

### Recommendation

**Immediate Fix**: Add null checks before all Election contract operations:

1. In `TryToGetVictories` (line 266-283 of AEDPoSContract_ViewMethods.cs):
```csharp
private bool TryToGetVictories(out MinerList victories)
{
    if (!State.IsMainChain.Value)
    {
        victories = null;
        return false;
    }
    
    // Add this check
    if (State.ElectionContract.Value == null)
    {
        EnsureElectionContractAddressSet();
    }
    
    if (State.ElectionContract.Value == null)
    {
        victories = null;
        return false;  // Graceful fallback
    }
    
    var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
    // ... rest of implementation
}
```

2. In `UpdateCurrentMinerInformationToElectionContract` (add null check similar to line 56):
```csharp
private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
{
    if (State.ElectionContract.Value == null) return;  // Add this
    
    State.ElectionContract.UpdateMultipleCandidateInformation.Send(/*...*/);
}
```

3. In `ProcessNextTerm` before TakeSnapshot call (line 213):
```csharp
if (State.ElectionContract.Value != null)
{
    State.ElectionContract.TakeSnapshot.Send(/*...*/);
}
```

**Additional Safeguards**:
- Add assertion in `InitialAElfConsensusContract` to verify Election contract was successfully retrieved
- Add integration tests that simulate Election contract unavailability during term transitions
- Document the dependency requirement in deployment procedures

### Proof of Concept

**Initial State Setup**:
1. Deploy AEDPoS consensus contract on a test chain
2. During `InitialAElfConsensusContract`, ensure `Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName)` returns null (simulate Election contract not being deployed)
3. Execute `FirstRound` to start consensus with initial miners
4. Configure `PeriodSeconds` to a short duration (e.g., 60 seconds for testing)

**Exploitation Steps**:
1. Wait for `PeriodSeconds` to elapse (term change condition is met)
2. Next miner attempts to produce block and calls `GetConsensusCommand`
3. `MainChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound` returns `AElfConsensusBehaviour.NextTerm`
4. `GetConsensusExtraData` calls `GetConsensusExtraDataForNextTerm`
5. `GenerateFirstRoundOfNextTerm` calls `TryToGetVictories`
6. `State.ElectionContract.GetVictories.Call(new Empty())` is invoked with null address

**Expected vs Actual Result**:
- **Expected**: Graceful fallback using current miner list (as intended by lines 234-242)
- **Actual**: `ContractCallException` thrown from `MethodReference.Call`, exception propagates up, consensus command generation fails, term transition cannot proceed

**Success Condition**: The blockchain successfully demonstrates that when Election contract is unavailable, term transition attempts fail with exceptions, and no subsequent blocks can be produced beyond the term boundary.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-51)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L43-46)
```csharp
        State.IsMainChain.Value = true;

        State.ElectionContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L147-152)
```csharp
    private void EnsureElectionContractAddressSet()
    {
        if (State.ElectionContract.Value == null)
            State.ElectionContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName);
    }
```
