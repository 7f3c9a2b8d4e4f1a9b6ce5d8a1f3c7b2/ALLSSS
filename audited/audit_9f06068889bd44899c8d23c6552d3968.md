### Title
Unbounded DelayDistributePeriodCount Enables Storage Exhaustion and Computational DoS via CachedDelayTotalShares Accumulation

### Summary
The `CreateScheme` method lacks validation for `DelayDistributePeriodCount`, allowing attackers to set arbitrarily large values (up to int32.MaxValue). This causes unbounded growth of `CachedDelayTotalShares` map entries during profit distribution, leading to storage exhaustion and computational denial-of-service in `RemoveBeneficiary` and `ClaimProfits` operations that must iterate over these accumulated entries.

### Finding Description

The root cause is the absence of bounds validation for `DelayDistributePeriodCount` in the `CreateScheme` method. While `ProfitReceivingDuePeriodCount` is validated against a maximum of 1024, no such validation exists for `DelayDistributePeriodCount`: [1](#0-0) [2](#0-1) 

The `DelayDistributePeriodCount` field is set during scheme creation without any bounds checking: [3](#0-2) 

**Attack Vector 1 - Unbounded Storage Accumulation:**
During `DistributeProfits`, each call adds an entry to `CachedDelayTotalShares` at key `(period + DelayDistributePeriodCount)`, but these entries are only removed when that future period is reached: [4](#0-3) 

With `DelayDistributePeriodCount` set to a large value (e.g., 1,000,000 or int32.MaxValue = 2,147,483,647), cache entries accumulate indefinitely as the removal condition (`input.Period == cached_key`) won't be satisfied for millions of periods.

**Attack Vector 2 - RemoveBeneficiary Computational DoS:**
The `RemoveBeneficiary` function contains a loop that iterates from `removedMinPeriod` to `removedMinPeriod + DelayDistributePeriodCount`: [5](#0-4) 

If `DelayDistributePeriodCount` equals int32.MaxValue, this attempts approximately 2.1 billion iterations, causing transaction failure or extreme gas consumption.

**Attack Vector 3 - ClaimProfits Computational DoS:**
The `ClaimProfits` function iterates over all keys in `CachedDelayTotalShares`: [6](#0-5) 

As the cache grows with each distribution period, this iteration becomes increasingly expensive, eventually making profit claims prohibitively costly or impossible.

The protobuf definition shows `DelayDistributePeriodCount` is an int32 field with no validation constraints: [7](#0-6) 

### Impact Explanation

**Operational Impact - Computational DoS:**
- `RemoveBeneficiary` becomes completely unusable when `DelayDistributePeriodCount` is set to large values. A loop attempting billions of iterations will exceed gas limits and fail.
- `ClaimProfits` operations experience exponentially increasing costs as cached entries accumulate over time. After N distribution periods, beneficiaries must iterate N times to claim profits.
- Any scheme with a large `DelayDistributePeriodCount` becomes permanently broken for beneficiary management.

**Storage Exhaustion:**
- Each `DistributeProfits` call adds one map entry (16 bytes minimum: int64 key + int64 value)
- After 1,000,000 periods, this accumulates ~16 MB per malicious scheme
- Multiple malicious schemes can amplify storage consumption
- Blockchain state bloat increases node operation costs system-wide

**Affected Parties:**
- All beneficiaries of schemes with large `DelayDistributePeriodCount` values cannot claim profits efficiently
- Scheme managers cannot remove beneficiaries
- Node operators face increased storage and computational costs
- Other schemes may be affected if shared resources are exhausted

**Severity Justification:**
This is HIGH severity because:
1. It causes complete denial-of-service for critical profit distribution functions
2. Storage exhaustion affects the entire blockchain state
3. Attack is permanent once scheme is created (no mechanism to modify `DelayDistributePeriodCount`)
4. Impacts both individual scheme operations and system-wide resources

### Likelihood Explanation

**Reachable Entry Point:**
`CreateScheme` is a public method callable by any user without restrictions: [8](#0-7) 

**Attacker Capabilities:**
- No special permissions required to create schemes
- Attacker becomes scheme manager upon creation, enabling all subsequent operations
- Can set `DelayDistributePeriodCount` to any int32 value (including int32.MaxValue = 2,147,483,647)
- Can call `DistributeProfits` repeatedly to accumulate cache entries

**Attack Complexity:**
- Single transaction to create malicious scheme
- Straightforward parameter manipulation (no complex state setup)
- Deterministic outcome (guaranteed DoS on affected operations)
- No race conditions or timing dependencies

**Economic Rationality:**
- Initial cost: Single transaction fee to create scheme
- Damage potential: Permanent DoS and storage exhaustion
- Cost-to-impact ratio: Extremely favorable for attacker
- No economic disincentive (attacker doesn't bear the computational costs of victim transactions)

**Detection/Operational Constraints:**
- Attack is invisible until victims attempt to use affected functions
- No monitoring mechanisms for suspicious `DelayDistributePeriodCount` values
- Cannot be reversed once scheme is created
- Legitimate use case example shows values of 0-1 are expected: [9](#0-8) 

**Probability Assessment:** HIGH
- Zero barriers to execution
- Attack is practical and economically rational
- No existing protections prevent exploitation
- Can be executed immediately by any malicious actor

### Recommendation

**1. Add Input Validation:**
Add a maximum bound check for `DelayDistributePeriodCount` in the `CreateScheme` method, similar to the existing validation for `ProfitReceivingDuePeriodCount`:

```csharp
// In ProfitContractConstants.cs
public const int MaximumDelayDistributePeriodCount = 100; // or appropriate value

// In ProfitContract.cs CreateScheme method (after line 54)
Assert(
    input.DelayDistributePeriodCount >= 0 &&
    input.DelayDistributePeriodCount <= ProfitContractConstants.MaximumDelayDistributePeriodCount,
    "Invalid delay distribute period count.");
```

**2. Add Safety Checks in Iteration Loops:**
Add bounds checking before entering loops that depend on `DelayDistributePeriodCount`:

```csharp
// In RemoveBeneficiary (before line 247)
Assert(scheme.DelayDistributePeriodCount <= ProfitContractConstants.MaximumDelayDistributePeriodCount,
    "Scheme has invalid delay period configuration.");
```

**3. Implement Cache Size Limits:**
Add a check to limit the maximum size of `CachedDelayTotalShares`:

```csharp
// In DistributeProfits (before line 466)
Assert(scheme.CachedDelayTotalShares.Count < MAX_CACHED_ENTRIES,
    "Cache size limit exceeded.");
```

**4. Test Cases:**
Add regression tests for:
- Scheme creation with maximum valid `DelayDistributePeriodCount`
- Rejection of schemes with excessive `DelayDistributePeriodCount` values
- `RemoveBeneficiary` and `ClaimProfits` operations with populated caches
- Storage consumption over multiple distribution periods

### Proof of Concept

**Initial State:**
- Attacker has an account with transaction fees

**Attack Steps:**

1. **Create Malicious Scheme:**
```
CreateScheme({
    DelayDistributePeriodCount: 1000000,  // or int32.MaxValue
    Manager: attacker_address,
    // other parameters as needed
})
```

2. **Add Beneficiary (optional, to attract victims):**
```
AddBeneficiary({
    SchemeId: malicious_scheme_id,
    BeneficiaryShare: { Beneficiary: victim_address, Shares: 100 }
})
```

3. **Trigger Cache Accumulation:**
```
For period = 1 to 1000:
    ContributeProfits({ SchemeId: malicious_scheme_id, Amount: 1000 })
    DistributeProfits({ SchemeId: malicious_scheme_id, Period: period })
```
After 1000 periods, `CachedDelayTotalShares` contains 1000 entries for periods 1,000,001 to 1,001,000.

4. **Trigger DoS:**
```
RemoveBeneficiary({ SchemeId: malicious_scheme_id, Beneficiary: any_address })
// Transaction fails or exhausts gas due to 1,000,000 loop iterations

ClaimProfits({ SchemeId: malicious_scheme_id, Beneficiary: victim_address })
// Transaction becomes increasingly expensive as it iterates over 1000+ cache entries
```

**Expected Result:** Transactions should reject invalid `DelayDistributePeriodCount` values during scheme creation.

**Actual Result:** Scheme is created with large `DelayDistributePeriodCount`, causing permanent DoS on `RemoveBeneficiary` and increasing costs for `ClaimProfits` as cache grows unbounded.

**Success Condition:** `RemoveBeneficiary` fails with gas exhaustion or timeout, and `ClaimProfits` gas costs increase linearly with cache size, demonstrating the DoS vulnerability.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L44-84)
```csharp
    public override Hash CreateScheme(CreateSchemeInput input)
    {
        ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);

        if (input.ProfitReceivingDuePeriodCount == 0)
            input.ProfitReceivingDuePeriodCount = ProfitContractConstants.DefaultProfitReceivingDuePeriodCount;
        else
            Assert(
                input.ProfitReceivingDuePeriodCount > 0 &&
                input.ProfitReceivingDuePeriodCount <= ProfitContractConstants.MaximumProfitReceivingDuePeriodCount,
                "Invalid profit receiving due period count.");

        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;

        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;

        Context.LogDebug(() => $"Created scheme {State.SchemeInfos[schemeId]}");

        Context.Fire(new SchemeCreated
        {
            SchemeId = scheme.SchemeId,
            Manager = scheme.Manager,
            IsReleaseAllBalanceEveryTimeByDefault = scheme.IsReleaseAllBalanceEveryTimeByDefault,
            ProfitReceivingDuePeriodCount = scheme.ProfitReceivingDuePeriodCount,
            VirtualAddress = scheme.VirtualAddress
        });
        return schemeId;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L245-257)
```csharp
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L793-797)
```csharp
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L938-954)
```csharp
    private Scheme GetNewScheme(CreateSchemeInput input, Hash schemeId, Address manager)
    {
        var scheme = new Scheme
        {
            SchemeId = schemeId,
            // The address of general ledger for current profit scheme.
            VirtualAddress = Context.ConvertVirtualAddressToContractAddress(schemeId),
            Manager = manager,
            ProfitReceivingDuePeriodCount = input.ProfitReceivingDuePeriodCount,
            CurrentPeriod = 1,
            IsReleaseAllBalanceEveryTimeByDefault = input.IsReleaseAllBalanceEveryTimeByDefault,
            DelayDistributePeriodCount = input.DelayDistributePeriodCount,
            CanRemoveBeneficiaryDirectly = input.CanRemoveBeneficiaryDirectly
        };

        return scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L1-10)
```csharp
namespace AElf.Contracts.Profit;

public class ProfitContractConstants
{
    public const int ProfitReceivingLimitForEachTime = 10;
    public const int DefaultProfitReceivingDuePeriodCount = 10;
    public const int MaximumProfitReceivingDuePeriodCount = 1024;
    public const int TokenAmountLimit = 5;
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
}
```

**File:** protobuf/profit_contract.proto (L125-127)
```text
    // Delay distribute period.
    int32 delay_distribute_period_count = 3;
    // The manager of this scheme, the default is the creator.
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-68)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
        }
```
