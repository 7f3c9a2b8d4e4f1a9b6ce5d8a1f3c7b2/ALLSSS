# Audit Report

## Title
Parliament Single Point of Failure in User Fee Governance Due to Trivial Referendum Threshold

## Summary
The referendum organization protecting UserFeeController has critically weak configuration (1 token approval threshold) combined with parliament-exclusive proposal control, allowing miners to unilaterally modify user transaction fee coefficients without meaningful token holder consensus. This violates the intended multi-stakeholder governance model.

## Finding Description

The `GetReferendumControllerCreateInputForUserFee()` function initializes the referendum organization with parameters that enable parliament bypass: [1](#0-0) 

The referendum configuration sets `MinimalApprovalThreshold = 1` and `MinimalVoteThreshold = 1`, while restricting `ProposerWhiteList` to only the parliament address. 

The UserFeeController uses an Association as RootController requiring both parliament and referendum approval: [2](#0-1) 

However, this dual-approval provides no security because:

1. **Proposal monopoly**: Only parliament can create referendum proposals due to ProposerWhiteList restriction
2. **Unrestricted voting**: The Referendum.Approve method accepts votes from any address with token allowance: [3](#0-2) [4](#0-3) 

3. **Trivial threshold**: Only 1 token of approval needed, easily provided by miner-controlled addresses

The protected method controls critical economic parameters: [5](#0-4) 

**Attack Execution Path:**
1. Parliament creates Association proposal to update fee coefficients
2. Parliament approves in parliament organization (2/3 miners)
3. Parliament creates referendum sub-proposal (allowed via whitelist)
4. Miner address approves 1 token allowance to referendum proposal virtual address
5. Same address calls Referendum.Approve() to lock 1 token
6. Referendum threshold reached (1 â‰¥ 1)
7. Parliament releases referendum proposal (via another parliament proposal)
8. Association sees both approvals satisfied and releases
9. Fee coefficients updated

## Impact Explanation

**Governance Failure**: Parliament achieves unilateral control over user transaction fee coefficients, affecting all network participants. The intended separation between parliament (miner collective) and token holder community is eliminated, concentrating economic policy power.

**Economic Manipulation**: Parliament can arbitrarily adjust fee calculation formulas to:
- Increase transaction costs network-wide
- Favor specific actors through targeted fee structures  
- Extract economic rent without community oversight

**Severity Justification**: HIGH - This breaks the fundamental governance invariant that critical economic parameters require multi-stakeholder approval. Token holders are systematically excluded from decisions directly impacting their transaction costs, while the governance structure falsely appears to have checks and balances.

## Likelihood Explanation

**Attacker Profile**: Parliament (default organization of miners requiring 2/3 approval) needs only 1 token for the attack.

**Execution Complexity**: LOW - The test suite demonstrates this exact governance flow: [6](#0-5) 

**Economic Feasibility**: Attack cost = 1 locked token (reclaimable after proposal expiry). Miners earn block rewards in the primary token, making this trivially affordable.

**Detection**: On-chain activity appears as legitimate governance operations. No monitoring system would differentiate this from intended usage.

## Recommendation

Increase referendum voting thresholds to require meaningful token holder participation:

```csharp
MinimalApprovalThreshold = totalSupply / 100, // Require 1% of total supply
MinimalVoteThreshold = totalSupply / 50,      // Require 2% participation
```

Additionally, expand ProposerWhiteList to include token holder representatives or remove the whitelist entirely to allow organic community proposals.

Consider implementing a time-lock mechanism between referendum approval and execution to allow community review.

## Proof of Concept

The existing test at lines 274-320 in `MultiTokenContractReferenceFeeTest.cs` demonstrates the vulnerability when run with a single miner-controlled account providing the 1-token referendum vote. The test shows parliament can successfully update coefficients through this governance path with minimal token participation.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L133-156)
```csharp
    private CreateOrganizationBySystemContractInput GetReferendumControllerCreateInputForUserFee(
        Address parliamentAddress)
    {
        var whiteList = new List<Address> { parliamentAddress };
        var tokenSymbol = GetPrimaryTokenSymbol(new Empty()).Value;
        return new CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new CreateOrganizationInput
            {
                TokenSymbol = tokenSymbol,
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { whiteList }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L158-184)
```csharp
    private Association.CreateOrganizationBySystemContractInput GetAssociationControllerCreateInputForUserFee(
        Address parliamentAddress, Address referendumAddress)
    {
        var proposers = new List<Address>
            { referendumAddress, parliamentAddress };
        return new Association.CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new Association.CreateOrganizationInput
            {
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { proposers }
                },
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { proposers }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L70-83)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.ApprovalCount = proposal.ApprovalCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Approve);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L141-152)
```csharp
    private long GetAllowance(Address owner, string tokenSymbol, Hash proposalId)
    {
        RequireTokenContractStateSet();
        var allowance = State.TokenContract.GetAllowance.Call(new GetAllowanceInput
        {
            Owner = owner,
            Spender = GetProposalVirtualAddress(proposalId),
            Symbol = tokenSymbol
        }).Allowance;
        Assert(allowance > 0, "Allowance not enough.");
        return allowance;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L25-32)
```csharp
    public override Empty UpdateCoefficientsForSender(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        AssertUserFeeController();
        input.Coefficients.FeeTokenType = (int)FeeTypeEnum.Tx; // The only possible for now.
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/MultiTokenContractReferenceFeeTest.cs (L918-962)
```csharp
    private async Task VoteToReferendumAsync(Hash input, string primaryTokenSymbol)
    {
        var organizations = await GetControllerForUserFeeAsync();

        var referendumProposal = new CreateProposalInput
        {
            ToAddress = AssociationContractAddress,
            Params = input.ToByteString(),
            OrganizationAddress = organizations.ReferendumController.OwnerAddress,
            ContractMethodName = nameof(AuthorizationContractContainer.AuthorizationContractStub.Approve),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
        };

        var parliamentProposal = new CreateProposalInput
        {
            ToAddress = ReferendumContractAddress,
            Params = referendumProposal.ToByteString(),
            OrganizationAddress = organizations.ParliamentController.OwnerAddress,
            ContractMethodName = nameof(AuthorizationContractContainer.AuthorizationContractStub.CreateProposal),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
        };
        var ret = await MainChainTesterCreatApproveAndReleaseProposalForParliamentAsync(parliamentProposal);
        var referendumProposalId = ProposalCreated.Parser
            .ParseFrom(ret.Logs.First(l => l.Name.Contains(nameof(ProposalCreated)))
                .NonIndexed).ProposalId;
        var proposalVirtualAddress =
            await ReferendumContractStub.GetProposalVirtualAddress.CallAsync(referendumProposalId);
        var approveResult = await TokenContractStub.Approve.SendAsync(new ApproveInput
        {
            Spender = proposalVirtualAddress,
            Symbol = primaryTokenSymbol,
            Amount = 100000
        });
        await ReferendumContractStub.Approve.SendAsync(referendumProposalId);

        parliamentProposal = new CreateProposalInput
        {
            ToAddress = ReferendumContractAddress,
            Params = referendumProposalId.ToByteString(),
            OrganizationAddress = organizations.ParliamentController.OwnerAddress,
            ContractMethodName = nameof(AuthorizationContractContainer.AuthorizationContractStub.Release),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
        };
        await MainChainTesterCreatApproveAndReleaseProposalForParliamentAsync(parliamentProposal);
    }
```
