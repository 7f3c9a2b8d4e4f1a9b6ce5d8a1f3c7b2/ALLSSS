### Title
Proposal Hijacking via Expiration-Based Overwrite in Contract Deployment Workflow

### Summary
The `RegisterContractProposingData()` function allows any user to overwrite an in-progress contract deployment proposal after its expiration time, regardless of the proposal's current status. This enables an attacker to hijack legitimate proposals that have already progressed through governance approval stages, causing denial of service and loss of control for the original proposer.

### Finding Description

The vulnerability exists in the `RegisterContractProposingData()` function which validates proposal registration: [1](#0-0) 

The function checks whether a proposal can be registered by asserting: `Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.")`. This condition allows complete overwriting of an existing proposal if the current time exceeds the stored `ExpiredTime`, without checking the proposal's current status.

**Root Cause**: The function treats all expired proposals identically, whether they are:
1. Fresh proposals that never progressed (status = PROPOSED)
2. In-progress proposals that have been approved and are awaiting code check (status = APPROVED, CODE_CHECK_PROPOSED, or CODE_CHECKED)

When overwriting occurs, the entire `ContractProposingInput` is replaced with new data, resetting:
- `Proposer` field to the attacker's address
- `Status` back to PROPOSED
- `ExpiredTime` to a new expiration period

**Multi-Stage Vulnerability**: The contract deployment workflow has multiple stages with different expiration periods: [2](#0-1) 

The initial proposal expires after 72 hours, but when `ProposeContractCodeCheck` is called, the expiration is updated to only 15 minutes: [3](#0-2) 

**Why Existing Protections Fail**: The release methods verify the proposer matches the caller: [4](#0-3) [5](#0-4) 

After an attacker overwrites the proposal, these checks prevent the legitimate proposer from completing their own proposal since the stored `Proposer` field now points to the attacker.

The same vulnerability pattern exists in `SendUserContractProposal`: [6](#0-5) 

### Impact Explanation

**Operational Impact**: 
- Legitimate proposers lose control of their proposals after investing time and resources to obtain governance approvals
- All governance progress (APPROVED â†’ CODE_CHECK_PROPOSED stages) is nullified when status resets to PROPOSED
- The legitimate proposer cannot call `ReleaseApprovedContract` or `ReleaseCodeCheckedContract` to complete deployment since these methods require `contractProposingInput.Proposer == Context.Sender`

**Governance Impact**:
- Denial of service: Attackers can indefinitely block contract deployments by repeatedly hijacking proposals after expiration
- Governance process integrity is compromised as approvals can be nullified through timing attacks
- Proposer attribution is manipulated, allowing attackers to claim credit for contracts they didn't legitimately propose

**Affected Parties**:
- Contract developers who successfully navigate the governance process only to have their proposals hijacked
- The governance system's credibility and reliability
- Any benefits/rewards associated with deploying specific contracts

**Severity Justification**: Medium severity due to:
- No direct fund theft, but significant operational disruption
- Complete loss of governance work and proposal control
- System-wide impact on contract deployment reliability

### Likelihood Explanation

**Attacker Capabilities**: 
- No special privileges required - any user can call `ProposeNewContract` or `ProposeUpdateContract`
- Attacker only needs to observe the blockchain for expiring proposals and submit transactions with identical inputs
- Attack cost is minimal (only transaction fees)

**Execution Practicality**:
- The 15-minute code check expiration window is extremely short and easily exceeded in production blockchain environments
- Block production delays, network congestion, or miner unavailability commonly cause governance processes to exceed 15 minutes
- Multiple proposals may be in the code check phase simultaneously, providing multiple attack targets

**Feasibility Conditions**:
- Normal blockchain operation with typical block times and network latency makes expiration likely
- No detection mechanism exists to alert proposers that their proposals are expiring
- Attacker can automate monitoring of contract proposals and their expiration times

**Probability Reasoning**:
- High likelihood during network stress or when governance participation is slow
- The test suite confirms re-proposing after expiration is intentionally supported, but doesn't test the case where in-progress proposals expire: [7](#0-6) 

This test only validates that expired proposals at PROPOSED status can be re-proposed, not the vulnerability case where APPROVED/CODE_CHECK_PROPOSED proposals expire.

### Recommendation

**Code-Level Mitigation**:
Modify `RegisterContractProposingData()` to prevent overwriting proposals that have progressed beyond the initial PROPOSED status:

```csharp
private void RegisterContractProposingData(Hash proposedContractInputHash)
{
    var registered = State.ContractProposingInputMap[proposedContractInputHash];
    
    // Only allow re-proposal if entry doesn't exist OR if it expired at PROPOSED status
    Assert(registered == null || 
           (Context.CurrentBlockTime >= registered.ExpiredTime && 
            registered.Status == ContractProposingInputStatus.Proposed), 
           "Already proposed.");
    
    var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
    State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
    {
        Proposer = Context.Sender,
        Status = ContractProposingInputStatus.Proposed,
        ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
    };
}
```

Apply the same fix to `SendUserContractProposal()` at line 315.

**Invariant Checks**:
- Proposals in APPROVED, CODE_CHECK_PROPOSED, or CODE_CHECKED status should never be overwritable, even after expiration
- Consider implementing a cleanup function that allows the original proposer to explicitly cancel their expired in-progress proposals
- Increase the code check expiration period to be more realistic (e.g., 24 hours instead of 15 minutes)

**Test Cases**:
- Test attempting to re-propose while a proposal is in APPROVED status and expired
- Test attempting to re-propose while a proposal is in CODE_CHECK_PROPOSED status and expired
- Test attempting to re-propose while a proposal is in CODE_CHECKED status and expired
- All should fail to prevent hijacking

### Proof of Concept

**Initial State**:
- Contract deployment governance is enabled
- Alice has successfully navigated initial governance approval
- Current time T1, code check expiration = T1 + 900 seconds

**Attack Sequence**:

1. **T0**: Alice calls `ProposeNewContract(input)` with contract code
   - Hash H = CalculateHashFromInput(input)
   - State: `{Proposer: Alice, Status: PROPOSED, ExpiredTime: T0 + 259200}`

2. **T0 + X**: Governance approves; Alice calls `ReleaseApprovedContract()`
   - State: `{Proposer: Alice, Status: APPROVED, ExpiredTime: T0 + 259200}`

3. **T1**: Parliament calls `ProposeContractCodeCheck()`
   - State: `{Proposer: Alice, Status: CODE_CHECK_PROPOSED, ExpiredTime: T1 + 900}`

4. **T1 + 901**: Code check governance delayed; proposal expired

5. **T1 + 901**: Bob calls `ProposeNewContract(input)` with identical input (same hash H)
   - Check passes: `Context.CurrentBlockTime (T1 + 901) >= registered.ExpiredTime (T1 + 900)`
   - State overwritten: `{Proposer: Bob, Status: PROPOSED, ExpiredTime: T1 + 901 + 259200}`

6. **T1 + 902**: Alice attempts to call `ReleaseCodeCheckedContract()`
   - **Expected**: Alice completes her proposal
   - **Actual**: Transaction fails with "Invalid contract proposing status" because status was reset to PROPOSED
   - Alice also cannot release even if status were correct, because `contractProposingInput.Proposer (Bob) != Context.Sender (Alice)`

**Success Condition**: Bob successfully overwrites Alice's in-progress proposal, causing Alice to lose control despite successfully obtaining governance approval.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L312-323)
```csharp
    private void SendUserContractProposal(Hash proposingInputHash, string releaseMethodName, ByteString @params)
    {
        var registered = State.ContractProposingInputMap[proposingInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var proposedInfo = new ContractProposingInput
        {
            Proposer = Context.Self,
            Status = ContractProposingInputStatus.CodeCheckProposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod()),
            Author = Context.Sender
        };
        State.ContractProposingInputMap[proposingInputHash] = proposedInfo;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-6)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
    public const int DefaultCodeCheckProposalExpirationTimePeriod = 900; // 60 * 15
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L234-260)
```csharp
    public override Hash ProposeContractCodeCheck(ContractCodeCheckInput input)
    {
        RequireSenderAuthority(State.ContractDeploymentController.Value.OwnerAddress);
        AssertCodeCheckProposingInput(input);
        var proposedContractInputHash = input.ProposedContractInputHash;
        var proposedInfo = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(proposedInfo != null && proposedInfo.Status == ContractProposingInputStatus.Approved,
            "Invalid contract proposing status.");
        proposedInfo.Status = ContractProposingInputStatus.CodeCheckProposed;
        State.ContractProposingInputMap[proposedContractInputHash] = proposedInfo;

        var codeCheckController = State.CodeCheckController.Value;
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName = input.CodeCheckReleaseMethod,
                Params = input.ContractInput,
                OrganizationAddress = codeCheckController.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod())
            },
            OriginProposer = proposedInfo.Proposer
        };

        proposedInfo.ExpiredTime = proposalCreationInput.ProposalInput.ExpiredTime;
        State.ContractProposingInputMap[proposedContractInputHash] = proposedInfo;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L277-290)
```csharp
    public override Empty ReleaseApprovedContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];
        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.Proposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
        contractProposingInput.Status = ContractProposingInputStatus.Approved;
        State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release),
            input.ProposalId.ToByteString());
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L292-306)
```csharp
    public override Empty ReleaseCodeCheckedContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];

        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.CodeCheckProposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
        contractProposingInput.Status = ContractProposingInputStatus.CodeChecked;
        State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
        var codeCheckController = State.CodeCheckController.Value;
        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release), input.ProposalId);
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L276-314)
```csharp
    public async Task Propose_MultiTimes()
    {
        var contractDeploymentInput = new ContractDeploymentInput
        {
            Category = KernelConstants.DefaultRunnerCategory, // test the default runner
            Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
        };

        var utcNow = TimestampHelper.GetUtcNow();
        // propose contract code
        var proposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput, utcNow);
        proposingTxResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var proposalId = ProposalCreated.Parser
            .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
            .ProposalId;
        proposalId.ShouldNotBeNull();
        var proposedContractInputHash = ContractProposed.Parser
            .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ContractProposed))).NonIndexed)
            .ProposedContractInputHash;

        var secondProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput);
        secondProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);

        var thirdProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput, utcNow.AddSeconds(86399));
        thirdProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
        
        var byteResult = await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractProposalExpirationTimePeriod),
            new Empty());
        var expirationTimePeriod = Int32Value.Parser.ParseFrom(byteResult);
        
        var forthProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput, utcNow.AddSeconds(expirationTimePeriod.Value));
        forthProposingTxResult.Status.ShouldBe(TransactionResultStatus.Mined);
    }
```
