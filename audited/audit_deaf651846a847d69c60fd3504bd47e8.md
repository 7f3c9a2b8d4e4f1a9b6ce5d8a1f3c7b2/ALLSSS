# Audit Report

## Title
Missing Validation of ExtraBlockProducerOfPreviousRound in NextTermInput Allows Reward Manipulation

## Summary
The `NextTermInput.Create()` method accepts a Round object without validating that the `ExtraBlockProducerOfPreviousRound` field matches the actual block producer. A malicious miner producing a NextTerm block can manipulate this field to grant extra mining privileges and rewards to arbitrary miners, breaking the consensus reward distribution mechanism.

## Finding Description

The vulnerability exists across multiple components in the AEDPoS consensus system:

**1. No validation in NextTermInput.Create()** [1](#0-0) 

The `Create()` method simply copies `ExtraBlockProducerOfPreviousRound` from the input Round without any validation against the actual sender.

**2. Missing validation in RoundTerminateValidationProvider** [2](#0-1) 

The validation for NextTerm only checks round number, term number, and InValues - it does NOT validate `ExtraBlockProducerOfPreviousRound`.

**3. ExtraBlockProducerOfPreviousRound excluded from hash calculation** [3](#0-2) 

The `GetCheckableRound()` method used for hashing does not include `ExtraBlockProducerOfPreviousRound`, so hash-based validation cannot detect manipulation of this field.

**4. The field grants special mining privileges** [4](#0-3) [5](#0-4) 

A miner whose pubkey matches `ExtraBlockProducerOfPreviousRound` can produce tiny blocks before the round starts, increasing their `ProducedBlocks` count.

**5. ProducedBlocks directly affects rewards** [6](#0-5) 

Each tiny block increments the miner's `ProducedBlocks` counter. [7](#0-6) 

Mining rewards are calculated based on total mined blocks (`minedBlocks * miningRewardPerBlock`).

**Root Cause**

In the honest case, the system correctly sets this field: [8](#0-7) 

However, a malicious miner can modify the Round object before including it in the block header and NextTerm transaction: [9](#0-8) 

The `ProcessNextTerm` method directly converts the input to Round without validating `ExtraBlockProducerOfPreviousRound`, and stores it in state.

## Impact Explanation

**Direct Fund Impact - Reward Misallocation:**

1. **Extra Mining Privileges**: The miner whose pubkey matches `ExtraBlockProducerOfPreviousRound` can produce additional tiny blocks before the round officially starts, which normal miners cannot do.

2. **Increased Block Production Count**: Each tiny block produced increments the miner's `ProducedBlocks` counter, as confirmed in the ProcessTinyBlock method.

3. **Higher Reward Share**: Mining rewards are calculated based on total mined blocks. The reward amount is `minedBlocks * miningRewardPerBlock`, and miners with higher `ProducedBlocks` receive proportionally more rewards from the Treasury contract.

**Attack Scenarios:**
- **Collusion**: Malicious NextTerm producer sets `ExtraBlockProducerOfPreviousRound` to a colluding miner's pubkey, granting them extra rewards
- **Self-enrichment**: The malicious producer can set it to their own pubkey to gain extra mining privileges
- **Denial of Service**: Setting it to a non-existent pubkey prevents the legitimate producer from utilizing these privileges

**Affected Parties:**
- The legitimate extra block producer loses rightful mining privileges and rewards
- Other honest miners receive proportionally reduced rewards when a colluding miner gains extra blocks
- Protocol integrity is compromised as rewards no longer accurately reflect work performed

## Likelihood Explanation

**Reachable Entry Point:**
The attack starts from the NextTerm transaction flow, which is a standard consensus operation triggered during term transitions.

**Attacker Capabilities:**
The attacker must be a miner selected to produce the NextTerm block. This is a privileged position but realistically achievable in the normal course of consensus operation - every miner will eventually be selected to produce various consensus blocks.

**Execution Practicality:**
1. Attacker produces a NextTerm block during their designated time slot
2. They call the contract to generate the honest Round object
3. Before signing the block, they modify the `ExtraBlockProducerOfPreviousRound` field in the consensus extra data
4. They create the NextTerm transaction with the same manipulated Round
5. The modified block passes all validation checks since no validator checks this specific field
6. ProcessNextTerm stores the manipulated Round in state
7. In the new term, the beneficiary miner gains extra mining privileges

**Detection Constraints:**
The manipulation is difficult to detect because:
- The field is not included in hash-based validation
- There's no regeneration of the expected value for comparison
- The block appears valid to all validation layers

**Economic Rationality:**
The attack has minimal cost (just modifying one field before signing) and provides direct economic benefit through increased reward allocation. For a rational attacker, the reward gain significantly outweighs any reputational risk.

## Recommendation

Add validation in `ProcessNextTerm` to verify that `ExtraBlockProducerOfPreviousRound` matches the sender's public key:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    var senderPubkey = Context.RecoverPublicKey().ToHex();
    
    // Validate that ExtraBlockProducerOfPreviousRound matches sender
    Assert(nextRound.ExtraBlockProducerOfPreviousRound == senderPubkey,
        "ExtraBlockProducerOfPreviousRound must match the block producer.");
    
    // ... rest of the method
}
```

Alternatively, add validation in `RoundTerminateValidationProvider`:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Check term number
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // Validate ExtraBlockProducerOfPreviousRound matches sender
    if (extraData.Round.ExtraBlockProducerOfPreviousRound != extraData.SenderPubkey.ToHex())
        return new ValidationResult { Message = "ExtraBlockProducerOfPreviousRound must match sender." };
    
    return new ValidationResult { Success = true };
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up an AEDPoS consensus test environment with multiple miners
2. Having a miner produce a NextTerm block
3. Before submitting, modifying the `ExtraBlockProducerOfPreviousRound` field in the Round object to a different miner's pubkey
4. Submitting the NextTerm transaction with the modified data
5. Observing that:
   - The transaction is accepted (no validation failure)
   - The manipulated Round is stored in state
   - The beneficiary miner can now produce extra tiny blocks
   - The beneficiary's `ProducedBlocks` counter increases beyond what they actually mined
   - At the next term transition, rewards are calculated with the inflated block count

The test would verify that the manipulated field bypasses all validation layers and results in incorrect reward distribution.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-13)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-163)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L254-254)
```csharp
        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
```
