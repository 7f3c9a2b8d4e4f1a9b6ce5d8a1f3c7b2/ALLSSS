### Title
Insufficient Validation of ImpliedIrreversibleBlockHeight Allows Byzantine Miners to Slow LIB Progression

### Summary
Miners can set arbitrarily low `ImpliedIrreversibleBlockHeight` values in their consensus updates because validation only ensures the value doesn't decrease from their previous submission, without verifying it reflects the actual current block height. If a Byzantine coalition of miners (>33%) strategically reports stale or slowly-incrementing values, the LIB calculation algorithm will consistently select low heights from the sorted array's lower third, causing finality to lag significantly behind block production.

### Finding Description

The vulnerability exists in the interaction between three components:

**1. Miner-Controlled Value Setting:**
Miners set their `ImpliedIrreversibleBlockHeight` value during block production. While the intended behavior sets this to `Context.CurrentHeight` [1](#0-0) , this value is passed through `UpdateValueInput` [2](#0-1)  and directly assigned to state [3](#0-2) . A malicious miner can modify their node's block generation logic to provide lower values than the actual current height.

**2. Insufficient Validation:**
The only validation of `ImpliedIrreversibleBlockHeight` occurs in `LibInformationValidationProvider` [4](#0-3) , which only checks that a miner's new value is not less than their previous value. There is no verification that:
- The value equals or is reasonably close to `Context.CurrentHeight`
- The value has increased by an expected amount since the miner's last block
- The value is consistent with other miners' reported values

This means miners can keep their `ImpliedIrreversibleBlockHeight` constant (e.g., always reporting 100) or increment it artificially slowly (e.g., +1 per block when the actual height increases by +5), and validation will pass as long as the value is non-decreasing.

**3. Vulnerable LIB Calculation:**
The LIB height is calculated by sorting all miners' reported values and selecting from the lower third [5](#0-4) . This Byzantine fault-tolerant design assumes honest miners report accurate values. However, if more than 33% of miners report artificially low values, the algorithm will consistently select these low values, causing LIB to advance slowly even as normal block production continues at height N >> LIB.

### Impact Explanation

**Finality Degradation:**
The Last Irreversible Block (LIB) mechanism provides finality guarantees to users and applications. When LIB progression is artificially slowed, transactions remain unconfirmed for extended periods. For example, if the current block height is 10,000 but malicious miners keep LIB stuck at 5,000, transactions in blocks 5,001-10,000 lack finality guarantees.

**Security Implications:**
- Applications relying on LIB for settlement decisions face increased uncertainty
- Chain reorganization becomes theoretically possible for a larger range of blocks
- Cross-chain operations that depend on LIB heights for verification are delayed
- User experience degrades as confirmation times increase dramatically

**Affected Parties:**
- End users waiting for transaction finality
- DApps and exchanges using LIB for deposit/withdrawal confirmations
- Cross-chain bridges relying on LIB for security
- The overall protocol's reputation for reliability

**Severity Justification:**
Medium severity is appropriate because while the impact on finality guarantees is significant, the attack requires:
- Byzantine miners (not typical operational failure)
- Coalition of >33% of mining power
- Modified node software (detectable anomaly)
- Questionable economic incentive (attacking one's own protocol)

### Likelihood Explanation

**Attacker Capabilities:**
The attack requires miners to modify their node software to change the value set in `GetConsensusExtraData` or provide custom `UpdateValueInput` parameters. This is feasible for any miner running their own infrastructure but requires deliberate Byzantine behavior.

**Attack Complexity:**
Low complexity once capability is established:
1. Miner modifies local node to set `ImpliedIrreversibleBlockHeight` to a target low value
2. During block production at height N, miner reports ImpliedIrreversibleBlockHeight = M where M << N
3. Validation passes if M >= miner's previous reported value
4. Process repeats automatically with each block the miner produces

**Feasibility Conditions:**
- Requires >33% mining power to significantly impact LIB calculation
- Miners must coordinate or independently choose to attack
- Attack is sustained over time (each malicious block contributes to the effect)

**Detection Constraints:**
The attack is detectable through monitoring:
- Anomalous `ImpliedIrreversibleBlockHeight` values that lag significantly behind block height
- Consistent pattern of specific miners reporting suspiciously low values
- Observable divergence between block production rate and LIB advancement rate

**Probability Reasoning:**
Moderate likelihood in adversarial scenarios:
- Technically feasible and executable
- Byzantine assumption allows for this behavior
- However, economic incentives are unclear (self-harm to protocol value)
- More likely in targeted attack scenarios (e.g., enabling double-spend or cross-chain exploit)

### Recommendation

**Code-Level Mitigation:**
Add validation in `LibInformationValidationProvider` to enforce that `ImpliedIrreversibleBlockHeight` is reasonably close to the current block height:

```csharp
// In LibInformationValidationProvider.ValidateHeaderInformation
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0)
{
    var impliedHeight = providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    var currentHeight = validationContext.CurrentHeight; // Need to add this to ConsensusValidationContext
    
    // Implied height should not lag more than MaximumAllowedLag blocks behind current height
    const long MaximumAllowedLag = 10; // Configurable parameter
    if (currentHeight - impliedHeight > MaximumAllowedLag)
    {
        validationResult.Message = $"Implied LIB height {impliedHeight} lags too far behind current height {currentHeight}";
        return validationResult;
    }
    
    // Existing non-decreasing check
    if (baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight > impliedHeight)
    {
        validationResult.Message = "Incorrect implied lib height.";
        return validationResult;
    }
}
```

**Invariant Checks:**
Add the following invariants to enforce proper LIB progression:
1. `ImpliedIrreversibleBlockHeight` for any miner must be within `MaximumAllowedLag` blocks of `Context.CurrentHeight`
2. Monitor and alert when LIB advancement rate falls below expected threshold
3. Consider slashing or reputation penalties for miners consistently reporting stale values

**Test Cases:**
1. Test that validation rejects blocks where `ImpliedIrreversibleBlockHeight` lags by more than threshold
2. Test LIB calculation with Byzantine coalition reporting low values to ensure attack is mitigated
3. Test that honest miners can still report slightly lagged values due to legitimate sync delays
4. Regression test ensuring validation doesn't break normal consensus operation

### Proof of Concept

**Required Initial State:**
- AEDPoS consensus active with multiple miners (e.g., 7 miners)
- Current blockchain height at 1000
- Current LIB at 990 (normal operation)

**Attack Sequence:**

**Block 1001** (Byzantine Miner A):
- Normal: Should report `ImpliedIrreversibleBlockHeight = 1000`
- Malicious: Reports `ImpliedIrreversibleBlockHeight = 990` (keeping previous value)
- Validation: `990 >= 990` (previous value) → **PASSES**
- State: Stored in round information

**Block 1002** (Honest Miner B):
- Reports `ImpliedIrreversibleBlockHeight = 1001` (normal)

**Block 1003** (Byzantine Miner C):
- Malicious: Reports `ImpliedIrreversibleBlockHeight = 990`
- Validation: `990 >= 990` → **PASSES**

**Block 1004** (Byzantine Miner D):
- Malicious: Reports `ImpliedIrreversibleBlockHeight = 991` (incrementing by 1)
- Validation: `991 >= 990` → **PASSES**

**LIB Calculation** (triggered during any miner's update):
- Sorted values from miners who mined in current round: `[990, 990, 991, 1001, ...]`
- Index selection: `(count - 1) / 3` picks from lower third
- With 3+ Byzantine miners reporting ~990, selected LIB = ~990
- **Expected**: LIB should be ~1000
- **Actual**: LIB stuck at ~990 despite blockchain at height 1004+

**Success Condition:**
Sustained over multiple rounds, LIB advancement rate becomes significantly slower than block production rate, creating a widening gap between current height and finality. With >33% Byzantine miners, gap can be maintained indefinitely.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L48-48)
```csharp
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L32-32)
```csharp
            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```
