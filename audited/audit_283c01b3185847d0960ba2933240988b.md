# Audit Report

## Title
Miners Lose Term Credit When Replacing Pubkey Before Term End Due to Stale Round Data

## Summary
When a miner replaces their public key via `ReplaceCandidatePubkey`, the election contract transfers their `candidateInformation` to the new pubkey and removes the old pubkey's entry. However, the consensus contract's stored round data for previous rounds retains the old pubkey. When `TakeSnapshot` is called at term end to credit miners, it retrieves pubkeys from the stored round data and attempts to update candidate information. The private `UpdateCandidateInformation` method has an early return when `candidateInformation` is null, causing miners to lose credit for terms where they successfully produced blocks.

## Finding Description

The vulnerability exists in the interaction between the pubkey replacement mechanism and the term snapshot logic. The issue arises from a data consistency problem across two contracts:

**Root Cause:**

When `ReplaceCandidatePubkey` is called in the Election contract, it transfers the candidate's information from the old pubkey to the new pubkey and explicitly removes the old pubkey's entry from state storage. [1](#0-0) 

The Election contract then notifies the consensus contract via `RecordCandidateReplacement`. However, this consensus method only updates the **current** round's `RealTimeMinersInformation`: [2](#0-1) 

Previous rounds that are already stored in state remain unchanged and continue to reference the old pubkey.

**Failure Point:**

When a term ends, the consensus contract calls `TakeSnapshot` on the Election contract: [3](#0-2) 

This method retrieves the previous term's miner list by calling `GetPreviousTermMinerPubkeyList`, which returns pubkeys directly from the stored round data: [4](#0-3) 

For each pubkey in this list, the private `UpdateCandidateInformation` method is called. This method has a critical early return when `candidateInformation` is null: [5](#0-4) 

Since the old pubkey's `candidateInformation` was removed during replacement, the method returns early without updating the `Terms` list (which tracks participation history) or the `ContinualAppointmentCount` (which tracks consecutive terms).

**Why Existing Protections Fail:**

The codebase includes a `GetNewestPubkey` function specifically designed to map old pubkeys to their newest replacements: [6](#0-5) 

This function is correctly used in other parts of the codebase, such as when withdrawing votes: [7](#0-6) 

There's even a dedicated method `GetPreviousTermSnapshotWithNewestPubkey` that applies this mapping when retrieving snapshots for queries: [8](#0-7) 

However, the `TakeSnapshot` method does **not** call `GetNewestPubkey` before attempting to update candidate information, causing it to use the stale old pubkey instead of the current one.

## Impact Explanation

**Direct Impact:**

Miners who replace their public keys during or before a term ends lose historical credit for that term. Specifically:

1. The `Terms` list, documented as "The number of terms that the candidate is elected" becomes incomplete and no longer reflects actual participation: [9](#0-8) 

2. The `ContinualAppointmentCount`, documented as "The count of continual appointment" is not updated correctly, breaking the continuity tracking mechanism: [10](#0-9) 

**Severity Justification:**

This is a **High** severity issue because:
- It violates a fundamental invariant of the election system: that miners receive credit for terms in which they actively participated
- The `Terms` list is part of the `CandidateInformation` that voters and the ecosystem rely on to evaluate miner performance
- Historical participation records are critical for the transparency and accountability mechanisms in a DPoS system
- If any future logic uses the `Terms` list for reward calculations, eligibility checks, or reputation scoring, affected miners would be disadvantaged

**Affected Parties:**

- Miners who use the legitimate pubkey replacement feature lose their participation history
- Voters lose access to accurate candidate history when making voting decisions
- Off-chain systems, explorers, and UI applications that display miner statistics will show incorrect data
- The protocol's accountability mechanisms are undermined as miner performance cannot be accurately tracked

## Likelihood Explanation

**Trigger Conditions:**

This vulnerability triggers automatically whenever:
1. A miner calls `ReplaceCandidatePubkey` (requires only being a registered candidate with admin privileges)
2. The term ends before the miner has a chance to replace their pubkey back
3. The consensus contract calls `TakeSnapshot` to finalize the term

**Attacker Capabilities:**

The "attacker" in this case is actually any legitimate user of the pubkey replacement feature. No special privileges beyond being a registered candidate are required. The vulnerability triggers passively through the normal term-end process executed by the consensus contract.

**Probability:**

This issue has **High** likelihood because:
- The `ReplaceCandidatePubkey` feature is specifically designed for key rotation scenarios, which are a common operational requirement
- Miners may need to replace keys for security reasons (compromised keys, hardware failures, operational changes)
- There is no warning mechanism to alert users that replacing their pubkey will cause them to lose term credits
- The vulnerability occurs deterministically every time the conditions are met

## Recommendation

The fix should apply the pubkey replacement mapping before attempting to update candidate information in the `TakeSnapshot` method. Specifically:

1. In `TakeSnapshot`, after retrieving `previousTermMinerList`, map each pubkey to its newest replacement using `GetNewestPubkey` before calling `UpdateCandidateInformation`:

```csharp
foreach (var pubkey in previousTermMinerList)
{
    var newestPubkey = GetNewestPubkey(pubkey);
    UpdateCandidateInformation(newestPubkey, input.TermNumber, previousTermMinerList);
}
```

This approach mirrors the existing protection in `ElectionContract_Elector.cs` and ensures that term credits are applied to the current pubkey even if it was replaced during the term.

Alternatively, consider updating previous round data when `RecordCandidateReplacement` is called, though this would be more gas-intensive and complex.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Initialize an election with a miner producing blocks
2. Call `ReplaceCandidatePubkey` to replace the miner's pubkey during a term
3. Advance to the end of the term and trigger `TakeSnapshot`
4. Query `GetCandidateInformation` for the new pubkey
5. Verify that the `Terms` list does not include the term where the miner participated before replacement
6. Verify that the `ContinualAppointmentCount` is incorrectly set to 0 instead of being incremented

The test would show that miners lose their participation records when using the legitimate pubkey replacement feature, violating the documented behavior of the `CandidateInformation` structure.

---

**Notes:**

This vulnerability affects the integrity of election records rather than causing direct financial loss. However, in a DPoS system, reputation and historical performance are critical trust mechanisms. The loss of participation history undermines the transparency that voters rely on when selecting block producers. The issue is particularly insidious because it affects users of a legitimate operational feature (key rotation) and occurs silently without any indication to the affected party.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L237-243)
```csharp
        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L402-434)
```csharp
    public override Empty TakeSnapshot(TakeElectionSnapshotInput input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        Assert(State.AEDPoSContract.Value == Context.Sender, "No permission.");

        SavePreviousTermInformation(input);

        if (State.ProfitContract.Value == null)
        {
            var profitContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            // Return if profit contract didn't deployed. (Often in test cases.)
            if (profitContractAddress == null) return new Empty();
            State.ProfitContract.Value = profitContractAddress;
        }

        // Update snapshot of corresponding voting record by the way.
        State.VoteContract.TakeSnapshot.Send(new TakeSnapshotInput
        {
            SnapshotNumber = input.TermNumber,
            VotingItemId = State.MinerElectionVotingItemId.Value
        });

        State.CurrentTermNumber.Value = input.TermNumber.Add(1);

        var previousTermMinerList =
            State.AEDPoSContract.GetPreviousTermMinerPubkeyList.Call(new Empty()).Pubkeys.ToList();

        foreach (var pubkey in previousTermMinerList)
            UpdateCandidateInformation(pubkey, input.TermNumber, previousTermMinerList);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L481-492)
```csharp
    private void UpdateCandidateInformation(string pubkey, long lastTermNumber,
        List<string> previousMiners)
    {
        var candidateInformation = State.CandidateInformationMap[pubkey];
        if (candidateInformation == null) return;
        candidateInformation.Terms.Add(lastTermNumber);
        var victories = GetVictories(previousMiners);
        candidateInformation.ContinualAppointmentCount = victories.Contains(ByteStringHelper.FromHexString(pubkey))
            ? candidateInformation.ContinualAppointmentCount.Add(1)
            : 0;
        State.CandidateInformationMap[pubkey] = candidateInformation;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L136-146)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L467-472)
```csharp
        var lastRound = State.Rounds[lastRoundNumber];
        if (lastRound == null || lastRound.RoundId == 0) return new PubkeyList();
        return new PubkeyList
        {
            Pubkeys = { lastRound.RealTimeMinersInformation.Keys }
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L63-64)
```csharp
        var oldVoteOptionPublicKey = GetNewestPubkey(votingRecord.Option);
        var oldCandidateVotes = State.CandidateVotes[oldVoteOptionPublicKey];
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L149-157)
```csharp
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
```

**File:** protobuf/election_contract.proto (L368-369)
```text
    // The number of terms that the candidate is elected.
    repeated int64 terms = 2;
```

**File:** protobuf/election_contract.proto (L374-375)
```text
    // The count of continual appointment.
    int64 continual_appointment_count = 5;
```
