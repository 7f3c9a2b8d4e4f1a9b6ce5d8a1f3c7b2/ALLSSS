# Audit Report

## Title
Integer Division Rounding Allows Zero Transaction Fee Bypass

## Summary
The transaction size fee calculation in the MultiToken contract uses integer division without rounding protection, allowing users to bypass fees entirely when paying with alternative tokens that have unfavorable weight ratios. When the converted fee amount rounds down to zero, transactions succeed without charging any fee despite users having sufficient balance, breaking the network's economic model for spam prevention and fee collection.

## Finding Description

The vulnerability exists in the `ChargeSizeFee` method's fee conversion logic. When a user pays transaction size fees using an alternative token instead of the primary token, the fee amount is converted using the token's weight ratio [1](#0-0) .

This conversion uses integer division (`Div()` method) which truncates toward zero. For small transaction fees or tokens with unfavorable weight ratios (e.g., `AddedTokenWeight=1`, `BaseTokenWeight=10`), the result rounds down to zero. For example: `5 * 1 / 10 = 0`.

Once `txSizeFeeAmount` becomes zero, the billing logic still succeeds because the sufficiency check only verifies that available funds are greater than or equal to the (now zero) fee amount [2](#0-1) .

In `GenerateBill`, when the fee amount is zero and the user has any balance, both `chargeAmount` and `chargeAllowanceAmount` are calculated as zero [3](#0-2) .

Finally, when `ModifyBalance` processes the bill, it skips any amounts that are less than or equal to zero [4](#0-3) , resulting in no actual balance deduction despite the transaction being marked as successfully charged.

The root cause is that `SetSymbolsToPayTxSizeFee` only validates that token weights are positive, not that their ratios prevent rounding issues [5](#0-4) . No minimum fee check exists after the conversion.

## Impact Explanation

This vulnerability breaks the fundamental transaction fee mechanism, which is a critical protocol invariant for:

1. **Spam Prevention**: Transaction size fees prevent network spam by making large-scale attacks economically infeasible. Zero-fee transactions eliminate this protection.

2. **Network Revenue**: Fee collection funds network operations and validator rewards. Lost fee revenue impacts the economic sustainability of the network.

3. **Economic Model Integrity**: The fee distribution mechanisms (Treasury, Profit pools) receive no funds from affected transactions, breaking expected economic flows.

**Quantified Impact**: 
- Transactions with size fees < 10 units using a 1:10 token ratio result in zero fees
- Transactions with size fees < 100 units using a 1:100 ratio result in zero fees  
- Users retain 100% of intended fee amounts
- Affects all transactions where `originalFee * AddedTokenWeight < BaseTokenWeight`

## Likelihood Explanation

**Attacker Capabilities**: Any user can exploit this vulnerability by simply selecting an alternative payment token when submitting transactions. No special privileges or technical expertise required.

**Preconditions**:
1. Governance must configure alternative tokens via `SetSymbolsToPayTxSizeFee` (likely already done in production deployments)
2. Token weight ratios must cause rounding (e.g., `AddedTokenWeight=1`, `BaseTokenWeightâ‰¥10`)
3. Transaction size fees must be small relative to the weight ratio

**Attack Complexity**: Trivial - the user just selects the favorable token when submitting a transaction. The vulnerable conversion happens automatically in the system.

**Probability**: Medium-High. Alternative tokens are commonly configured to allow fee payment flexibility (as evidenced by test cases). Once configured, any user can exploit this immediately. The attack requires no additional setup beyond normal transaction submission.

## Recommendation

Implement one or more of the following mitigations:

1. **Add Minimum Fee Check**: After fee conversion, verify that `txSizeFeeAmount > 0` before proceeding. If it rounds to zero, either fail the transaction or charge a minimum fee of 1 unit.

2. **Validate Weight Ratios**: In `SetSymbolsToPayTxSizeFee`, add validation that `BaseTokenWeight <= AddedTokenWeight * MaxAllowedSizeFee` to ensure typical transaction fees don't round to zero.

3. **Use Rounding-Up Division**: Modify the conversion to use ceiling division instead of floor division: `txSizeFeeAmount = (txSizeFeeAmount.Mul(availableSymbol.AddedTokenWeight).Add(availableSymbol.BaseTokenWeight - 1)).Div(availableSymbol.BaseTokenWeight)`.

4. **Reject Zero-Fee Bills**: In `GenerateBill`, add an assertion that fails if both `chargeAmount` and `chargeAllowanceAmount` are zero when `txSizeFeeAmount` was originally non-zero.

The most robust solution combines approach 1 (immediate check) with approach 2 (configuration-time validation) to provide defense in depth.

## Proof of Concept

```csharp
[Fact]
public async Task ChargeTransactionFees_IntegerDivision_Bypass_Test()
{
    await SetPrimaryTokenSymbolAsync();
    
    // Create alternative token with unfavorable 1:10 ratio
    var altToken = "ALT";
    await CreateTokenAsync(DefaultSender, altToken);
    await IssueTokenToDefaultSenderAsync(altToken, 10000);
    
    // Configure alternative token for size fee payment
    var sizeFeeSymbolList = new SymbolListToPayTxSizeFee();
    sizeFeeSymbolList.SymbolsToPayTxSizeFee.Add(new SymbolToPayTxSizeFee
    {
        TokenSymbol = NativeTokenSymbol,
        AddedTokenWeight = 1,
        BaseTokenWeight = 1
    });
    sizeFeeSymbolList.SymbolsToPayTxSizeFee.Add(new SymbolToPayTxSizeFee
    {
        TokenSymbol = altToken,
        AddedTokenWeight = 1,  // Unfavorable ratio
        BaseTokenWeight = 10   // Will cause rounding to 0 for fees < 10
    });
    await TokenContractImplStub.SetSymbolsToPayTxSizeFee.SendAsync(sizeFeeSymbolList);
    
    // Get balance before
    var balanceBefore = await GetBalanceAsync(DefaultSender, altToken);
    balanceBefore.ShouldBe(10000);
    
    // Charge transaction with small size fee (5 units)
    // Expected conversion: 5 * 1 / 10 = 0 (rounds down)
    var chargeInput = new ChargeTransactionFeesInput
    {
        MethodName = "Transfer",
        ContractAddress = TokenContractAddress,
        TransactionSizeFee = 5  // Small fee that will round to 0
    };
    chargeInput.SymbolsToPayTxSizeFee.AddRange(sizeFeeSymbolList.SymbolsToPayTxSizeFee);
    
    // Transaction should succeed
    var result = await TokenContractStub.ChargeTransactionFees.SendAsync(chargeInput);
    result.Output.Success.ShouldBeTrue();
    
    // Verify no fee was charged (balance unchanged)
    var balanceAfter = await GetBalanceAsync(DefaultSender, altToken);
    balanceAfter.ShouldBe(10000);  // Balance unchanged - fee bypassed!
    
    // The fee should have been charged, but due to integer division rounding,
    // the user paid ZERO fees despite having sufficient balance.
}
```

This test demonstrates that a transaction with a 5-unit size fee, when paid with a token having a 1:10 weight ratio, results in zero fee charged due to integer division (`5 * 1 / 10 = 0`), allowing the user to bypass the transaction fee entirely.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L247-247)
```csharp
            if (amount <= 0) continue;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L403-404)
```csharp
                txSizeFeeAmount = txSizeFeeAmount.Mul(availableSymbol.AddedTokenWeight)
                    .Div(availableSymbol.BaseTokenWeight);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L417-417)
```csharp
        var chargeResult = availableBalance.Add(availableAllowance) >= txSizeFeeAmount;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L519-543)
```csharp
    private void GenerateBill(long txSizeFeeAmount, string symbolToPayTxFee, string symbolChargedForBaseFee,
        long availableBalance, long availableAllowance, ref TransactionFeeBill bill,
        ref TransactionFreeFeeAllowanceBill allowanceBill)
    {
        var chargeAmount = 0L;
        var chargeAllowanceAmount = 0L;
        if (availableBalance.Add(availableAllowance) > txSizeFeeAmount)
        {
            // Allowance > size fee, all allowance
            if (availableAllowance > txSizeFeeAmount)
            {
                chargeAllowanceAmount = txSizeFeeAmount;
            }
            else
            {
                // Allowance is not enough
                chargeAllowanceAmount = availableAllowance;
                chargeAmount = txSizeFeeAmount.Sub(chargeAllowanceAmount);
            }
        }
        else
        {
            chargeAllowanceAmount = availableAllowance;
            chargeAmount = availableBalance;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L634-635)
```csharp
            Assert(tokenWeightInfo.AddedTokenWeight > 0 && tokenWeightInfo.BaseTokenWeight > 0,
                $"symbol:{tokenWeightInfo.TokenSymbol} weight should be greater than 0");
```
