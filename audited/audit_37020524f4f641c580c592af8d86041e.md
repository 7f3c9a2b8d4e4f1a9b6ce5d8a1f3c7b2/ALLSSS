# Audit Report

## Title
Malicious Miner Can DoS Critical System Operations By Injecting Invalid Hex Strings Via NextRound

## Summary
A malicious current miner can inject invalid hex strings into the `RealTimeMinersInformation` dictionary when calling `NextRound`, causing unhandled exceptions in subsequent calls to `IsCurrentMiner`. This blocks critical operations including transaction fee claiming, resource token donation, and cross-chain indexing until the malicious round expires.

## Finding Description

The vulnerability exists in the consensus round update flow where `NextRound` accepts arbitrary string keys in `RealTimeMinersInformation` without validating hex format: [1](#0-0) 

When a miner calls `NextRound`, the input is processed and stored without hex validation: [2](#0-1) 

The validation providers check round number, InValue nullity, and mining order, but never validate pubkey hex format: [3](#0-2) [4](#0-3) 

The malicious data is stored directly via: [5](#0-4) 

Later, when `IsCurrentMiner` is called, it attempts to convert addresses to pubkeys by iterating through all stored keys: [6](#0-5) 

The `ByteArrayHelper.HexStringToByteArray` method throws exceptions for invalid hex strings: [7](#0-6) 

This blocks critical operations that require miner permission checks:

**Transaction Fee Claiming:** [8](#0-7) 

**Resource Token Donation:** [9](#0-8) 

**Cross-Chain Indexing:** [10](#0-9) [11](#0-10) [12](#0-11) 

## Impact Explanation

**HIGH Severity** - The DoS affects multiple consensus-critical operations:

1. **Economic Disruption**: ALL miners lose ability to claim transaction fees, not just the attacker
2. **Resource Token Model Break**: `DonateResourceToken` fails system-wide
3. **Cross-Chain Communication Halt**: Side chains cannot index parent chain data, breaking cross-chain functionality completely
4. **Network-Wide Impact**: Affects entire blockchain until malicious round expires (1-2 rounds, potentially hours)

The vulnerability breaks the core security guarantee that authorized miners can execute critical system operations.

## Likelihood Explanation

**HIGH Likelihood:**
- Attack requires only current miner status (achievable through normal election)
- Single malicious/compromised miner sufficient
- Attack trivial to execute: add one malformed key (e.g., "xyz") to `RealTimeMinersInformation`
- No detection mechanisms exist - malicious data appears valid to validators
- Impact is immediate and deterministic

The permission check only verifies sender is a current miner, not data validity: [13](#0-12) 

## Recommendation

Add hex string format validation in consensus input processing:

```csharp
private void ValidateRoundMinersInformation(Round round)
{
    foreach (var key in round.RealTimeMinersInformation.Keys)
    {
        try
        {
            ByteArrayHelper.HexStringToByteArray(key);
        }
        catch
        {
            Assert(false, $"Invalid miner public key hex format: {key}");
        }
    }
}
```

Call this validation in `ProcessNextRound` before storing:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    ValidateRoundMinersInformation(nextRound); // Add validation here
    
    RecordMinedMinerListOfCurrentRound();
    // ... rest of processing
}
```

## Proof of Concept

```csharp
[Fact]
public void MaliciousMiner_InjectInvalidHex_DoSIsCurrentMiner()
{
    // Setup: Initialize consensus with legitimate miners
    var legitimateMiner = SampleAccount.Accounts[0].KeyPair;
    
    // Attacker is current miner, creates NextRoundInput with invalid hex key
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = 2,
        RealTimeMinersInformation = 
        {
            { legitimateMiner.PublicKey.ToHex(), new MinerInRound { Pubkey = legitimateMiner.PublicKey.ToHex(), Order = 1 } },
            { "xyz", new MinerInRound { Pubkey = "xyz", Order = 2 } } // Invalid hex!
        }
    };
    
    // Attack: Submit malicious NextRound
    var result = ConsensusContract.NextRound(maliciousInput);
    result.Status.ShouldBe(TransactionResultStatus.Mined); // Succeeds, data stored
    
    // Impact: IsCurrentMiner now throws exception
    Should.Throw<FormatException>(() => 
    {
        ConsensusContract.IsCurrentMiner(legitimateMiner.GetAddress());
    });
    
    // Consequence: Critical operations fail
    Should.Throw<Exception>(() => 
    {
        TokenContract.ClaimTransactionFees(new TotalTransactionFeesMap());
    });
}
```

## Notes

**Important Correction**: The original claim states the attack works via "NextRound or NextTerm". This is only partially correct:

- **NextRound**: ✅ Vulnerable as described
- **NextTerm**: ❌ NOT vulnerable - `ProcessNextTerm` calls `ByteStringHelper.FromHexString` on all keys before storing (line 189), causing immediate transaction failure and revert [14](#0-13) 

The vulnerability is real and severe via the `NextRound` path alone, but the `NextTerm` attack vector is incorrectly included in the claim.

### Citations

**File:** protobuf/aedpos_contract.proto (L458-462)
```text
message NextRoundInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-106)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L111-134)
```csharp
    public override BoolValue IsCurrentMiner(Address input)
    {
        var pubkey = ConvertAddressToPubkey(input);
        return new BoolValue
        {
            Value = IsCurrentMiner(pubkey)
        };
    }

    /// <summary>
    ///     The address must in miner list.
    /// </summary>
    /// <param name="address"></param>
    /// <returns></returns>
    private string ConvertAddressToPubkey(Address address)
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);

        return possibleKeys.FirstOrDefault(k =>
            Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)) == address);
    }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-19)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-906)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
        var claimTransactionExecuteHeight = State.ClaimTransactionFeeExecuteHeight.Value;

        Assert(claimTransactionExecuteHeight < Context.CurrentHeight,
            $"This method already executed in height {State.ClaimTransactionFeeExecuteHeight.Value}");
        State.ClaimTransactionFeeExecuteHeight.Value = Context.CurrentHeight;
        Context.LogDebug(() => $"Claim transaction fee. {input}");
        State.LatestTotalTransactionFeesMapHash.Value = HashHelper.ComputeFrom(input);
        foreach (var bill in input.Value)
        {
            var symbol = bill.Key;
            var amount = bill.Value;
            ModifyBalance(Context.Self, symbol, amount);
            Context.Fire(new TransactionFeeClaimed
            {
                Symbol = symbol,
                Amount = amount,
                Receiver = Context.Self
            });
            
            TransferTransactionFeesToFeeReceiver(symbol, amount);
        }

        Context.LogDebug(() => "Finish claim transaction fee.");

        return new Empty();
    }

    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L913-920)
```csharp
    public override Empty DonateResourceToken(TotalResourceTokensMaps input)
    {
        AssertSenderIsCurrentMiner();
        var donateResourceTokenExecuteHeight = State.DonateResourceTokenExecuteHeight.Value;
        if (donateResourceTokenExecuteHeight == 0)
        {
            donateResourceTokenExecuteHeight = Context.CurrentHeight;
        }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-302)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }

    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```
