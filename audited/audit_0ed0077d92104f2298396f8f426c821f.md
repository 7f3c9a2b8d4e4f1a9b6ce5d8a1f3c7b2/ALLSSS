### Title
Retroactive Threshold Changes Allow Invalidation of Already-Approved Proposals

### Summary
The `ChangeOrganizationThreshold` function allows modification of approval thresholds that apply retroactively to existing proposals. This enables already-approved proposals to become unapproved when thresholds are increased, preventing their execution and creating a governance manipulation vector.

### Finding Description

The vulnerability exists in how the Parliament contract evaluates proposal approval status. The root cause is that proposals do not snapshot the threshold at creation time, instead dynamically evaluating against the current organization threshold. [1](#0-0) 

When `ChangeOrganizationThreshold` is called, it directly updates the organization's threshold in storage without any consideration for existing proposals. [2](#0-1) 

The `ProposalInfo` structure stores only vote counts (approvals, rejections, abstentions) but does not store the threshold that was active when the proposal was created. [3](#0-2) 

When `Release` is called, it checks `IsReleaseThresholdReached` using the current organization's threshold from storage (line 137). [4](#0-3) 

The `IsReleaseThresholdReached` function dynamically calculates approval status by comparing vote counts against the organization's current threshold values, not a historical snapshot. [5](#0-4) 

The `GetProposal` view function also calculates `ToBeReleased` dynamically (line 241), meaning the same proposal can show as approved at one moment and unapproved later.

### Impact Explanation

**Governance Manipulation**: Approved proposals can be retroactively invalidated by increasing thresholds, allowing malicious actors to prevent legitimate governance actions from executing.

**Concrete Scenario**: 
- Organization has 50% approval threshold (5000/10000)
- Proposal P1 receives 60% approval (6 out of 10 parliament members)
- P1 is ready for release (`ToBeReleased = true`)
- Another proposal P2 that calls `ChangeOrganizationThreshold` is passed, increasing threshold to 70%
- Now P1 has only 60% approval but needs 70%
- `Release(P1)` fails with "Not approved" despite P1 being legitimately approved under the rules when votes were cast

**Who is Affected**: All Parliament organizations and their proposals. This breaks the fundamental governance invariant that approved proposals remain approved.

**Severity**: Critical - This undermines the entire governance mechanism's integrity and predictability.

### Likelihood Explanation

**Attacker Capabilities**: Any organization member or proposer who can create and approve proposals to change thresholds.

**Attack Complexity**: Low - requires only standard governance operations:
1. Create proposal to increase threshold
2. Get it approved
3. Release it to invalidate other approved proposals

**Feasibility Conditions**: 
- Attacker must be able to propose threshold changes (requires being authorized proposer)
- Must convince enough members to approve the threshold change
- Target proposals must not be released yet

**Detection**: Difficult to detect as threshold changes are legitimate governance operations. The retroactive effect may not be immediately obvious.

**Probability**: High - This is a natural consequence of the current implementation and can occur accidentally (legitimate threshold adjustments) or maliciously.

### Recommendation

**Code-Level Mitigation**: Store the threshold snapshot at proposal creation time and use it for approval evaluation.

Modify `ProposalInfo` to include:
```protobuf
message ProposalInfo {
    // ... existing fields ...
    acs3.ProposalReleaseThreshold threshold_snapshot = 14;
}
```

Update `CreateNewProposal` in Parliament_Helper.cs to capture threshold:
```csharp
proposal.ThresholdSnapshot = organization.ProposalReleaseThreshold;
```

Update `IsReleaseThresholdReached` to use the snapshot:
```csharp
private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
{
    var threshold = proposal.ThresholdSnapshot ?? organization.ProposalReleaseThreshold;
    // Use 'threshold' instead of 'organization.ProposalReleaseThreshold' in all checks
}
```

**Invariant Checks**: Add validation that `ChangeOrganizationThreshold` does not invalidate already-releasable proposals, or explicitly document that threshold changes are forward-only.

**Test Cases**: Add test verifying that proposals approved under old threshold remain releasable after threshold increase.

### Proof of Concept

**Initial State**:
- Parliament organization with 10 members
- MinimalApprovalThreshold = 5000 (50%)
- MinimalVoteThreshold = 5000 (50%)

**Attack Steps**:

1. **Create and approve target proposal P1**:
   - Create proposal P1 for legitimate governance action
   - 6 parliament members approve P1 (60% approval)
   - `GetProposal(P1).ToBeReleased` returns `true`

2. **Create and execute threshold change proposal P2**:
   - Create proposal P2 calling `ChangeOrganizationThreshold` with MinimalApprovalThreshold = 7000 (70%)
   - Get sufficient approvals for P2
   - Release P2, changing the threshold

3. **Attempt to release P1**:
   - `GetProposal(P1).ToBeReleased` now returns `false`
   - `Release(P1)` fails with "Not approved."

**Expected Result**: P1 should be releasable since it was approved under the rules when votes were cast.

**Actual Result**: P1 becomes unreleasable because it now needs 7 approvals but only has 6.

**Success Condition**: P1, which had sufficient approvals (60% > 50%), can no longer be released after threshold increase (60% < 70%), demonstrating retroactive invalidation of approved proposals.

### Notes

This vulnerability also affects Association and Referendum contracts which have similar `ChangeOrganizationThreshold` implementations and dynamic threshold evaluation logic. The same fix should be applied across all governance contracts.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L147-160)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L225-248)
```csharp
    public override ProposalOutput GetProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        if (proposal == null) return new ProposalOutput();

        var organization = State.Organizations[proposal.OrganizationAddress];

        return new ProposalOutput
        {
            ProposalId = proposalId,
            ContractMethodName = proposal.ContractMethodName,
            ExpiredTime = proposal.ExpiredTime,
            OrganizationAddress = proposal.OrganizationAddress,
            Params = proposal.Params,
            Proposer = proposal.Proposer,
            ToAddress = proposal.ToAddress,
            ToBeReleased = Validate(proposal) && IsReleaseThresholdReached(proposal, organization),
            ApprovalCount = proposal.Approvals.Count,
            RejectionCount = proposal.Rejections.Count,
            AbstentionCount = proposal.Abstentions.Count,
            Title = proposal.Title,
            Description = proposal.Description
        };
    }
```

**File:** protobuf/parliament_contract.proto (L116-143)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```
