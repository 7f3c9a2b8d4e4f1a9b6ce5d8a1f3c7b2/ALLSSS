### Title
Delegation Slot Exhaustion via Unconsumed Zero-Value Non-Unlimited Delegatees

### Summary
The `ModifyDelegation` function in fee charging does not remove delegatee entries when delegation amounts are consumed to zero, creating an inconsistent state where non-unlimited delegatees persist with zero-value delegation entries. Since there is a hard limit of 24 delegatees per delegator-contract-method combination, these "zombie" delegatees can exhaust all available slots, permanently blocking users from adding new valid delegatees until manual cleanup.

### Finding Description
The vulnerability stems from an inconsistency between delegation state management in `SetTransactionFeeDelegateInfos` and `ModifyDelegation`:

In `SetTransactionFeeDelegateInfos`, there is a validation assertion requiring non-unlimited delegations to have at least one entry: [1](#0-0) 

There is also a cleanup mechanism that removes delegatees when delegations become empty: [2](#0-1) 

However, when transaction fees are charged from delegations, the `ModifyDelegation` function reduces delegation amounts by subtraction without removing entries that reach zero or checking if the delegatee should be removed: [3](#0-2) 

This creates an inconsistent state: after fee charging, a non-unlimited delegatee can have `Delegations.Count > 0` (map entries exist) but all values equal 0. The cleanup check at lines 233-242 only triggers when `Delegations.Count == 0`, not when entries exist with zero values, so these "zombie" delegatees persist.

Additionally, there is a hard limit on the number of delegatees: [4](#0-3) [5](#0-4) 

### Impact Explanation
**Denial of Service Impact:**
- When all 24 delegatee slots are filled with exhausted delegations (zero-value entries), users cannot add new valid delegatees
- The add operation fails at the count check, even though all existing delegatees are functionally useless
- This permanently blocks the delegation feature until users manually identify and remove each exhausted delegatee

**Affected Parties:**
- Delegators who actively use the delegation feature for transaction fee payment
- Legitimate delegatees who cannot be added when slots are exhausted

**Storage & Gas Impact:**
- Unnecessary storage bloat from persisting useless delegation entries
- Users must spend additional gas to manually clean up exhausted delegatees through `RemoveTransactionFeeDelegateeInfos` or `RemoveTransactionFeeDelegatorInfos`

**Severity Justification:**
This is HIGH severity because it causes operational DOS of a core token contract feature during normal usage patterns (not requiring attacker actions), and the limit of 24 delegatees makes the exhaustion achievable through regular transaction fee consumption.

### Likelihood Explanation
**Occurrence Probability:** Very High
- This occurs naturally during normal operations when delegations are consumed by transaction fees
- No attacker action required - normal users paying fees from delegations will trigger this
- The more actively a user utilizes delegations, the faster they hit this issue

**Feasibility:**
- Entry point: Normal transaction fee charging flow (happens automatically for every transaction)
- No special permissions required
- No economic cost to trigger (happens during regular usage)
- State persists across transactions until manual cleanup

**Detection Difficulty:**
- Users may not realize their delegatee slots are filled with exhausted delegations
- No automatic notification or cleanup mechanism
- Manifests as mysterious "delegatee limit reached" errors when trying to add new delegatees

### Recommendation

**Code-Level Fix:**
Modify the `ModifyDelegation` function to remove delegation entries when they reach zero and check if the delegatee should be removed:

```csharp
private void ModifyDelegation(TransactionFeeBill bill, TransactionFreeFeeAllowanceBill allowanceBill,
    Address delegateeAddress, Address contractAddress, string methodName, Address delegatorAddress)
{
    foreach (var (symbol, amount) in bill.FeesMap)
    {
        if (amount <= 0) continue;
        var delegateInfo = State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] 
            ?? State.TransactionFeeDelegateesMap[delegatorAddress];
        var delegations = delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations;
        delegations[symbol] = delegations[symbol].Sub(amount);
        
        // Remove entry if it reaches zero
        if (delegations[symbol] <= 0)
        {
            delegations.Remove(symbol);
        }
    }
    
    // Similar logic for allowanceBill...
    
    // After modifying all delegations, check if delegatee should be removed
    var delegateeEntry = delegateInfo.Delegatees[delegateeAddress.ToBase58()];
    if (delegateeEntry.Delegations.Count == 0 && !delegateeEntry.IsUnlimitedDelegate)
    {
        delegateInfo.Delegatees.Remove(delegateeAddress.ToBase58());
        // Fire appropriate event
    }
}
```

**Invariant Checks:**
Add assertions to enforce the invariant: "Non-unlimited delegatees must have at least one delegation entry with amount > 0, or be removed from storage"

**Test Cases:**
1. Test delegation consumption to zero - verify delegatee is automatically removed
2. Test slot exhaustion scenario - verify all 24 slots can be filled and refilled after consumption
3. Test mixed unlimited and non-unlimited delegatees with various consumption patterns

### Proof of Concept

**Initial State:**
- Delegator has 24 non-unlimited delegatees configured for a contract/method
- Each delegatee has some delegation amount (e.g., {"ELF": 100})

**Execution Steps:**
1. User performs transactions that consume all delegation amounts through normal fee charging
2. For each transaction, `ChargeFromDelegations` is called, which invokes `ModifyDelegation`
3. `ModifyDelegation` reduces delegation amounts: `delegations[symbol] = delegations[symbol].Sub(amount)`
4. When amounts reach 0, entries remain with value 0 (e.g., {"ELF": 0})
5. Delegatees persist with `Delegations.Count > 0` but all values = 0
6. All 24 slots now filled with exhausted delegatees

**Attempted Recovery:**
7. User attempts to add a new valid delegatee with fresh delegation amount
8. Call to `SetTransactionFeeDelegateInfos` fails at the count check
9. Error: "The quantity of delegatee has reached its limit"

**Expected vs Actual:**
- **Expected:** Exhausted delegatees should be automatically removed when delegations reach zero, freeing slots
- **Actual:** Exhausted delegatees persist with zero-value entries, permanently blocking new delegatee additions until manual cleanup

**Success Condition:**
Verify that after consuming all delegations from 24 delegatees, the user cannot add a 25th delegatee even though all existing delegatees are functionally useless (have zero effective delegation).

**Notes**
The inconsistent state is created outside of `SetTransactionFeeDelegateInfos` itself - that function correctly enforces invariants. The vulnerability exists in the fee charging path (`ModifyDelegation`) which modifies delegation state without maintaining the same invariants. While users can manually clean up using removal functions, this requires awareness, additional transactions, and gas costs that should not be necessary for normal operations.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L208-210)
```csharp
            //If isUnlimitedDelegate is false,delegate info list should > 0.
            Assert(delegateInfo.IsUnlimitedDelegate || delegateInfo.Delegations.Count > 0,
                "Delegation cannot be null.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L226-227)
```csharp
                Assert(existDelegateeList.Count < TokenContractConstants.DELEGATEE_MAX_COUNT,
                    "The quantity of delegatee has reached its limit");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L233-242)
```csharp
            if (existDelegateeInfoList.Delegatees[delegateeAddress].Delegations.Count == 0 &&
                !existDelegateeInfoList.Delegatees[delegateeAddress].IsUnlimitedDelegate)
            {
                existDelegateeInfoList.Delegatees.Remove(delegateeAddress);
                toCancelTransactionList.Value.Add(new DelegateTransaction
                {
                    ContractAddress = delegateInfo.ContractAddress,
                    MethodName = delegateInfo.MethodName
                });
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L215-223)
```csharp
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            var delegateInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] ??
                State.TransactionFeeDelegateesMap[delegatorAddress];
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol] =
                delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol].Sub(amount);
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L18-18)
```csharp
    public const int DELEGATEE_MAX_COUNT = 24;
```
