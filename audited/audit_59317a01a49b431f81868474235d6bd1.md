### Title
Non-Deterministic Consensus Due to Insufficient Order Uniqueness Validation

### Summary
The consensus mechanism allows duplicate `FinalOrderOfNextRound` values to be accepted due to broken validation logic, leading to duplicate `Order` values in subsequent rounds. When multiple miners have the same `Order`, the `FirstMiner()` method's use of `FirstOrDefault()` on an unordered protobuf map introduces non-determinism, causing consensus failures and potential chain splits across nodes.

### Finding Description

**Root Cause:**

The vulnerability stems from three interrelated issues:

1. **Broken Validation Logic**: The `NextRoundMiningOrderValidationProvider` fails to detect duplicate `FinalOrderOfNextRound` values. At [1](#0-0) , it applies `.Distinct()` on `MinerInRound` objects, which uses reference equality by default, not value equality of the `FinalOrderOfNextRound` field. This means the validation counts distinct miner objects (by reference) rather than checking for unique order values.

2. **Unvalidated Order Assignment**: In `ProcessUpdateValue`, the `TuneOrderInformation` from user input directly sets `FinalOrderOfNextRound` without additional validation: [2](#0-1) . A malicious miner can craft `UpdateValueInput` with duplicate order assignments that bypass the broken validation.

3. **Non-Deterministic Dictionary Iteration**: The `RealTimeMinersInformation` field is defined as a protobuf map [3](#0-2) , which compiles to an unordered dictionary in C#. The `FirstMiner()` method uses `FirstOrDefault()` on this unordered collection: [4](#0-3) . When duplicate `Order` values exist, different nodes may return different miners due to undefined iteration order.

**Execution Path:**

1. During block generation, a miner calculates their consensus data via `GetConsensusExtraDataToPublishOutValue`, which calls `ApplyNormalConsensusData` to resolve order conflicts and populate `TuneOrderInformation`: [5](#0-4) 

2. The miner can manipulate `TuneOrderInformation` to assign duplicate `FinalOrderOfNextRound` values to multiple miners

3. During validation via `ValidateBeforeExecution`, the `NextRoundMiningOrderValidationProvider` is invoked but fails to detect duplicates: [6](#0-5) 

4. `ProcessUpdateValue` applies the malicious orders without additional checks

5. When `GenerateNextRoundInformation` creates the next round, it assigns `Order` values based on `FinalOrderOfNextRound`: [7](#0-6) . Duplicate `FinalOrderOfNextRound` values result in duplicate `Order` values.

6. Any subsequent call to `FirstMiner()` or other order-based lookups encounters non-deterministic behavior on the unordered dictionary

### Impact Explanation

**Consensus Failure and Chain Split:**
When different nodes execute `FirstMiner()` with duplicate orders in the dictionary, they may return different miners due to undefined iteration order. This causes nodes to:
- Calculate different round start times via `GetRoundStartTime()`: [8](#0-7) 
- Evaluate different mining eligibility in `IsTimeSlotPassed()`: [9](#0-8) 
- Produce different consensus hashes and round information

This non-determinism leads to consensus failures where nodes cannot agree on valid blocks, causing chain splits or network halts.

**Additional Impact:**
- The `BreakContinuousMining` function uses `.First()` to look up miners by order: [10](#0-9) , which would either throw exceptions or return arbitrary miners with duplicates
- Mining schedule integrity is compromised, violating critical consensus invariants
- All miners and validators are affected when the vulnerability is triggered

### Likelihood Explanation

**High Likelihood:**

1. **Reachable Entry Point**: Any miner can submit `UpdateValue` transactions: [11](#0-10) 

2. **Low Attack Complexity**: An attacker only needs to:
   - Become a miner (via election mechanism)
   - Craft `UpdateValueInput` with malicious `TuneOrderInformation` during their mining turn
   - Submit the transaction

3. **Feasible Preconditions**: The attack requires miner privileges, which are obtainable through the public election contract. No additional permissions or special conditions are needed.

4. **Practical Execution**: The malicious `TuneOrderInformation` bypasses validation because the check is fundamentally broken (using reference equality instead of value equality). The attack works on every execution.

5. **Detection Difficulty**: The non-determinism only manifests when different nodes execute consensus logic, making it appear as a consensus bug rather than a deliberate attack.

### Recommendation

**Immediate Fix:**

1. **Add Duplicate Detection in Validation**: Modify `NextRoundMiningOrderValidationProvider` to check for duplicate `FinalOrderOfNextRound` values: [12](#0-11) 
   
   Instead of checking distinct miner objects, validate that:
   - All `FinalOrderOfNextRound` values are unique
   - All values are in the range [1, minersCount]
   - All required orders from 1 to minersCount are covered

2. **Add Range Validation**: In `ProcessUpdateValue`, validate `TuneOrderInformation` values before applying them: [2](#0-1) 
   
   Check that all order values are within valid range and don't create duplicates.

3. **Add Deterministic Ordering**: Replace `FirstOrDefault()` in `FirstMiner()` with an explicit sort by pubkey to ensure deterministic ordering if duplicates somehow occur: [13](#0-12) 

**Test Cases:**
- Test that validation rejects `UpdateValue` with duplicate `FinalOrderOfNextRound` values
- Test that validation rejects out-of-range order values (0, negative, > minersCount)
- Test that `FirstMiner()` returns consistent results across multiple calls
- Test round generation with intentionally malformed order data

### Proof of Concept

**Initial State:**
- 5 active miners in current round (A, B, C, D, E)
- All miners have valid, unique `FinalOrderOfNextRound` values: A=2, B=4, C=1, D=5, E=3

**Attack Sequence:**

1. Miner A produces a block during their time slot and prepares `UpdateValueInput`

2. Miner A crafts malicious `TuneOrderInformation` setting:
   - B's `FinalOrderOfNextRound` = 1 (creating duplicate with C)
   - C's `FinalOrderOfNextRound` = 1 (keeping original)

3. Miner A submits `UpdateValue` with this crafted input

4. Validation runs `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()`:
   - Line 15-16 applies `.Distinct()` on miner objects (by reference)
   - Counts 5 distinct miner objects
   - Counts 5 miners with `OutValue != null`
   - Validation PASSES (incorrectly)

5. `ProcessUpdateValue` executes and applies the malicious orders:
   - B.FinalOrderOfNextRound = 1
   - C.FinalOrderOfNextRound = 1 (duplicate!)

6. Next round generation via `GenerateNextRoundInformation`:
   - Both B and C are assigned `Order = 1` in the next round
   
7. When any node calls `GetRoundStartTime()` or any code path using `FirstMiner()`:
   - Different nodes may return B or C randomly based on dictionary iteration order
   - Nodes calculate different round start times
   - Consensus failure occurs

**Expected Result:** Validation should reject the `UpdateValue` transaction with duplicate orders

**Actual Result:** Transaction succeeds, duplicate orders are stored, and consensus becomes non-deterministic in the next round

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** protobuf/aedpos_contract.proto (L247-247)
```text
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L92-92)
```csharp
        var actualStartTimes = FirstMiner().ActualMiningTimes;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L105-108)
```csharp
    public Timestamp GetRoundStartTime()
    {
        return FirstMiner().ExpectedMiningTime;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L142-148)
```csharp
    public MinerInRound FirstMiner()
    {
        return RealTimeMinersInformation.Count > 0
            ? RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == 1)
            // Unlikely.
            : new MinerInRound();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L86-86)
```csharp
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
