### Title
Negative Amount Exploit in NFT Contract UnApprove() Function Allows Arbitrary Allowance Inflation

### Summary
The `UnApprove()` function in the NFT contract fails to validate that `input.Amount` is positive before performing subtraction, allowing attackers to pass negative values that mathematically increase allowances instead of decreasing them. This breaks the allowance security model and enables unauthorized NFT transfers.

### Finding Description

The vulnerability exists in the `UnApprove()` function where `input.Amount` is defined as `int64` (signed integer) in the protobuf definition but lacks positive value validation. [1](#0-0) 

The function performs subtraction without checking if the amount is positive: [2](#0-1) 

When `input.Amount` is negative (e.g., -900), the operation `oldAllowance.Sub(input.Amount)` becomes `oldAllowance.Sub(-900)`, which mathematically equals `oldAllowance - (-900) = oldAllowance + 900`. The `Sub()` method in SafeMath performs checked arithmetic but only protects against overflow, not against the mathematical behavior of subtracting negative numbers: [3](#0-2) 

The only protection `if (currentAllowance <= 0) currentAllowance = 0;` is insufficient as it only prevents negative allowances, not inflated positive ones.

In contrast, the MultiToken contract properly validates the amount: [4](#0-3) [5](#0-4) 

### Impact Explanation

**Direct Fund Impact**: An attacker can arbitrarily inflate NFT allowances and use `TransferFrom()` to steal NFTs from owners who have granted any approval. The inflated allowance is validated and consumed in TransferFrom: [6](#0-5) 

**Who is Affected**: All NFT owners who have granted approvals, and all users of the NFT allowance system.

**Severity**: High - This breaks the fundamental security invariant that `UnApprove` should only decrease allowances, enabling theft of NFTs without owner consent beyond the originally intended approval amount.

### Likelihood Explanation

**Reachable Entry Point**: `UnApprove()` is a public function callable by any address that holds an approval.

**Attacker Capabilities**: 
- Any NFT owner can exploit their own approvals to grant themselves excessive allowance
- Any address with existing approval can inflate it to arbitrary amounts
- No special permissions or preconditions required

**Attack Complexity**: Trivial - single function call with a negative number as parameter.

**Economic Rationality**: Zero cost attack beyond transaction fees. Attacker gains ability to transfer NFTs they shouldn't have access to.

**Probability**: High - The attack is simple, requires no special conditions, and has high economic incentive for attackers targeting valuable NFTs.

### Recommendation

Add positive amount validation at the beginning of the `UnApprove()` function, identical to the MultiToken contract's approach:

```csharp
public override Empty UnApprove(UnApproveInput input)
{
    Assert(input.Amount > 0, "Invalid amount.");  // ADD THIS CHECK
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    var oldAllowance = State.AllowanceMap[tokenHash][Context.Sender][input.Spender];
    var currentAllowance = oldAllowance.Sub(input.Amount);
    if (currentAllowance <= 0) currentAllowance = 0;
    // ... rest of function
}
```

**Test Cases**:
1. Test that `UnApprove()` with negative amount reverts with "Invalid amount" error
2. Test that `UnApprove()` with zero amount reverts with "Invalid amount" error
3. Test that `UnApprove()` with positive amount correctly decreases allowance
4. Test that allowance cannot exceed original approved amount through UnApprove manipulation

### Proof of Concept

**Initial State**:
- Alice owns NFT with symbol "TEST", tokenId 1, balance 1000
- Bob has no allowance

**Attack Sequence**:
1. Alice calls `Approve(ApproveInput{spender: Bob, symbol: "TEST", token_id: 1, amount: 10})`
   - Bob's allowance = 10

2. Bob calls `UnApprove(UnApproveInput{spender: Bob, symbol: "TEST", token_id: 1, amount: -990})`
   - currentAllowance = 10.Sub(-990) = 10 - (-990) = 1000
   - Since 1000 > 0, not set to 0
   - Bob's allowance = 1000 (inflated from 10!)

3. Bob calls `TransferFrom(TransferFromInput{from: Alice, to: Bob, symbol: "TEST", token_id: 1, amount: 1000})`
   - Allowance check passes: 1000 >= 1000
   - Transfer succeeds
   - Bob steals 1000 NFT units with only 10 units originally approved

**Expected Result**: Step 2 should revert with "Invalid amount" error

**Actual Result**: Allowance inflated to 1000, enabling unauthorized transfer of 1000 units in step 3

### Citations

**File:** protobuf/nft_contract.proto (L160-165)
```text
message UnApproveInput {
    aelf.Address spender = 1;
    string symbol = 2;
    int64 token_id = 3;
    int64 amount = 4;
}
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L57-80)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var operatorList = State.OperatorMap[input.Symbol][input.From];
        var isOperator = operatorList?.Value.Contains(Context.Sender) ?? false;
        if (!isOperator)
        {
            var allowance = State.AllowanceMap[tokenHash][input.From][Context.Sender];
            Assert(allowance >= input.Amount, "Not approved.");
            State.AllowanceMap[tokenHash][input.From][Context.Sender] = allowance.Sub(input.Amount);
        }

        DoTransfer(tokenHash, input.From, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = input.From,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L310-328)
```csharp
    public override Empty UnApprove(UnApproveInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var oldAllowance = State.AllowanceMap[tokenHash][Context.Sender][input.Spender];
        var currentAllowance = oldAllowance.Sub(input.Amount);
        if (currentAllowance <= 0) currentAllowance = 0;

        State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = currentAllowance;

        Context.Fire(new UnApproved
        {
            Owner = Context.Sender,
            Spender = input.Spender,
            Symbol = input.Symbol,
            CurrentAllowance = currentAllowance,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L300-316)
```csharp
    public override Empty UnApprove(UnApproveInput input)
    {
        AssertValidInputAddress(input.Spender);
        var symbol = GetActualTokenSymbol(input.Symbol);
        AssertValidApproveTokenAndAmount(symbol, input.Amount);
        var oldAllowance = State.Allowances[Context.Sender][input.Spender][symbol];
        var amountOrAll = Math.Min(input.Amount, oldAllowance);
        State.Allowances[Context.Sender][input.Spender][symbol] = oldAllowance.Sub(amountOrAll);
        Context.Fire(new UnApproved
        {
            Owner = Context.Sender,
            Spender = input.Spender,
            Symbol = symbol,
            Amount = amountOrAll
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L41-45)
```csharp
    private void AssertValidApproveTokenAndAmount(string symbol, long amount)
    {
        Assert(amount > 0, "Invalid amount.");
        AssertApproveToken(symbol);
    }
```
