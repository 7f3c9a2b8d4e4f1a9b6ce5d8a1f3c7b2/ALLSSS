### Title
Side Chain Consensus Compromise via Unverified Main Chain Miner List

### Summary
The side chain consensus mechanism trusts the main chain miner list from `State.MainChainCurrentMinerList.Value` without cryptographic verification. An attacker who compromises the gRPC connection to the parent chain or achieves governance collusion can inject a fake miner list, resulting in complete takeover of the side chain's consensus mechanism.

### Finding Description

**Root Cause:** When `GenerateNextRoundInformation` detects a main chain miner list change on a side chain, it unconditionally uses `State.MainChainCurrentMinerList.Value` to generate the next consensus round without any cryptographic verification that this data authentically came from the main chain. [1](#0-0) 

**Data Flow Without Verification:**

1. **Miner List Source**: The main chain miner list is set in `UpdateInformationFromCrossChain`, which only verifies the sender is the CrossChain contract and performs basic structural checks, but does NOT cryptographically verify the data's authenticity: [2](#0-1) 

2. **Parent Chain Data Indexing**: The consensus information arrives via `IndexParentChainBlockData`, which extracts it from `ExtraData` and passes it to `UpdateConsensusInformation` without verifying block signatures or consensus proofs: [3](#0-2) 

3. **Validation Only Checks Structure**: The `ValidateParentChainBlockData` function only validates sequential heights, correct chain IDs, and non-null merkle roots—it does NOT verify the merkle root or block data is actually from the parent chain consensus: [4](#0-3) 

4. **Off-Chain Validation Trusts Cache**: The off-chain validation service compares proposed data against locally cached data from gRPC, but never verifies the cached data itself came from legitimate parent chain consensus: [5](#0-4) 

5. **Cache Populated via Unverified gRPC**: The cache is populated by requesting data from remote chains via gRPC without any cryptographic verification: [6](#0-5) 

**Why Protections Fail:**

- No signature verification of parent chain block headers
- No verification of parent chain consensus (e.g., validating miner signatures)
- No merkle proof verification at data ingestion time
- Governance approval (Parliament organization) can be achieved through miner collusion
- The entire trust model relies on the integrity of the gRPC connection and cache, not cryptographic proofs

### Impact Explanation

**Complete Side Chain Consensus Takeover:**

Once a fake miner list is accepted as the main chain's current miner list, the side chain uses it to generate all subsequent consensus rounds. This gives attackers:

1. **Full Control Over Block Production**: The attacker-controlled miners can produce all blocks, enabling:
   - Double-spending attacks (reorg any transaction)
   - Censorship (exclude any transaction/user)
   - Protocol manipulation (execute any transaction)

2. **Economic Damage**: 
   - All tokens and assets on the side chain are at risk
   - Cross-chain bridges become compromised
   - Complete loss of side chain value

3. **Affected Parties**:
   - All side chain users and dApp operators
   - Main chain reputation (security model broken)
   - Cross-chain asset holders

**Severity Justification**: This is CRITICAL because it breaks the fundamental consensus security invariant, allowing complete protocol takeover without requiring private key compromise.

### Likelihood Explanation

**Attack Complexity: Medium-High**

**Required Attacker Capabilities:**

*Scenario A - Governance Collusion:*
1. Control or collude with majority of miners in CrossChainIndexingController (Parliament organization)
2. Propose fake parent chain data via `ProposeCrossChainIndexing`
3. Approve the proposal through controlled governance
4. Execute `ReleaseCrossChainIndexingProposal` to index the fake data [7](#0-6) 

*Scenario B - gRPC Connection Compromise (Lower Bar):*
1. Compromise the gRPC connection to parent chain (MitM attack, DNS hijacking, or malicious node operator)
2. Inject fake parent chain data into cache
3. Any honest miner proposes the (poisoned) cached data
4. Honest governance approves it (believing it's legitimate)

**Feasibility Conditions:**

- **Entry Point Reachable**: `ProposeCrossChainIndexing` is a public method requiring current miner status
- **Preconditions Realistic**: 
  - In PoS systems, large stakeholders can achieve miner majority
  - gRPC connections are vulnerable to network-level attacks
  - Node operators control which remote chains to connect to
- **Economic Rationality**: Extremely high—attacker gains control of entire side chain
- **Detection Difficulty**: No on-chain detection mechanism exists until consensus is already compromised

**Probability Assessment**: While requiring either governance compromise or infrastructure control, the complete lack of cryptographic verification makes this attack feasible for well-resourced adversaries or coordinated miner cartels.

### Recommendation

**Immediate Mitigations:**

1. **Add Cryptographic Verification in UpdateInformationFromCrossChain:**

Verify parent chain block signatures before accepting consensus data. The consensus information should include verifiable proofs:

```
- Require parent chain block header with miner signatures
- Verify signatures against known parent chain validator set
- Implement light client-style verification of parent chain consensus
``` [8](#0-7) 

2. **Implement Merkle Proof Verification at Ingestion:**

Before storing `TransactionStatusMerkleTreeRoot`, verify it's actually part of a valid parent chain block using consensus proofs. [9](#0-8) 

3. **Add Consensus State Verification:**

Include verifiable parent chain state roots in cross-chain data and validate them against known checkpoints or light client state.

4. **Implement Fraud Proofs:**

Add a challenge period where validators can submit proofs that parent chain data is invalid before it affects consensus.

**Test Cases to Add:**

- Test rejection of parent chain data with invalid signatures
- Test rejection of parent chain data with incorrect consensus proofs  
- Test that fake miner lists cannot be injected via compromised gRPC
- Test fraud proof submission and validation
- Test rollback mechanism if fake data is detected post-acceptance

### Proof of Concept

**Attack Sequence:**

1. **Initial State:**
   - Side chain operating normally with legitimate main chain miner list
   - Attacker controls gRPC endpoint or has governance majority

2. **Attack Execution:**

   **Step 1 - Poison Cache (if using gRPC attack):**
   - Attacker intercepts gRPC connection or operates malicious parent chain node
   - Sends fake `ParentChainBlockData` with malicious consensus miner list in `ExtraData["Consensus"]`
   - Cache populated via `TryAddBlockCacheEntity` [10](#0-9) 

   **Step 2 - Propose Fake Data:**
   - Miner calls `ProposeCrossChainIndexing` with fake parent chain data
   - Validation passes because data matches poisoned cache [11](#0-10) 

   **Step 3 - Approve via Governance:**
   - Parliament organization (controlled or deceived) approves proposal
   - Proposal marked as `ToBeReleased = true`

   **Step 4 - Execute Indexing:**
   - Call `ReleaseCrossChainIndexingProposal`
   - `RecordCrossChainData` -> `IndexParentChainBlockData` executes
   - `UpdateConsensusInformation` called with fake consensus data [12](#0-11) 

   **Step 5 - Consensus Takeover:**
   - `State.MainChainCurrentMinerList.Value` now contains attacker's miner list
   - Next block triggers `GenerateNextRoundInformation`
   - `IsMainChainMinerListChanged` returns true
   - Fake miner list used to generate next round [1](#0-0) 

3. **Expected Result:**
   - Side chain rejects fake parent chain data due to cryptographic verification failure

4. **Actual Result:**
   - Fake miner list accepted and used for consensus
   - Attacker controls all subsequent blocks
   - Complete side chain consensus compromise

**Success Condition:** After Step 5, the attacker's controlled addresses are the only valid block producers, confirmed by querying `GetCurrentMinerList()`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-295)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-64)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L720-743)
```csharp
    private bool ValidateParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData,
        out Dictionary<int, List<ParentChainBlockData>> validatedParentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
        foreach (var blockData in parentChainBlockData)
        {
            if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
                blockData.TransactionStatusMerkleTreeRoot == null)
                return false;
            if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
                    State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
                    State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
                return false;

            currentHeight += 1;
        }

        if (parentChainBlockData.Count > 0)
            validatedParentChainBlockData[parentChainId] = parentChainBlockData.ToList();

        return true;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L761-807)
```csharp
    private IndexedParentChainBlockData IndexParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        var indexedParentChainBlockData = new IndexedParentChainBlockData
        {
            LocalChainHeight = Context.CurrentHeight
        };
        for (var i = 0; i < parentChainBlockData.Count; i++)
        {
            var blockInfo = parentChainBlockData[i];
            AssertParentChainBlock(parentChainId, currentHeight, blockInfo);
            var parentChainHeight = blockInfo.Height;
            State.ParentChainTransactionStatusMerkleTreeRoot[parentChainHeight] =
                blockInfo.TransactionStatusMerkleTreeRoot;
            foreach (var indexedBlockInfo in blockInfo.IndexedMerklePath)
            {
                BindParentChainHeight(indexedBlockInfo.Key, parentChainHeight);
                AddIndexedTxRootMerklePathInParentChain(indexedBlockInfo.Key, indexedBlockInfo.Value);
            }

            // send consensus data shared from main chain  
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }

            if (blockInfo.CrossChainExtraData != null)
                State.TransactionMerkleTreeRootRecordedInParentChain[parentChainHeight] =
                    blockInfo.CrossChainExtraData.TransactionStatusMerkleTreeRoot;

            indexedParentChainBlockData.ParentChainBlockDataList.Add(blockInfo);
            currentHeight += 1;
        }

        State.CurrentParentChainHeight.Value = currentHeight;
        
        Context.Fire(new ParentChainIndexed
        {
            ChainId = parentChainId,
            IndexedHeight = currentHeight
        });

        return indexedParentChainBlockData;
    }
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataValidationService.cs (L117-173)
```csharp
    private async Task<bool> ValidateParentChainBlockDataAsync(
        IEnumerable<ParentChainBlockData> multiParentChainBlockData,
        Hash blockHash, long blockHeight)
    {
        var parentChainBlockDataList = multiParentChainBlockData.ToList();
        if (parentChainBlockDataList.Count == 0)
            return true;
        var crossChainContractAddress = await GetCrossChainContractAddressAsync(new ChainContext
        {
            BlockHash = blockHash,
            BlockHeight = blockHeight
        });
        var parentChainId = (await _contractReaderFactory
            .Create(new ContractReaderContext
            {
                BlockHash = blockHash,
                BlockHeight = blockHeight,
                ContractAddress = crossChainContractAddress
            }).GetParentChainId
            .CallAsync(new Empty())).Value;
        if (parentChainId == 0)
            // no configured parent chain
            return false;

        var length = parentChainBlockDataList.Count;
        var i = 0;
        var targetHeight = (await _contractReaderFactory.Create(new ContractReaderContext
            {
                BlockHash = blockHash,
                BlockHeight = blockHeight,
                ContractAddress = crossChainContractAddress
            }).GetParentChainHeight
            .CallAsync(new Empty())).Value + 1;
        while (i < length)
        {
            var parentChainBlockData =
                _blockCacheEntityConsumer.Take<ParentChainBlockData>(parentChainId, targetHeight, false);
            if (parentChainBlockData == null)
            {
                Logger.LogDebug(
                    $"Parent chain data not found. Parent chain height: {targetHeight}.");
                return false;
            }

            if (!parentChainBlockDataList[i].Equals(parentChainBlockData))
            {
                Logger.LogDebug(
                    $"Incorrect parent chain data. Parent chain height: {targetHeight}.");
                return false;
            }

            targetHeight++;
            i++;
        }

        return true;
    }
```

**File:** src/AElf.CrossChain.Core/Application/CrossChainRequestService.cs (L28-49)
```csharp
    public async Task RequestCrossChainDataFromOtherChainsAsync()
    {
        var chainIdHeightDict = GetNeededChainIdAndHeightPairs();

        foreach (var chainIdHeightPair in chainIdHeightDict)
        {
            var chainIdBased58 = ChainHelper.ConvertChainIdToBase58(chainIdHeightPair.Key);
            Logger.LogDebug(
                $"Try to request from chain {chainIdBased58}, from height {chainIdHeightPair.Value}");
            try
            {
                var client = await _crossChainClientService.GetConnectedCrossChainClientAsync(chainIdHeightPair.Key);
                if (client != null)
                    await client.RequestCrossChainDataAsync(chainIdHeightPair.Value,
                        b => _blockCacheEntityProducer.TryAddBlockCacheEntity(b));
            }
            catch (CrossChainRequestException e)
            {
                Logger.LogWarning(e, $"Request chain {chainIdBased58} failed.");
            }
        }
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-302)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }

    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** src/AElf.CrossChain.Core/Cache/Application/IBlockCacheEntityProducer.cs (L24-36)
```csharp
    public bool TryAddBlockCacheEntity(ICrossChainBlockEntity crossChainBlockEntity)
    {
        if (crossChainBlockEntity == null)
            throw new ArgumentNullException(nameof(crossChainBlockEntity));
        if (!_crossChainCacheEntityProvider.TryGetChainCacheEntity(crossChainBlockEntity.ChainId,
                out var chainCacheEntity)) return false;

        var res = chainCacheEntity.TryAdd(crossChainBlockEntity);

        Logger.LogDebug(
            $"Cached height {crossChainBlockEntity.Height} from chain {ChainHelper.ConvertChainIdToBase58(crossChainBlockEntity.ChainId)}, {res}");
        return res;
    }
```
