### Title
Inconsistent Miner Count Calculation Between GetMinersCount() and GetMaximumMinersCount() Causes Election Contract State Divergence

### Summary
The `GetMinersCount(Round input)` function conditionally applies time-based auto-increase only when the current round has at least 17 miners, while `GetMaximumMinersCount()` unconditionally applies the same auto-increase formula. This inconsistency causes `SetMaximumMinersCount()` to send a different miner count to the Election contract than what external systems observe via `GetMaximumMinersCount()`, resulting in fewer miners being elected than the blockchain age warrants.

### Finding Description

The root cause lies in divergent logic between two miner count calculation functions:

**GetMinersCount(Round input)** uses conditional auto-increase logic: [1](#0-0) 

This function checks `input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount` (17). If true, it returns exactly 17 without applying the time-based auto-increase formula. Only when the round has ≥17 miners does it apply: `SupposedMinersCount + (blockchain_age / MinerIncreaseInterval) * 2`.

**GetMaximumMinersCount()** unconditionally applies auto-increase: [2](#0-1) 

This calls `GetAutoIncreasedMinersCount()` which always calculates: [3](#0-2) 

**SetMaximumMinersCount()** sends the inconsistent value to Election: [4](#0-3) 

At line 25, it calls `GetMinersCount(round)` and sends the result to the Election contract via `UpdateMinersCount`. The Election contract stores this value: [5](#0-4) 

The Election contract's `GetVictories()` function uses this stored `State.MinersCount.Value` to determine how many candidates to elect: [6](#0-5) 

**Concrete Scenario:**
- Blockchain has been running for sufficient time that auto-increase should add 4 miners (theoretical max: 21)
- Current round has only 12 miners (e.g., side chain initialization or after miner ejections)
- Parliament governance calls `SetMaximumMinersCount(50)` to set a high cap
- `GetMinersCount(round)` evaluates: 12 < 17, returns 17 (no auto-increase)
- Election contract receives and stores: `MinersCount = 17`
- But `GetMaximumMinersCount()` returns: 21 (17 + 4)
- `GetVictories()` elects only 17 miners instead of 21

### Impact Explanation

**Operational Impact on Consensus Integrity:**
- The Election contract elects fewer miners than the blockchain's maturity level warrants
- Reduces intended decentralization by limiting miner set below theoretical maximum
- Creates state inconsistency where external systems querying `GetMaximumMinersCount()` observe value 21, but Election targets only 17 miners
- Legitimate candidates who should be elected based on the auto-increase schedule are excluded

**Affected Parties:**
- Candidate nodes expecting election based on published maximum miner count
- Network decentralization and security (fewer miners than intended)
- External systems and users monitoring `GetMaximumMinersCount()` for planning

**Severity Justification:**
Medium severity because while it doesn't cause direct fund theft, it compromises consensus system integrity and creates persistent state inconsistency affecting miner elections and network decentralization.

### Likelihood Explanation

**Preconditions:**
- Current round must have fewer than 17 miners (SupposedMinersCount)
- Parliament governance must call `SetMaximumMinersCount()`
- Blockchain age must be sufficient for auto-increase to be non-zero

**When This Occurs:**
1. **Side chain initialization**: Side chains often start with fewer than 17 miners
2. **After miner ejections**: When multiple evil miners are detected and removed mid-term
3. **Early blockchain lifecycle**: During initial bootstrapping before reaching full miner set
4. **Test environments**: Commonly run with reduced miner counts

**Attack Complexity:**
- Does not require attacker control; can occur through normal governance operations
- Parliament governance legitimately calling `SetMaximumMinersCount()` triggers the issue
- Timing-dependent: only manifests when current round has < 17 miners

**Feasibility:**
The issue will naturally occur during legitimate governance actions in the scenarios listed above. While it requires parliamentary authorization (not an unauthorized exploit), the inconsistency represents a logic flaw that affects system correctness.

### Recommendation

**Fix the conditional logic inconsistency:**

Modify `GetMinersCount(Round input)` to unconditionally apply the auto-increase formula, matching `GetMaximumMinersCount()` behavior:

```csharp
private int GetMinersCount(Round input)
{
    if (State.BlockchainStartTimestamp.Value == null) 
        return AEDPoSContractConstants.SupposedMinersCount;
    
    if (!TryToGetRoundInformation(1, out _)) 
        return 0;
    
    // Remove conditional check - always apply auto-increase
    return Math.Min(
        AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2)), 
        State.MaximumMinersCount.Value);
}
```

**Add invariant validation:**
Add a test that verifies `GetMinersCount(round)` and `GetMaximumMinersCount()` return consistent values regardless of the current round's actual miner count.

**Regression test:**
Create test case simulating side chain with 10 miners calling `SetMaximumMinersCount()` after sufficient blockchain age, verifying Election receives the full auto-increased count.

### Proof of Concept

**Initial State:**
- Blockchain started timestamp: T0
- Current time: T0 + 365 days
- MinerIncreaseInterval: 31536000 seconds (1 year)
- Auto-increase calculation: (365*24*60*60 / 31536000) * 2 = 2 miners
- Expected maximum: 17 + 2 = 19 miners
- Current round has 12 miners (side chain scenario)
- State.MaximumMinersCount.Value = 50

**Transaction Sequence:**
1. Parliament governance creates proposal to call `SetMaximumMinersCount(50)`
2. Proposal gets approved and executed
3. `SetMaximumMinersCount()` executes at line 10-29
4. Line 20: `TryToGetCurrentRoundInformation(out var round)` retrieves round with 12 miners
5. Line 25: `GetMinersCount(round)` called
6. In `GetMinersCount()` at line 386: condition `12 < 17` evaluates to `true`
7. Returns `SupposedMinersCount = 17` (without auto-increase)
8. Line 23-26: Election contract receives `UpdateMinersCountInput { MinersCount = 17 }`
9. Election stores `State.MinersCount.Value = 17`

**Expected vs Actual Result:**
- **Expected**: Election should receive 19 (17 + 2 auto-increase)
- **Actual**: Election receives 17 (no auto-increase due to conditional)
- **Query `GetMaximumMinersCount()`**: Returns 19
- **Query Election's `GetMinersCount()`**: Returns 17
- **Inconsistency confirmed**: 19 ≠ 17

**Success Condition:**
Call both functions and observe different return values despite representing the "maximum" miner count for the same blockchain state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L72-78)
```csharp
    public override Int32Value GetMaximumMinersCount(Empty input)
    {
        return new Int32Value
        {
            Value = Math.Min(GetAutoIncreasedMinersCount(), State.MaximumMinersCount.Value)
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```
