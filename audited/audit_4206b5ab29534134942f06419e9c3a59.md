### Title
Term Transition Failure Due to Offline Miner Threshold Causing Indefinite Miner Entrenchment and Treasury Halt

### Summary
The `NeedToChangeTerm()` function contains a critical flaw where it compares the count of active miners (who have produced blocks) with timestamps beyond the term boundary against `MinersCountOfConsent` (2/3+1 of total miners). If more than 1/3 of miners are offline or have not produced blocks, term transitions will fail even when all active miners agree the term should change, causing `GetConsensusBehaviourToTerminateCurrentRound()` to incorrectly return `NextRound` instead of `NextTerm`, permanently preventing miner list updates, election result application, treasury releases, and mining reward distributions.

### Finding Description

**Root Cause Location:**

The vulnerability exists in `NeedToChangeTerm()` [1](#0-0) , which filters for miners with `ActualMiningTimes.Any()` and counts how many have timestamps indicating a new term, then compares against `MinersCountOfConsent`.

The threshold `MinersCountOfConsent` is calculated as: [2](#0-1) 

This calculation is based on the **total** miner count from `RealTimeMinersInformation.Count`, not the count of active miners.

**Flawed Logic Flow:**

1. `GetConsensusBehaviourToTerminateCurrentRound()` [3](#0-2)  returns `NextRound` if `!NeedToChangeTerm()` evaluates to true.

2. When miners are offline (no `ActualMiningTimes`), they are excluded from the count but `MinersCountOfConsent` still requires 2/3+1 of **all** miners, not just active ones.

3. Example: With 17 total miners, `MinersCountOfConsent = 12`. If only 11 miners have produced blocks (6 are offline), even if all 11 active miners have timestamps in the next term period, `NeedToChangeTerm()` returns false (11 < 12).

**Why Existing Protections Fail:**

The `IsTimeToChangeTerm()` helper [4](#0-3)  correctly identifies when a timestamp crosses the term boundary, but the aggregation logic in `NeedToChangeTerm()` fails to account for offline miners when determining consensus.

### Impact Explanation

When `NextRound` is incorrectly executed instead of `NextTerm`, the following critical operations are permanently skipped:

**1. Miner List Never Updates:**
`ProcessNextTerm()` calls `SetMinerList()` [5](#0-4)  to update `State.MinerListMap[termNumber]` with new miners from election results obtained via `TryToGetVictories()` [6](#0-5) . `ProcessNextRound()` [7](#0-6)  does NOT perform this update. Old miners retain power indefinitely despite being voted out.

**2. Election Results Never Applied:**
`UpdateCurrentMinerInformationToElectionContract()` [8](#0-7)  syncs miner performance data (produced blocks, missed time slots) to the Election contract, which is called only in `ProcessNextTerm()` [9](#0-8) . Without this, voting and candidate rankings become meaningless.

**3. Treasury Releases Halt:**
`State.TreasuryContract.Release.Send()` [10](#0-9)  distributes treasury funds for each term period, only called in `ProcessNextTerm()`. Fund distribution to stakeholders permanently stops.

**4. Mining Rewards Not Donated:**
`DonateMiningReward()` [11](#0-10)  calculates and donates mining rewards to the Treasury, called only in `ProcessNextTerm()` [12](#0-11) . The reward economy breaks down.

**5. Election Snapshots Not Taken:**
`State.ElectionContract.TakeSnapshot.Send()` [13](#0-12)  records voting weights for the term, only in `ProcessNextTerm()`. Voting power calculations become stale.

**6. Term Number Frozen:**
`TryToUpdateTermNumber()` [14](#0-13)  increments `State.CurrentTermNumber.Value` [15](#0-14) , only in `ProcessNextTerm()`. The blockchain remains stuck on the old term number, creating state inconsistency.

**Severity:** CRITICAL - Breaks core governance, consensus integrity, and economic mechanisms. Elected miners cannot take office, treasury distributions cease, and incumbent miners entrench themselves indefinitely.

### Likelihood Explanation

**Attack Vectors:**

1. **Natural Network Issues:** During network partitions, DDoS attacks, or infrastructure failures, >1/3 of miners naturally going offline triggers this bug without malicious intent.

2. **Coordinated Miner Collusion:** Current miners facing election defeat can coordinate to stop producing blocks (requires >1/3 colluding) to prevent term transitions and retain power.

3. **Targeted DDoS:** Attackers can selectively DDoS specific miners to push the offline count above the 1/3 threshold.

**Feasibility Conditions:**

- **Precondition:** More than `(total_miners - MinersCountOfConsent)` miners must not produce blocks during the round when term should transition.
- **Example:** With 17 miners and `MinersCountOfConsent = 12`, only 6 miners need to be offline (17 - 12 + 1 = 6).
- **Reachable Entry Point:** Any miner executing consensus commands reaches `GetConsensusBehaviourToTerminateCurrentRound()` [16](#0-15)  when terminating a round.

**Economic Rationality:**

- Miners about to lose election have direct financial incentive to prevent term transition (retain mining rewards).
- Cost to coordinate 6 out of 17 miners is reasonable for maintaining lucrative mining positions.
- DDoS attacks on 6 nodes are technically and economically feasible.

**Detection Difficulty:**

This appears as miners being "offline" which is hard to distinguish from legitimate network issues versus intentional manipulation. No on-chain mechanism exists to differentiate.

### Recommendation

**Code-Level Mitigation:**

Modify `NeedToChangeTerm()` to calculate the threshold based on **active miners** who have produced blocks, not total miners:

```csharp
public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
{
    var activeMinersWithTimes = RealTimeMinersInformation.Values
        .Where(m => m.ActualMiningTimes.Any())
        .ToList();
    
    if (!activeMinersWithTimes.Any())
        return false;
    
    // Calculate consent threshold based on active miners
    var activeMinerConsent = activeMinersWithTimes.Count.Mul(2).Div(3).Add(1);
    
    var minersIndicatingNewTerm = activeMinersWithTimes
        .Select(m => m.ActualMiningTimes.Last())
        .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp, t, currentTermNumber, periodSeconds));
    
    return minersIndicatingNewTerm >= activeMinerConsent;
}
```

**Additional Safeguards:**

1. Add a maximum term duration check: if current time exceeds `(termNumber + 1) * periodSeconds`, force `NextTerm` regardless of miner consent.

2. Track consecutive `NextRound` calls without `NextTerm` and trigger alerts when threshold exceeded.

3. Implement fallback mechanism: if term hasn't changed within 1.5x the period, allow term transition with simple majority of active miners.

**Test Cases:**

1. Test with 17 miners, 11 active (all with new term timestamps) → should trigger `NextTerm` (currently fails)
2. Test with various offline percentages (25%, 35%, 45%) → verify correct behavior
3. Test malicious scenario where exactly 1/3+1 miners refuse to mine → should still transition
4. Test maximum term duration override mechanism

### Proof of Concept

**Initial State:**
- Total miners: 17 (configured in `RealTimeMinersInformation`)
- Current term number: 1
- Term period: 604800 seconds (7 days) [1](#0-0) 
- Blockchain start timestamp: T₀
- Current time: T₀ + 604800 (exactly at term boundary)
- Election has completed with new miner list ready

**Exploit Sequence:**

1. **Setup Phase:** 6 miners (exactly enough to prevent consensus) coordinate to not produce blocks during the final round of term 1.

2. **Round Execution:** 11 miners produce blocks normally. All 11 blocks have timestamps > T₀ + 604800, indicating term 2 should begin.

3. **Term Transition Check:**
   - Active miners with blocks: 11
   - All 11 have `IsTimeToChangeTerm() == true`
   - `MinersCountOfConsent = 17 * 2 / 3 + 1 = 12`
   - Count of miners indicating new term: 11
   - `NeedToChangeTerm()` returns false (11 < 12)

4. **Behavior Selection:**
   - `GetConsensusBehaviourToTerminateCurrentRound()` returns `NextRound` (not `NextTerm`)
   - `ProcessNextRound()` executes instead of `ProcessNextTerm()`

5. **Result:**
   - Miner list NOT updated: old 17 miners remain active
   - Election winners cannot take office despite winning election
   - Treasury release NOT triggered: stakeholders don't receive distributions
   - Mining rewards NOT donated: economic incentives broken
   - Term number remains at 1: state diverges from expected term 2

**Expected vs Actual:**

- **Expected:** After time crosses term boundary with 2/3 active miner agreement, `NextTerm` executes, new miners take office, treasury releases, rewards distributed.
- **Actual:** System executes `NextRound`, old miners retain power indefinitely, all term-based operations permanently blocked.

**Success Condition:** Blockchain continues operating but with old miner set, no treasury releases, and term number frozen at 1 despite time progressing to term 2+. The 6 offline miners can rejoin in the next round, repeating the attack for subsequent terms.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L239-243)
```csharp
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L173-173)
```csharp
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L201-201)
```csharp
        UpdateCurrentMinerInformationToElectionContract(previousRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-203)
```csharp
        if (DonateMiningReward(previousRound))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L205-208)
```csharp
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-51)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L98-105)
```csharp
    private bool TryToUpdateTermNumber(long termNumber)
    {
        var oldTermNumber = State.CurrentTermNumber.Value;
        if (termNumber != 1 && oldTermNumber + 1 != termNumber) return false;

        State.CurrentTermNumber.Value = termNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```
