### Title
Assembled NFTs Can Be Minted Multiple Times Allowing Disassembly Without Returning Locked Assets

### Summary
When an NFT protocol has `IsTokenIdReuse = true`, minters can call `Mint()` to increase the quantity of an already-assembled NFT, creating additional copies that are not backed by locked assets in `AssembledNftsMap`. Subsequent disassemblies of these fake copies burn the NFT but return nothing, causing permanent loss of value and breaking the invariant that assembled NFTs should always be backed by their locked components.

### Finding Description

The vulnerability exists in the interaction between `Assemble()` and `Mint()` in `NFTContract_UseChain.cs`.

When `Assemble()` is called, it creates an assembled NFT and stores the locked assets in `AssembledNftsMap`: [1](#0-0) 

The critical line is where `PerformMint()` is called with `isTokenIdMustBeUnique = true`: [2](#0-1) 

However, after assembly, a minter can call the public `Mint()` method with the same `tokenId`. The `Mint()` method calls `PerformMint()` with `isTokenIdMustBeUnique = false` (default parameter): [3](#0-2) 

In `PerformMint()`, the token ID reuse check only triggers if `IsTokenIdReuse` is false OR `isTokenIdMustBeUnique` is true: [4](#0-3) 

For protocols with `IsTokenIdReuse = true`, when `isTokenIdMustBeUnique = false` (regular Mint), the check evaluates to `if (!true || false)` = `if (false)`, allowing the mint to proceed. The code then increases the NFT quantity: [5](#0-4) 

This creates multiple copies of the assembled NFT, but `AssembledNftsMap` only has ONE entry per token hash (keyed by the hash of symbol + tokenId): [6](#0-5) 

When `Disassemble()` is called, it burns one copy, retrieves the locked assets from `AssembledNftsMap`, transfers them back, and removes the map entry: [7](#0-6) 

A second `Disassemble()` call will burn another copy successfully, but when it tries to retrieve from `AssembledNftsMap`, the entry is gone (removed at line 209), so no assets are returned. The NFT is burned without returning its supposed backing.

### Impact Explanation

**Direct Fund Impact**: Permanent loss of locked NFT value. When fake assembled NFTs (those minted after the initial assembly) are disassembled, they are burned but the locked assets are not returned because the `AssembledNftsMap` entry was already removed by the first disassembly.

**Affected Parties**:
- Holders of fake assembled NFTs who expect to receive locked assets upon disassembly
- The protocol's integrity, as it allows existence of unbacked assembled NFTs
- Market participants who may trade these fake assembled NFTs at full value

**Severity**: Critical - This breaks a fundamental invariant that assembled NFTs should always be backed by their locked components. The locked NFTs (which could have significant value) are permanently lost when fake copies are burned.

### Likelihood Explanation

**Attacker Capabilities Required**:
1. Must be a minter of an NFT protocol (added by protocol creator via `AddMinters()`)
2. Protocol must have `IsTokenIdReuse = true` (set during protocol creation)
3. Protocol must have `IsBurnable = true` (required for Disassemble to work) [8](#0-7) 

**Attack Complexity**: Low - straightforward sequence of public method calls (Assemble → Mint → Disassemble → Disassemble)

**Feasibility**: High - While requiring minter role is a constraint, this is a legitimate and commonly granted capability. Protocols may enable `IsTokenIdReuse` for legitimate use cases (re-minting after burn). The Burn function's unusual requirement that only minters can burn means this affects the minter community specifically.

**Detection**: Difficult - the fake assembled NFTs appear identical to real ones in terms of token hash, symbol, and token ID. Only by checking the actual `AssembledNftsMap` state or attempting disassembly would the issue be discovered.

### Recommendation

**Code-Level Mitigation**:
1. Add a check in `PerformMint()` to prevent minting additional copies of assembled NFTs regardless of `IsTokenIdReuse` setting:

```csharp
// After line 394 in PerformMint
var isAssembledNft = State.AssembledNftsMap[tokenHash] != null || 
                     State.AssembledFtsMap[tokenHash] != null;
if (isAssembledNft && nftInfo != null)
    Assert(false, "Cannot mint additional copies of assembled NFTs. TokenId already used for assembly.");
```

2. Alternative: Store a flag in NFT metadata or NFTInfo indicating if an NFT was created through assembly, and check this flag in `PerformMint()`.

**Invariant Checks**:
- Add assertion: `assembled NFT quantity == 1 && AssembledNftsMap[tokenHash] exists` OR `quantity > 0 && AssembledNftsMap[tokenHash] does not exist`
- Verify in tests that after Disassemble, both the NFT quantity is 0 AND the AssembledNftsMap entry is removed

**Test Cases**:
1. Test that Mint() with same tokenId as assembled NFT fails
2. Test that attempting to disassemble twice fails appropriately
3. Test with `IsTokenIdReuse = true` and `false` to ensure both cases are covered

### Proof of Concept

**Initial State**:
- NFT Protocol "TEST" created with `IsTokenIdReuse = true`, `IsBurnable = true`
- Alice is a minter
- Alice owns NFT-A and NFT-B (to be used for assembly)

**Attack Steps**:

1. Alice calls `Assemble(symbol="TEST", tokenId=1, assembledNfts={NFT-A: 1, NFT-B: 1})`
   - Result: Assembled NFT "TEST-1" created with quantity=1, AssembledNftsMap[hash("TEST1")] = {NFT-A: 1, NFT-B: 1}

2. Alice calls `Mint(symbol="TEST", tokenId=1, quantity=1)`
   - Expected: Should fail (tokenId already exists for assembled NFT)
   - Actual: Succeeds, quantity of TEST-1 increases to 2

3. Alice calls `Disassemble(symbol="TEST", tokenId=1)` (first time)
   - Result: Burns 1 copy (quantity: 2→1), transfers NFT-A and NFT-B back to Alice, removes AssembledNftsMap entry

4. Alice calls `Disassemble(symbol="TEST", tokenId=1)` (second time)
   - Expected: Should fail or return the locked NFTs
   - Actual: Burns 1 copy (quantity: 1→0), but AssembledNftsMap[hash("TEST1")] is null, so NO NFTs are returned

**Success Condition**: After step 4, the second assembled NFT copy was burned but Alice did not receive NFT-A and NFT-B back (they were already retrieved in step 3). The second copy was effectively an unbacked assembled NFT.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L12-19)
```csharp
    public override Hash Mint(MintInput input)
    {
        if (input.Metadata != null && input.Metadata.Value.Any())
            AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var nftMinted = PerformMint(input);
        return nftMinted.TokenHash;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-93)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L113-189)
```csharp
    public override Hash Assemble(AssembleInput input)
    {
        if (input.Metadata != null && input.Metadata.Value.Any())
            AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var metadata = input.Metadata ?? new Metadata();

        if (input.AssembledNfts.Value.Any())
        {
            metadata.Value[AssembledNftsKey] = input.AssembledNfts.ToString();
            // Check owner.
            foreach (var pair in input.AssembledNfts.Value)
            {
                var nftHash = Hash.LoadFromHex(pair.Key);
                var nftInfo = GetNFTInfoByTokenHash(nftHash);
                Assert(State.BalanceMap[nftHash][Context.Sender] >= pair.Value,
                    $"Insufficient balance of {nftInfo.Symbol}{nftInfo.TokenId}.");
                DoTransfer(nftHash, Context.Sender, Context.Self, pair.Value);
            }
        }

        if (input.AssembledFts.Value.Any())
        {
            metadata.Value[AssembledFtsKey] = input.AssembledFts.ToString();
            // Check balance and allowance.
            foreach (var pair in input.AssembledFts.Value)
            {
                var symbol = pair.Key;
                var amount = pair.Value;
                var balance = State.TokenContract.GetBalance.Call(new MultiToken.GetBalanceInput
                {
                    Owner = Context.Sender,
                    Symbol = symbol
                }).Balance;
                Assert(balance >= amount, $"Insufficient balance of {symbol}");
                var allowance = State.TokenContract.GetAllowance.Call(new MultiToken.GetAllowanceInput
                {
                    Owner = Context.Sender,
                    Spender = Context.Self,
                    Symbol = symbol
                }).Allowance;
                Assert(allowance >= amount, $"Insufficient allowance of {symbol}");
                State.TokenContract.TransferFrom.Send(new MultiToken.TransferFromInput
                {
                    From = Context.Sender,
                    To = Context.Self,
                    Symbol = symbol,
                    Amount = amount
                });
            }
        }

        var mingInput = new MintInput
        {
            Symbol = input.Symbol,
            Alias = input.Alias,
            Owner = input.Owner,
            Uri = input.Uri,
            Metadata = metadata,
            TokenId = input.TokenId
        };

        var nftMinted = PerformMint(mingInput, true);
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;

        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;

        Context.Fire(new Assembled
        {
            Symbol = input.Symbol,
            TokenId = nftMinted.TokenId,
            AssembledNfts = input.AssembledNfts,
            AssembledFts = input.AssembledFts
        });

        return nftMinted.TokenHash;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-236)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }

        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
        }

        Context.Fire(new Disassembled
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            DisassembledNfts = assembledNfts ?? new AssembledNfts(),
            DisassembledFts = assembledFts ?? new AssembledFts()
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-437)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-32)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
```
