### Title
Term Transitions Can Occur at Non-Irreversible Block Heights, Allowing Reversible Critical Consensus State Changes

### Summary
The `ValidationForNextTerm()` function does not verify that term transitions occur only after sufficient block confirmations (at irreversible block heights). This allows term transitions to happen at reversible blocks, meaning critical consensus state changes—including miner list updates, treasury donations, and election snapshots—can be reversed during chain reorganizations, causing consensus inconsistencies and potential economic loss.

### Finding Description

The `ValidationForNextTerm()` method in `RoundTerminateValidationProvider.cs` performs only basic checks when validating term transitions: [1](#0-0) 

The validation only ensures that:
1. The round number increments by 1 (via `ValidationForNextRound`)
2. The term number increments by 1

**Critically missing**: There is no check to verify that the current block height exceeds the confirmed irreversible block height (`ConfirmedIrreversibleBlockHeight`) by a safe margin before allowing a term transition.

Furthermore, the validation pipeline for `NextTerm` behavior explicitly excludes `LibInformationValidationProvider`, which is only added for `UpdateValue` operations: [2](#0-1) 

When `ProcessNextTerm` executes, it performs multiple critical state changes without any irreversibility guarantees: [3](#0-2) 

These operations include:
- Updating the miner list for the new term (line 190)
- Donating mining rewards to Treasury (lines 203-211)
- Releasing treasury funds (lines 205-208)
- Taking election snapshots (lines 213-218)
- Updating election contract state (line 201)

### Impact Explanation

**Consensus Integrity Impact**: If a term transition occurs at a non-irreversible block height and a chain reorganization reverses that block, the blockchain will have inconsistent consensus state. The new term's miner list would be invalid, yet miners may have already acted based on it, creating conflicting blocks.

**Economic Impact**: Treasury operations (mining reward donations and fund releases) executed during the reversed term transition would create accounting inconsistencies. The Treasury contract may record donations/releases that never actually occurred from the chain's perspective after reorganization.

**Election System Impact**: Election snapshots taken during the reversed term transition would be invalid, potentially affecting subsequent reward distributions and governance decisions.

**Severity**: HIGH - This violates the critical invariant that "Correct round transitions and time-slot validation, miner schedule integrity, LIB height rules" must be maintained. Term transitions are among the most critical consensus operations and must only occur at irreversible heights to prevent state divergence.

### Likelihood Explanation

**Attacker Capabilities**: No special attacker capabilities are required. This vulnerability can be triggered by natural chain reorganizations that occur around the time of a term transition.

**Attack Complexity**: LOW - Term transitions occur at predictable intervals based on `periodSeconds`: [4](#0-3) 

An attacker observing the blockchain can predict when term transitions will occur and attempt to cause or exploit natural reorganizations at those times.

**Feasibility**: Chain reorganizations are a normal occurrence in blockchain systems, especially when network latency is high or when there are temporary network partitions. If the LIB lags significantly behind the chain tip (which can happen during high network activity), the window for reversible term transitions increases.

**Probability**: MEDIUM-HIGH - While deep reorganizations past the LIB are rare, short reorganizations within the non-irreversible portion of the chain are common. Since term transitions can occur at any block height (subject only to the time-based `NeedToChangeTerm` check), there is no protection against them occurring in this reversible window.

### Recommendation

**Immediate Fix**: Add an irreversible block height check to `ValidationForNextTerm`:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // NEW: Verify term transition occurs at sufficient height above LIB
    var currentHeight = validationContext.CurrentHeight; // Would need to pass this in context
    var confirmedIrreversibleHeight = validationContext.BaseRound.ConfirmedIrreversibleBlockHeight;
    var minSafeDistance = 100; // Configure appropriate safety margin
    
    if (confirmedIrreversibleHeight > 0 && 
        currentHeight < confirmedIrreversibleHeight + minSafeDistance)
    {
        return new ValidationResult 
        { 
            Message = $"Term transition too close to LIB. Current: {currentHeight}, LIB: {confirmedIrreversibleHeight}" 
        };
    }

    // Is next term number correct?
    return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
        ? new ValidationResult { Message = "Incorrect term number for next round." }
        : new ValidationResult { Success = true };
}
```

**Alternative Fix**: Add `LibInformationValidationProvider` to the NextTerm validation pipeline: [5](#0-4) 

Change to also include LIB validation for NextTerm like it's done for UpdateValue.

**Configuration**: Define `MinTermTransitionDistanceFromLIB` as a consensus parameter to control the safety margin.

**Test Cases**: Add regression tests that verify:
1. Term transitions are rejected when current height < LIB + safety margin
2. Term transitions succeed when current height >= LIB + safety margin
3. Chain reorganization scenarios that attempt to reverse term transitions fail

### Proof of Concept

**Initial State**:
- Current block height: 1000
- Confirmed irreversible block height: 950
- Current term: 1
- Time indicates term transition should occur (NeedToChangeTerm returns true)

**Attack Sequence**:
1. Miner produces block 1001 with `NextTerm` behavior
2. `ValidationForNextTerm` passes (only checks round/term increments)
3. `ProcessNextTerm` executes, performing:
   - Miner list update to term 2
   - Treasury donation of mining rewards
   - Treasury release for previous term
   - Election snapshot
4. Network experiences temporary partition or attack
5. Alternative chain fork with blocks 996-1001 becomes longer
6. Chain reorganizes back to block 995, removing the term transition block

**Expected Result**: Term transition should be rejected at step 2 because block 1001 is not sufficiently beyond LIB (950).

**Actual Result**: Term transition succeeds at block 1001 and then gets reversed by reorganization, leaving:
- Invalid miner list for term 2 in some nodes' state
- Inconsistent treasury accounting
- Invalid election snapshots
- Consensus state divergence between nodes

**Success Condition**: Demonstrating that `ValidationForNextTerm` accepts the term transition at block 1001 despite it being only 51 blocks past LIB, and subsequent reorganization causes state inconsistency.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-243)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }

    /// <summary>
    ///     If periodSeconds == 7:
    ///     1, 1, 1 => 0 != 1 - 1 => false
    ///     1, 2, 1 => 0 != 1 - 1 => false
    ///     1, 8, 1 => 1 != 1 - 1 => true => term number will be 2
    ///     1, 9, 2 => 1 != 2 - 1 => false
    ///     1, 15, 2 => 2 != 2 - 1 => true => term number will be 3.
    /// </summary>
    /// <param name="blockchainStartTimestamp"></param>
    /// <param name="termNumber"></param>
    /// <param name="blockProducedTimestamp"></param>
    /// <param name="periodSeconds"></param>
    /// <returns></returns>
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```
