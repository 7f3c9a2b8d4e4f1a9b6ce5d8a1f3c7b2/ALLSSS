### Title
Linear Search on Large Organization Member Lists Causes DOS in Approve/Reject/Release Operations

### Summary
The `Contains()` method in `OrganizationMemberList` performs O(n) linear search on the `organizationMembers_` repeated field, which can contain an unbounded number of members. This causes voting operations (Approve/Reject/Abstain) to scale linearly with organization size, and critically, the `Release` operation scales quadratically O(m*n) where m is the number of votes and n is the number of members, making governance unusable for organizations with large member lists.

### Finding Description

**Root Cause:**

The `Contains()` method performs a linear search on the protobuf `repeated` field: [1](#0-0) 

The underlying `organizationMembers_` field is defined as a protobuf repeated field, which generates to `RepeatedField<Address>` in C#, backed by a `List<T>` with O(n) `Contains()` complexity: [2](#0-1) 

**Critical Usage in Voting Operations:**

Every `Approve`, `Reject`, and `Abstain` call must verify the sender is an authorized organization member: [3](#0-2) [4](#0-3) 

This verification uses `Contains()` with O(n) complexity: [5](#0-4) 

**Catastrophic O(m*n) Complexity in Release:**

The `Release` operation calls `IsReleaseThresholdReached()` which performs vote counting with nested iterations - for each vote, it checks if the voter is a valid organization member using `Contains()`: [6](#0-5) 

Each of the three `Count(organization.OrganizationMemberList.Contains)` operations iterates through all votes (m) and for each vote performs an O(n) member list lookup, resulting in O(m*n) total complexity.

**No Size Validation:**

The `Validate()` method only checks for empty lists and duplicates, with no maximum size constraint: [7](#0-6) 

### Impact Explanation

**Concrete Harm:**
- Organizations with large member lists (e.g., 100,000+ members representing public DAOs or tokenholders) become effectively unusable for governance
- Each Approve/Reject operation requires ~100K iterations to verify membership
- Release operations with 10,000 votes and 100,000 members require 1 billion iterations (10K * 100K * 3 threshold checks)
- Transaction costs become prohibitively expensive, potentially exceeding gas limits
- Legitimate governance proposals cannot be approved or released

**Affected Parties:**
- Organizations with large member bases
- Voters attempting to participate in governance
- Proposers unable to release approved proposals

**Severity: Medium** - While this causes complete DOS of affected organizations' governance capabilities, it is limited to specific organizations that choose large member lists and does not affect the broader system or result in direct fund loss.

### Likelihood Explanation

**Attacker Capabilities:**
- Any user can create an organization via the public `CreateOrganization()` method [8](#0-7) 

**Attack Complexity: Low**
1. Create an organization with a large member list (100K-1M addresses)
2. The organization becomes immediately impacted - no further action needed
3. Any legitimate use of that organization (voting, releasing proposals) becomes prohibitively expensive

**Feasibility:**
- No special permissions required
- No economic barriers beyond transaction costs for organization creation
- Attack is permanent once organization is created
- Realistic scenario: Public DAOs or token-weighted governance systems that want to give voting rights to all token holders

**Detection Constraints:**
- Issue is inherent in the data structure design
- No runtime detection mechanism exists
- Impact becomes apparent only when operations are attempted

### Recommendation

**Immediate Mitigation:**

1. **Add maximum organization size validation** in the `Validate()` method:
```csharp
// In Association_Helper.cs Validate() method
const int MaxOrganizationMembers = 10000; // or appropriate limit
Assert(organizationMemberCount <= MaxOrganizationMembers, 
    "Organization member count exceeds maximum allowed.");
```

2. **Use HashSet for O(1) membership lookups** - Replace the repeated field storage with a more efficient data structure:
```csharp
// Store member addresses in a MappedState for O(1) lookups
public MappedState<Address, Address, bool> OrganizationMembers { get; set; }
// Key1: Organization Address, Key2: Member Address, Value: true if member
```

3. **Cache vote validation during Release** - Pre-filter valid votes once rather than checking membership repeatedly:
```csharp
// In IsReleaseThresholdReached, validate all votes first:
var validApprovals = proposal.Approvals.Where(organization.OrganizationMemberList.Contains).ToList();
var approvedMemberCount = validApprovals.Count;
```

**Long-term Solution:**
Redesign the organization member system to use a mapping-based structure for O(1) membership checks, similar to how the Parliament contract handles miner lists.

### Proof of Concept

**Initial State:**
- Attacker has sufficient tokens for transaction fees

**Attack Steps:**

1. **Create organization with 100,000 members:**
```
CreateOrganization({
    organization_member_list: { 
        organization_members: [address_1, address_2, ..., address_100000] 
    },
    proposal_release_threshold: { 
        minimal_approval_threshold: 50000,
        minimal_vote_threshold: 50000,
        maximal_rejection_threshold: 25000,
        maximal_abstention_threshold: 25000
    },
    proposer_white_list: { proposers: [attacker] }
})
```

2. **Create a test proposal** - succeeds normally

3. **Attempt to Approve the proposal** as organization member:
   - Expected: Quick authorization check
   - Actual: ~100,000 iterations to verify membership
   - Result: High gas cost, potentially exceeding limits

4. **Attempt to Release after collecting 60,000 approvals:**
   - Expected: Threshold validation and execution
   - Actual: 60,000 * 100,000 * 3 = 18 billion iterations for vote validation
   - Result: Transaction fails due to gas limit or prohibitively expensive execution

**Success Condition:**
The organization's governance operations become economically infeasible, effectively DOS'ing all proposal approval and release functionality for that organization.

### Citations

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```

**File:** protobuf/association_contract.proto (L105-108)
```text
message OrganizationMemberList {
    // The address of organization members.
    repeated aelf.Address organization_members = 1;
}
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L143-161)
```csharp
    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Rejections.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Reject),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-59)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }

    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```
