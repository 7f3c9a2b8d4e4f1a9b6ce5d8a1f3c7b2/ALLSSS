### Title
Missing Hash Validation Allows Miners to Break Secret-Sharing Consensus Protocol

### Summary
The `ApplyNormalConsensusData()` function directly assigns `OutValue` without validating it matches `Hash(InValue)`, and subsequent validation only checks the hash relationship with `PreviousInValue` but not whether it matches secret-sharing reconstructed values. This allows a malicious miner to submit an arbitrary `OutValue` in one round, then craft a fake `InValue` in the next round that passes validation but contradicts the secret shares they distributed, breaking the verifiable commitment guarantee of the secret-sharing protocol.

### Finding Description

**Root Cause:**

At line 12, `OutValue` is directly assigned without cryptographic validation: [1](#0-0) 

Similarly in `ProcessUpdateValue`, the user-provided `OutValue` is accepted without verification: [2](#0-1) 

**Why Existing Protections Fail:**

The `UpdateValueValidationProvider` only validates that `Hash(PreviousInValue) == PreviousOutValue` from the previous round: [3](#0-2) 

It does NOT validate:
1. That the current round's `OutValue` equals `Hash(InValue)` (because `InValue` is supposed to be secret)
2. That the miner's claimed `PreviousInValue` matches what other miners reconstructed from secret shares

When secret shares are revealed and reconstructed, they update OTHER miners' `PreviousInValue`: [4](#0-3) 

But the miner's OWN `PreviousInValue` comes from their direct claim, which overwrites any reconstructed value: [5](#0-4) 

**Execution Path:**

The consensus protocol flow as documented shows `out_node(t) = hash(in_node(t))` should be validated when `in_node(t)` is revealed: [6](#0-5) 

However, there's no on-chain cross-check between the miner's claimed `PreviousInValue` and the value reconstructed by other miners from secret shares.

### Impact Explanation

**Concrete Harm:**

1. **Consensus Randomness Manipulation:** The `Signature` value is calculated using `InValue` and determines mining order for the next round: [7](#0-6) 

By providing a fake `InValue` that passes hash validation, a miner can manipulate their calculated signature and thus their mining position.

2. **Secret-Sharing Protocol Broken:** The secret-sharing mechanism's core security guarantee—that miners cannot change their committed `InValue` after distributing encrypted shares—is violated. The protocol reconstructs the real `InValue` from shares: [8](#0-7) 

But this reconstructed value is never compared on-chain with the miner's claim.

3. **Affected Parties:** All network participants are affected as the fairness and unpredictability of block production scheduling is compromised.

**Severity Justification:** HIGH - This breaks a critical consensus invariant (mining order randomness) and allows miners to gain unfair advantages in block production rights.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an active miner (publicly elected position)
- Must precompute a fake `InValue'` such that `Hash(InValue') == OutValue'` (computationally trivial)
- Can choose `OutValue'` to yield a favorable mining order

**Attack Complexity:**
- LOW - Simply submit crafted `OutValue` in one round via the public `UpdateValue` method: [9](#0-8) 
- Then submit matching fake `PreviousInValue` in next round

**Feasibility Conditions:**
- Attacker needs miner status (verified via `PreCheck`): [10](#0-9) 
- No additional authorization required beyond normal mining permissions

**Detection Constraints:**
- Other miners can detect discrepancy off-chain by comparing their reconstructed `InValue` with miner's claim
- However, no on-chain enforcement mechanism exists to reject the malicious data

**Probability:** MEDIUM-HIGH - Miners have economic incentive to gain favorable block production positions, and the attack is technically straightforward.

### Recommendation

**Code-Level Mitigation:**

Add validation in `UpdateValueValidationProvider` to cross-check the miner's claimed `PreviousInValue` against values reconstructed from secret shares. Specifically:

1. Store reconstructed `InValues` from secret sharing in the round state
2. In `ValidatePreviousInValue`, add a check:
```
if (reconstructedInValue != Hash.Empty) {
    Assert(extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == reconstructedInValue,
           "Claimed PreviousInValue does not match secret-sharing reconstruction");
}
```

3. Alternatively, compute `OutValue` on-chain from the provided `InValue` during block production: [11](#0-10) 

Ensure this computed value is the only one stored, never accepting user-provided `OutValue` directly.

**Invariant Check:**
Add assertion: `Hash(CurrentRoundInValue) == PreviousRoundOutValue` when `InValue` is first revealed in the next round.

**Test Cases:**
1. Test that submitting mismatched `OutValue` and later fake `InValue` is rejected
2. Test that reconstructed secret-shared values are enforced on-chain
3. Test that mining order cannot be manipulated via crafted hash values

### Proof of Concept

**Required Initial State:**
- Attacker is an elected miner in round N
- Secret sharing is enabled

**Transaction Steps:**

1. **Round N - Submit Invalid OutValue:**
   - Attacker generates real `InValue_N` (e.g., `0xABCD...`)
   - Computes real `OutValue_N = Hash(InValue_N)` (e.g., `0x1234...`)
   - Distributes secret shares of real `InValue_N` to other miners
   - But submits `OutValue'_N = 0x9999...` (arbitrary value) via `UpdateValue()`
   - Current validation only checks `OutValue'_N` is not empty ✓ passes

2. **Round N+1 - Submit Fake InValue:**
   - Other miners reconstruct real `InValue_N = 0xABCD...` from secret shares (off-chain)
   - Attacker precomputes fake `InValue'_N = 0x5678...` such that `Hash(InValue'_N) == 0x9999...`
   - Submits `InValue'_N` as `PreviousInValue` via `UpdateValue()`
   - Validation checks: `Hash(InValue'_N) == OutValue'_N` ✓ passes
   - No check that `InValue'_N == 0xABCD...` (reconstructed value) ✗ missing

**Expected vs Actual Result:**
- **Expected:** Transaction rejected because `InValue'_N` doesn't match secret-sharing reconstruction
- **Actual:** Transaction accepted, attacker's fake `InValue'_N` is used for signature calculation, manipulating mining order

**Success Condition:**
Attacker successfully changes their committed `InValue` after the fact, breaking the secret-sharing commitment and manipulating their position in the mining schedule for subsequent rounds.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L12-12)
```csharp
        RealTimeMinersInformation[pubkey].OutValue = outValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L245-245)
```csharp
        minerInRound.OutValue = updateValueInput.OutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L263-264)
```csharp
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-67)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** docs-sphinx/protocol/consensus.md (L35-45)
```markdown
Each mining node has three main properties in a specific round **t**:

* Private key, **in_node(t)**, which is a value inputted from the mining node and kept privately by the mining node itself in round **t**. It will become public after all block generations in round **t** are completed;
* Public key, **out_node(t)**, which is the hash value of **in_node(t)**. Every node in the aelf network can look up this value at any time;
* Signature, **sig_node(t)**, which is a value generated by the mining node itself in the first round. After the first round, it can only be calculated once the previous round is completed. It is used as the signature of this mining node in this round and it is also opened to public at all times like the **out_node(t)**.

### Main Processes

#### Pre-Verification

Before a node starts its block generation in round **(t+1)**, it has to have its status verified in round **t**. In round **(t+1)**, **in_node(t)** is already published as public, and **out_node(t)** can be queried at any time. So to verify the status of in round , other nodes can check **hash(in_node(t)) = out_node(t)**.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
