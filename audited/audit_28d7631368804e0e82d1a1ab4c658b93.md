### Title
Missing Block-Level Execution Protection in UpdateInformationFromCrossChain Enables State Thrashing and Token Drainage

### Summary
The `UpdateInformationFromCrossChain()` function lacks the `EnsureTransactionOnlyExecutedOnceInOneBlock()` protection that guards other critical consensus operations. A compromised CrossChain contract can call this function multiple times per block with incrementing round numbers, causing repeated token distributions to arbitrary miner lists and thrashing critical consensus state variables, leading to DoS and potential fund loss.

### Finding Description
The vulnerability exists in the `UpdateInformationFromCrossChain()` method which updates side chain consensus information from the main chain. [1](#0-0) 

**Root Cause:** Unlike other critical consensus operations (UpdateValue, NextRound, NextTerm, TinyBlock), this function does NOT call `EnsureTransactionOnlyExecutedOnceInOneBlock()` to prevent multiple executions within a single block. [2](#0-1) 

**Insufficient Protection:** The only check is that incoming round numbers must be higher than the stored value, which does NOT prevent multiple calls per blockâ€”only that each call must use an increasing round number. [3](#0-2) 

**Access Control:** The function verifies the caller is the CrossChain contract, but the security premise assumes this contract is compromised or buggy. [4](#0-3) 

**Execution Path:** The CrossChain contract calls this function via `Context.SendInline` during parent chain block indexing. [5](#0-4) 

### Impact Explanation
**Token Drainage:** Each invocation calls `DistributeResourceTokensToPreviousMiners()` which distributes the consensus contract's entire resource token balance (transaction fees and rental tokens) to the miner list. [6](#0-5)  Multiple calls drain tokens to different, attacker-controlled miner addresses. [7](#0-6) 

**State Thrashing:** Critical state variables `MainChainRoundNumber` and `MainChainCurrentMinerList` are updated repeatedly with inconsistent values in a single block. [8](#0-7)  This corrupts the side chain's view of main chain consensus.

**Consensus DoS:** Arbitrary, rapid changes to the miner list can disrupt side chain consensus operations that depend on accurate main chain state, potentially halting block production.

**Affected Parties:** All side chain users and miners, as consensus integrity is compromised and accumulated fee tokens can be stolen.

### Likelihood Explanation
**Attacker Capabilities:** Requires a compromised or buggy CrossChain system contract (as stated in the security question premise). While system contracts are privileged, bugs or upgrades could introduce vulnerabilities.

**Attack Complexity:** Low. The attacker simply calls `UpdateInformationFromCrossChain` multiple times with fabricated `AElfConsensusHeaderInformation` containing incrementing round numbers (100, 101, 102...) and attacker-controlled miner lists.

**Feasibility:** Highly feasible under the stated premise. No additional cryptographic or economic constraints exist beyond the compromised contract requirement.

**Detection:** Multiple consensus information updates per block are abnormal and could be detected, but the damage (token drainage and state corruption) occurs immediately within the block.

**Defense-in-Depth Failure:** This represents a critical gap in defensive programming. The codebase uses `EnsureTransactionOnlyExecutedOnceInOneBlock()` consistently for consensus operations but omits it here, creating an exploitable inconsistency. [9](#0-8) 

### Recommendation
**1. Add Block-Level Protection:** Insert `EnsureTransactionOnlyExecutedOnceInOneBlock()` at the beginning of `UpdateInformationFromCrossChain()` immediately after the sender check, mirroring the protection pattern used in `ProcessConsensusInformation()`.

```
public override Empty UpdateInformationFromCrossChain(BytesValue input)
{
    Assert(
        Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
        "Only Cross Chain Contract can call this method.");
    
    // ADD THIS LINE:
    EnsureTransactionOnlyExecutedOnceInOneBlock();
    
    Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");
    // ... rest of implementation
}
```

**2. Add Integration Tests:** Create test cases that attempt multiple calls to `UpdateInformationFromCrossChain` within a single block and verify the second call fails with "Cannot execute this tx." error.

**3. Code Review:** Audit all ACS11 and cross-chain interaction methods to ensure consistent application of block-level execution protections for state-mutating operations.

### Proof of Concept
**Initial State:**
- Side chain with consensus contract containing 10 ELF in resource tokens
- MainChainRoundNumber = 50
- MainChainCurrentMinerList = [MinerA, MinerB, MinerC]

**Attack Sequence (within single block):**
1. Compromised CrossChain contract calls `UpdateInformationFromCrossChain` with:
   - RoundNumber = 51
   - MinerList = [AttackerAddress1, AttackerAddress2]
   
2. Result: 10 ELF distributed to MinerA, MinerB, MinerC (previous list), then state updates to round 51 with [AttackerAddress1, AttackerAddress2]

3. Same block, call again with:
   - RoundNumber = 52
   - MinerList = [AttackerAddress3, AttackerAddress4]
   
4. Result: Remaining balance distributed to AttackerAddress1, AttackerAddress2, state updates to round 52

5. Same block, call again with:
   - RoundNumber = 53
   - MinerList = [AttackerAddress5]
   
6. Result: Any new tokens distributed to AttackerAddress3, AttackerAddress4, state updates to round 53

**Expected vs Actual:**
- **Expected:** Only one consensus update per block, second call fails
- **Actual:** All three calls succeed, draining tokens to attacker addresses and leaving final state at round 53 with miner list [AttackerAddress5]

**Success Condition:** Multiple successful `UpdateInformationFromCrossChain` calls within the same block, each updating state and distributing tokens, confirmed by checking `State.MainChainRoundNumber.Value` and token balances of attacker addresses.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-64)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L66-96)
```csharp
    private void DistributeResourceTokensToPreviousMiners()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
            Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
            if (amount <= 0) continue;
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-23)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L227-234)
```csharp
    private void UpdateConsensusInformation(ByteString bytes)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        Context.SendInline(State.CrossChainInteractionContract.Value,
            nameof(State.CrossChainInteractionContract.UpdateInformationFromCrossChain),
            new BytesValue { Value = bytes });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```
