### Title
Missing Validation of Extra Block Producer in Round Structure Enables Consensus DoS

### Summary
The `GetExtraBlockProducerInformation()` method uses LINQ's `First()` without validation that an extra block producer exists, and consensus validation providers do not verify Round structure integrity. A malicious miner can submit a modified `NextRoundInput`/`NextTermInput` with no extra block producer or with an extra block producer having `Order = 0`, causing consensus failure or incorrect mining time calculations.

### Finding Description

**Location:** [1](#0-0) 

The vulnerable method retrieves the extra block producer without validation: [1](#0-0) 

**Root Cause:**
1. While Round generation methods properly initialize miners ( [2](#0-1) , [3](#0-2) ), miners submit Round data as transaction input after generation.

2. The consensus validation providers ( [4](#0-3) ) do not validate:
   - Exactly one miner has `IsExtraBlockProducer = true`
   - All miners have `Order > 0`
   - Extra block producer has valid `ExpectedMiningTime`

3. Round submission via `NextRound`/`NextTerm` directly stores the input without structural validation ( [5](#0-4) ).

**Attack Path:**
1. Malicious miner generates valid Round on-chain ( [6](#0-5) )
2. Modifies the Round to remove `IsExtraBlockProducer = true` from all miners or sets extra block producer's `Order = 0`
3. Submits modified Round via `NextRoundInput.Create()` ( [7](#0-6) )
4. Passes `PreCheck()` as valid miner ( [8](#0-7) )
5. Validation providers miss structural issues ( [9](#0-8) )
6. Corrupt Round stored via `AddRoundInformation()` ( [10](#0-9) )

### Impact Explanation

**Consensus DoS (Critical):**
When next miner attempts to generate NextRound, the contract calls `GenerateNextRoundInformation()` → `BreakContinuousMining()` ( [11](#0-10) ) → `GetExtraBlockProducerInformation()` at lines 80 and 97. If no miner has `IsExtraBlockProducer = true`, `First()` throws `InvalidOperationException`, preventing block generation and halting consensus permanently.

**Incorrect Mining Times (High):**
If extra block producer has `Order = 0`, the calculation at [12](#0-11)  returns `futureRoundStartTime.AddMilliseconds(0)`, assigning the incorrect time slot and breaking mining schedule integrity.

**Affected Parties:**
- All miners unable to produce blocks
- Network operations halted
- Economic incentives disrupted

### Likelihood Explanation

**Attacker Capabilities:**
- Must be in current miner list (realistic - miners rotate)
- Must produce NextRound/NextTerm block (happens regularly)
- Can intercept and modify transaction data before submission

**Attack Complexity:** Low
1. Call `GetConsensusBlockExtraData` (view method)
2. Modify returned Round structure
3. Submit via `NextRound`/`NextTerm` transaction

**Feasibility Conditions:**
- No cryptographic signature verification on Round structure
- No structural validation in consensus validation providers
- Direct storage without integrity checks

**Detection Constraints:**
Attack succeeds silently until next miner attempts block generation, at which point consensus is already broken.

**Probability:** Medium-High
While requiring miner privileges, the lack of validation makes exploitation straightforward once miner access is obtained. The long-term economic harm incentivizes attacks from competing miners or malicious actors.

### Recommendation

**Immediate Fix:**
Add validation in `ValidateBeforeExecution` or create a dedicated `RoundStructureValidationProvider`:

```csharp
// Add to validation providers in AEDPoSContract_Validation.cs
public class RoundStructureValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext context)
    {
        var round = context.ExtraData.Round;
        
        // Check exactly one extra block producer
        var extraBlockProducers = round.RealTimeMinersInformation.Values
            .Count(m => m.IsExtraBlockProducer);
        if (extraBlockProducers != 1)
            return new ValidationResult { Message = "Round must have exactly one extra block producer." };
        
        // Check all miners have valid Order
        if (round.RealTimeMinersInformation.Values.Any(m => m.Order <= 0))
            return new ValidationResult { Message = "All miners must have Order > 0." };
        
        // Check extra block producer has valid fields
        var extraBlockProducer = round.RealTimeMinersInformation.Values
            .First(m => m.IsExtraBlockProducer);
        if (extraBlockProducer.ExpectedMiningTime == null)
            return new ValidationResult { Message = "Extra block producer must have valid ExpectedMiningTime." };
        
        return new ValidationResult { Success = true };
    }
}
```

Register in validation flow: [13](#0-12) 

**Additional Hardening:**
- Use `FirstOrDefault()` with null check in `GetExtraBlockProducerInformation()`
- Add `Assert` statements in `AddRoundInformation()` for structural invariants
- Implement Round hash verification for NextRound/NextTerm inputs

### Proof of Concept

**Initial State:**
- Chain running with 3 miners: A, B, C
- Current round has proper structure
- Miner B is scheduled to produce NextRound block

**Attack Steps:**
1. Miner B calls `GetConsensusBlockExtraData(AElfConsensusBehaviour.NextRound)`
2. Receives valid Round with Miner A as extra block producer (`Order = 1`)
3. Modifies Round: Sets `MinerA.IsExtraBlockProducer = false`
4. Creates `NextRoundInput` with modified Round
5. Submits transaction to `NextRound` method
6. Transaction passes validation (no structural checks)
7. Corrupt Round stored in state

**Expected Result:** Transaction rejected with "Round must have exactly one extra block producer"

**Actual Result:** Transaction succeeds, corrupt Round stored

**Consensus Failure:**
8. Miner C attempts to generate next block
9. Calls `GetConsensusBlockExtraData` → `GenerateNextRoundInformation` → `BreakContinuousMining`
10. Line 80 executes: `var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();`
11. `First(bp => bp.Value.IsExtraBlockProducer)` throws `InvalidOperationException`
12. Miner C cannot generate block
13. **Consensus halted permanently**

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L36-36)
```csharp
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-37)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-92)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-106)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```
