### Title
Asset Duplication via Disassemble with Multiple NFT Copies

### Summary
The Disassemble function hardcodes the burn amount to 1 and unconditionally removes the assembled asset mapping, regardless of remaining NFT quantity. When a protocol has `IsTokenIdReuse` enabled, an attacker with minting privileges can mint additional copies of an assembled NFT, then disassemble to recover all underlying assets while retaining the extra copies, effectively duplicating the underlying NFTs/FTs.

### Finding Description

The vulnerability exists in the `Disassemble` function which hardcodes the burn amount to 1 and unconditionally removes assembled asset mappings without checking if the NFT quantity exceeds 1. [1](#0-0) 

The function unconditionally removes the assembled asset mappings regardless of remaining quantity: [2](#0-1) [3](#0-2) 

The attack exploits the interaction between the `Assemble` function, which creates assembled NFTs with `isTokenIdMustBeUnique=true` ensuring initial quantity of 1: [4](#0-3) 

And the `PerformMint` function, which allows adding quantity to existing token IDs when `IsTokenIdReuse=true` in the protocol configuration: [5](#0-4) [6](#0-5) 

When `IsTokenIdReuse` is true (a legitimate protocol setting defined in the protocol specification): [7](#0-6) [8](#0-7) 

A subsequent `Mint` call with the same tokenId bypasses the uniqueness check and adds to the existing quantity. This creates multiple copies of the assembled NFT, but the assembled asset mapping still points to the same set of underlying assets stored in the contract.

### Impact Explanation

**Direct asset theft and duplication.** An attacker can:
1. Assemble valuable NFTs/FTs worth X into an assembled NFT (quantity=1)
2. Mint additional copies of the assembled NFT (quantity becomes 2+)
3. Call Disassemble once to recover ALL underlying assets worth X
4. Retain the remaining copies and sell/transfer them as legitimate assembled NFTs

This results in:
- **Theft of underlying NFTs/FTs** from the contract
- **Fraudulent NFTs circulating** that appear assembled but have no backing assets
- **Buyer fraud** - purchasers of remaining copies lose their investment when they discover no underlying assets exist
- **Protocol reputation damage** and potential total value loss of all assembled NFTs

The severity is **HIGH** because it enables direct theft of arbitrary-value assets stored in assembled NFTs, with concrete financial impact on both the protocol and innocent buyers.

### Likelihood Explanation

The attack requires two preconditions:

1. **Protocol has `IsTokenIdReuse=true`** - This is a legitimate protocol configuration option designed to allow token ID reuse after burns. Some protocols may enable this for their operational model.

2. **Attacker must be in the `MinterListMap`** - Required by the Burn function's permission check: [9](#0-8) 

While not universal, minter privileges are commonly granted for various operational reasons including protocol creators, approved partners, or game mechanics.

**Attack complexity is LOW:**
- Simple sequence of `Assemble → Mint → Disassemble` calls
- No timing dependencies or complex state manipulation
- Easy to execute once preconditions are met
- Difficult to detect until underlying assets are withdrawn

The preconditions are **realistic enough** to warrant HIGH severity because `IsTokenIdReuse` is a valid design choice, minter privileges may be granted legitimately, and the impact is catastrophic regardless of frequency.

### Recommendation

Add a quantity validation check in the `Disassemble` function before burning:

```csharp
var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
var nftInfo = GetNFTInfoByTokenHash(tokenHash);
Assert(nftInfo.Quantity == 1, 
    "Cannot disassemble NFT with quantity > 1. All copies must be burned before disassembly.");
```

Additionally, consider:
1. **Prevent Mint from adding quantity to assembled NFTs** by checking if `AssembledNftsMap[tokenHash]` exists before allowing quantity increases
2. **Add explicit validation tests** for:
   - Attempting to mint additional quantity of assembled NFTs (should fail)
   - Attempting to disassemble NFTs with quantity > 1 (should fail)
   - Verifying assembled asset mappings remain consistent with NFT quantity invariants

### Proof of Concept

**Required initial state:**
- NFT protocol "ASSEMBLED" with `IsTokenIdReuse=true`, `IsBurnable=true`
- Attacker address is in `MinterListMap` for "ASSEMBLED"
- Attacker owns NFT_A (tokenId=1) and NFT_B (tokenId=2)
- Contract deployed and operational

**Attack sequence:**

1. Attacker calls `Assemble(symbol="ASSEMBLED", tokenId=100, assembledNfts={NFT_A:1, NFT_B:1})`
   - Result: NFT_A and NFT_B transferred to contract
   - Result: Assembled NFT with tokenId=100, quantity=1 minted to attacker
   - Result: `State.AssembledNftsMap[hash("ASSEMBLED-100")] = {NFT_A:1, NFT_B:1}`

2. Attacker calls `Mint(symbol="ASSEMBLED", tokenId=100, quantity=1)`
   - Result: Since `IsTokenIdReuse=true` and `isTokenIdMustBeUnique=false`, uniqueness check passes
   - Result: Quantity increases from 1 to 2
   - Result: Attacker now has 2 copies of ASSEMBLED-100

3. Attacker calls `Disassemble(symbol="ASSEMBLED", tokenId=100)`
   - Result: Burns 1 copy (quantity: 2 → 1)
   - Result: Transfers NFT_A and NFT_B back to attacker from contract
   - Result: Removes `State.AssembledNftsMap[hash("ASSEMBLED-100")]`
   - Result: Attacker retains 1 copy of ASSEMBLED-100

**Expected behavior:** Disassemble should fail if quantity > 1, or only return proportional assets

**Actual behavior:** Attacker successfully recovers NFT_A and NFT_B while retaining 1 copy of ASSEMBLED-100 (which now has no backing assets)

**Success condition:** After step 3, attacker's balance shows ownership of NFT_A > 0, NFT_B > 0, AND ASSEMBLED-100 quantity = 1, proving asset duplication occurred.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L89-93)
```csharp
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L175-178)
```csharp
        var nftMinted = PerformMint(mingInput, true);
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;

        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L193-198)
```csharp
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L203-210)
```csharp
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L212-225)
```csharp
        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-437)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }
```

**File:** protobuf/nft_contract.proto (L126-127)
```text
    // Is token id can be reused.
    bool is_token_id_reuse = 9;
```

**File:** protobuf/nft_contract.proto (L282-283)
```text
    // Is token id can be reused.
    bool is_token_id_reuse = 11;
```
