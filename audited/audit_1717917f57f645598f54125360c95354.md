### Title
Permanent Authority Lockout via MethodFeeController Change to Inaccessible Organization

### Summary
The `ChangeMethodFeeController()` function allows changing the method fee controller to a Parliament organization with impossible-to-achieve voting thresholds (e.g., 100% approval required). Once changed, the system becomes permanently locked from any future fee updates or controller changes, as there is no recovery mechanism and the only way to modify the controller requires executing a proposal through the now-inaccessible organization.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController()` function which changes the authority controlling method fees: [1](#0-0) 

The function enforces that only the current controller (line 24) can change to a new controller, and validates that the new organization exists (lines 25-26). However, it does **not** validate that the new organization has achievable voting thresholds.

The Parliament contract's validation logic permits creating organizations with extreme thresholds: [2](#0-1) 

This validation allows `MinimalApprovalThreshold = 10000` (100%), requiring unanimous approval from all current miners. Test cases confirm this is explicitly permitted: [3](#0-2) 

When a proposal is released, it executes with the organization's virtual address as the sender: [4](#0-3) 

The critical issue is that to change the MethodFeeController again after it's been set to an inaccessible organization, the authorization check requires `Context.Sender` to equal the organization address (line 24 in ChangeMethodFeeController). This can only be achieved by releasing a proposal through that organization. However, if the organization requires 100% approval: [5](#0-4) 

The approval threshold becomes mathematically impossible to reach if any single miner is offline, compromised, or maliciously refuses to vote. The threshold calculation requires `approvedMemberCount * 10000 >= 10000 * parliamentMembers.Count`, meaning every single current miner must approve.

The default initialization only sets the controller if it's null, providing no recovery path: [6](#0-5) 

### Impact Explanation

**Operational Impact - Critical Governance Failure:**

1. **Permanent Loss of Fee Governance**: Once locked, the protocol loses the ability to adjust method fees forever. This affects all system contracts implementing ACS1, including Token, Treasury, Consensus, Election, and other core contracts.

2. **Economic Rigidity**: The blockchain cannot adapt transaction fees to changing network conditions, token valuations, or spam attacks. Fees remain frozen at potentially inappropriate levels.

3. **System-Wide Effect**: This impacts not just the Parliament contract but any contract whose MethodFeeController was changed to the inaccessible organization.

4. **No Recovery Mechanism**: There is no bypass, emergency override, or reset function. The Emergency Response Organization has no special powers to override this check. Once locked, the state is permanent and irreversible.

5. **Critical Invariant Violation**: Violates the governance invariant that "method-fee provider authority" must remain accessible for system adaptation.

### Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Capabilities Required:**
- Must be able to propose to the default Parliament organization (requires being a miner or whitelisted proposer)
- Must obtain sufficient votes (typically 2/3 approval) to pass a governance proposal
- No special privileges beyond normal governance participation

**Attack Complexity: Low**
1. Create organization with impossible thresholds (single transaction)
2. Create proposal to change MethodFeeController (single transaction)
3. Obtain legitimate governance approval (may require social engineering or appear as legitimate governance change)
4. Release approved proposal (single transaction)

**Feasibility Conditions:**
- The attack could be executed accidentally by well-intentioned governance participants who don't understand the irreversibility
- Could be executed maliciously by a compromised miner or through social engineering
- No technical barriers prevent execution once governance approval is obtained

**Detection Difficulty:**
- The proposal would appear as a normal governance action
- The dangerous threshold configuration (100% approval) might not be obvious to voters
- No circuit breaker or warning system exists to flag risky organization configurations

**Economic Rationality:**
- Attack cost is minimal (only transaction fees)
- Could be motivated by griefing, ransom demands, or competitive sabotage
- Accidental execution through governance error is realistic

### Recommendation

**Immediate Mitigations:**

1. **Add Maximum Threshold Validation** in `ChangeMethodFeeController()`: [1](#0-0) 

Add validation before line 28:
```csharp
// Validate that the organization has achievable thresholds
var organization = State.Organizations[input.OwnerAddress];
Assert(organization != null, "Organization does not exist.");
Assert(organization.ProposalReleaseThreshold.MinimalApprovalThreshold < 9000, 
    "Organization threshold too high for method fee controller.");
```

2. **Add Threshold Bounds in Organization Validation**: [2](#0-1) 

Add to validation logic:
```csharp
// For governance-critical roles, prevent unreachable thresholds
&& proposalReleaseThreshold.MinimalApprovalThreshold <= MaxSafeApprovalThreshold
```

3. **Add Emergency Recovery Mechanism**:
Create a time-locked fallback that allows the default organization to reclaim control after a sufficient period (e.g., 30 days) of inactivity from the current controller.

4. **Add Warning Events**:
Emit events when organizations with high thresholds (>80%) are created or assigned as controllers.

**Test Cases to Add:**
- Test that ChangeMethodFeeController rejects organizations with MinimalApprovalThreshold â‰¥ 9000
- Test recovery mechanism after controller becomes inaccessible
- Test that proposals fail with appropriate error messages when thresholds are unreachable

### Proof of Concept

**Initial State:**
- Parliament contract initialized with default organization (66.67% approval threshold)
- MethodFeeController = default Parliament organization

**Attack Sequence:**

**Step 1:** Create malicious organization with impossible thresholds
- Call `CreateOrganization` with:
  - MinimalApprovalThreshold = 10000 (100%)
  - MinimalVoteThreshold = 10000 (100%)
  - MaximalAbstentionThreshold = 0
  - MaximalRejectionThreshold = 0
- Transaction succeeds per test validation: [3](#0-2) 

**Step 2:** Create proposal to change MethodFeeController
- Create proposal through default organization to call `ChangeMethodFeeController`
- Target: Parliament contract
- Parameters: AuthorityInfo pointing to malicious organization from Step 1

**Step 3:** Obtain governance approval and release
- Get 2/3+ miner approvals (achievable through legitimate governance process)
- Release proposal
- MethodFeeController now points to inaccessible organization

**Step 4:** Verify permanent lockout
- Attempt to create proposal to change MethodFeeController back
- Proposal can be created and approved by miners
- Attempt to release proposal
- **Expected:** Proposal release succeeds
- **Actual:** Proposal can never be released because IsReleaseThresholdReached() returns false: [5](#0-4) 
- Any missing miner vote prevents reaching 100% threshold
- MethodFeeController permanently locked

**Success Condition:**
The MethodFeeController state is permanently set to the inaccessible organization address with no recovery mechanism available.

### Citations

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L62-73)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.DefaultOrganizationAddress.Value,
            ContractAddress = Context.Self
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L187-196)
```csharp
        {
            createOrganizationInput.ProposalReleaseThreshold = proposalReleaseThreshold;
            createOrganizationInput.ProposalReleaseThreshold.MinimalApprovalThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MinimalVoteThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MaximalAbstentionThreshold = 0;
            createOrganizationInput.ProposalReleaseThreshold.MaximalRejectionThreshold = 0;
            var transactionResult =
                await minerParliamentContractStub.CreateOrganization.SendAsync(createOrganizationInput);
            transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```
