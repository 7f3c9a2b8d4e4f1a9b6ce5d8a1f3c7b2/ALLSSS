### Title
Unvalidated RevealedInValues Allow PreviousInValue Poisoning Leading to Miner DoS

### Summary
The `UpdateLatestSecretPieces()` function accepts `RevealedInValues` from trigger information without validation and uses them to set other miners' `PreviousInValue` if currently `Hash.Empty` or `null`. A malicious miner can inject fake revealed values to poison victim miners' `PreviousInValue`, causing their subsequent blocks to fail validation since the `Hash.Empty` check prevents correction. This enables targeted denial-of-service attacks against specific miners in the consensus.

### Finding Description

**Root Cause**: The vulnerability exists in the `UpdateLatestSecretPieces()` function where `RevealedInValues` from trigger information are applied to other miners' `PreviousInValue` fields without cryptographic verification. [1](#0-0) 

The `RevealedInValues` are sourced from `AElfConsensusTriggerInformation` provided by the block producer: [2](#0-1) 

**Missing Validation**: The contract validation only checks the block producer's own `PreviousInValue`, not the revealed values for other miners: [3](#0-2) 

The validation context shows that only `SenderPubkey` (the block producer) is validated: [4](#0-3) 

**Why Protection Fails**: Once a `PreviousInValue` is set (even to a fake value), the `Hash.Empty`/`null` check in `ApplyNormalConsensusData` prevents legitimate updates: [5](#0-4) 

**Execution Path**:
1. Malicious Miner M modifies their node to provide fake `RevealedInValues[V] = FakeHash` instead of using legitimate secret sharing reconstruction
2. Miner M produces a block in Round N+1 where Victim V hasn't mined yet (so V's `PreviousInValue` is `Hash.Empty`)
3. The fake value gets applied to V's `PreviousInValue` via `UpdateLatestSecretPieces`
4. Block passes validation since only M's `PreviousInValue` is checked
5. When Victim V tries to mine, their correct `PreviousInValue` cannot overwrite the fake value due to the `Hash.Empty` check
6. V's block contains `PreviousInValue = FakeHash` in the proposed round data
7. Validation fails: `hash(FakeHash) != OutValue_V` from previous round where V successfully mined
8. V's block is rejected

The fake value also propagates through `SupplyCurrentRoundInformation` when filling missing consensus data: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Impact**: 
- Malicious miners can prevent specific victim miners from successfully producing blocks
- Causes targeted denial-of-service lasting at least one full round
- Disrupts miner schedule integrity and consensus fairness

**Economic Impact**:
- Victim miners lose block production rewards for rejected blocks
- Mining reputation (ProducedBlocks count) is not incremented while MissedTimeSlots increases
- Affects profitability calculations and future mining slot assignments

**Operational Impact**:
- Network could experience reduced block production rate if multiple miners are targeted
- Creates uncertainty in consensus predictability
- May cascade through rounds if fake values propagate via `SupplyCurrentRoundInformation`

**Affected Parties**:
- Individual miners who failed to mine in a previous round (setting up `Hash.Empty` condition)
- Network overall through reduced throughput and consensus reliability
- Token holders through potential delays in transaction finality

**Severity Justification**: HIGH - Allows consensus miners to arbitrarily exclude other miners from block production, violating consensus fairness and causing quantifiable economic harm through lost rewards.

### Likelihood Explanation

**Attacker Capabilities Required**:
- Must be an authorized consensus miner (high privilege but realistic in adversarial models)
- Must have ability to modify their node software to inject fake `RevealedInValues`
- No special cryptographic capabilities needed beyond being in miner set

**Attack Complexity**: LOW
- Simple modification to trigger information generation before block production
- No timing precision required - attacker just needs to produce a block before victim in a round
- No complex multi-step setup or coordination needed

**Feasibility Conditions**: MODERATE
- Victim must have missed mining in a previous round (common due to network issues, maintenance, or attacks)
- Attacker must produce a block before victim in the subsequent round (probability = 1/N where N is miner count, typically 50-100% for early miners)
- Secret sharing must be enabled (configurable feature) [7](#0-6) 

**Detection/Prevention Constraints**:
- Attack is detectable by comparing on-chain `RevealedInValues` with legitimate secret sharing reconstruction
- However, detection is post-facto - damage already done once block is executed
- No in-contract prevention mechanism exists
- Victims have no recourse once their `PreviousInValue` is poisoned for that round

**Probability Assessment**: MEDIUM-HIGH
- Miners routinely miss rounds due to operational issues (network latency, restarts, upgrades)
- Malicious miners in governance scenarios have strong incentive to exclude competitors
- Economic rational: cost is zero (just software modification), benefit is eliminating competition for rewards

### Recommendation

**Immediate Fix**: Add cryptographic validation of `RevealedInValues` in the contract before applying them:

```csharp
foreach (var revealedInValue in triggerInformation.RevealedInValues)
{
    if (!updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
        continue;
        
    var targetMiner = updatedRound.RealTimeMinersInformation[revealedInValue.Key];
    
    // CRITICAL FIX: Validate revealed value against previous round's OutValue
    if (TryToGetPreviousRoundInformation(out var prevRound) && 
        prevRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
    {
        var expectedOutValue = prevRound.RealTimeMinersInformation[revealedInValue.Key].OutValue;
        if (expectedOutValue != null && expectedOutValue != Hash.Empty)
        {
            // Only accept revealed value if it correctly hashes to the OutValue
            if (HashHelper.ComputeFrom(revealedInValue.Value) != expectedOutValue)
            {
                Context.LogDebug(() => $"Invalid revealed in value for {revealedInValue.Key}");
                continue; // Skip invalid revealed value
            }
        }
    }
    
    if (targetMiner.PreviousInValue == Hash.Empty || targetMiner.PreviousInValue == null)
        targetMiner.PreviousInValue = revealedInValue.Value;
}
```

**Additional Hardening**:
1. Add event emission when `RevealedInValues` are applied to enable off-chain monitoring
2. Implement threshold verification: require multiple miners to agree on revealed values before accepting
3. Add a grace period mechanism allowing miners to dispute and correct fake `PreviousInValue` within a time window

**Invariant to Enforce**:
- For any miner M with `PreviousInValue` set via `RevealedInValues`: `hash(PreviousInValue) MUST equal OutValue from previous round` if OutValue exists

**Test Cases**:
1. Inject fake `RevealedInValues` that don't hash to correct OutValue → should be rejected
2. Inject correct `RevealedInValues` that match OutValue → should be accepted
3. Attempt to overwrite correct `PreviousInValue` with fake revealed value → should be rejected even if `Hash.Empty` initially
4. Verify victim miner's block succeeds after attempted poisoning is blocked

### Proof of Concept

**Initial State**:
- Round N: Miner V successfully mines with `InValue_V = 0x1234...`, producing `OutValue_V = hash(InValue_V) = 0xabcd...`
- Round N stored in state with V's `OutValue = 0xabcd...`

**Attack Execution**:

**Step 1** - Round N+1 Setup:
- Miner V goes offline (or is otherwise unable to mine in Round N+1)
- All miners begin Round N+1 with `PreviousInValue = null` (new round)

**Step 2** - Malicious Miner M Produces Block:
- M modifies `AEDPoSTriggerInformationProvider` to inject:
  ```
  trigger.RevealedInValues["MinerV_Pubkey"] = FakeHash // Where FakeHash != InValue_V
  ```
- M produces block in Round N+1
- `UpdateLatestSecretPieces` executes:
  - Checks: V's `PreviousInValue == null` ✓
  - Sets: `Round[N+1].RealTimeMinersInformation[V].PreviousInValue = FakeHash`
- `UpdateValueValidationProvider` executes:
  - Only validates M's `PreviousInValue` (not V's revealed value) ✓
- Block accepted and state updated

**Step 3** - Victim V Attempts to Mine:
- V comes back online and attempts to produce block in Round N+1
- V's trigger information contains correct `PreviousInValue = InValue_V = 0x1234...`
- `ApplyNormalConsensusData` executes with `previousInValue = 0x1234...`
  - Checks: `RealTimeMinersInformation[V].PreviousInValue == Hash.Empty` ✗ (it's FakeHash)
  - V's `PreviousInValue` remains FakeHash, NOT updated to correct value
- V's block proposed with `PreviousInValue = FakeHash` in round data

**Step 4** - Validation Failure:
- `UpdateValueValidationProvider.ValidatePreviousInValue` executes:
  - `previousOutValue = Round[N].RealTimeMinersInformation[V].OutValue = 0xabcd...`
  - `previousInValue = FakeHash` (from proposed round data)
  - Validation: `hash(FakeHash) == 0xabcd...` ✗
- V's block REJECTED

**Expected Result**: V's block should be accepted with correct `PreviousInValue`

**Actual Result**: V's block rejected due to poisoned `PreviousInValue` that cannot be corrected

**Success Condition**: Transaction logs show V's block validation failure with message "Incorrect previous in value" while M's earlier block with fake revealed value was accepted

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L112-114)
```csharp
            var revealedInValues = _secretSharingService.GetRevealedInValues(hint.RoundId);
            foreach (var revealedInValue in revealedInValues)
                trigger.RevealedInValues.Add(revealedInValue.Key, revealedInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L17-17)
```csharp
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-193)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```
