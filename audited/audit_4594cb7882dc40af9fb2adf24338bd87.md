### Title
State Map Entries Not Cleaned Up Leading to Unbounded State Accumulation

### Summary
The NFT contract fails to remove state map entries when they reach zero or empty values, causing unbounded state growth over time. Through normal operations like transfers, burns, approvals, and operator management, zero-value entries accumulate in `BalanceMap`, `AllowanceMap`, `OperatorMap`, `MinterListMap`, `IsCreatedMap`, and `NftInfoMap`, increasing storage costs and bloating contract state without bound.

### Finding Description

The NFT contract defines multiple state maps but fails to implement proper cleanup logic when entries become obsolete:

**BalanceMap**: When tokens are transferred or burned, balances are decremented but zero-balance entries are never removed. [1](#0-0) 

The burn operation also leaves zero-balance entries: [2](#0-1) 

**AllowanceMap**: When allowances are consumed in `TransferFrom`, they are decremented but not removed when reaching zero: [3](#0-2) 

In `UnApprove`, allowances reaching zero or below are set to zero but the entry persists: [4](#0-3) 

The `Approve` method also doesn't remove zero allowances: [5](#0-4) 

**OperatorMap**: When operators are removed in `ApproveProtocol`, individual operators are removed from the list but empty lists remain in state: [6](#0-5) 

**MinterListMap**: When minters are removed, individual minters are deleted from the list but empty lists persist: [7](#0-6) 

**IsCreatedMap**: Symbol numbers are added during creation but never removed: [8](#0-7) 

**NftInfoMap**: NFT information persists even after burning, only setting a flag: [9](#0-8) 

In contrast, `AssembledNftsMap` and `AssembledFtsMap` properly use `.Remove()` during disassembly: [10](#0-9)  and [11](#0-10) 

The state map definitions confirm all these maps exist: [12](#0-11) 

### Impact Explanation

**Storage Cost Impact**: Users pay transaction fees for state updates in AElf, and the system charges resource tokens including STORAGE based on transaction size. Each obsolete entry increases the contract's state size, imposing unnecessary costs on users who interact with the contract.

**State Bloat**: Over time, the accumulated entries grow unbounded. A popular NFT protocol could accumulate millions of zero-balance entries, thousands of zero-allowance entries, and numerous empty operator/minter lists.

**Operational Degradation**: As state grows, queries and state access become less efficient. The contract state can become unnecessarily large, affecting blockchain node performance.

**Who is Affected**: All users of the NFT contract pay higher transaction fees due to the bloated state. The blockchain itself suffers from inefficient state storage.

**Severity Justification**: While this doesn't directly steal funds, it creates an economic burden on all users and degrades system performance over time. The issue occurs through normal operations, making it inevitable and affecting every NFT protocol created through this contract.

### Likelihood Explanation

**Attacker Capabilities**: No special capabilities required. Any user can trigger state accumulation through normal contract usage. An attacker could intentionally accelerate the issue by:
1. Creating NFT protocols
2. Minting tokens and distributing small amounts to many addresses
3. Transferring all balances away, leaving zero entries
4. Repeatedly approving and revoking allowances
5. Adding and removing operators/minters

**Attack Complexity**: Trivial. The issue occurs naturally during normal contract usage without any attack.

**Feasibility**: Extremely high. Every transfer that empties an account, every approval that gets consumed, and every operator removal contributes to state accumulation. Over months/years of normal usage, this becomes significant.

**Detection**: The state growth is gradual and difficult to detect until it becomes a significant problem. There are no transaction failures or error conditions that would alert users.

**Probability**: Certain. This will occur in every deployment of the contract through normal operations.

### Recommendation

Implement explicit cleanup logic to remove zero-value and empty entries:

1. **BalanceMap Cleanup**: In `DoTransfer` and `Burn`, after decrementing balances, check if the balance reaches zero and remove the entry:
```csharp
if (State.BalanceMap[tokenHash][from] == 0)
    State.BalanceMap[tokenHash].Remove(from);
```

2. **AllowanceMap Cleanup**: In `TransferFrom`, `UnApprove`, and `Approve`, remove zero allowances:
```csharp
if (State.AllowanceMap[tokenHash][owner][spender] == 0)
    State.AllowanceMap[tokenHash][owner].Remove(spender);
```

3. **OperatorMap Cleanup**: In `ApproveProtocol`, remove empty operator lists:
```csharp
if (operatorList.Value.Count == 0)
    State.OperatorMap[input.Symbol].Remove(Context.Sender);
else
    State.OperatorMap[input.Symbol][Context.Sender] = operatorList;
```

4. **MinterListMap Cleanup**: In `RemoveMinters`, remove empty minter lists:
```csharp
if (minterList.Value.Count == 0)
    State.MinterListMap.Remove(input.Symbol);
else
    State.MinterListMap[input.Symbol] = minterList;
```

5. **NftInfoMap Consideration**: Consider if burned NFT info with `IsBurned=true` should be retained for historical purposes or removed. Document this design decision.

6. **IsCreatedMap**: Evaluate if this map is necessary long-term or if an alternative approach could avoid permanent accumulation.

**Invariant Checks**: Add assertions to verify state size doesn't grow unboundedly in test suites.

**Test Cases**: Add regression tests that verify:
- Transferring all tokens removes the balance entry
- Using full allowance removes the allowance entry  
- Removing all operators removes the operator list entry
- Removing all minters removes the minter list entry

### Proof of Concept

**Initial State**: NFT protocol "AR123" exists with user Alice holding 100 tokens.

**Transaction Sequence**:

1. Alice transfers 100 tokens to Bob
   - Expected: Alice's balance becomes 0, entry should be removed
   - Actual: `State.BalanceMap[tokenHash][Alice] = 0` persists in state

2. Bob approves Charlie for 50 tokens
   - State: `State.AllowanceMap[tokenHash][Bob][Charlie] = 50`

3. Charlie calls `TransferFrom` to transfer 50 tokens from Bob to himself
   - Expected: Allowance becomes 0, entry should be removed
   - Actual: `State.AllowanceMap[tokenHash][Bob][Charlie] = 0` persists in state

4. Bob approves Dave as operator, then removes Dave
   - Expected: Empty operator list should be removed
   - Actual: `State.OperatorMap[symbol][Bob]` contains empty `AddressList` in state

5. Protocol creator removes all minters except themselves, then removes themselves
   - Expected: Empty minter list or minimal list
   - Actual: Empty or near-empty `MinterList` persists in state

**Success Condition**: Query state size before and after these operations. State size grows with each operation and never shrinks, demonstrating unbounded accumulation. Each user's interaction leaves permanent state artifacts even when they no longer hold tokens or have active approvals.

### Notes

The contrast with `AssembledNftsMap` and `AssembledFtsMap` (which properly use `.Remove()`) demonstrates that the developers were aware of cleanup requirements in some cases but failed to apply this pattern consistently across all state maps. This inconsistency suggests an oversight rather than an intentional design decision.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L52-54)
```csharp
        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L64-66)
```csharp
            var allowance = State.AllowanceMap[tokenHash][input.From][Context.Sender];
            Assert(allowance >= input.Amount, "Not approved.");
            State.AllowanceMap[tokenHash][input.From][Context.Sender] = allowance.Sub(input.Amount);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L94-94)
```csharp
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L99-101)
```csharp
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L209-209)
```csharp
            State.AssembledNftsMap.Remove(tokenHash);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L224-224)
```csharp
            State.AssembledFtsMap.Remove(tokenHash);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L247-252)
```csharp
            case false when operatorList.Value.Contains(input.Operator):
                operatorList.Value.Remove(input.Operator);
                break;
        }

        State.OperatorMap[input.Symbol][Context.Sender] = operatorList;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L298-298)
```csharp
        State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = input.Amount;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L313-317)
```csharp
        var oldAllowance = State.AllowanceMap[tokenHash][Context.Sender][input.Spender];
        var currentAllowance = oldAllowance.Sub(input.Amount);
        if (currentAllowance <= 0) currentAllowance = 0;

        State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = currentAllowance;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L361-365)
```csharp
        foreach (var minter in input.MinterList.Value)
            if (minterList.Value.Contains(minter))
                minterList.Value.Remove(minter);

        State.MinterListMap[input.Symbol] = minterList;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L27-27)
```csharp
        State.IsCreatedMap[randomNumber] = true;
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L10-45)
```csharp
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
```
