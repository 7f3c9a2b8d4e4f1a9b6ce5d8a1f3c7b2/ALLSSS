# Audit Report

## Title
Insufficient Fee Protection for Unconfigured Methods in Genesis Contract

## Summary
The Genesis contract's `GetMethodFee` implementation returns null for unconfigured methods instead of default fees, causing the fee collection system to skip base method fees entirely. This allows expensive operations like `DeployUserSmartContract` to be executed with only minimal transaction size fees if governance fails to configure them, enabling economic DoS attacks through under-priced contract deployment proposals.

## Finding Description

The Genesis contract implements a dangerous default behavior for unconfigured method fees that diverges from other system contracts. When `GetMethodFee` is called for an unconfigured method, it returns null: [1](#0-0) 

This null return propagates to the fee charging system in the MultiToken contract. When `methodFees` is null, the fee dictionary remains empty and base fee charging is skipped: [2](#0-1) 

The critical issue occurs in `ChargeTransactionFeesToBill` where base fees are only charged when the fee dictionary is non-empty: [3](#0-2) 

When `fee.Count == 0` (line 278), base fee charging is completely skipped. Only transaction size fees based on byte count are charged (lines 292-297), which are significantly lower than method-specific base fees (typically 1-10 ELF).

This affects expensive public operations like `DeployUserSmartContract`, which is callable by any user on mainnet without permission checks: [4](#0-3) [5](#0-4) 

On mainnet (where `Context.Variables.NativeSymbol == primaryTokenSymbol`), the method returns early at line 351 without any permission checks, making it publicly accessible.

This design contrasts sharply with other system contracts like Profit and Vote, which return default fees (1-10 ELF) for unconfigured methods: [6](#0-5) [7](#0-6) 

Test evidence shows fees are configured for `DeploySmartContract` but not for `DeployUserSmartContract`: [8](#0-7) 

While rate limiting exists per contract hash (72 hours), it doesn't prevent an attacker from proposing different contracts: [9](#0-8) [10](#0-9) 

## Impact Explanation

**Economic Impact:**
- Users pay only transaction size fees (typically 0.01-0.1 ELF based on bytes) instead of base method fees (1-10 ELF)
- Contract deployments become 10-100x cheaper than intended
- Attackers can spam governance system with cheap proposals at minimal cost

**Operational Impact:**
- Economic DoS: Flood governance with numerous cheap contract deployment proposals
- Overwhelm code check proposal system requiring BPs to validate each submission
- Degrade network performance through under-priced state-changing operations
- Create unfair economic advantage for exploiters over legitimate users

**Affected Parties:**
- Network validators facing increased computational load without adequate compensation
- Governance system burdened with proposal queue spam
- Legitimate users who properly pay fees for other operations

The severity is MEDIUM because while it doesn't result in direct fund theft, it enables significant economic exploitation and operational DoS of the governance system through systematically under-priced operations.

## Likelihood Explanation

**Preconditions:**
- Governance must fail to explicitly configure fees for `DeployUserSmartContract` via `SetMethodFee`
- Method remains publicly accessible on mainnet (currently true)

**Attack Complexity: LOW**
- No special permissions required
- Direct method invocation
- Simple transaction construction

**Feasibility: MEDIUM-HIGH**
- Test evidence shows `DeployUserSmartContract` fees are not configured in test suites
- Genesis contract's lack of default fees (unlike Profit/Vote) makes oversight more likely
- User contract deployment is a relatively newer feature that may have been overlooked during initial fee configuration
- Once discovered, exploitation is trivial and repeatable

**Detection:**
- Monitoring can detect unusual spikes in contract deployment proposals
- Low fee collection relative to operation count would be observable
- However, detection cannot prevent initial exploitation

The likelihood is rated MEDIUM-HIGH because the precondition (unconfigured fees) is plausible given test evidence and design inconsistencies, and exploitation requires no special capabilities once the precondition is met.

## Recommendation

**Option 1 (Preferred): Implement Default Fees**
Modify the Genesis contract's `GetMethodFee` to return default fees for unconfigured methods, consistent with Profit and Vote contracts:

```csharp
public override MethodFees GetMethodFee(StringValue input)
{
    var fees = State.TransactionFees[input.Value];
    if (fees != null) return fees;
    
    if (input.Value == nameof(ReleaseApprovedUserSmartContract))
    {
        return new MethodFees
        {
            MethodName = input.Value,
            IsSizeFeeFree = true
        };
    }
    
    // Return default fee for unconfigured methods
    return new MethodFees
    {
        MethodName = input.Value,
        Fees = {
            new MethodFee { 
                Symbol = Context.Variables.NativeSymbol, 
                BasicFee = 1_00000000  // 1 ELF default
            }
        }
    };
}
```

**Option 2: Explicit Fee Configuration**
Immediately configure fees for `DeployUserSmartContract` and other expensive unconfigured methods through governance proposal.

**Option 3: Stricter Rate Limiting**
Implement per-address rate limiting in addition to per-contract-hash limiting to prevent rapid proposal spam.

## Proof of Concept

```csharp
[Fact]
public async Task DeployUserSmartContract_WithoutConfiguredFees_OnlyChargesSizeFees()
{
    // Verify DeployUserSmartContract has no configured fees
    var methodFees = await BasicContractZeroStub.GetMethodFee.CallAsync(
        new StringValue { Value = nameof(BasicContractZeroStub.DeployUserSmartContract) });
    
    // Should be null for unconfigured method
    methodFees.ShouldBeNull();
    
    // Prepare minimal contract code
    var contractCode = File.ReadAllBytes(typeof(SimpleContract).Assembly.Location);
    var input = new UserContractDeploymentInput
    {
        Category = 0,
        Code = ByteString.CopyFrom(contractCode)
    };
    
    var balanceBefore = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultSender,
        Symbol = "ELF"
    });
    
    // Call DeployUserSmartContract (publicly accessible on mainnet)
    await BasicContractZeroStub.DeployUserSmartContract.SendAsync(input);
    
    var balanceAfter = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultSender,
        Symbol = "ELF"
    });
    
    var feeCharged = balanceBefore.Balance - balanceAfter.Balance;
    
    // Verify only minimal size fee was charged (much less than 1 ELF base fee)
    feeCharged.ShouldBeLessThan(10_000000); // Less than 0.1 ELF
    
    // This demonstrates the vulnerability: expensive operation costs only size fee
}
```

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L34-46)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var fees = State.TransactionFees[input.Value];
        if (fees == null && input.Value == nameof(ReleaseApprovedUserSmartContract))
        {
            fees = new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        }

        return fees;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-52)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L268-300)
```csharp
    private bool ChargeTransactionFeesToBill(ChargeTransactionFeesInput input, Address fromAddress,
        ref TransactionFeeBill bill,
        ref TransactionFreeFeeAllowanceBill allowanceBill, Dictionary<string, long> fee, bool isSizeFeeFree = false,
        TransactionFeeDelegations delegations = null)
    {
        var successToChargeBaseFee = true;

        SetOrRefreshTransactionFeeFreeAllowances(fromAddress);
        var freeAllowancesMap = CalculateTransactionFeeFreeAllowances(fromAddress);

        if (fee.Count != 0)
        {
            // If base fee is set before, charge base fee.
            successToChargeBaseFee =
                ChargeBaseFee(fee, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }

        //For delegation, if the base fee fails to be charged, the size fee will not be charged
        if (delegations != null && !successToChargeBaseFee)
        {
            return false;
        }

        var successToChargeSizeFee = true;
        if (!isSizeFeeFree)
        {
            // If IsSizeFeeFree == true, do not charge size fee.
            successToChargeSizeFee =
                ChargeSizeFee(input, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }

        return successToChargeBaseFee && successToChargeSizeFee;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L409-443)
```csharp
    public override DeployUserSmartContractOutput DeployUserSmartContract(UserContractDeploymentInput input)
    {
        AssertInlineDeployOrUpdateUserContract();
        AssertUserDeployContract();

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        Context.LogDebug(() => "BasicContractZero - Deployment user contract hash: " + codeHash.ToHex());

        AssertContractNotExists(codeHash);

        if (input.Salt != null)
        {
            AssertContractAddressAvailable(Context.Sender, input.Salt);
        }

        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformDeployUserSmartContract),
            input.ToByteString());

        // Fire event to trigger BPs checking contract code
        Context.Fire(new CodeCheckRequired
        {
            Code = input.Code,
            ProposedContractInputHash = proposedContractInputHash,
            Category = input.Category,
            IsSystemContract = false,
            IsUserContract = true
        });

        return new DeployUserSmartContractOutput
        {
            CodeHash = codeHash
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L35-59)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var methodFees = State.TransactionFees[input.Value];
        if (methodFees != null) return methodFees;

        switch (input.Value)
        {
            case nameof(CreateScheme):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
            default:
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 1_00000000 }
                    }
                };
        }
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L35-59)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var tokenAmounts = State.TransactionFees[input.Value];
        if (tokenAmounts != null) return tokenAmounts;

        switch (input.Value)
        {
            case nameof(Register):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
            default:
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 1_00000000 }
                    }
                };
        }
    }
```

**File:** test/AElf.Contracts.EconomicSystem.Tests/BVT/TransactionFeeProviderTests.cs (L110-122)
```csharp
    public async Task Genesis_FeeProvider_Test()
    {
        await ExecuteProposalForParliamentTransaction(ContractZeroAddress, MethodName, new MethodFees
        {
            MethodName = nameof(BasicContractZeroStub.DeploySmartContract),
            Fees = { TokenAmount }
        });
        var result = await BasicContractZeroStub.GetMethodFee.CallAsync(new StringValue
        {
            Value = nameof(BasicContractZeroStub.DeploySmartContract)
        });
        result.Fees.First().ShouldBe(TokenAmount);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-5)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
```
