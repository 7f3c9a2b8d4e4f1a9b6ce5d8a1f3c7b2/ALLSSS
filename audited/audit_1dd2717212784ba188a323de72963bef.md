### Title
Byzantine Miners Can Prevent LIB Finalization by Deliberately Skipping Rounds

### Summary
Miners controlling more than 1/3 of the network can prevent Last Irreversible Block (LIB) finalization by deliberately not producing blocks in alternating rounds. When a new round is generated, all miners' `ImpliedIrreversibleBlockHeight` values default to 0, and the LIB calculation filters out these zero values, causing finalization to halt if fewer than 2/3+1 miners have positive values from the previous round.

### Finding Description

The vulnerability exists in the interaction between round generation and LIB calculation:

**Root Cause - Zero Initialization:**
When a new round is generated, `MinerInRound` objects are created without explicitly setting `ImpliedIrreversibleBlockHeight`, causing it to default to 0: [1](#0-0) [2](#0-1) 

`ImpliedIrreversibleBlockHeight` is only set to a positive value when a miner actually produces a block: [3](#0-2) 

**Filtering Mechanism:**
The LIB calculation filters out miners with non-positive `ImpliedIrreversibleBlockHeight`: [4](#0-3) 

**LIB Calculation Failure:**
If fewer than `MinersCountOfConsent` (2/3+1) miners have positive values, the LIB calculation returns 0: [5](#0-4) 

**LIB Freeze:**
When `libHeight` is 0, the condition to update `ConfirmedIrreversibleBlockHeight` fails, preventing LIB advancement: [6](#0-5) 

**Why Existing Protections Fail:**
The evil miner detection only triggers after 4,320 missed time slots (3 days), allowing sustained attacks: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Concrete Harm:**
- **Finalization DoS**: LIB stops advancing, eliminating finality guarantees for all transactions
- **Cross-Chain Operations Blocked**: Cross-chain transfers and indexing depend on LIB heights and would halt
- **Application Delays**: Any application waiting for finalization would be indefinitely delayed
- **Chain Security Degradation**: Without finality, the chain becomes vulnerable to long-range reorganization attacks

**Severity Justification:**
This is a **High** severity vulnerability because:
1. It breaks a critical consensus invariant (LIB progression)
2. It affects the entire network, not just individual users
3. It enables sustained DoS on a fundamental chain property
4. The attack requires only >1/3 Byzantine miners, which is within the standard Byzantine fault tolerance threat model

### Likelihood Explanation

**Attacker Capabilities:**
- Must control >1/3 of miner nodes (e.g., 6 out of 17 miners with default configuration)
- Must coordinate these miners to skip the same rounds
- No special privileges beyond being elected miners are required

**Attack Complexity:**
- **Low**: Attack simply involves not producing blocks in specific rounds
- **Coordination**: Requires coordinated behavior but no sophisticated exploits
- **Detection**: Attack is detectable (miners missing blocks) but not immediately punished

**Feasibility Conditions:**
- Standard Byzantine adversary assumption (>1/3 corrupt miners)
- Attack can be executed repeatedly with alternating skip patterns
- Cost is minimal: one round of missed block rewards per attack cycle

**Economic Rationality:**
- **Attack Cost**: Lost block rewards for one round (relatively small)
- **Punishment Delay**: 4,320 missed slots before evil miner detection
- **Attack Duration**: Can sustain for multiple rounds/days before punishment
- **Motivation**: Competitors, ransom, or chain disruption

**Probability Assessment:** Medium-High likelihood given realistic Byzantine adversary assumptions.

### Recommendation

**Code-Level Mitigation:**

1. **Carry Forward Previous Heights**: When generating a new round, carry forward the `ImpliedIrreversibleBlockHeight` from the previous round instead of resetting to 0:

```csharp
// In Round_Generation.cs, GenerateNextRoundInformation
nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
{
    Pubkey = minerInRound.Pubkey,
    Order = order,
    ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
    ProducedBlocks = minerInRound.ProducedBlocks,
    MissedTimeSlots = minerInRound.MissedTimeSlots,
    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight // ADD THIS
};
```

2. **Use All Miners for LIB, Not Just Mined**: Instead of only considering miners who mined in the current round, consider all miners from the previous round:

```csharp
// In AEDPoSContract_LIB.cs
var allMiners = _previousRound.RealTimeMinersInformation.Keys.ToList();
var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(allMiners);
```

3. **Add Invariant Check**: Assert that sufficient miners participated in the previous round before attempting LIB calculation.

**Test Cases:**
- Test LIB calculation when >1/3 miners miss a round
- Test that LIB continues advancing even with partial miner participation
- Test evil miner detection triggers appropriately

### Proof of Concept

**Initial State:**
- 17 miners in the network
- Attacker controls 7 miners (>1/3)
- Chain at height 1000, round N-1 completed normally

**Attack Sequence:**

1. **Round N-1**: All 17 miners produce blocks normally
   - All miners have `ImpliedIrreversibleBlockHeight` set to their respective block heights (990-1006)

2. **Round N**: Attacker's 7 miners deliberately skip all time slots
   - They don't call `UpdateValue`, so no blocks produced
   - Their `SupposedOrderOfNextRound` remains 0 in Round N
   - Their `ImpliedIrreversibleBlockHeight` remains 0 in Round N
   - Only 10 honest miners produce blocks (heights 1007-1016)

3. **Round N+1**: Attacker's 7 miners resume producing blocks
   - They now have `SupposedOrderOfNextRound != 0` in Round N+1
   - They're included in `GetMinedMiners()` for Round N+1
   - LIB calculation executes during their block production

4. **LIB Calculation Failure**:
   - Gets mined miners from Round N+1: 17 miners (all mining)
   - Looks up their `ImpliedIrreversibleBlockHeight` from Round N
   - 7 attackers have value 0 (filtered out)
   - 10 honest miners have positive values
   - `MinersCountOfConsent` = 2/3 * 17 + 1 = 12 required
   - Only 10 positive values available
   - Condition fails, `libHeight = 0`, LIB doesn't advance

5. **Sustained Attack**: Repeat steps 2-4 in alternating rounds
   - LIB remains frozen at height ~1006
   - Can continue for days before evil miner threshold reached
   - Cross-chain and finality-dependent operations halt

**Expected vs Actual:**
- **Expected**: LIB should advance even with partial miner participation
- **Actual**: LIB freezes when >1/3 miners coordinate to skip specific rounds

**Success Condition:** Monitor `ConfirmedIrreversibleBlockHeight` - it will not increase during the attack rounds despite new blocks being produced.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L46-55)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L14-16)
```csharp
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-30)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-281)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```
