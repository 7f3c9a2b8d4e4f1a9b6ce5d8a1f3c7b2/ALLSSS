# Audit Report

## Title
Contract Deployment Path Bypasses ACS Fee Standard Validation Allowing Fee-Free Transaction Execution

## Summary
The Genesis contract's `ProposeNewContract` deployment path fails to enforce ACS standard validation, allowing contracts to be deployed without implementing ACS1 or ACS12. This bypasses the protocol's fee enforcement mechanism, enabling completely fee-free transaction execution for governance-approved contracts.

## Finding Description

The vulnerability exists in the Genesis contract's dual deployment architecture, where contracts can be deployed via two distinct paths with fundamentally different validation behaviors.

**Vulnerable Path - ProposeNewContract:**
The `ProposeNewContract` method creates governance proposals for contract deployment but fires the `CodeCheckRequired` event without setting `IsUserContract=true`. [1](#0-0) 

**Secure Path - DeployUserSmartContract:**
In contrast, `DeployUserSmartContract` explicitly sets `IsUserContract=true` when firing the code check event. [2](#0-1) 

**Root Cause - Conditional ACS Validation:**
The code check service only retrieves and enforces ACS requirements when `isUserContract` is true. When this flag is false (as with `ProposeNewContract`), the `requiredAcs` remains empty and no ACS validation occurs. [3](#0-2) 

**Fee Enforcement Bypass:**
Transaction fees are enforced via pre-execution plugins that check whether contracts implement ACS1 (for regular fees) or ACS12 (for user contract fees). These plugins inspect the contract's service descriptors at runtime. [4](#0-3) 

When a contract lacks ACS1/ACS12 implementation, the plugin's `IsApplicableToTransaction` returns false, causing an empty transaction list to be returned - meaning no fee-charging pre-transaction is generated. [5](#0-4) 

**Protocol Invariant Violation:**
Significantly, ALL system contracts in the codebase implement ACS1_TransactionFeeProvider, including Genesis, Parliament, MultiToken, and Consensus contracts. This establishes a clear protocol expectation that contracts should implement fee standards regardless of privilege level. The ProposeNewContract path violates this invariant by allowing deployment without ACS validation.

**Missing Authorization Control:**
The authorization check in `ProposeNewContract` is commented out, allowing any address to create proposals (though governance approval is still required). [6](#0-5) 

## Impact Explanation

**Direct Economic Impact:**
- **Complete fee bypass**: Transactions to contracts deployed via this path execute without paying any fees (neither base fees nor size fees)
- **Protocol revenue loss**: The blockchain loses 100% of transaction fee revenue from affected contracts
- **Resource exploitation**: Network computational resources can be consumed without economic compensation

**Systemic Risk:**
- **Unfair advantage**: Operators of these contracts gain competitive advantage over legitimate fee-paying contracts
- **Economic sustainability threat**: If multiple contracts exploit this path, it undermines the protocol's fee-based economic model
- **Governance privilege escalation**: This represents mis-scoped privilege where governance's approval power lacks proper constraints

**Who Is Affected:**
- Protocol economic mechanisms (fee burn, distribution to validators, treasury)
- Legitimate users and developers who pay fees properly
- Network validators bearing costs without compensation
- Overall blockchain economic fairness and sustainability

**Severity Justification (HIGH):**
The severity is HIGH because it directly violates a fundamental protocol invariant (all non-system contracts must have fee-paying capability), creates measurable economic loss, and provides a systematic bypass mechanism. Even honest governance cannot protect against this if they don't realize the contract lacks fee implementation.

## Likelihood Explanation

**Attack Preconditions:**
1. Ability to create proposals via `ProposeNewContract` (unrestricted due to commented authorization check)
2. Obtain governance approval from ContractDeploymentController organization (typically Parliament)
3. Obtain code check approval from CodeCheckController organization

**Feasibility Assessment (MEDIUM):**
While governance approval is required, several factors make exploitation feasible:

1. **Information Asymmetry**: Governance reviewers may focus on contract functionality and security without specifically checking for ACS1/ACS12 implementation, especially since there's no protocol-level warning or validation failure

2. **Legitimate Appearance**: A contract can be fully functional and appear properly designed while lacking fee-paying standards - this is not obvious without specific inspection

3. **Miner Conflict of Interest**: In Parliament-controlled governance, miners can both propose and approve contracts, creating incentive alignment for fee avoidance

4. **Protocol Design Flaw**: The separation of deployment paths suggests this may be incomplete implementation rather than intentional design, given that even privileged system contracts implement ACS1

**Detection Difficulty:**
Once deployed, these contracts appear normal - only runtime analysis of transaction execution would reveal the missing fee deductions, making this vulnerability hard to detect post-deployment.

**Risk Assessment:**
The combination of protocol-level validation failure, information asymmetry in governance review, and economic incentives for exploitation creates a MEDIUM likelihood scenario, particularly in environments where governance oversight processes don't explicitly verify ACS implementation.

## Recommendation

**Primary Fix - Enforce ACS Validation:**
Modify `ProposeNewContract` to fire `CodeCheckRequired` with `IsUserContract=true` for all non-system contracts:

```csharp
Context.Fire(new CodeCheckRequired
{
    Code = ExtractCodeFromContractCodeCheckInput(input),
    ProposedContractInputHash = proposedContractInputHash,
    Category = input.Category,
    IsSystemContract = input.IsSystemContract,
    IsUserContract = !input.IsSystemContract  // Add this line
});
```

**Secondary Fix - Restore Authorization:**
Uncomment and implement the `AssertDeploymentProposerAuthority` check in `ProposeNewContract` to restrict who can create proposals.

**Tertiary Fix - Explicit Validation:**
Add explicit validation in the contract deployment flow to verify ACS1 implementation for all non-system contracts before allowing deployment, regardless of deployment path.

**Protocol-Level Fix:**
Consider consolidating the deployment paths or making the distinction explicit with clear documentation of when each path should be used and what guarantees each provides.

## Proof of Concept

A proof of concept would require:
1. Deploying a contract via `ProposeNewContract` that lacks ACS1/ACS12 implementation
2. Obtaining governance approval through the proposal system
3. Executing transactions on the deployed contract
4. Verifying no fee pre-transactions are generated
5. Confirming transaction execution succeeds without fee deduction

The test would demonstrate that transactions to such contracts execute completely fee-free, validating the complete bypass of the fee enforcement mechanism.

**Notes:**
- This vulnerability represents a mis-scoped privilege issue where governance's contract approval power lacks proper protocol-level constraints
- Even system contracts implement ACS1, establishing that fee-paying capability is a universal requirement
- The missing validation creates information asymmetry where governance cannot reliably ensure contracts meet protocol standards
- This is not merely a governance failure but a protocol design flaw that allows the invariant violation to occur

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L124-124)
```csharp
        // AssertDeploymentProposerAuthority(Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L266-272)
```csharp
        Context.Fire(new CodeCheckRequired
        {
            Code = ExtractCodeFromContractCodeCheckInput(input),
            ProposedContractInputHash = proposedContractInputHash,
            Category = input.Category,
            IsSystemContract = input.IsSystemContract
        });
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L430-437)
```csharp
        Context.Fire(new CodeCheckRequired
        {
            Code = input.Code,
            ProposedContractInputHash = proposedContractInputHash,
            Category = input.Category,
            IsSystemContract = false,
            IsUserContract = true
        });
```

**File:** src/AElf.Kernel.CodeCheck/Application/CodeCheckService.cs (L37-40)
```csharp
        if (isUserContract)
        {
            requiredAcs = await _requiredAcsProvider.GetRequiredAcsInContractsAsync(blockHash, blockHeight);
        }
```

**File:** src/AElf.Kernel.SmartContract/Application/SmartContractExecutionPluginBase.cs (L16-19)
```csharp
    protected bool HasApplicableAcs(IReadOnlyList<ServiceDescriptor> descriptors)
    {
        return descriptors.Any(service => service.File.GetIdentity() == _acsSymbol);
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L77-78)
```csharp
            if (!IsApplicableToTransaction(descriptors, transactionContext.Transaction, tokenContractAddress))
                return new List<Transaction>();
```
