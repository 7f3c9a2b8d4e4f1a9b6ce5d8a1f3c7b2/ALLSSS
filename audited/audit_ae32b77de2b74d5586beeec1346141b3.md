### Title
Missing Round Number Gap Validation in Cross-Chain Consensus Updates Allows Acceptance of Unrealistic Main Chain State

### Summary
The `UpdateInformationFromCrossChain()` function accepts main chain consensus information without validating the gap between consecutive round numbers. While parent chain block heights are validated to increment sequentially, the consensus round numbers embedded within those blocks can jump arbitrarily (e.g., from round 100 to round 10,100), which a compromised or malicious main chain could exploit to inject unrealistic consensus state into side chains.

### Finding Description
The vulnerability exists in the `UpdateInformationFromCrossChain()` function which only validates that incoming round numbers are strictly greater than the previously stored value, without checking if the gap is reasonable. [1](#0-0) 

The validation logic simply checks:
- If `consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value`, it returns early
- Otherwise, it accepts and stores the new round number without any upper bound validation [2](#0-1) 

In contrast, the side chain's own consensus validation enforces strict sequential progression where round numbers must increment by exactly 1: [3](#0-2) 

While parent chain block heights are validated to increment sequentially through `AssertParentChainBlock()`: [4](#0-3) 

This validation only applies to block heights, not to the consensus round numbers contained within the `ExtraData[ConsensusExtraDataName]` field. The consensus information is extracted and passed to `UpdateConsensusInformation()` without round number gap validation: [5](#0-4) 

No constants exist in the codebase to define maximum acceptable round number gaps for cross-chain updates: [6](#0-5) 

### Impact Explanation
A compromised or malicious main chain could embed consensus data with artificially inflated round numbers (e.g., jumping 1000+ rounds) in legitimate parent chain blocks. Since parent chain blocks are indexed sequentially and only block heights are validated, the side chain would accept this unrealistic round number progression.

**Concrete impacts:**
1. **Consensus Integrity**: The side chain tracks `MainChainRoundNumber` and `MainChainCurrentMinerList` for consensus operations, treating this data as authoritative main chain state
2. **Trust Model Violation**: Side chains assume main chain consensus progresses reasonably; accepting inflated round numbers breaks this trust assumption
3. **Operational Disruption**: Unrealistic round numbers could affect side chain components that rely on main chain consensus timing and progression
4. **Detection Difficulty**: Large gaps provide clear evidence of main chain compromise that should be detected and rejected

The severity is **Medium** because while it requires main chain compromise as a precondition, it represents a complete failure to validate consensus data integrity during cross-chain updates.

### Likelihood Explanation
**Attacker Capabilities Required:**
- Compromise or control of the main chain to inject malicious consensus data into parent chain blocks
- Ability to produce valid parent chain blocks with manipulated consensus extra data

**Attack Complexity:**
- Low complexity once main chain is compromised - simply include inflated round numbers in consensus extra data
- The side chain will automatically accept this data through normal cross-chain indexing

**Feasibility Conditions:**
- Function is callable only by CrossChain contract (authorization check in place)
- Parent chain blocks must pass height sequencing validation
- Round number must be greater than current stored value (trivially satisfied with inflated values)

**Probability Assessment:**
Main chain compromise is a significant precondition, but if it occurs, this vulnerability provides no defense-in-depth. The likelihood is **Medium** because:
1. The attack path is straightforward once preconditions are met
2. No additional validation exists to detect or prevent exploitation
3. The vulnerability represents missing sanity checks that should exist regardless of trust assumptions

### Recommendation
Implement round number gap validation in `UpdateInformationFromCrossChain()` to detect unreasonably large jumps that indicate potential main chain compromise or data integrity issues.

**Code-level mitigation:**
Add a maximum acceptable round number gap constant and validation logic:

```csharp
// In AEDPoSContractConstants.cs
public const long MaximumAcceptableMainChainRoundGap = 1000; // Configurable based on expected main chain progression

// In UpdateInformationFromCrossChain() after line 47
var roundGap = consensusInformation.Round.RoundNumber - State.MainChainRoundNumber.Value;
Assert(roundGap <= AEDPoSContractConstants.MaximumAcceptableMainChainRoundGap, 
    $"Round number gap ({roundGap}) exceeds maximum acceptable gap. Possible main chain compromise detected.");
```

**Invariant to enforce:**
For cross-chain consensus updates: `NewRoundNumber - CurrentRoundNumber <= MaximumAcceptableMainChainRoundGap`

**Test cases to add:**
1. Test accepting reasonable round number increments (gaps of 1-100)
2. Test rejecting unreasonably large gaps (gaps of 1000+)
3. Test boundary conditions at the maximum gap threshold
4. Test that legitimate multi-block parent chain updates within reasonable bounds are accepted

### Proof of Concept
**Initial State:**
- Side chain initialized with `MainChainRoundNumber = 100`
- Parent chain indexed up to height 1000

**Attack Sequence:**
1. Compromised main chain produces block at height 1001 with consensus extra data containing `RoundNumber = 10100` (gap of 10,000 rounds)
2. Main chain miner proposes indexing this block through normal cross-chain indexing proposal process
3. CrossChain contract calls `IndexParentChainBlockData()` with the block data
4. `AssertParentChainBlock()` validates block height is 1001 (currentHeight + 1) ✓
5. `UpdateConsensusInformation()` is called with the consensus extra data
6. `UpdateInformationFromCrossChain()` checks: `10100 > 100` ✓
7. Side chain accepts and stores `MainChainRoundNumber = 10100`

**Expected Result:**
Function should reject the update and revert with error about unreasonably large round number gap

**Actual Result:**
Function accepts the inflated round number without validation, updating state to reflect an unrealistic 10,000 round jump

**Success Condition:**
Verify that `State.MainChainRoundNumber.Value` is updated to 10100 and `State.MainChainCurrentMinerList` is updated based on the malicious consensus data, demonstrating complete absence of gap validation.

### Notes
While the precondition of main chain compromise is significant, defense-in-depth principles dictate that side chains should validate consensus data for basic sanity even when trusting the main chain. The strict sequential validation applied to the side chain's own consensus (exact +1 increment) contrasts sharply with the complete absence of gap validation for main chain updates. This asymmetry represents a security gap that should be addressed to maintain consensus integrity guarantees.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L46-47)
```csharp
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L55-55)
```csharp
        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-30)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L338-346)
```csharp
    private void AssertParentChainBlock(int parentChainId, long currentRecordedHeight,
        ParentChainBlockData parentChainBlockData)
    {
        Assert(parentChainId == parentChainBlockData.ChainId, "Wrong parent chain id.");
        Assert(currentRecordedHeight + 1 == parentChainBlockData.Height,
            $"Parent chain block info at height {currentRecordedHeight + 1} is needed, not {parentChainBlockData.Height}");
        Assert(parentChainBlockData.TransactionStatusMerkleTreeRoot != null,
            "Parent chain transaction status merkle tree root needed.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L783-788)
```csharp
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L1-16)
```csharp
namespace AElf.Contracts.Consensus.AEDPoS;

// ReSharper disable once InconsistentNaming
public static class AEDPoSContractConstants
{
    public const int MaximumTinyBlocksCount = 8;
    public const long InitialMiningRewardPerBlock = 12500000;
    public const long TimeToReduceMiningRewardByHalf = 126144000; // 60 * 60 * 24 * 365 * 4
    public const int SupposedMinersCount = 17;
    public const int KeepRounds = 40960;
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
    public const string SideChainShareProfitsTokenSymbol = "SHARE";
    public const string PayTxFeeSymbolListName = "SymbolListToPayTxFee";
    public const string PayRentalSymbolListName = "SymbolListToPayRental";
    public const string SecretSharingEnabledConfigurationKey = "SecretSharingEnabled";
}
```
