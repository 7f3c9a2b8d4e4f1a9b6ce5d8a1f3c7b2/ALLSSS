### Title
Reentrancy Vulnerability in DistributeProfits Causes Lost Updates to Scheme State

### Summary
The `PerformDistributeProfits` function uses `SendVirtualInline` to transfer tokens, which can trigger callbacks through the MultiToken contract's transfer callback mechanism. A malicious token with a transfer callback can reenter the Profit contract and call `ClaimProfits`, modifying `TotalShares` and `CachedDelayTotalShares`. These modifications are then lost when `DistributeProfits` saves its stale local copy of the scheme, causing permanent corruption of the scheme's accounting state.

### Finding Description

The vulnerability exists in the profit distribution flow where external token transfers are made before all state updates are finalized: [1](#0-0) 

The scheme is read into a local variable at the beginning, and state modifications during distribution occur on this local copy. The external transfer happens via `SendVirtualInline`: [2](#0-1) 

The MultiToken contract's `Transfer` method includes a callback mechanism that executes custom logic if a token has `TransferCallbackExternalInfoKey` set in its `ExternalInfo`: [3](#0-2) 

During the callback, an attacker can invoke `ClaimProfits`, which reads a fresh copy of the scheme from state, modifies `TotalShares` and `CachedDelayTotalShares`, and saves it: [4](#0-3) 

After the callback returns and `PerformDistributeProfits` completes, `DistributeProfits` modifies its stale local `scheme` variable and saves it back to state, overwriting the changes made during reentrancy.

The contract has no reentrancy guards, and follows an unsafe pattern of: read state → make external call → write state, violating the checks-effects-interactions pattern.

### Impact Explanation

**Direct Financial Impact:**
When `ClaimProfits` removes expired profit details during reentrancy, it subtracts those shares from `TotalShares`. However, this update is lost when `DistributeProfits` overwrites the scheme. This causes `TotalShares` to remain artificially inflated, leading to:

1. **Diluted Distributions**: All future profit distributions use the incorrect (inflated) `TotalShares` value. Each beneficiary receives less than their fair share since the calculation is `SafeCalculateProfits(beneficiaryShares, totalAmount, totalShares)` - a larger denominator means smaller payouts.

2. **Permanent Value Leakage**: The shares corresponding to removed beneficiaries remain counted in `TotalShares` but cannot be claimed. In each distribution, the amount that should be distributed to these phantom shares accumulates as unclaimed funds in the contract.

3. **Corrupted Delay Cache**: The `CachedDelayTotalShares` map also becomes incorrect, affecting schemes with `DelayDistributePeriodCount > 0`, causing compounding errors in delayed distribution calculations.

**Affected Parties:**
- All current and future beneficiaries of the corrupted scheme receive reduced profit distributions
- The scheme manager loses ability to accurately track and distribute profits
- The protocol suffers reputational damage from broken profit distribution mechanics

**Severity Justification:**
This is a Medium severity issue because:
- It corrupts critical accounting state permanently
- Every subsequent distribution is affected
- It causes measurable but gradual value leakage rather than immediate large-scale theft
- The impact scales with the size of incorrectly counted shares and number of distributions

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Create a malicious token with `TransferCallbackExternalInfoKey` in its `ExternalInfo` pointing to an attacker-controlled contract
2. Contribute this token to a target profit scheme via `ContributeProfits` (which anyone can call)
3. Be a beneficiary with claimable profits in the scheme
4. Wait for the scheme manager to call `DistributeProfits`

**Attack Complexity:**
The attack is straightforward to execute:
1. Create malicious token with transfer callback (requires seed NFT or being in create whitelist)
2. Contribute token to scheme using `ContributeProfits`
3. If scheme has `IsReleaseAllBalanceEveryTimeByDefault = true`, the malicious token will be auto-distributed
4. Callback triggers during distribution, attacker calls `ClaimProfits`
5. Lost update occurs automatically [5](#0-4) 

**Feasibility Conditions:**
- Token creation mechanisms in AElf allow arbitrary `ExternalInfo` settings
- `ContributeProfits` has no whitelist - anyone can contribute any token
- Many schemes use `IsReleaseAllBalanceEveryTimeByDefault` for convenience
- The MultiToken callback mechanism is an intended feature, not a bug

**Detection/Operational Constraints:**
- The attack is difficult to detect as it appears as normal `ClaimProfits` activity
- The state corruption is subtle and may not be noticed immediately
- No transaction will revert - the attack succeeds silently
- Historical data shows `TotalShares` decreasing then mysteriously increasing back

**Probability Assessment:**
Medium-High probability because:
- Preconditions are achievable by any user
- No special permissions required beyond normal token creation
- Economic incentive exists in schemes with significant value
- Attack can be repeated across multiple schemes

### Recommendation

**Immediate Mitigation:**
Implement a reentrancy guard using a mutex pattern:

```csharp
// Add to ProfitContractState.cs
public BoolState Locked { get; set; }

// Add to beginning of DistributeProfits
Assert(!State.Locked.Value, "Reentrant call detected");
State.Locked.Value = true;

// Add before return/at end of DistributeProfits
State.Locked.Value = false;
```

**Proper Fix - Follow Checks-Effects-Interactions:**
Restructure `DistributeProfits` to complete all state updates before making external calls:

1. Read scheme from state once
2. Calculate all distribution amounts
3. Update `CurrentPeriod`, `CachedDelayTotalShares`, and all other scheme state
4. Save scheme to state
5. Only then make external token transfer calls
6. If transfers fail, revert entire transaction

**Additional Safeguards:**
1. Add a scheme-level whitelist for allowed tokens to prevent malicious token injection
2. Validate that distributed tokens don't have suspicious callbacks
3. Consider using `TransferFrom` with approval instead of virtual inline transfers
4. Add events logging when reentrancy attempts are detected

**Test Cases:**
1. Create scheme with beneficiaries and malicious callback token
2. Call `DistributeProfits` with malicious token
3. In callback, call `ClaimProfits` to remove expired details
4. Verify `TotalShares` remains consistent after distribution completes
5. Verify reentrancy guard prevents nested `DistributeProfits` calls
6. Test with multiple beneficiaries and various callback timings

### Proof of Concept

**Initial State:**
- Profit scheme exists with SchemeId = SCHEME_ID
- Scheme has 1000 total shares: Beneficiary A (600 shares), Beneficiary B (400 shares)
- Beneficiary A has expired profit details (100 shares from old period)
- Malicious token EVIL with transfer callback created by attacker
- Attacker is Beneficiary A

**Attack Sequence:**

1. **Setup**: Attacker contributes EVIL token to scheme
   ```
   ContributeProfits(SchemeId: SCHEME_ID, Symbol: "EVIL", Amount: 10000, Period: 0)
   ```

2. **Trigger**: Scheme manager distributes profits
   ```
   DistributeProfits(SchemeId: SCHEME_ID, AmountsMap: {}, Period: N)
   ```
   - Line 422: Reads scheme with TotalShares = 1000
   - Line 490: Marks period N as released
   - Line 592: Calls `DistributeProfitsForSubSchemes`
   - Line 596: Calls `SendVirtualInline` to transfer EVIL tokens

3. **Reentrancy**: EVIL token callback executes
   ```
   // In malicious callback:
   ClaimProfits(SchemeId: SCHEME_ID, Beneficiary: Attacker)
   ```
   - Line 752: Reads fresh scheme from state (TotalShares = 1000)
   - Lines 787-792: Removes 100 expired shares, TotalShares becomes 900
   - Line 799: Saves scheme with TotalShares = 900

4. **Lost Update**: `DistributeProfits` continues
   - Line 494: Modifies local scheme's CurrentPeriod (still has TotalShares = 1000)
   - Line 496: Saves stale scheme, **TotalShares reverts to 1000**

**Expected Result:**
TotalShares should be 900 after expired details are removed

**Actual Result:**
TotalShares is 1000, causing all future distributions to be diluted by the phantom 100 shares

**Success Condition:**
Query `GetScheme(SCHEME_ID)` after attack completes:
- TotalShares shows 1000 instead of correct 900
- Future distributions give each beneficiary `amount * shares / 1000` instead of `amount * shares / 900`
- ~10% of each distribution becomes unclaimed/stuck funds

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L417-499)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        if (input.AmountsMap.Any())
            Assert(input.AmountsMap.All(a => !string.IsNullOrEmpty(a.Key)), "Invalid token symbol.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");

        ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);

        var profitsMap = new Dictionary<string, long>();
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }

        var totalShares = scheme.TotalShares;

        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }

        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");

        var profitsReceivingVirtualAddress =
            GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, releasingPeriod);

        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);

        Context.LogDebug(() => $"Receiving virtual address: {profitsReceivingVirtualAddress}");

        UpdateDistributedProfits(profitsMap, profitsReceivingVirtualAddress, totalShares);

        PerformDistributeProfits(profitsMap, scheme, totalShares, profitsReceivingVirtualAddress);

        scheme.CurrentPeriod = input.Period.Add(1);

        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L585-604)
```csharp
    private void PerformDistributeProfits(Dictionary<string, long> profitsMap, Scheme scheme, long totalShares,
        Address profitsReceivingVirtualAddress)
    {
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
            Context.LogDebug(() => $"Distributing {remainAmount} {symbol} tokens.");
            // Transfer remain amount to individuals' receiving profits address.
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-721)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
        // ReSharper disable once PossibleNullReferenceException
        var virtualAddress = scheme.VirtualAddress;

        if (input.Period == 0)
        {

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = virtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = $"Add {input.Amount} dividends."
            });
        }
        else
        {
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
        }

        // If someone directly use virtual address to do the contribution, won't sense the token symbol he was using.
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);

        State.SchemeInfos[scheme.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-799)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```
