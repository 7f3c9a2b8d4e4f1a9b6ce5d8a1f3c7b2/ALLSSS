### Title
Integer Overflow in Fee Aggregation via LINQ Sum() with Unchecked Arithmetic

### Summary
The `AssertValidToken` method fails to validate against `long.MaxValue`, and the fee aggregation logic uses LINQ's `.Sum()` operator which performs unchecked arithmetic. When multiple method fees with the same token symbol are set with large amounts (e.g., `long.MaxValue`), the sum overflows silently, resulting in incorrect fee calculations that can either cause transaction fee charging failures or enable fee undercharging.

### Finding Description
**Root Cause:**

The vulnerability exists in the fee aggregation logic where multiple fees for the same token symbol are summed together. The issue spans three key locations:

1. **Insufficient Validation**: `AssertValidToken` in TokenHolderContract only validates `amount >= 0` but does not check for `long.MaxValue` or prevent values that could overflow when aggregated. [1](#0-0) 

2. **Vulnerable Aggregation**: The `GetBaseFeeDictionary` method uses LINQ's `.Sum()` operator to aggregate fees by symbol. LINQ's `Sum()` uses unchecked arithmetic and will silently overflow when the sum exceeds `long.MaxValue`. [2](#0-1) 

The same pattern exists in `GetUserContractFeeDictionary`: [3](#0-2) 

3. **Duplicate Symbols Allowed**: The system explicitly allows and processes multiple `MethodFee` entries with the same symbol, as confirmed by test case `Set_Repeat_Token_Test` which expects fees to be summed together. [4](#0-3) 

**Why Existing Protections Fail:**

The AElf SafeMath protection system operates at two levels:
- IL code patching that replaces unchecked arithmetic opcodes with overflow-checking variants
- A validator that checks for unsafe opcodes [5](#0-4) 

However, the `UncheckedMathValidator` only checks for `Add`, `Sub`, and `Mul` IL opcodes in contract code: [6](#0-5) 

LINQ's `.Sum()` method is part of the .NET framework (System.Linq.dll) and is not patched. It uses unchecked arithmetic internally, causing silent integer overflow when the sum exceeds `long.MaxValue`.

**Execution Path:**
1. Method fee controller (Parliament governance) calls `SetMethodFee` with multiple `MethodFee` entries having the same symbol
2. Each fee passes `AssertValidToken` validation (only checks `>= 0`)
3. Fees are stored in `State.TransactionFees[input.MethodName]`
4. When charging fees, `ChargeTransactionFees` retrieves fees and calls `GetBaseFeeDictionary`
5. `.Sum()` overflows silently, producing an incorrect (negative or wrapped) fee amount
6. Incorrect fee amount is used in `ChargeBaseFee` and subsequent fee calculations

### Impact Explanation
**Direct Impact:**

When fees with the same symbol sum to values exceeding `long.MaxValue`, the overflow produces incorrect results:
- **Overflow to negative values**: Causes fee charging logic to fail validation checks, resulting in DoS of the affected method
- **Overflow to small positive values**: Results in severe fee undercharging, as the actual fee charged would be the wrapped-around value instead of the intended amount

**Affected Components:**

All contracts implementing ACS1 fee provider are affected:
- TokenHolder contract (investigated)
- All system contracts using the same pattern (Parliament, Association, Referendum, Configuration, CrossChain, Treasury, TokenConverter, Profit, Vote, Economic, Election, Consensus.AEDPoS)

**Severity Justification:**

Medium severity because:
- Requires governance action (Parliament) to set extreme fee values
- Breaks fee charging invariants (Token Supply & Fees critical invariant #3)
- Can cause operational DoS or enable fee bypass
- Defense-in-depth principle violated: validation should prevent obviously dangerous values even from governance

### Likelihood Explanation
**Preconditions:**

1. Method fee controller (defaults to Parliament governance) must call `SetMethodFee`
2. Must set multiple `MethodFee` entries with the same token symbol
3. The sum of these fees must exceed `long.MaxValue` (e.g., two entries each with `long.MaxValue/2 + 1`)

**Attack Complexity:**

LOW - Requires only a single `SetMethodFee` transaction with carefully crafted input.

**Feasibility:**

MEDIUM - Requires governance authority (Parliament) to either:
- Maliciously set extreme fees (hostile governance takeover scenario)
- Accidentally misconfigure fees (operational error)

While governance is typically trusted, the audit question specifically asks about input validation sufficiency, indicating concern about defense-in-depth even for governance-set values.

**Detection:**

LOW - Overflow occurs silently without throwing exceptions. Fee charging failures or anomalies would be the only indication.

### Recommendation
**Code-Level Mitigation:**

1. **Add maximum value validation in AssertValidToken:**
```
private void AssertValidToken(string symbol, long amount)
{
    Assert(amount >= 0, "Invalid amount.");
    Assert(amount <= long.MaxValue / 2, "Amount too large, may cause overflow when aggregated.");
    // ... existing token availability check
}
```

2. **Add duplicate symbol check in SetMethodFee:**
```
public override Empty SetMethodFee(MethodFees input)
{
    var symbols = new HashSet<string>();
    foreach (var methodFee in input.Fees)
    {
        Assert(!symbols.Contains(methodFee.Symbol), $"Duplicate symbol {methodFee.Symbol} not allowed.");
        symbols.Add(methodFee.Symbol);
        AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
    }
    // ... rest of method
}
```

3. **Use SafeMath explicitly instead of LINQ Sum():**
```
private Dictionary<string, long> GetBaseFeeDictionary(MethodFees methodFees)
{
    var result = new Dictionary<string, long>();
    foreach (var fee in methodFees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol)))
    {
        if (!result.ContainsKey(fee.Symbol))
            result[fee.Symbol] = 0;
        result[fee.Symbol] = result[fee.Symbol].Add(fee.BasicFee); // Uses checked arithmetic
    }
    return result;
}
```

**Test Cases:**

Add regression tests for:
- Setting fee with `long.MaxValue` (should fail validation)
- Setting multiple fees with same symbol totaling > `long.MaxValue` (should fail)
- Setting duplicate symbols (should fail if prevention implemented)

### Proof of Concept
**Initial State:**
- TokenHolder contract deployed
- Parliament governance is the method fee controller

**Attack Steps:**

1. Parliament calls `TokenHolderContract.SetMethodFee` with:
```
MethodFees {
    method_name = "ClaimProfits",
    fees = [
        { symbol = "ELF", basic_fee = 4611686018427387904 },  // long.MaxValue/2 + 1
        { symbol = "ELF", basic_fee = 4611686018427387904 }   // long.MaxValue/2 + 1
    ]
}
```

2. Both fees pass `AssertValidToken` validation (both >= 0)
3. Fees are stored successfully

4. User attempts to call `ClaimProfits` method
5. `ChargeTransactionFees` is invoked
6. `GetBaseFeeDictionary` is called:
   - Groups fees by symbol "ELF"
   - Calls `.Sum()` on [4611686018427387904, 4611686018427387904]
   - Result: -9223372036854775808 (overflow to `long.MinValue + 0`)

**Expected Result:** Fee charging should use the sum of both fees (9223372036854775808, if representable)

**Actual Result:** Fee charging attempts to charge -9223372036854775808, causing validation failures and DoS of the method

**Success Condition:** Transaction either fails (DoS) or charges incorrect fee amount (undercharge if wrapped to small positive value)

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L78-87)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L322-327)
```csharp
    private Dictionary<string, long> GetBaseFeeDictionary(MethodFees methodFees)
    {
        return methodFees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol))
            .GroupBy(f => f.Symbol, f => f.BasicFee)
            .ToDictionary(g => g.Key, g => g.Sum());
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L329-334)
```csharp
    private Dictionary<string, long> GetUserContractFeeDictionary(UserContractMethodFees fees)
    {
        return fees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol)) 
            .GroupBy(f => f.Symbol, f => f.BasicFee)
            .ToDictionary(g => g.Key, g => g.Sum());
    }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutePluginTransactionDirectlyTest.cs (L66-104)
```csharp
    public async Task Set_Repeat_Token_Test()
    {
        await IssueTokenToDefaultSenderAsync(NativeTokenSymbol, 100000_00000000);
        await SetPrimaryTokenSymbolAsync();
        var address = DefaultSender;
        var methodName = nameof(TokenContractContainer.TokenContractStub.Transfer);
        var basicMethodFee = 1000;
        var methodFee = new MethodFees
        {
            MethodName = methodName,
            Fees =
            {
                new MethodFee
                {
                    Symbol = NativeTokenSymbol,
                    BasicFee = basicMethodFee
                },
                new MethodFee
                {
                    Symbol = NativeTokenSymbol,
                    BasicFee = basicMethodFee
                }
            }
        };
        var sizeFee = 0;
        await TokenContractImplStub.SetMethodFee.SendAsync(methodFee);
        var beforeChargeBalance = await GetBalanceAsync(address, NativeTokenSymbol);
        var chargeTransactionFeesInput = new ChargeTransactionFeesInput
        {
            MethodName = methodName,
            ContractAddress = TokenContractAddress,
            TransactionSizeFee = sizeFee,
        };

        var chargeFeeRet = await TokenContractStub.ChargeTransactionFees.SendAsync(chargeTransactionFeesInput);
        chargeFeeRet.Output.Success.ShouldBeTrue();
        var afterChargeBalance = await GetBalanceAsync(address, NativeTokenSymbol);
        beforeChargeBalance.Sub(afterChargeBalance).ShouldBe(basicMethodFee.Add(basicMethodFee));
    }
```

**File:** src/AElf.CSharp.CodeOps/Patchers/Module/SafeMath/Patcher.cs (L14-20)
```csharp
    // Replace unchecked math OpCodes with checked OpCodes (overflow throws exception)
    private static readonly Dictionary<OpCode, OpCode> PlainToCheckedOpCodes = new()
    {
        {OpCodes.Add, OpCodes.Add_Ovf},
        {OpCodes.Sub, OpCodes.Sub_Ovf},
        {OpCodes.Mul, OpCodes.Mul_Ovf}
    };
```

**File:** src/AElf.CSharp.CodeOps/Validators/Method/UncheckedMathValidator.cs (L12-17)
```csharp
    private readonly HashSet<OpCode> _uncheckedOpCodes = new HashSet<OpCode>
    {
        OpCodes.Add,
        OpCodes.Sub,
        OpCodes.Mul
    };
```
