### Title
Consensus Validation DoS via Unbounded ActualMiningTimes in Block Headers

### Summary
A malicious miner can inject millions of fake timestamps into the `ActualMiningTimes` field within the consensus extra data of their blocks. When other nodes validate these blocks, they must sort all these entries before rejecting the block, causing excessive CPU consumption and enabling denial-of-service attacks against the consensus validation pipeline.

### Finding Description

The vulnerability exists in the consensus header validation flow. When a block is validated:

1. `ValidateBeforeExecution` calls `RecoverFromUpdateValue` or `RecoverFromTinyBlock` to merge the provided round information from the block header into the base round [1](#0-0) 

2. The recovery methods blindly add all timestamps from the provided round's `ActualMiningTimes` to the base round without any size validation [2](#0-1) [3](#0-2) 

3. `CheckMinerTimeSlot` then sorts the combined `ActualMiningTimes` using LINQ's `OrderBy` [4](#0-3) 

The `ProvidedRound` comes directly from the block's consensus extra data without size constraints [5](#0-4) 

No validation provider checks the size of `ActualMiningTimes`. The existing validators only check mining permissions, VRF values, and time slot boundaries—not the collection size [6](#0-5) 

In legitimate operation, `ActualMiningTimes` is bounded by `MaximumTinyBlocksCount` (8) and cleared at each round transition [7](#0-6) [8](#0-7) 

However, a malicious miner can bypass this by directly crafting block headers with bloated `ActualMiningTimes` arrays.

### Impact Explanation

**Operational Impact - Consensus Validation DoS:**

- All validator nodes must process the expensive sort operation during block validation, even if the block is ultimately rejected
- The sorting operation is O(n log n), so millions of entries require millions of comparisons
- A coordinated attacker (or even a single malicious miner during their time slots) can repeatedly broadcast such blocks
- This degrades network performance, delays block validation, and can stall consensus progress
- All honest nodes are affected simultaneously when processing these malicious blocks

**Severity Justification:**
- **Medium to High** - While it doesn't directly steal funds, it can halt or severely degrade the blockchain's consensus mechanism
- The attack is repeatable during each of the attacker's time slots
- Recovery requires manual intervention to block the malicious miner

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an elected miner (requires staking and community votes)
- Once elected, attacker modifies their node software to inject fake `ActualMiningTimes` entries into block headers
- No special cryptographic capabilities needed - just array manipulation

**Attack Complexity:**
- Low - Simple modification to populate `ActualMiningTimes` with millions of arbitrary timestamps before broadcasting blocks
- The validation pipeline will process the bloated data before rejection

**Feasibility Conditions:**
- Attacker must be in the active miner set (feasible through election process)
- Attacker produces blocks during their allocated time slots (normal operation)
- No additional network or contract state manipulation required

**Detection:**
- Attack is observable through CPU spikes during block validation
- Network monitoring would show abnormally large block headers
- However, damage occurs before detection can prevent it

**Economic Rationality:**
- Cost: Stake required to become miner + potential stake slashing if detected
- Benefit: Can disrupt competitor blockchains or destabilize governance
- For motivated attackers (competitors, nation-states), the cost is acceptable

**Probability: Medium-High** once an attacker becomes a miner, execution is trivial and repeatable.

### Recommendation

**Immediate Fix:**
Add size validation in the recovery methods before adding `ActualMiningTimes`:

```csharp
// In Round_Recover.cs, RecoverFromUpdateValue and RecoverFromTinyBlock
public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
{
    if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
        !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return this;

    var minerInRound = RealTimeMinersInformation[pubkey];
    var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
    
    // ADDED: Validate ActualMiningTimes size
    var maximumAllowedTimes = GetMaximumBlocksCount() * 2; // Account for extra block producer
    if (providedInformation.ActualMiningTimes.Count > maximumAllowedTimes)
        throw new AssertionException($"ActualMiningTimes count {providedInformation.ActualMiningTimes.Count} exceeds maximum {maximumAllowedTimes}");
    
    minerInRound.OutValue = providedInformation.OutValue;
    // ... rest of method
}
```

**Alternative: Add Early Validation Provider:**
Create a new `ConsensusExtraDataSizeValidationProvider` that runs first:

```csharp
public class ConsensusExtraDataSizeValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var providedMinerInfo = validationContext.ProvidedRound
            .RealTimeMinersInformation[validationContext.SenderPubkey];
        
        var maxAllowed = AEDPoSContractConstants.MaximumTinyBlocksCount * 2;
        if (providedMinerInfo.ActualMiningTimes.Count > maxAllowed)
        {
            return new ValidationResult 
            { 
                Message = $"ActualMiningTimes size {providedMinerInfo.ActualMiningTimes.Count} exceeds limit {maxAllowed}" 
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Add this provider first in the validation list in `ValidateBeforeExecution`.

**Test Cases:**
- Test block validation with `ActualMiningTimes.Count` = 100, 1000, 10000, 1000000
- Verify validation rejects blocks exceeding the threshold
- Verify legitimate blocks with ≤ MaximumTinyBlocksCount entries pass
- Measure CPU time to ensure DoS is mitigated

### Proof of Concept

**Required Initial State:**
- Attacker is an elected miner in the current round
- Attacker has modified their node software to inject fake data

**Attack Steps:**

1. **Attacker prepares malicious block:**
   - During their time slot, generate a normal `UpdateValue` transaction
   - Before creating block header, populate `Round.RealTimeMinersInformation[attackerPubkey].ActualMiningTimes` with 1,000,000 fake timestamps
   - Serialize this into the consensus extra data

2. **Attacker broadcasts block:**
   - Send block to network peers

3. **Victim nodes process block:**
   - `ValidateBeforeExecution` is called
   - `RecoverFromUpdateValue` adds 1,000,000 timestamps to `baseRound.ActualMiningTimes`
   - `CheckMinerTimeSlot` calls `OrderBy()` on ~1,000,000 entries
   - CPU usage spikes for several seconds
   - Block eventually rejected (e.g., timestamps outside valid time slot)
   - But damage is done - CPU time wasted

4. **Attacker repeats:**
   - During each time slot, broadcast multiple such blocks
   - Network experiences sustained DoS

**Expected vs Actual Result:**
- **Expected:** Validation should reject oversized data early without expensive operations
- **Actual:** Sorting happens before rejection, consuming excessive CPU time

**Success Condition:**
- Monitor CPU usage during block validation
- Observe significant increase (e.g., >1 second per block) when processing malicious blocks
- Network throughput degrades as validators spend more time on validation than consensus

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L20-20)
```csharp
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L44-44)
```csharp
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L41-41)
```csharp
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
