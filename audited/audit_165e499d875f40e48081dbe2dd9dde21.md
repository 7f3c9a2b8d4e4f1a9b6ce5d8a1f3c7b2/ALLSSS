### Title
Permanent Quadratic Vote Cost Inflation via VoteId Reuse in Delegated Voting

### Summary
In the Vote contract's quadratic voting mechanism, the `QuadraticVotesCountMap` is incremented during `Vote()` but never decremented during `Withdraw()`, causing permanent cost inflation. For delegated voting items (IsLockToken = false), sponsors can intentionally reuse VoteIds after withdrawal, leading to exponentially increasing vote costs and overwriting of previous voting records without any prevention mechanism.

### Finding Description

The vulnerability exists in the quadratic voting logic within `VoteContract.cs`. When a vote is cast in quadratic mode, the `QuadraticVotesCountMap` for that VoteId is incremented and used to calculate the cost: [1](#0-0) 

However, when a vote is withdrawn, this counter is never decremented - only the `IsWithdrawn` flag is set: [2](#0-1) 

The state variable definition confirms this is a simple counter map with no automatic cleanup: [3](#0-2) 

For delegated voting (IsLockToken = false), the sponsor must provide the VoteId explicitly: [4](#0-3) 

Critically, there is no validation to prevent VoteId reuse. The `Vote()` method simply overwrites any existing voting record: [5](#0-4) 

For normal voting (IsLockToken = true), VoteIds are auto-generated using the transaction ID, making collisions virtually impossible: [6](#0-5) [7](#0-6) 

However, the `Vote()` method is public and accepts any caller who meets the sponsor requirement for delegated voting, with no duplicate detection.

### Impact Explanation

**Quadratic Voting Mechanism Broken**: Each reuse of a VoteId permanently inflates the cost multiplier. If a VoteId "X" is used, withdrawn, and reused, the cost progresses as: TicketCost×1 → TicketCost×2 → TicketCost×3, instead of resetting to TicketCost×1 for each distinct vote.

**Voting Record Corruption**: When a VoteId is reused, the previous `VotingRecord` is completely overwritten, causing:
- Original voters lose proof of their vote
- Original voters cannot withdraw (their record no longer exists)
- Historical voting data is permanently lost

**Vote Manipulation**: A malicious sponsor of a delegated voting item can:
1. Register voters by casting votes on their behalf
2. Withdraw those votes to manipulate voting results
3. Reuse the same VoteIds for new voters at inflated costs
4. Systematically corrupt the quadratic voting mechanism

**Accounting Inconsistencies**: The recorded amounts in voting records become incorrect, potentially affecting any higher-level contracts that rely on these values for token accounting or reward calculations.

**Affected Users**: Any participants in delegated quadratic voting items where a malicious sponsor controls VoteId assignment. This breaks the fundamental fairness guarantee of quadratic voting systems.

### Likelihood Explanation

**Attacker Capabilities**: Any user can become a sponsor by registering a voting item with IsQuadratic = true and IsLockToken = false. No special privileges required beyond being able to call the public `Register()` method.

**Attack Complexity**: Low - The attack requires only three sequential transactions:
1. Vote with VoteId "X"
2. Withdraw VoteId "X"  
3. Vote again with VoteId "X"

**Feasibility Conditions**: 
- The Vote contract is public and directly callable
- No checks prevent VoteId reuse in the contract
- The ElectionContract has duplicate prevention, but Vote contract is general-purpose and can be used by other contracts or directly
- Sponsor role is easy to obtain

**Detection Constraints**: The vulnerability is not easily detectable because:
- QuadraticVotesCountMap is internal state not exposed in events
- Overwritten records leave no trace
- The sponsor's actions appear as legitimate voting operations

**Economic Rationality**: The exploit has zero cost to execute (only gas fees), while enabling complete manipulation of a voting item's quadratic cost structure and historical records.

### Recommendation

**Immediate Fix**: Add VoteId existence check and prevent reuse:

```csharp
public override Empty Vote(VoteInput input)
{
    var votingItem = AssertValidVoteInput(input);
    
    // Add duplicate VoteId check
    var existingRecord = State.VotingRecords[input.VoteId];
    Assert(existingRecord == null || existingRecord.IsWithdrawn, 
        "VoteId already in use by an active vote.");
    
    var amount = 0L;
    if (!votingItem.IsQuadratic)
    {
        amount = input.Amount;
    }
    else
    {
        // Reset counter if previous vote was withdrawn
        if (existingRecord != null && existingRecord.IsWithdrawn)
        {
            State.QuadraticVotesCountMap[input.VoteId] = 0;
        }
        
        var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
        State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
        amount = votingItem.TicketCost.Mul(currentVotesCount);
    }
    // ... rest of method
}
```

**Alternative Fix**: Decrement counter in Withdraw and forbid reuse:

```csharp
public override Empty Withdraw(WithdrawInput input)
{
    var votingRecord = State.VotingRecords[input.VoteId];
    if (votingRecord == null) throw new AssertionException("Voting record not found.");
    
    Assert(!votingRecord.IsWithdrawn, "Vote already withdrawn.");
    
    var votingItem = State.VotingItems[votingRecord.VotingItemId];
    
    // ... permission checks ...
    
    // Reset quadratic counter for this VoteId
    if (votingItem.IsQuadratic)
    {
        State.QuadraticVotesCountMap[input.VoteId] = 0;
    }
    
    votingRecord.IsWithdrawn = true;
    // ... rest of method
}
```

**Invariant Checks**: 
- Assert VoteId uniqueness across active votes
- Assert QuadraticVotesCountMap consistency with VotingRecord state
- Assert no overwriting of non-withdrawn records

**Test Cases**:
- Test voting with same VoteId twice (should fail)
- Test voting after withdrawal with same VoteId (verify cost resets or fails)
- Test delegated voting VoteId reuse attack scenario
- Test QuadraticVotesCountMap state after withdraw operations

### Proof of Concept

**Initial State**: 
- Attacker registers voting item: VotingItemId = "ITEM1", IsQuadratic = true, IsLockToken = false, TicketCost = 100, Sponsor = Attacker

**Transaction 1 - First Vote**:
```
Call: Vote(VoteId = "REUSE", VotingItemId = "ITEM1", Voter = Alice, Option = "A")
Sender: Attacker (sponsor)
```
**Result**: 
- QuadraticVotesCountMap["REUSE"] = 1
- Amount calculated = 100 × 1 = 100
- VotingRecord["REUSE"] = {Voter: Alice, Amount: 100, IsWithdrawn: false}

**Transaction 2 - Withdrawal**:
```
Call: Withdraw(VoteId = "REUSE")
Sender: Attacker (sponsor)
```
**Result**:
- VotingRecord["REUSE"].IsWithdrawn = true
- QuadraticVotesCountMap["REUSE"] = 1 (NOT decremented)

**Transaction 3 - Reuse Attack**:
```
Call: Vote(VoteId = "REUSE", VotingItemId = "ITEM1", Voter = Bob, Option = "B")
Sender: Attacker (sponsor)
```
**Expected Result**: QuadraticVotesCountMap["REUSE"] = 1, Amount = 100 (fresh vote)

**Actual Result**:
- QuadraticVotesCountMap["REUSE"] = 1 + 1 = 2
- Amount calculated = 100 × 2 = 200 (INFLATED)
- VotingRecord["REUSE"] = {Voter: Bob, Amount: 200, IsWithdrawn: false} (Alice's record OVERWRITTEN)
- Alice can no longer withdraw her vote (record lost)

**Success Condition**: Bob's vote is recorded with amount = 200 instead of expected 100, and Alice's voting record is permanently lost, confirming permanent cost inflation and record corruption.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L100-102)
```csharp
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L203-205)
```csharp
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-388)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L397-397)
```csharp
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L30-33)
```csharp
    /// <summary>
    ///     Vote Id -> Votes Count
    /// </summary>
    public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L139-145)
```csharp
    public Hash GenerateId(Address contractAddress, IEnumerable<byte> bytes)
    {
        var contactedBytes = OriginTransactionId.Value.Concat(contractAddress.Value);
        var enumerable = bytes as byte[] ?? bytes?.ToArray();
        if (enumerable != null)
            contactedBytes = contactedBytes.Concat(enumerable);
        return HashHelper.ComputeFrom(contactedBytes.ToArray());
```
