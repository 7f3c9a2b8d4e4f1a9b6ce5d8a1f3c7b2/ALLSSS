### Title
Division by Zero in ArrangeAbnormalMiningTime Causes Consensus Denial of Service

### Summary
The `ArrangeAbnormalMiningTime()` method performs an unprotected division operation that will throw a `DivideByZeroException` if the mining interval is zero. The `FirstRound()` initialization method does not validate that the mining interval is greater than zero before storing the round, allowing a misconfigured system to enter an unrecoverable state where consensus operations fail.

### Finding Description

The vulnerability exists in the division operation at line 34 of `ArrangeAbnormalMiningTime()`: [1](#0-0) 

The `Div()` extension method is a simple wrapper around the division operator that does NOT handle division by zero: [2](#0-1) 

Unit tests confirm this throws `DivideByZeroException`: [3](#0-2) 

The divisor `TotalMilliseconds(miningInterval)` returns zero when `miningInterval` is zero: [4](#0-3) 

The `GetMiningInterval()` method returns zero when miners with Order 1 and 2 have identical `ExpectedMiningTime` values: [5](#0-4) 

**Root Cause:** The `FirstRound()` initialization method stores the round without validating that the mining interval is greater than zero: [6](#0-5) 

The mining interval comes from system configuration without validation: [7](#0-6) [8](#0-7) 

While `CheckRoundTimeSlots()` validates mining interval > 0, it is only called for new rounds during `ValidateBeforeExecution`, NOT during `FirstRound` initialization: [9](#0-8) [10](#0-9) 

### Impact Explanation

**Operational Impact - Critical:**

When `ArrangeAbnormalMiningTime()` is invoked (which occurs during consensus command generation and miner permission checks), the division by zero exception causes:

1. **Consensus Command Generation Failure:** The method is called by `TerminateRoundCommandStrategy` when miners need to produce extra blocks: [11](#0-10) [12](#0-11) 

2. **Miner Permission Check Failure:** The method is called by `IsCurrentMiner()` to check if a node can mine in the "saving extra block" time slot: [13](#0-12) 

Additionally, `IsCurrentMiner()` performs TWO other unprotected divisions with the same zero miningInterval at lines 208 and 157, compounding the failure points.

**Impact Scope:**
- Complete consensus mechanism failure
- Node crashes and inability to produce blocks
- Blockchain halt requiring manual intervention
- Affects all nodes in the network

### Likelihood Explanation

**Preconditions:**
- Requires `ConsensusOptions.MiningInterval` to be set to 0 in system configuration during blockchain initialization
- This is a misconfiguration scenario, not requiring attacker compromise

**Execution Path:**
1. Administrator configures `MiningInterval = 0` in node configuration
2. System initialization calls `FirstRound()` with corrupted round data
3. Round is stored without validation
4. Any consensus operation calling `ArrangeAbnormalMiningTime()`, `IsCurrentMiner()`, or command generation triggers the exception
5. Node crashes, consensus halts

**Probability Factors:**
- **Low-Medium probability:** Depends on configuration validation in deployment processes
- **High severity when triggered:** Complete operational failure
- **Not easily detectable pre-deployment:** Requires specific test coverage for zero mining interval
- **No recovery path:** Requires blockchain restart with corrected configuration

The vulnerability is exploitable through operational misconfiguration, making it a defensive programming failure that violates fail-safe principles.

### Recommendation

**1. Add Mining Interval Validation in FirstRound:**

Add validation in `FirstRound()` method before storing the round:

```csharp
public override Empty FirstRound(Round input)
{
    Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");
    
    // Add validation
    var miningInterval = input.GetMiningInterval();
    Assert(miningInterval > 0, "Mining interval must be greater than zero.");
    
    State.CurrentTermNumber.Value = 1;
    State.CurrentRoundNumber.Value = 1;
    State.FirstRoundNumberOfEachTerm[1] = 1;
    State.MiningInterval.Value = miningInterval;
    // ... rest of method
}
```

**2. Add Validation in ConsensusOptions:**

Add a validation attribute or initialization check:

```csharp
public class ConsensusOptions
{
    private int _miningInterval;
    public int MiningInterval 
    { 
        get => _miningInterval;
        set 
        {
            if (value <= 0)
                throw new ArgumentException("MiningInterval must be greater than zero");
            _miningInterval = value;
        }
    }
    // ... rest of properties
}
```

**3. Add Defensive Check in ArrangeAbnormalMiningTime:**

```csharp
public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
    bool mustExceededCurrentRound = false)
{
    var miningInterval = GetMiningInterval();
    Assert(miningInterval > 0, "Invalid mining interval");
    
    // ... rest of method
}
```

**4. Add Regression Tests:**

Create test cases that verify:
- FirstRound rejects zero mining interval
- ArrangeAbnormalMiningTime handles edge cases gracefully
- ConsensusOptions validation prevents invalid configuration

### Proof of Concept

**Initial State:**
- Node configuration file sets `ConsensusOptions.MiningInterval = 0`
- System attempts blockchain initialization

**Execution Steps:**

1. `AEDPoSContractInitializationProvider` reads `MiningInterval = 0` from configuration
2. `GenerateFirstRoundOfNewTerm(miningInterval: 0, ...)` creates a Round where:
   - Miner Order 1: `ExpectedMiningTime = currentTime + 0 = currentTime`
   - Miner Order 2: `ExpectedMiningTime = currentTime + 0 = currentTime`
3. `FirstRound(input)` stores the round without validation
4. `State.MiningInterval.Value = 0` is set
5. Later, when consensus attempts to generate a command:
   - `TerminateRoundCommandStrategy.GetAEDPoSConsensusCommand()` calls
   - `ArrangeExtraBlockMiningTime()` which calls
   - `ArrangeAbnormalMiningTime()` which executes
   - `distanceToRoundStartTime.Div(TotalMilliseconds(0))` where `TotalMilliseconds(0) = 0`
   - `DivideByZeroException` is thrown

**Expected Result:** System validates mining interval and rejects invalid configuration

**Actual Result:** System crashes with `DivideByZeroException`, consensus halts, blockchain becomes inoperable

**Success Condition:** Exception thrown, consensus operations fail, requiring manual intervention to restart with corrected configuration

### Notes

The vulnerability affects multiple division points beyond line 34:
- Line 183 in `IsCurrentMiner()`: `AddMilliseconds(-currentRound.TotalMilliseconds())`
- Line 208 in `IsCurrentMiner()`: `Div(miningInterval)` 

All three locations require the same fix. This is a critical defensive programming failure that can cause complete operational failure of the consensus mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L34-34)
```csharp
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L68-73)
```csharp
    public int TotalMilliseconds(int miningInterval = 0)
    {
        if (miningInterval == 0) miningInterval = GetMiningInterval();

        return RealTimeMinersInformation.Count * miningInterval + miningInterval;
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L50-51)
```csharp
        Should.Throw<DivideByZeroException>(() => { number1.Div(0); });
        Should.Throw<DivideByZeroException>(() => { number2.Div(0); });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-47)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L74-92)
```csharp
    public override Empty FirstRound(Round input)
    {
        /* Basic checks. */
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
        State.FirstRoundNumberOfEachTerm[1] = 1;
        State.MiningInterval.Value = input.GetMiningInterval();
        SetMinerList(input.GetMinerList(), 1);

        AddRoundInformation(input);

        Context.LogDebug(() =>
            $"Initial Miners: {input.RealTimeMinersInformation.Keys.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");

        return new Empty();
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/ConsensusOptions.cs (L7-14)
```csharp
public class ConsensusOptions
{
    public List<string> InitialMinerList { get; set; }
    public int MiningInterval { get; set; }
    public Timestamp StartTimestamp { get; set; } = new() { Seconds = 0 };
    public long PeriodSeconds { get; set; } = 604800;
    public long MinerIncreaseInterval { get; set; } = 31536000;
}
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/AEDPoSContractInitializationDataProvider.cs (L16-26)
```csharp
    public AEDPoSContractInitializationData GetContractInitializationData()
    {
        return new AEDPoSContractInitializationData
        {
            MiningInterval = _consensusOptions.MiningInterval,
            PeriodSeconds = _consensusOptions.PeriodSeconds,
            StartTimestamp = _consensusOptions.StartTimestamp,
            InitialMinerList = _consensusOptions.InitialMinerList,
            MinerIncreaseInterval = _consensusOptions.MinerIncreaseInterval
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L25-26)
```csharp
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L22-25)
```csharp
        public static Timestamp ArrangeExtraBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return round.ArrangeAbnormalMiningTime(pubkey, currentBlockTime);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L181-183)
```csharp
        var nextArrangeMiningTime =
            currentRound.ArrangeAbnormalMiningTime(pubkey, Context.CurrentBlockTime, true);
        var actualArrangedMiningTime = nextArrangeMiningTime.AddMilliseconds(-currentRound.TotalMilliseconds());
```
