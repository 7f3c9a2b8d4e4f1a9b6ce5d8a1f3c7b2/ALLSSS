# Audit Report

## Title
Duplicate Initial Miner Entries Cause Consensus DoS During Evil Miner Replacement

## Summary
The `State.InitialMiners` list can contain duplicate entries due to missing deduplication during initialization and incomplete removal during pubkey replacement. When evil miner replacement is triggered, duplicate pubkeys can be returned to the Consensus contract, causing an `ArgumentException` when adding the same key twice to the round's miner map, resulting in chain halt.

## Finding Description

The Election contract stores initial miners without deduplication during initialization. [1](#0-0)  This contrasts with the Consensus contract initialization which explicitly deduplicates using `.Distinct()`. [2](#0-1) 

During pubkey replacement, the `Remove()` method on protobuf repeated fields only removes the **first occurrence** of a duplicate entry. [3](#0-2)  If `State.InitialMiners` contains `[A, A, B]` and `A` is replaced with `A'`, the result is `[A, B, A']` with one stale entry remaining.

When `GetMinerReplacementInformation()` needs to fill evil miner replacement slots but has insufficient non-initial-miner candidates, it falls back to selecting from initial miners. [4](#0-3)  The LINQ chain (`Select().Where().Where().Take()`) does **not** deduplicate, so duplicate pubkeys can be returned in `AlternativeCandidatePubkeys`.

The Consensus contract then iterates through the replacement lists and attempts to add each alternative candidate to the round's miner map. [5](#0-4)  The `real_time_miners_information` field is a protobuf map, [6](#0-5)  which internally uses a C# `Dictionary`. When the same pubkey is added twice via `Add()`, it throws an `ArgumentException` with "An item with the same key has already been added", crashing the consensus round generation and halting the chain.

## Impact Explanation

**Critical Infrastructure Failure:**
- The Consensus contract cannot generate new rounds, preventing block production entirely
- All nodes experience the same deterministic failure due to identical state
- Chain halt persists until manual intervention through governance or emergency response
- Affects all network participants simultaneously

**Severity Justification:**
- Core consensus mechanism is disabled
- No automatic recovery mechanism exists
- Requires coordinated governance action to resolve
- Business continuity completely disrupted during downtime

This represents a High severity availability impact on critical blockchain infrastructure.

## Likelihood Explanation

**Preconditions:**
1. **Configuration Error**: Initial miner list configured with duplicate pubkeys (realistic in complex multi-validator setups)
2. **OR Replacement Chain**: Prior pubkey replacement with duplicates creates unremoved stale entries (deterministic given precondition 1)

**Trigger Condition:**
Evil miner detection combined with insufficient non-initial-miner candidates to fulfill all replacement slots. This is a designed protocol feature that activates when:
- Miners misbehave (miss time slots, produce invalid blocks)
- Limited active candidates with sufficient votes

**Likelihood Assessment:**
- **Medium Likelihood**: While requiring operational error, such errors are realistic in production environments
- Configuration validation is absent, making duplicate insertion possible
- Once duplicates exist, the failure is deterministic upon trigger
- Evil miner detection occurs periodically during normal operations
- No monitoring or early warning exists before the DoS manifests

## Recommendation

**Immediate Fixes:**

1. **Add deduplication during initialization:**
```csharp
State.InitialMiners.Value = new PubkeyList
{
    Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)).Distinct() }
};
```

2. **Remove all occurrences during replacement:**
```csharp
var initialMiners = State.InitialMiners.Value;
if (initialMiners.Value.Contains(oldPubkeyBytes))
{
    // Remove all occurrences
    while (initialMiners.Value.Remove(oldPubkeyBytes)) { }
    initialMiners.Value.Add(newPubkeyBytes);
    State.InitialMiners.Value = initialMiners;
}
```

3. **Add deduplication in GetMinerReplacementInformation:**
```csharp
var selectedInitialMiners = State.InitialMiners.Value.Value
    .Select(k => k.ToHex())
    .Distinct()  // Add this
    .Where(k => !State.BannedPubkeyMap[k])
    .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
```

4. **Add validation in InitialElectionContract:**
```csharp
Assert(input.MinerList.Count == input.MinerList.Distinct().Count(), 
    "Duplicate miners not allowed in initialization.");
```

## Proof of Concept

```csharp
[Fact]
public async Task DuplicateInitialMiner_CausesConsensusDoS_WhenEvilMinerReplacement()
{
    // Setup: Initialize with duplicate miner pubkeys
    var duplicateMinerPubkey = MissionedECKeyPairs.InitialKeyPairs[0].PublicKey.ToHex();
    var minerList = new List<string>
    {
        duplicateMinerPubkey,
        duplicateMinerPubkey,  // Duplicate entry
        MissionedECKeyPairs.InitialKeyPairs[1].PublicKey.ToHex()
    };
    
    await InitializeContracts(minerList);
    
    // Trigger: Mark first miner as evil (banned)
    await ElectionContractStub.UpdateCandidateInformation.SendAsync(
        new UpdateCandidateInformationInput
        {
            Pubkey = minerList[0],
            IsEvilNode = true
        });
    
    // Exploit: Try to get replacement information
    var result = await ElectionContractStub.GetMinerReplacementInformation.CallAsync(
        new GetMinerReplacementInformationInput
        {
            CurrentMinerList = { minerList[0] }
        });
    
    // Verify duplicates in alternatives
    Assert.Equal(2, result.AlternativeCandidatePubkeys.Count(p => p == duplicateMinerPubkey));
    
    // Trigger DoS: Consensus contract processes replacement
    var exception = await Assert.ThrowsAsync<ArgumentException>(async () =>
    {
        await ConsensusContractStub.ProcessReplacementInformation.SendAsync(result);
    });
    
    Assert.Contains("An item with the same key has already been added", exception.Message);
}
```

## Notes

This vulnerability demonstrates a **data integrity issue** where the Election contract's lack of deduplication in `InitialMiners` propagates to cause a **consensus availability failure**. The issue is particularly insidious because:

1. It can lie dormant until evil miner replacement is triggered
2. Standard testing may miss it if duplicate configuration isn't tested
3. Recovery requires governance intervention, extending downtime
4. The failure is deterministic and reproducible across all nodes

The fix requires defense-in-depth: validation at initialization, proper removal during replacement, and deduplication when reading for replacement information.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L34-38)
```csharp
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Extensions/MinerListExtensions.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in miners.Pubkeys.Distinct()
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L382-392)
```csharp
        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-338)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
```

**File:** protobuf/aedpos_contract.proto (L246-247)
```text
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
```
