### Title
Incomplete Field Validation in NextRound Allows Manipulation of Extra Block Producer Selection

### Summary
The `ValidationForNextRound` function only validates that `InValue` fields are null for miners in the next round, but fails to validate that `OutValue`, `Signature`, and `PreviousInValue` fields are also properly cleared. This allows a malicious miner to inject arbitrary `Signature` values that will subsequently be used by `CalculateNextExtraBlockProducerOrder` to manipulate the selection of the extra block producer, violating consensus fairness and randomness guarantees.

### Finding Description

The vulnerability exists in the `ValidationForNextRound` method which only checks that `InValue` is null: [1](#0-0) 

However, when a new round is honestly generated via `GenerateNextRoundInformation`, all cryptographic fields (InValue, OutValue, Signature, PreviousInValue) should be unset/null since these are only populated during actual mining via UpdateValue: [2](#0-1) 

The `NextRoundInput` is converted to `Round` via `ToRound()` which directly copies all fields including any injected malicious values: [3](#0-2) 

The injected `Signature` value is then used to calculate the extra block producer when this compromised round is later used to generate the subsequent round: [4](#0-3) 

The extra block producer calculation uses the first miner's Signature field directly (line 112-113, 118-121), making it vulnerable to manipulation through injected values that passed the incomplete validation.

### Impact Explanation

**Consensus Integrity Violation**: The extra block producer role is meant to be selected pseudo-randomly based on legitimate consensus data. By manipulating the Signature field, an attacker can control which miner becomes the extra block producer in future rounds.

**Mining Reward Manipulation**: The attacker can increase their own mining frequency by ensuring they or colluding miners are selected as extra block producers more frequently, leading to unfair distribution of block rewards.

**Consensus Fairness**: Violates the fundamental fairness assumption of the AEDPoS consensus mechanism where the extra block producer should be determined by legitimate cryptographic signatures, not attacker-controlled values.

The severity is HIGH because it directly compromises consensus integrity, affects all network participants through unfair miner selection, and can lead to economic advantages for the attacker at the expense of honest miners.

### Likelihood Explanation

**Attacker Requirements**: The attacker must be an active miner in the current round to produce blocks. This is a realistic precondition since miners are elected through the governance process.

**Attack Complexity**: The attack is straightforward - the attacker simply needs to craft a `NextRoundInput` with controlled `Signature` values while keeping `InValue` null. The validation logic uses basic null checks that are easily bypassed.

**Execution Path**: 
1. Attacker produces a NextRound block (typically as the extra block producer)
2. Injects malicious Signature values in the NextRoundInput
3. Block passes validation since only InValue is checked
4. Malicious round is stored in state
5. When this round is used to generate the next round, the injected Signature manipulates extra block producer selection

**Detection Difficulty**: The attack is subtle and would appear as valid consensus data. The manipulated Signature values would not be obviously malicious without comparing against expected honest generation.

**Economic Rationality**: The attack cost is minimal (standard block production cost) while the benefit is increased mining frequency and rewards. The attack is economically rational for any miner seeking unfair advantage.

Likelihood is MEDIUM-HIGH given that any miner can execute this attack with minimal additional effort beyond normal block production.

### Recommendation

Add comprehensive validation to check all cryptographic fields are properly cleared in the next round:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    // Validate all cryptographic fields are null/empty for new round
    foreach (var miner in extraData.Round.RealTimeMinersInformation.Values)
    {
        if (miner.InValue != null)
            return new ValidationResult { Message = "InValue must be null in next round." };
        
        if (miner.OutValue != null && miner.OutValue.Value.Any())
            return new ValidationResult { Message = "OutValue must be null in next round." };
        
        if (miner.Signature != null && miner.Signature.Value.Any())
            return new ValidationResult { Message = "Signature must be null in next round." };
        
        if (miner.PreviousInValue != null && miner.PreviousInValue != Hash.Empty)
            return new ValidationResult { Message = "PreviousInValue must be null in next round." };
    }

    return new ValidationResult { Success = true };
}
```

**Test Cases**: Add test cases that attempt to submit NextRoundInput with non-null OutValue, Signature, or PreviousInValue values and verify they are rejected.

### Proof of Concept

**Initial State**:
- Attacker is an active miner in round N
- Attacker has permission to produce the extra block (NextRound) for round N

**Attack Steps**:
1. Attacker generates NextRoundInput for round N+1
2. Sets `InValue = null` for all miners (passes validation)
3. Sets `Signature = Hash.FromRawBytes([controlled_bytes])` where controlled_bytes is chosen to make `GetAbsModulus(signature.ToInt64(), minerCount) + 1` equal to attacker's desired extra block producer order
4. Submits NextRound transaction with this manipulated input
5. Validation passes since only InValue is checked
6. Round N+1 is stored with malicious Signature values

**Expected vs Actual**:
- **Expected**: NextRoundInput with non-null Signature should be rejected
- **Actual**: NextRoundInput passes validation and malicious Signature is stored

**Success Condition**: 
When round N+1 is used to generate round N+2, the `CalculateNextExtraBlockProducerOrder` function uses the attacker-controlled Signature value to select the extra block producer, demonstrating successful manipulation of consensus logic.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```
