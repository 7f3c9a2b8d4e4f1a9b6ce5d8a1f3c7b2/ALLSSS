# Audit Report

## Title
Cross-Scheme State Confusion Due to One-to-One Mapping Limitation in TokenHolder Contract

## Summary
The TokenHolder contract enforces a one-to-one relationship between manager addresses and schemes through its storage mapping, while the underlying Profit contract supports multiple schemes per manager. When a user calls `CreateScheme` multiple times, subsequent calls overwrite the scheme metadata in TokenHolder storage but create new schemes in the Profit contract. This architectural mismatch causes cross-scheme state confusion where operations use metadata from one scheme but execute against a different scheme ID, resulting in token type mismatches and loss of funds accessibility.

## Finding Description

The vulnerability stems from an architectural inconsistency between TokenHolder and Profit contract storage designs.

The TokenHolder contract uses a one-to-one mapping to store scheme metadata: [1](#0-0) 

However, every call to `CreateScheme` creates a new scheme in the Profit contract: [2](#0-1) 

And then overwrites the TokenHolder storage entry: [3](#0-2) 

The Profit contract explicitly supports multiple schemes per manager by maintaining a list: [4](#0-3) 

This list is populated each time CreateScheme is called: [5](#0-4) 

When `GetValidScheme` is called with a null SchemeId, `UpdateTokenHolderProfitScheme` retrieves only the FIRST scheme from the manager's list using `FirstOrDefault()`: [6](#0-5) 

**Attack Scenario:**
1. User calls `CreateScheme({Symbol="ELF", MinimumLockMinutes=100})` → Creates SchemeA in Profit, stores metadata in TokenHolder
2. User calls `CreateScheme({Symbol="USDT", MinimumLockMinutes=200})` → Creates SchemeB in Profit, OVERWRITES TokenHolder metadata
3. Any subsequent operation retrieves metadata {Symbol="USDT", MinimumLockMinutes=200} but SchemeId points to SchemeA
4. When user calls `RegisterForProfits`, they lock USDT tokens: [7](#0-6) 
5. But the beneficiary is added to SchemeA (which distributes ELF): [8](#0-7) 

This creates an irreconcilable state where locked token type (USDT) doesn't match the scheme's distributed token type (ELF).

## Impact Explanation

**Direct Fund Impact (HIGH):**
1. **Token Type Mismatch**: Users lock the wrong token type. If SchemeA expects "ELF" but stored metadata says "USDT", `RegisterForProfits` locks USDT tokens for a scheme that distributes ELF profits, making those profits unclaimable.

2. **Inaccessible Locked Funds**: The locked tokens cannot be used to claim profits from the intended scheme since the scheme ID points to a different scheme with different token requirements.

3. **Incorrect Lock Duration**: The `Withdraw` method enforces the minimum lock time from the overwritten metadata: [9](#0-8)  If SchemeA requires 100 minutes but the stored metadata says 200 minutes, users are forced to wait longer than necessary.

**Operational Impact:**
- The first scheme becomes permanently orphaned and inaccessible through TokenHolder methods
- All TokenHolder operations reference the wrong scheme, causing systematic failures
- Beneficiaries added with mixed configuration will not receive correct profit distributions
- The `ClaimProfits` operation will attempt to claim from the wrong scheme: [10](#0-9) 

## Likelihood Explanation

**HIGH Likelihood:**

1. **No Access Control**: `CreateScheme` is a public method callable by any address with no restrictions preventing multiple invocations by the same sender.

2. **No Duplicate Prevention**: The code contains no check to prevent calling `CreateScheme` multiple times: [11](#0-10) 

3. **Design Contradiction**: The Profit contract is explicitly designed to support multiple schemes per manager (as evidenced by its list-based storage), suggesting this is an intended use case that TokenHolder fails to accommodate.

4. **Legitimate Use Cases**: Users may reasonably want to create multiple schemes for different token types or configurations (e.g., one for ELF rewards, another for USDT rewards).

5. **Silent Failure**: No error or warning is emitted during the second `CreateScheme` call, making this issue easy to trigger unknowingly. The transaction succeeds, giving users false confidence.

6. **Natural User Behavior**: Users who experiment with scheme creation or make a mistake can easily trigger this issue through normal contract interaction.

## Recommendation

**Option 1 - Prevent Multiple Schemes (Restrictive):**
Add a check in `CreateScheme` to prevent multiple scheme creations:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this address.");
    
    // ... rest of implementation
}
```

**Option 2 - Support Multiple Schemes (Recommended):**
Refactor storage to support multiple schemes per address by using a compound key:

```csharp
// In TokenHolderContractState.cs
public MappedState<Address, Hash, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }

// In CreateScheme
var schemeId = State.ProfitContract.CreateScheme.Call(...);
State.TokenHolderProfitSchemes[Context.Sender][schemeId] = new TokenHolderProfitScheme
{
    SchemeId = schemeId,
    Symbol = input.Symbol,
    // ... other fields
};
```

This requires updating all methods that access `TokenHolderProfitSchemes` to accept a SchemeId parameter.

**Option 3 - Return Scheme ID (Minimal Fix):**
Store and return the SchemeId immediately upon creation and require users to specify which scheme they're operating on:

```csharp
public override Hash CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    var schemeId = State.ProfitContract.CreateScheme.Call(...);
    
    State.TokenHolderProfitSchemes[Context.Sender][schemeId] = new TokenHolderProfitScheme
    {
        SchemeId = schemeId,
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };
    
    return schemeId;
}
```

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task CreateScheme_MultipleCallsCauseStateConfusion()
{
    // Setup
    var user = Accounts[0].Address;
    
    // Step 1: Create first scheme with ELF token
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100,
        AutoDistributeThreshold = { {"ELF", 1000} }
    });
    
    // Verify first scheme stored correctly
    var scheme1 = await TokenHolderContractStub.GetScheme.CallAsync(user);
    scheme1.Symbol.ShouldBe("ELF");
    scheme1.MinimumLockMinutes.ShouldBe(100);
    
    // Step 2: Create second scheme with USDT token (THIS OVERWRITES)
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",
        MinimumLockMinutes = 200,
        AutoDistributeThreshold = { {"USDT", 2000} }
    });
    
    // Step 3: Verify TokenHolder metadata is from second call
    var scheme2 = await TokenHolderContractStub.GetScheme.CallAsync(user);
    scheme2.Symbol.ShouldBe("USDT"); // Shows second scheme metadata
    scheme2.MinimumLockMinutes.ShouldBe(200);
    
    // Step 4: Check which SchemeId is actually referenced
    // GetValidScheme will populate SchemeId using FirstOrDefault() which returns FIRST scheme
    var managingSchemes = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = user });
    managingSchemes.SchemeIds.Count.ShouldBe(2); // Two schemes exist in Profit contract
    
    var firstSchemeId = managingSchemes.SchemeIds[0];
    var firstScheme = await ProfitContractStub.GetScheme.CallAsync(firstSchemeId);
    // FirstScheme would have been created with ELF parameters
    
    // Step 5: Attempt to register for profits - THIS CAUSES THE MISMATCH
    // User will try to lock USDT (from metadata) but register to ELF scheme (from SchemeId)
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = user,
        Amount = 1000
    });
    
    // Result: USDT tokens are locked, but user is registered to first scheme (ELF scheme)
    // User cannot claim profits because token types don't match
}
```

## Notes

This vulnerability represents a critical design flaw where two contracts maintain incompatible data models for the same conceptual entity. The TokenHolder contract's assumption of a one-to-one manager-to-scheme relationship contradicts the Profit contract's multi-scheme architecture. This creates a systematic inconsistency that affects all TokenHolder operations post-second-creation, making it impossible for users to correctly interact with either scheme through the TokenHolder interface.

The severity is amplified by the silent nature of the failure - users receive no indication that their second `CreateScheme` call has corrupted their state, and the issues only manifest later when attempting to register for or claim profits.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L10-10)
```csharp
    public MappedState<Address, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-165)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L168-176)
```csharp
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L251-255)
```csharp
        State.ProfitContract.ClaimProfits.Send(new Profit.ClaimProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = beneficiary
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L290-293)
```csharp
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
```

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L15-15)
```csharp
    public MappedState<Address, CreatedSchemeIds> ManagingSchemeIds { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```
