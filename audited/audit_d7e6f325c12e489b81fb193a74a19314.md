### Title
Deposit Balance Erasure Through Re-enabling Connector with Negative amountOutOfTokenConvert

### Summary
The `GetNeededDeposit()` function calculates `amountOutOfTokenConvert = totalSupply - balance - AmountToTokenConvert`, which becomes negative when `balance + AmountToTokenConvert > totalSupply`. When negative, the function returns `needDeposit.NeedAmount = 0`. The `EnableConnector()` function lacks a check to prevent multiple invocations and unconditionally sets `State.DepositBalance = needDeposit.NeedAmount`, allowing an attacker to erase critical deposit tracking by re-enabling an active connector, thereby corrupting Bancor reserve accounting and breaking price calculations.

### Finding Description

**Location:** [1](#0-0) 

The calculation `var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;` can produce negative values when the sum of the converter's current token balance plus the specified transfer amount exceeds the total supply. [2](#0-1) 

When `amountOutOfTokenConvert <= 0`, the conditional check fails and `needDeposit` remains 0, with the function returning a `DepositInfo` containing both the zero `NeedAmount` and the negative `AmountOutOfTokenConvert` value.

**Root Cause:** [3](#0-2) 

The `EnableConnector()` function has no assertion to prevent re-invocation after a connector is already enabled (no `IsPurchaseEnabled` check), unlike `UpdateConnector()` which explicitly prevents updates after activation. [4](#0-3) 

Compare with `UpdateConnector()` which correctly asserts `!targetConnector.IsPurchaseEnabled` to prevent modification after activation. [5](#0-4) 

The critical line `State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;` uses assignment (not addition), completely replacing the existing deposit balance that was maintained through Buy/Sell operations. [6](#0-5) [7](#0-6) 

The `DepositBalance` state variable is carefully maintained during normal trading operations by adding amounts in `Buy()` and subtracting in `Sell()`, making the unconditional overwrite in `EnableConnector()` particularly destructive.

### Impact Explanation

**Direct Fund Impact:** [8](#0-7) 

The `GetSelfBalance()` function returns `State.DepositBalance[connector.Symbol]` for deposit account connectors, which is directly used in Bancor price calculations. [9](#0-8) 

In `Buy()`, the Bancor formula uses `GetSelfBalance()` for both connectors to calculate `amountToPay`. If `DepositBalance` is corrupted (especially set to 0), the price calculation becomes completely invalid, leading to:
- **Extreme mispricing**: Tokens can be bought/sold at drastically wrong prices
- **Arbitrage exploitation**: Attackers can exploit price discrepancies to drain reserves
- **Reserve depletion**: If DepositBalance = 0, the Bancor model breaks down entirely

**Realistic Scenario:** If through normal trading operations all or most tokens accumulate in the converter (balance ≈ totalSupply), any subsequent call to `EnableConnector()` with `AmountToTokenConvert = 0` will:
1. Calculate `amountOutOfTokenConvert = totalSupply - balance ≈ 0`
2. Set `needDeposit.NeedAmount = 0`
3. Erase all deposit tracking by setting `DepositBalance = 0`
4. Break all subsequent Buy/Sell pricing

**Affected parties:** All users trading through the connector, as they will receive/pay incorrect amounts based on corrupted reserve data.

### Likelihood Explanation

**Attacker Capabilities:** Any user can call `EnableConnector()` - it is a public method with no special authorization requirements beyond the token transfers.

**Attack Complexity:** Low. The attacker simply needs to:
1. Observe that a connector has been enabled and is actively trading
2. Monitor the token balance in the converter contract
3. When `balance` approaches or equals `totalSupply` (achievable through normal market dynamics where most holders sell their tokens), call `EnableConnector()` with `AmountToTokenConvert = 0`

**Feasibility Conditions:**
- The scenario where `balance >= totalSupply` can occur naturally through sustained selling pressure
- Even if `balance < totalSupply`, the attacker can still corrupt accounting by calling with `AmountToTokenConvert = 0`, which recalculates and overwrites the carefully maintained `DepositBalance`
- No transaction fees or special tokens required beyond gas costs

**Detection Constraints:** The attack is difficult to prevent as it uses legitimate public methods. Once executed, the corrupted `DepositBalance` immediately affects all subsequent trades.

**Probability:** HIGH - The preconditions can occur naturally during normal market operations, and the attack is straightforward to execute.

### Recommendation

**Code-level Mitigation:**

Add an assertion at the start of `EnableConnector()` to prevent re-enabling:

```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
    
    // ADD THIS CHECK:
    Assert(!fromConnector.IsPurchaseEnabled && !toConnector.IsPurchaseEnabled, 
        "Connector is already enabled and cannot be re-enabled.");
    
    // ... rest of function
}
```

**Additional Invariant Check in GetNeededDeposit():**

Add validation that `balance + AmountToTokenConvert <= totalSupply`:

```csharp
public override DepositInfo GetNeededDeposit(ToBeConnectedTokenInfo input)
{
    // ... existing code to get toConnector, fromConnector, tokenInfo, balance ...
    
    // ADD THIS VALIDATION:
    Assert(balance.Add(input.AmountToTokenConvert) <= tokenInfo.TotalSupply,
        "AmountToTokenConvert would exceed available token supply.");
    
    var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
    // ... rest of function
}
```

**Test Cases:**
1. Test that `EnableConnector()` reverts when called on an already-enabled connector
2. Test that `GetNeededDeposit()` reverts when `balance + AmountToTokenConvert > totalSupply`
3. Test that `DepositBalance` cannot be corrupted through repeated `EnableConnector()` calls

### Proof of Concept

**Required Initial State:**
- Token "TOKEN" created with `totalSupply = 1,000,000`
- Connector pair created and enabled via legitimate `EnableConnector()` call
- Initial `DepositBalance[depositConnector] = 500` (base tokens)
- Through trading operations, all or most tokens end up in converter: `balance = 1,000,000`

**Attack Transaction Steps:**

1. **Attacker queries converter balance:**
   - Observes `balance = 1,000,000` (all tokens in converter)
   - Observes `DepositBalance[depositConnector] = 500` (from trading)

2. **Attacker calls EnableConnector():**
   - Input: `{ TokenSymbol: "TOKEN", AmountToTokenConvert: 0 }`
   
3. **Execution flow:**
   - `GetNeededDeposit()` calculates: `amountOutOfTokenConvert = 1,000,000 - 1,000,000 - 0 = 0`
   - Since `amountOutOfTokenConvert = 0`, the check `if (amountOutOfTokenConvert > 0)` fails
   - Returns `needDeposit.NeedAmount = 0`
   - Line 277-285: Skipped (NeedAmount = 0)
   - Line 287-295: Skipped (AmountToTokenConvert = 0)
   - Line 297: **`State.DepositBalance[depositConnector] = 0`** ← Deposit balance erased!

**Expected vs Actual Result:**
- **Expected:** Transaction should revert (connector already enabled)
- **Actual:** Transaction succeeds, `DepositBalance` set to 0, reserve accounting corrupted

**Success Condition:** 
After the attack, querying `GetDepositConnectorBalance()` shows 0 instead of 500, and all subsequent Buy/Sell operations use incorrect Bancor calculations based on zero reserves, leading to extreme mispricing.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-73)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L75-84)
```csharp
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-64)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L141-141)
```csharp
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```
