# Audit Report

## Title
Negative Amount Bypass in NFT Burn Function Allows Arbitrary Balance Inflation

## Summary
The NFT contract's `Burn` function lacks validation for negative input amounts, allowing minters to inflate their NFT balances, protocol supply, and token quantities arbitrarily. When a negative amount is passed, the `SafeMath.Sub()` operation results in addition instead of subtraction, enabling unlimited NFT creation beyond protocol constraints.

## Finding Description

The vulnerability exists in the `Burn` function where balance manipulation occurs without validating that the input amount is non-negative. [1](#0-0) 

The root cause stems from the input amount being defined as a signed `int64` type in the protocol buffer definition, [2](#0-1)  allowing negative values to be passed to the function.

While the `DoTransfer` helper function properly validates against negative amounts with an explicit check, [3](#0-2)  the `Burn` function performs direct state manipulation without calling `DoTransfer` or implementing equivalent validation.

When a negative amount is passed (e.g., `-1000`), the security check at line 91 passes because any positive balance is greater than a negative number. Subsequently, the `SafeMath.Sub()` operation with a negative operand mathematically results in addition. [4](#0-3) 

This behavior is confirmed by the SafeMath test suite, which explicitly tests that `10.Sub(-5)` equals `15`. [5](#0-4) 

In contrast, the MultiToken contract's `Burn` implementation properly validates amounts by calling `AssertValidToken`, which includes a check that `amount > 0`. [6](#0-5) 

## Impact Explanation

This vulnerability has **CRITICAL** severity with direct fund impact:

**Supply Invariant Violation:**
- Minters can inflate their NFT balance to arbitrary amounts (e.g., from 50 to 1,050 NFTs with a single call passing `-1000` as the amount)
- Protocol supply can exceed `total_supply` limits, breaking the fundamental NFT scarcity invariant that governs the entire protocol's economic model
- Token quantity becomes inconsistent with actual minted amounts

**Protocol-Wide Impact:**
- NFT protocol holders suffer immediate dilution of their holdings as new NFTs are created out of thin air
- NFT marketplace integrity is compromised as supply limits become meaningless
- The protocol's economic model breaks down entirely, as scarcity-based value is eliminated

**Severity Justification:**
This violates the critical "Token Supply & Fees" invariant requiring correct mint/burn limits and NFT uniqueness checks. It effectively allows unlimited asset creation, equivalent to unlimited money printing in a monetary system.

## Likelihood Explanation

The likelihood of exploitation is **HIGH** due to the following factors:

**Reachable Entry Point:**
The `Burn` function is a public RPC method defined in the NFT contract interface, [7](#0-6)  accessible to any caller meeting the preconditions.

**Feasible Preconditions:**
- Attacker must be in the minter list for the NFT protocol
- Minters are added by protocol creators and are not system-level trusted entities [8](#0-7) 
- This is a realistic scenario as legitimate minters exist for every NFT protocol and can be any address added by the creator

**Execution Practicality:**
- Single transaction attack with negative amount parameter
- No complex state setup or timing requirements needed
- Immediate and guaranteed success if attacker is a minter
- The permission check at line 90-93 passes because `balance >= negative_amount` evaluates to true

**Economic Rationality:**
Extremely rational for a malicious actor - effectively free NFT creation with zero cost and unlimited profit potential based on NFT market value.

## Recommendation

Add explicit validation to reject negative amounts in the `Burn` function before performing any state modifications:

```csharp
public override Empty Burn(BurnInput input)
{
    Assert(input.Amount > 0, "Invalid burn amount."); // Add this validation
    
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    var nftInfo = GetNFTInfoByTokenHash(tokenHash);
    // ... rest of the function
}
```

This matches the validation pattern used in the MultiToken contract's burn implementation and prevents the mathematical exploitation of `Sub()` with negative operands.

## Proof of Concept

The following test demonstrates the vulnerability:

```csharp
[Fact]
public async Task NFT_Burn_Negative_Amount_Inflates_Balance()
{
    // Setup: Create NFT protocol and mint 50 NFTs to minter
    var symbol = await CreateNFTProtocol();
    var tokenId = 1;
    await MintNFT(symbol, tokenId, 50);
    
    var initialBalance = await GetNFTBalance(symbol, tokenId);
    initialBalance.ShouldBe(50); // Minter has 50 NFTs
    
    // Exploit: Call Burn with negative amount (-1000)
    var result = await NFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        TokenId = tokenId,
        Amount = -1000 // Negative amount
    });
    
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Balance increased instead of decreased
    var finalBalance = await GetNFTBalance(symbol, tokenId);
    finalBalance.ShouldBe(1050); // 50 - (-1000) = 1050 âœ“ Inflated!
    
    // Verify: Protocol supply also increased
    var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = symbol });
    protocolInfo.Supply.ShouldBeGreaterThan(50); // Supply exceeded original amount
}
```

This test demonstrates that passing a negative amount to `Burn` inflates the balance from 50 to 1,050 NFTs, violating the fundamental invariant that burning should decrease, not increase, token supply.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-55)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");

        if (amount == 0) return;

        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-353)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** protobuf/nft_contract.proto (L45-47)
```text
    // Destroy nfts.
    rpc Burn (BurnInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/nft_contract.proto (L182-186)
```text
message BurnInput {
    string symbol = 1;
    int64 token_id = 2;
    int64 amount = 3;
}
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L23-24)
```csharp
        10.Sub(5).ShouldBe(5);
        10.Sub(-5).ShouldBe(15);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```
