# Audit Report

## Title
Users Lose 100 ELF When Calling Create on Sidechains Due to Chain-Agnostic Fee Configuration

## Summary
The NFT contract's `GetMethodFee()` returns a hardcoded 100 ELF fee for the `Create` method regardless of chain context, while `Create()` itself only executes on the mainchain. On sidechains, users pay 100 ELF in the pre-execution phase, then the main transaction fails at the chain ID assertion, resulting in permanent fund loss with no service provided.

## Finding Description

The vulnerability arises from a mismatch between fee configuration and execution restrictions across chains:

**Fee Configuration - Chain Agnostic:**
The `GetMethodFee()` implementation returns 100 ELF for the Create method without checking `Context.ChainId`: [1](#0-0) 

**Execution Restriction - Mainchain Only:**
The `Create()` method enforces a mainchain-only restriction via assertion: [2](#0-1) 

**Fee Charging in Pre-Execution:**
Transaction fees are charged via `ChargeTransactionFees` which queries `GetMethodFee` from the target contract: [3](#0-2) 

**Pre-Transaction State Commitment:**
Pre-execution plugins generate and execute fee charging transactions before the main transaction: [4](#0-3) 

When fee charging succeeds, `IsStopExecuting` returns false, allowing main transaction to proceed: [5](#0-4) 

**Critical Flaw - State Persistence:**
When the main transaction fails, successful pre-transaction state changes (fee deductions) are still committed: [6](#0-5) 

**Execution Flow on Sidechains:**
1. User calls `Create()` on sidechain (NFT contract is deployed on sidechains to support `CrossChainCreate`)
2. Pre-execution plugin calls `ChargeTransactionFees`
3. `ChargeTransactionFees` invokes `GetMethodFee("Create")` → returns 100 ELF
4. User has sufficient balance, fee charging succeeds (Success = true)
5. Fee deduction state changes are committed
6. `IsStopExecuting` returns false (because Success = true)
7. Main transaction executes
8. `Create()` fails at chain ID assertion
9. Fee charging was successful, so its state changes persist
10. User permanently loses 100 ELF

## Impact Explanation

**Direct Financial Loss:**
Each failed attempt costs exactly 100_00000000 base units (100 ELF with 8 decimals), representing significant value loss with zero benefit.

**Affected Users:**
- Users unaware of mainchain-only restriction
- Users accidentally calling from sidechain wallets
- Developers testing NFT creation on sidechains
- Users misled by the proto interface which doesn't indicate chain restrictions: [7](#0-6) 

**Protocol Trust Damage:**
This creates a fee trap that appears as either a bug or intentional extraction, particularly problematic since `CrossChainCreate` exists for sidechains but charges no fees through `GetMethodFee`.

## Likelihood Explanation

**No Attack Required:**
This is a design flaw in normal operation. Any user simply calling a public method triggers the loss.

**Low Complexity:**
- User must be on a sidechain (where NFT contract is deployed for `CrossChainCreate` functionality)
- User needs ≥100 ELF balance
- No other preconditions required

**High Probability:**
- `Create` is the primary NFT protocol creation entry point
- Proto interface exposes it as a standard RPC without mainchain indication
- Error message appears only after fee deduction
- Natural user behavior on sidechains triggers the issue

## Recommendation

Implement chain-aware fee configuration in `GetMethodFee`:

```csharp
public override MethodFees GetMethodFee(StringValue input)
{
    if (input.Value == nameof(Create))
    {
        // Only charge fee on mainchain where Create actually works
        if (Context.ChainId != ChainHelper.ConvertBase58ToChainId("AELF"))
        {
            return new MethodFees(); // Return empty fees on sidechains
        }
        
        return new MethodFees
        {
            MethodName = input.Value,
            Fees =
            {
                new MethodFee
                {
                    Symbol = Context.Variables.NativeSymbol,
                    BasicFee = 100_00000000
                }
            }
        };
    }

    return new MethodFees();
}
```

Alternatively, move the chain ID validation earlier or document the restriction prominently in the proto interface.

## Proof of Concept

```csharp
[Fact]
public async Task Create_OnSidechain_LosesFeeWithoutExecution()
{
    // Setup: Deploy NFT contract on sidechain
    var sideChainId = ChainHelper.ConvertBase58ToChainId("tDVV");
    
    // User starts with 1000 ELF
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = UserAddress,
        Symbol = "ELF",
        Amount = 1000_00000000
    });
    
    var initialBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddress,
        Symbol = "ELF"
    });
    
    // User calls Create on sidechain (will fail due to chain restriction)
    var result = await NFTContractStub.Create.SendWithExceptionAsync(new CreateInput
    {
        NftType = "Art",
        ProtocolName = "TestNFT",
        TotalSupply = 1000,
        // ... other fields
    });
    
    // Transaction fails with chain ID error
    result.TransactionResult.Error.ShouldContain("NFT Protocol can only be created at aelf mainchain");
    
    // But user still lost 100 ELF in fees
    var finalBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddress,
        Symbol = "ELF"
    });
    
    var feeLost = initialBalance.Balance - finalBalance.Balance;
    feeLost.ShouldBe(100_00000000); // User permanently lost 100 ELF
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-34)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-17)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-39)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L58-112)
```csharp
    public async Task<IEnumerable<Transaction>> GetPreTransactionsAsync(IReadOnlyList<ServiceDescriptor> descriptors,
        ITransactionContext transactionContext)
    {
        try
        {
            var chainContext = new ChainContext
            {
                BlockHash = transactionContext.PreviousBlockHash,
                BlockHeight = transactionContext.BlockHeight - 1
            };

            var tokenContractAddress = await _smartContractAddressService.GetAddressByContractNameAsync(
                chainContext,
                TokenSmartContractAddressNameProvider.StringName);

            if (transactionContext.BlockHeight < AElfConstants.GenesisBlockHeight + 1 ||
                tokenContractAddress == null)
                return new List<Transaction>();

            if (!IsApplicableToTransaction(descriptors, transactionContext.Transaction, tokenContractAddress))
                return new List<Transaction>();

            var tokenStub = _contractReaderFactory.Create(new ContractReaderContext
            {
                Sender = transactionContext.Transaction.From,
                ContractAddress = tokenContractAddress,
                RefBlockNumber = transactionContext.Transaction.RefBlockNumber
            });

            if (IsExemptedTransaction(transactionContext.Transaction, tokenContractAddress, tokenStub))
                return new List<Transaction>();

            var txCost = await _txFeeService.CalculateFeeAsync(transactionContext, chainContext);
            var chargeTransactionFeesInput = new ChargeTransactionFeesInput
            {
                MethodName = transactionContext.Transaction.MethodName,
                ContractAddress = transactionContext.Transaction.To,
                TransactionSizeFee = txCost
            };

            var transactionSizeFeeSymbols =
                await _transactionSizeFeeSymbolsProvider.GetTransactionSizeFeeSymbolsAsync(chainContext);
            if (transactionSizeFeeSymbols != null)
                foreach (var transactionSizeFeeSymbol in transactionSizeFeeSymbols.TransactionSizeFeeSymbolList)
                    chargeTransactionFeesInput.SymbolsToPayTxSizeFee.Add(new SymbolToPayTxSizeFee
                    {
                        TokenSymbol = transactionSizeFeeSymbol.TokenSymbol,
                        BaseTokenWeight = transactionSizeFeeSymbol.BaseTokenWeight,
                        AddedTokenWeight = transactionSizeFeeSymbol.AddedTokenWeight
                    });

            var chargeFeeTransaction = GetTransaction(tokenStub, chargeTransactionFeesInput);
            return new List<Transaction>
            {
                chargeFeeTransaction
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L123-129)
```csharp
    public bool IsStopExecuting(ByteString txReturnValue, out string preExecutionInformation)
    {
        var chargeTransactionFeesOutput = new ChargeTransactionFeesOutput();
        chargeTransactionFeesOutput.MergeFrom(txReturnValue);
        preExecutionInformation = chargeTransactionFeesOutput.ChargingInformation;
        return !chargeTransactionFeesOutput.Success;
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L110-133)
```csharp
        if (!trace.IsSuccessful())
        {
            var transactionExecutingStateSets = new List<TransactionExecutingStateSet>();

            AddToTransactionStateSets(transactionExecutingStateSets, trace.PreTraces);
            AddToTransactionStateSets(transactionExecutingStateSets, trace.PostTraces);

            groupStateCache.Update(transactionExecutingStateSets);
            trace.SurfaceUpError();
        }
        else
        {
            groupStateCache.Update(trace.GetStateSets());
        }

        return true;
    }

    private static void AddToTransactionStateSets(List<TransactionExecutingStateSet> transactionExecutingStateSets,
        RepeatedField<TransactionTrace> traces)
    {
        transactionExecutingStateSets.AddRange(traces.Where(p => p.IsSuccessful())
            .SelectMany(p => p.GetStateSets()));
    }
```

**File:** protobuf/nft_contract.proto (L22-24)
```text
    // Create a new nft protocol.
    rpc Create (CreateInput) returns (google.protobuf.StringValue) {
    }
```
