### Title
Insufficient Deposit Calculation Due to Pre-Transferred Tokens in EnableConnector

### Summary
The `GetNeededDeposit` function includes pre-existing token balances when calculating required deposits for connector enablement. An attacker can directly transfer resource tokens to the TokenConverter contract before calling `EnableConnector`, artificially reducing the calculated deposit requirement. This results in insufficient base token reserves backing the resource token supply, breaking the Bancor pricing invariant and enabling economic attacks.

### Finding Description

The vulnerability exists in the `GetNeededDeposit` function which calculates the deposit required before enabling a connector pair. [1](#0-0) 

At these lines, the function retrieves the contract's current balance of the resource token and calculates `amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert`. This formula assumes that any tokens already at the contract address (`balance`) are legitimately "in the system" and don't need deposit backing.

However, there is no restriction preventing direct token transfers to the contract address. If an attacker transfers resource tokens directly to the contract before `EnableConnector` is called, this artificially inflates the `balance` value, which in turn reduces `amountOutOfTokenConvert`, leading to a lower calculated `needDeposit`. [2](#0-1) 

The reduced `needDeposit` is then used in `EnableConnector` to set the initial deposit balance: [3](#0-2) 

The critical issue is that `State.DepositBalance` is set to the insufficient amount, while the contract holds more resource tokens than this deposit can properly back. During subsequent `Buy` and `Sell` operations, the Bancor formula uses:
- Deposit connector balance from `State.DepositBalance` (artificially low)
- Resource connector balance from actual contract balance (artificially high due to pre-transfer) [4](#0-3) 

This imbalance skews the Bancor pricing mechanism, as the reserve ratio no longer matches the intended economic model.

### Impact Explanation

**Direct Economic Damage:**
- The Bancor reserve ratio is broken, with insufficient base token deposits backing the resource token supply
- Resource tokens can be purchased at artificially low prices because the deposit balance appears lower relative to the resource token balance than it should be
- Attackers can exploit the mispricing to drain the deposit pool through arbitrage
- The protocol's economic invariant (proper reserve backing) is violated from initialization

**Affected Parties:**
- Legitimate users who deposit funds expecting proper Bancor pricing
- The protocol treasury which relies on correct fee calculations
- Any participants in the token conversion system who face incorrect exchange rates

**Severity Justification:**
This is a **Critical** vulnerability because:
1. It affects fund security directly (deposit pool can be drained)
2. It breaks a core economic invariant (Bancor reserve backing)
3. The exploit is trivial to execute (single token transfer + EnableConnector call)
4. The impact persists for the lifetime of the connector (cannot be fixed post-enablement)
5. It affects all subsequent Buy/Sell transactions

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker needs: (1) resource tokens to pre-transfer, (2) small amount of base tokens for the reduced deposit
- Both are readily available on any functioning blockchain

**Attack Complexity:**
- Very low - only two simple operations required:
  1. Standard token transfer to contract address
  2. Call to public `EnableConnector` function
- No special timing, permissions, or sophisticated interactions needed

**Feasibility Conditions:**
- Connector pair must be added but not yet enabled (via `AddPairConnector`)
- Attacker must act before legitimate enablement
- These conditions are easily achievable in practice

**Detection/Operational Constraints:**
- The attack is difficult to detect because direct token transfers appear as normal blockchain transactions
- No on-chain validation prevents this behavior
- Once enabled with incorrect reserves, the connector cannot be updated (UpdateConnector is blocked after enablement) [5](#0-4) 

**Probability Assessment:**
High likelihood - the attack is economically rational (profit from arbitrage exceeds gas costs), technically trivial, and provides immediate returns with minimal risk.

### Recommendation

**Code-Level Mitigation:**

Modify `GetNeededDeposit` to reject calculations when the contract holds any pre-existing balance of the resource token:

```csharp
public override DepositInfo GetNeededDeposit(ToBeConnectedTokenInfo input)
{
    var toConnector = State.Connectors[input.TokenSymbol];
    Assert(toConnector != null && !toConnector.IsDepositAccount, "[GetNeededDeposit]Can't find to connector.");
    var fromConnector = State.Connectors[toConnector.RelatedSymbol];
    Assert(fromConnector != null, "[GetNeededDeposit]Can't find from connector.");
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(
        new GetTokenInfoInput
        {
            Symbol = input.TokenSymbol
        });
    var balance = State.TokenContract.GetBalance.Call(
        new GetBalanceInput
        {
            Owner = Context.Self,
            Symbol = input.TokenSymbol
        }).Balance;
    
    // NEW CHECK: Reject if contract already holds tokens before EnableConnector
    Assert(balance == 0, "Contract must not hold any tokens before EnableConnector is called.");
    
    var amountOutOfTokenConvert = tokenInfo.TotalSupply - input.AmountToTokenConvert;
    // ... rest of function
}
```

**Invariant Check:**
Add assertion in `EnableConnector` before accepting tokens:
```csharp
var preBalance = State.TokenContract.GetBalance.Call(new GetBalanceInput
{
    Owner = Context.Self,
    Symbol = input.TokenSymbol
}).Balance;
Assert(preBalance == 0, "Contract must not hold resource tokens before enablement.");
```

**Test Cases:**
1. Test that `EnableConnector` fails if tokens are pre-transferred to contract
2. Test that `GetNeededDeposit` returns error for non-zero pre-existing balance
3. Regression test verifying correct deposit calculation with zero initial balance

### Proof of Concept

**Initial State:**
- Resource token "CPU" with total supply: 1,000,000 tokens
- Deposit connector "(NT)CPU" with virtual balance: 100,000 ELF
- Both connectors have weight: 0.5
- Connector pair added but not enabled
- Attacker holds: 400,000 CPU tokens

**Attack Sequence:**

1. **Attacker transfers tokens directly to contract:**
   - Call `TokenContract.Transfer(To: TokenConverterContract, Symbol: "CPU", Amount: 400,000)`
   - Contract now holds 400,000 CPU tokens

2. **Attacker calls EnableConnector with minimal deposit:**
   ```
   EnableConnector({
     TokenSymbol: "CPU",
     AmountToTokenConvert: 100,000
   })
   ```

3. **GetNeededDeposit calculation (compromised):**
   - balance = 400,000 (includes pre-transferred tokens)
   - amountOutOfTokenConvert = 1,000,000 - 400,000 - 100,000 = 500,000
   - needDeposit = BancorFormula(500,000 circulating) â‰ˆ 100,000 ELF

4. **Expected vs Actual Result:**
   - **Expected:** Deposit should back 500,000 tokens being placed into converter system
   - **Actual:** Deposit only backs circulating 500,000 tokens, but converter holds 500,000 tokens (400,000 + 100,000)
   - Result: Contract has 500,000 tokens with deposit calculated for 500,000 circulating (missing 400,000 tokens worth of backing)

5. **Post-Attack State:**
   - Contract balance: 500,000 CPU tokens
   - State.DepositBalance: ~100,000 ELF (insufficient)
   - Bancor pricing uses: deposit=100,000 ELF, resource=500,000 CPU
   - **Correct ratio should be:** deposit backing 500,000 CPU in system, not 500,000 circulating

6. **Exploitation:**
   - Users can now buy CPU tokens at artificially low prices
   - The 400,000 pre-transferred tokens effectively have zero deposit backing
   - Attacker can arbitrage the mispricing to drain the deposit pool

**Success Condition:** 
The connector is enabled with `State.DepositBalance` significantly lower than required for the actual token balance held by the contract, breaking the Bancor economic model and enabling profitable arbitrage attacks.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L67-73)
```csharp
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L74-84)
```csharp
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-297)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```
