### Title
Decimal Overflow in Bancor Price Calculation Causes DoS When Extreme Connector Weight Ratios Are Used

### Summary
The `Exp` function computes powers up to y^20 using binary exponentiation without bounds checking on the argument `y`. When connector weights have extreme ratios (e.g., 0.9999:0.0001), combined with legitimate trade amounts, the resulting `y` value passed to `Exp` can exceed ~4000, causing intermediate calculations in `Pow` to overflow `decimal.MaxValue` (~7.9×10^28) and revert with `OverflowException`, resulting in permanent DoS of token conversion functionality.

### Finding Description

The vulnerability exists in the interaction between three functions: [1](#0-0) 

The `Exp` function implements the exponential power series `exp(y) = 1 + y + y^2/2! + y^3/3! + ... + y^20/20!`. At line 160, it calls `Pow(y, iteration)` where iteration ranges from 1 to 20. [2](#0-1) 

The `Pow` function uses left-to-right binary exponentiation, repeatedly performing `A *= A` (squaring) operations. For large base values, these squaring operations cause exponential growth that exceeds decimal limits.

**Root Cause**: The argument `y` to `Exp` is computed as `(weight_ratio) * Ln(balance_ratio)`: [3](#0-2) [4](#0-3) 

Connector weights are validated to be strictly between 0 and 1: [5](#0-4) [6](#0-5) 

However, **there is no constraint on the ratio between two connector weights**. If weights are 0.9999 and 0.0001, the ratio is 9,999. The `Ln` function can return values up to ~0.693 (approaching ln(2)): [7](#0-6) 

Therefore, `y = 9,999 × 0.693 ≈ 6,929` is a valid input to `Exp`.

**Overflow Calculation**: For y = 6,929 in computing y^20 via binary exponentiation:
- y^2 = 48,010,041
- y^4 = 2.3 × 10^15
- y^8 = 5.3 × 10^30 → **OVERFLOWS decimal.MaxValue ≈ 7.9 × 10^28**

AElf contracts enforce checked arithmetic that throws `OverflowException` on overflow, causing transaction reversion.

### Impact Explanation

**Operational Impact - DoS of Token Conversion**:
- When connector weights have extreme ratios (>1000:1) and users attempt moderate-sized trades (>30% of connector balance), the `Buy` and `Sell` operations fail with `OverflowException`
- This creates a **permanent DoS** condition because activated connectors cannot have their weights updated: [8](#0-7) 

Line 64 prevents weight updates after activation, making the DoS irrecoverable without contract migration.

**Affected Operations**: [9](#0-8) [10](#0-9) 

Both `Buy` and `Sell` directly call the vulnerable Bancor calculation functions at lines 120-123 and 168-172, with no exception handling to gracefully degrade or recover.

**Severity Justification**: HIGH - Complete loss of token conversion functionality for affected connector pairs, with no recovery mechanism. While funds are not directly stolen, the economic damage is severe as liquidity becomes permanently locked and token exchange is impossible.

### Likelihood Explanation

**Preconditions**:
1. Connector controller (typically Parliament governance) sets connector weights with extreme ratio (>1000:1)
2. Connectors are activated (`IsPurchaseEnabled = true`)
3. User submits `Buy` or `Sell` transaction with amount >30% of connector balance

**Feasibility**:
- **Weight Configuration**: Extreme ratios like 0.9999:0.0001 are technically valid per the validation logic. This could occur through:
  - **Mistake**: Governance proposal contains typo (e.g., "0.0001" instead of "0.001")
  - **Malicious governance**: Intentional misconfiguration
  - **Poor understanding**: Not realizing ratio implications [11](#0-10) 

Only controller authorization is checked (lines 60, 82), no ratio bounds.

- **Trade Triggering**: Normal user trades with moderate amounts trigger overflow. Example: If `toConnectorBalance = 10,000 tokens`, a buy of 3,400 tokens causes overflow with 10,000:1 weight ratio.

- **Attack Complexity**: LOW - Once misconfigured, any user can trigger the DoS through normal trading operations without specialized knowledge.

**Probability Assessment**: MEDIUM-HIGH
- Extreme weight ratios unlikely under careful governance but plausible with configuration errors
- No warning systems or pre-deployment validation for ratio safety
- Once deployed, easily triggered by regular users
- Permanent damage due to inability to fix activated connectors

### Recommendation

**1. Add Connector Weight Ratio Bounds**:

In `AssertValidConnectorWeight` and `AddPairConnector`, validate that weight ratios between paired connectors remain within safe bounds (e.g., max 100:1 ratio):

```csharp
private void AssertValidPairConnectorWeights(Connector connector1, Connector connector2)
{
    var weight1 = decimal.Parse(connector1.Weight);
    var weight2 = decimal.Parse(connector2.Weight);
    var ratio = Math.Max(weight1 / weight2, weight2 / weight1);
    Assert(ratio <= 100m, "Connector weight ratio must not exceed 100:1 to prevent overflow.");
}
```

Apply this check in `AddPairConnector` after line 106 and in `UpdateConnector` when both connectors exist.

**2. Add Input Bounds to Exp Function**:

Add explicit bounds checking in `Exp` to prevent overflow:

```csharp
private static decimal Exp(decimal y)
{
    // Prevent overflow: for y^8 < decimal.MaxValue, need y < ~4000
    if (Math.Abs(y) > 4000m)
        throw new InvalidValueException("Exponential argument exceeds safe bounds.");
    // ... existing implementation
}
```

**3. Add Integration Tests**:

Create tests covering extreme but valid weight ratios:
- Test connector pair with weights 0.9:0.1 (ratio 9:1)
- Test connector pair with weights 0.99:0.01 (ratio 99:1)  
- Verify transactions don't revert with overflow
- Add negative test confirming ratio >100:1 is rejected

**4. Governance Documentation**:

Document safe weight ratio ranges in governance proposal templates and connector setup guides.

### Proof of Concept

**Initial State**:
1. TokenConverter contract deployed and initialized
2. Connector controller is Parliament contract

**Transaction Sequence**:

**Step 1** - Governance sets extreme weight ratio (through Parliament proposal):
- Create connector pair for ELF-WRITE token conversion
- ELF connector: weight = "0.9999", virtual balance = 1,000,000
- WRITE connector: weight = "0.0001", virtual balance = 1,000,000
- Weight ratio: 0.9999 / 0.0001 = 9,999

**Step 2** - Activate connectors:
- Enable purchase on both connectors

**Step 3** - User attempts to buy WRITE tokens:
- Call `Buy(symbol: "WRITE", amount: 340,000, payLimit: 0)`
- This represents buying 34% of WRITE connector balance

**Expected Result**: Transaction completes, user receives 340,000 WRITE tokens

**Actual Result**: 
- `GetAmountToPayFromReturn` calculates: y = 9,999 × Ln(1,000,000 / 660,000) ≈ 9,999 × 0.416 ≈ 4,159
- `Exp(4,159)` calls `Pow(4,159, 20)`
- Computing 4,159^8 during binary exponentiation: 4,159^8 ≈ 1.2 × 10^29 > decimal.MaxValue
- `OverflowException` thrown
- Transaction reverts
- **Success Condition for Exploit**: DoS confirmed - all subsequent Buy/Sell attempts with amounts >30% of balance will fail permanently

**Notes**:
- The exact threshold depends on the specific weight ratio and trade size
- With ratio 1,000:1, trades >60% of balance trigger overflow
- With ratio 10,000:1, trades >30% of balance trigger overflow
- Once connectors are activated, weights cannot be changed, making the DoS permanent without contract migration
- The overflow occurs in the legitimate price calculation logic, not through any malicious contract call

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-94)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L104-120)
```csharp
    public static decimal Pow(decimal x, uint y)
    {
        if (y == 1)
            return x;

        var A = 1m;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;

        for (var i = t - 1; i >= 0; --i)
        {
            A *= A;
            if (e[i]) A *= x;
        }

        return A;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L124-143)
```csharp
    private static decimal Ln(decimal a)
    {
        /*
        ln(a) = log(1-x) = - x - x^2/2 - x^3/3 - ...   (where |x| < 1)
            x: a = 1-x    =>   x = 1-a = 1 - 1.004 = -.004
        */
        var x = 1 - a;
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");

        decimal result = 0;
        uint iteration = _LOOPS;
        while (iteration > 0)
        {
            result -= Pow(x, iteration) / iteration;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L54-110)
```csharp

        return new Empty();
    }

    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }


    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-159)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-175)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```
