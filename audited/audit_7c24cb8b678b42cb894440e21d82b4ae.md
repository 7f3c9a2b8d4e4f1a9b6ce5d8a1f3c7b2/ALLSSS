### Title
Malicious Miner Can Inject Duplicate Order Values to Crash Secret Sharing Mechanism via Unvalidated TuneOrderInformation

### Summary
A malicious miner can submit an `UpdateValue` transaction with crafted `TuneOrderInformation` containing duplicate `FinalOrderOfNextRound` values. These duplicate values propagate to the next round's `Order` field and subsequently cause `RevealSharedInValues()` to extract duplicate order values at lines 40-44, leading to division-by-zero in `SecretSharingHelper.DecodeSecret()` and complete failure of the secret sharing mechanism.

### Finding Description

The vulnerability exists in the order validation and secret reconstruction flow:

**Root Cause Location 1 - Missing Validation:** [1](#0-0) 

The `ProcessUpdateValue` function directly applies `TuneOrderInformation` from user input without validating order uniqueness.

**Root Cause Location 2 - Insufficient Validation Provider:** [2](#0-1) 

The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue` but does not check for duplicate `FinalOrderOfNextRound` values in `TuneOrderInformation`.

**Root Cause Location 3 - Missing Validation Application:** [3](#0-2) 

The `NextRoundMiningOrderValidationProvider` (which checks order distinctness) is NOT applied to `UpdateValue` behavior, only to `NextRound` behavior at lines 85-86.

**Attack Vector - Order Propagation:** [4](#0-3) 

When generating the next round, miners' `Order` values are directly assigned from their `FinalOrderOfNextRound` in the current round, propagating any duplicates.

**Failure Point - Duplicate Order Extraction:** [5](#0-4) 

The `orders` list is constructed by looking up each `DecryptedPiece` key in `previousRound.RealTimeMinersInformation` and extracting the `Order` field. If the previous round contains duplicate `Order` values, this list will contain duplicates.

**Crash Point - Division by Zero:** [6](#0-5) 

In the Lagrange interpolation loop, when `i ≠ j` but `orders[i] == orders[j]`, the calculation `orders[j] - orders[i]` at line 57 yields zero, causing division-by-zero when computing the modular inverse.

### Impact Explanation

**Operational Impact - DoS of Secret Sharing:**
- The secret sharing mechanism completely fails when duplicate orders are passed to `DecodeSecret`
- Division-by-zero error crashes the secret reconstruction process
- Miners cannot reveal previous in-values, breaking the verifiable random function (VRF) chain
- Consensus round transitions become disrupted as `RevealSharedInValues` is called during `NextRound` transitions

**Consensus Integrity Impact:** [7](#0-6) 

`RevealSharedInValues` is invoked during `GetConsensusExtraDataForNextRound`, which is part of the consensus command generation. Failure here disrupts the entire consensus flow.

**Affected Parties:**
- All honest miners attempting to produce blocks in affected rounds
- Network users experiencing consensus delays or halts
- Any services dependent on the random number generation

### Likelihood Explanation

**Attacker Capabilities - Realistic:**
- Attacker must be a legitimate miner in the current round (verified by `PreCheck`) [8](#0-7) 

- Attacker needs modified node software to construct malicious `UpdateValueInput`
- The `UpdateValue` method is public and accepts arbitrary input [9](#0-8) 

**Attack Complexity - Low:**
1. Miner constructs `UpdateValueInput` with `TuneOrderInformation` mapping multiple miner pubkeys to the same order value (e.g., `{"MinerB": 2, "MinerC": 2}`)
2. Submit transaction during their mining slot
3. Transaction passes validation (no duplicate check exists)
4. Duplicate orders persist in state
5. Next round inherits duplicate orders
6. Subsequent round transition triggers crash

**Feasibility Conditions:**
- Secret sharing must be enabled [10](#0-9) 

- At least one miner in the affected round must have sufficient `DecryptedPieces` to trigger reconstruction

**Detection Constraints:**
- Attack is visible on-chain (malicious `TuneOrderInformation` in transaction)
- However, there's no automated detection or rejection mechanism
- Network-wide impact occurs before manual intervention is possible

### Recommendation

**1. Add Duplicate Order Validation:**

Add validation in `UpdateValueValidationProvider` or create a dedicated provider to check that all `FinalOrderOfNextRound` values remain distinct after applying `TuneOrderInformation`:

```csharp
// In UpdateValueValidationProvider or new provider
var allOrders = validationContext.ProvidedRound.RealTimeMinersInformation.Values
    .Select(m => m.FinalOrderOfNextRound)
    .Where(o => o > 0)
    .ToList();
    
if (allOrders.Count != allOrders.Distinct().Count())
    return new ValidationResult { Message = "Duplicate FinalOrderOfNextRound values detected." };
```

**2. Apply Order Validation to UpdateValue Behavior:**

Modify the validation provider registration to include order uniqueness checks for `UpdateValue`: [11](#0-10) 

Add a distinct order validation provider to the `UpdateValue` case similar to the `NextRound` case.

**3. Add Defensive Check in RevealSharedInValues:**

Before calling `DecodeSecret`, validate that the `orders` list contains no duplicates:

```csharp
// After line 44
if (orders.Count != orders.Distinct().Count())
{
    Context.LogDebug(() => $"Duplicate orders detected for miner {publicKeyOfAnotherMiner}, skipping secret reconstruction.");
    continue;
}
```

**4. Add Contract-Level Invariant Test:**

Create test cases that attempt to inject duplicate orders via malicious `TuneOrderInformation` and verify rejection.

### Proof of Concept

**Required Initial State:**
- Secret sharing enabled via configuration
- Network with at least 3 miners (A, B, C)
- Round N in progress

**Attack Steps:**

1. **Round N - Inject Duplicate Orders:**
   - Attacker (Miner A) constructs malicious `UpdateValueInput` during their mining slot:
     ```
     UpdateValueInput {
       TuneOrderInformation: {
         "MinerB_Pubkey": 2,
         "MinerC_Pubkey": 2  // Duplicate!
       },
       [other required fields set normally]
     }
     ```
   - Submit via `UpdateValue()` transaction
   - Transaction succeeds (passes `UpdateValueValidationProvider`)

2. **Round N State Corrupted:**
   - `State.Rounds[N]` now contains:
     - `MinerB.FinalOrderOfNextRound = 2`
     - `MinerC.FinalOrderOfNextRound = 2`

3. **Round N+1 Generation:**
   - `GenerateNextRoundInformation` is called
   - Creates `Round N+1` with:
     - `MinerB.Order = 2`
     - `MinerC.Order = 2` (duplicate orders in active round)

4. **Round N+1 → N+2 Transition - Crash Triggered:**
   - Extra block producer initiates `NextRound` behavior
   - `GetConsensusExtraDataForNextRound` invokes `RevealSharedInValues(currentRound=N+1, pubkey)`
   - `RevealSharedInValues` retrieves `previousRound = Round N+1` (with duplicates)
   - For a miner with `DecryptedPieces` containing keys for both MinerB and MinerC:
     - `orders` list becomes `[..., 2, 2, ...]`
   - Calls `SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount)`
   - At iteration where `orders[i] = 2` and `orders[j] = 2` but `i ≠ j`:
     - `denominator = orders[j] - orders[i] = 0`
     - `Inverse(0)` causes division-by-zero

**Expected vs Actual Result:**
- **Expected:** Secret reconstruction succeeds, consensus proceeds normally
- **Actual:** Division-by-zero error, secret reconstruction fails, consensus disrupted

**Success Condition:**
The attack succeeds when duplicate orders persist through round generation and trigger the crash in `DecodeSecret` during subsequent round transitions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-83)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-44)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L52-61)
```csharp
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
