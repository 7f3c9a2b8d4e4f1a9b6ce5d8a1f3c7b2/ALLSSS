# Audit Report

## Title
Replacement Miner Can Manipulate Mining Order Through Arbitrary PreviousInValue Injection

## Summary
The AEDPoS consensus contract fails to validate `PreviousInValue` for replacement miners appearing for the first time. This allows attackers to inject arbitrary values that directly control their signature calculation, enabling them to manipulate their mining order in the next round through offline brute-forcing. This breaks the consensus mechanism's fairness and randomness guarantees.

## Finding Description

The vulnerability exists in the `GetConsensusExtraDataToPublishOutValue()` function where validation logic for `PreviousInValue` is bypassed for replacement miners. [1](#0-0) 

When a miner provides `triggerInformation.PreviousInValue`, the code checks if the miner existed in the previous round. For replacement miners who are appearing for the first time (replacing evil miners), the condition `previousRound.RealTimeMinersInformation.ContainsKey(pubkey)` returns false. This causes the code to skip the hash validation and accept the arbitrary value in the else block, then use it to calculate the miner's signature.

The validation provider confirms this bypass: [2](#0-1) 

The validation immediately returns `true` if the miner doesn't exist in the previous round, bypassing all subsequent validation checks including the critical hash verification.

The arbitrary `PreviousInValue` is then used to calculate the signature: [3](#0-2) 

This signature directly determines the miner's order in the next round through modular arithmetic: [4](#0-3) 

The intended fallback mechanism that should generate a deterministic `fakePreviousInValue` is bypassed: [5](#0-4) 

An attacker can preemptively provide their own `PreviousInValue` in the trigger information, taking the earlier code path where validation is skipped for new miners.

## Impact Explanation

**Critical Consensus Integrity Violation**: The AEDPoS consensus mechanism is designed to ensure unpredictable and fair mining order through cryptographic randomness. This vulnerability allows attackers to deterministically choose their position.

**Concrete Harms**:

1. **Mining Order Manipulation**: Attacker can brute-force offline to select any desired mining position (1 through N) by trying different `PreviousInValue` candidates until the resulting signature produces their target order.

2. **Extra Block Producer Influence**: When an attacker achieves Order 1 in any round, their manipulated signature is used to determine the extra block producer for the following round: [6](#0-5) 

3. **Reward Advantage**: Extra block producers mine additional blocks, increasing their `ProducedBlocks` counter which directly determines mining reward shares: [7](#0-6) 

4. **Fairness Violation**: Honest miners lose fair competition for mining positions while the attacker gains systematic advantage.

**Severity: HIGH** - This breaks a fundamental consensus invariant (randomness/fairness of miner ordering), enables reward manipulation, and has no detection mechanism.

## Likelihood Explanation

**Attack Prerequisites**:
- Attacker must be selected as a replacement miner (occurs when miners are marked as evil for missing time slots)
- Attacker controls their node software to modify trigger information (standard assumption for consensus security)

**Attack Complexity: LOW**
- All previous round signatures are publicly available on-chain
- Simple XOR operations and modular arithmetic
- Offline brute-forcing with no time pressure
- For 21 miners: ~10-11 attempts average to find Order 1
- Formula: Try different `PreviousInValue` values until `(XOR(PreviousInValue, all_previous_signatures) % minersCount) + 1` equals desired order

**Feasibility: HIGH**
- Evil miner replacement is a regular occurrence in the protocol
- No special permissions beyond being an authorized candidate
- No timing constraints (compute before mining slot)
- Attack is indistinguishable from legitimate consensus data

**Detection: NONE**
- No on-chain mechanism validates randomness of PreviousInValue for replacement miners
- Manipulated signatures appear legitimate
- No monitoring for order manipulation patterns

**Probability: MEDIUM-HIGH** - Replacement opportunities occur regularly during normal consensus operation.

## Recommendation

Add validation to ensure replacement miners cannot provide arbitrary `PreviousInValue` values. The deterministic `fakePreviousInValue` mechanism should be enforced for all first-time miners.

**Fix**: Modify the validation logic to reject provided `PreviousInValue` for miners not in the previous round:

```csharp
// In GetConsensusExtraDataToPublishOutValue()
if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
{
    // For replacement miners, ignore provided PreviousInValue and use deterministic value
    if (!previousRound.RealTimeMinersInformation.ContainsKey(pubkey))
    {
        var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
        signature = previousRound.CalculateSignature(fakePreviousInValue);
    }
    else if (triggerInformation.PreviousInValue != null && triggerInformation.PreviousInValue != Hash.Empty)
    {
        // Existing validation for normal miners
        if (HashHelper.ComputeFrom(triggerInformation.PreviousInValue) != previousRound.RealTimeMinersInformation[pubkey].OutValue)
        {
            previousInValue = Hash.Empty;
        }
        else
        {
            previousInValue = triggerInformation.PreviousInValue;
        }
        signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
    }
    // ... rest of logic
}
```

Alternatively, update `UpdateValueValidationProvider` to explicitly validate that replacement miners do not provide `PreviousInValue`:

```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;
    
    // Replacement miners should not provide PreviousInValue
    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey))
    {
        return extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null ||
               extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == Hash.Empty;
    }
    
    // Existing validation for normal miners
    // ...
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a test chain with evil miner detection
2. Having a replacement miner join mid-round
3. Injecting crafted `PreviousInValue` in trigger information
4. Observing that validation passes despite arbitrary value
5. Verifying the miner's order in the next round matches the brute-forced target

The attack flow:
```
Round N-1: All miners with public signatures S1, S2, ..., Sn
Round N: Evil miner detected, replacement miner M added (not in N-1)
         M computes offline: for each candidate PreviousInValue P:
           signature = XOR(P, XOR(S1, S2, ..., Sn))
           order = (signature % n) + 1
         M selects P where order = 1
         M provides P in trigger information
         Validation returns true (line 40 of UpdateValueValidationProvider)
         M's signature = calculated signature
Round N+1: M has Order 1 (manipulated position)
```

A complete test would require setting up the AEDPoS test environment with miner replacement scenarios, which involves the Election contract integration for evil miner detection and replacement candidate selection.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L74-93)
```csharp
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L96-108)
```csharp
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L789-821)
```csharp
        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
```
