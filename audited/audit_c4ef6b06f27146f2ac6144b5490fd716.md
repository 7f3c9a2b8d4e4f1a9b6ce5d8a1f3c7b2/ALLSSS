### Title
Unbounded Proposal Spam Attack on Organizations with Disabled Proposer Authority

### Summary
Organizations with `ProposerAuthorityRequired` set to false allow any address to create unlimited proposals without authorization checks, rate limits, or spam protection mechanisms. This enables attackers to perform state bloat attacks and DoS governance operations through proposal spam, as transaction fees are configurable and may be insufficient deterrents.

### Finding Description

The vulnerability exists in the authorization logic for proposal creation. The `AssertIsAuthorizedProposer` function uses an OR condition that short-circuits when `ProposerAuthorityRequired` is false: [1](#0-0) 

When `!organization.ProposerAuthorityRequired` evaluates to true (i.e., when the flag is false), the entire assertion passes regardless of whitelist or parliament member status, allowing **any address** to create proposals.

The `CreateProposal` method relies solely on this authorization check before creating proposals: [2](#0-1) 

Multiple organizations in the system have this flag set to false by design:

1. **Emergency Response Organization** - explicitly created with open proposal access: [3](#0-2) 

2. **Cross-Chain Side Chain Lifetime Controller**: [4](#0-3) 

**Why Existing Protections Fail:**

1. **No Rate Limiting**: The contract has no per-address or global rate limits on proposal creation.

2. **No Proposal Caps**: There is no limit on the number of active proposals per organization or per proposer.

3. **Duplicate Prevention Insufficient**: While duplicate proposal IDs are rejected: [5](#0-4) 

Attackers can easily create unique proposals by varying any input field (title, description, params, token, etc.). Length limits exist but are generous: [6](#0-5) 

4. **Transaction Fees Not Enforced**: The Parliament contract's `GetMethodFee` implementation returns `State.TransactionFees[input.Value]` for CreateProposal, which may be null or zero if not explicitly configured: [7](#0-6) 

Fees are controlled by governance and can be set to any value including zero.

5. **Reactive Cleanup Only**: The `ClearProposal` method allows cleanup of expired proposals, but this is reactive and doesn't prevent spam creation: [8](#0-7) 

### Impact Explanation

**Operational Impact - State Bloat:**
Each proposal is stored in contract state with no upper bound: [9](#0-8) 

An attacker can create thousands of proposals (limited only by block gas and transaction fees), each consuming storage space with:
- Proposal metadata (addresses, timestamps, strings up to 10,455 characters total)
- Event data from `ProposalCreated` events
- State trie overhead

**Operational Impact - Query Performance Degradation:**
Multiple view methods iterate over proposal IDs without pagination, becoming increasingly expensive as spam accumulates: [10](#0-9) 

**Governance Impact - Disruption:**
Legitimate proposals become difficult to track and monitor when buried among spam proposals. The `GetProposal` and filtering methods would need to process through spam, increasing operational costs for:
- Parliament members reviewing proposals
- Indexing services and dApps displaying governance data
- Automated monitoring and voting systems

**Severity Justification:**
This is a HIGH severity issue because:
1. It affects critical governance infrastructure
2. Attack is practical and executable by any address
3. Impact scales with attack duration (state grows unboundedly)
4. Economic barriers may be insufficient (fees are configurable)
5. Recovery requires manual cleanup of each spam proposal after expiration

### Likelihood Explanation

**Attacker Capabilities Required:**
- Any externally owned account or contract address
- Sufficient balance to pay transaction fees (if configured) and gas
- No special permissions or privileges needed

**Attack Complexity:**
LOW - The attack is straightforward:
1. Identify organizations with `ProposerAuthorityRequired = false` (Emergency Response Organization is publicly known)
2. Generate unique proposal inputs by varying title, description, or token fields
3. Submit repeated `CreateProposal` transactions

**Feasibility Conditions:**
- Organizations with disabled proposer authority exist by default (Emergency Response Organization is created during initialization)
- Transaction fees may be unset, zero, or set too low to deter spam
- No cooldown periods or rate limits exist in the contract logic

**Economic Rationality:**
The attack cost depends on transaction fees, which are:
- Configurable by governance via `SetMethodFee`
- May be initially unset (returning null from `GetMethodFee`)
- Can be set to zero or negligible amounts

Even with reasonable fees (e.g., 0.01 ELF per proposal), an attacker could create 10,000 spam proposals for ~100 ELF, which may be economically rational if the governance disruption or reputational damage exceeds this cost.

**Detection:**
The attack would be easily detected through:
- ProposalCreated events from the same address
- State growth monitoring
- Community observation

However, detection doesn't prevent the attack or mitigate its impact on state bloat.

### Recommendation

Implement multi-layered spam protection for organizations with disabled proposer authority:

**1. Rate Limiting (Primary Defense):**
Add per-address proposal creation limits:
```
// In ParliamentState.cs
public MappedState<Address, long> LastProposalTime { get; set; }
public MappedState<Address, int> ProposalCountInWindow { get; set; }

// In AssertIsAuthorizedProposer or CreateProposal
if (!organization.ProposerAuthorityRequired) {
    var lastTime = State.LastProposalTime[proposer];
    var currentTime = Context.CurrentBlockTime.Seconds;
    
    // Reset window if 24 hours passed
    if (currentTime - lastTime > 86400) {
        State.ProposalCountInWindow[proposer] = 0;
    }
    
    var count = State.ProposalCountInWindow[proposer];
    Assert(count < MaxProposalsPerDay, "Proposal rate limit exceeded.");
    
    State.ProposalCountInWindow[proposer] = count + 1;
    State.LastProposalTime[proposer] = currentTime;
}
```

**2. Minimum Stake Requirement:**
Require proposers to lock tokens when creating proposals for open organizations:
```
// Lock tokens that are returned when proposal expires or is released
var stakeAmount = organization.MinimumProposalStake;
if (stakeAmount > 0 && !organization.ProposerAuthorityRequired) {
    State.TokenContract.TransferFrom.Send(new TransferFromInput {
        From = Context.Sender,
        To = Context.Self,
        Amount = stakeAmount,
        Symbol = "ELF"
    });
    proposal.StakedAmount = stakeAmount;
}
```

**3. Proposal Limits per Organization:**
Cap total active proposals per organization:
```
public MappedState<Address, int> ActiveProposalCount { get; set; }

// In CreateNewProposal
var activeCount = State.ActiveProposalCount[organizationAddress];
Assert(activeCount < MaxActiveProposalsPerOrganization, "Too many active proposals.");
State.ActiveProposalCount[organizationAddress] = activeCount + 1;

// In Release and ClearProposal
State.ActiveProposalCount[organizationAddress] = 
    State.ActiveProposalCount[organizationAddress] - 1;
```

**4. Increase Minimum Transaction Fees:**
Set reasonable default fees for CreateProposal in organizations with open access (enforce via governance proposal).

**5. Add Invariant Tests:**
```csharp
[Test]
public void CreateProposal_WithOpenOrganization_ShouldEnforceRateLimit()
{
    // Create multiple proposals rapidly
    // Assert rate limit is enforced after threshold
}

[Test]
public void CreateProposal_WithOpenOrganization_ShouldRequireStake()
{
    // Assert token transfer occurs when creating proposal
    // Assert tokens returned after cleanup
}
```

### Proof of Concept

**Required Initial State:**
1. Parliament contract initialized
2. Emergency Response Organization created (happens automatically via `CreateEmergencyResponseOrganization`)
3. Attacker has sufficient balance for gas and any configured transaction fees

**Attack Steps:**

1. Query Emergency Response Organization address:
```
var emergencyOrg = ParliamentContract.GetEmergencyResponseOrganizationAddress(new Empty());
```

2. Create spam proposals by varying title or token fields:
```
for (int i = 0; i < 10000; i++) {
    var proposalInput = new CreateProposalInput {
        OrganizationAddress = emergencyOrg,
        ContractMethodName = "SomeMethod",
        ToAddress = targetAddress,
        Params = ByteString.Empty,
        ExpiredTime = Timestamp.FromDateTime(DateTime.UtcNow.AddDays(7)),
        Title = $"Spam Proposal {i}",  // Vary to create unique IDs
        Description = "Spam description"
    };
    
    var proposalId = ParliamentContract.CreateProposal(proposalInput);
    // Transaction succeeds, proposal stored in state
}
```

**Expected vs Actual Result:**

**Expected (Secure):** After a small number of proposals (e.g., 10), subsequent CreateProposal calls should fail with rate limit or stake requirement errors.

**Actual (Vulnerable):** All 10,000 transactions succeed, creating 10,000 proposals in contract state, each consuming storage and adding to query overhead. The only limit is the attacker's transaction fee budget and block gas limits.

**Success Condition:**
The attack succeeds when:
1. Multiple proposals from the same address are created without authorization checks (bypassing whitelist/member validation)
2. No rate limiting prevents rapid proposal creation
3. State size grows proportionally with spam proposals
4. Query methods exhibit degraded performance when filtering through spam proposals

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L30-33)
```csharp
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L243-243)
```csharp
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L244-244)
```csharp
        State.Proposals[proposalId] = proposal;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L325-326)
```csharp
            ProposerAuthorityRequired = false,
            ParliamentMemberProposingAllowed = true
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L179-186)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L300-316)
```csharp
    public override ProposalIdList GetNotVotedPendingProposals(ProposalIdList input)
    {
        var result = new ProposalIdList();
        var currentParliament = GetCurrentMinerList();
        foreach (var proposalId in input.ProposalIds)
        {
            var proposal = State.Proposals[proposalId];
            if (proposal == null || !Validate(proposal) || CheckProposalAlreadyVotedBy(proposal, Context.Sender))
                continue;
            var organization = State.Organizations[proposal.OrganizationAddress];
            if (organization == null || !IsProposalStillPending(proposal, organization, currentParliament))
                continue;
            result.ProposalIds.Add(proposalId);
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L607-608)
```csharp
                    ProposerAuthorityRequired = false,
                    ParliamentMemberProposingAllowed = true
```

**File:** contract/AElf.Contracts.Parliament/ParliamentConstants.cs (L5-7)
```csharp
    public const int MaxLengthForTitle = 255;
    public const int MaxLengthForDescription = 10200;
    public const int MaxLengthForProposalDescriptionUrl = 255;
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L34-44)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(ApproveMultiProposals))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };

        return State.TransactionFees[input.Value];
    }
```
