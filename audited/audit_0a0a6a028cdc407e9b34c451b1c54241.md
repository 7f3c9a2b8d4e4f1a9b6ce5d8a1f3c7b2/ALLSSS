### Title
Extra Block Producer Selection Bypass Due to Incomplete Conflict Resolution in Round Generation

### Summary
A flaw in the `FinalOrderOfNextRound` conflict resolution logic within `ApplyNormalConsensusData` can cause duplicate mining orders, leading to missing orders in the next round. When the randomly calculated extra block producer order corresponds to a missing order, the system falls back to selecting the first miner deterministically, bypassing the intended signature-based random selection mechanism.

### Finding Description

The vulnerability involves two interconnected components:

**Root Cause - Incomplete Conflict Resolution Loop:** [1](#0-0) 

When `supposedOrderOfNextRound` equals `minersCount` (e.g., 5), the conflict resolution loop iterates from `i = minersCount + 1` (6) to `i < minersCount * 2` (10). For `i > minersCount`, it calculates `maybeNewOrder = i % minersCount`, yielding values [1, 2, 3, 4] but never checking order 5 itself. If orders 1-4 are all occupied, the loop fails to reassign the conflicted miner, resulting in duplicate `FinalOrderOfNextRound` values.

**Exploitation Point - Missing Order Handling:** [2](#0-1) 

In `GenerateNextRoundInformation`, duplicate `FinalOrderOfNextRound` values cause some orders to be missing from `nextRound`. When `CalculateNextExtraBlockProducerOrder` returns a missing order (which is valid per [3](#0-2) , as it produces values in [1, minersCount]), the `FirstOrDefault` lookup returns null, causing line 63 to assign the first miner in dictionary iteration order as the extra block producer instead of the signature-determined random selection.

**Execution Path:** [4](#0-3) 

The issue manifests when building `nextRound`: miners who mined receive their `FinalOrderOfNextRound` values (potentially duplicated), and remaining orders are assigned to non-mining miners. With duplicates like [1,2,2,3,4] in a 5-miner system, order 5 becomes unavailable despite being a valid selection target.

### Impact Explanation

**Consensus Fairness Violation:**
The extra block producer has special responsibilities in the AEDPoS consensus mechanism [5](#0-4) , producing the round-terminating block. The signature-based randomization ensures fair distribution of this role across miners. When bypassed, the first miner in dictionary iteration order (typically insertion-order deterministic) receives disproportionate selection frequency.

**Miner Schedule Integrity:**
The deterministic fallback creates predictable patterns in extra block producer selection, violating the CRITICAL INVARIANT of "miner schedule integrity" as specified in the audit requirements. This affects round timing calculations and could enable timing-based attacks or unfair reward accumulation.

**Severity:** Medium - Does not directly compromise funds or enable unauthorized actions, but degrades consensus fairness and violates protocol design guarantees over time.

### Likelihood Explanation

**Preconditions (Naturally Occurring):**
1. At least `minersCount - 1` miners must mine in a round
2. Two miners' signatures must produce `supposedOrderOfNextRound = minersCount` 
3. Orders 1 through `minersCount - 1` must already be occupied

**Probability Analysis:**
Signature-derived orders are effectively random (hash-based). For collision at order `minersCount`: ~1/minersCount probability per miner per round. With 17-23 mainnet miners and thousands of rounds, this becomes increasingly likely over time. No malicious behavior required - natural cryptographic randomness will eventually trigger this condition.

**Detection Difficulty:**
The fallback to `.First()` appears as normal operation externally. Only deep round data analysis would reveal the pattern, making this a silent fairness degradation.

**Likelihood:** Medium-High - Occurs through normal consensus operation without requiring attacker control, though specific conditions reduce per-round probability.

### Recommendation

**Fix the Modulo Logic:**
```csharp
// In ApplyNormalConsensusData.cs, line 31-33
for (var i = supposedOrderOfNextRound + 1; i <= supposedOrderOfNextRound + minersCount; i++)
{
    var maybeNewOrder = (i - 1) % minersCount + 1; // Ensures range [1, minersCount]
    if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
    {
        RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound = maybeNewOrder;
        break;
    }
}
```

**Add Validation:**
In `GenerateNextRoundInformation` after line 56, verify all orders [1, minersCount] are assigned:
```csharp
Assert(nextRound.RealTimeMinersInformation.Values.Select(m => m.Order).Distinct().Count() == minersCount, 
       "All mining orders must be uniquely assigned");
```

**Regression Test:**
Create test case with 5 miners where miners A-D get orders [1,2,3,4] and miners E,F both calculate `supposedOrderOfNextRound = 5`, verifying conflict resolution assigns unique orders and extra block producer selection succeeds.

### Proof of Concept

**Initial State:**
- Round with `minersCount = 5`
- Miners A, B, C, D have mined with `FinalOrderOfNextRound = [1, 2, 3, 4]`
- Miner E has `FinalOrderOfNextRound = 5`

**Exploitation Sequence:**
1. Miner F produces block with signature yielding `supposedOrderOfNextRound = 5`
2. Conflict detected with Miner E at order 5
3. Conflict resolution loop searches `maybeNewOrder` = [1,2,3,4] (all occupied)
4. Loop completes without reassigning E; both E and F have `FinalOrderOfNextRound = 5`
5. `GenerateNextRoundInformation` builds `nextRound` with orders [1,2,2,3,4], missing order 5
6. If `CalculateNextExtraBlockProducerOrder()` returns 5:
   - `FirstOrDefault(m => m.Order == 5)` returns null
   - Fallback: `nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true`

**Expected vs Actual:**
- **Expected:** Miner at order 5 becomes extra block producer (signature-determined randomness)
- **Actual:** First miner in dictionary iteration becomes extra block producer (deterministic bypass)

**Success Condition:** Transaction logs show extra block producer differs from the order calculated by signature, and occurs when duplicate `FinalOrderOfNextRound` values exist in round data.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L31-40)
```csharp
            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L60-65)
```csharp
    /// <summary>
    ///     In current AElf Consensus design, each miner produce his block in one time slot, then the extra block producer
    ///     produce a block to terminate current round and confirm the mining order of next round.
    ///     So totally, the time of one round is:
    ///     MiningInterval * MinersCount + MiningInterval.
    /// </summary>
```
