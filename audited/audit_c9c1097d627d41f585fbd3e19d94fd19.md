### Title
Insufficient Validation of Other Miners' PreviousInValue Allows Consensus State Corruption

### Summary
The `ValidatePreviousInValue()` function only validates the block producer's own `PreviousInValue` against the previous round's `OutValue`, but does not validate `PreviousInValue` for other miners. However, during execution, the `PerformSecretSharing()` function writes `PreviousInValue` for multiple miners to state based on data from the block header. This allows a malicious miner to inject arbitrary `PreviousInValue` data for other miners, corrupting consensus state and potentially manipulating mining order.

### Finding Description

**Root Cause:**

The validation only checks the sender's `PreviousInValue`: [1](#0-0) 

The critical issue is at line 38 where `publicKey` is set to `validationContext.SenderPubkey`, meaning only the block producer's own `PreviousInValue` is validated against the previous round's `OutValue`.

**Attack Vector:**

During block generation, miners can set `PreviousInValue` for other miners through the `RevealedInValues` mechanism: [2](#0-1) 

This data gets included in the block header's Round information and is NOT validated for other miners.

**State Corruption During Execution:**

The transaction input is constructed by extracting ALL miners' `PreviousInValue` from the Round: [3](#0-2) 

Then during execution, these unvalidated values are written to state: [4](#0-3) 

**Why Protections Fail:**

The validation providers list only includes `UpdateValueValidationProvider` for UpdateValue behavior: [5](#0-4) 

No validator checks the integrity of other miners' `PreviousInValue` fields.

The `RecoverFromUpdateValue` method copies `PreviousInValue` for all miners from the provided round to the base round: [6](#0-5) 

But this recovered data is not validated against the previous round's state.

### Impact Explanation

**Concrete Harm:**

1. **Consensus State Corruption**: Attacker can write arbitrary `PreviousInValue` for victim miners, corrupting the consensus round state stored on-chain.

2. **Mining Order Manipulation**: The signature calculation depends on `PreviousInValue`: [7](#0-6) 

And mining order for next round is determined by this signature: [8](#0-7) 

By corrupting `PreviousInValue`, the attacker can influence signature values and manipulate the mining order, potentially allowing themselves or colluding miners to mine more frequently.

3. **Secret Sharing Protocol Breach**: The `PreviousInValue` is part of the secret sharing mechanism. Corrupting these values breaks the protocol's integrity and randomness guarantees.

4. **Random Number Generation Impact**: Random hashes are generated using consensus data that depends on `PreviousInValue` values, affecting system-wide randomness.

**Affected Parties:**
- All honest miners whose `PreviousInValue` can be corrupted
- The entire network's consensus integrity
- Any systems depending on consensus randomness

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an active miner (authorized to produce blocks)
- No additional permissions required beyond normal mining rights
- Can exploit on every block they produce

**Attack Complexity:**
- LOW: Simply include fake `RevealedInValues` in the trigger information when producing a block
- Direct manipulation of block header data
- No complex timing or coordination required

**Execution Practicality:**
- Entry point is the standard block production flow through `GetConsensusExtraData`
- Fully compatible with AElf contract execution model
- No state pre-conditions needed beyond being a miner

**Detection Constraints:**
- Difficult to detect as the fake values appear as legitimate "revealed" in-values
- After-execution validation compares corrupted header against corrupted state, so they match

**Probability:**
- HIGH: Any malicious miner can execute this attack
- Can be repeated on every block produced by the attacker
- No economic disincentive (no cost to the attacker)

### Recommendation

**Code-Level Mitigation:**

In `UpdateValueValidationProvider.cs`, extend validation to check ALL miners' `PreviousInValue` in the provided round:

```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Validate ALL miners' PreviousInValue, not just sender
    foreach (var minerInfo in extraData.Round.RealTimeMinersInformation)
    {
        var publicKey = minerInfo.Key;
        
        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
            continue;
        
        var previousInValue = minerInfo.Value.PreviousInValue;
        if (previousInValue == null || previousInValue == Hash.Empty) 
            continue;
        
        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        if (HashHelper.ComputeFrom(previousInValue) != previousOutValue)
            return false;
    }
    
    return true;
}
```

**Invariant Checks to Add:**

1. For every miner's `PreviousInValue` in `extraData.Round`: If non-empty, `Hash(PreviousInValue) == PreviousRound[miner].OutValue`
2. Only allow miners to set their own `PreviousInValue`, not other miners'

**Test Cases:**

1. Test that blocks with incorrect `PreviousInValue` for non-sender miners are rejected
2. Test that multiple miners' `PreviousInValue` are all validated
3. Test that validation fails if any miner has incorrect `PreviousInValue`

### Proof of Concept

**Initial State:**
- Three miners: Alice, Bob, Charlie
- Current round N with all miners having established `OutValue` in previous round N-1
- Bob is producing the next block in round N

**Attack Steps:**

1. **Block Generation Phase**: Bob produces a block with `UpdateValue` behavior
   - Bob provides correct `PreviousInValue` for himself (to pass validation)
   - Bob provides fake `PreviousInValue` for Alice and Charlie in `RevealedInValues`
   - Example: Sets Alice's `PreviousInValue` to arbitrary Hash X, where `Hash(X) != Alice's OutValue from round N-1`

2. **Validation Phase**: Block is validated
   - `ValidatePreviousInValue()` only checks Bob's `PreviousInValue` (line 38)
   - Bob's value is correct, so validation passes
   - Alice's and Charlie's fake values are NOT checked
   - Block validation succeeds

3. **Execution Phase**: Consensus transaction executes
   - `ExtractInformationToUpdateConsensus` extracts all miners' `PreviousInValue` including fake values
   - `PerformSecretSharing` writes fake values to state (line 295-296)
   - Alice's and Charlie's `PreviousInValue` in state are now corrupted

**Expected vs Actual Result:**
- Expected: Only valid `PreviousInValue` that hash to correct `OutValue` should be written to state
- Actual: Arbitrary `PreviousInValue` for non-sender miners are written without validation

**Success Condition:**
State query after block execution shows Alice's and Charlie's `PreviousInValue` equal to the fake values Bob provided, not the correct values that hash to their previous `OutValue`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-83)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L28-29)
```csharp
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
