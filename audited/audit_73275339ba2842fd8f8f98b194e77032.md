# Audit Report

## Title
TokenConverter Deposit Balance Manipulation via EnableConnector Re-enabling Without Protection

## Summary
The `EnableConnector` function in the TokenConverter contract lacks protection against re-invocation on already-enabled connectors and uses a SET operation to overwrite `State.DepositBalance`, allowing attackers to corrupt accumulated deposit balances by donating resource tokens before calling EnableConnector, breaking the Bancor reserve ratio and causing fund locking and price manipulation.

## Finding Description

The TokenConverter contract implements asymmetric balance tracking where resource connectors use real MultiToken balances while deposit connectors use internal `State.DepositBalance` accounting. [1](#0-0) 

When connectors are added via `AddPairConnector`, deposit connectors are configured with `IsDepositAccount = true`: [2](#0-1) 

The critical vulnerability exists in `EnableConnector` which lacks protection against multiple invocations. Unlike `UpdateConnector` which explicitly checks `Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated")`, EnableConnector has no such check: [3](#0-2) 

The vulnerable `EnableConnector` function uses a SET operation (=) at line 297 to establish deposit balance: [4](#0-3) 

The `GetNeededDeposit` calculation queries the real token balance which can be artificially inflated through direct transfers: [5](#0-4) 

**Attack Sequence:**

1. Initial state: After legitimate `Buy` operations, `State.DepositBalance["(NT)CPU"]` = 1,000,000 ELF (accumulated via the ADD operation at line 141) [6](#0-5) 

2. Attacker donates 500,000 CPU tokens directly to TokenConverter contract via `MultiToken.Transfer`

3. Attacker calls `EnableConnector(TokenSymbol = "CPU", AmountToTokenConvert = 0)`

4. `GetNeededDeposit` calculates: `amountOutOfTokenConvert = TotalSupply - (originalBalance + 500,000) - 0`, resulting in a much smaller value

5. Line 297 executes: `State.DepositBalance["(NT)CPU"] = 100,000` (overwrites the 1,000,000!)

6. Lines 298-299 set `IsPurchaseEnabled = true` (no-op since already true)

The SafeMath.Sub() implementation uses checked arithmetic that will throw on underflow: [7](#0-6) 

## Impact Explanation

**High Severity** - This vulnerability causes multiple critical impacts:

1. **Fund Locking**: The 900,000 ELF difference between actual balance (1,000,000) and recorded balance (100,000) becomes permanently locked in the contract. While the ELF physically exists in the contract, `GetSelfBalance` for deposit connectors returns only `State.DepositBalance`, making the excess inaccessible.

2. **Price Manipulation**: The Bancor formula uses the corrupted `State.DepositBalance` value, causing severe price distortion. Resource tokens become artificially cheap, allowing exploitation through arbitrage.

3. **DoS on Sell Operations**: Once users sell enough tokens to exhaust the manipulated 100,000 balance, subsequent `Sell` operations will fail when `State.DepositBalance.Sub()` attempts to go below zero, triggering SafeMath underflow protection at line 193-194. [8](#0-7) 

4. **Protocol Insolvency**: The contract's accounting becomes permanently inconsistent with actual holdings, breaking fundamental invariants of the Bancor model where reserves must accurately reflect the pricing curve.

## Likelihood Explanation

**High Likelihood** - The attack is highly feasible:

- **No Authorization Required**: `EnableConnector` is a public function with no access control beyond the standard token transfer requirements
- **Simple Attack**: Only requires two transactions: (1) Transfer tokens to contract, (2) Call EnableConnector
- **Low Barrier**: Attacker needs capital for resource token donation, but economic benefit typically outweighs cost for high-value token pairs
- **No Detection**: Direct token transfers are indistinguishable from legitimate operations
- **Realistic Preconditions**: Only requires that connectors exist and have been previously enabled (common state after initialization)
- **Repeatable**: Can be executed multiple times if attacker has sufficient tokens

## Recommendation

Add re-enabling protection to `EnableConnector` similar to `UpdateConnector`:

```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
    
    // ADD THIS CHECK
    Assert(!toConnector.IsPurchaseEnabled && !fromConnector.IsPurchaseEnabled, 
        "Connector already enabled");
    
    var needDeposit = GetNeededDeposit(input);
    // ... rest of function unchanged
}
```

Alternatively, if re-enabling is intentionally allowed, change line 297 to use ADD instead of SET:

```csharp
State.DepositBalance[toConnector.Symbol] = 
    State.DepositBalance[toConnector.Symbol].Add(needDeposit.NeedAmount);
```

## Proof of Concept

```csharp
[Fact]
public async Task EnableConnector_ReenablingOverwritesDepositBalance_VulnerabilityDemo()
{
    // Setup: Initialize converter with CPU/ELF pair
    await InitializeTokenConverterContract();
    await CreateAndIssueTokenAsync("CPU", 1000000);
    
    // Enable connector initially - sets DepositBalance to X
    await TokenConverterContractStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = "CPU",
        AmountToTokenConvert = 100000
    });
    
    // Simulate legitimate Buy operations accumulating deposits
    // This ADDS to DepositBalance making it = X + 1000000
    for(int i = 0; i < 10; i++)
    {
        await BuyCPUTokens(100000); // Each buy adds to State.DepositBalance
    }
    
    var balanceBefore = await GetDepositBalance("(NT)CPU");
    Assert.True(balanceBefore > 1000000); // Accumulated balance is high
    
    // ATTACK: Donate CPU tokens to contract
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = TokenConverterContractAddress,
        Symbol = "CPU",
        Amount = 500000
    });
    
    // ATTACK: Call EnableConnector again (NO PROTECTION PREVENTS THIS)
    await TokenConverterContractStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = "CPU",
        AmountToTokenConvert = 0
    });
    
    // VERIFY: DepositBalance was OVERWRITTEN to much lower value
    var balanceAfter = await GetDepositBalance("(NT)CPU");
    Assert.True(balanceAfter < balanceBefore); // Balance was corrupted!
    
    // IMPACT: Try to sell - will eventually fail when DepositBalance exhausted
    // even though contract has plenty of actual ELF
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L96-108)
```csharp
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-159)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-212)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
        // Transfer sold token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
        Context.Fire(new TokenSold
        {
            Symbol = input.Symbol,
            SoldAmount = input.Amount,
            BaseAmount = amountToReceive,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L56-91)
```csharp
    public override DepositInfo GetNeededDeposit(ToBeConnectedTokenInfo input)
    {
        var toConnector = State.Connectors[input.TokenSymbol];
        Assert(toConnector != null && !toConnector.IsDepositAccount, "[GetNeededDeposit]Can't find to connector.");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[GetNeededDeposit]Can't find from connector.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(
            new GetTokenInfoInput
            {
                Symbol = input.TokenSymbol
            });
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }

        return new DepositInfo
        {
            NeedAmount = needDeposit,
            AmountOutOfTokenConvert = amountOutOfTokenConvert
        };
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-97)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
```
