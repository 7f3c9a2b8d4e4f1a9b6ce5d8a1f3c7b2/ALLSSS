### Title
State Corruption in Cross-Chain Data Recording Due to Asymmetric Parent/Side Chain Persistence

### Summary
The `RecordCrossChainData()` function processes parent chain and side chain data with fundamentally different persistence models. Parent chain data is persisted immediately, while side chain data is accumulated and only persisted if the accumulated list is non-empty. However, ALL proposals are marked as ACCEPTED regardless, creating a state inconsistency where side chain proposals show ACCEPTED status but their data is not recorded in `State.IndexedSideChainBlockData`.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:**

The function exhibits asymmetric data persistence:

1. **Parent Chain Processing** [2](#0-1) 
   - Calls `IndexParentChainBlockData()` which immediately modifies state variables including `State.CurrentParentChainHeight` and `State.ParentChainTransactionStatusMerkleTreeRoot` [3](#0-2) 
   - Data is persisted within the function itself

2. **Side Chain Processing** [4](#0-3) 
   - Calls `IndexSideChainBlockData()` which can return an empty list without throwing an exception (e.g., when height mismatch occurs) [5](#0-4) 
   - Return value is accumulated in a local variable `indexedSideChainBlockData`
   - Data persistence to `State.IndexedSideChainBlockData` only occurs at the end if the count is greater than zero [6](#0-5) 

3. **Unconditional Status Update:** Both parent and side chain proposals are marked as ACCEPTED immediately after processing, regardless of actual persistence outcome [7](#0-6) 

**Why Existing Protections Fail:**

While validation occurs during proposal creation [8](#0-7) , the actual indexing happens later during release. The `IndexSideChainBlockData` function can legitimately return an empty list when heights don't match expected values without throwing an exception, but the proposal is still marked ACCEPTED. The protobuf definition confirms ACCEPTED means "The proposal has been released" [9](#0-8) , implying successful data recording.

### Impact Explanation

**Cross-Chain Integrity Violation:**

1. **Inconsistent State:** Side chain proposals marked as ACCEPTED have no corresponding entry in `State.IndexedSideChainBlockData`, violating the invariant that ACCEPTED status indicates successful data persistence.

2. **Failed Cross-Chain Verification:** The `GetIndexedSideChainBlockDataByHeight` view function queries `State.IndexedSideChainBlockData` [10](#0-9) . When queried for a height where side chain proposals were ACCEPTED but data not persisted, it returns empty data, breaking cross-chain verification.

3. **Merkle Root Calculation Failure:** The `GetSideChainMerkleTreeRoot` function relies on `State.IndexedSideChainBlockData` [11](#0-10) . Missing data causes incorrect merkle roots, breaking cross-chain transaction verification [12](#0-11) .

4. **Proposal System Corruption:** Once marked ACCEPTED, proposals are cleared by `AcceptCrossChainIndexingProposal` [13](#0-12) , preventing re-proposal of the missing data without creating a new proposal with potentially different block data.

**Affected Parties:** All users relying on cross-chain transaction verification between parent chain and side chains, potentially leading to failed cross-chain asset transfers or message passing.

### Likelihood Explanation

**Attack Vector:** The vulnerability is triggered through the normal operation flow via `ReleaseCrossChainIndexingProposal` [14](#0-13) .

**Preconditions:**
1. Multiple chain IDs (parent + side chain(s)) passed to `RecordCrossChainData` in a single call
2. Parent chain indexing succeeds
3. Side chain's `IndexSideChainBlockData` returns empty list (height mismatch scenario or empty input)
4. No exception thrown during processing

**Feasibility:** 
- **Moderate-High Likelihood:** The height mismatch condition can occur naturally if proposed block heights don't align with current state expectations
- **Miner-Triggered:** Only miners can call `ReleaseCrossChainIndexingProposal` [15](#0-14) , but this is part of normal cross-chain operation, not requiring malicious intent
- **Detection:** The inconsistency is subtle - proposals show ACCEPTED but queries return empty data

### Recommendation

**Code-Level Mitigation:**

1. **Synchronize Persistence Model:** Modify `RecordCrossChainData` to either persist all chain data immediately or accumulate all (including parent) and persist atomically:

```
// Option 1: Accumulate all data first, then persist atomically
private void RecordCrossChainData(IEnumerable<int> chainIdList)
{
    var indexedParentChainData = new List<IndexedParentChainBlockData>();
    var indexedSideChainBlockData = new IndexedSideChainBlockData();
    
    foreach (var chainId in chainIdList)
    {
        var pendingProposalExists = TryGetIndexingProposalWithStatus(chainId,
            CrossChainIndexingProposalStatus.Pending,
            out var pendingCrossChainIndexingProposal);
        Assert(pendingProposalExists, "Chain indexing not proposed.");

        if (chainId == State.ParentChainId.Value)
            indexedParentChainData.Add(IndexParentChainBlockData(...));
        else
            indexedSideChainBlockData.SideChainBlockDataList.Add(IndexSideChainBlockData(...));
        
        // Only mark as Accepted if data was actually indexed
        bool hasData = chainId == State.ParentChainId.Value 
            ? indexedParentChainData.Any() 
            : indexedSideChainBlockData.SideChainBlockDataList.Any();
        
        Assert(hasData, "No data indexed for proposed chain");
        SetCrossChainIndexingProposalStatus(pendingCrossChainIndexingProposal,
            CrossChainIndexingProposalStatus.Accepted);
    }
    
    // Persist side chain data if exists
    if (indexedSideChainBlockData.SideChainBlockDataList.Count > 0)
    {
        State.IndexedSideChainBlockData.Set(Context.CurrentHeight, indexedSideChainBlockData);
        Context.Fire(new SideChainBlockDataIndexed());
    }
}
```

2. **Add Assertion:** Before marking proposal as ACCEPTED, verify that data was actually persisted or will be persisted.

3. **Validation Check:** Add an assertion after the loop to ensure that if any proposals were marked ACCEPTED, corresponding data exists in the persistence layer.

**Test Cases:**
1. Test processing parent chain with empty side chain data - should fail
2. Test processing multiple side chains where some return empty - should fail for empty ones
3. Test processing with all valid data - should succeed and all persist
4. Verify `GetIndexedSideChainBlockDataByHeight` returns correct data for all ACCEPTED proposals

### Proof of Concept

**Initial State:**
- Parent chain proposal PENDING with valid block data at heights [100, 101]
- Side chain A proposal PENDING with valid block data at heights [50, 51]
- Side chain B proposal PENDING with block data at heights [70, 71] but `State.CurrentSideChainHeight[chainB] = 80` (height mismatch)

**Transaction Steps:**
1. Miner calls `ReleaseCrossChainIndexingProposal([parentChainId, sideChainA_Id, sideChainB_Id])`
2. `ReleaseIndexingProposal()` releases governance proposals
3. `RecordCrossChainData()` processes chains:
   - Parent chain: `IndexParentChainBlockData()` succeeds, state persisted, proposal → ACCEPTED
   - Side chain A: `IndexSideChainBlockData()` returns 2 blocks, added to accumulator, proposal → ACCEPTED
   - Side chain B: `IndexSideChainBlockData()` height mismatch at line 838-839, returns empty list, proposal → ACCEPTED
4. Line 331: count = 2 (from side chain A), so persistence executes
5. `State.IndexedSideChainBlockData[currentHeight]` contains only side chain A's 2 blocks

**Actual Result:**
- Parent chain proposal: ACCEPTED, data in `State.ParentChainTransactionStatusMerkleTreeRoot`
- Side chain A proposal: ACCEPTED, data in `State.IndexedSideChainBlockData[currentHeight]`
- Side chain B proposal: **ACCEPTED**, but NO data in `State.IndexedSideChainBlockData[currentHeight]`
- Query `GetIndexedSideChainBlockDataByHeight(currentHeight)` returns only side chain A's blocks, missing side chain B

**Expected Result:**
Either all proposals ACCEPTED with all data persisted, OR side chain B proposal should remain PENDING/fail with assertion

**Success Condition:** 
Side chain B shows ACCEPTED status but querying indexed data returns no record of its blocks, confirming state corruption.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L241-246)
```csharp
    private Hash GetSideChainMerkleTreeRoot(long parentChainHeight)
    {
        var indexedSideChainData = State.IndexedSideChainBlockData[parentChainHeight];
        return ComputeRootWithMultiHash(
            indexedSideChainData.SideChainBlockDataList.Select(d => d.TransactionStatusMerkleTreeRoot));
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L309-336)
```csharp
    private void RecordCrossChainData(IEnumerable<int> chainIdList)
    {
        var indexedSideChainBlockData = new IndexedSideChainBlockData();
        foreach (var chainId in chainIdList)
        {
            var pendingProposalExists = TryGetIndexingProposalWithStatus(chainId,
                CrossChainIndexingProposalStatus.Pending,
                out var pendingCrossChainIndexingProposal);
            Assert(pendingProposalExists, "Chain indexing not proposed.");

            if (chainId == State.ParentChainId.Value)
                IndexParentChainBlockData(pendingCrossChainIndexingProposal.ProposedCrossChainBlockData
                    .ParentChainBlockDataList);
            else
                indexedSideChainBlockData.SideChainBlockDataList.Add(IndexSideChainBlockData(
                    pendingCrossChainIndexingProposal.ProposedCrossChainBlockData.SideChainBlockDataList,
                    pendingCrossChainIndexingProposal.Proposer, chainId));

            SetCrossChainIndexingProposalStatus(pendingCrossChainIndexingProposal,
                CrossChainIndexingProposalStatus.Accepted);
        }

        if (indexedSideChainBlockData.SideChainBlockDataList.Count > 0)
        {
            State.IndexedSideChainBlockData.Set(Context.CurrentHeight, indexedSideChainBlockData);
            Context.Fire(new SideChainBlockDataIndexed());
        }
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L690-718)
```csharp
    private bool ValidateSideChainBlockData(IEnumerable<SideChainBlockData> sideChainBlockData,
        out Dictionary<int, List<SideChainBlockData>> validatedSideChainBlockData)
    {
        var groupResult = sideChainBlockData.GroupBy(data => data.ChainId, data => data);

        validatedSideChainBlockData = new Dictionary<int, List<SideChainBlockData>>();
        foreach (var group in groupResult)
        {
            var chainId = group.Key;
            validatedSideChainBlockData[chainId] = group.ToList();
            var info = State.SideChainInfo[chainId];
            if (info == null || info.SideChainStatus == SideChainStatus.Terminated)
                return false;
            var currentSideChainHeight = State.CurrentSideChainHeight[chainId];
            var target = currentSideChainHeight != 0
                ? currentSideChainHeight + 1
                : AElfConstants.GenesisBlockHeight;

            foreach (var blockData in group)
            {
                var sideChainHeight = blockData.Height;
                if (target != sideChainHeight)
                    return false;
                target++;
            }
        }

        return true;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L761-806)
```csharp
    private IndexedParentChainBlockData IndexParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        var indexedParentChainBlockData = new IndexedParentChainBlockData
        {
            LocalChainHeight = Context.CurrentHeight
        };
        for (var i = 0; i < parentChainBlockData.Count; i++)
        {
            var blockInfo = parentChainBlockData[i];
            AssertParentChainBlock(parentChainId, currentHeight, blockInfo);
            var parentChainHeight = blockInfo.Height;
            State.ParentChainTransactionStatusMerkleTreeRoot[parentChainHeight] =
                blockInfo.TransactionStatusMerkleTreeRoot;
            foreach (var indexedBlockInfo in blockInfo.IndexedMerklePath)
            {
                BindParentChainHeight(indexedBlockInfo.Key, parentChainHeight);
                AddIndexedTxRootMerklePathInParentChain(indexedBlockInfo.Key, indexedBlockInfo.Value);
            }

            // send consensus data shared from main chain  
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }

            if (blockInfo.CrossChainExtraData != null)
                State.TransactionMerkleTreeRootRecordedInParentChain[parentChainHeight] =
                    blockInfo.CrossChainExtraData.TransactionStatusMerkleTreeRoot;

            indexedParentChainBlockData.ParentChainBlockDataList.Add(blockInfo);
            currentHeight += 1;
        }

        State.CurrentParentChainHeight.Value = currentHeight;
        
        Context.Fire(new ParentChainIndexed
        {
            ChainId = parentChainId,
            IndexedHeight = currentHeight
        });

        return indexedParentChainBlockData;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L838-839)
```csharp
                if (target != sideChainHeight)
                    break;
```

**File:** protobuf/cross_chain_contract.proto (L181-187)
```text
enum CrossChainIndexingProposalStatus{
    NON_PROPOSED = 0;
    // The proposal is pending.
    PENDING = 1;
    // The proposal has been released.
    ACCEPTED = 2;
}
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L13-17)
```csharp
    public override IndexedSideChainBlockData GetIndexedSideChainBlockDataByHeight(Int64Value input)
    {
        var indexedSideChainBlockData = State.IndexedSideChainBlockData[input.Value];
        return indexedSideChainBlockData ?? new IndexedSideChainBlockData();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L37-46)
```csharp
    public override BoolValue VerifyTransaction(VerifyTransactionInput input)
    {
        var parentChainHeight = input.ParentChainHeight;
        var merkleTreeRoot = GetMerkleTreeRoot(input.VerifiedChainId, parentChainHeight);
        Assert(merkleTreeRoot != null,
            $"Parent chain block at height {parentChainHeight} is not recorded.");
        var rootCalculated = ComputeRootWithTransactionStatusMerklePath(input.TransactionId, input.Path);

        return new BoolValue { Value = merkleTreeRoot == rootCalculated };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L304-310)
```csharp
    public override Empty AcceptCrossChainIndexingProposal(AcceptCrossChainIndexingProposalInput input)
    {
        AssertCrossChainIndexingControllerAuthority(Context.Sender);
        AssertIsCrossChainBlockDataAccepted(input.ChainId);
        ResetChainIndexingProposal(input.ChainId);
        return new Empty();
    }
```
