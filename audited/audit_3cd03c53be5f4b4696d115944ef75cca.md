### Title
Method Fee Controller Can Be Permanently Hijacked via Malicious Contract Bypass

### Summary
The `ChangeMethodFeeController()` function validates organization existence by calling `ValidateOrganizationExist` on the provided `input.ContractAddress` without verifying that the contract is a legitimate governance contract (Parliament, Association, or Referendum). A malicious contract that always returns `true` can bypass this validation, allowing an attacker to permanently seize control of method fee configuration without further governance approval.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController()` implementation across all ACS1-compliant contracts. [1](#0-0) 

The `CheckOrganizationExist()` function performs organization validation by making a cross-contract call to the user-provided `ContractAddress`: [2](#0-1) 

**Root Cause**: The validation assumes `ContractAddress` points to a legitimate governance contract (Parliament, Association, or Referendum), but there is no whitelist or verification mechanism. Any contract can be provided, and if it implements `ValidateOrganizationExist` to return `true`, it will pass validation.

**Why Existing Protections Fail**:
1. The authorization check only verifies the sender matches the current controller's `OwnerAddress` [3](#0-2) 
2. Organization validation delegates entirely to the provided contract with no additional checks [4](#0-3) 
3. No whitelist of approved governance contract addresses exists

**Critical Discrepancy**: After the controller is changed, `SetMethodFee()` only checks `OwnerAddress`, completely ignoring `ContractAddress`: [5](#0-4) 

This means an attacker who sets `OwnerAddress` to their own address can directly call `SetMethodFee()` without any governance involvement.

**Legitimate governance contracts** properly implement `ValidateOrganizationExist` to check registered organizations: [6](#0-5) 

### Impact Explanation

**Governance Bypass**: Once the controller is hijacked, the attacker can permanently modify method fees for all consensus contract operations without any governance approval, violating the critical authorization invariant.

**Concrete Harm**:
- **DoS Attack**: Set prohibitively high fees (e.g., 1,000,000 ELF) for critical consensus methods like `NextRound` or `UpdateValue`, effectively halting blockchain operation
- **Economic Manipulation**: Set fees to zero for attacker-controlled operations while maintaining high fees for others
- **Permanent Control**: Unlike typical governance attacks requiring repeated approvals, this grants irreversible control until a chain upgrade

**Affected Scope**: This vulnerability affects all ACS1-compliant contracts across the AElf ecosystem: [7](#0-6) [8](#0-7) [9](#0-8) 

### Likelihood Explanation

**Preconditions**:
1. Attacker must get a single malicious proposal approved by the current governance organization
2. Deploy a malicious contract with `ValidateOrganizationExist` method that always returns `true`

**Attack Complexity**: MEDIUM
- Requires initial governance influence, but this is a privilege escalation attack
- The malicious contract can be disguised as a legitimate organizational upgrade/migration
- Governance participants may approve without thorough contract code review

**Feasibility Scenarios**:
1. **Social Engineering**: Proposing what appears to be a routine governance contract upgrade
2. **Governance Oversight**: Malicious contract disguised with legitimate-looking organization validation logic
3. **Insider Threat**: Proposer with limited governance power leveraging this to gain permanent control

**Key Distinction**: This is NOT simple governance abuse. An attacker who can pass one proposal gains permanent unilateral control, escalating from "requires repeated governance approval" to "complete governance bypass."

**Detection**: The malicious contract deployment and proposal would be visible on-chain, but may not trigger alarms if disguised as organizational maintenance.

### Recommendation

**Immediate Fix**: Implement a whitelist of approved governance contract addresses:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a known governance contract
    var validContracts = new List<Address>
    {
        State.ParliamentContract.Value,
        State.AssociationContract.Value,
        State.ReferendumContract.Value
    };
    
    Assert(validContracts.Any(c => c == authorityInfo.ContractAddress), 
        "ContractAddress must be a registered governance contract.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Invariant Check**: Add explicit verification that `ContractAddress` belongs to Parliament, Association, or Referendum contracts before accepting the controller change.

**Test Cases**:
1. Verify `ChangeMethodFeeController` rejects unknown contract addresses
2. Verify `ChangeMethodFeeController` accepts only whitelisted governance contracts
3. Test that malicious contract returning `true` is properly rejected

### Proof of Concept

**Initial State**:
- Current MethodFeeController: Parliament default organization (requires 2/3 miner approval)
- Attacker: Has influence to get one proposal approved

**Attack Steps**:

1. **Deploy Malicious Contract**:
```csharp
public override BoolValue ValidateOrganizationExist(Address input)
{
    return new BoolValue { Value = true }; // Always returns true
}
```

2. **Create Proposal**: Submit proposal to current governance calling `ChangeMethodFeeController` with:
   - `input.ContractAddress` = MaliciousContract address
   - `input.OwnerAddress` = Attacker's address

3. **Execute Approved Proposal**: When governance approves and releases the proposal:
   - `Context.Sender` = Current organization address ✓ (passes line 28)
   - `CheckOrganizationExist` calls `MaliciousContract.ValidateOrganizationExist(AttackerAddress)` ✓ (returns true)
   - Validation passes ✓ (line 30)
   - Controller updated to attacker's control ✓ (line 32)

4. **Post-Attack**: Attacker directly calls `SetMethodFee` for any method:
   - Check: `Context.Sender == State.MethodFeeController.Value.OwnerAddress` ✓ (attacker's address)
   - No further governance approval required ✓

**Expected Result**: Governance should reject non-whitelisted contract addresses

**Actual Result**: Malicious contract passes validation, granting permanent fee control to attacker

**Success Condition**: After step 3, `GetMethodFeeController()` returns `AuthorityInfo` with attacker's address as `OwnerAddress` and malicious contract as `ContractAddress`, enabling unlimited `SetMethodFee` calls without governance.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L19-19)
```csharp
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L25-34)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L83-88)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```
