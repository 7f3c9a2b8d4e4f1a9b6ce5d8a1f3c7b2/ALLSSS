### Title
Retroactive Proposal Invalidation via Member Removal in Association Contract

### Summary
The Association contract's vote counting mechanism has a time-of-check/time-of-use vulnerability where member approvals are validated at vote time but recounted at release time based on current membership. If members who approved a proposal are later removed from the organization, their votes are retroactively invalidated, potentially preventing legitimately approved proposals from being executed.

### Finding Description

The vulnerability exists in the interaction between three critical functions in the Association contract:

**1. Vote-time validation**: When members approve a proposal, the contract validates that the sender is a current organization member [1](#0-0) , and adds them to the approval list [2](#0-1) .

**2. Release-time revalidation**: When releasing a proposal, the contract recounts approvals by filtering only those from current members using `Contains()` [3](#0-2) . The `Contains()` method checks membership against the current state [4](#0-3) .

**3. Member removal**: The organization can remove members at any time [5](#0-4) . The validation only ensures thresholds remain theoretically achievable with the new member count [6](#0-5) , but does not check whether existing proposals would lose their valid approvals.

**Root cause**: The contract stores approval addresses permanently but evaluates them dynamically against the current membership list. This creates a temporal inconsistency where a valid approval at time T1 can become invalid at time T2 due to membership changes, even though the approval itself was legitimately obtained.

### Impact Explanation

**Direct Governance Impact**: 
- Proposals that legitimately reached the required approval threshold can be prevented from execution
- Organizations can retroactively manipulate the outcome of proposals by strategically removing members who voted in favor
- This violates the fundamental governance invariant that validly approved proposals should be executable

**Affected Parties**:
- Honest organization members whose votes can be nullified after the fact
- Proposers who obtained legitimate approval but cannot execute their proposals
- The entire governance system's integrity and trustworthiness

**Severity Justification**: This is a **Critical** vulnerability because it allows manipulation of already-approved governance decisions, undermining the entire purpose of the multi-signature governance mechanism. It enables a majority to censor proposals retroactively even after they were legitimately approved according to the rules at the time of voting.

### Likelihood Explanation

**Attacker Capabilities**: The organization itself (through its virtual address) can call `RemoveMember` [5](#0-4) . This means a controlling faction can pass a proposal to remove members.

**Attack Complexity**: Low - the attack requires only:
1. Wait for a proposal to reach approval threshold
2. Create and approve a proposal to remove members who voted for the target proposal
3. Execute the member removal
4. The original proposal can no longer be released

**Feasibility Conditions**: 
- Standard organization operations with no special privileges required
- No economic cost beyond normal transaction fees
- Can occur in the normal course of organization management

**Detection Constraints**: Difficult to distinguish from legitimate member management. The attack appears as normal organizational restructuring.

**Probability**: High - this can occur inadvertently during normal member management or deliberately for governance manipulation. The vulnerability is inherent in the design pattern used.

### Recommendation

**Immediate Fix**: Implement snapshot-based voting that records the organization membership state at proposal creation time:

1. Store the organization member list hash or snapshot when a proposal is created
2. During release, validate approvals against the membership at proposal creation time, not current membership
3. Alternatively, record whether each approval was valid at the time it was cast, rather than re-evaluating membership

**Specific Code Changes**:
- Modify `ProposalInfo` to store either the member list snapshot or a mapping of valid approvers at creation time
- Update `CheckEnoughVoteAndApprovals` to validate against the historical membership state
- Ensure `RemoveMember` cannot affect already-cast votes on existing proposals

**Invariant to Enforce**: "Once a valid approval is recorded on a proposal, it must remain valid regardless of subsequent membership changes, unless the proposal expires."

**Test Cases**:
1. Create proposal with 10 members, threshold 5
2. Obtain 5 valid approvals
3. Remove 2 members who approved
4. Verify proposal can still be released (should pass with fix, currently fails)

### Proof of Concept

**Initial State**:
- Organization has 10 members: M1, M2, M3, ..., M10
- ProposalReleaseThreshold.MinimalApprovalThreshold = 5
- ProposalReleaseThreshold.MinimalVoteThreshold = 5

**Attack Sequence**:

1. **Proposal Creation**: Proposer creates Proposal_A
   - State: Proposal_A created with 0 approvals

2. **Valid Approvals**: Members M1, M2, M3, M4, M5 each call `Approve(Proposal_A)`
   - Each approval checked: `AssertIsAuthorizedOrganizationMember(organization, Context.Sender)` passes
   - State: Proposal_A has 5 approvals, meets threshold

3. **Member Removal**: Organization executes `RemoveMember(M1)` and `RemoveMember(M2)`
   - Validation passes: remaining 8 members still allow threshold of 5
   - State: Organization now has 8 members (M3-M10)

4. **Attempted Release**: Proposer calls `Release(Proposal_A)`
   - `CheckEnoughVoteAndApprovals` executes: `approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains)`
   - M1 and M2 approvals filtered out (not in current member list)
   - Counted approvals: 3 (only M3, M4, M5)
   - Check fails: 3 < 5 (threshold)
   - Transaction reverts: "Not approved."

**Expected Result**: Proposal_A should be releasable (it had 5 valid approvals)

**Actual Result**: Proposal_A cannot be released (only 3 approvals counted)

**Success Condition**: The proposal that was validly approved with 5 votes is now blocked from execution, demonstrating the retroactive invalidation vulnerability.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```
