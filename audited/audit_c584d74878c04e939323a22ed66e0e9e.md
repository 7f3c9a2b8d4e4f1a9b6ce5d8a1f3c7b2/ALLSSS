# Audit Report

## Title
Consensus Denial of Service via Malicious FinalOrderOfNextRound Values Due to Incorrect Distinct Validation

## Summary
The `NextRoundMiningOrderValidationProvider` contains a critical validation bug where it calls `.Distinct()` on `MinerInRound` objects instead of their `FinalOrderOfNextRound` values. This allows a malicious validator to inject duplicate `FinalOrderOfNextRound` values that pass validation but cause permanent consensus halt when the subsequent round attempts to use these corrupted mining order values.

## Finding Description

**Root Cause:**

The validation incorrectly applies `.Distinct()` to a collection of `MinerInRound` objects rather than to their `FinalOrderOfNextRound` values: [1](#0-0) 

Since `MinerInRound` is a protobuf-generated class where each miner instance is a distinct object by reference, the distinct count will always equal the number of miner objects regardless of whether their `FinalOrderOfNextRound` values contain duplicates. The validation should instead check: `providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0).Select(m => m.FinalOrderOfNextRound).Distinct().Count()`.

**Exploitation Path:**

1. **Attack Trigger:** During a round transition, a malicious validator crafts a `NextRoundInput` where `Order` and `ExpectedMiningTime` are correctly set for the current round, but `FinalOrderOfNextRound` values contain duplicates (e.g., all set to 1).

2. **Validation Bypass:** The validation passes because it's added to the validation pipeline for NextRound behavior: [2](#0-1) 

The time slot validation only checks the current round's `Order` field, not the malicious `FinalOrderOfNextRound`: [3](#0-2) 

The round termination validator only checks that `InValue` is null, allowing malicious `FinalOrderOfNextRound` values through: [4](#0-3) 

3. **State Corruption:** The malicious round data is stored via the `NextRound` method which calls `ProcessConsensusInformation`: [5](#0-4) 

Which eventually stores the round via `AddRoundInformation`: [6](#0-5) 

4. **Consensus Corruption:** When generating the subsequent round, the system uses these duplicate `FinalOrderOfNextRound` values: [7](#0-6) 

Multiple miners receive identical `Order` values and consequently identical `ExpectedMiningTime` values.

5. **Consensus Halt:** Any attempt to validate the corrupted subsequent round fails because the time slot check calculates a zero mining interval: [8](#0-7) 

When miners at indices 0 and 1 have identical `ExpectedMiningTime` due to duplicate orders, `baseMiningInterval` becomes 0, causing the validation to fail with "Mining interval must greater than 0."

## Impact Explanation

**Severity: HIGH**

This vulnerability enables a single malicious validator to permanently halt the entire blockchain consensus mechanism:

- **Complete Consensus Halt:** No new blocks can be produced after the corrupted round completes execution
- **Network-Wide Impact:** All validators are unable to progress to the next round due to systematic validation failures
- **No Automatic Recovery:** The system has no built-in mechanism to recover from this state; manual intervention or chain rollback would be required
- **Operational Paralysis:** All on-chain operations cease, affecting all network participants

The vulnerability violates the critical consensus invariant: "Correct round transitions and time-slot validation, miner schedule integrity."

## Likelihood Explanation

**Probability: HIGH**

The attack is highly feasible:

- **Low Attacker Requirements:** Only requires being an active validator in the current round (a realistic precondition)
- **Low Complexity:** Single `NextRound` transaction with crafted `FinalOrderOfNextRound` values
- **No Special Privileges:** Uses standard validator capabilities; no elevated permissions needed beyond validator set membership
- **Natural Execution Opportunity:** Occurs during the normal rotation when it's the attacker's turn to propose round transition
- **Low Cost:** Only transaction fees required; no economic barriers
- **Delayed Detection:** Malicious values appear valid during the current round; attack only manifests when generating the next round

## Recommendation

Fix the validation to check uniqueness of `FinalOrderOfNextRound` values, not object instances:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Add this line
    .Distinct()
    .Count();
```

This ensures the validation checks for duplicate order VALUES rather than distinct object instances.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousDuplicateFinalOrderOfNextRound_CausesConsensusHalt()
{
    // Setup: Initialize consensus with 3 miners
    var miners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusWithMiners(miners);
    
    // Round N: Normal mining
    await ProducerBlocksForCurrentRound();
    
    // Attack: Malicious miner creates NextRoundInput with duplicate FinalOrderOfNextRound
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = 2,
        RealTimeMinersInformation = 
        {
            ["miner1"] = new MinerInRound 
            { 
                Pubkey = "miner1", 
                Order = 1, 
                ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow),
                OutValue = Hash.FromString("out1"),
                FinalOrderOfNextRound = 1  // Malicious duplicate
            },
            ["miner2"] = new MinerInRound 
            { 
                Pubkey = "miner2", 
                Order = 2, 
                ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow.AddSeconds(4)),
                OutValue = Hash.FromString("out2"),
                FinalOrderOfNextRound = 1  // Malicious duplicate
            },
            ["miner3"] = new MinerInRound 
            { 
                Pubkey = "miner3", 
                Order = 3, 
                ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow.AddSeconds(8)),
                OutValue = Hash.FromString("out3"),
                FinalOrderOfNextRound = 1  // Malicious duplicate
            }
        }
    };
    
    // Round N+1: Malicious NextRound transaction SUCCEEDS (bypasses validation)
    var result = await AEDPoSContract.NextRound.SendAsync(maliciousNextRound);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Round N+1: Mining proceeds normally with correct Order values
    await ProduceBlocksForCurrentRound();
    
    // Round N+2: Attempt to generate next round using corrupted FinalOrderOfNextRound
    var nextRoundResult = await AEDPoSContract.GetConsensusCommand.CallAsync(new BytesValue());
    
    // Verify: Round N+2 generation FAILS due to duplicate orders
    // CheckRoundTimeSlots validation should fail with baseMiningInterval = 0
    var validationResult = ValidateRoundTimeSlots(nextRoundResult);
    validationResult.Success.ShouldBeFalse();
    validationResult.Message.ShouldContain("Mining interval must greater than 0");
    
    // Consensus is now permanently halted - no validator can produce Round N+2
}
```

## Notes

This vulnerability exists in all AElf chains using the AEDPoS consensus mechanism. The fix is straightforward but critical: the validation must operate on the `FinalOrderOfNextRound` values themselves, not on the `MinerInRound` object instances. The attack is particularly dangerous because the malicious data passes all current validations and only manifests as a problem in the subsequent round, making it difficult to identify the malicious actor after the fact.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L32-34)
```csharp
        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-47)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```
