# Audit Report

## Title
Two-Miner Consensus Deadlock: Malicious Miner Can Permanently Block Term Transitions

## Summary
In a two-miner network, a single malicious miner can permanently block term transitions by refusing to mine, creating an unrecoverable deadlock. The consensus requires both miners to have mined blocks before allowing term transition, but a non-mining attacker prevents this threshold from ever being met, permanently freezing the miner list and halting treasury distributions.

## Finding Description

The vulnerability exists in the term transition mechanism of the AEDPoS consensus contract. The system determines whether to transition to a new term based on the `NeedToChangeTerm` method, which implements a two-thirds consensus requirement. [1](#0-0) 

For a two-miner network, the calculation `RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1)` results in: 2 × 2 / 3 + 1 = 1 + 1 = 2 (using integer division), requiring both miners to agree. [2](#0-1) 

The `NeedToChangeTerm` method filters miners by `ActualMiningTimes.Any()`, meaning only miners who have actively mined blocks are counted. If the malicious miner refuses to mine, only the honest miner has `ActualMiningTimes` with timestamps in the new period, resulting in a count of 1, which is less than `MinersCountOfConsent` (2). [3](#0-2) 

When `NeedToChangeTerm` returns false, the system returns `NextRound` instead of `NextTerm`, continuing rounds indefinitely. Note there is a special case for single-node networks (line 33), but NOT for two-miner networks. [4](#0-3) 

After 4320 missed time slots (3 days), the evil miner is detected: [5](#0-4) 

However, marking as evil only updates the Election contract state: [6](#0-5) 

It does NOT remove the miner from the current consensus miner list. The active miner list is only updated during term transitions: [7](#0-6) 

This creates an unbreakable circular dependency:
- Removing the evil miner requires term transition
- Term transition requires `NextTerm` behavior  
- `NextTerm` requires `NeedToChangeTerm` to return true
- `NeedToChangeTerm` requires both miners to mine
- But the malicious miner refuses → deadlock

Even governance cannot break this: [8](#0-7) 

The `RemoveEvilNode` method only updates the Election contract and cannot force a term transition.

## Impact Explanation

This vulnerability causes **critical protocol-level failure**:

1. **Term Transitions Permanently Blocked**: The system cannot transition to new terms, freezing at the current term indefinitely

2. **Miner List Frozen**: Election results cannot be applied, preventing legitimate miners from joining and illegitimate miners from being removed from consensus

3. **Treasury Distribution Halted**: Mining rewards and profit distributions occur during term transitions. Without term transitions, treasury distributions never execute: [9](#0-8) 

4. **Governance Paralysis**: The protocol cannot adapt to changing conditions or recover without external intervention (hard fork)

**Affected parties**: Honest miners cannot join, token holders receive no distributions, the entire blockchain becomes controlled by the malicious miner, and all governance mechanisms become ineffective.

## Likelihood Explanation

**High likelihood** in two-miner scenarios:

1. **Low Attack Threshold**: Requires only 50% miner control (1 of 2 miners)

2. **Trivial Execution**: Attacker simply stops mining when period boundary approaches—no complex transaction sequencing required

3. **Realistic Scenario**: Two-miner networks exist for early-stage sidechains, test networks, small private chains, and networks during bootstrap phase

4. **Economic Rationality**: Malicious miner maintains their position and rewards indefinitely while preventing competitors from joining via elections, with zero transaction costs

5. **Detection Difficulty**: Attack initially appears as normal network issues. By the time the deadlock is recognized (after 3+ days), recovery requires a hard fork

The attack is passive, undetectable initially, and provides complete control over the network with no cost to execute.

## Recommendation

Implement one or more of the following fixes:

1. **Special Case for Two Miners**: Add explicit handling similar to the single-node case. Modify `GetConsensusBehaviourToTerminateCurrentRound` to force `NextTerm` when only one miner has been actively mining for extended periods in a two-miner network.

2. **Governance Override**: Allow emergency response organization to force term transitions via a new method that bypasses `NeedToChangeTerm` consensus requirements.

3. **Timeout Mechanism**: Implement a timeout that automatically triggers term transition if rounds continue without term change beyond a threshold (e.g., 2x expected term duration).

4. **Dynamic Threshold**: Adjust `MinersCountOfConsent` calculation to use only actively mining miners as the denominator, so the threshold adapts to actual network participation.

Example fix for option 1:

```csharp
protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
{
    // For two-miner networks, check if only one miner is active
    if (CurrentRound.RealTimeMinersInformation.Keys.Count == 2)
    {
        var activeMiners = CurrentRound.RealTimeMinersInformation.Values
            .Where(m => m.ActualMiningTimes.Any()).Count();
        if (activeMiners == 1 && /* check extended period condition */)
            return AElfConsensusBehaviour.NextTerm;
    }
    
    return CurrentRound.RoundNumber == 1 ||
           !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
               CurrentRound.TermNumber, _periodSeconds) ||
           CurrentRound.RealTimeMinersInformation.Keys.Count == 1
        ? AElfConsensusBehaviour.NextRound
        : AElfConsensusBehaviour.NextTerm;
}
```

## Proof of Concept

A comprehensive test would require:
1. Set up a two-miner test network
2. Mine blocks normally until approaching period boundary
3. Have one miner stop producing blocks
4. Verify honest miner continues but term transition never occurs
5. Confirm after 4320+ missed slots, evil miner is marked but remains in consensus miner list
6. Demonstrate treasury distributions are not executed
7. Verify no governance method can force term transition

The vulnerability is confirmed through static code analysis showing the mathematical impossibility of meeting the `MinersCountOfConsent` threshold when one miner refuses to participate in a two-miner network, combined with the lack of any fallback or override mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-351)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
    }
```
