# Audit Report

## Title
Governance DoS via Overly Restrictive Referendum Thresholds in Three-Tier UserFeeController

## Summary
The three-tier UserFeeController architecture contains a critical governance DoS vulnerability where any token holder with as little as 1 token can permanently block all user fee governance operations. The referendum organization is initialized with `MaximalRejectionThreshold = 0`, allowing any single rejection to prevent proposal execution. Since the Association root controller requires approval from both Parliament AND Referendum organization addresses, blocking the referendum creates an inescapable governance deadlock.

## Finding Description

The vulnerability originates from the initialization of the referendum organization in `GetReferendumControllerCreateInputForUserFee`: [1](#0-0) 

These thresholds create a critical flaw: `MaximalRejectionThreshold = 0` means any rejection count greater than zero blocks the proposal.

The referendum's release logic strictly enforces this constraint: [2](#0-1) 

When Parliament attempts user fee governance, the flow requires:
1. Parliament creates an Association proposal to call `UpdateCoefficientsForSender`
2. Both Parliament AND Referendum organization addresses must approve the Association proposal
3. Referendum approves by having Parliament create a referendum proposal that, when released, calls `Association.Approve` on behalf of the referendum address
4. Token holders vote on this referendum proposal

**The Attack:** An attacker approves 1 token to the referendum proposal's virtual address and calls `Referendum.Reject`. This increments `RejectionCount` to 1, which exceeds `MaximalRejectionThreshold` (0), permanently blocking the proposal's release.

**Why Association Blocks:** The Association requires both members to approve: [3](#0-2) 

The Association's approval logic requires: [4](#0-3) 

With `MinimalApprovalThreshold = 2` (both parliament and referendum), if the referendum address never approves (due to blocked proposal), only parliament's approval results in `approvedMemberCount = 1 < 2`, failing the threshold check.

**Impact on User Fee Operations:** The `UpdateCoefficientsForSender` method requires authorization from the RootController: [5](#0-4) [6](#0-5) 

Without Association approval, the authorization check fails permanently.

**No Escape Mechanism:** The `ChangeUserFeeController` method, which could theoretically replace the stuck controller, requires authorization from the SAME stuck RootController: [7](#0-6) 

This creates a catch-22: you need the blocked controller to approve changing itself, which is impossible.

## Impact Explanation

**Severity: HIGH**

This vulnerability enables complete denial of service for critical governance functions:

1. **Complete Governance Paralysis**: All user fee coefficient updates via `UpdateCoefficientsForSender` become permanently inaccessible
2. **Economic Stagnation**: Transaction fee calculation parameters cannot be adjusted to respond to network conditions, token price changes, or congestion
3. **No Recovery Path**: The `ChangeUserFeeController` escape mechanism is blocked by the same authority requirement, creating permanent deadlock
4. **Protocol-Wide Impact**: Affects all users' transaction costs and the protocol's ability to maintain economic balance

The impact is permanent because:
- Proposal expiry doesn't help (attacker can reject new proposals)
- Parliament cannot bypass referendum (Association requires both)
- No administrative override exists in the code
- The controller cannot change itself without passing through the blocked governance path

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly probable due to:

**Low Attacker Requirements:**
- Needs only â‰¥1 token of the primary token symbol (readily available on any exchange)
- No special privileges or access required
- Any token holder can execute this attack

**Simple Attack Execution:**
1. Monitor for referendum proposals (public on-chain data)
2. Call `TokenContract.Approve` to approve 1 token to proposal virtual address
3. Call `Referendum.Reject(proposalId)` to block the proposal
4. Tokens are reclaimable after proposal expiry, so net cost is only gas fees

**Economic Rationality:**
- Attack cost: ~1 token locked temporarily + gas fees (negligible)
- Impact: Permanent governance disruption
- Motivations: Competitive advantage, ideological opposition, or pure griefing
- Detection is immediate but response is impossible

**Real-World Scenarios:**
- Contentious fee changes could motivate token holders to block proposals
- Competitors could disrupt protocol governance
- Single malicious actor with minimal capital can cause permanent damage

## Recommendation

**Immediate Fix:** Modify the referendum threshold configuration to allow proposals to pass despite some rejections:

```csharp
private CreateOrganizationBySystemContractInput GetReferendumControllerCreateInputForUserFee(
    Address parliamentAddress)
{
    var whiteList = new List<Address> { parliamentAddress };
    var tokenSymbol = GetPrimaryTokenSymbol(new Empty()).Value;
    return new CreateOrganizationBySystemContractInput
    {
        OrganizationCreationInput = new CreateOrganizationInput
        {
            TokenSymbol = tokenSymbol,
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 1000000, // e.g., 1M tokens must approve
                MinimalVoteThreshold = 2000000,     // e.g., 2M tokens must vote
                MaximalRejectionThreshold = 1000000, // Allow up to 1M tokens to reject
                MaximalAbstentionThreshold = 1000000 // Allow up to 1M tokens to abstain
            },
            ProposerWhiteList = new ProposerWhiteList
            {
                Proposers = { whiteList }
            }
        }
    };
}
```

**Alternative Approach:** Implement a tiered threshold system where:
- Simple majority (>50% of votes) is required for approval
- Set reasonable minimum participation thresholds
- Allow parliamentary override after a timeout period if referendum participation is too low

**Emergency Mitigation:** If already deployed, consider:
1. Creating a new referendum organization with proper thresholds
2. Using Parliament to create a new Association with the corrected referendum
3. Transitioning governance through `ChangeUserFeeController` (requires current controller approval, so must be done before attack occurs)

## Proof of Concept

```csharp
[Fact]
public async Task UserFeeGovernance_DoS_Via_Single_Token_Rejection()
{
    // Setup: Initialize the three-tier UserFeeController
    await TokenContractStub.InitializeAuthorizedController.SendAsync(new Empty());
    var controller = await TokenContractStub.GetUserFeeController.CallAsync(new Empty());
    
    // Verify referendum has MaximalRejectionThreshold = 0
    var referendumOrg = await ReferendumContractStub.GetOrganization.CallAsync(
        controller.ReferendumController.OwnerAddress);
    referendumOrg.ProposalReleaseThreshold.MaximalRejectionThreshold.ShouldBe(0);
    
    // Parliament proposes to update user fee coefficients
    var updateInput = new UpdateCoefficientsInput { /* coefficient data */ };
    
    // Create Association proposal
    var associationProposal = await CreateAssociationProposalForUserFee(updateInput);
    
    // Parliament approves the Association proposal
    await ParliamentApproveAssociationProposal(associationProposal);
    
    // Create Referendum proposal to have referendum address approve Association proposal
    var referendumProposal = await CreateReferendumProposalToApproveAssociation(associationProposal);
    
    // ATTACK: Attacker with 1 token rejects the referendum proposal
    await TokenContractStub.Approve.SendAsync(new ApproveInput {
        Spender = await ReferendumContractStub.GetProposalVirtualAddress.CallAsync(referendumProposal),
        Symbol = "ELF",
        Amount = 1
    });
    await ReferendumContractStub.Reject.SendAsync(referendumProposal);
    
    // Verify: Parliament cannot release the referendum proposal
    var releaseResult = await ParliamentContractStub.CreateProposal.SendAsync(new CreateProposalInput {
        ToAddress = ReferendumContractAddress,
        Params = referendumProposal.ToByteString(),
        OrganizationAddress = controller.ParliamentController.OwnerAddress,
        ContractMethodName = nameof(ReferendumContractStub.Release),
        ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
    });
    await ParliamentApproveAndRelease(releaseResult);
    
    // Verify: Referendum proposal was NOT released (blocked by rejection)
    var proposal = await ReferendumContractStub.GetProposal.CallAsync(referendumProposal);
    proposal.ToBeReleased.ShouldBeFalse(); // Blocked by RejectionCount > 0
    
    // Verify: Association proposal cannot be released (missing referendum approval)
    var associationReleaseAttempt = await TryReleaseAssociationProposal(associationProposal);
    associationReleaseAttempt.Status.ShouldBe(TransactionResultStatus.Failed);
    associationReleaseAttempt.Error.ShouldContain("Not approved"); // Association needs both approvals
    
    // Verify: UpdateCoefficientsForSender is permanently blocked
    var updateAttempt = await TokenContractStub.UpdateCoefficientsForSender.SendWithExceptionAsync(updateInput);
    updateAttempt.TransactionResult.Error.ShouldContain("no permission");
    
    // Verify: ChangeUserFeeController escape route is also blocked (same authority required)
    var changeAttempt = await TokenContractStub.ChangeUserFeeController.SendWithExceptionAsync(
        new AuthorityInfo { /* new controller */ });
    changeAttempt.TransactionResult.Error.ShouldContain("no permission");
    
    // Result: Complete and permanent governance DoS with no recovery mechanism
}
```

## Notes

This is a **fundamental architectural flaw** in the three-tier governance design. The use of `MaximalRejectionThreshold = 0` makes the referendum organization trivially blockable by any token holder, and the two-member Association requirement creates an inescapable dependency. The vulnerability demonstrates that overly restrictive governance thresholds can paradoxically make systems less secure by creating permanent DoS vectors.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L70-78)
```csharp
    public override Empty ChangeUserFeeController(AuthorityInfo input)
    {
        AssertUserFeeController();
        Assert(CheckOrganizationExist(input), "Invalid authority input.");
        State.UserFeeController.Value.RootController = input;
        State.UserFeeController.Value.ParliamentController = null;
        State.UserFeeController.Value.ReferendumController = null;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L143-149)
```csharp
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L171-177)
```csharp
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L391-397)
```csharp
    private void AssertUserFeeController()
    {
        Assert(State.UserFeeController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");
        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == State.UserFeeController.Value.RootController.OwnerAddress, "no permission");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L20-22)
```csharp
        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-51)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L25-32)
```csharp
    public override Empty UpdateCoefficientsForSender(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        AssertUserFeeController();
        input.Coefficients.FeeTokenType = (int)FeeTypeEnum.Tx; // The only possible for now.
        UpdateCoefficients(input);
        return new Empty();
    }
```
