# Audit Report

## Title
Unauthorized Round Termination by Non-Designated Miners on Side Chains

## Summary
The AEDPoS consensus contract allows any miner who missed their time slot to terminate a round and produce the extra block on side chains, bypassing the deterministic extra block producer designation. This violates a critical consensus invariant and allows miners to manipulate round termination for economic gain.

## Finding Description

The vulnerability exists in how side chains determine consensus behavior for round termination. The extra block producer for each round should be deterministically calculated to ensure fair rotation and prevent manipulation. However, the implementation allows any miner who hasn't produced a block to terminate the round.

**Root Cause**: The `SideChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` method unconditionally returns `NextRound` without validating whether the calling miner is the designated extra block producer. [1](#0-0) 

**Attack Flow**:

1. Any miner in the side chain miner list calls the public `GetConsensusCommand()` method [2](#0-1) 

2. For side chains, the system creates a `SideChainConsensusBehaviourProvider` and calls `GetConsensusBehaviour()` [3](#0-2) 

3. If the miner hasn't produced a block (`OutValue == null`), it calls `HandleMinerInNewRound()` [4](#0-3) 

4. When the miner's time slot has passed, `HandleMinerInNewRound()` returns `Nothing` [5](#0-4) 

5. Execution continues to call `GetConsensusBehaviourToTerminateCurrentRound()` which returns `NextRound` without any authorization check [6](#0-5) 

**Why Protections Fail**:

The extra block producer is deterministically calculated using signatures [7](#0-6)  and one miner per round is designated with `IsExtraBlockProducer = true` [8](#0-7) 

However, the validation providers for `NextRound` behavior do NOT check this flag:
- `MiningPermissionValidationProvider` only checks miner list membership [9](#0-8) 
- `NextRoundMiningOrderValidationProvider` checks order correctness [10](#0-9) 
- `RoundTerminateValidationProvider` checks round number and InValues [11](#0-10) 
- No validator checks the `IsExtraBlockProducer` designation [12](#0-11) 

While `IsCurrentMiner()` does check for extra block producer privileges [13](#0-12)  this method is never invoked during consensus behavior determination or validation for `NextRound` blocks.

## Impact Explanation

**Consensus Integrity Violation**: The deterministic extra block producer calculation is a critical consensus mechanism to ensure fair rotation and prevent manipulation. Allowing arbitrary miners to terminate rounds breaks this invariant.

**Economic Benefits to Attacker**:

1. The terminating miner becomes `ExtraBlockProducerOfPreviousRound` in the next round [14](#0-13) 

2. Their `ProducedBlocks` count is incremented by 1 [15](#0-14) 

3. This affects mining reward calculations as rewards are based on total mined blocks [16](#0-15) 

4. Mining rewards are donated to Treasury [17](#0-16) 

5. They gain the privilege to mine at the start of the next round as the previous round's extra block producer [18](#0-17) 

**Affected Parties**: All side chain miners face unfair competition as the consensus mechanism's fairness and determinism are compromised. Honest miners lose their designated round termination opportunities.

**Severity**: HIGH - This violates the "Correct round transitions and miner schedule integrity" critical invariant for consensus systems.

## Likelihood Explanation

**Attacker Capabilities**: Any miner in the side chain miner list can execute this attack. The only requirement is being in the current round's miner list, which is checked [19](#0-18) 

**Attack Complexity**: Trivial
1. Miner intentionally skips producing a block during their assigned time slot
2. Wait for their time slot to pass
3. Call `GetConsensusCommand()` - a standard public method defined in the ACS4 consensus standard [20](#0-19) 
4. Receive `NextRound` behavior and produce the round-terminating block

**Feasibility Conditions**: 
- Miner must be in the current round's miner list (given for any miner)
- Miner's time slot must have passed (automatic with time progression)
- No other miner has already terminated the round (creates a race condition, but multiple miners can attempt this)

**Economic Rationality**: The attack cost is zero (simply not mining during the assigned slot), while the benefit includes increased block production statistics, enhanced reputation in the Election contract, and the privilege to mine at the start of the next round. Multiple miners can attempt this simultaneously, creating a race to terminate rounds.

**Detection Difficulty**: The attack is difficult to distinguish from legitimate network delays or node failures, as miners missing time slots is a normal occurrence in distributed systems.

## Recommendation

Add validation in either the consensus behavior provider or the validation pipeline to ensure only the designated extra block producer can terminate rounds:

**Option 1**: Add validation in `SideChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()`:
```csharp
protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
{
    // Check if current miner is the designated extra block producer
    var extraBlockProducer = CurrentRound.RealTimeMinersInformation.Values
        .FirstOrDefault(m => m.IsExtraBlockProducer);
    
    if (extraBlockProducer?.Pubkey != _pubkey)
    {
        // Not the designated extra block producer, cannot terminate round
        return AElfConsensusBehaviour.Nothing;
    }
    
    return AElfConsensusBehaviour.NextRound;
}
```

**Option 2**: Add a new validation provider `ExtraBlockProducerValidationProvider` that checks the `IsExtraBlockProducer` flag during `NextRound` validation.

**Option 3**: Invoke the existing `IsCurrentMiner()` check during consensus behavior determination to ensure the miner is authorized to produce the extra block.

## Proof of Concept

```csharp
[Fact]
public async Task UnauthorizedRoundTermination_ByNonDesignatedMiner()
{
    // Setup: Initialize side chain with multiple miners
    var miners = new[] { "miner1", "miner2", "miner3" };
    await InitializeSideChainConsensus(miners);
    
    // Get current round information
    var currentRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Identify the designated extra block producer
    var designatedExtraBlockProducer = currentRound.RealTimeMinersInformation.Values
        .First(m => m.IsExtraBlockProducer);
    
    // Select a different miner (non-designated) who hasn't mined this round
    var attackerMiner = currentRound.RealTimeMinersInformation.Values
        .First(m => !m.IsExtraBlockProducer && m.OutValue == null);
    
    // Wait for attacker's time slot to pass
    await AdvanceTimeSlot(attackerMiner.ExpectedMiningTime);
    
    // Attacker calls GetConsensusCommand
    var command = await ConsensusContract.GetConsensusCommand.CallAsync(
        new BytesValue { Value = ByteString.CopyFromUtf8(attackerMiner.Pubkey) });
    
    // Verify attacker received NextRound behavior despite not being designated
    Assert.NotNull(command);
    Assert.NotEqual(ConsensusCommandProvider.InvalidConsensusCommand, command);
    
    // Produce block with NextRound behavior
    await ProduceBlockWithConsensusCommand(attackerMiner.Pubkey, command);
    
    // Verify attacker became ExtraBlockProducerOfPreviousRound in next round
    var nextRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.Equal(attackerMiner.Pubkey, nextRound.ExtraBlockProducerOfPreviousRound);
    
    // Verify attacker's ProducedBlocks was incremented
    Assert.True(nextRound.RealTimeMinersInformation[attackerMiner.Pubkey].ProducedBlocks > 0);
    
    // Verify the designated extra block producer was bypassed
    Assert.NotEqual(designatedExtraBlockProducer.Pubkey, nextRound.ExtraBlockProducerOfPreviousRound);
}
```

## Notes

This vulnerability affects **both main chain and side chains**, as the `MainChainConsensusBehaviourProvider` also does not validate the extra block producer designation [21](#0-20) . However, the report focuses on side chains where the impact is more direct since side chains don't have the additional complexity of term changes.

The vulnerability allows manipulation of consensus statistics and mining privileges, which could lead to centralization concerns if a subset of miners consistently exploits this to gain unfair advantages over honest miners who follow the protocol rules.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-23)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-27)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L44-46)
```csharp
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-51)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L114-114)
```csharp
            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-24)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-177)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L178-178)
```csharp
        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L191-192)
```csharp
        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L119-120)
```csharp
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L125-129)
```csharp
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });
```

**File:** protobuf/acs4.proto (L19-22)
```text
    // Generate a consensus command based on the consensus contract state and the input public key.
    rpc GetConsensusCommand (google.protobuf.BytesValue) returns (ConsensusCommand) {
        option (aelf.is_view) = true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```
