### Title
Premature Consensus Round/Term Transition via Unchecked Behaviour Field Manipulation

### Summary
A malicious miner can trigger premature round or term transitions by directly calling the public `GetConsensusExtraData` method with a crafted `AElfConsensusTriggerInformation` containing `NextRound` or `NextTerm` behaviour, bypassing the intended consensus flow. The validation logic only verifies sequential round/term numbering but fails to check whether transition conditions are actually met, allowing attackers to disrupt consensus integrity and steal mining opportunities from other validators.

### Finding Description

The vulnerability exists in the consensus block production flow where the `Behaviour` field determines round transition logic.

**Entry Point:** The public `GetConsensusExtraData` method exposes `GetConsensusBlockExtraData` without validating that the provided behaviour is appropriate for the current consensus state. [1](#0-0) 

**Root Cause:** The switch statement in `GetConsensusBlockExtraData` unconditionally processes the `triggerInformation.Behaviour` field received from user input, executing `NextRound` or `NextTerm` paths without verifying preconditions. [2](#0-1) 

**Why Protections Fail:** The validation system uses `RoundTerminateValidationProvider` which only checks that round/term numbers increment sequentially, but does NOT verify whether the round has actually completed or whether term change conditions are satisfied. [3](#0-2) 

The `ValidationForNextRound` method only validates round number increment and that InValues are null, missing critical checks for round completion: [4](#0-3) 

**Missing Validation:** The legitimate flow determines behaviour through `MainChainConsensusBehaviourProvider`, which checks `NeedToChangeTerm` based on elapsed time and miner consensus: [5](#0-4) [6](#0-5) 

However, a malicious miner can bypass this logic by crafting trigger information directly, and the validation never re-checks these conditions.

**Execution Path:**
1. Attacker (valid miner) crafts `AElfConsensusTriggerInformation` with `Behaviour = NextRound` or `NextTerm`
2. Calls public `GetConsensusExtraData` method with crafted input
3. `GetConsensusBlockExtraData` processes the behaviour via switch statement without validation
4. For `NextRound`, `GetConsensusExtraDataForNextRound` executes, setting attacker as `ExtraBlockProducerOfPreviousRound`: [7](#0-6) 

5. Block validation passes because only sequential numbering is checked
6. `ProcessNextRound` executes without verifying round completion: [8](#0-7) 

### Impact Explanation

**Consensus Integrity Violation:** Premature round transitions disrupt the ordered miner schedule, allowing attackers to:
- Skip remaining miners in the current round, denying them block production opportunities and associated rewards
- Become the `ExtraBlockProducerOfPreviousRound`, granting extra mining privileges in the next round
- Manipulate the mining order to their advantage

**Direct Economic Harm:**
- Miners who haven't had their scheduled time slot lose block rewards (typically proportional to round participation)
- Attacker gains unfair advantage through extra block production privileges
- Treasury reward distribution becomes skewed based on manipulated mining statistics

**Term Transition Exploitation:** For `NextTerm` behaviour, premature term changes trigger critical system operations:
- Early treasury profit releases before intended time
- Premature validator election snapshots with incomplete round data
- Mining reward distributions based on manipulated statistics [9](#0-8) 

**Operational Impact:** Repeated exploitation creates chain instability, as honest nodes and malicious nodes have divergent views of round progression, potentially causing consensus failures and chain reorganizations.

### Likelihood Explanation

**Attacker Requirements:**
- Must be a valid miner in the current round (standard validator requirement)
- Can call public `GetConsensusExtraData` method (no special permissions needed)
- Can construct valid `AElfConsensusTriggerInformation` protobuf messages (standard capability)

**Attack Complexity:** LOW
- Single transaction attack with minimal setup
- No multi-step coordination required
- Can be executed repeatedly once validator status is achieved

**Feasibility Conditions:**
- Attacker controls at least one validator node (common in permissioned consensus)
- Network accepts blocks from attacker's node (standard operation)
- No rate limiting on consensus transactions

**Detection Difficulty:** Medium to High
- Premature transitions appear as valid consensus operations with correct sequential numbering
- Requires off-chain monitoring of expected vs actual round timing to detect
- Individual instances may appear as timing variations rather than attacks

**Economic Rationality:** The cost is minimal (validator node operation costs) while benefits include:
- Stealing mining rewards from other validators
- Gaining extra mining privileges
- Manipulating reward distributions

The PreCheck only validates miner list membership, not behaviour appropriateness: [10](#0-9) 

### Recommendation

**Immediate Mitigation:** Add validation in `ValidateBeforeExecution` to verify round/term transition conditions are met before accepting `NextRound` or `NextTerm` behaviours.

**Specific Code Changes:**

1. Enhance `RoundTerminateValidationProvider` to check round completion:
   - Verify all miners have had opportunity to mine or their time slots have passed
   - Check that current time exceeds round expected end time
   - Validate that the triggering miner is the appropriate one (e.g., last in order)

2. For `NextTerm` validation, add check that `NeedToChangeTerm` conditions are met:
   - Verify that two-thirds of miners' latest mining times exceed term duration threshold
   - Ensure term period has actually elapsed according to blockchain timestamps

3. Add authorization check that only the designated extra block producer can trigger round transitions at the appropriate time

**Invariant Checks to Add:**
```
For NextRound:
- ASSERT(currentTime >= currentRound.GetExpectedEndTime())
- ASSERT(AllMinersHadOpportunityOrTimeExpired(currentRound))
- ASSERT(sender.IsAuthorizedToTerminateRound(currentRound))

For NextTerm:
- ASSERT(currentRound.NeedToChangeTerm(blockchainStartTime, termNumber, periodSeconds))
- ASSERT(ValidateTermDurationElapsed(currentRound, termNumber))
```

**Test Cases:**
1. Test that NextRound is rejected when called mid-round by non-designated miner
2. Test that NextTerm is rejected when term duration has not elapsed
3. Test that malicious trigger information with wrong behaviour is rejected
4. Test that only legitimate consensus flow can trigger transitions at proper times

### Proof of Concept

**Initial State:**
- Current round has 7 miners with orders 1-7
- Miners 1-3 have produced blocks (OutValue != null)
- Current time is within Miner 4's time slot
- Round is scheduled to last until all 7 miners complete their slots

**Attack Steps:**
1. Attacker (Miner 5) constructs `AElfConsensusTriggerInformation`:
   - Set `Pubkey` to their validator public key
   - Set `Behaviour` to `AElfConsensusBehaviour.NextRound`
   
2. Attacker calls `GetConsensusExtraData(triggerInformation)`
   - Method returns consensus extra data with NextRound behaviour
   - Resulting round has `RoundNumber = currentRound.RoundNumber + 1`
   - Attacker is set as `ExtraBlockProducerOfPreviousRound`

3. Attacker produces block with this consensus extra data

4. Block validation executes:
   - `MiningPermissionValidationProvider`: PASS (attacker is in miner list)
   - `TimeSlotValidationProvider`: PASS (only checks new round time slots are valid)
   - `RoundTerminateValidationProvider`: PASS (round number increments correctly)
   - All validations pass despite round being incomplete

5. `ProcessNextRound` executes successfully, incrementing round number

**Expected Result:** Transaction should be rejected because miners 4-7 haven't had their turns

**Actual Result:** Transaction succeeds, round transitions prematurely, miners 4-7 lose their scheduled mining opportunity, attacker gains `ExtraBlockProducerOfPreviousRound` status for extra mining privileges

**Success Condition:** The attack succeeds if `State.CurrentRoundNumber` increments to the next round before all scheduled miners complete their time slots, which can be verified by checking that miners 4-7 have `OutValue == null` in the terminated round.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L26-48)
```csharp
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```
