### Title
Unbounded Transaction Fees Enable Economic Rent Extraction Through Governance

### Summary
The Configuration contract's `SetMethodFee` function lacks upper bound validation on transaction fee amounts, allowing Parliament (current miners with 66.67% approval) to set arbitrarily high fees without programmatic constraints. This creates a mechanism for economic rent extraction from users and centralization of power, as users would be forced to pay excessive fees or abandon the blockchain entirely.

### Finding Description

The `SetMethodFee` method in the Configuration contract only validates that fee amounts are non-negative and that tokens are available for method fees, but imposes no upper bounds on fee values. [1](#0-0) 

The validation function `AssertValidToken` only checks `amount >= 0` and token availability, with no maximum limit: [2](#0-1) 

The `MethodFeeController` defaults to Parliament's default organization, requiring 66.67% miner approval: [3](#0-2) [4](#0-3) 

Transaction fees are directly charged to users based on the configured `BasicFee` values without any caps: [5](#0-4) 

Other system contracts implement bounds on critical parameters (e.g., Profit contract limits fee count, Economic contract limits memo size), demonstrating that the lack of bounds on transaction fees is inconsistent with the broader system design pattern: [6](#0-5) 

### Impact Explanation

**Direct Economic Impact:** If Parliament sets excessive fees (e.g., 1,000,000 ELF per transaction), users would be forced to pay these amounts for any blockchain interaction or cease using the system entirely. This creates direct financial extraction from the user base with no programmatic recourse.

**Economic Centralization:** The unlimited fee-setting power concentrates economic control in the hands of the current miner set (Parliament). If miners collectively benefit from high fees (e.g., fees flow to mining rewards), they have economic incentive to extract maximum rent from users, creating a centralized rent-seeking mechanism.

**System-Wide Impact:** Unlike vulnerabilities affecting individual contracts or methods, this affects ALL contract method calls system-wide, as every transaction incurs these fees. The entire blockchain becomes unusable at extractive fee levels.

**No Market Correction:** Unlike competitive markets where users can switch providers, blockchain users are locked into the network and have no alternative if governance sets excessive fees, making this a captive market exploitation scenario.

### Likelihood Explanation

**Attacker Capabilities:** Requires coordination of 66.67% of current miners (the Parliament approval threshold) to propose and approve excessive fees. [7](#0-6) 

**Execution Practicality:** The attack follows the standard governance process: (1) Create Parliament proposal calling `SetMethodFee` with high `BasicFee` values, (2) Obtain 66.67% miner approval, (3) Release and execute the proposal. No special privileges or technical exploits required. [8](#0-7) [9](#0-8) 

**Economic Rationality:** While miners harming the blockchain long-term contradicts sustainability, short-term profit extraction scenarios exist: (1) Market manipulation before exit, (2) Competitive pressure to extract value before replacement, (3) External economic incentives (e.g., paid to sabotage a competitor chain), (4) Coordination failure where individual rational choices lead to collective harm.

**Feasibility Assessment:** Medium-to-High likelihood. Miner coordination is achievable through off-chain agreements, and historical blockchain governance shows coalitions can form around economic interests, even when detrimental to the broader ecosystem.

### Recommendation

**Code-Level Mitigation:**

1. Add maximum fee bounds validation in `SetMethodFee`:
```
Assert(methodFee.BasicFee <= ConfigurationContractConstants.MaximumBasicFee, 
       "Basic fee exceeds maximum allowed.");
```

2. Define reasonable maximum constants (e.g., tied to economic metrics like median transaction value or percentage of token supply).

3. Implement rate-limiting on fee changes (e.g., maximum 2x increase per governance period).

4. Add economic reasonableness checks tied to observable metrics (network usage, token price, etc.).

**Invariant Checks:**
- `BasicFee <= MaximumBasicFee` for all tokens
- Fee changes cannot exceed `MaximumFeeChangeRatio` per period
- Total fees per transaction cannot exceed `MaximumTotalFeePerTransaction`

**Test Cases:**
- Test that `SetMethodFee` reverts when `BasicFee > MaximumBasicFee`
- Test that multiple fee increases in succession respect rate limits
- Test that extreme fee values (e.g., max int64) are rejected
- Test governance attack scenarios where 66.67% of miners attempt excessive fees

**Governance Enhancement:**
- Implement two-stage governance for fee changes with mandatory delay periods
- Add emergency response mechanism for users to petition fee reductions
- Consider tiered approval thresholds (e.g., 90% required for fees above certain levels)

### Proof of Concept

**Required Initial State:**
- Parliament contract initialized with default organization
- Configuration contract deployed and initialized
- Test accounts with miner privileges (67% of miner set)

**Attack Sequence:**

1. **Miner Coordination Phase:** 67% of miners coordinate off-chain to extract rent through excessive fees.

2. **Proposal Creation:** A miner creates Parliament proposal:
   - Target: Configuration contract `SetMethodFee`
   - Parameters: `MethodFees` with `BasicFee = 1000000_00000000` (1 million ELF per call)
   - Method: "Transfer" (most commonly used method)

3. **Approval Phase:** 67% of miners approve the proposal through Parliament voting. [10](#0-9) 

4. **Release & Execution:** Proposer releases the approved proposal, executing `SetMethodFee`. [1](#0-0) 

5. **Impact Realization:** Next user attempting a Transfer transaction is charged 1 million ELF fee, effectively making the blockchain unusable for normal users.

**Expected vs Actual Result:**
- **Expected:** Transaction fee setting should be rejected due to excessive amount exceeding reasonable bounds
- **Actual:** Transaction fee is set successfully with no upper bound check, enabling economic extraction

**Success Condition:** `State.TransactionFees["Transfer"].Fees[0].BasicFee == 1000000_00000000` and normal users cannot afford to use the blockchain, confirming economic centralization through unbounded governance power.

### Citations

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L11-21)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L51-65)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L79-88)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L5-9)
```csharp
    private const int DefaultOrganizationMinimalApprovalThreshold = 6667;
    private const int DefaultOrganizationMaximalAbstentionThreshold = 2000;
    private const int DefaultOrganizationMaximalRejectionThreshold = 2000;
    private const int DefaultOrganizationMinimalVoteThresholdThreshold = 7500;
    private const int AbstractVoteTotal = 10000;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-52)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        Assert(input.Fees.Count <= ProfitContractConstants.TokenAmountLimit, "Invalid input.");
        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L78-94)
```csharp
    public override Empty Approve(Hash input)
    {
        var parliamentMemberAddress = GetAndCheckActualParliamentMemberAddress();
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedByMember(proposal, parliamentMemberAddress);
        proposal.Approvals.Add(parliamentMemberAddress);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = parliamentMemberAddress,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```
