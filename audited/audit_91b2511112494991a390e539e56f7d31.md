# Audit Report

## Title
Time-of-Check-Time-of-Use Vulnerability in Proposal Rejection Count Allows Governance Bypass Through Member Manipulation

## Summary
The Association contract's `IsProposalRejected()` function contains a critical TOCTOU vulnerability that recalculates rejection counts using the current organization membership at proposal release time rather than the membership snapshot at voting time. This allows attackers to bypass legitimate proposal rejections by removing rejecting members between voting and release, completely undermining the multi-signature governance model.

## Finding Description

The vulnerability exists in the proposal rejection validation mechanism. When a proposal is being released, the `IsProposalRejected()` function filters stored rejection addresses against the **current** organization membership list [1](#0-0) , rather than using a membership snapshot from when votes were cast.

The core issue is that rejection addresses are stored in the proposal at voting time [2](#0-1)  and stored as a `repeated aelf.Address` list [3](#0-2) . However, when evaluating if a proposal is rejected during release, the code counts only those rejection addresses that are **currently** in the organization member list [4](#0-3) .

Organization membership can be modified after votes are cast through the `RemoveMember()` [5](#0-4) , `AddMember()` [6](#0-5) , and `ChangeMember()` [7](#0-6)  functions, all callable by the organization address itself via proposal execution.

The vulnerable check occurs during proposal release where `IsReleaseThresholdReached()` calls `IsProposalRejected()` to determine if the proposal should be blocked [8](#0-7) , and this check is enforced in the `Release()` function [9](#0-8) .

There are no protections: no membership snapshots are captured at proposal creation or voting time, no locks prevent member removal for proposals with active votes, and the validation logic in `Validate()` [10](#0-9)  does not prevent membership changes for active proposals.

## Impact Explanation

**CRITICAL SEVERITY** - This vulnerability enables a complete governance bypass with the following impacts:

1. **Governance Invariant Violation**: Proposals that were legitimately rejected by the organization can be executed after membership manipulation, violating the fundamental principle that rejection decisions should be final.

2. **Concrete Attack Scenario**:
   - Organization with 7 members [A,B,C,D,E,F,G]
   - Thresholds: MinimalApproval=3, MaximalRejection=3
   - Malicious Proposal P1 receives 3 approvals and 4 rejections (D,E,F,G)
   - P1 is correctly rejected (4 > 3)
   - Attacker orchestrates Proposal P2 to remove member D
   - After D's removal, P1's rejection count becomes 3 (only E,F,G remain as members)
   - Since 3 is NOT > 3, P1 can now be released despite being properly rejected

3. **Affected Systems**: All Association-based governance organizations, including critical system governance controlling protocol parameters, treasury funds, and cross-chain operations.

4. **Attack Outcomes**: 
   - Unauthorized fund transfers from organization-controlled treasuries
   - Malicious contract executions with organization authority
   - Protocol parameter manipulation
   - Governance capture through threshold manipulation

## Likelihood Explanation

**HIGH/MODERATE LIKELIHOOD** based on:

**Attacker Requirements**:
- Ability to create and vote on proposals (normal member operations)
- Control of sufficient votes to pass member removal proposals OR
- Ability to influence legitimate membership changes through social engineering

**Attack Complexity**: MODERATE
- Uses only standard governance operations (no exploits required)
- Requires timing coordination between rejection and member removal
- Does not require privilege escalation or system-level access

**Feasibility Factors**:
- Organizations with natural member turnover are inherently vulnerable
- Long-lived proposals (before expiration) provide extended exploitation windows
- Organizations with lower `MaximalRejectionThreshold` values require fewer member removals
- All operations appear legitimate, making detection difficult

**Preconditions**: 
- Active organization with dynamic membership (common in real-world governance)
- Proposals with sufficient lifetime between voting and release
- No external monitoring of member removal patterns relative to active proposals

## Recommendation

Implement membership snapshot mechanism at voting time:

```csharp
// Capture membership snapshot when first vote is cast
private void CaptureOrganizationSnapshot(Hash proposalId, Organization organization)
{
    if (!State.ProposalMembershipSnapshots[proposalId].Exists())
    {
        State.ProposalMembershipSnapshots[proposalId] = organization.OrganizationMemberList;
    }
}

// Use snapshot for rejection validation
private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
{
    var membershipSnapshot = State.ProposalMembershipSnapshots[proposal.ProposalId] 
        ?? organization.OrganizationMemberList;
    var rejectionMemberCount = proposal.Rejections.Count(membershipSnapshot.Contains);
    return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
}

// Call in Approve/Reject/Abstain methods before adding vote
CaptureOrganizationSnapshot(input, organization);
```

Alternative: Add validation to prevent member removal when they have active votes on pending proposals.

## Proof of Concept

```csharp
[Fact]
public async Task TOCTOU_Governance_Bypass_Via_Member_Removal_Test()
{
    // Setup: Create organization with 7 members
    var members = new[] { Accounts[0].Address, Accounts[1].Address, Accounts[2].Address, 
                         Accounts[3].Address, Accounts[4].Address, Accounts[5].Address, 
                         Accounts[6].Address };
    
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold: 3,
        minimalVoteThreshold: 4,
        maximalAbstentionThreshold: 0,
        maximalRejectionThreshold: 3,
        proposer: members[0],
        members: members);

    // Create malicious proposal P1
    var proposalP1 = await CreateProposalAsync(Accounts[0].KeyPair, organizationAddress);
    
    // Vote on P1: 3 approvals (A,B,C) and 4 rejections (D,E,F,G)
    await ApproveAsync(Accounts[0].KeyPair, proposalP1);
    await ApproveAsync(Accounts[1].KeyPair, proposalP1);
    await ApproveAsync(Accounts[2].KeyPair, proposalP1);
    await RejectAsync(Accounts[3].KeyPair, proposalP1);
    await RejectAsync(Accounts[4].KeyPair, proposalP1);
    await RejectAsync(Accounts[5].KeyPair, proposalP1);
    await RejectAsync(Accounts[6].KeyPair, proposalP1);
    
    // Verify P1 is rejected (4 rejections > 3 threshold)
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalP1);
    proposal.ToBeReleased.ShouldBeFalse();
    proposal.RejectionCount.ShouldBe(4);
    
    // Create and execute P2 to remove member D (Accounts[3])
    var proposalP2 = await CreateRemoveMemberProposalAsync(organizationAddress, members[3]);
    await ApproveAsync(Accounts[0].KeyPair, proposalP2);
    await ApproveAsync(Accounts[1].KeyPair, proposalP2);
    await ApproveAsync(Accounts[2].KeyPair, proposalP2);
    await ApproveAsync(Accounts[4].KeyPair, proposalP2);
    await ReleaseAsync(Accounts[0].KeyPair, proposalP2);
    
    // VULNERABILITY: P1 should still be rejected but now passes
    var proposalAfter = await AssociationContractStub.GetProposal.CallAsync(proposalP1);
    proposalAfter.ToBeReleased.ShouldBeTrue(); // BUG: Now releasable despite rejection!
    
    // P1 can now be released despite being legitimately rejected
    var releaseResult = await ReleaseAsync(Accounts[0].KeyPair, proposalP1);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

**Notes**

This vulnerability represents a fundamental flaw in the Association contract's governance model. The same issue likely affects approval and abstention counting mechanisms as well (both use the same pattern of filtering against current membership). The vulnerability is particularly severe because it allows retroactive invalidation of governance decisions through membership manipulation, which completely undermines the trustworthiness of the multi-signature system. Organizations using Association contracts for critical operations (treasury management, protocol upgrades, cross-chain operations) are at significant risk.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L143-161)
```csharp
    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Rejections.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Reject),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L248-264)
```csharp
    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** protobuf/association_contract.proto (L93-94)
```text
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```
