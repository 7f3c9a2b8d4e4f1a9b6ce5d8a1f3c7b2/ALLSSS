### Title
Alias-to-Alias Mapping Enables Circular References and Incomplete Symbol Resolution

### Summary
The token alias system allows creating aliases that point to other aliases instead of actual token symbols, enabling both circular reference chains and incomplete resolution paths. The `GetActualTokenSymbol` function only resolves one level of indirection, causing balance queries, transfers, and other token operations to fail or return incorrect results when chained or circular aliases are used.

### Finding Description

The vulnerability exists in two critical components:

**1. Single-Level Alias Resolution**

The `GetActualTokenSymbol` function performs only one level of alias lookup. [1](#0-0) 

If an alias points to another alias, the resolution stops at the intermediate alias instead of resolving to the actual token symbol. This affects all token operations including balance queries [2](#0-1) , transfers [3](#0-2) , and approvals [4](#0-3) .

**2. Missing Validation in Alias Creation**

The `SetTokenAlias` function, called during token creation, does not validate that the symbol extracted from ExternalInfo is not already an existing alias. [5](#0-4) 

The function only validates that the alias format matches the collection prefix via `CheckTokenAlias`, but never checks if the target symbol is itself an alias. [6](#0-5) 

**3. Attack Vectors**

This is exploitable through two code paths:
- During NFT Collection creation with ExternalInfo containing alias settings [7](#0-6) 
- During cross-chain token synchronization [8](#0-7) 

The ExternalInfo format allows specifying arbitrary symbol-to-alias mappings without validation. [9](#0-8) 

### Impact Explanation

**Operational Disruption:**
- Balance queries using chained aliases return incorrect results (0 or wrong balances) because the intermediate alias doesn't correspond to an actual token symbol
- Transfer operations fail or affect unintended tokens when aliases resolve incorrectly
- Approval and allowance operations malfunction as they use `GetActualTokenSymbol` internally
- Lock/unlock operations fail for tokens accessed via chained aliases

**Economic Impact:**
- Users lose access to their token balances through alias-based queries
- Token metadata becomes inaccessible, breaking NFT marketplace integrations
- Cross-chain token operations can propagate broken alias chains to other chains, creating system-wide corruption
- Smart contracts relying on alias resolution receive incorrect data, leading to flawed business logic execution

**Severity Justification:**
While this doesn't directly steal funds, it creates a permanent denial-of-service condition for affected tokens and can corrupt the alias mapping state across the entire system including cross-chain deployments. The impact extends to all users attempting to interact with the affected tokens through their aliases.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires only standard NFT collection creation rights (no special permissions)
- Standard token creation flow allows setting ExternalInfo during `Create` call
- No governance approval or trusted role needed

**Attack Complexity:**
- Low complexity: Single transaction to create NFT collection with crafted ExternalInfo
- No timing requirements or race conditions
- Exploitation works reliably every time

**Feasibility Conditions:**
- Attacker needs ability to create NFT collections (standard user capability)
- Cost is minimal: standard token creation gas fees
- No preconditions beyond having one existing alias to target

**Detection Constraints:**
- Cannot be prevented by monitoring since ExternalInfo is a legitimate parameter
- No runtime checks exist to detect or prevent alias-to-alias mappings
- Silent failure mode makes detection difficult until users report issues

**Probability Assessment:**
HIGH - The attack is trivial to execute through normal contract interfaces, requires no special access, and has immediate effect.

### Recommendation

**1. Implement Recursive Alias Resolution**

Modify `GetActualTokenSymbol` to recursively resolve aliases until reaching an actual token symbol or detecting a cycle:

```csharp
private string GetActualTokenSymbol(string aliasOrSymbol, HashSet<string> visited = null)
{
    if (visited == null) visited = new HashSet<string>();
    
    if (State.TokenInfos[aliasOrSymbol] != null)
        return aliasOrSymbol;
    
    Assert(!visited.Contains(aliasOrSymbol), "Circular alias reference detected.");
    visited.Add(aliasOrSymbol);
    
    var nextSymbol = State.SymbolAliasMap[aliasOrSymbol];
    if (string.IsNullOrEmpty(nextSymbol))
        return aliasOrSymbol;
    
    return GetActualTokenSymbol(nextSymbol, visited);
}
```

**2. Add Validation in SetTokenAlias**

Add checks to ensure the target symbol is not an existing alias: [5](#0-4) 

Insert after line 828:
```csharp
// Ensure symbol is not an existing alias
Assert(State.SymbolAliasMap[symbol] == null, 
    $"Cannot set alias to point to another alias: {symbol}");

// Ensure symbol points to an actual token
var targetTokenInfo = State.TokenInfos[symbol];
Assert(targetTokenInfo != null, 
    $"Alias target symbol does not exist: {symbol}");
```

**3. Add Similar Validation in SetSymbolAlias** [10](#0-9) 

Insert before line 768 the same checks to prevent setting aliases to aliases.

**4. Test Cases**

Add regression tests covering:
- Attempting to create alias pointing to existing alias (should fail)
- Attempting to create circular reference (should fail)
- Multi-level alias chains are properly rejected
- Existing aliases continue to work correctly

### Proof of Concept

**Attack Scenario 1: Alias Chain Creating Incomplete Resolution**

1. **Initial State:** Create NFT Collection "ABC-0" and set alias via `SetSymbolAlias`:
   - Input: `Symbol="ABC-1"`, `Alias="ABC"`
   - Result: `State.SymbolAliasMap["ABC"] = "ABC-1"`

2. **Exploit:** Create NFT Collection "XYZ-0" with ExternalInfo:
   ```json
   {"ABC":"XYZ"}
   ```
   - `SetTokenAlias` extracts `(symbol="ABC", alias="XYZ")`
   - Sets `State.SymbolAliasMap["XYZ"] = "ABC"`
   - No validation that "ABC" is itself an alias
   - Result: Chain created: `XYZ → ABC → ABC-1`

3. **Verify Impact:** Call `GetSymbolByAlias("XYZ")`:
   - Expected: Should return "ABC-1"
   - Actual: Returns "ABC" (intermediate alias)
   - Balance query `GetBalance(address, "XYZ")` looks up `State.Balances[address]["ABC"]` which doesn't exist, returns 0

**Attack Scenario 2: Circular Reference**

1. **Exploit Step 1:** Create NFT Collection "ABC-0" with ExternalInfo:
   ```json
   {"XYZ":"ABC"}
   ```
   - Result: `State.SymbolAliasMap["ABC"] = "XYZ"`

2. **Exploit Step 2:** Create NFT Collection "XYZ-0" with ExternalInfo:
   ```json
   {"ABC":"XYZ"}
   ```
   - Result: `State.SymbolAliasMap["XYZ"] = "ABC"`
   - Circular reference created: `ABC → XYZ → ABC → XYZ...`

3. **Verify Impact:**
   - `GetSymbolByAlias("ABC")` returns "XYZ" (not a real token)
   - `GetSymbolByAlias("XYZ")` returns "ABC" (not a real token)
   - Neither resolves to actual token symbol
   - All operations using these aliases fail or return incorrect results

**Success Condition:** The above sequences execute successfully through the `Create` method without any validation errors, and subsequent `GetSymbolByAlias` calls return intermediate aliases instead of actual token symbols, demonstrating the vulnerability.

### Notes

The vulnerability is confirmed through code analysis and test file examination. The `TokenAliasTests.cs` test file demonstrates the intended usage pattern but does not include negative test cases for alias-to-alias mappings or circular references. The missing validation in `SetTokenAlias` combined with single-level resolution in `GetActualTokenSymbol` creates the exploitable condition. This affects both on-chain token creation and cross-chain token synchronization paths.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L286-294)
```csharp
    private string GetActualTokenSymbol(string aliasOrSymbol)
    {
        if (State.TokenInfos[aliasOrSymbol] == null)
        {
            return State.SymbolAliasMap[aliasOrSymbol] ?? aliasOrSymbol;
        }

        return aliasOrSymbol;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L166-172)
```csharp
    private long GetBalance(Address address, string symbol)
    {
        AssertValidInputAddress(address);
        var actualSymbol = GetActualTokenSymbol(symbol);
        Assert(!string.IsNullOrWhiteSpace(actualSymbol), "Invalid symbol.");
        return State.Balances[address][actualSymbol];
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L81-85)
```csharp
        if (IsAliasSettingExists(tokenInfo))
        {
            Assert(symbolType == SymbolType.NftCollection, "Token alias can only be set for NFT Item.");
            SetTokenAlias(tokenInfo);
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L261-268)
```csharp
    public override Empty Approve(ApproveInput input)
    {
        AssertValidInputAddress(input.Spender);
        var actualSymbol = GetActualTokenSymbol(input.Symbol);
        AssertValidApproveTokenAndAmount(actualSymbol, input.Amount);
        Approve(input.Spender, actualSymbol, input.Amount);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L505-531)
```csharp
        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L738-779)
```csharp
    public override Empty SetSymbolAlias(SetSymbolAliasInput input)
    {
        // Alias setting can only work for NFT Item for now.
        // And the setting exists on the TokenInfo of the NFT Collection.

        // Can only happen on Main Chain.
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "Symbol alias setting only works on MainChain.");

        var collectionSymbol = GetNftCollectionSymbol(input.Symbol, true);

        // For now, token alias can only be set once.
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");

        CheckTokenAlias(input.Alias, collectionSymbol);

        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");

        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);

        State.SymbolAliasMap[input.Alias] = input.Symbol;

        Context.LogDebug(() => $"Token alias added: {input.Symbol} -> {input.Alias}");

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = input.Symbol,
            Alias = input.Alias
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L826-838)
```csharp
    private void SetTokenAlias(TokenInfo tokenInfo)
    {
        var (symbol, alias) = ExtractAliasSetting(tokenInfo);
        State.SymbolAliasMap[alias] = symbol;

        CheckTokenAlias(alias, tokenInfo.Symbol);

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = symbol,
            Alias = alias
        });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L840-852)
```csharp
    private void CheckTokenAlias(string alias, string collectionSymbol)
    {
        if (collectionSymbol == null)
        {
            throw new AssertionException("Token alias can only be set for NFT Item.");
        }

        // Current Rule: Alias must be the seed name.
        var parts = collectionSymbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(parts.Length == 2, $"Incorrect collection symbol: {collectionSymbol}.");
        Assert(parts.Last() == TokenContractConstants.CollectionSymbolSuffix, "Incorrect collection symbol suffix.");
        Assert(alias == parts.First(), $"Alias for an item of {collectionSymbol} cannot be {alias}.");
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenAliasTests.cs (L358-378)
```csharp
    private TokenInfo NftCollection1155WithAliasInfo => new()
    {
        Symbol = "TP-",
        TokenName = "Trump Digital Trading Cards #1155",
        TotalSupply = TotalSupply,
        Decimals = 0,
        Issuer = DefaultAddress,
        IssueChainId = _chainId,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                {
                    NftCollectionMetaFields.ImageUrlKey,
                    "https://i.seadn.io/gcs/files/0f5cdfaaf687de2ebb5834b129a5bef3.png?auto=format&w=3840"
                },
                { NftCollectionMetaFields.NftType, NftType },
                { TokenAliasExternalInfoKey, "{\"TP-31175\":\"TP\"}" }
            }
        }
    };
```
