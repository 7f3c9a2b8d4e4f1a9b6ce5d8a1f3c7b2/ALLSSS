### Title
Signature Replay Vulnerability in ProposeNewContract Allows Multiple Proposals with Single Deployer Self-Signature

### Summary
The `ProposeNewContract` function contains a signature replay vulnerability when deployers self-sign their `ContractOperation` rather than using a delegate signer. The `RemoveOneTimeSigner` call only prevents replay of delegate signer signatures, but deployer self-signatures bypass this protection and can be reused to create multiple governance proposals with different categories, causing governance resource exhaustion and operational confusion.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:**

The signature validation logic has two authentication paths: [2](#0-1) 

Path A: `recoveredAddress == contractOperation.Deployer` (deployer self-signs)
Path B: `State.SignerMap[contractOperation.Deployer] == recoveredAddress` (delegate signer)

After validation, the one-time signer is removed: [3](#0-2) [4](#0-3) 

**Why Protection Fails:**

For Path A (deployer self-signs):
- Validation succeeds because the recovered address equals the deployer address directly
- `RemoveOneTimeSigner` removes `SignerMap[deployer]`, but this mapping was never required for validation
- On replay: validation STILL succeeds via Path A since `recoveredAddress == deployer` remains true

For Path B (delegate signer):
- Validation requires `SignerMap[deployer]` to match the recovered address
- `RemoveOneTimeSigner` removes this mapping
- On replay: validation fails because `SignerMap[deployer]` is now null

**Signature Coverage Gap:**

The signature only covers specific fields: [5](#0-4) 

Notably, the signature does NOT cover:
- `Category` field in `ContractDeploymentInput`
- Full code bytes (only codeHash)

This allows an attacker to replay the same signature with different categories.

**Proposal Hash Calculation:**

Each proposal generates a unique hash from the entire input: [6](#0-5) [7](#0-6) 

Different categories produce different proposal hashes, so the "Already proposed" check passes: [8](#0-7) 

### Impact Explanation

**Governance Resource Exhaustion:**
An attacker with access to a single valid deployer self-signature can create unlimited governance proposals by varying the `Category` field. Each proposal:
- Consumes governance voting resources (block producers must review and vote)
- Creates proposal queue congestion
- Requires storage and processing overhead

**Operational Confusion:**
Multiple proposals for essentially the same contract (same code, deployer, salt, and computed address) but with different categories cause:
- Confusion about which category is correct for the contract
- Wasted code review effort by security auditors and block producers
- Risk of approving wrong category variant

**Severity Justification:**
HIGH severity because:
- Directly impacts critical governance operations
- No value extraction but enables governance DoS
- Low attack complexity once signature obtained
- Affects system-wide contract deployment process

### Likelihood Explanation

**Attack Prerequisites:**
1. Attacker needs one valid `ContractOperation` signature where deployer self-signed
2. Common case: Deployers frequently self-sign rather than using delegate signers, as shown in tests: [9](#0-8) 

**Attack Complexity:**
LOW - The attacker only needs to:
1. Obtain or create one valid deployer self-signature for any contract operation
2. Submit multiple `ProposeNewContract` transactions with same signature but different `Category` values
3. Each transaction succeeds and creates a separate governance proposal

**Feasibility Conditions:**
- Public method accessible to any user
- No rate limiting on proposal creation per deployer/signature
- Signature can be obtained legitimately by the deployer or intercepted
- Time window exists between proposal and execution for exploitation

**Detection Constraints:**
- Difficult to detect automatically since each proposal has valid signature
- Only becomes apparent when reviewing multiple similar proposals
- No on-chain mechanism to prevent this pattern

**Probability:** HIGH - Deployer self-signatures are common, and attack is trivial to execute once signature is obtained.

### Recommendation

**Code-Level Mitigation:**

Add a nonce or signature tracking mechanism for deployer self-signatures:

```solidity
// In BasicContractZeroState.cs, add:
public MappedState<Address, Hash, BoolState> UsedSignatures { get; set; }

// In ValidateContractOperation, add after line 412:
var signatureHash = HashHelper.ComputeFrom(contractOperation.Signature);
Assert(State.UsedSignatures[contractOperation.Deployer][signatureHash] != true, 
    "Signature already used.");
State.UsedSignatures[contractOperation.Deployer][signatureHash] = true;
```

**Alternative Fix:**

Include `Category` in the signature computation: [5](#0-4) 

Modify to include category in the signed data structure.

**Invariant Checks:**
- Each `ContractOperation` signature must be usable exactly once, regardless of authentication path
- Signature tracking must be independent of `SignerMap` for deployer self-signatures

**Test Cases:**
1. Test deployer self-signature cannot be reused with same category (should fail: "Already proposed")
2. Test deployer self-signature cannot be reused with different category (should fail: "Signature already used")
3. Test delegate signer signature cannot be reused (already prevented, verify no regression)
4. Test signature tracking persists across blocks/transactions

### Proof of Concept

**Initial State:**
- Deployer address: `D`
- Valid contract code with hash: `H`
- Salt: `S`
- ChainId: `C`

**Step 1:** Deployer creates self-signature
```
signature = Sign(PrivateKey_D, Hash(ChainId=C, CodeHash=H, Deployer=D, Salt=S, Version=1))
contractOperation = ContractOperation(ChainId=C, CodeHash=H, Deployer=D, Salt=S, Version=1, Signature=signature)
```

**Step 2:** Submit first proposal
```
ProposeNewContract(ContractDeploymentInput(Code=code_with_hash_H, Category=1, ContractOperation=contractOperation))
```
- Validation passes: recovered address == D ✓
- `RemoveOneTimeSigner(D)` removes `SignerMap[D]` (was likely null)
- Proposal 1 created with proposalHash1 = Hash(code, category=1, contractOperation)

**Step 3:** Replay with different category
```
ProposeNewContract(ContractDeploymentInput(Code=code_with_hash_H, Category=2, ContractOperation=contractOperation))
```
- Validation passes: recovered address == D ✓ (STILL VALID!)
- Proposal 2 created with proposalHash2 = Hash(code, category=2, contractOperation) ≠ proposalHash1

**Step 4:** Repeat unlimited times
```
ProposeNewContract with Category=3, same signature ✓
ProposeNewContract with Category=4, same signature ✓
... unlimited proposals created
```

**Expected Result:** Only first proposal should succeed, subsequent ones should fail with "Signature already used"

**Actual Result:** All proposals succeed, creating multiple governance proposals with single signature

**Success Condition:** Multiple distinct governance proposals exist for same deployer/salt/code but different categories, all using identical `ContractOperation` signature.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L122-173)
```csharp
    public override Hash ProposeNewContract(ContractDeploymentInput input)
    {
        // AssertDeploymentProposerAuthority(Context.Sender);
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();

        if (input.ContractOperation != null)
        {
            ValidateContractOperation(input.ContractOperation, 0, codeHash);
            
            // Remove one time signer if exists. Signer is only needed for validating signature.
            RemoveOneTimeSigner(input.ContractOperation.Deployer);
            
            AssertContractAddressAvailable(input.ContractOperation.Deployer, input.ContractOperation.Salt);
        }

        // Create proposal for deployment
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName =
                    nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.ProposeContractCodeCheck),
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(DeploySmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = input.Category,
                    IsSystemContract = false
                }.ToByteString(),
                OrganizationAddress = State.ContractDeploymentController.Value.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
            },
            OriginProposer = Context.Sender
        };
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput.ToByteString());

        Context.Fire(new ContractProposed
        {
            ProposedContractInputHash = proposedContractInputHash
        });

        return proposedContractInputHash;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L175-178)
```csharp
    private Hash CalculateHashFromInput(IMessage input)
    {
        return HashHelper.ComputeFrom(input);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L408-412)
```csharp
        var recoveredAddress = RecoverAddressFromSignature(contractOperation);

        Assert(
            recoveredAddress == contractOperation.Deployer ||
            State.SignerMap[contractOperation.Deployer] == recoveredAddress, "Invalid signature.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L423-433)
```csharp
    private Hash ComputeContractOperationHash(ContractOperation contractOperation)
    {
        return HashHelper.ComputeFrom(new ContractOperation
        {
            ChainId = contractOperation.ChainId,
            CodeHash = contractOperation.CodeHash,
            Deployer = contractOperation.Deployer,
            Salt = contractOperation.Salt,
            Version = contractOperation.Version
        }.ToByteArray());
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L435-438)
```csharp
    private void RemoveOneTimeSigner(Address address)
    {
        State.SignerMap.Remove(address);
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractTests_Deterministic.cs (L465-491)
```csharp
    private async Task<Address> DeployContractOnMainChain()
    {
        var mainChainId = Tester.GetChainAsync().Result.Id;
        var code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TestContract.BasicFunction")).Value);

        var contractDeploymentInput = new ContractDeploymentInput
        {
            Category = KernelConstants.DefaultRunnerCategory, // test the default runner
            Code = code,
            ContractOperation = new ContractOperation
            {
                ChainId = mainChainId,
                CodeHash = HashHelper.ComputeFrom(code.ToByteArray()),
                Deployer = CreatorAddress,
                Salt = HashHelper.ComputeFrom("test"),
                Version = 1,
                Signature = GenerateContractSignature(CreatorKeyPair.PrivateKey, mainChainId,
                    HashHelper.ComputeFrom(code.ToByteArray()), CreatorAddress, HashHelper.ComputeFrom("test"), 1)
            }
        };

        var contractAddress =
            await DeployAsync(Tester, ParliamentAddress, BasicContractZeroAddress, contractDeploymentInput);
        contractAddress.ShouldNotBeNull();

        return contractAddress;
    }
```
