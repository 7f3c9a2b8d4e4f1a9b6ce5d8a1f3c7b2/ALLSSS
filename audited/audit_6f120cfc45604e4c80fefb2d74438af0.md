# Audit Report

## Title
Ghost Vote Counting Vulnerability: Removed Members' Votes Still Count Toward MinimalVoteThreshold

## Summary
The Association contract contains a critical inconsistency in vote counting logic. When checking if the MinimalVoteThreshold is reached, the contract counts all votes including those from removed members, but when checking abstention/rejection thresholds, it only counts current members. This allows proposals to pass with insufficient participation from current organization members by exploiting ghost votes from members removed after voting.

## Finding Description

The vulnerability exists in the threshold checking logic where vote counting is inconsistent across different checks.

**The Inconsistency:**

When checking rejection thresholds, the contract filters to only count current members: [1](#0-0) 

When checking abstention thresholds, the contract also filters to only count current members: [2](#0-1) 

When checking approval counts, the contract filters to only count current members: [3](#0-2) 

**However**, when checking if MinimalVoteThreshold is reached, the contract counts ALL votes without filtering by current membership: [4](#0-3) 

**Root Cause:**

The proposal stores votes as address lists that are never cleaned when members are removed: [5](#0-4) 

When members are removed, their past votes remain in the proposal: [6](#0-5) 

The release process relies on these threshold checks: [7](#0-6) 

**Why Protections Fail:**

Members must be current members when voting: [8](#0-7) 

However, there is no mechanism to invalidate or recount votes after member removal. The unfiltered count at lines 56-57 treats removed members' votes as valid participation.

## Impact Explanation

**Severity: HIGH**

This vulnerability breaks the fundamental governance invariant that thresholds represent current member participation. 

**Concrete Scenario:**
- Organization with 10 members
- Thresholds: MinimalVoteThreshold=8, MinimalApprovalThreshold=6, MaximalAbstentionThreshold=1
- 3 members abstain on a proposal
- Organization removes these 3 members (7 members remain)
- 6 current members approve
- Actual current participation: 6/7 members (85.7%)
- Counted participation: 9 votes total (6 approvals + 3 ghost abstentions)
- Proposal passes MinimalVoteThreshold check (9 â‰¥ 8) despite only 6/7 current members voting

**Affected Parties:**
- All Association-governed organizations
- Treasury releases, configuration changes, and other critical protocol operations controlled by Association organizations
- Multi-signature operations relying on accurate member participation tracking

The vulnerability enables unauthorized proposal execution through governance manipulation and makes the MinimalVoteThreshold security guarantee meaningless.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attacker Requirements:**
- Control of organization majority to remove members (this is legitimate governance)
- Ability to coordinate voting sequences
- All steps use standard public methods with normal access control

**Attack Complexity:**
- Multiple coordinated transactions required
- Must time member removals between voting and release
- However, all operations are straightforward public methods

**Natural Occurrence:**
This vulnerability can be triggered even without malicious intent during normal member turnover, making it particularly dangerous. When organizations naturally remove inactive members or rotate membership, existing proposals can inadvertently pass with insufficient current member participation.

**Detection:**
Difficult to detect as votes and member changes appear legitimate separately. The inconsistency is only visible when analyzing the threshold calculation logic.

## Recommendation

Modify the MinimalVoteThreshold check to filter votes by current membership, consistent with other threshold checks:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter total votes to only count current members
    var currentMemberVotes = 
        proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
        proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
        proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached =
        currentMemberVotes >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

This ensures that MinimalVoteThreshold represents actual current member participation, maintaining the security invariant that all thresholds reflect the current organization state.

## Proof of Concept

```csharp
[Fact]
public async Task GhostVote_MinimalVoteThreshold_Bypass_Test()
{
    // Setup: Organization with 10 members
    var minimalApprovalThreshold = 6;
    var minimalVoteThreshold = 8;
    var maximalAbstentionThreshold = 1;
    var maximalRejectionThreshold = 1;
    
    var allMembers = new[] { Reviewer1, Reviewer2, Reviewer3, 
        Address.FromPublicKey(SampleECKeyPairs.KeyPairs[0].PublicKey),
        Address.FromPublicKey(SampleECKeyPairs.KeyPairs[1].PublicKey),
        Address.FromPublicKey(SampleECKeyPairs.KeyPairs[2].PublicKey),
        Address.FromPublicKey(SampleECKeyPairs.KeyPairs[3].PublicKey),
        Address.FromPublicKey(SampleECKeyPairs.KeyPairs[4].PublicKey),
        Address.FromPublicKey(SampleECKeyPairs.KeyPairs[5].PublicKey),
        Address.FromPublicKey(SampleECKeyPairs.KeyPairs[6].PublicKey)
    };
    
    var organizationAddress = await CreateOrganizationWithMembersAsync(
        allMembers, minimalApprovalThreshold, minimalVoteThreshold,
        maximalAbstentionThreshold, maximalRejectionThreshold, Reviewer1);
    
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // Step 1: Three members abstain
    await AbstainAsync(SampleECKeyPairs.KeyPairs[0], proposalId);
    await AbstainAsync(SampleECKeyPairs.KeyPairs[1], proposalId);
    await AbstainAsync(SampleECKeyPairs.KeyPairs[2], proposalId);
    
    // Step 2: Remove the three members who abstained
    var orgStub = GetAssociationContractTester(organizationAddress);
    await orgStub.RemoveMember.SendAsync(Address.FromPublicKey(SampleECKeyPairs.KeyPairs[0].PublicKey));
    await orgStub.RemoveMember.SendAsync(Address.FromPublicKey(SampleECKeyPairs.KeyPairs[1].PublicKey));
    await orgStub.RemoveMember.SendAsync(Address.FromPublicKey(SampleECKeyPairs.KeyPairs[2].PublicKey));
    
    // Step 3: Six current members approve (out of 7 remaining members)
    await ApproveAsync(Reviewer1KeyPair, proposalId);
    await ApproveAsync(Reviewer2KeyPair, proposalId);
    await ApproveAsync(Reviewer3KeyPair, proposalId);
    await ApproveAsync(SampleECKeyPairs.KeyPairs[3], proposalId);
    await ApproveAsync(SampleECKeyPairs.KeyPairs[4], proposalId);
    await ApproveAsync(SampleECKeyPairs.KeyPairs[5], proposalId);
    
    // Verify: Proposal should NOT pass (only 6/7 current members voted)
    // But it DOES pass because ghost votes count toward MinimalVoteThreshold
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    
    // Ghost vulnerability: ToBeReleased is true despite insufficient current member participation
    proposal.ToBeReleased.ShouldBeTrue(); // VULNERABILITY: This should be false!
    
    // Can successfully release with ghost votes
    var releaseResult = await AssociationContractStub.Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-53)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-59)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** protobuf/association_contract.proto (L91-96)
```text
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
