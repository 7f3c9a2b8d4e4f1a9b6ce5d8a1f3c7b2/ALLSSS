### Title
Auto-Distribution Break Statement Prevents Multiple Token Threshold Checks in TokenHolder Contract

### Summary
The `RegisterForProfits` function contains a break statement that exits the threshold checking loop after processing the first qualifying token, preventing subsequent tokens from being evaluated and distributed even when they also meet their thresholds. This causes profit distribution failures for multi-token schemes where multiple token balances exceed their configured thresholds simultaneously.

### Finding Description

In the `RegisterForProfits` function, the auto-distribution logic iterates through all configured thresholds in `scheme.AutoDistributeThreshold` to determine which tokens should be automatically distributed. [1](#0-0) 

The critical flaw occurs at line 199, where an unconditional `break` statement exits the foreach loop immediately after adding the first qualifying token to `distributedInput.AmountsMap`. This means:

1. The loop checks the first threshold's balance against its configured threshold value
2. If the balance meets or exceeds the threshold, it adds that token symbol to `AmountsMap` with value 0
3. The break statement executes, terminating the loop
4. All remaining thresholds are never evaluated

The `AutoDistributeThreshold` field is defined as a `map<string, int64>` that can contain multiple token symbols with different threshold values. [2](#0-1) 

The downstream `DistributeProfits` function in the Profit contract only processes tokens explicitly listed in the `AmountsMap` parameter. [3](#0-2) 

This means tokens not added to `AmountsMap` due to the premature loop exit will not be distributed, even if their balances exceed their configured thresholds.

### Impact Explanation

**Direct Fund Impact - Reward Misallocation:**
When multiple token types accumulate in a profit scheme's virtual address and multiple thresholds are simultaneously met, only the first token encountered in the dictionary iteration will be distributed. Other qualifying tokens remain locked in the virtual address indefinitely, unable to be auto-distributed to beneficiaries.

**Affected Scenarios:**
- Multi-token profit schemes configured with thresholds like `{"ELF": 1000, "USDT": 500, "BTC": 0.1}`
- When ELF reaches 2000, USDT reaches 1000, and BTC reaches 0.2, only the first token checked will be distributed
- The other tokens' profits are trapped until manual distribution is triggered or different auto-distribution conditions are met

**Severity Justification:**
This is a Medium severity issue because:
1. It prevents intended profit distribution functionality
2. Funds are not stolen but become inaccessible through the auto-distribution mechanism
3. Manual intervention by the scheme manager is required to distribute the stuck profits
4. The issue affects any scheme using multiple token thresholds, which is a standard use case for diversified profit schemes

### Likelihood Explanation

**Reachable Entry Point:**
`RegisterForProfits` is a public method callable by any user who wants to lock tokens and register for profit distribution. [4](#0-3) 

**Feasible Preconditions:**
1. A profit scheme must be created with multiple token symbols in `AutoDistributeThreshold`
2. Multiple token types must be contributed to the scheme
3. Multiple tokens must simultaneously exceed their configured thresholds
4. A user calls `RegisterForProfits`

These conditions are realistic and expected in production:
- Multi-token profit schemes are a standard feature for projects that accept various payment tokens
- The test suite demonstrates this exact scenario with two token thresholds [5](#0-4) 

**Execution Practicality:**
The bug triggers automatically during normal operation—no special manipulation required. When any user calls `RegisterForProfits` and the threshold conditions are met, the break statement executes.

**Probability:**
High probability in multi-token schemes. As profit schemes accumulate various token types over time, it's expected that multiple thresholds would be reached simultaneously, especially after periods of inactivity.

### Recommendation

**Code-Level Mitigation:**
Remove the break statement at line 199 to allow the loop to check all configured thresholds:

```csharp
foreach (var threshold in scheme.AutoDistributeThreshold)
{
    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
    {
        Owner = virtualAddress,
        Symbol = threshold.Key
    }).Balance;
    if (balance < threshold.Value) continue;
    if (distributedInput == null)
        distributedInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
    distributedInput.AmountsMap[threshold.Key] = 0;
    // Remove the break statement here
}
```

**Invariant Check:**
Add a test assertion to verify that when multiple thresholds are configured and met, all qualifying tokens are added to the distribution map before `DistributeProfits` is called.

**Regression Prevention:**
Enhance the existing test `RegisterForProfits_With_Auto_Distribute_Test` to explicitly verify that both tokens in the profit map have non-zero claimable amounts, confirming both were distributed. [5](#0-4) 

### Proof of Concept

**Initial State:**
1. Create a TokenHolder scheme with multiple thresholds:
   - ELF: 1000 tokens
   - USDT: 500 tokens
2. Contribute profits to the scheme:
   - Contribute 1500 ELF to virtual address
   - Contribute 800 USDT to virtual address
3. Both balances exceed their thresholds (ELF: 1500 > 1000, USDT: 800 > 500)

**Exploitation Steps:**
1. User calls `RegisterForProfits` with amount and scheme manager
2. Auto-distribution logic executes at line 178-206
3. Loop iterates through thresholds (order depends on dictionary iteration)
4. First threshold checked (e.g., ELF):
   - Balance 1500 >= threshold 1000 → true
   - Adds ELF to `distributedInput.AmountsMap`
   - **Break statement executes at line 199**
5. Second threshold (USDT) is never checked
6. Only ELF is distributed via `DistributeProfits`

**Expected vs Actual Result:**
- **Expected:** Both ELF and USDT should be distributed since both meet their thresholds
- **Actual:** Only ELF is distributed; 800 USDT remains in virtual address undistributed

**Success Condition:**
Query the scheme's virtual address balance after `RegisterForProfits` completes. The USDT balance will still be 800, demonstrating it was not distributed despite exceeding its threshold of 500.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-209)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

        // Check auto-distribute threshold.
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }

        return new Empty();
    }
```

**File:** protobuf/token_holder_contract.proto (L68-69)
```text
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 3;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L433-445)
```csharp
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L359-419)
```csharp
    public async Task RegisterForProfits_With_Auto_Distribute_Test()
    {
        var amount = 1000L;
        var nativeTokenSymbol = TokenHolderContractTestConstants.NativeTokenSymbol;
        var tokenA = "JUN";
        await StarterCreateIssueAndApproveTokenAsync(tokenA, 1000000L, 100000L);
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = nativeTokenSymbol,
            AutoDistributeThreshold =
            {
                { nativeTokenSymbol, amount },
                { tokenA, amount }
            }
        });
        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Amount = amount,
            Symbol = nativeTokenSymbol
        });
        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Amount = amount,
            Symbol = tokenA
        });
        var beforeLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
        {
            Amount = amount,
            SchemeManager = Starter
        });
        var afterLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        beforeLockBalance.ShouldBe(afterLockBalance.Add(amount));
        var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
        {
            Manager = Starter
        });
        var schemeId = schemeIds.SchemeIds.First();
        var profitMap = await ProfitContractStub.GetProfitsMap.CallAsync(new Profit.ClaimProfitsInput
        {
            Beneficiary = Starter,
            SchemeId = schemeId
        });
        profitMap.Value.Count.ShouldBe(2);
        profitMap.Value.ContainsKey(nativeTokenSymbol).ShouldBeTrue();
        profitMap.Value[nativeTokenSymbol].ShouldBe(amount);
        var schemeInfoInProfit = await ProfitContractStub.GetScheme.CallAsync(schemeId);
        var schemeInfoInTokenHolder = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
        schemeInfoInProfit.CurrentPeriod.ShouldBe(2);
        schemeInfoInTokenHolder.Period.ShouldBe(2);
    }
```
