### Title
Time-of-Check-Time-of-Use Vulnerability: Removed Proposers Can Still Release Approved Proposals

### Summary
The Referendum contract (and similarly Parliament and Association contracts) only validates proposer whitelist membership at proposal creation time via `AssertIsAuthorizedProposer()`, but not at release time. This allows a proposer who has been removed from the ProposerWhiteList to still release proposals they created before removal, enabling unauthorized proposal execution and bypassing governance controls.

### Finding Description

**Root Cause:**

The `AssertIsAuthorizedProposer()` function validates that a proposer is in the organization's ProposerWhiteList, but this check only occurs during proposal creation: [1](#0-0) [2](#0-1) 

However, at release time, the `Release()` function only verifies that the caller is the original proposer, without re-checking whitelist membership: [3](#0-2) 

Organizations can update their ProposerWhiteList at any time through `ChangeOrganizationProposerWhiteList()`: [4](#0-3) 

**Why Protections Fail:**

The authorization check happens at two different times:
1. **Time of Check (CreateProposal):** Whitelist membership is validated
2. **Time of Use (Release):** Only proposer identity is validated, not current whitelist status

This TOCTOU vulnerability means whitelist changes between proposal creation and release have no effect on existing proposals. The same vulnerability exists in Parliament and Association contracts: [5](#0-4) [6](#0-5) 

### Impact Explanation

**Concrete Harm:**
- **Unauthorized Governance Execution:** A proposer removed from the whitelist for malicious behavior, compromise, or policy reasons retains the ability to execute previously created proposals
- **Governance Bypass:** Organizations lose the ability to revoke proposal release rights from problematic proposers
- **Execution of Malicious Proposals:** If a proposer is identified as malicious and removed from the whitelist, they can still release approved proposals that may:
  - Transfer funds from organization-controlled addresses
  - Change critical contract configurations
  - Execute arbitrary contract calls with organization authority

**Who is Affected:**
- All organizations using Referendum, Parliament, or Association governance contracts
- Stakeholders who voted on proposals assuming the proposer's current authorization status matters

**Severity Justification:**
Medium severity because:
1. Proposals still require threshold approval from voters
2. Organizations have tools to clear expired proposals
3. However, the vulnerability enables persistent unauthorized access and governance bypass
4. Impact scales with the authority and privileges of the organization

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Initially be a legitimate whitelisted proposer
2. Create one or more proposals while authorized
3. Wait for proposals to receive sufficient approval votes
4. After being removed from whitelist, call `Release()` on approved proposals

**Attack Complexity:** Low
- Single function call to `Release()` with proposal ID
- No special privileges or complex state manipulation required
- Works consistently across all ACS3 governance contracts

**Feasibility Conditions:**
- **Realistic Scenario:** Organizations regularly update ProposerWhiteLists to:
  - Remove compromised accounts
  - Revoke access from departed members
  - Respond to malicious behavior
  - Update governance policies
- **No Unusual Prerequisites:** Standard governance workflow
- **Detection Difficult:** Removed proposers retain valid `proposal.Proposer` status

**Economic Rationality:**
- Cost: Only gas fees for `Release()` transaction
- Benefit: Can execute proposals with organization's authority even after removal
- Rational for attackers to create multiple proposals before expected removal

**Probability:** Medium-High
Organizations routinely change whitelist membership, making this a likely scenario in production environments.

### Recommendation

**Code-Level Mitigation:**

Add whitelist re-validation in the `Release()` function. Update `Referendum_Helper.cs`:

```csharp
private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
{
    var organization = State.Organizations[organizationAddress];
    Assert(organization != null, "Organization not found.");
    Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
}
```

Then modify `Release()` in `Referendum.cs` to add:

```csharp
public override Empty Release(Hash input)
{
    var proposal = GetValidProposal(input);
    Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
    
    // Add whitelist re-validation
    AssertIsAuthorizedProposer(proposal.OrganizationAddress, proposal.Proposer);
    
    var organization = State.Organizations[proposal.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
    // ... rest of release logic
}
```

**Apply the same fix to:**
- `Parliament.cs` Release() method
- `Association.cs` Release() method

**Invariant Checks to Add:**
- At release time: `proposal.Proposer ∈ organization.ProposerWhiteList`
- Ensure this invariant is documented in ACS3 standard

**Test Cases to Prevent Regression:**

1. **Test_Release_After_Whitelist_Removal:**
   - Create organization with proposer A in whitelist
   - Proposer A creates proposal
   - Proposal receives sufficient approvals
   - Update whitelist to remove proposer A
   - Verify proposer A **CANNOT** release the proposal (should fail with "Unauthorized to propose")

2. **Test_Release_After_Whitelist_Addition:**
   - Create proposal with proposer A (in whitelist)
   - Add proposer B to whitelist after proposal creation
   - Verify proposer B cannot release A's proposal (existing behavior)

3. **Test_Whitelist_Change_Does_Not_Affect_Current_Authorized_Proposers:**
   - Verify proposers remaining in updated whitelist can still release their proposals

### Proof of Concept

**Initial State:**
1. Organization created with ProposerWhiteList containing addresses [Alice, Bob]
2. Alice creates malicious Proposal_X targeting sensitive contract method
3. Proposal_X receives sufficient approval votes from token holders

**Attack Sequence:**

**Step 1:** Organization discovers Alice's malicious intent
```
ChangeOrganizationProposerWhiteList({proposers: [Bob]}) 
// Alice removed from whitelist
```

**Step 2:** Verify Alice cannot create NEW proposals
```
CreateProposal(..., proposer=Alice) 
// ✗ FAILS: "Unauthorized to propose."
```

**Step 3:** Alice releases previously created proposal
```
Release(Proposal_X, sender=Alice)
// ✓ SUCCEEDS despite Alice no longer in whitelist
```

**Expected Result:** Step 3 should fail with "Unauthorized to propose."

**Actual Result:** Step 3 succeeds, executing Proposal_X with organization authority

**Success Condition for Exploit:**
- Proposal_X executes successfully
- Malicious contract method is called with organization's virtual address as sender
- Alice maintains control over governance despite whitelist removal

**Evidence from Tests:**

Existing test shows whitelist changes prevent future proposal creation but doesn't test release permissions: [7](#0-6) 

Test confirms Release() only checks proposer identity, not whitelist: [8](#0-7)

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** test/AElf.Contracts.Referendum.Tests/ReferendumContractTest.cs (L599-616)
```csharp
    public async Task Release_WrongSender_Test()
    {
        var minimalApproveThreshold = 5000;
        var minimalVoteThreshold = 5000;
        var maximalRejectionThreshold = 10000;
        var maximalAbstentionThreshold = 10000;
        var organizationAddress = await CreateOrganizationAsync(minimalApproveThreshold, minimalVoteThreshold,
            maximalAbstentionThreshold, maximalRejectionThreshold, new[] { DefaultSender });
        var proposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
        var keyPair = Accounts[3].KeyPair;
        var amount = 5000;
        await ApproveAllowanceAsync(keyPair, amount, proposalId);
        await ApproveAsync(keyPair, proposalId);

        var referendumContractStub = GetReferendumContractTester(keyPair);
        var result = await referendumContractStub.Release.SendWithExceptionAsync(proposalId);
        result.TransactionResult.Error.Contains("No permission.").ShouldBeTrue();
    }
```

**File:** test/AElf.Contracts.Referendum.Tests/ReferendumContractTest.cs (L792-848)
```csharp
    public async Task Change_OrganizationProposalWhitelist_Test()
    {
        var minimalApproveThreshold = 5000;
        var minimalVoteThreshold = 5000;
        var maximalRejectionThreshold = 10000;
        var maximalAbstentionThreshold = 10000;
        var organizationAddress = await CreateOrganizationAsync(minimalApproveThreshold, minimalVoteThreshold,
            maximalAbstentionThreshold, maximalRejectionThreshold, new[] { DefaultSender });

        var whiteAddress = Accounts[3].Address;
        var proposerWhiteList = new ProposerWhiteList
        {
            Proposers = { whiteAddress }
        };

        ReferendumContractStub = GetReferendumContractTester(DefaultSenderKeyPair);
        var changeProposalId = await CreateReferendumProposalAsync(DefaultSenderKeyPair, proposerWhiteList,
            nameof(ReferendumContractStub.ChangeOrganizationProposerWhiteList), organizationAddress,
            ReferendumContractAddress);
        await ApproveAllowanceAsync(Accounts[3].KeyPair, minimalApproveThreshold, changeProposalId);
        await ApproveAsync(Accounts[3].KeyPair, changeProposalId);
        ReferendumContractStub = GetReferendumContractTester(DefaultSenderKeyPair);
        var releaseResult = await ReferendumContractStub.Release.SendAsync(changeProposalId);
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        //verify whiteList
        var verifyResult = await ReferendumContractStub.ValidateProposerInWhiteList.CallAsync(
            new ValidateProposerInWhiteListInput
            {
                OrganizationAddress = organizationAddress,
                Proposer = whiteAddress
            });
        verifyResult.Value.ShouldBeTrue();

        var timeStamp = TimestampHelper.GetUtcNow();
        var createInput = new CreateInput
        {
            Symbol = "NEW",
            Decimals = 2,
            TotalSupply = 10_0000,
            TokenName = "new token",
            Issuer = organizationAddress,
            IsBurnable = true
        };
        var createProposalInput = new CreateProposalInput
        {
            ContractMethodName = nameof(TokenContract.Create),
            ToAddress = TokenContractAddress,
            Params = createInput.ToByteString(),
            ExpiredTime = timeStamp ?? BlockTimeProvider.GetBlockTime().AddSeconds(1000),
            OrganizationAddress = organizationAddress
        };
        ReferendumContractStub = GetReferendumContractTester(DefaultSenderKeyPair);
        var result = await ReferendumContractStub.CreateProposal.SendWithExceptionAsync(createProposalInput);
        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        result.TransactionResult.Error.ShouldContain("Unauthorized to propose.");
    }
```
