### Title
Reentrancy Vulnerability Enabling Pricing Manipulation in TokenConverter Buy/Sell Operations

### Summary
The TokenConverter contract's `Buy` and `Sell` methods are vulnerable to reentrancy attacks that can cause inconsistent pricing. While `GetReturnFromPaid` and `GetAmountToPayFromReturn` are pure functions, the contract reads connector balances once, makes multiple external calls without reentrancy guards, then updates state later, creating a Time-Of-Check Time-Of-Use (TOCTOU) window. An attacker can exploit token transfer callbacks or Treasury donation flows to reenter the contract and execute trades at stale prices.

### Finding Description

The vulnerability exists in the TokenConverter contract's transaction flow:

**Buy Method Vulnerability:**
The `Buy` method calculates pricing using current connector balances, then makes external calls before updating state. [1](#0-0) 

**Sell Method Vulnerability:**
The `Sell` method has the same pattern - price calculation followed by external calls before state updates. [2](#0-1) 

**Root Cause:**
The pricing functions themselves are pure and use only input parameters. [3](#0-2) [4](#0-3) 

However, these parameters are derived from state (`GetSelfBalance`) that is read once but updated later, creating a TOCTOU vulnerability when combined with external calls.

**Reentrancy Vectors:**

1. **Token Transfer Callbacks**: The MultiToken contract supports transfer callbacks that execute arbitrary contract code during token transfers. [5](#0-4) 

These callbacks are invoked after balance updates but during the transfer flow. [6](#0-5) 

2. **Treasury Donation Flow**: When `HandleFee` donates to Treasury, if the token is non-native and can be sold, the Treasury calls back to `TokenConverter.Sell`. [7](#0-6) [8](#0-7) [9](#0-8) 

**No Reentrancy Protection:**
The TokenConverter contract has no reentrancy guard state variable or locks. [10](#0-9) 

### Impact Explanation

**Direct Financial Impact:**
- Attackers can execute trades at stale prices by reentering during external calls
- The reentrant transaction sees connector balances that don't reflect the outer transaction's pending changes
- This allows arbitrage opportunities where prices don't match actual market state
- Repeated exploitation can drain reserves or extract value from the converter pool

**Severity Factors:**
- Bancor pricing relies on accurate reserve ratios; stale balances violate this invariant
- The deposit balance update happens mid-transaction, creating asymmetric state visibility
- No slippage protection beyond user-specified limits can prevent this timing attack
- All users of TokenConverter are affected as pricing integrity is compromised

**Quantified Damage:**
The impact depends on reserve sizes and price differences between stale and current state. With significant reserves (e.g., 1M+ ELF), even small percentage discrepancies could yield substantial profits per attack.

### Likelihood Explanation

**Exploitability Conditions:**
The attack requires one of these preconditions:

1. **Token Transfer Callbacks**: Tokens must have `TransferCallbackExternalInfoKey` configured in their ExternalInfo, pointing to attacker-controlled contracts. Tokens can be created with arbitrary ExternalInfo during token creation. [11](#0-10) 

2. **Non-Native Base Token**: If TokenConverter is initialized with a non-native base token that can be converted, the Treasury donation flow triggers reentrancy. [12](#0-11) 

**Attack Complexity:**
- Entry point is public (`Buy`/`Sell` methods)
- Attack steps are straightforward once reentrancy is achieved
- No special permissions required beyond normal trading access
- Exploitation cost is transaction fees plus capital for trades

**Feasibility Assessment:**
- **If using native ELF as base and system tokens without callbacks**: Low likelihood (requires attacker to create and list malicious tokens)
- **If tokens support callbacks or non-native base**: High likelihood (direct exploitation path exists)
- The vulnerability EXISTS in the code architecture regardless of current deployment configuration

### Recommendation

**Immediate Mitigation:**
1. Add a reentrancy guard to TokenConverterContractState:
```
public BoolState IsLocked { get; set; }
```

2. Implement a modifier pattern or guard checks in `Buy` and `Sell`:
    - Set `IsLocked` to true at method entry
    - Assert `!IsLocked` at method entry
    - Set `IsLocked` to false before return
    - Apply to all state-changing methods

3. Alternative: Use the Checks-Effects-Interactions pattern - update all state BEFORE making external calls:
    - Move `State.DepositBalance` updates before `HandleFee` and token transfers
    - Recalculate any derived values after state changes

**Additional Protections:**
1. Validate that critical tokens (ELF, resource tokens) don't have transfer callbacks or have callbacks only to trusted system contracts
2. Add integration tests specifically for reentrancy scenarios
3. Consider using framework-level reentrancy protection if available in AElf runtime

**Test Cases:**
1. Attempt to call `Buy` during callback from token transfer
2. Attempt to call `Sell` during Treasury donation callback
3. Verify state updates occur atomically before external calls
4. Test that reentrancy attempts revert with appropriate error

### Proof of Concept

**Initial State:**
- TokenConverter has CPU-ELF pair with balances: 1000 ELF deposit, 1000 CPU
- Attacker creates a token with transfer callback pointing to attack contract
- Or TokenConverter uses non-native base token requiring conversion

**Attack Sequence:**
1. Attacker calls `Buy(CPU, amount=100)`
2. TokenConverter calculates price: `amountToPay = 110 ELF` (based on current 1000:1000 ratio)
3. `HandleFee(11 ELF)` is called
4. During `TransferFrom` for fee (if callback exists) OR during Treasury `Donate`/`ConvertToNativeToken`:
   - Attack contract receives callback
   - Attack contract calls `Sell(CPU, amount=100)`
   - `Sell` reads balances: still 1000 ELF, 1000 CPU (outer `Buy` hasn't updated yet)
   - `Sell` calculates `amountToReceive = 90 ELF` (based on stale balances)
   - `Sell` completes, updating state
5. Outer `Buy` resumes and completes with inconsistent state

**Expected Result:** Transactions should be atomic or revert on reentrancy attempt

**Actual Result:** Both transactions complete with pricing based on stale state at reentrancy point, allowing arbitrage exploitation

**Success Condition:** Attacker profits from price difference between outer and reentrant transaction pricing

---

**Notes:**
This vulnerability's practical exploitability depends on deployment configuration (whether tokens have callbacks, which base token is used). However, the architectural flaw exists in the code and creates risk. Defense-in-depth requires reentrancy guards even if current configuration appears safe, as configuration can change or new tokens can be added with callbacks.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L27-56)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(IsValidBaseSymbol(input.BaseTokenSymbol), $"Base token symbol is invalid. {input.BaseTokenSymbol}");
        Assert(State.TokenContract.Value == null, "Already initialized.");
        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        State.BaseTokenSymbol.Value = !string.IsNullOrEmpty(input.BaseTokenSymbol)
            ? input.BaseTokenSymbol
            : Context.Variables.NativeSymbol;
        var feeRate = AssertedDecimal(input.FeeRate);
        Assert(IsBetweenZeroAndOne(feeRate), "Fee rate has to be a decimal between 0 and 1.");
        State.FeeRate.Value = feeRate.ToString(CultureInfo.InvariantCulture);
        foreach (var connector in input.Connectors)
        {
            if (connector.IsDepositAccount)
            {
                Assert(!string.IsNullOrEmpty(connector.Symbol), "Invalid connector symbol.");
                AssertValidConnectorWeight(connector);
            }
            else
            {
                Assert(IsValidSymbol(connector.Symbol), "Invalid symbol.");
                AssertValidConnectorWeight(connector);
            }

            State.Connectors[connector.Symbol] = connector;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-159)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-212)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
        // Transfer sold token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
        Context.Fire(new TokenSold
        {
            Symbol = input.Symbol,
            SoldAmount = input.Amount,
            BaseAmount = amountToReceive,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L214-258)
```csharp
    private void HandleFee(long fee)
    {
        var donateFee = fee.Div(2);
        var burnFee = fee.Sub(donateFee);

        // Donate 0.5% fees to Treasury
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = donateFee
            });
        if (State.DividendPoolContract.Value == null)
            State.DividendPoolContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = State.BaseTokenSymbol.Value,
            Spender = State.DividendPoolContract.Value,
            Amount = donateFee
        });
        State.DividendPoolContract.Donate.Send(new DonateInput
        {
            Symbol = State.BaseTokenSymbol.Value,
            Amount = donateFee
        });

        // Transfer to self contract then burn
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = burnFee
            });
        State.TokenContract.Burn.Send(
            new BurnInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                Amount = burnFee
            });
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-94)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L174-251)
```csharp
    public override Empty Donate(DonateInput input)
    {
        Assert(input.Amount > 0, "Invalid amount of donating. Amount needs to be greater than 0.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();

        if (State.TokenConverterContract.Value == null)
            State.TokenConverterContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);

        var isNativeSymbol = input.Symbol == Context.Variables.NativeSymbol;
        var canExchangeWithNativeSymbol =
            isNativeSymbol ||
            State.TokenConverterContract.IsSymbolAbleToSell
                .Call(new StringValue { Value = input.Symbol }).Value;

        if (Context.Sender != Context.Self)
            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = Context.Self,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = "Donate to treasury."
            });

        var needToConvert = !isNativeSymbol && canExchangeWithNativeSymbol;
        if (needToConvert)
        {
            ConvertToNativeToken(input.Symbol, input.Amount);
        }
        else
        {
            State.TokenContract.Approve.Send(new ApproveInput
            {
                Symbol = input.Symbol,
                Amount = input.Amount,
                Spender = State.ProfitContract.Value
            });

            State.ProfitContract.ContributeProfits.Send(new ContributeProfitsInput
            {
                SchemeId = State.TreasuryHash.Value,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            var donatesOfCurrentBlock = State.DonatedDividends[Context.CurrentHeight];
            if (donatesOfCurrentBlock != null && Context.Variables.NativeSymbol == input.Symbol &&
                donatesOfCurrentBlock.Value.ContainsKey(Context.Variables.NativeSymbol))
                donatesOfCurrentBlock.Value[Context.Variables.NativeSymbol] = donatesOfCurrentBlock
                    .Value[Context.Variables.NativeSymbol].Add(input.Amount);
            else
                donatesOfCurrentBlock = new Dividends
                {
                    Value =
                    {
                        { input.Symbol, input.Amount }
                    }
                };

            State.DonatedDividends[Context.CurrentHeight] = donatesOfCurrentBlock;

            Context.Fire(new DonationReceived
            {
                From = Context.Sender,
                Symbol = input.Symbol,
                Amount = input.Amount,
                PoolContract = Context.Self
            });
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L667-686)
```csharp
    private void ConvertToNativeToken(string symbol, long amount)
    {
        State.TokenContract.Approve.Send(new ApproveInput
        {
            Spender = State.TokenConverterContract.Value,
            Symbol = symbol,
            Amount = amount
        });

        State.TokenConverterContract.Sell.Send(new SellInput
        {
            Symbol = symbol,
            Amount = amount
        });

        Context.SendInline(Context.Self, nameof(DonateAll), new DonateAllInput
        {
            Symbol = Context.Variables.NativeSymbol
        });
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs (L9-22)
```csharp
public class TokenConverterContractState : ContractState
{
    internal TokenContractContainer.TokenContractReferenceState TokenContract { get; set; }
    internal ParliamentContractContainer.ParliamentContractReferenceState ParliamentContract { get; set; }
    internal DividendPoolContractContainer.DividendPoolContractReferenceState DividendPoolContract { get; set; }

    public StringState BaseTokenSymbol { get; set; }
    public StringState FeeRate { get; set; }
    public MappedState<string, Connector> Connectors { get; set; }
    public MappedState<string, MethodFees> TransactionFees { get; set; }
    public MappedState<string, long> DepositBalance { get; set; }
    public SingletonState<AuthorityInfo> ConnectorController { get; set; }
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```
