### Title
NFT Contract Method Fee Governance Bypass via Non-Functional ACS1 Implementation

### Summary
The NFT contract implements ACS1 (Transaction Fee Standard) with stub/no-op methods that neither read from nor write to state, making it impossible for governance to adjust method fees. Unlike all other system contracts which store fees in `State.TransactionFees` mappings, the NFT contract returns only hardcoded values, leaving most NFT operations with zero method fees and the Create operation permanently fixed at 100 ELF.

### Finding Description

The NFT contract's ACS1 implementation is fundamentally broken compared to proper implementations in other system contracts.

**NFT Contract - Broken Implementation:**

The `GetMethodFee()` method returns hardcoded values without reading from state: [1](#0-0) 

The `SetMethodFee()` method is a complete no-op that does nothing: [2](#0-1) 

The `ChangeMethodFeeController()` method is also a no-op: [3](#0-2) 

The NFT contract state has no `TransactionFees` mapping defined: [4](#0-3) 

**Proper Implementation - MultiToken Contract:**

The MultiToken contract's `GetMethodFee()` reads from state storage: [5](#0-4) 

The MultiToken contract's `SetMethodFee()` validates and stores fees in state: [6](#0-5) 

MultiToken defines the required state mapping: [7](#0-6) 

**Proper Implementation - Association Contract:**

The Association contract also properly implements state storage and reading: [8](#0-7) 

**Fee Enforcement Mechanism:**

When transactions execute, the system calls `GetMethodFee()` on the target contract to determine fees: [9](#0-8) 

**Root Cause:**

The NFT contract has 14+ public methods including Mint, Transfer, Burn, Approve, etc. (as defined in the proto file), but only Create has a hardcoded fee of 100 ELF. All other methods return empty `MethodFees()`, meaning they only pay size fees without method-specific base fees. Parliament governance cannot adjust these fees because `SetMethodFee()` does nothing.

### Impact Explanation

**1. Denial of Service Attack Vector:**
NFT operations (Mint, Transfer, TransferFrom, Approve, Burn, Assemble, Disassemble, Recast) have zero method fees - only paying minimal transaction size fees. An attacker can spam these operations at extremely low cost, causing:
- State bloat from excessive NFT minting/transfers
- Network congestion from high-volume low-fee transactions
- Resource exhaustion for nodes processing NFT operations

**2. Governance Authority Bypass:**
Parliament, which controls method fees for all other system contracts, has zero control over NFT contract fees. This violates the fundamental governance model where the Parliament default organization should control all method fee configurations through the ACS1 standard.

**3. Economic Inflexibility:**
The Create method is permanently hardcoded to 100 ELF (100_00000000 units), which cannot be adjusted for:
- Market conditions (if ELF price changes dramatically)
- Network congestion levels
- Policy decisions to encourage/discourage NFT protocol creation

**4. Protocol Inconsistency:**
All 14+ other system contracts (MultiToken, Parliament, Association, Economic, Election, etc.) have functional ACS1 implementations with state storage. Only the NFT contract is broken, creating an architectural vulnerability.

**Affected Users:**
- Network operators facing DoS attacks
- Governance participants unable to enforce fee policies
- Legitimate users competing with spam transactions
- Protocol economics undermined by uncontrolled fee structure

### Likelihood Explanation

**Exploitation Probability: HIGH**

**Reachable Entry Points:**
All NFT contract methods are publicly callable. The proto file defines 16 public RPC methods including Mint, Transfer, Burn, etc., all accessible without special privileges: [10](#0-9) 

**Attack Complexity: TRIVIAL**
No preconditions required:
- No special permissions needed
- No authentication required
- No economic barriers (minimal size fees only)
- No timing constraints

**Execution Practicality:**
An attacker can execute this immediately:
1. Call `Mint()` repeatedly with minimal token IDs → zero method fee, only size fee
2. Call `Transfer()` between controlled addresses → zero method fee
3. Call `Approve()`/`UnApprove()` repeatedly → zero method fee
4. Repeat thousands of times at negligible cost

**Economic Rationality:**
With size fees being the only cost (no method fees for most operations), an attacker can execute thousands of operations for minimal investment, making spam attacks economically viable.

**Detection Difficulty:**
The vulnerability is permanent and structural - it cannot be fixed without contract upgrade. Current governance has no mechanism to mitigate it through parameter changes.

### Recommendation

**Immediate Fix - Implement Proper ACS1 State Storage:**

1. Add `TransactionFees` state mapping to `NFTContractState.cs`:
```csharp
internal MappedState<string, MethodFees> TransactionFees { get; set; }
```

2. Implement `SetMethodFee()` with proper authorization and state writes (follow MultiToken pattern):
```csharp
public override Empty SetMethodFee(MethodFees input)
{
    // Validate fee tokens
    // Check MethodFeeController authorization
    // Store: State.TransactionFees[input.MethodName] = input;
    return new Empty();
}
```

3. Implement `GetMethodFee()` to read from state (follow MultiToken pattern):
```csharp
public override MethodFees GetMethodFee(StringValue input)
{
    return State.TransactionFees[input.Value] ?? new MethodFees();
}
```

4. Implement `ChangeMethodFeeController()` with proper state updates

5. Add `MethodFeeController` state similar to other contracts

6. Initialize default controller to Parliament's default organization

**Invariant Checks to Add:**
- Validate all ACS1 methods actually modify/read state in unit tests
- Assert that governance can successfully set and retrieve method fees
- Verify fees are actually charged by the fee enforcement plugin

**Test Cases to Prevent Regression:**
- Test setting fees for all NFT methods via Parliament proposal
- Test retrieving fees returns stored values, not hardcoded values
- Test fee changes take effect immediately
- Test unauthorized users cannot set fees
- Test method fee controller can be changed via governance

### Proof of Concept

**Initial State:**
- NFT contract deployed with current broken ACS1 implementation
- User has minimal ELF balance (just enough for size fees)

**Exploitation Steps:**

1. **Verify Current Broken State:**
   - Call `GetMethodFee("Mint")` → Returns empty `MethodFees()` (zero method fee)
   - Call `GetMethodFee("Transfer")` → Returns empty `MethodFees()` (zero method fee)
   - Call `GetMethodFeeController()` → Returns empty `AuthorityInfo()` (no controller)

2. **Attempt Governance Control (Fails):**
   - Parliament creates proposal to call `SetMethodFee()` with 10 ELF fee for Mint
   - Proposal passes and executes
   - Call `GetMethodFee("Mint")` again → Still returns empty (fee not stored)
   - **Expected:** Fee should be set to 10 ELF
   - **Actual:** Fee remains at zero (method did nothing)

3. **Execute Low-Cost Spam:**
   - Create NFT protocol with `Create()` → Pays 100 ELF (hardcoded)
   - Call `Mint()` 1000 times → Pays only size fees (no method fee)
   - Call `Transfer()` 1000 times → Pays only size fees (no method fee)
   - **Expected:** Should pay method fees per operation
   - **Actual:** Only pays minimal size fees, enabling cheap spam

4. **Verify Governance Bypass:**
   - Parliament has no mechanism to stop the spam by increasing fees
   - `SetMethodFee()` continues doing nothing regardless of governance
   - **Success Condition:** Attacker executes thousands of operations at minimal cost while governance remains powerless to adjust fees

**Quantified Impact:**
If size fee = 0.0001 ELF per transaction, attacker can execute 10,000 Mint operations for only 1 ELF, whereas with proper method fees (e.g., 0.1 ELF per Mint), the same spam would cost 1,000 ELF - a 1000x cost increase that makes attacks economically infeasible.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-11)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L13-16)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L1-46)
```csharp
﻿using AElf.Sdk.CSharp.State;
using AElf.Types;

namespace AElf.Contracts.NFT;

public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L37-52)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (new List<string>
            {
                nameof(ClaimTransactionFees), nameof(DonateResourceToken), nameof(ChargeTransactionFees),
                nameof(CheckThreshold), nameof(CheckResourceToken), nameof(ChargeResourceToken),
                nameof(CrossChainReceiveToken)
            }.Contains(input.Value))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        var fees = State.TransactionFees[input.Value];
        return fees;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L10-10)
```csharp
    internal MappedState<string, MethodFees> TransactionFees { get; set; }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L10-43)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }

    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }

    #region Views

    public override MethodFees GetMethodFee(StringValue input)
    {
        return State.TransactionFees[input.Value];
    }

    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-52)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
```

**File:** protobuf/nft_contract.proto (L22-66)
```text
    // Create a new nft protocol.
    rpc Create (CreateInput) returns (google.protobuf.StringValue) {
    }
    rpc CrossChainCreate (CrossChainCreateInput) returns (google.protobuf.Empty) {
    }
    // Mint (Issue) an amount of nft.
    rpc Mint (MintInput) returns (aelf.Hash) {
    }
    // Transfer nft to another address.
    rpc Transfer (TransferInput) returns (google.protobuf.Empty) {
    }
    // Transfer nft from one address to another.
    rpc TransferFrom (TransferFromInput) returns (google.protobuf.Empty) {
    }
    // Approve another address to transfer nft from own account.
    rpc Approve (ApproveInput) returns (google.protobuf.Empty) {
    }
    // De-approve.
    rpc UnApprove (UnApproveInput) returns (google.protobuf.Empty) {
    }
    // Approve or de-approve another address as the operator of all NFTs of a certain protocol.
    rpc ApproveProtocol (ApproveProtocolInput) returns (google.protobuf.Empty) {
    }
    // Destroy nfts.
    rpc Burn (BurnInput) returns (google.protobuf.Empty) {
    }
    // Lock several nfts and fts to mint one nft.
    rpc Assemble (AssembleInput) returns (aelf.Hash) {
    }
    // Disassemble one assembled nft to get locked nfts and fts back.
    rpc Disassemble (DisassembleInput) returns (google.protobuf.Empty) {
    }
    // Modify metadata of one nft.
    rpc Recast (RecastInput) returns (google.protobuf.Empty) {
    }

    rpc AddMinters (AddMintersInput) returns (google.protobuf.Empty) {
    }
    rpc RemoveMinters (RemoveMintersInput) returns (google.protobuf.Empty) {
    }
    
    rpc AddNFTType (AddNFTTypeInput) returns (google.protobuf.Empty) {
    }
    rpc RemoveNFTType (google.protobuf.StringValue) returns (google.protobuf.Empty) {
    }
```
