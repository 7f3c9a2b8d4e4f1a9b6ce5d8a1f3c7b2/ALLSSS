# Audit Report

## Title
Quadratic Voting Completely Bypassed Due to Unique VoteId Generation Per Vote Transaction

## Summary
The quadratic voting implementation in the Vote contract is fundamentally broken. Each vote transaction generates a unique VoteId based on the cumulative vote amount, causing the quadratic vote counter to reset to 1 for every vote. This allows any voter to cast unlimited votes at constant cost instead of the intended quadratic cost progression, completely defeating the fairness mechanism.

## Finding Description

The quadratic voting mechanism is designed to prevent vote concentration by making each successive vote from the same voter increasingly expensive. However, the implementation contains a critical flaw in how it tracks vote counts.

When a user votes on a quadratic voting item with `IsLockToken=true`, the Vote() method calculates the cost based on a counter stored in `QuadraticVotesCountMap`. [1](#0-0) 

The critical issue is that `QuadraticVotesCountMap` is keyed by VoteId [2](#0-1) , and for locked-token voting, the VoteId is auto-generated using the current cumulative vote amount: [3](#0-2) 

Since `votingResult.VotesAmount` is updated after each vote [4](#0-3) , every subsequent vote transaction receives a **different VoteId**. This means:

1. **First vote**: VotesAmount=0 → VoteId=Hash(0) → QuadraticVotesCountMap[Hash(0)]=1 → Cost=100
2. **Second vote**: VotesAmount=100 → VoteId=Hash(100) → QuadraticVotesCountMap[Hash(100)]=1 → Cost=100 (should be 200!)
3. **Third vote**: VotesAmount=200 → VoteId=Hash(200) → QuadraticVotesCountMap[Hash(200)]=1 → Cost=100 (should be 300!)

Each new VoteId starts with a count of 0 in the map, so after incrementing, `currentVotesCount` is always 1, resulting in constant cost.

The system allows users to vote multiple times on the same item [5](#0-4) , and the validation logic only checks basic constraints without preventing duplicate votes from the same voter. [6](#0-5) 

Furthermore, no tests exist for quadratic voting functionality, as confirmed by the absence of `IsQuadratic`, `TicketCost`, or `QuadraticVotesCountMap` in any test files.

## Impact Explanation

This vulnerability completely breaks the quadratic voting fairness mechanism, which is designed to prevent wealthy actors from dominating voting outcomes. 

**Quantified Impact**: For a voting item with `TicketCost=100`:
- Expected cost for 10 votes: 100+200+300+...+1000 = 5,500 tokens
- Actual cost exploiting this bug: 100×10 = 1,000 tokens
- **Cost reduction: 82%**

This allows malicious actors to:
- Cast unlimited votes at constant cost
- Dominate governance decisions, elections, and referendums without quadratic penalty
- Unfairly influence protocol governance with disproportionate voting power
- Undermine the core fairness guarantee of quadratic voting systems

All voting items with `IsQuadratic=true` and `IsLockToken=true` are affected, compromising governance integrity across the entire system.

## Likelihood Explanation

**Exploitation is trivial and always possible**:
- Any address with sufficient tokens can exploit this
- No special privileges or preconditions required
- Simply call `Vote()` multiple times on the same `VotingItemId`
- The vulnerability is inherent in the code logic, not dependent on specific states

**Detection is difficult**: The bug manifests as correctly-formatted vote records with amounts that appear valid individually. Only by analyzing multiple votes from the same voter can the constant cost pattern be detected.

**Probability: HIGH** - The vulnerability is always exploitable whenever a quadratic voting item exists, and there are no protective mechanisms to prevent or detect it.

## Recommendation

The root cause is using unique per-transaction VoteIds to key the vote counter. The fix requires tracking cumulative votes per (voter, voting_item_id) pair instead.

**Recommended Fix**:

1. Change the state variable from:
```
MappedState<Hash, long> QuadraticVotesCountMap
```
to:
```
MappedState<Address, MappedState<Hash, long>> QuadraticVotesCountMap
// voter address → voting_item_id → cumulative vote count
```

2. Update the Vote() method to track votes per voter per item:
```csharp
if (votingItem.IsQuadratic)
{
    var currentVotesCount = State.QuadraticVotesCountMap[Context.Sender][input.VotingItemId].Add(1);
    State.QuadraticVotesCountMap[Context.Sender][input.VotingItemId] = currentVotesCount;
    amount = votingItem.TicketCost.Mul(currentVotesCount);
}
```

3. Update the Withdraw() method to decrement the counter appropriately when votes are withdrawn.

4. Add comprehensive tests for quadratic voting scenarios with multiple votes from the same voter.

## Proof of Concept

```csharp
[Fact]
public async Task QuadraticVoting_Bypass_ConstantCost()
{
    // Register quadratic voting item with TicketCost=100
    var startTime = TimestampHelper.GetUtcNow();
    var input = new VotingRegisterInput
    {
        TotalSnapshotNumber = 1,
        EndTimestamp = startTime.AddDays(10),
        StartTimestamp = startTime,
        Options = { "Option1", "Option2" },
        AcceptedCurrency = TestTokenSymbol,
        IsLockToken = true,
        IsQuadratic = true,
        TicketCost = 100
    };
    await VoteContractStub.Register.SendAsync(input);
    
    var votingItemId = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(input), 
        HashHelper.ComputeFrom(DefaultSender)
    );
    
    var voter = Accounts[1];
    
    // Vote 3 times on same item
    var vote1 = await Vote(voter.KeyPair, votingItemId, "Option1", 0);
    var vote2 = await Vote(voter.KeyPair, votingItemId, "Option1", 0);
    var vote3 = await Vote(voter.KeyPair, votingItemId, "Option1", 0);
    
    // Get vote records
    var voteIds = await GetVoteIds(voter.KeyPair, votingItemId);
    var record1 = await GetVotingRecord(voteIds.ActiveVotes[0]);
    var record2 = await GetVotingRecord(voteIds.ActiveVotes[1]);
    var record3 = await GetVotingRecord(voteIds.ActiveVotes[2]);
    
    // BUG: All three votes cost the same (100 tokens each)
    // Expected: 100, 200, 300
    // Actual: 100, 100, 100
    record1.Amount.ShouldBe(100); // Should be 100 ✓
    record2.Amount.ShouldBe(200); // Should be 200, but is 100 ✗
    record3.Amount.ShouldBe(300); // Should be 300, but is 100 ✗
    
    // Attacker pays only 300 tokens instead of 600 tokens
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L100-102)
```csharp
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L179-179)
```csharp
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L30-33)
```csharp
    /// <summary>
    ///     Vote Id -> Votes Count
    /// </summary>
    public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L586-604)
```csharp
    {
        var voteUser = Accounts[2].KeyPair;
        var votingItem = await RegisterVotingItemAsync(10, 3, true, DefaultSender, 2);

        await Vote(voteUser, votingItem.VotingItemId, votingItem.Options.First(), 1000L);
        var votingResult = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
        {
            VotingItemId = votingItem.VotingItemId,
            SnapshotNumber = 1
        });

        votingResult.VotingItemId.ShouldBe(votingItem.VotingItemId);
        votingResult.VotersCount.ShouldBe(1);
        votingResult.Results.Values.First().ShouldBe(1000L);

        await Vote(voteUser, votingItem.VotingItemId, votingItem.Options.Last(), 500L);
        var votedResult = await GetVotedItems(Address.FromPublicKey(voteUser.PublicKey));
        votedResult.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Count.ShouldBe(2);
    }
```
