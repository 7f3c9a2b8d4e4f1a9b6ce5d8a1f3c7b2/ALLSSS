### Title
Incorrect Balance Validation in Recharge Allows Side Chain to Run Out of Indexing Funds Immediately

### Summary
The `Recharge` function contains a mathematically incorrect balance validation formula that double-counts the recharge amount, allowing side chains to pass the sufficiency check even when they lack funds for the next block indexing. This enables side chains to immediately enter debt status after a successful recharge, disrupting cross-chain indexing operations.

### Finding Description

The vulnerability exists in the `Recharge` function's balance validation logic when a side chain is in debt status. [1](#0-0) 

The execution flow is:
1. The function transfers `input.Amount` tokens to the side chain's virtual address [2](#0-1) 
2. If the chain is in debt, it pays all arrears to creditors [3](#0-2) 
3. It then retrieves the current balance AFTER paying arrears [4](#0-3) 
4. Finally, it validates: `input.Amount + originBalance >= arrearsAmount + IndexingPrice` [5](#0-4) 

**Root Cause:** The formula is incorrect because `originBalance` (obtained via `GetSideChainIndexingFeeDeposit`) [6](#0-5)  returns the balance AFTER both the recharge and arrears payment have executed. This means:
- `originBalance = initial_balance + input.Amount - arrearsAmount`

Substituting into the assertion:
- `input.Amount + (initial_balance + input.Amount - arrearsAmount) >= arrearsAmount + IndexingPrice`
- Simplifying: `2*input.Amount + initial_balance >= 2*arrearsAmount + IndexingPrice`

The correct check should be:
- `initial_balance + input.Amount - arrearsAmount >= IndexingPrice`
- Which simplifies to: `initial_balance + input.Amount >= arrearsAmount + IndexingPrice`

The actual formula double-counts both `input.Amount` and `arrearsAmount`, allowing recharges to pass validation when the final balance is insufficient for next indexing.

**Additional Issue:** When the side chain is NOT in debt status, there is NO validation of the recharge amount at all [7](#0-6) , allowing arbitrarily small recharges regardless of `IndexingPrice`.

### Impact Explanation

**Operational Impact - Cross-Chain Indexing Disruption:**
When a side chain successfully recharges with insufficient funds, it will immediately return to debt status after the next indexing operation. The indexing fee payment mechanism deducts `IndexingPrice` from the side chain's balance for each indexed block [8](#0-7) . When balance becomes negative, the chain enters `IndexingFeeDebt` status and new arrears are recorded [9](#0-8) .

**Severity Justification (Medium):**
- Side chain operators can unknowingly perform "successful" recharges that fail immediately
- Proposers who index the next block are not paid (arrears accumulate)
- Cross-chain data flow is disrupted as the chain repeatedly cycles between Active and Debt states
- No direct fund theft, but operational reliability is compromised
- Affects all stakeholders: side chain operators, indexing proposers, and cross-chain applications

**Quantified Damage:**
For example, with `IndexingPrice = 20 tokens`, a recharge of 100 tokens to pay 90 tokens in arrears would pass validation (200 >= 200) but leave only 10 tokens available—insufficient for even one indexing operation.

### Likelihood Explanation

**Reachable Entry Point:** The `Recharge` function is a public method callable by any user [10](#0-9) .

**Feasible Preconditions:**
1. A side chain exists with non-zero `IndexingPrice`
2. The chain is in `IndexingFeeDebt` status with accumulated arrears
3. User attempts to recharge with an amount that satisfies the flawed formula but is actually insufficient

**Execution Practicality:** 
The vulnerability triggers naturally during normal operations. No special privileges or attack steps are required. Side chain operators attempting legitimate recharges will encounter this issue whenever:
- `initial_balance = 0` (common after entering debt)
- `input.Amount < arrearsAmount + IndexingPrice` but `2*input.Amount >= arrearsAmount + IndexingPrice`

**Economic Rationality:**
This is not an intentional attack but a logic error that manifests during routine recharge operations. Side chain operators have economic incentive to keep chains funded, making this a high-probability operational failure rather than a deliberate exploit.

**Probability Assessment:** High - The flaw will manifest whenever recharge amounts fall within the vulnerable range, which is common when operators attempt to recharge with exactly enough to cover arrears without accounting for next indexing.

### Recommendation

**Fix the Validation Formula:**

Replace the incorrect assertion [5](#0-4)  with:

```csharp
var originBalance = GetSideChainIndexingFeeDeposit(chainId);
// Balance before recharge minus arrears that were just paid
var balanceBeforeRecharge = originBalance - input.Amount + arrearsAmount;
Assert(balanceBeforeRecharge + input.Amount >= arrearsAmount + sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

Or more simply, check the final balance directly:
```csharp
var finalBalance = GetSideChainIndexingFeeDeposit(chainId);
Assert(finalBalance >= sideChainInfo.IndexingPrice,
    "Insufficient balance for next indexing after paying arrears.");
```

**Add Validation for Non-Debt Case:**

Add a minimum balance check when the chain is NOT in debt:
```csharp
// After line 209, before line 211
else
{
    var finalBalance = GetSideChainIndexingFeeDeposit(chainId);
    Assert(finalBalance >= sideChainInfo.IndexingPrice,
        "Insufficient balance for indexing.");
}
```

**Invariant to Maintain:**
After any recharge operation, the side chain's balance must be >= `IndexingPrice` to ensure at least one indexing operation can be paid.

**Test Cases:**
1. Recharge with exact amount to cover arrears but insufficient for next indexing
2. Recharge non-debt chain with amount less than IndexingPrice
3. Verify both cases are rejected appropriately

### Proof of Concept

**Initial State:**
- Side chain ID: 123456
- Initial balance: 0 tokens
- Accumulated arrears: 90 tokens
- IndexingPrice: 20 tokens
- Chain status: `IndexingFeeDebt`

**Transaction Steps:**

1. User calls `Recharge(chainId: 123456, amount: 100)`

2. Execution:
   - Transfer 100 tokens to side chain (balance = 100)
   - Pay 90 tokens in arrears (balance = 10)
   - Get `originBalance = 10`
   - Check: `100 + 10 >= 90 + 20` → `110 >= 110` → **PASSES**
   - Clear arrears, set status to Active

3. Next block: Proposer attempts to index side chain block
   - System deducts `IndexingPrice = 20` from balance
   - Current balance = 10
   - `10 - 20 = -10` (negative balance)
   - Chain immediately returns to `IndexingFeeDebt` status
   - Proposer's 20 tokens are recorded as new arrears

**Expected Result:** 
Recharge should FAIL with "Indexing fee recharging not enough" because final balance (10) < IndexingPrice (20).

**Actual Result:**
Recharge SUCCEEDS but chain immediately returns to debt status on next indexing operation, creating a cycle of failed recharges and accumulating unpaid fees.

**Success Condition:**
The vulnerability is confirmed when a recharge transaction with `amount < arrearsAmount + IndexingPrice` succeeds, leaving `final_balance < IndexingPrice`, and the chain enters debt again upon the next indexing.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L174-215)
```csharp
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");

        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L88-98)
```csharp
    private long GetSideChainIndexingFeeDeposit(int chainId)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var balanceOutput = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol
        });

        return balanceOutput.Balance;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L842-855)
```csharp
                var indexingPrice = sideChainInfo.IndexingPrice;

                lockedToken -= indexingPrice;

                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
                else
                {
                    indexingFeeAmount += indexingPrice;
                }
```
