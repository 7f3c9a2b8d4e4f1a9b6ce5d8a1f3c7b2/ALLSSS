### Title
Permanent DOS of Fee and Rental Controllers via Premature Initialization with Empty Parliament Controller

### Summary
The `InitializeAuthorizedController()` function lacks access control and can be called by anyone before the Parliament contract is deployed. When called prematurely, it initializes fee and rental controllers with zero/empty addresses from an undeployed Parliament contract, permanently locking critical governance functionality. Once initialized, these controllers cannot be reset, and all fee coefficient and rental management operations become permanently inaccessible since no address can match the zero owner address.

### Finding Description

The vulnerability exists in the `InitializeAuthorizedController()` function which is publicly callable without any authorization checks: [1](#0-0) 

The function immediately calls `GetDefaultParliamentController()` which returns an empty `AuthorityInfo` object with zero addresses if the Parliament contract is not yet deployed: [2](#0-1) 

This empty controller is then used to initialize three critical controllers through conditional blocks that only execute if the state values are null: [3](#0-2) [4](#0-3) [5](#0-4) 

The controller creation functions use the empty parliament address to build organization structures with zero addresses in member lists and whitelists: [6](#0-5) [7](#0-6) [8](#0-7) 

Once these controllers are set with zero addresses, the authorization assertion functions will permanently fail because no sender can equal a zero address: [9](#0-8) 

This breaks critical operations that require these assertions: [10](#0-9) [11](#0-10) 

The change controller functions that could potentially fix this also require authorization from the broken controllers, creating an unrecoverable deadlock: [12](#0-11) 

### Impact Explanation

**Operational Impact - Critical DOS**: This vulnerability permanently disables core governance and fee management functionality:

1. **Fee Coefficient Management Locked**: `UpdateCoefficientsForSender` and `UpdateCoefficientsForContract` become permanently inaccessible, preventing any adjustments to transaction fee calculation algorithms across all fee types (Read, Write, Storage, Traffic, Tx).

2. **Side Chain Rental Management Locked**: `UpdateRental` and `UpdateRentedResources` become permanently inaccessible, breaking side chain resource allocation and rental fee management.

3. **Controller Change Functions Blocked**: `ChangeUserFeeController`, `ChangeDeveloperController`, and `ChangeSideChainRentalController` all require authorization from the broken controllers, making recovery impossible.

4. **No Recovery Mechanism**: The null checks prevent re-initialization, and all change functions are protected by the broken controllers, creating a permanent deadlock.

The Economic contract's intended initialization path becomes a no-op because the controllers are already set: [13](#0-12) 

This affects the entire blockchain's fee economy and side chain governance, representing a critical protocol-level DOS attack.

### Likelihood Explanation

**High Likelihood** - The attack is highly practical:

1. **No Access Control**: Any address can call `InitializeAuthorizedController()` - there are no authorization checks or restrictions.

2. **Realistic Attack Window**: During normal deployment, there exists a window between MultiToken contract deployment and Parliament contract deployment where this attack is executable. An attacker monitoring contract deployments can front-run the Economic contract's initialization.

3. **Zero Cost Attack**: The attacker only needs to submit a single transaction calling `InitializeAuthorizedController()` with empty input. No tokens or special privileges required.

4. **Guaranteed Success**: If executed before Parliament contract is deployed/registered by name, `GetDefaultParliamentController()` deterministically returns an empty `AuthorityInfo`, making the attack outcome guaranteed.

5. **Detection Difficulty**: The transaction would appear as a normal initialization call and might not be detected as malicious until fee/rental operations are attempted later.

The Economic contract expects to be the first caller based on its initialization sequence, but nothing enforces this ordering.

### Recommendation

Implement the following mitigations:

1. **Add Access Control**: Restrict `InitializeAuthorizedController()` to only be callable by authorized system contracts (e.g., Economic contract or Genesis contract):

```csharp
public override Empty InitializeAuthorizedController(Empty input)
{
    // Only allow Economic contract or Zero contract to initialize
    var authorizedCallers = new List<Address>
    {
        Context.GetContractAddressByName(SmartContractConstants.EconomicContractSystemName),
        Context.GetZeroSmartContractAddress()
    };
    Assert(authorizedCallers.Contains(Context.Sender), 
        "Only authorized system contracts can initialize controllers.");
    
    // existing initialization logic...
}
```

2. **Add Parliament Contract Validation**: Assert that Parliament contract exists before proceeding:

```csharp
var defaultParliamentController = GetDefaultParliamentController();
Assert(defaultParliamentController.ContractAddress != null && 
       !defaultParliamentController.OwnerAddress.Value.IsNullOrEmpty(),
       "Parliament contract must be deployed before initialization.");
```

3. **Add Re-initialization Protection**: Use an explicit initialization flag similar to other contracts:

```csharp
Assert(!State.ControllersInitialized.Value, "Controllers already initialized.");
// ... initialization logic ...
State.ControllersInitialized.Value = true;
```

4. **Add Emergency Recovery Function**: Implement a recovery mechanism callable by Parliament default organization to reset broken controllers:

```csharp
public override Empty ResetControllers(Empty input)
{
    var defaultParliament = GetDefaultParliamentController();
    AssertSenderAddressWith(defaultParliament.OwnerAddress);
    State.UserFeeController.Value = null;
    State.DeveloperFeeController.Value = null;
    State.SideChainRentalController.Value = null;
    return new Empty();
}
```

5. **Test Coverage**: Add test cases verifying initialization fails when Parliament is not deployed and succeeds only with proper authorization.

### Proof of Concept

**Initial State**:
- MultiToken contract deployed
- Parliament contract NOT yet deployed or registered
- Economic contract NOT yet initialized

**Attack Steps**:

1. Attacker monitors blockchain for MultiToken contract deployment
2. Attacker calls `TokenContract.InitializeAuthorizedController(Empty)` before Economic contract initialization
3. `GetDefaultParliamentController()` returns empty `AuthorityInfo` (ContractAddress=null, OwnerAddress=zero)
4. Function creates `UserFeeController`, `DeveloperFeeController`, and `SideChainRentalController` with zero addresses
5. Controllers are saved to state with zero owner addresses

**Result**:

Expected behavior: Controllers should be initialized with valid Parliament organization addresses
Actual behavior: Controllers contain zero addresses and are permanently locked

**Verification**:

Attempt to call `UpdateCoefficientsForSender`:
- Function calls `AssertUserFeeController()`
- Assertion checks: `Context.Sender == State.UserFeeController.Value.RootController.OwnerAddress`
- Since OwnerAddress is zero/empty, assertion fails with "no permission"
- No address can ever satisfy this check
- Function is permanently inaccessible

Attempt to call `ChangeUserFeeController` to fix the issue:
- Function calls `AssertUserFeeController()` first
- Same failure as above
- Recovery is impossible

**Success Condition for Attack**: Controllers initialized with zero addresses, and all fee/rental management operations return "no permission" errors permanently.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L16-16)
```csharp
    public override Empty InitializeAuthorizedController(Empty input)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L19-26)
```csharp
        if (State.UserFeeController.Value == null)
        {
            var defaultUserFeeController = GetDefaultUserFeeController(defaultParliamentController);
            CreateReferendumControllerForUserFee(defaultParliamentController.OwnerAddress);
            CreateAssociationControllerForUserFee(defaultParliamentController.OwnerAddress,
                defaultUserFeeController.ReferendumController.OwnerAddress);
            State.UserFeeController.Value = defaultUserFeeController;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L28-35)
```csharp
        if (State.DeveloperFeeController.Value == null)
        {
            var developerController = GetDefaultDeveloperFeeController(defaultParliamentController);
            CreateDeveloperController(defaultParliamentController.OwnerAddress);
            CreateAssociationControllerForDeveloperFee(defaultParliamentController.OwnerAddress,
                developerController.DeveloperController.OwnerAddress);
            State.DeveloperFeeController.Value = developerController;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L37-42)
```csharp
        if (State.SideChainCreator.Value == null || State.SideChainRentalController.Value != null) return new Empty();
        var sideChainRentalController = GetDefaultSideChainRentalController(defaultParliamentController);
        CreateAssociationControllerForSideChainRental(State.SideChainCreator.Value,
            defaultParliamentController.OwnerAddress);
        State.SideChainRentalController.Value = sideChainRentalController;
        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L70-88)
```csharp
    public override Empty ChangeUserFeeController(AuthorityInfo input)
    {
        AssertUserFeeController();
        Assert(CheckOrganizationExist(input), "Invalid authority input.");
        State.UserFeeController.Value.RootController = input;
        State.UserFeeController.Value.ParliamentController = null;
        State.UserFeeController.Value.ReferendumController = null;
        return new Empty();
    }

    public override Empty ChangeDeveloperController(AuthorityInfo input)
    {
        AssertDeveloperFeeController();
        Assert(CheckOrganizationExist(input), "Invalid authority input.");
        State.DeveloperFeeController.Value.RootController = input;
        State.DeveloperFeeController.Value.ParliamentController = null;
        State.DeveloperFeeController.Value.DeveloperController = null;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L275-294)
```csharp
    private AuthorityInfo GetDefaultParliamentController()
    {
        if (State.ParliamentContract.Value == null)
        {
            var parliamentContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
            if (parliamentContractAddress == null)
                // Test environment.
                return new AuthorityInfo();

            State.ParliamentContract.Value = parliamentContractAddress;
        }

        var defaultOrganizationAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
        return new AuthorityInfo
        {
            ContractAddress = State.ParliamentContract.Value,
            OwnerAddress = defaultOrganizationAddress
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L296-322)
```csharp
    private DeveloperFeeController GetDefaultDeveloperFeeController(AuthorityInfo defaultParliamentController)
    {
        if (State.AssociationContract.Value == null)
            State.AssociationContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);

        var developerFeeController = new DeveloperFeeController
        {
            ParliamentController = new AuthorityInfo(),
            DeveloperController = new AuthorityInfo(),
            RootController = new AuthorityInfo()
        };
        developerFeeController.ParliamentController = defaultParliamentController;
        developerFeeController.DeveloperController.ContractAddress = State.AssociationContract.Value;
        developerFeeController.DeveloperController.OwnerAddress =
            State.AssociationContract.CalculateOrganizationAddress.Call(
                GetDeveloperControllerCreateInput(defaultParliamentController.OwnerAddress)
                    .OrganizationCreationInput);
        developerFeeController.RootController.ContractAddress = State.AssociationContract.Value;
        developerFeeController.RootController.OwnerAddress =
            State.AssociationContract.CalculateOrganizationAddress.Call(
                GetAssociationControllerCreateInputForDeveloperFee(
                        defaultParliamentController.OwnerAddress,
                        developerFeeController.DeveloperController.OwnerAddress)
                    .OrganizationCreationInput);
        return developerFeeController;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L324-352)
```csharp
    private UserFeeController GetDefaultUserFeeController(AuthorityInfo defaultParliamentController)
    {
        if (State.AssociationContract.Value == null)
            State.AssociationContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);

        if (State.ReferendumContract.Value == null)
            State.ReferendumContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);

        var userFeeController = new UserFeeController
        {
            RootController = new AuthorityInfo(),
            ParliamentController = new AuthorityInfo(),
            ReferendumController = new AuthorityInfo()
        };
        userFeeController.ParliamentController = defaultParliamentController;
        userFeeController.ReferendumController.ContractAddress = State.ReferendumContract.Value;
        userFeeController.ReferendumController.OwnerAddress =
            State.ReferendumContract.CalculateOrganizationAddress.Call(
                GetReferendumControllerCreateInputForUserFee(defaultParliamentController.OwnerAddress)
                    .OrganizationCreationInput);
        userFeeController.RootController.ContractAddress = State.AssociationContract.Value;
        userFeeController.RootController.OwnerAddress = State.AssociationContract.CalculateOrganizationAddress.Call(
            GetAssociationControllerCreateInputForUserFee(defaultParliamentController.OwnerAddress,
                    userFeeController.ReferendumController.OwnerAddress)
                .OrganizationCreationInput);
        return userFeeController;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L359-374)
```csharp
    private AuthorityInfo GetDefaultSideChainRentalController(AuthorityInfo defaultParliamentController)
    {
        if (State.AssociationContract.Value == null)
            State.AssociationContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
        var calculatedAddress = State.AssociationContract.CalculateOrganizationAddress.Call(
            GetControllerCreateInputForSideChainRental(
                    State.SideChainCreator.Value,
                    defaultParliamentController.OwnerAddress)
                .OrganizationCreationInput);
        return new AuthorityInfo
        {
            ContractAddress = State.AssociationContract.Value,
            OwnerAddress = calculatedAddress
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L383-413)
```csharp
    private void AssertDeveloperFeeController()
    {
        Assert(State.DeveloperFeeController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");

        Assert(Context.Sender == State.DeveloperFeeController.Value.RootController.OwnerAddress, "no permission");
    }

    private void AssertUserFeeController()
    {
        Assert(State.UserFeeController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");
        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == State.UserFeeController.Value.RootController.OwnerAddress, "no permission");
    }

    private void AssertControllerForSymbolToPayTxSizeFee()
    {
        if (State.SymbolToPayTxFeeController.Value == null)
            State.SymbolToPayTxFeeController.Value = GetDefaultSymbolToPayTxFeeController();

        Assert(State.SymbolToPayTxFeeController.Value.OwnerAddress == Context.Sender, "no permission");
    }

    private void AssertControllerForSideChainRental()
    {
        Assert(State.SideChainRentalController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");
        // ReSharper disable once PossibleNullReferenceException
        Assert(State.SideChainRentalController.Value.OwnerAddress == Context.Sender, "no permission");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L16-32)
```csharp
    public override Empty UpdateCoefficientsForContract(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        Assert(input.Coefficients.FeeTokenType != (int)FeeTypeEnum.Tx, "Invalid fee type.");
        AssertDeveloperFeeController();
        UpdateCoefficients(input);
        return new Empty();
    }

    public override Empty UpdateCoefficientsForSender(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        AssertUserFeeController();
        input.Coefficients.FeeTokenType = (int)FeeTypeEnum.Tx; // The only possible for now.
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1099-1127)
```csharp
    public override Empty UpdateRental(UpdateRentalInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.Rental)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.Rental[pair.Key] = pair.Value;
        }

        return new Empty();
    }

    public override Empty UpdateRentedResources(UpdateRentedResourcesInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.ResourceAmount)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.ResourceAmount[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L36-37)
```csharp
        State.TokenContract.InitialCoefficients.Send(new Empty());
        State.TokenContract.InitializeAuthorizedController.Send(new Empty());
```
