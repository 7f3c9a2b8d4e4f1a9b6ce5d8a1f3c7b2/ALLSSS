# Audit Report

## Title
Scheme Overwriting Causes Permanent Token Lock Due to Symbol Mismatch

## Summary
When a manager calls `CreateScheme` multiple times, the new scheme overwrites the previous one in TokenHolderContract storage. Existing users who locked tokens under the original scheme cannot withdraw because the `Withdraw` function queries locked amounts using the new scheme's symbol, which returns zero balance for tokens locked under the different original symbol, leaving funds permanently inaccessible.

## Finding Description

The TokenHolderContract allows managers to create profit-sharing schemes where users lock tokens to receive profit distributions. The vulnerability occurs due to three interacting design flaws:

**Root Cause 1: Unrestricted Scheme Overwriting**

The `CreateScheme` method directly overwrites the scheme stored at `State.TokenHolderProfitSchemes[Context.Sender]` without any validation to prevent duplicate calls or check for existing user registrations. [1](#0-0) 

Each call to `CreateScheme` creates a new profit scheme in the Profit contract with a unique schemeId (based on the count of schemes), but overwrites the TokenHolderProfitScheme metadata including the critical `Symbol` field. [2](#0-1) 

**Root Cause 2: Deterministic Lock ID Generation**

Lock IDs are generated deterministically based only on the manager address and user address, making them identical across different schemes with the same manager. [3](#0-2) 

When users register, tokens are locked with the current scheme's symbol, and the lock ID mapping persists in `State.LockIds[manager][user]`. [4](#0-3) 

**Root Cause 3: Symbol Mismatch in Withdrawal**

The `Withdraw` function retrieves the CURRENT scheme (which may have a different symbol than when the user registered), then queries the locked amount using this current scheme's symbol with the old lock ID. [5](#0-4) 

The critical flaw is in how `GetLockedAmount` works: it computes the virtual address from the lock ID and then queries the balance of a SPECIFIC symbol at that virtual address. [6](#0-5) 

Since the virtual address calculation doesn't include the symbol (it's only based on sender, user address, and lock ID), but the balance query IS symbol-specific, tokens locked under one symbol become invisible when queried with a different symbol. [7](#0-6) 

**Attack Scenario:**
1. Manager creates scheme with Symbol="ELF", MinimumLockMinutes=1000
2. User registers and locks 10,000 ELF tokens at virtual address V
3. Manager calls `CreateScheme` again with Symbol="USDT", MinimumLockMinutes=10
4. User calls `Withdraw`:
   - Retrieves current scheme (Symbol="USDT")
   - Queries `GetLockedAmount(lockId, "USDT")` â†’ returns 0 (virtual address V has ELF, not USDT)
   - Unlocks 0 USDT tokens
   - Removes lock ID mapping
   - Original 10,000 ELF remains locked at virtual address V permanently

## Impact Explanation

**HIGH Severity** - Direct and permanent loss of user funds with no standard recovery mechanism:

1. **Permanent Fund Lock**: Users completely lose access to their locked tokens. The withdrawal function returns zero balance and removes the lock ID mapping, eliminating the normal path to retrieve funds.

2. **Multi-User Impact**: When a manager overwrites a scheme, ALL users who registered under the original scheme are simultaneously affected. For a popular staking scheme, this could impact hundreds of users.

3. **No Administrative Recovery**: There is no function in the contract to recover these locked funds. The tokens remain at the virtual address indefinitely with no authority able to unlock them.

4. **Undetectable by Users**: Users have no way to detect this vulnerability before locking funds. The withdrawal only fails after the manager has already overwritten the scheme.

## Likelihood Explanation

**HIGH Likelihood** - Simple to trigger, both accidentally and maliciously:

1. **Public Entry Point**: The `CreateScheme` method is publicly accessible to any address. [8](#0-7) 

2. **Low Complexity**: The attack requires only two standard contract calls by the manager with no complex state manipulation or timing requirements.

3. **Accidental Trigger**: A manager might innocently call `CreateScheme` a second time to update scheme parameters (e.g., changing minimum lock duration or auto-distribute thresholds), not realizing it creates a new scheme and breaks existing user locks.

4. **Malicious Scenario**: A malicious manager could deliberately lock user funds to prevent withdrawals, gaining time advantage in profit distributions or causing financial harm.

5. **No Warning**: The contract provides no warnings or checks to prevent this scenario, making it easy to trigger unintentionally.

## Recommendation

Implement protection against scheme overwriting by checking if users are registered before allowing scheme updates:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    var existingScheme = State.TokenHolderProfitSchemes[Context.Sender];
    Assert(existingScheme == null, "Scheme already exists. Cannot overwrite existing scheme.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, implement an `UpdateScheme` method that only allows updating non-critical parameters (like MinimumLockMinutes) while preserving the Symbol field and validating that no users would be affected.

## Proof of Concept

The vulnerability can be demonstrated with the following test sequence:

```csharp
// 1. Manager creates initial scheme
tokenHolderContract.CreateScheme(new CreateTokenHolderProfitSchemeInput
{
    Symbol = "ELF",
    MinimumLockMinutes = 1000
});

// 2. User locks tokens
tokenHolderContract.RegisterForProfits(new RegisterForProfitsInput
{
    SchemeManager = managerAddress,
    Amount = 10000
});

// 3. Verify tokens are locked
var lockedAmount1 = tokenContract.GetLockedAmount(new GetLockedAmountInput
{
    Address = userAddress,
    LockId = lockId,
    Symbol = "ELF"
});
Assert(lockedAmount1.Amount == 10000);

// 4. Manager overwrites scheme
tokenHolderContract.CreateScheme(new CreateTokenHolderProfitSchemeInput
{
    Symbol = "USDT",
    MinimumLockMinutes = 10
});

// 5. User attempts withdrawal - gets 0 balance
// Because GetLockedAmount queries with "USDT" symbol but tokens locked as "ELF"
tokenHolderContract.Withdraw(managerAddress);

// 6. Verify original ELF tokens remain locked at virtual address
var lockedAmount2 = tokenContract.GetLockedAmount(new GetLockedAmountInput
{
    Address = userAddress,
    LockId = lockId,
    Symbol = "ELF"
});
Assert(lockedAmount2.Amount == 10000); // Still locked!

// 7. Verify lock ID mapping was removed, blocking re-registration
var canRegisterAgain = tokenHolderContract.RegisterForProfits(new RegisterForProfitsInput
{
    SchemeManager = managerAddress,
    Amount = 1
});
// This would work but requires locking MORE funds, original funds still stuck
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-14)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-158)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-166)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L213-225)
```csharp
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-115)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L118-124)
```csharp
    public override Address GetVirtualAddressForLocking(GetVirtualAddressForLockingInput input)
    {
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        return virtualAddress;
    }
```
