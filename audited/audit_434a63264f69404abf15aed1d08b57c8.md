### Title
Malicious Block Producer Can Skip Term Changes by Using NextRound Instead of NextTerm Behavior

### Summary
The validation logic for NextRound behavior does not verify that a term change should not have occurred, allowing a malicious block producer to skip mandatory term transitions by using NextRound when NextTerm is required. This bypasses critical term change operations including miner list updates, reward distributions, treasury releases, and election snapshots.

### Finding Description

The vulnerability exists in the consensus validation and behavior enforcement flow:

**Root Cause:**
The `RoundTerminateValidationProvider.ValidationForNextRound` method only validates round number increment and null InValues, but does NOT check whether the term number should have changed. [1](#0-0) 

**Behavior Determination vs Enforcement:**
The system determines which behavior (NextRound vs NextTerm) should be used in `MainChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound` based on `NeedToChangeTerm` logic: [2](#0-1) 

However, this determination is only advisory. The `ConsensusCommand` returned by `GetAEDPoSConsensusCommand` contains only timing information and a behavior hint, without round/term numbers: [3](#0-2) 

**Attack Vector:**
A malicious block producer controls their node software and can manipulate the behavior passed to `GetConsensusBlockExtraData`. The trigger information provider extracts the behavior from the consensus command hint and passes only the pubkey and behavior to the contract: [4](#0-3) 

The contract then generates fresh round information based on that behavior: [5](#0-4) 

**Why Protections Fail:**
The validation only enforces constraints for the claimed behavior, not whether the correct behavior was chosen: [6](#0-5) 

For NextRound, no term-related validation exists, while NextTerm validates both round and term increments: [7](#0-6) 

### Impact Explanation

**Direct Consensus and Governance Impact:**
When `ProcessNextRound` executes instead of `ProcessNextTerm`, critical term change operations are skipped: [8](#0-7) 

Versus the term change operations that should occur: [9](#0-8) 

**Specific Harms:**
1. **Miner list becomes stale** - Election contract updates are not applied, preventing proper validator rotation
2. **Reward misallocation** - Mining rewards for the term are not distributed to Treasury
3. **Treasury malfunction** - Period-based Treasury releases are skipped, breaking economic schedule
4. **Election state corruption** - Election snapshots are not taken, breaking vote weight calculations
5. **Term/round desynchronization** - System term number diverges from expected timeline

**Affected Parties:**
- All network participants expecting term transitions
- Miners awaiting election-based rotation
- Token holders expecting term-based rewards
- Governance processes dependent on term scheduling

**Severity Justification:**
High severity due to fundamental consensus integrity violation, economic impact from skipped distributions, and governance disruption from stale validator sets.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires being an active block producer (miner/validator)
- Must control node software to inject incorrect behavior
- No additional privileges needed beyond mining rights

**Attack Complexity:**
- Low complexity: Modify node's `AEDPoSTriggerInformationProvider` or `ConsensusService` to always return NextRound behavior
- Alternative: Directly call `GetConsensusExtraData` with crafted trigger information
- No cryptographic bypasses or complex state manipulation required

**Feasibility Conditions:**
- Attacker must be scheduled to produce block during term transition round
- No on-chain detection mechanism exists to identify incorrect behavior usage
- Validation will pass as long as round number increments correctly

**Detection Constraints:**
- Other nodes will accept the block as valid since validation passes
- Off-chain monitoring could detect missing term changes by comparing expected vs actual term progression
- Requires external comparison of term schedule with actual blockchain state

**Probability:**
Medium-High likelihood given that any malicious miner can execute this attack when scheduled during term transition rounds, with minimal technical barriers and no on-chain enforcement.

### Recommendation

**Code-Level Mitigation:**
Add term change validation to `ValidationForNextRound` in `RoundTerminateValidationProvider`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    // NEW: Verify term should not change
    if (validationContext.BaseRound.NeedToChangeTerm(
        GetBlockchainStartTimestamp(), 
        validationContext.CurrentTermNumber, 
        State.PeriodSeconds.Value))
    {
        return new ValidationResult { Message = "Term change required but NextRound behavior used." };
    }

    // NEW: Verify term number stays the same
    if (validationContext.BaseRound.TermNumber != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Term number must not change for NextRound behavior." };

    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

**Invariant Checks:**
1. NextRound behavior MUST NOT be used when `NeedToChangeTerm()` returns true
2. NextRound behavior MUST keep term number unchanged
3. NextTerm behavior MUST be used when term change conditions are met

**Test Cases:**
1. Test that block with NextRound during term change time fails validation
2. Test that block with NextRound changing term number fails validation
3. Test that block with NextTerm at wrong time fails validation
4. Test end-to-end term transition enforcement across multiple miners

### Proof of Concept

**Initial State:**
- Round: R, Term: T
- Blockchain running for time exceeding term period
- `NeedToChangeTerm()` returns true (term change required)
- Malicious miner M scheduled to produce next block

**Attack Steps:**
1. Malicious miner M receives `GetConsensusCommand` returning NextTerm behavior
2. Miner M modifies local trigger information to use NextRound instead
3. Miner M calls `GetConsensusExtraData` with NextRound behavior
4. Contract generates round R+1 with term T (unchanged)
5. Miner M produces block with this extra data
6. Network nodes validate block:
   - `ValidateConsensusBeforeExecution` calls `RoundTerminateValidationProvider`
   - Round number check: R+1 == R+1 ✓
   - InValue check: null ✓
   - No term change enforcement ✗
   - Validation passes
7. Block executes, `ProcessNextRound` runs instead of `ProcessNextTerm`
8. State updated: Round = R+1, Term = T (should be T+1)

**Expected Result:**
Block should be rejected due to incorrect behavior (NextRound used when NextTerm required)

**Actual Result:**
Block is accepted, term change is skipped, all term transition operations bypassed

**Success Condition:**
Query `State.CurrentTermNumber` before and after - term number unchanged despite time period expiration and multiple miners signaling term change readiness.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-39)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
        }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L41-75)
```csharp
    public BytesValue GetTriggerInformationForBlockHeaderExtraData(BytesValue consensusCommandBytes)
    {
        if (consensusCommandBytes == null)
            return new AElfConsensusTriggerInformation
            {
                Pubkey = Pubkey,
                Behaviour = AElfConsensusBehaviour.UpdateValue
            }.ToBytesValue();

        var command = consensusCommandBytes.ToConsensusCommand();
        var hint = command.Hint.ToAElfConsensusHint();

        if (hint.Behaviour == AElfConsensusBehaviour.UpdateValue)
        {
            var newInValue = _inValueCache.GetInValue(hint.RoundId);
            var previousInValue = _inValueCache.GetInValue(hint.PreviousRoundId);
            Logger.LogDebug($"New in value {newInValue} for round of id {hint.RoundId}");
            Logger.LogDebug($"Previous in value {previousInValue} for round of id {hint.PreviousRoundId}");
            var trigger = new AElfConsensusTriggerInformation
            {
                Pubkey = Pubkey,
                InValue = newInValue,
                PreviousInValue = previousInValue,
                Behaviour = hint.Behaviour
            };

            return trigger.ToBytesValue();
        }

        return new AElfConsensusTriggerInformation
        {
            Pubkey = Pubkey,
            Behaviour = hint.Behaviour
        }.ToBytesValue();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```
