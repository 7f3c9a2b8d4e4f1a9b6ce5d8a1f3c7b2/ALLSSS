### Title
Sponsor Funds Misdirected to Wrong Address After Pubkey Replacement for Self-Announced Candidates

### Summary
When a candidate announces election themselves (via `AnnounceElection`), no sponsor is recorded in `CandidateSponsorMap`. If their pubkey is subsequently replaced via `ReplaceCandidatePubkey`, the null sponsor mapping is copied to the new pubkey. Upon `QuitElection`, the locked tokens are sent to the new pubkey's address instead of the original candidate's address who paid for them, resulting in fund misdirection.

### Finding Description

The vulnerability exists in the interaction between three functions across the Election contract:

**1. Initial Token Lock (AnnounceElection path):**
When a candidate announces via `AnnounceElection`, tokens are locked from `Context.Sender` (the candidate's address derived from the transaction signature). [1](#0-0) 

Critically, unlike `AnnounceElectionFor`, the `AnnounceElection` method does NOT set `CandidateSponsorMap`, leaving it null for that candidate. [2](#0-1) 

Compare this to `AnnounceElectionFor` which explicitly sets the sponsor: [3](#0-2) 

**2. Pubkey Replacement:**
When `ReplaceCandidatePubkey` is called, it correctly attempts to transfer the sponsor mapping from old to new pubkey. However, if the original sponsor mapping is null, it copies null: [4](#0-3) 

The entire `CandidateInformation` (including `AnnouncementTransactionId` used to locate locked tokens) is also transferred: [5](#0-4) 

**3. Token Return on Quit:**
When `QuitElection` is called on the new pubkey, it uses the fallback logic: if `CandidateSponsorMap` is null, send tokens to `Address.FromPublicKey(pubkeyBytes)` where `pubkeyBytes` is the CURRENT (new) pubkey: [6](#0-5) 

**Root Cause:**
The fallback logic assumes that if no sponsor is set, the tokens should go to the address derived from the current pubkey. This assumption breaks after pubkey replacement because the tokens were originally taken from the OLD pubkey's address, not the new one.

### Impact Explanation

**Direct Fund Impact:**
- The original candidate (Address A) loses `ElectionContractConstants.LockTokenForElection` tokens (100,000 ELF based on typical configuration)
- The new pubkey holder (Address B) receives tokens they never paid for
- This constitutes theft through fund misdirection

**Who is Affected:**
- Any candidate who announced election themselves (via `AnnounceElection`) and subsequently had their pubkey replaced
- Common scenario: Initial miners or candidates who later need to update their node's keypair for security or operational reasons

**Severity Justification:**
HIGH severity because:
1. Direct loss of substantial funds (100,000 ELF)
2. Exploitable by candidate admin (trusted but not fully privileged role)
3. No warning or validation prevents this scenario
4. Existing test suite doesn't cover this case [7](#0-6) 

### Likelihood Explanation

**Attacker Capabilities:**
- Requires being a candidate admin for a candidate who announced via `AnnounceElection` (not `AnnounceElectionFor`)
- Admin authority is legitimate but should not enable fund theft

**Attack Complexity:**
LOW - Three standard operations:
1. Candidate announces election (normal flow)
2. Admin calls `ReplaceCandidatePubkey` with attacker-controlled new pubkey (legitimate use case)
3. Admin calls `QuitElection` to receive funds at attacker's address

**Feasibility Conditions:**
- Very feasible: initial miners and many candidates use `AnnounceElection` path
- Pubkey replacement is a legitimate operational need (key rotation, node migration)
- No validation prevents this sequence

**Economic Rationality:**
Profitable - attacker gains 100,000 ELF with only admin authority, which may have been legitimately obtained or acquired through social engineering/compromise of a less-secure admin account.

**Detection:**
Difficult - appears as normal pubkey replacement followed by normal quit election. The victim (original candidate) may not immediately notice token loss if they don't actively monitor balances.

### Recommendation

**Code-Level Mitigation:**
In `ReplaceCandidatePubkey`, before transferring the sponsor mapping, check if it's null. If null, explicitly set it to the old pubkey's address to preserve the original fund source:

```csharp
// In ReplaceCandidatePubkey, before line 320:
var originalSponsor = State.CandidateSponsorMap[input.OldPubkey];
if (originalSponsor == null || originalSponsor.Value.IsNullOrEmpty())
{
    // For self-announced candidates, set sponsor to original address
    State.CandidateSponsorMap[input.NewPubkey] = Address.FromPublicKey(
        ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
}
else
{
    State.CandidateSponsorMap[input.NewPubkey] = originalSponsor;
}
State.CandidateSponsorMap.Remove(input.OldPubkey);
```

**Invariant Check:**
Add assertion: "After pubkey replacement, sponsor mapping must always point to the original fund source (either explicit sponsor or original candidate address)"

**Test Cases to Add:**
1. Test `ReplaceCandidatePubkey` followed by `QuitElection` for a candidate announced via `AnnounceElection` - verify tokens return to original candidate address
2. Test the same flow for `AnnounceElectionFor` - verify tokens return to sponsor address
3. Test multiple replacements in sequence - verify funds still return to original source

### Proof of Concept

**Initial State:**
- Candidate KeyPair A (with Address A derived from public key A)
- Admin Address (distinct from A)
- Candidate KeyPair B (with Address B derived from public key B, controlled by attacker)

**Exploitation Steps:**

1. **Candidate announces election (as themselves):**
   - Transaction signed by KeyPair A
   - Call `AnnounceElection(adminAddress)`
   - Effect: 100,000 ELF locked from Address A
   - Effect: `CandidateSponsorMap[pubkeyA]` remains null

2. **Admin replaces pubkey (legitimate operation):**
   - Transaction from Admin address
   - Call `ReplaceCandidatePubkey(oldPubkey: A, newPubkey: B)`
   - Effect: `CandidateSponsorMap[pubkeyB]` = null (copied from A)
   - Effect: Candidate information transferred to pubkey B

3. **Admin quits election:**
   - Transaction from Admin address
   - Call `QuitElection(pubkeyB)`
   - Effect: 100,000 ELF sent to `Address.FromPublicKey(B)` (fallback logic)
   - **Expected:** Tokens should return to Address A (who paid them)
   - **Actual:** Tokens sent to Address B (attacker's address)

**Success Condition:**
Address B receives 100,000 ELF despite never paying for them, while Address A loses their deposit permanently.

**Notes:**
The existing test demonstrates the quit flow but doesn't verify token destinations, allowing this vulnerability to remain undetected. [8](#0-7)

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L239-249)
```csharp
        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L237-243)
```csharp
        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L320-321)
```csharp
        State.CandidateSponsorMap[newPubkey] = State.CandidateSponsorMap[oldPubkey];
        State.CandidateSponsorMap.Remove(oldPubkey);
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ReplaceCandidateTests.cs (L14-86)
```csharp
    public async Task ElectionContract_ReplaceCandidatePubkey_Test()
    {
        var announceElectionKeyPair = ValidationDataCenterKeyPairs.First();
        var candidateAdmin = ValidationDataCenterKeyPairs.Last();
        var candidateAdminAddress = Address.FromPublicKey(candidateAdmin.PublicKey);
        await AnnounceElectionAsync(announceElectionKeyPair, candidateAdminAddress);

        // Check candidate admin
        {
            var admin = await ElectionContractStub.GetCandidateAdmin.CallAsync(new StringValue
                { Value = announceElectionKeyPair.PublicKey.ToHex() });
            admin.ShouldBe(candidateAdminAddress);
        }

        // Check candidates.
        {
            var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
            candidates.Value.ShouldContain(ByteString.CopyFrom(announceElectionKeyPair.PublicKey));
        }

        var candidateAdminStub =
            GetTester<ElectionContractImplContainer.ElectionContractImplStub>(ElectionContractAddress,
                candidateAdmin);
        var newKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
        await candidateAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
        {
            OldPubkey = announceElectionKeyPair.PublicKey.ToHex(),
            NewPubkey = newKeyPair.PublicKey.ToHex()
        });

        // Check candidates again.
        {
            var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
            candidates.Value.ShouldContain(ByteString.CopyFrom(newKeyPair.PublicKey));
            candidates.Value.ShouldNotContain(ByteString.CopyFrom(announceElectionKeyPair.PublicKey));
        }

        // Check candidate information
        {
            var oldCandidateInformation =
                await ElectionContractStub.GetCandidateInformation.CallAsync(new StringValue
                    { Value = announceElectionKeyPair.PublicKey.ToHex() });
            oldCandidateInformation.IsCurrentCandidate.ShouldBeFalse();
            var newPubkeyInformation =
                await ElectionContractStub.GetCandidateInformation.CallAsync(new StringValue
                    { Value = newKeyPair.PublicKey.ToHex() });
            newPubkeyInformation.IsCurrentCandidate.ShouldBeTrue();
        }

        // Two pubkeys cannot quit election.
        {
            var stub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(ElectionContractAddress,
                announceElectionKeyPair);
            var result = await stub.QuitElection.SendAsync(new StringValue { Value = newKeyPair.PublicKey.ToHex() });
            result.TransactionResult.Error.ShouldContain("Only admin can quit election.");
        }
        {
            var stub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(ElectionContractAddress,
                newKeyPair);
            var result = await stub.QuitElection.SendAsync(new StringValue { Value = newKeyPair.PublicKey.ToHex() });
            result.TransactionResult.Error.ShouldContain("Only admin can quit election.");
        }

        // Only admin can quit election.
        {
            await candidateAdminStub.QuitElection.SendAsync(new StringValue
            {
                Value = newKeyPair.PublicKey.ToHex()
            });
            var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
            candidates.Value.ShouldNotContain(ByteString.CopyFrom(newKeyPair.PublicKey));
        }
    }
```
