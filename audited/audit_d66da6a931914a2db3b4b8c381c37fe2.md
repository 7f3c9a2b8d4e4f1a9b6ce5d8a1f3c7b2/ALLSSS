# Audit Report

## Title
Threshold Mismatch in Secret Sharing Causes Incorrect InValue Reconstruction When Miner Count Changes

## Summary
The `RevealSharedInValues` function in the AEDPoS consensus contract uses the current round's miner count to calculate the Shamir's Secret Sharing decoding threshold, while secrets were encoded using a different round's miner count. When the miner list size changes between rounds—a supported protocol feature during term transitions or evil miner replacements—this threshold mismatch causes incorrect InValue reconstruction, corrupting the consensus randomness beacon.

## Finding Description

The vulnerability exists in the threshold calculation logic within the on-chain secret revelation process. [1](#0-0) 

The function calculates the decoding threshold (`minimumCount`) using `currentRound.RealTimeMinersInformation.Count`, but the secrets being decoded were created using a previous round's miner count.

During off-chain secret encoding, the service correctly uses the appropriate round's miner count: [2](#0-1) 

The Shamir's Secret Sharing implementation creates a polynomial of degree `threshold-1`: [3](#0-2) 

The decoding function uses Lagrange interpolation with exactly `threshold` points: [4](#0-3) 

**Exploitation Timeline:**
1. **Round N-1 (7 miners):** SecretSharingInformation event fired for Round N, secrets encoded with threshold = ⌊7×2/3⌋ = 4
2. **Round N (transitions to 5 miners):** Miner list changes via NextTerm or miner replacement [5](#0-4) 
3. **Round N+1 (5 miners):** When revealing Round N's secrets, uses threshold = ⌊5×2/3⌋ = 3
4. **Decoding failure:** Attempts to reconstruct a degree-3 polynomial using only 3 points when 4 are required
5. **Result:** Lagrange interpolation produces mathematically incorrect InValue

The validation check does not prevent this: [6](#0-5) 

This check only verifies sufficient pieces exist (7 pieces from the previous round > 5 required), allowing the mismatched decoding to proceed.

## Impact Explanation

**Consensus Randomness Corruption:** The incorrectly reconstructed `PreviousInValue` is stored and propagated: [7](#0-6) 

InValues form the foundation of the consensus random beacon, which affects:
- Miner selection and ordering for subsequent rounds
- Block validation via random number generation
- Time slot assignments and expected mining times

**Quantified Impact:**
- **Automatic Trigger:** Occurs deterministically during every round transition where `previousRound.MinerCount > currentRound.MinerCount`
- **Protocol-Wide Effect:** Affects all consensus participants simultaneously, not isolated to specific miners
- **Undetectable:** The corrupted value appears cryptographically valid since it passes through the same hash function
- **Consensus Divergence Risk:** Different nodes may compute different "revealed" values if they process updates in different orders
- **Security Guarantee Violation:** Breaks the unpredictability guarantee of the random beacon, which is critical for fair miner selection

This is a **HIGH severity** issue because it corrupts a core consensus invariant during normal protocol operations without requiring any attacker action.

## Likelihood Explanation

**No Attacker Required:** This is a deterministic protocol bug triggered by legitimate operations. The function is invoked automatically during round transitions: [8](#0-7) 

Miner list changes occur during:
- **Term transitions:** Regular protocol operation when new election results take effect [9](#0-8) 
- **Evil miner replacement:** Security feature that removes malicious nodes
- **Maximum miners count adjustments:** Governance-controlled parameter changes

**Execution Certainty:**
- Triggers whenever the miner count decreases between the round where secrets were encoded and the round where they are decoded
- Example: 7 miners → 5 miners produces threshold 4 → 3 mismatch
- No special permissions required beyond normal consensus participation
- The protocol explicitly supports miner count changes via `IsMinerListJustChanged` flag: [10](#0-9) 

**Probability Assessment:** **HIGH** - Term transitions and miner list updates are regular protocol events, not rare edge cases.

## Recommendation

Fix the threshold mismatch by using the same round's miner count for both encoding and decoding. Modify `RevealSharedInValues` to use the `previousRound`'s miner count (the round containing the secrets) instead of `currentRound`'s count:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;
    if (!TryToGetPreviousRoundInformation(out var previousRound)) return;
    
    // FIX: Use previousRound's count for decoding, matching the encoding threshold
    var minersCount = previousRound.RealTimeMinersInformation.Count;
    var minimumCount = minersCount.Mul(2).Div(3);
    minimumCount = minimumCount == 0 ? 1 : minimumCount;
    
    foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
    {
        // ... rest of the logic remains the same
    }
}
```

This ensures the decoding threshold matches the encoding threshold used when the secrets were created, maintaining cryptographic correctness regardless of miner count changes.

## Proof of Concept

The vulnerability can be demonstrated by creating a test scenario where:
1. Round N-1 has 7 miners and fires SecretSharingInformation
2. Off-chain service encodes secrets with threshold = 4 (7×2/3)
3. Round N transitions to 5 miners via NextTerm
4. Round N+1 calls RevealSharedInValues with threshold = 3 (5×2/3)
5. Verify that DecodeSecret with threshold=3 produces a different result than the original InValue when the polynomial was created with threshold=4

The mathematical proof: A degree-3 polynomial requires 4 points to uniquely determine its coefficients. Using only 3 points will fit a different degree-2 polynomial through those points, producing an incorrect value at x=0 (the secret).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-22)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L101-104)
```csharp
        var minersCount = secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        var secretShares =
            SecretSharingHelper.EncodeSecret(newInValue.ToByteArray(), minimumCount, minersCount);
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L14-19)
```csharp
        public static List<byte[]> EncodeSecret(byte[] secretMessage, int threshold, int totalParts)
        {
            // Polynomial construction.
            var coefficients = new BigInteger[threshold];
            // Set p(0) = secret message.
            coefficients[0] = secretMessage.ToBigInteger();
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-48)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L42-42)
```csharp
        round.IsMinerListJustChanged = true;
```
