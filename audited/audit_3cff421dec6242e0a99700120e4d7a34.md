### Title
Missing LIB Validation in NextRound/NextTerm Allows Manipulation of Consensus Irreversible Block Height

### Summary
The `LibInformationValidationProvider` is only applied to `UpdateValue` consensus behavior, leaving `NextRound` and `NextTerm` behaviors without validation of `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields. A malicious miner producing a NextRound or NextTerm block can artificially advance these values, causing the consensus contract to store inflated LIB heights that suppress legitimate LIB updates until the real consensus catches up, delaying blockchain finality.

### Finding Description

**Root Cause**: The validation logic selectively applies LIB validation only to UpdateValue behavior while NextRound and NextTerm behaviors store LIB values without any validation. [1](#0-0) 

The `LibInformationValidationProvider` is added to the validation chain only when `extraData.Behaviour == AElfConsensusBehaviour.UpdateValue`. For NextRound and NextTerm behaviors, it is never invoked. [2](#0-1) 

The validation checks if provided LIB values are non-zero and not regressing compared to base round, but this validation is unreachable for NextRound/NextTerm.

**Why UpdateValue is Also Ineffective**: When generating UpdateValue headers, the Round object is simplified and LIB fields are NOT copied: [3](#0-2) 

The simplified Round created by `GetUpdateValueRound` creates a new Round object containing only miner-specific information, omitting `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` entirely. These fields default to 0, causing the validation at lines 14-15 of LibInformationValidationProvider to always fail the non-zero check, making it a no-op.

**Why NextRound/NextTerm Are Vulnerable**: For NextRound and NextTerm, the full Round WITH LIB fields is included: [4](#0-3) [5](#0-4) 

These inputs include `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields copied from the Round, but there is no validation to ensure they are correct.

**Direct Storage Without Validation**: When processing NextRound/NextTerm, the input is directly converted to a Round and stored: [6](#0-5) 

At line 110, `input.ToRound()` converts the input directly, and at line 156, `AddRoundInformation(nextRound)` stores it to state without recalculating or validating the LIB fields. [7](#0-6) 

Similarly for NextTerm at lines 163 and 196 (not shown but follows same pattern).

**Suppression of Real LIB Updates**: The LIB update logic in ProcessUpdateValue only advances LIB if the new calculated value exceeds the stored value: [8](#0-7) 

At line 272, the check `if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)` prevents LIB from being updated if a malicious miner has already artificially advanced it. This means an inflated LIB value will block real updates until consensus catches up.

**Validation Gap**: The `RoundTerminateValidationProvider` used for NextRound/NextTerm only validates round number and term number, NOT LIB fields: [9](#0-8) 

### Impact Explanation

**Consensus Integrity Violation**: The Last Irreversible Block (LIB) height is a critical consensus parameter that determines blockchain finality. By manipulating it:

1. **Delayed Finality**: Legitimate LIB updates calculated from miner consensus are suppressed. The check at line 272 of ProcessConsensusInformation prevents updates when stored LIB exceeds calculated LIB, creating a finality gap where blocks that should become irreversible remain in a reversible state.

2. **Event Suppression**: No `IrreversibleBlockFound` events are fired during the suppression period: [10](#0-9) 

This event is consumed by the blockchain service to update the chain's LIB, so the system-wide finality marker is also not advanced.

3. **Cross-Chain Impact**: Cross-chain operations depend on accurate LIB heights for parent/side chain indexing and merkle proof verification. An artificially inflated LIB could cause cross-chain message verification to incorrectly accept or reject proofs.

4. **Mining Parameter Manipulation**: The inflated LIB affects `GetMaximumBlocksCount`: [11](#0-10) 

Lines 25-26 use the stored LIB values to evaluate blockchain mining status, potentially causing incorrect throttling or allowance of block production.

**Severity**: HIGH - This violates the critical invariant that "LIB height rules" must be correct, directly impacting consensus integrity and cross-chain operations.

### Likelihood Explanation

**Reachable Entry Point**: The attack leverages the public consensus flow. Any miner assigned as the extra block producer for a round can trigger NextRound behavior: [12](#0-11) 

The `GetConsensusCommand` method determines behavior, and when a miner's time slot passes as the extra block producer, they can produce a NextRound block.

**Attacker Capabilities**: 
- Attacker must be a valid miner in the current round
- Must wait to become the extra block producer (rotates through miners)
- Can modify the Round data in their block header between receiving it from `GetConsensusExtraData` and including it in the block
- No special privileges beyond being a miner are required

**Execution Steps**:
1. Attacker is assigned as extra block producer
2. Calls `GetConsensusExtraData` to get suggested NextRound data with correct LIB (e.g., height=1000)
3. Modifies the Round in header to set `ConfirmedIrreversibleBlockHeight` to inflated value (e.g., height=1500)
4. Sets `ConfirmedIrreversibleBlockRoundNumber` to plausible corresponding value
5. Block passes validation (LibInformationValidationProvider not invoked)
6. ProcessNextRound stores manipulated values to state
7. Subsequent UpdateValue blocks cannot advance LIB past 1500 until real consensus reaches it
8. Finality delayed by 500 blocks worth of time

**Detection**: Difficult to detect without comparing consensus contract's LIB against blockchain service's LIB or analyzing event logs for gaps in IrreversibleBlockFound events.

**Economic Rationality**: Low cost (just modification of header data), high impact (delays finality for all network participants).

### Recommendation

1. **Add LIB Validation for NextRound/NextTerm**: Extend the validation provider list in `AEDPoSContract_Validation.cs`:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

2. **Regenerate LIB in Processing**: Instead of trusting the input, regenerate the LIB fields in `ProcessNextRound` and `ProcessNextTerm`:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    // Preserve correct LIB from current round instead of trusting input
    TryToGetCurrentRoundInformation(out var currentRound);
    nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
    nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
    
    // ... rest of processing
}
```

3. **Strengthen LibInformationValidationProvider**: Add validation that LIB fields are consistent with blockchain state, not just non-regressing.

4. **Test Cases**: Add tests that attempt to:
   - Provide NextRound input with inflated LIB values
   - Provide mismatched height/round pairs
   - Verify rejection or correction of manipulated values

### Proof of Concept

**Initial State**:
- Current round N at height 5000, round number 100
- Current LIB: height=4900, round=99
- Attacker is extra block producer for round N

**Attack Sequence**:
1. Attacker calls `GetConsensusCommand` → receives NextRound command
2. Attacker calls `GetConsensusExtraData` → receives NextRoundInput with correct LIB (4900/99)
3. Attacker modifies NextRoundInput: sets `ConfirmedIrreversibleBlockHeight = 5100`, `ConfirmedIrreversibleBlockRoundNumber = 102`
4. Attacker includes modified NextRoundInput in block header
5. Block validation runs:
   - `LibInformationValidationProvider` is NOT in validation list (lines 84-92 of AEDPoSContract_Validation.cs)
   - `RoundTerminateValidationProvider` checks round number (100+1=101 ✓) but NOT LIB fields
   - Validation passes ✓
6. `ProcessNextRound` executes:
   - Line 110: Converts input to Round with LIB=5100/102
   - Line 156: Stores to state
7. Round N+1 now has LIB=5100/102 (artificially advanced by 200 blocks)
8. Next UpdateValue block calculates real LIB (e.g., 4920):
   - Line 272 check: `if (5100 < 4920)` → FALSE
   - LIB update skipped, no `IrreversibleBlockFound` event fired
9. This continues until real LIB calculation reaches 5101

**Expected Result**: Block rejected or LIB corrected to 4900/99

**Actual Result**: Block accepted, LIB set to 5100/102, finality delayed by ~200 blocks

**Success Condition**: Query consensus contract's Round state and observe `ConfirmedIrreversibleBlockHeight = 5100` despite actual consensus being at 4900, with no IrreversibleBlockFound events fired between 4900 and when real consensus eventually reaches 5101.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-56)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = pubkey,
                    OutValue = minerInRound.OutValue,
                    Signature = minerInRound.Signature,
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    PreviousInValue = minerInRound.PreviousInValue,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
                    Order = minerInRound.Order,
                    IsExtraBlockProducer = minerInRound.IsExtraBlockProducer
                }
            }
        };
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-175)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-39)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```
