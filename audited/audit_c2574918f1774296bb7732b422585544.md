### Title
Missing Organization Address Validation in Cross-Chain Indexing Proposal Release Allows Bypass of Controller Authority

### Summary
The `HandleIndexingProposal()` function fails to validate that a proposal's organization address matches the current controller's owner address before releasing it, unlike the validation present in `GetIndexingProposalStatus()`. This allows proposals approved under a previous controller to be released after the controller has been changed, bypassing the new controller's authority and potentially indexing malicious or outdated cross-chain data.

### Finding Description
The vulnerability exists in the proposal release flow where two functions handle the same proposal validation differently:

**Correct Validation (View Function):** [1](#0-0) 

The `GetIndexingProposalStatus()` function correctly validates both conditions before marking a proposal as ready for release.

**Missing Validation (Execution Function):** [2](#0-1) 

The `HandleIndexingProposal()` function only checks `proposal.ToBeReleased` without verifying that `proposal.OrganizationAddress` matches the current `crossChainIndexingController.OwnerAddress`.

**Root Cause:**
When proposals are created via `ProposeCrossChainBlockData()`, they are assigned the organization address from the controller at creation time: [3](#0-2) 

If the controller is subsequently changed via `ChangeCrossChainIndexingController()`: [4](#0-3) 

The change does NOT clear existing pending proposals, and `HandleIndexingProposal()` does not validate that proposals belong to the current controller before releasing them.

**Execution Path:** [5](#0-4) [6](#0-5) 

### Impact Explanation
**Authorization Bypass:** Proposals approved by a previous controller organization can be released after the controller has been changed to a different organization, completely bypassing the new controller's authority.

**Governance Integrity Violation:** If the controller is changed to upgrade security (e.g., from a compromised organization to a secure one), old malicious proposals can still be released, defeating the purpose of the controller change.

**Cross-Chain Data Integrity:** Malicious or outdated cross-chain block data from the old organization can be indexed into the chain, potentially enabling:
- Invalid merkle proof verification paths
- Incorrect parent/side-chain height synchronization  
- Acceptance of fraudulent cross-chain transactions

**Affected Parties:** All participants relying on cross-chain data integrity, including users of side chains and cross-chain assets.

**Severity:** Critical - This violates the fundamental governance invariant that only the current authorized controller should be able to approve and release cross-chain indexing proposals.

### Likelihood Explanation
**Attacker Capabilities:** An attacker needs to either:
1. Have a proposal approved under a controller that will later be changed, OR
2. Compromise a controller temporarily, get proposals approved, then after the controller is fixed, release those old proposals

**Attack Complexity:** Medium
- Requires a controller change to occur (governance event)
- Pending proposals must exist that are approved but not yet released
- Timing window between approval and release

**Feasibility Conditions:**
- Controller changes are rare but legitimate governance operations
- Proposals can remain pending for blocks before release
- No automatic cleanup of old proposals on controller change

**Detection/Operational Constraints:** The vulnerability would be difficult to detect as the proposal release appears legitimate (it is marked `ToBeReleased`), and the missing organization check is subtle.

**Probability:** Medium - While controller changes are uncommon, when they do occur (especially security upgrades), the vulnerability can be exploited during the transition window.

### Recommendation
**Immediate Fix:** Add organization address validation to `HandleIndexingProposal()`:

```csharp
private void HandleIndexingProposal(Hash proposalId)
{
    var crossChainIndexingController = GetCrossChainIndexingController();
    var proposal = GetCrossChainProposal(crossChainIndexingController, proposalId);
    Assert(proposal.ToBeReleased, "Not approved cross chain indexing proposal.");
    // ADD THIS CHECK:
    Assert(proposal.OrganizationAddress == crossChainIndexingController.OwnerAddress,
        "Proposal organization does not match current controller.");
    Context.SendInline(crossChainIndexingController.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release),
        proposal.ProposalId);
}
```

**Additional Safeguard:** Clear all pending cross-chain indexing proposals when the controller is changed:

```csharp
public override Empty ChangeCrossChainIndexingController(AuthorityInfo input)
{
    AssertCrossChainIndexingControllerAuthority(Context.Sender);
    SetContractStateRequired(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);
    Assert(
        input.ContractAddress == State.ParliamentContract.Value &&
        ValidateParliamentOrganization(input.OwnerAddress), "Invalid authority input.");
    
    // ADD: Clear all pending proposals
    State.IndexingPendingProposal.Value = new ProposedCrossChainIndexing();
    
    State.CrossChainIndexingController.Value = input;
    Context.Fire(new CrossChainIndexingControllerChanged
    {
        AuthorityInfo = input
    });
    return new Empty();
}
```

**Test Cases:**
1. Create proposal under ControllerA
2. Approve proposal 
3. Change controller to ControllerB
4. Attempt to release old proposal - should FAIL with organization mismatch
5. Verify pending proposals are cleared on controller change

### Proof of Concept

**Initial State:**
- CrossChainIndexingController set to Parliament contract with OrganizationA
- OrganizationA members are the current miners

**Exploitation Steps:**

1. **Miner proposes cross-chain data:**
   - Call `ProposeCrossChainIndexing()` with malicious cross-chain block data
   - Proposal created with `OrganizationAddress = OrganizationA`
   - Proposal ID stored in `State.IndexingPendingProposal`

2. **OrganizationA approves the proposal:**
   - Miners vote on the proposal in Parliament contract
   - Proposal reaches approval threshold
   - `proposal.ToBeReleased = true`

3. **Controller is changed (security upgrade):**
   - Governance votes to change controller to OrganizationB (more secure)
   - Call `ChangeCrossChainIndexingController()` with new AuthorityInfo
   - `State.CrossChainIndexingController.Value` now points to OrganizationB
   - Old proposal still exists in `State.IndexingPendingProposal` with `OrganizationAddress = OrganizationA`

4. **Attacker releases old proposal:**
   - Miner calls `ReleaseCrossChainIndexingProposal(chainIdList)`
   - `HandleIndexingProposal()` executes:
     - Gets current controller (OrganizationB)
     - Queries proposal (has OrganizationAddress = OrganizationA)
     - Checks only `proposal.ToBeReleased` (TRUE) âœ“
     - **MISSING:** Check if `OrganizationAddress == OrganizationB.OwnerAddress` (would be FALSE)
     - Releases the proposal

5. **Result:**
   - Malicious cross-chain data approved by compromised OrganizationA is indexed
   - OrganizationB never had a chance to review or reject the proposal
   - Authorization bypass complete

**Expected vs Actual:**
- **Expected:** Proposal from old organization should be rejected after controller change
- **Actual:** Proposal is released without checking organization match

**Success Condition:** Old proposal successfully released and cross-chain data indexed despite controller change.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L177-179)
```csharp
            pendingChainIndexingProposalStatus.ToBeReleased =
                proposalInfo.ToBeReleased &&
                proposalInfo.OrganizationAddress == crossChainIndexingController.OwnerAddress;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L297-307)
```csharp
    private void ReleaseIndexingProposal(IEnumerable<int> chainIdList)
    {
        foreach (var chainId in chainIdList)
        {
            var pendingProposalExists = TryGetIndexingProposalWithStatus(chainId,
                CrossChainIndexingProposalStatus.Pending,
                out var pendingCrossChainIndexingProposal);
            Assert(pendingProposalExists, "Chain indexing not proposed.");
            HandleIndexingProposal(pendingCrossChainIndexingProposal.ProposalId);
        }
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L392-409)
```csharp
        var crossChainIndexingController = GetCrossChainIndexingController();
        foreach (var chainId in crossChainDataDto.GetChainIdList())
        {
            Assert(!TryGetIndexingProposal(chainId, out _), "Chain indexing already proposed.");
            var proposalToken =
                HashHelper.ConcatAndCompute(Context.PreviousBlockHash, ConvertChainIdToHash(chainId));
            var proposalCreationInput = new CreateProposalBySystemContractInput
            {
                ProposalInput = new CreateProposalInput
                {
                    Params = new AcceptCrossChainIndexingProposalInput
                    {
                        ChainId = chainId
                    }.ToByteString(),
                    ContractMethodName = nameof(AcceptCrossChainIndexingProposal),
                    ExpiredTime =
                        Context.CurrentBlockTime.AddSeconds(CrossChainIndexingProposalExpirationTimePeriod),
                    OrganizationAddress = crossChainIndexingController.OwnerAddress,
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L455-463)
```csharp
    private void HandleIndexingProposal(Hash proposalId)
    {
        var crossChainIndexingController = GetCrossChainIndexingController();
        var proposal = GetCrossChainProposal(crossChainIndexingController, proposalId);
        Assert(proposal.ToBeReleased, "Not approved cross chain indexing proposal.");
        Context.SendInline(crossChainIndexingController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release),
            proposal.ProposalId); // release if ready
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L61-74)
```csharp
    public override Empty ChangeCrossChainIndexingController(AuthorityInfo input)
    {
        AssertCrossChainIndexingControllerAuthority(Context.Sender);
        SetContractStateRequired(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);
        Assert(
            input.ContractAddress == State.ParliamentContract.Value &&
            ValidateParliamentOrganization(input.OwnerAddress), "Invalid authority input.");
        State.CrossChainIndexingController.Value = input;
        Context.Fire(new CrossChainIndexingControllerChanged
        {
            AuthorityInfo = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```
