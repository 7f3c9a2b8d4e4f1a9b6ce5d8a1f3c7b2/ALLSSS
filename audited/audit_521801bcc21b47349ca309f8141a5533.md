### Title
Cross-Chain Height Binding DOS via Unchecked Future Child Heights

### Summary
The `BindParentChainHeight` function and its validation logic fail to verify that child chain heights in `IndexedMerklePath` are legitimate (e.g., at or below current height). A malicious miner can propose parent chain block data containing arbitrary future child heights, which if approved by parliament, permanently bind these heights to incorrect parent chain heights, causing permanent denial-of-service for cross-chain operations at those heights.

### Finding Description

The vulnerability exists in the cross-chain indexing flow involving three key locations:

**Location 1:** The `BindParentChainHeight` function performs no validation on the `childHeight` parameter beyond checking if it's already bound: [1](#0-0) 

**Location 2:** The `ValidateParentChainBlockData` function only checks if child heights haven't been bound before, but never validates that these heights are reasonable or correspond to actual child chain blocks: [2](#0-1) 

**Location 3:** During indexing, `IndexParentChainBlockData` blindly processes all heights from `IndexedMerklePath` without verification: [3](#0-2) 

**Root Cause:** The contract assumes miners will provide honest data and relies entirely on off-chain validation by parliament members. There is no on-chain check ensuring that heights in `IndexedMerklePath` represent actual child chain blocks or are within reasonable bounds (e.g., not future heights).

**Why Existing Protections Fail:**
- Authorization checks only verify the caller is a miner, not data validity [4](#0-3) 

- Parliament approval is a governance vote without cryptographic data verification
- No mechanism exists to unbind or correct erroneous height bindings (verified via grep search showing only 3 assignment locations, no deletion operations)

### Impact Explanation

**Direct Harm:**
When future heights are incorrectly bound, cross-chain verification operations that depend on `GetBoundParentChainHeightAndMerklePathByHeight` will use wrong merkle paths: [5](#0-4) 

This breaks cross-chain token transfers and transaction verification: [6](#0-5) 

**Quantified Impact:**
- Permanent DOS: Affected heights can NEVER be rebound correctly (no unbind mechanism exists)
- Scope: Attacker can DOS multiple heights in a single proposal
- Cascading failure: All cross-chain operations (token transfers, verification, state synchronization) for affected heights are permanently broken

**Who is Affected:**
- Users attempting cross-chain token transfers from affected heights
- DApps relying on cross-chain verification
- The entire side chain's cross-chain functionality for specific height ranges

**Severity Justification:** HIGH - While not direct fund theft, this causes permanent, irreversible DOS of critical cross-chain infrastructure with no recovery mechanism.

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Must be a current miner (verified by `AssertAddressIsCurrentMiner`) [7](#0-6) 

2. Must obtain parliament approval for the malicious proposal

**Attack Complexity:** MEDIUM
- Miner status is privileged but achievable for determined attackers
- Parliament members cannot cryptographically verify `IndexedMerklePath` data on-chain
- Off-chain validation requires manual comparison with parent chain state, which may be skipped

**Feasibility Conditions:**
- Attacker is an active miner OR compromises a miner node
- Parliament members don't thoroughly validate the proposed data off-chain
- More feasible if attacker controls minority parliament votes

**Detection Constraints:**
- Malicious data appears structurally valid (passes all on-chain checks)
- Detection requires comparing proposed heights with actual parent chain indexing data
- Damage only becomes apparent when affected heights are reached

**Probability Assessment:** MEDIUM-HIGH
Given that parliament approval is primarily a governance vote without built-in cryptographic verification, and miners have significant influence in the system, a coordinated attack by a malicious miner with some parliament support is practically feasible.

### Recommendation

**Code-Level Mitigation:**
Add height bound validation in `ValidateParentChainBlockData` after line 730:

```csharp
// Add this check after line 730
if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
        indexedBlockInfo.Key > Context.CurrentHeight + MaxFutureHeightGap))
    return false;
```

Where `MaxFutureHeightGap` is a reasonable constant (e.g., 0 for no future heights, or small buffer for network delays).

**Invariant Checks to Add:**
1. `childHeight <= Context.CurrentHeight + buffer` in `BindParentChainHeight`
2. Optional: Add recovery mechanism to rebind heights with governance approval
3. Add event logging for all height bindings for off-chain monitoring

**Test Cases:**
1. Test that parent chain data with future heights (childHeight > CurrentHeight) is rejected
2. Test that parent chain data with heights equal to CurrentHeight is accepted
3. Test that attempting to index same height twice is rejected
4. Test cross-chain verification fails when using incorrectly bound heights

### Proof of Concept

**Required Initial State:**
- Side chain initialized with parent chain ID
- Current side chain height: 100
- Attacker is an active miner
- Attacker controls sufficient parliament votes or parliament doesn't validate thoroughly

**Transaction Sequence:**

1. **Attacker proposes malicious parent chain data:**
   - Fetch legitimate parent chain block data for height 50
   - Modify `IndexedMerklePath` to include future heights: `{1000: legitMerklePath, 1001: legitMerklePath2}`
   - Call `ProposeCrossChainIndexing` with modified data
   - Validation passes because heights 1000, 1001 haven't been bound yet

2. **Parliament approves:**
   - Parliament votes on proposal (unable to verify off-chain that heights are wrong)
   - Proposal status becomes `ToBeReleased`

3. **Attacker releases proposal:**
   - Call `ReleaseCrossChainIndexingProposal`
   - `RecordCrossChainData` â†’ `IndexParentChainBlockData` executes
   - Heights 1000, 1001 get bound to parent height 50

4. **Expected vs Actual:**
   - **Expected:** Only actual indexed heights (e.g., 95-99) should be bound
   - **Actual:** Future heights 1000, 1001 are now bound to parent height 50

5. **Success Condition:**
   - Call `GetBoundParentChainHeightAndMerklePathByHeight(1000)` - succeeds with wrong parent height
   - When side chain reaches height 1000 later, cross-chain verification fails because merkle path is for height ~95, not 1000
   - Height 1000 can never be correctly re-bound (no unbind mechanism)
   - Cross-chain operations from height 1000 are permanently broken

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L27-32)
```csharp
    private void BindParentChainHeight(long childHeight, long parentHeight)
    {
        Assert(State.ChildHeightToParentChainHeight[childHeight] == 0,
            $"Already bound at height {childHeight} with parent chain");
        State.ChildHeightToParentChainHeight[childHeight] = parentHeight;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L731-734)
```csharp
            if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
                    State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
                    State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
                return false;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L776-780)
```csharp
            foreach (var indexedBlockInfo in blockInfo.IndexedMerklePath)
            {
                BindParentChainHeight(indexedBlockInfo.Key, parentChainHeight);
                AddIndexedTxRootMerklePathInParentChain(indexedBlockInfo.Key, indexedBlockInfo.Value);
            }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-291)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L19-30)
```csharp
    public override CrossChainMerkleProofContext GetBoundParentChainHeightAndMerklePathByHeight(Int64Value input)
    {
        var boundParentChainHeight = State.ChildHeightToParentChainHeight[input.Value];
        Assert(boundParentChainHeight != 0);
        var merklePath = State.TxRootMerklePathInParentChain[input.Value];
        Assert(merklePath != null);
        return new CrossChainMerkleProofContext
        {
            MerklePathFromParentChain = merklePath,
            BoundParentChainHeight = boundParentChainHeight
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```
