### Title
Unprotected Dictionary Access in UpdateValueValidationProvider Causes KeyNotFoundException During Consensus Validation

### Summary
The `UpdateValueValidationProvider` accesses `ProvidedRound.RealTimeMinersInformation[SenderPubkey]` without verifying the key exists, allowing any valid miner to craft malicious consensus extra data that causes `KeyNotFoundException` during block validation. This can disrupt consensus validation across the network, though the vulnerability is in the validation phase rather than strategy instantiation as originally described.

### Finding Description

The vulnerability exists in the consensus validation flow, specifically in `UpdateValueValidationProvider`: [1](#0-0) 

The `NewConsensusInformationFilled` method directly accesses `validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey]` without checking if the key exists. The `ProvidedRound` comes from attacker-controlled block header data: [2](#0-1) 

Additional unprotected accesses exist in the same class: [3](#0-2) 

Lines 42 and 45 access `extraData.Round.RealTimeMinersInformation[publicKey]` only checking if the key exists in `PreviousRound`, not in the `ProvidedRound` being accessed.

**Why existing protections fail:**

The `MiningPermissionValidationProvider` only validates against `BaseRound` (from state), not `ProvidedRound` (from block header): [4](#0-3) 

The `RecoverFromUpdateValue` method has protection but only returns early without enforcing that `ProvidedRound` must contain the sender's pubkey: [5](#0-4) 

The validation service stops on first failure but the `MiningPermissionValidationProvider` passes before reaching `UpdateValueValidationProvider`: [6](#0-5) [7](#0-6) 

**Note:** The original question references strategy instantiation in `CommandStrategyBase.cs`, but that path is protected: [8](#0-7) 

The `IsInMinerList` check validates the pubkey exists before any strategy is instantiated: [9](#0-8) 

### Impact Explanation

**Operational DoS Impact:**
- Any valid miner can produce a block with consensus extra data (`ExtraData.Round`) that excludes their own pubkey from `RealTimeMinersInformation`
- When other nodes validate this block via `ValidateConsensusBeforeExecution`, an unhandled `KeyNotFoundException` is thrown
- This disrupts block validation across all nodes receiving the malicious block
- Repeated attacks can cause consensus delays or validation failures network-wide

**Affected Parties:**
- All validating nodes in the network (not just the attacker)
- Consensus integrity and block production continuity

**Severity Justification:**
- High severity due to ability to disrupt consensus validation
- Any current miner can exploit (low attacker privilege requirement)
- Causes unhandled exceptions that could crash validation processes
- Can be repeated to create sustained DoS

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a valid miner in the current round (checked in state)
- Can craft arbitrary consensus extra data in produced blocks
- No economic cost beyond normal block production

**Attack Complexity:**
- Low complexity: Simply omit own pubkey from `RealTimeMinersInformation` in block's consensus extra data
- The provided round structure is not validated to match the base round's miner list

**Feasibility Conditions:**
- Entry point is public: `ValidateConsensusBeforeExecution` called by blockchain infrastructure
- No special permissions needed beyond being an active miner
- Attack is deterministic and repeatable

**Detection:**
- Would appear as validation exceptions in node logs
- Network would see blocks rejected, but determining malicious intent vs. bugs may be difficult

**Probability:**
High likelihood - the vulnerability is trivially exploitable by any active miner with no validation preventing the malicious data structure.

### Recommendation

**Immediate Fix:**

Add validation in `UpdateValueValidationProvider` to check key existence before dictionary access:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    // Add this check
    if (!validationContext.ProvidedRound.RealTimeMinersInformation.ContainsKey(validationContext.SenderPubkey))
        return false;
        
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    return minerInRound.OutValue != null && minerInRound.Signature != null &&
           minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
}

private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;

    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
        return true;

    // Add this check before accessing extraData.Round
    if (!extraData.Round.RealTimeMinersInformation.ContainsKey(publicKey))
        return false;

    if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) 
        return true;
    // ... rest of method
}
```

**Structural Improvement:**

Add a validation provider that enforces `ProvidedRound.RealTimeMinersInformation` must contain `SenderPubkey` and have matching miner lists with `BaseRound`. Add this before `UpdateValueValidationProvider` in the validation pipeline.

**Test Cases:**

1. Test block validation with `ProvidedRound` missing sender's pubkey - should fail gracefully
2. Test block validation with `ProvidedRound` containing extra/missing miners vs. `BaseRound` - should validate miner list consistency
3. Test that legitimate blocks with correct `ProvidedRound` still pass validation

### Proof of Concept

**Initial State:**
- MinerA is a valid miner in current round (in state's `CurrentRound.RealTimeMinersInformation`)
- Network has multiple validating nodes

**Attack Steps:**

1. MinerA produces a block with `AElfConsensusBehaviour.UpdateValue`
2. MinerA crafts `AElfConsensusHeaderInformation` where:
   - `ExtraData.SenderPubkey` = MinerA's pubkey (signed correctly)
   - `ExtraData.Round.RealTimeMinersInformation` = dictionary excluding MinerA's pubkey (only contains other miners)
3. MinerA broadcasts the block to the network
4. Other nodes receive block and call `ValidateConsensusBeforeExecution`
5. Validation flow:
   - `MiningPermissionValidationProvider` checks `BaseRound` (from state) â†’ passes (MinerA is valid)
   - `UpdateValueValidationProvider.NewConsensusInformationFilled` called
   - Attempts: `ProvidedRound.RealTimeMinersInformation[MinerA's pubkey]`
   - Result: `KeyNotFoundException` thrown

**Expected vs Actual:**
- Expected: Validation should fail gracefully with validation error message
- Actual: Unhandled `KeyNotFoundException` propagates, potentially crashing validation

**Success Condition:**
The attack succeeds if validating nodes throw `KeyNotFoundException` instead of returning a proper `ValidationResult` with `Success = false`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L40-46)
```csharp
        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-13)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-82)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ValidationService.cs (L16-26)
```csharp
    public ValidationResult ValidateInformation(ConsensusValidationContext validationContext)
    {
        foreach (var headerInformationValidationProvider in _headerInformationValidationProviders)
        {
            var result =
                headerInformationValidationProvider.ValidateHeaderInformation(validationContext);
            if (!result.Success) return result;
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L23-27)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```
