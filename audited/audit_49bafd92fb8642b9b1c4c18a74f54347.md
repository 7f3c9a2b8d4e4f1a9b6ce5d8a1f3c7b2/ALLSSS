### Title
Treasury Funds Permanently Locked When Removed Symbols Become Ineligible for Re-addition

### Summary
The `SetSymbolList` function replaces the entire symbol list without distributing existing balances, and later status changes to removed symbols can prevent their re-addition, permanently locking funds in the TreasuryVirtualAddress. Symbols removed from the list are excluded from profit distribution, and if their eligibility status changes (becoming convertible or unprofitable), the validation in SetSymbolList will prevent recovery.

### Finding Description

The `SetSymbolList` function in TreasuryContract.cs completely replaces the symbol list used for profit distribution: [1](#0-0) 

The function validates each non-native symbol must either be available for method fees OR have treasury whitelisted, AND must NOT be convertible: [2](#0-1) 

When the Treasury releases profits via `Release()`, it only includes symbols from the current SymbolList.Value in the AmountsMap: [3](#0-2) 

The Profit contract's `DistributeProfits` only processes symbols present in the AmountsMap. When amount is 0, it queries the balance and distributes it: [4](#0-3) 

**Root Cause:** If a symbol X is removed from SymbolList and subsequently:
1. The TokenConverter enables selling for X (IsSymbolAbleToSell returns true), OR
2. X becomes unprofitable (IsBurnable becomes false) AND treasury is not whitelisted

Then SetSymbolList validation will fail when attempting to re-add X, and the funds are permanently inaccessible because:
- DistributeProfits is the ONLY way to transfer from scheme virtual address
- No emergency withdrawal or rescue mechanism exists in the Profit contract
- The virtual address can only be controlled via `SendVirtualInline` which requires the scheme manager (Treasury contract) to call DistributeProfits [5](#0-4) 

### Impact Explanation

**Direct Fund Loss:** Any token balance in TreasuryVirtualAddress for removed symbols becomes permanently locked if the symbol's status changes to make it ineligible for re-addition. The Treasury holds significant value from mining rewards, transaction fees, and resource consumption.

**Affected Parties:**
- All Treasury beneficiaries (miners, voters, citizens) lose access to profit distribution from locked tokens
- The overall economic system loses flexibility in managing multi-token rewards

**Severity Justification:** HIGH
- Permanent and irreversible loss of funds
- No recovery mechanism exists even via emergency governance
- Affects core Treasury operations managing substantial protocol value
- Impact scales with the amount of locked token balance

### Likelihood Explanation

**Attack Vector:** This is not a direct attack but an operational risk that can occur through:
1. Governance legitimately removing a symbol from the list (e.g., to phase out a token)
2. External state changes to token properties that are common in live systems:
   - TokenConverter connector configuration changes (enabling/disabling purchase)
   - Token IsBurnable property changes
   - Whitelist modifications

**Preconditions:**
- Symbol X exists in SymbolList with balance in TreasuryVirtualAddress
- Governance calls SetSymbolList removing X (requires treasury controller authority)
- TokenConverter configuration changes making X convertible, OR token loses IsBurnable=true status

**Execution Practicality:** HIGH
- Entry point is governance-controlled (not untrusted attacker)
- But the risk is REAL because token properties and converter configurations DO change in production
- No special privileges needed beyond normal token configuration authority
- Status changes are permanent state modifications

**Probability:** MEDIUM-HIGH
- Token converter connector management is an expected operational activity
- Token properties can be modified by token issuers or through governance
- The longer a symbol remains removed, the higher the chance its status changes

### Recommendation

**Immediate Fix:**
Add a safety mechanism in `SetSymbolList` to force distribution of all current balances before updating the list:

```csharp
public override Empty SetSymbolList(SymbolList input)
{
    AssertPerformedByTreasuryController();
    Assert(input.Value.Contains(Context.Variables.NativeSymbol), "Need to contain native symbol.");
    
    // NEW: Distribute any remaining balances for symbols being removed
    var removedSymbols = State.SymbolList.Value.Value
        .Where(s => !input.Value.Contains(s))
        .ToList();
    
    if (removedSymbols.Any())
    {
        var currentPeriod = GetCurrentTreasuryPeriod();
        var amountsMap = removedSymbols.ToDictionary(s => s, s => 0L);
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.TreasuryHash.Value,
            Period = currentPeriod,
            AmountsMap = { amountsMap }
        });
    }
    
    // Continue with existing validation...
}
```

**Alternative Fix:**
Add an emergency withdrawal function that allows treasury controller to extract specific token balances without requiring the symbol to be in the list (with appropriate governance controls).

**Invariant to Add:**
- Before removing symbols from SymbolList, ensure all balances for those symbols are distributed to zero
- Add events/logs when symbols are removed to track potential fund lock scenarios

**Test Cases:**
1. Test removing symbol with balance → verify forced distribution occurs
2. Test re-adding previously removed symbol after status change → verify it works or gracefully handles the case
3. Test emergency withdrawal mechanism for edge case recovery

### Proof of Concept

**Initial State:**
- Symbol "ABC" is in TreasurySymbolList
- TreasuryVirtualAddress has 1,000,000 ABC tokens
- ABC is burnable (IsTokenAvailableForMethodFee returns true)
- ABC is not convertible (IsSymbolAbleToSell returns false)

**Step 1:** Governance calls `SetSymbolList` with a new list excluding "ABC"
- Transaction succeeds
- SymbolList.Value no longer contains "ABC"
- 1,000,000 ABC remains in TreasuryVirtualAddress

**Step 2:** Next `Release()` call occurs
- AmountsMap is built from SymbolList.Value (no "ABC")
- DistributeProfits processes only symbols in AmountsMap
- 1,000,000 ABC is NOT distributed, remains locked

**Step 3:** TokenConverter governance enables ABC connector
- IsSymbolAbleToSell("ABC") now returns true
- OR: ABC token issuer sets IsBurnable to false

**Step 4:** Attempt to recover by calling `SetSymbolList` to re-add "ABC"
- Validation at line 304 fails: "Token ABC doesn't need to set to symbol list because it would become native token after donation"
- OR: Validation at line 302 fails: "Symbol need to be profitable"
- Transaction reverts

**Expected Result:** Symbol can be re-added and funds recovered
**Actual Result:** SetSymbolList validation permanently blocks re-adding the symbol, 1,000,000 ABC is permanently locked in TreasuryVirtualAddress with no recovery mechanism

**Success Condition:** Funds remain inaccessible indefinitely as no code path exists to transfer from scheme virtual address without the symbol being in the distribution list.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L129-134)
```csharp
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.TreasuryHash.Value,
            Period = input.PeriodNumber,
            AmountsMap = { State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L) }
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L282-310)
```csharp
    public override Empty SetSymbolList(SymbolList input)
    {
        AssertPerformedByTreasuryController();
        Assert(input.Value.Contains(Context.Variables.NativeSymbol), "Need to contain native symbol.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        if (State.TokenConverterContract.Value == null)
            State.TokenConverterContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);

        foreach (var symbol in input.Value.Where(s => s != Context.Variables.NativeSymbol))
        {
            var isTreasuryInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
            {
                Symbol = symbol,
                Address = Context.Self
            }).Value;
            Assert(
                State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value ||
                isTreasuryInWhiteList, "Symbol need to be profitable.");
            Assert(!State.TokenConverterContract.IsSymbolAbleToSell.Call(new StringValue { Value = symbol }).Value,
                $"Token {symbol} doesn't need to set to symbol list because it would become native token after donation.");
        }

        State.SymbolList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L433-445)
```csharp
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L596-602)
```csharp
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
```
