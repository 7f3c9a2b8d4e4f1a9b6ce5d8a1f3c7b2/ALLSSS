### Title
Missing FinalOrderOfNextRound Validation Enables Consensus DoS via UpdateValue Manipulation

### Summary
The `RecoverFromUpdateValue` method and `ProcessUpdateValue` execution lack validation for `FinalOrderOfNextRound` values, allowing a malicious miner to inject invalid order values (e.g., 0) for other miners during UpdateValue blocks. This corrupts the consensus round state and causes NextRound validation to fail, resulting in a consensus deadlock where the blockchain cannot progress to the next round.

### Finding Description

**Root Cause:**
The vulnerability exists in two locations where `FinalOrderOfNextRound` values are applied without validation:

1. **During Validation** - `RecoverFromUpdateValue` blindly copies `FinalOrderOfNextRound` from attacker-provided consensus header: [1](#0-0) 

2. **During Execution** - `ProcessUpdateValue` applies `TuneOrderInformation` without validating values: [2](#0-1) 

**Why Protections Fail:**

The UpdateValue validation flow uses multiple validators but none check `FinalOrderOfNextRound`: [3](#0-2) 

The `MiningPermissionValidationProvider` only verifies the sender is in the miner list: [4](#0-3) 

The `UpdateValueValidationProvider` only checks OutValue/Signature and PreviousInValue: [5](#0-4) 

**Execution Path:**

1. Attacker (legitimate miner) modifies node software to inject malicious `FinalOrderOfNextRound=0` for all other miners into the consensus header round
2. During validation, `RecoverFromUpdateValue` copies these invalid values to baseRound
3. No validator detects the invalid values (0 is outside valid range 1 to minersCount)
4. During execution, `ProcessUpdateValue` applies `TuneOrderInformation` with value 0 for other miners
5. Corrupted state is persisted with most miners having `FinalOrderOfNextRound=0`
6. When `GenerateNextRoundInformation` is called, miners with `FinalOrderOfNextRound=0` are ordered first and assigned order 0: [6](#0-5) 

7. NextRound validation fails because `NextRoundMiningOrderValidationProvider` detects invalid order count: [7](#0-6) 

Valid orders must be in range 1 to minersCount as established by the consensus logic: [8](#0-7) [9](#0-8) 

### Impact Explanation

**Harm:**
- **Consensus Deadlock:** The blockchain becomes unable to progress to the next round, halting all block production
- **Operational DoS:** All consensus operations are blocked, preventing new transactions from being confirmed
- **State Corruption:** The round state is permanently corrupted with invalid order assignments
- **Recovery Difficulty:** No automatic recovery mechanism exists; manual intervention or hard fork may be required

**Severity Justification:**
Critical - This vulnerability completely halts the blockchain's consensus mechanism, affecting all users and applications. The entire network becomes non-operational until the corrupted state is manually repaired.

**Affected Parties:**
- All blockchain users (cannot submit/confirm transactions)
- All dApps and contracts (become unusable)
- All miners (cannot produce blocks after corruption)
- The entire network infrastructure

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a legitimate elected/staked miner with block production rights
- Must have technical ability to modify node software to inject malicious consensus data
- Can perform attack during any UpdateValue block in their time slot

**Attack Complexity:**
- Medium - Requires miner status but straightforward to execute once achieved
- Node software modification required to inject malicious values into consensus header
- Single malicious UpdateValue block sufficient to corrupt state

**Feasibility Conditions:**
- Attacker must obtain miner position (via election/staking - moderate cost)
- No cryptographic barriers prevent the attack once miner status obtained
- Attack is detectable on-chain but damage occurs before detection

**Detection Constraints:**
- Corrupted `FinalOrderOfNextRound` values visible in chain state
- NextRound validation failure indicates successful attack
- However, detection occurs after corruption is already persisted

**Probability:**
High for motivated attacker who achieves miner status. The cost of obtaining miner position is moderate (election/staking requirements), but the impact justifies this cost for an attacker seeking to DoS the network.

### Recommendation

**Immediate Mitigation:**
Add validation in both `RecoverFromUpdateValue` and `ProcessUpdateValue`:

1. In `RecoverFromUpdateValue`, validate before copying:
   - Ensure `FinalOrderOfNextRound` is in range [1, minersCount] for all miners
   - Ensure no duplicate `FinalOrderOfNextRound` values among miners who mined
   - Ensure miners who haven't mined have `FinalOrderOfNextRound=0` only

2. In `ProcessUpdateValue`, validate `TuneOrderInformation`:
   - Ensure all values are in range [1, minersCount]
   - Ensure no duplicates are created
   - Verify tuning is legitimate (resolves actual conflicts)

**Code-Level Fix:**
Add validation helper method:
```csharp
private bool ValidateFinalOrderOfNextRound(Round round)
{
    var minersCount = round.RealTimeMinersInformation.Count;
    var minersWhoMined = round.RealTimeMinersInformation.Values
        .Where(m => m.OutValue != null).ToList();
    
    // Check all orders are in valid range or 0
    foreach (var miner in round.RealTimeMinersInformation.Values)
    {
        var order = miner.FinalOrderOfNextRound;
        if (order != 0 && (order < 1 || order > minersCount))
            return false;
    }
    
    // Check no duplicates among miners who mined
    var ordersUsed = minersWhoMined
        .Select(m => m.FinalOrderOfNextRound)
        .Where(o => o > 0)
        .GroupBy(o => o);
    if (ordersUsed.Any(g => g.Count() > 1))
        return false;
    
    return true;
}
```

Call this in `RecoverFromUpdateValue` before applying values and in `UpdateValueValidationProvider`.

**Test Cases:**
- Test UpdateValue with `FinalOrderOfNextRound=0` for other miners - should reject
- Test UpdateValue with `FinalOrderOfNextRound > minersCount` - should reject  
- Test UpdateValue with duplicate `FinalOrderOfNextRound` values - should reject
- Test UpdateValue with negative `FinalOrderOfNextRound` - should reject
- Test legitimate conflict resolution still works after fix

### Proof of Concept

**Initial State:**
- Blockchain running with N miners (e.g., 17 miners)
- Current round in progress with multiple miners having produced blocks
- Attacker is miner #5 with valid mining rights

**Attack Steps:**

1. **Attacker Setup:**
   - Attacker modifies their node software to manipulate consensus header generation
   - Override `GetUpdateValueRound` to set `FinalOrderOfNextRound=0` for all miners except self

2. **Execute Malicious UpdateValue:**
   - When attacker's time slot arrives, produce UpdateValue block
   - Inject consensus header with corrupted round data:
     - Attacker: `FinalOrderOfNextRound=5` (valid)
     - All others: `FinalOrderOfNextRound=0` (invalid)
   - Include `TuneOrderInformation` mapping all other miners to 0

3. **Validation Passes:**
   - `MiningPermissionValidationProvider`: ✓ (attacker is in miner list)
   - `TimeSlotValidationProvider`: ✓ (correct time)
   - `UpdateValueValidationProvider`: ✓ (OutValue/Signature valid)
   - `RecoverFromUpdateValue` copies malicious values without validation
   - Block accepted

4. **State Corruption:**
   - `ProcessUpdateValue` executes
   - Applies `TuneOrderInformation`, setting 16 miners to `FinalOrderOfNextRound=0`
   - Only attacker has valid `FinalOrderOfNextRound=5`
   - Corrupted state persisted to blockchain

5. **Consensus Deadlock:**
   - Round continues with corrupted state
   - When round should end, `GenerateNextRoundInformation` called
   - Generated NextRound has 16 miners with Order=0 (invalid)
   - `NextRoundMiningOrderValidationProvider` fails: distinctCount=1 but miners who mined=17
   - NextRound transaction rejected
   - Blockchain cannot progress to next round

**Expected vs Actual:**
- **Expected:** UpdateValue with invalid `FinalOrderOfNextRound` should be rejected during validation
- **Actual:** Invalid values pass validation, corrupt state, and cause consensus deadlock

**Success Condition:**
NextRound validation fails with message "Invalid FinalOrderOfNextRound" and blockchain cannot progress, requiring manual intervention to recover.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-83)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-24)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L41-41)
```csharp
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
