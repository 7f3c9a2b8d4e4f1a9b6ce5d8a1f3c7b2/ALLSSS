# Audit Report

## Title
Time Slot Collision Vulnerability Due to Incomplete Conflict Resolution and Flawed Validation

## Summary
The AEDPoS consensus contract contains two critical bugs that together allow multiple miners to be assigned the same time slot in subsequent rounds. An off-by-one error in the `ApplyNormalConsensusData` conflict resolution loop fails to check the highest valid order when reassigning conflicted miners, while the `NextRoundMiningOrderValidationProvider` incorrectly validates object distinctness rather than order value uniqueness. This enables duplicate `FinalOrderOfNextRound` assignments, causing time slot collisions that violate fundamental consensus invariants.

## Finding Description

**Root Cause 1: Incomplete Conflict Resolution Loop**

When a miner produces a block, `ApplyNormalConsensusData` calculates their `supposedOrderOfNextRound` for the next round using their signature hash modulo the miner count. [1](#0-0)  Valid orders are 1-indexed from 1 to `minersCount`.

If this calculated order conflicts with an existing miner's order, the code attempts to reassign the conflicted miner. [2](#0-1)  The reassignment loop iterates from `supposedOrderOfNextRound + 1` to `minersCount * 2 - 1`, using modulo arithmetic to wrap around.

**The Bug**: When `supposedOrderOfNextRound` equals `minersCount` (e.g., 5 in a 5-miner round), the modulo operation creates a gap:
- Loop starts at i=6, ends before i=10
- i=6: `maybeNewOrder = 6 % 5 = 1`
- i=7: `maybeNewOrder = 7 % 5 = 2`
- i=8: `maybeNewOrder = 8 % 5 = 3`
- i=9: `maybeNewOrder = 9 % 5 = 4`

Order 5 is never checked (would require i=5 or i=10, both outside the loop range). If orders 1-4 are all occupied, the loop exits without reassigning the conflicted miner. Both the current miner and the previously conflicted miner retain `FinalOrderOfNextRound = 5`.

**Root Cause 2: Flawed Validation Logic**

The `NextRoundMiningOrderValidationProvider` is intended to verify unique `FinalOrderOfNextRound` values among miners who produced blocks. [3](#0-2) 

The validation calls `.Distinct()` on `MinerInRound` objects rather than their `FinalOrderOfNextRound` property values. Since `MinerInRound` is a protobuf-generated class without custom equality implementation, `.Distinct()` uses reference equality. Each miner object has a distinct reference, so `distinctCount` always equals the number of miner objects, even with duplicate `FinalOrderOfNextRound` values.

**Execution Path**:

1. During block production, `GetConsensusExtraDataToPublishOutValue` invokes `ApplyNormalConsensusData` to update consensus data. [4](#0-3) 

2. The updated round containing duplicate orders is returned and persisted in consensus extra data. [5](#0-4) 

3. The `NextRoundMiningOrderValidationProvider` is only used during `NextRound` transitions, not during `UpdateValue` when duplicates are created. [6](#0-5)  Even if it were invoked, the validation bug would allow duplicates to pass.

4. During `NextRound` transition, `GenerateNextRoundInformation` orders miners by `FinalOrderOfNextRound` and assigns their time slots. [7](#0-6)  Miners with duplicate `FinalOrderOfNextRound` values receive identical `Order` and `ExpectedMiningTime` values in the next round.

## Impact Explanation

This vulnerability violates the core AEDPoS consensus invariant that each miner must have a unique, non-overlapping time slot for block production. When multiple miners are assigned to the same time slot:

**Consensus Integrity**: Two miners simultaneously believe they have authority to produce blocks at the same timestamp, creating ambiguity about which block is canonical.

**Network Instability**: 
- Competing miners may produce conflicting blocks at the same height
- Reduced block finality as nodes must resolve which of two valid blocks to accept
- Potential consensus deadlock if both miners refuse to yield
- Cascade effect as the corrupted order propagates to subsequent rounds

**Severity**: HIGH - This compromises fundamental consensus mechanics. While the specific preconditions reduce immediate exploitability, the impact on consensus integrity and network stability is critical. The bug exists in production code and can manifest under normal operation.

## Likelihood Explanation

**Entry Point**: Any miner can trigger this through standard `UpdateValue` transactions during block production - no special privileges required beyond being a valid consensus participant.

**Preconditions**:
1. In a round with N miners, N-1 miners have already claimed orders 1 through N-1
2. Two miners independently calculate `supposedOrderOfNextRound = N` via signature hash modulo
3. The second miner processes their consensus data after the first

**Feasibility**: While signature hash collisions yielding the same modulo value are probabilistically rare in any single round, the AEDPoS design relies on unpredictable signature values. Over hundreds or thousands of rounds:
- The specific scenario where `supposedOrderOfNextRound = minersCount` occurs with 1/N probability (~20% for N=5)
- Natural operation eventually produces the required preconditions
- Adversarial miners could deliberately time their block production to increase collision probability

**Detection**: The flawed validation allows this to pass undetected until actual time slot conflicts manifest during next round mining, by which point the corrupted round data is already persisted.

## Recommendation

**Fix 1 - Correct the conflict resolution loop:**

```csharp
// In Round_ApplyNormalConsensusData.cs, line 31
for (var i = supposedOrderOfNextRound + 1; i <= minersCount + supposedOrderOfNextRound; i++)
{
    var maybeNewOrder = (i - 1) % minersCount + 1; // 1-indexed modulo
    if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
    {
        RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound = maybeNewOrder;
        break;
    }
}
```

This ensures all orders from 1 to `minersCount` are checked exactly once, including the edge case where `supposedOrderOfNextRound = minersCount`.

**Fix 2 - Correct the validation logic:**

```csharp
// In NextRoundMiningOrderValidationProvider.cs, line 15-16
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Select order values
    .Distinct()
    .Count();
```

This validates distinctness of order values rather than object references.

**Additional Safeguard**: Add `NextRoundMiningOrderValidationProvider` to `UpdateValue` behavior validation to catch duplicates when they're created rather than during the next round transition.

## Proof of Concept

```csharp
[Fact]
public void TimeSlotCollision_DuplicateFinalOrderOfNextRound_Test()
{
    // Setup: 5-miner round with orders 1-4 already occupied
    var round = new Round { RoundNumber = 1, TermNumber = 1 };
    var minersCount = 5;
    
    // Create 4 miners with orders 1-4 and FinalOrderOfNextRound 1-4
    for (int i = 1; i <= 4; i++)
    {
        round.RealTimeMinersInformation[$"Miner{i}"] = new MinerInRound
        {
            Pubkey = $"Miner{i}",
            Order = i,
            FinalOrderOfNextRound = i,
            OutValue = Hash.FromString($"out{i}")
        };
    }
    
    // Miner5 with order 5, calculates supposedOrderOfNextRound = 5
    round.RealTimeMinersInformation["Miner5"] = new MinerInRound
    {
        Pubkey = "Miner5",
        Order = 5
    };
    
    // Create signature that maps to order 5: signature % 5 = 4, +1 = 5
    var signatureMiner5 = Hash.FromString("sig5_maps_to_4");
    
    // Apply consensus data for Miner5
    round.ApplyNormalConsensusData("Miner5", Hash.Empty, Hash.FromString("out5"), signatureMiner5);
    round.RealTimeMinersInformation["Miner5"].FinalOrderOfNextRound.ShouldBe(5);
    
    // Miner6 also calculates supposedOrderOfNextRound = 5
    round.RealTimeMinersInformation["Miner6"] = new MinerInRound
    {
        Pubkey = "Miner6",
        Order = 6
    };
    
    var signatureMiner6 = Hash.FromString("sig6_maps_to_4");
    
    // Apply consensus data for Miner6 - should trigger conflict resolution
    round.ApplyNormalConsensusData("Miner6", Hash.Empty, Hash.FromString("out6"), signatureMiner6);
    
    // BUG: Both Miner5 and Miner6 now have FinalOrderOfNextRound = 5
    round.RealTimeMinersInformation["Miner5"].FinalOrderOfNextRound.ShouldBe(5);
    round.RealTimeMinersInformation["Miner6"].FinalOrderOfNextRound.ShouldBe(5); // DUPLICATE!
    
    // Verify validation fails to detect duplicates due to Distinct() bug
    var validationProvider = new NextRoundMiningOrderValidationProvider();
    var context = new ConsensusValidationContext { ProvidedRound = round };
    var result = validationProvider.ValidateHeaderInformation(context);
    
    // EXPECTED: Validation should fail, ACTUAL: Passes due to reference equality bug
    result.Success.ShouldBeTrue(); // This demonstrates the validation bug
    
    // Generate next round - both miners get same time slot
    var currentTime = TimestampHelper.GetUtcNow();
    round.GenerateNextRoundInformation(currentTime, currentTime, out var nextRound);
    
    var miner5NextRound = nextRound.RealTimeMinersInformation["Miner5"];
    var miner6NextRound = nextRound.RealTimeMinersInformation["Miner6"];
    
    // TIME SLOT COLLISION: Both miners assigned Order 5 and identical ExpectedMiningTime
    miner5NextRound.Order.ShouldBe(5);
    miner6NextRound.Order.ShouldBe(5);
    miner5NextRound.ExpectedMiningTime.ShouldBe(miner6NextRound.ExpectedMiningTime);
}
```

## Notes

The vulnerability requires two independent bugs to manifest:
1. The conflict resolution loop's off-by-one error creates the duplicate orders
2. The validation's incorrect use of `Distinct()` fails to detect them

Either fix alone would prevent the vulnerability, but both should be corrected for defense in depth. The issue is particularly concerning because it can occur through normal mining operations without malicious intent, though adversarial miners could deliberately exploit the timing to increase collision probability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-40)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L128-133)
```csharp
        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = updatedRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-86)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
