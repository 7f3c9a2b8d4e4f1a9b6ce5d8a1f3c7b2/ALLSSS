### Title
Unreachable Profit Periods Enable Permanent Token Lock via Unbounded Period Parameter

### Summary
The `ContributeProfits` function accepts any period value greater than or equal to `CurrentPeriod` without an upper bound check, allowing tokens to be contributed to arbitrarily large future periods (e.g., `long.MaxValue`). Since profit distribution must proceed sequentially period-by-period and cannot skip ahead, tokens contributed to unreachable periods become permanently locked with no recovery mechanism.

### Finding Description

**Root Cause:**

The `ContributeProfits` function validates the period parameter with only a lower bound check: [1](#0-0) 

This assertion allows any period >= `scheme.CurrentPeriod` but imposes no upper bound. When a user specifies a very large period value, tokens are transferred to a period-specific virtual address: [2](#0-1) 

**Why Protections Fail:**

The `DistributeProfits` function, which releases profits for claiming, enforces strict sequential period progression: [3](#0-2) 

It can ONLY process the exact current period (`releasingPeriod = scheme.CurrentPeriod`) and increments the period by exactly one: [4](#0-3) 

**No Recovery Mechanism:**

There is no mechanism to:
- Skip periods or jump ahead to future periods
- Reset or manually adjust `CurrentPeriod`
- Directly withdraw tokens from period-specific virtual addresses [5](#0-4) 

The only places `CurrentPeriod` is modified are during scheme creation (initialized to 1) and in `DistributeProfits`/`BurnProfits` (incremented by 1). No administrative override exists.

**Execution Path:**

1. User calls `ContributeProfits` with a large period value (e.g., `9223372036854775807` for `long.MaxValue`)
2. Validation passes: `9223372036854775807 >= scheme.CurrentPeriod` âœ“
3. Tokens are transferred to period-specific virtual address via `GetDistributedPeriodProfitsVirtualAddress(schemeId, 9223372036854775807)`
4. To release these tokens, manager must call `DistributeProfits` sequentially for periods 1, 2, 3, ... up to 9223372036854775807
5. This is computationally impossible (would require ~9.2 quintillion transactions)
6. Tokens remain locked permanently as beneficiaries can only claim from released periods: [6](#0-5) [7](#0-6) 

### Impact Explanation

**Direct Fund Impact:**
- Tokens contributed to unreachable periods are permanently locked and unrecoverable
- No mechanism exists to extract funds from period-specific virtual addresses without sequential distribution
- Both malicious actors and legitimate users can cause permanent fund loss

**Who Is Affected:**
- Token contributors who accidentally specify wrong period values (fat-finger errors)
- Schemes where malicious contributors intentionally lock tokens to grief the scheme
- Any user with token approval could contribute others' tokens to unreachable periods via `TransferFrom`

**Quantified Damage:**
- Any amount of tokens can be locked permanently
- For periods >= `long.MaxValue - CurrentPeriod`, recovery is mathematically impossible
- Even moderately large periods (e.g., millions) are practically unreachable given gas costs and block time constraints

**Severity Justification:**
The vulnerability enables permanent, irreversible loss of arbitrary token amounts through a single transaction. While the protobuf definition shows period as `int64`, there's no validation preventing extreme values: [8](#0-7) 

### Likelihood Explanation

**Reachable Entry Point:**
`ContributeProfits` is a public RPC method callable by any user: [9](#0-8) 

**Attacker Capabilities:**
- **Unintentional**: User error (typo, wrong parameter) is highly plausible
- **Intentional**: Malicious actor can deliberately lock tokens to grief a scheme
- Requires token ownership/approval, making self-harm most likely scenario

**Execution Practicality:**
- Single transaction with large period parameter
- No special permissions required beyond token approval
- Works under normal AElf contract execution semantics

**Economic Rationality:**
- For accidental scenarios: Zero cost beyond gas, high probability given human error
- For griefing: Attacker must sacrifice their own tokens or obtain approval, limiting practical attacks
- Most realistic threat: User mistakes rather than deliberate attacks

**Detection Constraints:**
- No on-chain validation would prevent this
- Off-chain monitoring could detect but not prevent large period values
- Once executed, damage is irreversible

**Probability Assessment:**
Medium likelihood - while intentional attacks have economic barriers, accidental user errors with large period values are reasonably probable and would result in permanent loss.

### Recommendation

**Immediate Code-Level Mitigation:**

Add an upper bound check in `ContributeProfits` to limit maximum future period contributions. Recommended approach:

```csharp
// In ContributeProfits, after line 684:
const long MaxFuturePeriods = 1000; // Reasonable upper bound
Assert(input.Period <= scheme.CurrentPeriod.Add(MaxFuturePeriods), 
    $"Period too far in future. Maximum allowed: {scheme.CurrentPeriod.Add(MaxFuturePeriods)}");
```

**Invariant Checks:**
- Period must be: `CurrentPeriod <= Period <= CurrentPeriod + MaxFuturePeriods`
- `MaxFuturePeriods` should be configurable but capped (e.g., 1000-10000 periods)
- Consider adding a governance parameter for maximum future period offset

**Test Cases to Add:**

1. Test contributing to period `long.MaxValue` - should fail
2. Test contributing to period `CurrentPeriod + MaxFuturePeriods + 1` - should fail
3. Test contributing to period `CurrentPeriod + MaxFuturePeriods` - should succeed
4. Test period wraparound scenarios with `Add()` method
5. Regression test ensuring sequential distribution still works correctly

**Additional Safeguards:**

Consider implementing:
- Emergency recovery mechanism for scheme manager to burn/reclaim tokens from unreleased periods
- Period reset capability (with proper governance controls)
- Warning logs when periods > reasonable threshold

### Proof of Concept

**Initial State:**
- Scheme created with `CurrentPeriod = 1`
- User has 1000 ELF tokens with approval to ProfitContract
- SchemeId: `0x1234...`

**Attack Sequence:**

1. **Contribute to unreachable period:**
   ```
   ProfitContract.ContributeProfits({
       SchemeId: 0x1234...,
       Amount: 1000,
       Period: 9223372036854775807, // long.MaxValue
       Symbol: "ELF"
   })
   ```
   
2. **Result:** Transaction succeeds, tokens transferred to period-specific virtual address

3. **Attempt recovery via DistributeProfits:**
   ```
   ProfitContract.DistributeProfits({
       SchemeId: 0x1234...,
       Period: 1
   })
   // CurrentPeriod now = 2
   
   ProfitContract.DistributeProfits({
       SchemeId: 0x1234...,
       Period: 2
   })
   // CurrentPeriod now = 3
   // ... must repeat 9,223,372,036,854,775,804 more times ...
   ```

4. **Attempt to skip ahead:**
   ```
   ProfitContract.DistributeProfits({
       SchemeId: 0x1234...,
       Period: 9223372036854775807
   })
   ```
   **FAILS** with: "Invalid period. When release scheme ... Current period is 3"

**Expected vs Actual:**
- **Expected:** Tokens should be recoverable or period parameter should be bounded
- **Actual:** Tokens permanently locked, no recovery path exists

**Success Condition:**
Tokens are irretrievable, demonstrating permanent fund lock vulnerability.

### Notes

The vulnerability severity is rated **Medium** rather than High because:
- Most realistic scenario is accidental user error rather than deliberate attack
- Intentional griefing requires sacrificing one's own tokens or obtaining approval
- However, the **impact** when triggered is **High** (permanent, irreversible loss)

The test suite shows `long.MaxValue` is used legitimately for `EndPeriod` in beneficiary details (indicating unlimited participation), but lacks validation for its use in contribution periods: [10](#0-9) 

This suggests the developers were aware of large period values in some contexts but didn't protect against them in contribution logic.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L479-480)
```csharp
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L684-684)
```csharp
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L685-710)
```csharp
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L767-767)
```csharp
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L857-859)
```csharp
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L881-881)
```csharp
                    if (distributedProfitsInformation.IsReleased && amount > 0)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L947-947)
```csharp
            CurrentPeriod = 1,
```

**File:** protobuf/profit_contract.proto (L41-43)
```text
    // Contribute profit to a scheme.
    rpc ContributeProfits (ContributeProfitsInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/profit_contract.proto (L252-261)
```text
message ContributeProfitsInput {
    // The scheme id to contribute.
    aelf.Hash scheme_id = 1;
    // The amount to contribute.
    int64 amount = 2;
    // The number of periods in which the income is used for dividends.
    int64 period = 3;
    // The token symbol to contribute.
    string symbol = 4;
}
```
