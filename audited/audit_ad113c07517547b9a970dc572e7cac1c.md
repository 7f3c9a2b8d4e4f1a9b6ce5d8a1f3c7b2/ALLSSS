# Audit Report

## Title
Retroactive Vote Manipulation Through Member List Changes in Association Contract

## Summary
The Association contract's vote counting mechanism filters votes by current membership at release time rather than membership at voting time, allowing organizations to retroactively manipulate proposal outcomes by removing members who voted against proposals. This breaks the fundamental integrity of the governance system.

## Finding Description

The Association contract implements a multi-signature governance system where organization members vote on proposals. The critical flaw exists in how votes are counted during proposal release.

When members vote, their addresses are permanently recorded in the proposal's vote lists. [1](#0-0) [2](#0-1) [3](#0-2) 

However, when determining if a proposal meets release thresholds, the contract filters these votes by **current** membership status: [4](#0-3) [5](#0-4) [6](#0-5) 

The organization can modify its member list through member management functions that only require the organization itself as sender (via proposal execution): [7](#0-6) 

These functions only validate that the organization remains mathematically valid after changes—there is **no check** preventing member modifications while proposals are active: [8](#0-7) 

**Attack Scenario:**
1. Organization has members [A, B, C, D, E, F] with thresholds: MinimalApprovalThreshold=3, MaximalRejectionThreshold=1
2. Proposal X is created with controversial action
3. Members vote: A, B, C approve (3 votes); D, E reject (2 rejections)
4. Proposal is blocked because rejection count (2) > MaximalRejectionThreshold (1)
5. Organization passes separate proposal to remove member D
6. With D removed, rejection count recalculated as: [D, E] filtered by current members = [E] only = 1 rejection
7. Now 1 ≤ MaximalRejectionThreshold (1), so proposal is no longer blocked
8. Proposal X can be released despite having been blocked by the votes cast

The contract never snapshots membership at voting time, allowing retroactive vote invalidation.

## Impact Explanation

This vulnerability fundamentally breaks the governance integrity guarantee that votes cast at time T should remain valid regardless of future organizational changes.

**Concrete Impacts:**
- **Governance Capture**: Organizations controlling high-value assets (treasury funds, contract upgrade authority, token permissions) can bypass multi-sig protections
- **Threshold Bypass**: Both rejection and abstention thresholds can be retroactively manipulated
- **Multi-sig Undermining**: The security model of M-of-N multi-signature governance is completely compromised

The severity scales with the authority level of affected Association organizations. If an Association controls critical system permissions or substantial funds, this represents a **CRITICAL** vulnerability.

## Likelihood Explanation

**Attacker Requirements:**
- Control sufficient members to pass member removal proposals (MinimalApprovalThreshold votes)
- Ability to propose member changes without being blocked

**Feasibility:** HIGH
- Member removal proposals are distinct from controversial actions—different members may support "membership cleanup" versus contentious proposals
- The attack uses legitimate functionality for malicious purposes
- Multiple sequential proposals can be executed before the original proposal expires
- No on-chain mechanism prevents or detects this pattern

**Detection Difficulty:** HIGH
- Member management is legitimate operation
- Connection between removal and vote manipulation requires analyzing proposal histories
- Each individual step appears valid in isolation

The attack is economically rational whenever the controlled assets exceed coordination costs among colluding members.

## Recommendation

Implement membership snapshots at voting time to ensure vote validity is immutable:

**Solution 1: Snapshot on First Vote**
Store the organization's member list hash when the first vote is cast. During release, validate votes only against members in that snapshot.

**Solution 2: Block Member Changes During Active Proposals**
Track active proposal counts per organization and prevent member modifications when proposals are pending.

**Solution 3: Snapshot on Proposal Creation**
Store the current member list with each proposal at creation time, and use that list for all vote counting.

The recommended approach is Solution 3 as it provides the clearest semantics and prevents the attack entirely.

## Proof of Concept

The vulnerability can be demonstrated with the following test sequence:

1. Create organization with members [A, B, C, D, E, F] and thresholds MinimalApprovalThreshold=3, MaximalRejectionThreshold=1
2. Create Proposal X to transfer funds from organization
3. Members A, B, C call `Approve(proposalX)` 
4. Members D, E call `Reject(proposalX)`
5. Verify `GetProposal(proposalX).ToBeReleased == false` (blocked by 2 rejections > threshold of 1)
6. Create Proposal Y to call `RemoveMember(D)`
7. Members A, B, C approve and release Proposal Y
8. Verify organization now has 5 members [A, B, C, E, F]
9. Verify `GetProposal(proposalX).ToBeReleased == true` (now unblocked: only 1 rejection from E)
10. Call `Release(proposalX)` successfully executes the previously blocked proposal

This demonstrates that votes cast by member D are retroactively invalidated by removing D from the organization.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L130-130)
```csharp
        proposal.Approvals.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L150-150)
```csharp
        proposal.Rejections.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L170-170)
```csharp
        proposal.Abstentions.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```
