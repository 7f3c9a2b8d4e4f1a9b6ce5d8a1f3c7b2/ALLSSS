### Title
NextTerm Miner List Manipulation Enables Arbitrary MinersCountOfConsent Threshold Control

### Summary
The `MinersCountOfConsent` calculation is mathematically correct as `(Count * 2 / 3) + 1`, but the underlying `RealTimeMinersInformation.Count` can be manipulated during term changes. The `ProcessNextTerm` function directly accepts the miner list from the `NextTermInput` without validating it against election results from `GetVictories()`, allowing a malicious block producer to insert an arbitrary miner list that passes validation, thereby controlling the two-thirds threshold for all future term changes.

### Finding Description

**Root Cause:**

The `MinersCountOfConsent` property is correctly implemented as a computed property: [1](#0-0) 

This calculates the two-thirds consensus requirement used in `NeedToChangeTerm()`: [2](#0-1) 

However, the critical vulnerability lies in how `RealTimeMinersInformation` is populated during term transitions. In `ProcessNextTerm`, the miner list is taken directly from the input without validation: [3](#0-2) 

The miner list from this unvalidated round is then stored as the authoritative miner list: [4](#0-3) 

**Missing Validation:**

While honest block producers call `GenerateFirstRoundOfNextTerm` which properly queries election results: [5](#0-4) 

The validation framework does NOT verify that received `NextTermInput` matches these election results. The before-execution validation only checks round/term number increments: [6](#0-5) 

The after-execution validation only checks miner replacements via `GetNewestPubkey`, not the full miner list against `GetVictories()`: [7](#0-6) 

**Why Protections Fail:**

The election system properly returns the top voted candidates: [8](#0-7) 

But this election result is never validated against what a block producer actually submits in their `NextTermInput`. A malicious producer can craft arbitrary miner lists that pass validation as long as they can be justified as "replacements" via the `GetNewestPubkey` mechanism, which was designed for legitimate pubkey changes, not miner list manipulation.

### Impact Explanation

**Consensus Takeover:**
An attacker who is the extra block producer at a term boundary can replace the legitimate election-based miner list with an arbitrary list (e.g., containing only the attacker and colluding parties). This violates the fundamental election-based governance mechanism.

**Threshold Manipulation:**
By controlling `RealTimeMinersInformation.Count`, the attacker directly controls `MinersCountOfConsent = (Count * 2 / 3) + 1`. If the attacker reduces the miner set from 17 miners to 3 miners, the threshold for future term changes drops from 12 miners to 3 miners, enabling the attacker cabal to perpetually maintain control.

**Governance Bypass:**
All election results become meaningless as the attacker can ignore vote-based miner selection. Legitimate candidates with majority votes are excluded while attacker-controlled addresses maintain mining rights indefinitely.

**Chain Authority:**
With control over the miner set and consensus thresholds, attackers can:
- Censor transactions arbitrarily
- Manipulate LIB (Last Irreversible Block) heights
- Control all governance proposals requiring miner consensus
- Prevent legitimate miners from ever regaining control

**Affected Parties:**
- All token holders whose votes are ignored
- Legitimate candidate miners who are excluded despite winning elections
- End users who face censorship and reduced security
- The entire network's decentralization and security model is compromised

### Likelihood Explanation

**Attacker Capabilities:**
The attacker must be a current miner and specifically the extra block producer when a term change occurs. In a 17-miner system, this represents a ~6% chance per term for any single malicious miner.

**Attack Preconditions:**
The attack can only occur during term transitions when `NeedToChangeTerm()` returns true (when 2/3+ miners have blocks past the term boundary). Terms occur periodically (e.g., every 7 days based on `PeriodSeconds`), providing regular opportunities.

**Execution Practicality:**
The attack is straightforward:
1. Monitor for term transition conditions
2. When serving as extra block producer, call the honest `GetConsensusExtraData` method to generate valid extra data
3. Modify the `RealTimeMinersInformation` in the returned data to inject desired miner list
4. Submit the modified `NextTermInput` transaction
5. The validation logic will accept it as the round/term numbers are correct and any miner differences can be framed as "replacements"

**Detection Constraints:**
The attack appears as a legitimate `NextTerm` transaction that passes all validation checks. Without independent verification against `GetVictories()` results, honest nodes cannot distinguish malicious from legitimate term changes. Post-attack, the manipulated miner list becomes the "official" state.

**Probability Assessment:**
MEDIUM-HIGH likelihood. While requiring the attacker to be extra block producer at term boundary (6% chance), term changes occur regularly, providing multiple opportunities. A single malicious miner eventually gets the required position, and the attack requires minimal technical complexity beyond standard block production.

### Recommendation

**Primary Fix:**
Add miner list validation in `ProcessNextTerm` before storing the new round:

```csharp
// In AEDPoSContract_ProcessConsensusInformation.cs, after line 163
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // CRITICAL: Validate miner list matches election results
    if (State.IsMainChain.Value && State.ElectionContract.Value != null)
    {
        var expectedVictories = State.ElectionContract.GetVictories.Call(new Empty());
        var expectedMiners = expectedVictories.Value.Select(v => v.ToHex()).OrderBy(k => k).ToList();
        var actualMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        
        // Allow for legitimate pubkey replacements
        var actualWithReplacements = actualMiners.Select(m => 
            State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = m }).Value ?? m
        ).OrderBy(k => k).ToList();
        
        Assert(
            expectedMiners.Count == actualWithReplacements.Count &&
            expectedMiners.SequenceEqual(actualWithReplacements),
            "NextTerm miner list does not match election results from GetVictories()."
        );
    }
    
    // ... rest of existing ProcessNextTerm logic
}
```

**Secondary Validation:**
Add a similar check in `ValidateConsensusAfterExecution` to catch any bypass attempts: [9](#0-8) 

Add validation for NextTerm behavior specifically before the existing replacement check.

**Test Cases:**
1. Test that legitimate NextTerm with correct election results passes
2. Test that NextTerm with manipulated miner list (missing election winners) is rejected
3. Test that NextTerm with extra unauthorized miners is rejected
4. Test that legitimate pubkey replacements via `GetNewestPubkey` still work
5. Test term change with varying miner counts (verify MinersCountOfConsent updates correctly)

### Proof of Concept

**Initial State:**
- Chain has 17 legitimate miners selected via election
- Malicious miner M is one of the current miners
- Term period is 7 days, term change is approaching
- M waits to become extra block producer at term boundary

**Attack Sequence:**

1. **Wait for Opportunity:**
   - M monitors `NeedToChangeTerm()` until 2/3+ miners cross term boundary
   - M is scheduled as extra block producer for term transition

2. **Prepare Malicious NextTerm:**
   - M calls `GetConsensusCommand()` which returns `NextTerm` behavior
   - M gets legitimate extra data: `extraData = GetConsensusExtraData(...)`
   - M modifies `extraData.Round.RealTimeMinersInformation` to contain only 3 miners: M, M2, M3 (colluding parties)
   - M ensures replaced miners can be explained via `GetNewestPubkey` mechanism

3. **Submit Malicious Block:**
   - M produces block with modified `NextTermInput` containing 3-miner list
   - Transaction passes `ValidateConsensusBeforeExecution` (round/term numbers correct)
   - Transaction executes, storing 3-miner list to state
   - Transaction passes `ValidateConsensusAfterExecution` (replacements appear authorized)

4. **Verify Success:**
   - New term begins with only 3 miners (M, M2, M3)
   - `MinersCountOfConsent = (3 * 2 / 3) + 1 = 3` (all 3 required for consensus)
   - Legitimate miners with 14 members cannot reclaim control (they're not in miner list)
   - M's cabal can perpetually renew their position by controlling future NextTerm blocks
   - Election results showing 17 different winners are ignored

**Expected vs Actual Result:**
- **Expected:** NextTerm installs the 17 miners who won the election
- **Actual:** NextTerm installs M's 3-miner cabal, giving them permanent control
- **Success Condition:** `State.CurrentRound.Value.RealTimeMinersInformation.Count == 3` and all keys belong to attacker-controlled addresses

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-163)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```
