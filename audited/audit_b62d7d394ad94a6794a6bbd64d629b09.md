### Title
Double Swap Logic Flaw in BreakContinuousMining Allows Continuous Mining Pattern with Two Miners

### Summary
The `BreakContinuousMining()` function contains a logic flaw where two sequential swap operations cancel each other out when exactly two miners exist and the same miner is selected as the extra block producer for both consecutive rounds. This defeats the function's purpose of preventing continuous mining, allowing one miner to produce the extra block of the current round immediately followed by the first block of the next round.

### Finding Description

The vulnerability exists in the `BreakContinuousMining()` method in [1](#0-0) 

The function performs two independent swap operations:
1. **First swap** (lines 85-89): If the first miner of next round equals the extra block producer of current round, swap positions 1 and 2
2. **Second swap** (lines 102-106): If the last miner of next round equals the extra block producer of next round, swap the last two positions

**Root Cause**: When exactly 2 miners exist and the same miner is the extra block producer for both the current and next round, both conditions become true, causing both swaps to execute sequentially. With only 2 miners, the second swap operates on the same miners that were just swapped by the first operation, reversing it.

**Execution Flow with 2 Miners** (Miner A and B):
- Initial state: Miner A at Order 1, Miner B at Order 2
- Precondition: Miner A is extra block producer for both current and next round
- Line 81 check: `firstMinerOfNextRound (A at Order 1) == extraBlockProducerOfCurrentRound (A)` → TRUE
- First swap executes: A moves to Order 2, B moves to Order 1
- After first swap: B at Order 1, A at Order 2
- Line 98 check: `lastMinerOfNextRound (A at Order 2) == extraBlockProducerOfNextRound (A)` → TRUE
- Second swap executes: A moves back to Order 1, B moves back to Order 2
- **Final result**: A at Order 1, B at Order 2 (identical to initial state)

The `IsExtraBlockProducer` flag is set before `BreakContinuousMining` is called [2](#0-1)  and is never modified by the swap operations, which only change the `Order` field and `ExpectedMiningTime`.

### Impact Explanation

**Consensus Integrity Violation**: The function fails to break the continuous mining pattern, allowing Miner A to produce:
1. The extra block terminating the current round
2. The first regular block of the next round immediately after

This violates the core design principle of AEDPoS consensus to prevent any single miner from producing consecutive blocks [3](#0-2) , which is intended to ensure fair block production distribution and prevent temporary centralization.

**Affected Parties**: All participants in a two-miner consensus scenario where the same miner is probabilistically selected as extra block producer for consecutive rounds.

**Severity Justification**: MEDIUM severity due to:
- Limited to edge case (exactly 2 miners)
- Backup validation exists via `ContinuousBlocksValidationProvider` with `MaximumTinyBlocksCount = 8` [4](#0-3) 
- Violates stated consensus invariant for miner schedule integrity

### Likelihood Explanation

**Preconditions**:
1. Exactly 2 active miners (function returns early for minersCount ≤ 1 [5](#0-4) )
2. Same miner selected as extra block producer for consecutive rounds via `CalculateNextExtraBlockProducerOrder()` [6](#0-5)  (approximately 50% probability with 2 miners)
3. That miner initially assigned as first miner of next round

**Feasibility**: The scenario occurs automatically during round generation when conditions are met. While the system typically operates with 17+ miners [7](#0-6) , the code explicitly supports 2-miner scenarios (only returning early for ≤1 miner).

**Detection**: The issue manifests silently as the swaps cancel out before the round data is persisted. The backup `ContinuousBlocksValidationProvider` [8](#0-7)  may catch excessive continuous mining after the fact, but the primary prevention mechanism fails.

### Recommendation

**Code-level Mitigation**:
Add a check after both swaps to verify the continuous mining pattern was actually broken:

```csharp
private void BreakContinuousMining(ref Round nextRound)
{
    var minersCount = RealTimeMinersInformation.Count;
    if (minersCount <= 1) return;

    var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
    var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
    if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
    {
        var secondMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
        secondMinerOfNextRound.Order = 1;
        firstMinerOfNextRound.Order = 2;
        var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
        secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
        firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
    }

    var lastMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
    if (lastMinerOfNextRound == null) return;

    var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
    if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
    {
        var lastButOneMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
        lastButOneMinerOfNextRound.Order = minersCount;
        lastMinerOfNextRound.Order = minersCount.Sub(1);
        var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
        lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
        lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
    }
    
    // NEW: Verify the invariant holds after swaps
    var finalFirstMiner = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
    Assert(finalFirstMiner.Pubkey != extraBlockProducerOfCurrentRound.Pubkey, 
           "Failed to break continuous mining pattern");
}
```

**Alternative Approach**: For the 2-miner case specifically, when both conditions are true, perform a different mitigation such as adjusting timing delays rather than position swaps.

**Test Cases**:
1. Test with 2 miners where same miner is extra for consecutive rounds
2. Verify first miner of next round ≠ extra of current round post-function
3. Test with 3+ miners to ensure fix doesn't break existing behavior

### Proof of Concept

**Initial State**:
- Active miners: 2 (Miner A, Miner B)
- Current round: Miner A is extra block producer
- Next round calculation: `CalculateNextExtraBlockProducerOrder()` returns order pointing to Miner A
- Initial next round assignment: A at Order 1, B at Order 2

**Execution Steps**:
1. `GenerateNextRoundInformation()` is called during round transition
2. Extra block producer for next round is set to Miner A (IsExtraBlockProducer = true)
3. `BreakContinuousMining(ref nextRound)` is invoked
4. First condition (line 81): Miner A (Order 1) == Current Extra (A) → TRUE
5. First swap: A→Order 2, B→Order 1
6. Second condition (line 98): Miner A (Order 2, last) == Next Extra (A) → TRUE  
7. Second swap: A→Order 1, B→Order 2

**Expected Result**: Miner A should NOT be at Order 1 (continuous mining should be broken)

**Actual Result**: Miner A is at Order 1, will mine extra block of current round + first block of next round consecutively

**Success Condition**: After `BreakContinuousMining()`, verify that `nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1).Pubkey != GetExtraBlockProducerInformation().Pubkey` — this assertion FAILS in the described scenario.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-67)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L60-65)
```csharp
    /// <summary>
    ///     In current AElf Consensus design, each miner produce his block in one time slot, then the extra block producer
    ///     produce a block to terminate current round and confirm the mining order of next round.
    ///     So totally, the time of one round is:
    ///     MiningInterval * MinersCount + MiningInterval.
    /// </summary>
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L6-29)
```csharp
public class ContinuousBlocksValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
}
```
