### Title
Permanent Token Lock via Scheme Symbol Overwrite in TokenHolderContract

### Summary
The `CreateScheme` function in TokenHolderContract lacks validation to prevent multiple invocations by the same manager, allowing the scheme symbol to be overwritten. Users who registered under the original scheme will have their tokens permanently locked because the `Withdraw` function attempts to unlock tokens using the new scheme symbol instead of the original symbol used during registration.

### Finding Description

The vulnerability exists in the `CreateScheme` function which has no protection against being called multiple times by the same manager: [1](#0-0) 

When `CreateScheme` is called, it unconditionally overwrites the `TokenHolderProfitScheme` mapping at line 27, replacing the existing scheme (including its symbol) with new values. Each invocation creates a distinct scheme in the ProfitContract with a different `schemeId` based on an incremental counter: [2](#0-1) 

The root cause is that while ProfitContract creates separate schemes (preventing "Already exists" errors), TokenHolderContract maintains only a single scheme reference per manager, which gets overwritten.

During `RegisterForProfits`, tokens are locked using the scheme's symbol at that point in time: [3](#0-2) 

The lock mechanism stores tokens in a virtual address computed from the sender, user address, and lockId - but crucially, the symbol determines which token balance is held at that virtual address: [4](#0-3) 

When `Withdraw` is called after the scheme symbol has changed, it retrieves the current scheme (with the new symbol) and attempts to unlock using this new symbol: [5](#0-4) 

The `GetLockedAmount` call at lines 220-225 checks the balance of the new symbol at the virtual address, which returns zero because the tokens were locked with the original symbol: [6](#0-5) 

The virtual address computation is identical (based on address and lockId only, not symbol), but the balance query is symbol-specific. This causes the unlock to proceed with zero amount for the wrong symbol, leaving the original tokens permanently locked with no recovery mechanism.

### Impact Explanation

**Direct Fund Impact:** Users lose complete access to their locked tokens permanently. If a manager creates a scheme with symbol "ELF" and users lock 10,000 ELF tokens, then the manager calls `CreateScheme` again with symbol "USDT", those 10,000 ELF tokens become permanently irrecoverable.

**Who is Affected:** All users who registered for profits under the original scheme before `CreateScheme` was called again. This could affect hundreds or thousands of users depending on the scheme's popularity.

**Severity Justification:** HIGH severity because:
1. Results in permanent and complete loss of user funds (not temporary or partial)
2. No recovery mechanism exists - the lockId mapping is deleted after withdrawal attempt
3. Affects potentially large amounts across multiple users
4. The virtual address holding the locked tokens becomes orphaned with no contract reference to the original symbol

### Likelihood Explanation

**Attacker Capabilities:** The scheme manager (who calls `CreateScheme`) could be:
- Malicious: Intentionally locks user funds to prevent withdrawals while continuing to collect profits
- Negligent: Accidentally calls `CreateScheme` again thinking they're updating the scheme
- Compromised: Has their keys stolen by an attacker who executes this attack

**Attack Complexity:** Low - requires only two transactions:
1. Initial `CreateScheme` with Symbol A
2. Second `CreateScheme` with Symbol B

**Feasibility Conditions:** 
- No special permissions required beyond being the scheme manager
- No timing constraints or complex state dependencies
- Works regardless of how many users have registered
- No economic cost to execute (only gas fees)

**Detection Constraints:** The contract provides no events or warnings when `CreateScheme` overwrites an existing scheme. Users would only discover the issue when attempting to withdraw and receiving zero tokens.

**Probability Assessment:** Medium-to-High likelihood because:
- No UI or contract-level warnings prevent duplicate calls
- Managers may legitimately think they can "update" their scheme
- The function signature gives no indication it should only be called once
- Economic incentive exists if manager wants to lock user funds while maintaining their own control

### Recommendation

**Code-Level Mitigation:**

Add an assertion check at the beginning of `CreateScheme` to prevent overwriting existing schemes:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add this check
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists. Cannot create multiple schemes.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
    // ... rest of function
}
```

**Invariant Checks:**
1. Ensure one-to-one mapping between manager and TokenHolderProfitScheme
2. Validate that scheme.Symbol matches the symbol of locked tokens before unlock
3. Consider adding a scheme version number that must match between registration and withdrawal

**Test Cases:**
1. Test calling `CreateScheme` twice with same manager - should revert
2. Test calling `CreateScheme` with different symbols - should revert on second call
3. Test that users can successfully withdraw after single `CreateScheme` call
4. Test withdrawal attempt after scheme symbol change (should be impossible after fix)

### Proof of Concept

**Initial State:**
- Manager M deploys TokenHolderContract
- Token "ELF" exists with sufficient supply

**Exploit Sequence:**

1. **Manager creates scheme with ELF:**
   - M calls `CreateScheme({Symbol: "ELF", MinimumLockMinutes: 1000})`
   - Scheme stored: `State.TokenHolderProfitSchemes[M] = {Symbol: "ELF", SchemeId: null}`

2. **User locks tokens:**
   - User U calls `RegisterForProfits({SchemeManager: M, Amount: 10000})`
   - 10,000 ELF tokens locked at virtual_address with lockId
   - `State.LockIds[M][U]` = lockId
   - User is beneficiary in ProfitContract scheme

3. **Manager creates new scheme (malicious or accidental):**
   - M calls `CreateScheme({Symbol: "USDT", MinimumLockMinutes: 500})`
   - NEW scheme created in ProfitContract with different schemeId
   - **OVERWRITES:** `State.TokenHolderProfitSchemes[M] = {Symbol: "USDT", SchemeId: null}`
   - Original scheme reference lost

4. **User attempts withdrawal after lock period:**
   - U calls `Withdraw(M)`
   - Gets scheme: `{Symbol: "USDT", ...}`
   - Gets lockId: original lockId (still stored)
   - Calls `GetLockedAmount(Address: U, LockId: lockId, Symbol: "USDT")` → Returns **0**
   - Calls `Unlock(Address: U, LockId: lockId, Amount: 0, Symbol: "USDT")` → Unlocks nothing
   - Deletes `State.LockIds[M][U]`

**Expected Result:** User U should receive 10,000 ELF tokens

**Actual Result:** 
- User U receives 0 tokens
- 10,000 ELF tokens remain locked at virtual_address["ELF"] 
- lockId mapping deleted - no way to attempt withdrawal again
- No contract method can recover the orphaned tokens
- **Permanent loss of 10,000 ELF**

**Success Condition:** The virtual address balance of ELF remains 10,000 while user's balance is unchanged, and the lockId entry is deleted, confirming permanent lock.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-177)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-245)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L195-222)
```csharp
    public override Empty Lock(LockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");

        var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
        if (allowance >= input.Amount)
            State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
        DealWithExternalInfoDuringLocking(new TransferFromInput
        {
            From = input.Address,
            To = virtualAddress,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-116)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
    }
```
