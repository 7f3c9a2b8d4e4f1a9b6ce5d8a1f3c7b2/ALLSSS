# Audit Report

## Title
Predictable NFT Symbol Number Generation Enables Miner Front-Running and Selective Symbol Claiming

## Summary
The NFT contract's `GenerateSymbolNumber()` function uses randomness from the previous block height (`Context.CurrentHeight.Sub(1)`), which is already finalized and publicly known when miners build blocks. Combined with the attacker-controllable `Context.Sender` parameter, this allows miners to predict symbol numbers offline, test multiple addresses, and selectively claim desirable NFT protocol symbols before including transactions, creating systematic unfair advantages over regular users.

## Finding Description

The vulnerability exists in the symbol number generation mechanism used during NFT protocol creation. The entry point is the public `Create()` method [1](#0-0) , which calls `GetSymbol()` that invokes `GenerateSymbolNumber()` [2](#0-1) .

The core issue is in `GenerateSymbolNumber()` which retrieves random bytes using the previous block's height [3](#0-2) . This calls the consensus contract's `GetRandomBytes()` method [4](#0-3) , which returns `State.RandomHashes[height]` [5](#0-4) .

These random hashes are stored during consensus processing via VRF verification [6](#0-5) . While VRF ensures miners cannot manipulate the base random hash, when a miner produces block H, the value `RandomHashes[H-1]` is already finalized and publicly accessible on-chain.

**Attack Mechanism:**

When a miner produces block H:
1. They observe `State.RandomHashes[H-1]` is already stored (finalized in the previous block)
2. They control transaction inclusion and ordering for block H
3. They can compute `Hash(Address_i || RandomHashes[H-1])` offline for multiple controlled addresses
4. They determine which address yields the most desirable symbol number (e.g., "AR100000001" vs "AR987654321")
5. They submit the Create transaction from the optimal address
6. They can exclude or delay competing user transactions

The symbol numbers start with minimum length 9 digits [7](#0-6)  and get combined with NFT type short names like "AR" for Art, "MU" for Music, etc., to form the final protocol symbol. Lower numbers or memorable patterns may have higher perceived market value, giving miners who can predict and selectively claim them an unfair advantage.

**Why Existing Protections Fail:**

The do-while loop in `GenerateSymbolNumber()` only prevents duplicate symbol reuse but does not prevent prediction. There is no commit-reveal mechanism, no use of future block randomness, and no protection against selective transaction inclusion by miners.

## Impact Explanation

This vulnerability creates **systematic unfair advantages** in NFT protocol symbol allocation:

1. **Fairness Violation**: The protocol implicitly guarantees random, unbiased symbol allocation, but miners can systematically claim desirable numbers while regular users receive whatever random allocation they get.

2. **Market Manipulation**: If symbol numbers have market value (e.g., lower sequential numbers like "AR100000001", memorable patterns, or early numbers in new NFT categories), miners control access to these valuable identifiers during critical launch periods.

3. **Protocol Integrity**: Undermines user trust in the NFT ecosystem if miners are seen to consistently obtain desirable symbols through privileged access.

4. **Economic Impact**: While speculative, if 1000 NFT protocols are created and miners systematically claim the top 10% most desirable symbols, this represents a quantifiable advantage. In NFT markets where rarity and sequential numbering matter, this could translate to real economic value.

**Severity Assessment: MEDIUM**

This is not a critical vulnerability because:
- No direct fund theft or loss
- No token supply manipulation  
- No protocol breakdown or consensus failure
- Impact depends on whether symbol numbers actually command market premiums

However, it is significant because:
- Creates systematic rather than one-time advantages
- Affects fairness guarantees in a potentially valuable asset allocation mechanism
- Is easily exploitable by all miners/validators
- Hard to detect without statistical analysis

## Likelihood Explanation

**Attacker Profile:**
- Must be a current miner/validator in the AEDPoS consensus set
- This is a realistic attacker profile as validators are elected participants in the protocol

**Attack Complexity: LOW**
1. Monitor `State.RandomHashes[H-1]` when producing block H (publicly available on-chain)
2. Compute hash outputs for controlled addresses offline
3. Select address yielding desirable symbol number
4. Submit Create transaction and control transaction ordering

**Prerequisites:**
- Block production rights (validators have this legitimately)
- Technical ability to compute hashes (straightforward)
- Multiple controlled addresses (trivial to create)
- No special permissions beyond standard mining

**Detection Difficulty:**
- Appears as normal NFT protocol creation on-chain
- No cryptographic evidence of malicious intent
- Can be disguised as "fortunate" random allocation
- Only statistical analysis showing miners' abnormal clustering at desirable numbers would reveal the pattern

**Economic Rationality:**
- Attack cost: Minimal (only transaction fees)
- Potential benefit: Market premium on desirable symbols (if any)
- Risk: Low technical/financial risk; only reputation damage if detected statistically

**Probability: HIGH** if symbol numbers have perceived market value and validators have economic incentive in NFT markets.

## Recommendation

**Fix 1: Use Future Block Randomness (Preferred)**

Implement a commit-reveal scheme where users commit to creating an NFT protocol in one block and the symbol is generated using randomness from a future block that hasn't been produced yet. This prevents miners from knowing the randomness at commit time.

**Fix 2: Use Current Block Randomness with Delay**

Instead of `Context.CurrentHeight.Sub(1)`, consider using `Context.CurrentHeight.Add(N)` where N is a future block height. Store the pending creation and fulfill it when that block is reached, using its randomness.

**Fix 3: Add Sender-Unpredictable Component**

Combine additional unpredictable data that miners cannot control at transaction submission time, such as the transaction hash itself or other block-specific data that's only known after inclusion.

**Example Fix (Conceptual):**
```csharp
// Instead of using previous block:
Value = Context.CurrentHeight.Sub(1)

// Use future block or include transaction-specific unpredictable data:
Value = Context.CurrentHeight.Add(DelayBlocks)
// Or combine with tx hash: Hash(Context.TransactionId || Context.Sender || RandomBytes)
```

## Proof of Concept

The following test demonstrates that symbol numbers are predictable given knowledge of the previous block's random hash and sender address:

```csharp
[Fact]
public async Task PredictableSymbolNumber_MinerCanPrecomputeSymbols()
{
    // Setup: Assume we're at block height H
    var currentHeight = 100L;
    var previousHeight = currentHeight - 1;
    
    // Miner knows the previous block's random hash (it's already stored on-chain)
    var previousRandomHash = HashHelper.ComputeFrom("known_previous_hash");
    
    // Miner can test multiple controlled addresses offline
    var address1 = Address.FromPublicKey("address1_pubkey".GetBytes());
    var address2 = Address.FromPublicKey("address2_pubkey".GetBytes());
    var address3 = Address.FromPublicKey("address3_pubkey".GetBytes());
    
    // Compute what symbol numbers each address would generate
    var hash1 = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(address1), 
        HashHelper.ComputeFrom(previousRandomHash));
    var hash2 = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(address2), 
        HashHelper.ComputeFrom(previousRandomHash));
    var hash3 = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(address3), 
        HashHelper.ComputeFrom(previousRandomHash));
    
    // Convert to symbol numbers (same logic as GenerateSymbolNumber)
    var from = 100000000L; // 9 digits minimum
    var symbolNum1 = ConvertHashToInt64(hash1, from, from * 10);
    var symbolNum2 = ConvertHashToInt64(hash2, from, from * 10);
    var symbolNum3 = ConvertHashToInt64(hash3, from, from * 10);
    
    // Miner selects the most desirable number (e.g., lowest)
    var minSymbol = Math.Min(Math.Min(symbolNum1, symbolNum2), symbolNum3);
    Address selectedAddress;
    if (minSymbol == symbolNum1) selectedAddress = address1;
    else if (minSymbol == symbolNum2) selectedAddress = address2;
    else selectedAddress = address3;
    
    // Miner submits Create transaction from selected address
    // This demonstrates the predictability - miner can choose optimal symbol
    // before including transaction in block
    
    Assert.True(true); // Demonstrates the attack is feasible
}
```

**Notes:**
- This is not a test that runs against the actual contract, but demonstrates the logical vulnerability
- The actual exploit would involve a miner running this computation off-chain before building their block
- The miner would then submit the Create transaction from whichever address yields the best symbol number
- The on-chain result appears as normal NFT creation with no detectable manipulation

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-73)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);

        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;

        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = tokenCreateInput.Symbol,
            Creator = tokenCreateInput.Issuer,
            IsBurnable = tokenCreateInput.IsBurnable,
            IssueChainId = tokenCreateInput.IssueChainId,
            ProtocolName = tokenCreateInput.TokenName,
            TotalSupply = tokenCreateInput.TotalSupply,
            Metadata = protocolInfo.Metadata,
            BaseUri = protocolInfo.BaseUri,
            IsTokenIdReuse = protocolInfo.IsTokenIdReuse,
            NftType = protocolInfo.NftType
        });

        return new StringValue
        {
            Value = symbol
        };
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L117-122)
```csharp
    public override Hash GetRandomHash(Int64Value input)
    {
        Assert(input.Value > 1, "Invalid block height.");
        Assert(Context.CurrentHeight >= input.Value, "Block height not reached.");
        return State.RandomHashes[input.Value] ?? Hash.Empty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L124-129)
```csharp
    public override BytesValue GetRandomBytes(BytesValue input)
    {
        var height = new Int64Value();
        height.MergeFrom(input.Value);
        return GetRandomHash(height).ToBytesValue();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```
