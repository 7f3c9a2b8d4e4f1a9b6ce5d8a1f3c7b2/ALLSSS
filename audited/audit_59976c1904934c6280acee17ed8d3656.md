### Title
ReceivedTokenSymbols Accumulates Obsolete Symbols Causing Gas Waste and Potential DoS in Profit Claims

### Summary
The `ReceivedTokenSymbols` list in profit schemes permanently accumulates all token symbols ever contributed, with no removal mechanism. This causes `ClaimProfits` and view functions to iterate through potentially hundreds of obsolete symbols, leading to unnecessary gas consumption and possible transaction failures due to gas limits.

### Finding Description

The vulnerability exists in how `ReceivedTokenSymbols` is managed in the Profit contract:

**Root Cause:**
Symbols are added to `ReceivedTokenSymbols` when tokens are contributed to a scheme [1](#0-0)  or distributed to sub-schemes [2](#0-1) , but there is no code to remove symbols when they become obsolete or have zero balance.

**Problematic Usage:**
In `ProfitAllPeriods`, when `targetSymbol` is null, the function iterates through ALL symbols in `ReceivedTokenSymbols` [3](#0-2) . For each symbol, it performs nested loops through periods [4](#0-3) , creating virtual addresses [5](#0-4)  and reading from state storage [6](#0-5)  even when symbols have no profits.

**Call Paths:**
- `ClaimProfits` calls `ProfitAllPeriods` with `targetSymbol=null` [7](#0-6) 
- View method `GetAllProfitsMap` also calls `ProfitAllPeriods` [8](#0-7) 

**Why Existing Protections Fail:**
While the code skips symbols with no profits via continue statements [9](#0-8) , it still performs expensive operations (virtual address creation and state reads) for each symbol before determining it has no profits.

### Impact Explanation

**Operational Impact - Gas Waste and DoS:**
- Every `ClaimProfits` transaction wastes gas iterating through obsolete symbols that no longer have any profits
- As schemes accumulate more token symbols over time (e.g., 50-100+ different tokens), the gas cost grows linearly
- Beyond a threshold, `ClaimProfits` transactions may fail due to exceeding block gas limits, effectively preventing beneficiaries from claiming their legitimate profits

**Attack Vector:**
An attacker with minimal resources can exploit `ContributeProfits` (public method) [10](#0-9)  to contribute 1 wei of many different token symbols, permanently inflating `ReceivedTokenSymbols` and making all future profit claims more expensive or impossible.

**Affected Parties:**
- Legitimate beneficiaries unable to claim profits due to high gas costs
- Schemes with long operational history naturally accumulating many symbols
- All users querying profit information via view methods

### Likelihood Explanation

**Attacker Capabilities:**
- Requires ability to obtain various token symbols (minimal amounts sufficient)
- Needs approval to call `ContributeProfits` for each symbol
- Total cost: gas fees + 1 wei per token symbol (very low barrier)

**Attack Complexity:**
Low - straightforward repeated calls to a public method [11](#0-10) 

**Feasibility:**
- No special permissions required beyond token ownership
- `ContributeProfits` performs token existence validation but not symbol count limits [12](#0-11) 
- Attack amplifies naturally as schemes age and receive diverse tokens

**Detection:**
Difficult to distinguish malicious inflation from legitimate multi-token contributions

**Probability:**
Medium-High for natural accumulation in long-running schemes, Low-Medium for intentional attacks due to attacker costs

### Recommendation

**Immediate Mitigation:**
1. Add a cap on `ReceivedTokenSymbols` list size in `ContributeProfits`:
```
Assert(scheme.ReceivedTokenSymbols.Count < MAX_SYMBOL_COUNT || 
       scheme.ReceivedTokenSymbols.Contains(input.Symbol), 
       "Maximum token symbol limit reached.");
```

2. Implement symbol cleanup logic to remove symbols with zero balance across all periods during `DistributeProfits` or add a dedicated maintenance function.

3. In `ProfitAllPeriods`, add early-exit optimization:
```
// Skip symbols with no balance in any period for this scheme
var balance = State.TokenContract.GetBalance.Call(...).Balance;
if (balance == 0 && !HasHistoricalProfits(schemeId, symbol)) continue;
```

**Long-term Solution:**
- Replace the unbounded list with a more efficient data structure (e.g., active symbols set with periodic cleanup)
- Add manager-only function to explicitly remove obsolete symbols
- Implement pagination for multi-symbol operations

**Test Cases:**
1. Verify adding 100+ distinct symbols triggers the cap
2. Test cleanup removes symbols with zero balance across all claimable periods
3. Confirm gas costs remain bounded as symbol list grows
4. Validate legitimate multi-token operations still function

### Proof of Concept

**Initial State:**
- Scheme S exists with `IsReleaseAllBalanceEveryTimeByDefault = true`
- Beneficiary B has profit shares in scheme S
- Attacker A has small amounts of 100 different token symbols

**Attack Steps:**
1. For each of 100 token symbols (TOKEN_1 through TOKEN_100):
   - A calls `ContributeProfits(schemeId: S, symbol: TOKEN_i, amount: 1, period: 0)`
   - Each call adds TOKEN_i to `ReceivedTokenSymbols` [1](#0-0) 

2. Manager distributes profits for period 1 using only ELF token

3. B attempts to call `ClaimProfits(schemeId: S, beneficiary: B)`

**Expected Result:**
B successfully claims ELF profits with reasonable gas cost

**Actual Result:**
- `ClaimProfits` â†’ `ProfitAllPeriods` iterates through all 100 symbols [13](#0-12) 
- For each symbol, performs nested loops through periods and state reads [4](#0-3) 
- Gas consumption increases ~100x compared to single-symbol case
- Transaction may fail with "out of gas" error if symbol count is high enough

**Success Condition:**
Transaction succeeds but consumes excessive gas, or fails entirely if enough symbols are added, demonstrating the DoS condition.

**Notes**

This is classified as **Low severity** because:
- Requires sustained attack or natural accumulation over time to cause significant impact
- Does not directly steal funds or compromise authorization
- Primarily affects operational efficiency rather than correctness
- Mitigation is straightforward (add symbol count limits)

However, for long-lived production schemes handling diverse tokens, this can become a practical operational issue preventing legitimate profit claims.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L641-644)
```csharp
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-721)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
        // ReSharper disable once PossibleNullReferenceException
        var virtualAddress = scheme.VirtualAddress;

        if (input.Period == 0)
        {

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = virtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = $"Add {input.Amount} dividends."
            });
        }
        else
        {
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
        }

        // If someone directly use virtual address to do the contribution, won't sense the token symbol he was using.
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);

        State.SchemeInfos[scheme.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L784-784)
```csharp
            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L851-853)
```csharp
        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-912)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L130-133)
```csharp
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
            AddProfitToDict(allProfitsDict, totalProfitsDictForEachProfitDetail);
            if(i >= profitableDetailCount) continue;
            var claimableProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount,true, symbol);
```
