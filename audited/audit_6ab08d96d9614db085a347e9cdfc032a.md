### Title
Branch Count Exhaustion DoS in Association Voting Due to Linear Search on Large Vote Lists

### Summary
The `AssertProposalNotYetVotedBySender()` function performs linear `Contains()` searches on three proposal vote lists (Approvals, Rejections, Abstentions), with each iteration counting as a branch operation against AElf's 15,000 branch limit. When a proposal accumulates ~15,000 or more total votes, subsequent voting attempts will exceed the branch threshold and fail with `RuntimeBranchThresholdExceededException`, creating a denial-of-service condition that prevents legitimate organization members from voting.

### Finding Description

**Location**: [1](#0-0) 

**Root Cause**: The vote validation logic uses three sequential `Contains()` operations on `repeated aelf.Address` fields, which are implemented as collections with O(n) linear search complexity. In AElf's execution model, each backward-jumping branch instruction (including loop iterations within `Contains()`) increments the branch counter tracked by the ExecutionObserver. [2](#0-1) 

The hard limit of 15,000 branches per transaction is defined in: [3](#0-2) 

**Execution Path**:
1. Member calls `Approve()`, `Reject()`, or `Abstain()` on a proposal: [4](#0-3) 
2. Each voting method immediately calls `AssertProposalNotYetVotedBySender()`
3. This function performs up to three `Contains()` scans across the vote lists
4. Each iteration in `Contains()` increments the branch count
5. When cumulative iterations exceed 15,000, execution fails

**Why Protections Fail**: 
- No size limit exists on organization member lists: [5](#0-4) 
- No limit on the number of votes a proposal can accumulate
- Protobuf `repeated` fields use collections with linear search: [6](#0-5) 
- The short-circuit OR operator only helps if the sender is found early; worst case still scans all lists

Test evidence confirms foreach loops counting toward branch limits: [7](#0-6) 

### Impact Explanation

**Operational Impact - DoS of Governance Flow**:
- Organizations with high voting participation (15,000+ cumulative votes) become permanently unable to accept new votes
- Proposals approaching or exceeding the vote count threshold effectively "lock out" remaining members
- Critical governance decisions may fail to reach approval thresholds due to artificial participation caps
- The issue naturally occurs without any malicious actor - legitimate democratic participation triggers the DoS

**Who is Affected**:
- Large decentralized organizations (DAOs, token holder associations, cross-chain governance bodies)
- Any Association organization with hundreds or thousands of active members
- High-stakes proposals that naturally attract broad participation

**Severity Justification**: 
This creates an unintentional but hard ceiling on governance participation. As organizations grow and proposals attract legitimate widespread support, the system self-destructs. Unlike traditional DoS requiring continuous attack, this is a permanent state change once vote lists grow large enough. The 15,000 limit is far below "millions" - with just 10,000 approvals + 3,000 rejections + 2,000 abstentions, the next voter is blocked.

### Likelihood Explanation

**Reachable Entry Point**: All three public voting methods (`Approve`, `Reject`, `Abstain`) are affected: [8](#0-7) 

**Feasible Preconditions**:
- Organization with sufficient members (no size limit enforced)
- Proposal receiving legitimate votes from ~15,000 members total across all three vote types
- No special attacker capabilities needed - regular members voting normally

**Execution Practicality**: 
The scenario is entirely realistic for:
- Public governance organizations with thousands of token holders
- Cross-chain coordination bodies with diverse stakeholders  
- Community DAOs with broad participation

The issue is exacerbated because:
- Organization member lists have no upper bound validation
- The same pattern exists in Parliament contract: [9](#0-8) 
- Though Parliament is less vulnerable due to smaller miner lists, Association explicitly supports large public organizations

**Probability**: MEDIUM-HIGH for large organizations, increases with organization size and proposal importance.

### Recommendation

**Immediate Mitigation**:
Replace linear `Contains()` searches with a more efficient lookup mechanism. Store a separate `MappedField<Address, bool>` or use a HashSet-style structure for voted addresses:

```csharp
// In state definition, add:
public MappedField<Hash, Address, bool> ProposalVoters { get; set; }

// In AssertProposalNotYetVotedBySender:
private void AssertProposalNotYetVotedBySender(ProposalInfo proposal, Address sender)
{
    var hasVoted = State.ProposalVoters[proposal.ProposalId][sender];
    Assert(!hasVoted, "Sender already voted.");
}

// In voting methods, set the flag:
State.ProposalVoters[input][Context.Sender] = true;
```

**Additional Protections**:
1. Add organization member count validation in `Validate()` function with a reasonable upper bound (e.g., 10,000 members)
2. Add per-proposal vote count limits based on organization size
3. Include integration tests with large vote lists (~15,000+ members) to verify branch count limits
4. Monitor existing proposals nearing the threshold and provide migration paths

**Invariant to Add**:
`proposal.Approvals.Count + proposal.Rejections.Count + proposal.Abstentions.Count < ExecutionBranchThreshold`

### Proof of Concept

**Required Initial State**:
1. Association organization created with 20,000 members
2. Proposal created for that organization
3. 10,000 members call `Approve(proposalId)`
4. 3,000 members call `Reject(proposalId)` 
5. 2,000 members call `Abstain(proposalId)`
6. Total votes: 15,000

**Attack Steps**:
```
Step 1: Member #15,001 calls Approve(proposalId)
Step 2: Transaction enters Approve() method
Step 3: AssertProposalNotYetVotedBySender() is called
Step 4: proposal.Approvals.Contains(sender) iterates 10,000 times → 10,000 branches
Step 5: proposal.Rejections.Contains(sender) iterates 3,000 times → +3,000 branches  
Step 6: proposal.Abstentions.Contains(sender) iterates 2,000 times → +2,000 branches
Step 7: Total branch count: 15,000 → threshold reached
```

**Expected vs Actual Result**:
- Expected: Member's vote is recorded, governance proceeds normally
- Actual: Transaction fails with "Contract branch threshold 15000 exceeded" error
- All subsequent voters (members 15,001 through 20,000) are permanently unable to vote
- Proposal may fail to reach approval threshold despite having sufficient support

**Success Condition**: Transaction reverts with `RuntimeBranchThresholdExceededException` before reaching line where vote would be recorded.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L132-138)
```csharp
    private void AssertProposalNotYetVotedBySender(ProposalInfo proposal, Address sender)
    {
        var isAlreadyVoted = proposal.Approvals.Contains(sender) || proposal.Rejections.Contains(sender) ||
                             proposal.Abstentions.Contains(sender);

        Assert(!isAlreadyVoted, "Sender already voted.");
    }
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L29-36)
```csharp
    public void BranchCount()
    {
        if (_branchThreshold != -1 && _branchCount == _branchThreshold)
            throw new RuntimeBranchThresholdExceededException(
                $"Contract branch threshold {_branchThreshold} exceeded.");

        _branchCount++;
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-181)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }

    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Rejections.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Reject),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }

    public override Empty Abstain(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Abstentions.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Abstain),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** protobuf/association_contract.proto (L91-96)
```text
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
```

**File:** test/AElf.Contracts.TestContract.Tests/PatchedContractSecurityTests.cs (L428-434)
```csharp
            await TestBasicSecurityContractStub.TestForeachInfiniteLoop.SendAsync(new ListInput
                { List = { new int[14999] } });
            var txResult =
                await TestBasicSecurityContractStub.TestForeachInfiniteLoop.SendWithExceptionAsync(
                    new ListInput { List = { new int[15000] } });
            txResult.TransactionResult.Error.ShouldContain(nameof(RuntimeBranchThresholdExceededException));
        }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L190-199)
```csharp
    private void AssertProposalNotYetVotedByMember(ProposalInfo proposal, Address parliamentMemberAddress)
    {
        Assert(!CheckProposalAlreadyVotedBy(proposal, parliamentMemberAddress), "Already approved.");
    }

    private bool CheckProposalAlreadyVotedBy(ProposalInfo proposal, Address address)
    {
        return proposal.Approvals.Contains(address) || proposal.Rejections.Contains(address) ||
               proposal.Abstentions.Contains(address);
    }
```
