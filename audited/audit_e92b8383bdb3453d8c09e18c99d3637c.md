### Title
Missing Validation Allows Miner to Execute Multiple UpdateValue Transactions in Same Round

### Summary
The `UpdateValue` validation logic does not check whether a miner has already mined in the current round before accepting another `UpdateValue` transaction. A malicious miner can bypass the consensus command protocol to submit multiple `UpdateValue` transactions within the same round, artificially inflating their block production count and manipulating reward distributions.

### Finding Description

The vulnerability exists in two locations:

**1. Insufficient Validation Logic**

The `UpdateValueValidationProvider` only validates that the newly provided consensus data contains valid `OutValue` and `Signature` fields, but does not check whether the miner has already mined in the current round (i.e., whether `OutValue` is already set in the state). [1](#0-0) 

The validation logic only examines `validationContext.ProvidedRound` (the new data being submitted), not the original state before recovery. This is because `ValidateBeforeExecution` calls `RecoverFromUpdateValue` on the base round before creating the validation context: [2](#0-1) 

The recovery process overwrites the `OutValue` in the base round, making it impossible for validators to detect if the miner had already mined: [3](#0-2) 

**2. Missing Assertion in Execution Logic**

The `ProcessUpdateValue` method has no check to prevent execution when `OutValue` is already set. It unconditionally adds to `ActualMiningTimes`, overwrites `OutValue` and `Signature`, and increments block production counters: [4](#0-3) 

**Root Cause**

While the normal consensus flow uses `ConsensusBehaviourProviderBase` to check `OutValue == null` before returning `UpdateValue` behavior, this is only a client-side protocol decision: [5](#0-4) 

The validation and execution layers do not enforce this invariant. A malicious miner can bypass the command protocol and directly submit `UpdateValue` transactions.

### Impact Explanation

**Direct Impact:**
- **Block Production Inflation**: Each additional `UpdateValue` call increments `ProducedBlocks` and `ProducedTinyBlocks` counters, allowing miners to falsely inflate their production statistics
- **Reward Manipulation**: Block production counts directly affect miner rewards and profit distributions in the consensus dividend pool
- **Election Gaming**: Production metrics influence miner rankings and election results, allowing malicious miners to gain unfair advantages
- **Round Data Corruption**: Multiple `ActualMiningTimes` entries violate the one-block-per-miner-per-round invariant, corrupting consensus state

**Affected Parties:**
- Honest miners receive reduced rewards due to dilution
- Token holders and voters are misled by inflated performance metrics
- Overall consensus integrity is compromised

**Severity**: Critical - Direct manipulation of consensus state and reward allocation with minimal cost to attacker.

### Likelihood Explanation

**Reachability**: The `UpdateValue` method is publicly callable: [6](#0-5) 

**Attacker Capabilities**: Any authorized miner in the current or previous round can execute this attack. The `PreCheck` only verifies miner list membership, not whether they've already mined: [7](#0-6) 

**Attack Complexity**: Low - Miner simply needs to:
1. Produce first block normally with `UpdateValue` (OutValue gets set)
2. Craft second `UpdateValue` transaction with different `InValue`/`OutValue`
3. Submit as consensus transaction in next block they produce

**Detection**: Difficult - The malicious transactions appear valid and pass all existing validation checks. Only forensic analysis of `ActualMiningTimes` counts would reveal the exploit.

**Economic Rationality**: High - Attacker gains increased rewards and election advantage at negligible cost (just block production costs they already pay).

### Recommendation

**Primary Fix**: Add explicit validation to check if `OutValue` is already set in the original state before recovery.

In `UpdateValueValidationProvider.ValidateHeaderInformation`, add:

```csharp
// Check if miner has already mined in current round
if (validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey].OutValue != null)
{
    return new ValidationResult { Message = "Miner has already mined in this round." };
}
```

**Note**: This requires modifying the validation flow to preserve the original `BaseRound` state before `RecoverFromUpdateValue` is called, or passing both pre-recovery and post-recovery rounds to validators.

**Secondary Fix**: Add defensive assertion in `ProcessUpdateValue`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    
    // Ensure miner hasn't already mined in current round
    Assert(minerInRound.OutValue == null, "Miner has already mined in this round.");
    
    // ... rest of method
}
```

**Test Cases**: Add integration tests verifying that:
1. Second `UpdateValue` call by same miner in same round is rejected during validation
2. Attempting to increment `ProducedBlocks` twice fails with clear error
3. `ActualMiningTimes` never contains duplicate entries for same miner in same round

### Proof of Concept

**Initial State:**
- Round N is active
- Miner A is in the miner list with time slot
- Miner A's `OutValue` = null (hasn't mined yet)

**Attack Sequence:**

1. **Block Height H - Legitimate First Mining:**
   - Miner A calls `GetConsensusCommand` → Returns `UpdateValue` (OutValue is null)
   - Miner A produces block with `UpdateValue(InValue1, OutValue1, Signature1)`
   - Validation: Passes (first time mining)
   - Execution: `OutValue` = OutValue1, `ProducedBlocks` = 1, `ActualMiningTimes` = [TimeH]
   - State After: `minerA.OutValue` = OutValue1, `minerA.ProducedBlocks` = 1

2. **Block Height H+1 - Malicious Second Mining:**
   - Miner A BYPASSES `GetConsensusCommand` (would return TinyBlock/terminate)
   - Miner A crafts `UpdateValue(InValue2, OutValue2, Signature2)` transaction directly
   - Validation:
     - Gets baseRound from state (OutValue = OutValue1)
     - Calls `RecoverFromUpdateValue` → Overwrites OutValue with OutValue2 in validation copy
     - `UpdateValueValidationProvider` checks if OutValue2 is filled → YES, passes
     - **VULNERABILITY: Never checks original OutValue was already set**
   - Execution:
     - Gets currentRound from state (OutValue still = OutValue1)
     - Line 243: `ActualMiningTimes.Add(TimeH+1)` → Now [TimeH, TimeH+1]
     - Line 245: `OutValue` = OutValue2 (overwrites OutValue1)
     - Line 251-252: `ProducedBlocks` = 2, `ProducedTinyBlocks` = 2
   - State After: `minerA.OutValue` = OutValue2, `minerA.ProducedBlocks` = 2

**Expected Result:** Second `UpdateValue` should be rejected with "Miner has already mined in this round"

**Actual Result:** Second `UpdateValue` succeeds, miner credited with 2 blocks in same round

**Success Condition:** `minerA.ProducedBlocks` = 2 and `minerA.ActualMiningTimes.Count` = 2 within single round, violating consensus invariants.

### Notes

This vulnerability represents a fundamental gap in defense-in-depth. While the normal protocol flow through `ConsensusBehaviourProviderBase` prevents this scenario, the validation and execution layers must independently enforce consensus invariants regardless of client behavior. The recovery mechanism in validation further obscures the original state, making detection impossible with current validation logic.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-60)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L14-20)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-252)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-56)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
