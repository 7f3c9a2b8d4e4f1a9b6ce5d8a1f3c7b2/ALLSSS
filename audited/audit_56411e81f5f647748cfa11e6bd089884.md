### Title
Hex Encoding Case Sensitivity Causes Miner DoS Through Candidate Replacement

### Summary
The `RecordCandidateReplacement` method in the consensus contract accepts pubkey strings from the Election Contract without normalizing their case. Since `RealTimeMinersInformation` uses case-sensitive dictionary keys but all normal operations use lowercase hex strings from `.ToHex()`, an attacker can replace a candidate's pubkey with an uppercase variant, causing the miner to be unable to produce blocks due to dictionary key mismatches.

### Finding Description

The vulnerability exists in the interaction between the Election Contract's `ReplaceCandidatePubkey` method and the Consensus Contract's `RecordCandidateReplacement` method.

**Root Cause:**

The consensus contract's `RecordCandidateReplacement` method accepts string pubkeys directly without case normalization: [1](#0-0) 

At lines 140-143, the method removes the old pubkey and adds the new pubkey as dictionary keys without any case normalization.

**Normal Flow Uses Lowercase:**

Throughout the codebase, all pubkey strings are consistently generated using `.ToHex()` which produces lowercase hex: [2](#0-1) 

The hex encoding at lines 25 and 28 uses `b + 0x37 + 0x20` which produces lowercase 'a'-'f' characters.

**Dictionary Access in Block Production:**

When miners produce blocks, their pubkey is converted to lowercase hex and used to access the dictionary: [3](#0-2) [4](#0-3) 

**Dictionary Access in Validation:**

The validation also uses lowercase pubkeys: [5](#0-4) [6](#0-5) 

**Attack Entry Point:**

The Election Contract's `ReplaceCandidatePubkey` method accepts arbitrary string pubkeys without validation: [7](#0-6) [8](#0-7) [9](#0-8) 

The protobuf definition shows pubkeys are simple strings with no format constraints.

### Impact Explanation

**Direct Operational Impact:**
- A miner whose pubkey was replaced with an uppercase variant becomes unable to produce blocks
- Block production at lines 58-63 of `AEDPoSContract_GetConsensusBlockExtraData.cs` will fail with KeyNotFoundException
- Validation checks will fail, preventing the miner from participating in consensus

**Consensus Integrity:**
- Affected miners miss their time slots, causing consensus delays
- If multiple miners are affected, could significantly disrupt block production
- Reduces effective miner count and centralizes consensus power

**Who is Affected:**
- Any candidate/miner whose admin performs a pubkey replacement with non-lowercase hex
- Can be triggered maliciously by the candidate's own admin
- Can also occur accidentally if someone uses uppercase hex strings

**Severity:** HIGH - Direct DoS of consensus participants, disrupts core protocol operation

### Likelihood Explanation

**Attacker Capabilities:**
- Requires being the admin of a candidate who is a current miner
- This is a legitimate, non-privileged role that candidates set themselves

**Attack Complexity:**
- Single transaction call to `Election.ReplaceCandidatePubkey`
- Simply provide uppercase hex string as new pubkey
- No complex setup or timing requirements

**Feasibility Conditions:**
- Candidate must be a current miner (common scenario)
- Admin must have permission (which they do by design)
- No special blockchain state required

**Detection Constraints:**
- Attack is not immediately detectable
- Only becomes apparent when miner tries to produce next block
- Could be disguised as accidental misconfiguration

**Probability:** MEDIUM-HIGH
- Can occur accidentally (developer using uppercase hex)
- Can be triggered maliciously by malicious admin
- No economic or technical barriers to execution

### Recommendation

**Code-Level Mitigation:**

1. Add case normalization in `RecordCandidateReplacement`: [10](#0-9) 

Modify lines 137-143 to normalize pubkey strings to lowercase before use:
```csharp
var oldPubkeyNormalized = input.OldPubkey.ToLowerInvariant();
var newPubkeyNormalized = input.NewPubkey.ToLowerInvariant();

if (!currentRound.RealTimeMinersInformation.ContainsKey(oldPubkeyNormalized)) return new Empty();

var realTimeMinerInformation = currentRound.RealTimeMinersInformation[oldPubkeyNormalized];
realTimeMinerInformation.Pubkey = newPubkeyNormalized;
currentRound.RealTimeMinersInformation.Remove(oldPubkeyNormalized);
currentRound.RealTimeMinersInformation.Add(newPubkeyNormalized, realTimeMinerInformation);
```

2. Add validation in `ReplaceCandidatePubkey`: [11](#0-10) 

Add validation after line 177 to ensure pubkeys are lowercase hex:
```csharp
Assert(input.OldPubkey == input.OldPubkey.ToLowerInvariant(), "Old pubkey must be lowercase hex.");
Assert(input.NewPubkey == input.NewPubkey.ToLowerInvariant(), "New pubkey must be lowercase hex.");
```

**Invariant Checks:**
- All pubkey strings used as dictionary keys must be lowercase
- Add assertion in dictionary access operations to catch case mismatches

**Test Cases:**
- Test replacement with uppercase pubkey should fail validation or normalize
- Test miner block production after replacement with mixed-case pubkey
- Test validation with case-mismatched pubkeys

### Proof of Concept

**Initial State:**
- Candidate with pubkey `0xabcd...` is an active miner
- Their pubkey exists in `currentRound.RealTimeMinersInformation["abcd..."]`
- Candidate admin has permission to replace pubkey

**Attack Steps:**

1. Attacker (candidate admin) calls `Election.ReplaceCandidatePubkey`:
   ```
   OldPubkey: "abcd..." (lowercase, current format)
   NewPubkey: "ABCD..." (uppercase, same bytes)
   ```

2. This triggers `Consensus.RecordCandidateReplacement`:
   - Removes dictionary entry with key "abcd..."
   - Adds dictionary entry with key "ABCD..."

3. When miner tries to produce block:
   - Their pubkey bytes `[0xAB, 0xCD, ...]` convert to "abcd..." via `.ToHex()`
   - Code tries to access `currentRound.RealTimeMinersInformation["abcd"]`
   - Dictionary lookup fails (key not found)
   - Block production fails

**Expected vs Actual:**
- Expected: Pubkey replacement allows miner to continue producing blocks
- Actual: Miner can no longer produce blocks due to dictionary key mismatch

**Success Condition:**
- After replacement with uppercase pubkey, miner's next block production attempt fails
- Error occurs at dictionary access in `GetConsensusExtraDataToPublishOutValue`

### Notes

This vulnerability demonstrates a critical type safety issue where string case sensitivity creates an exploitable inconsistency between different contract interactions. The fix requires enforcing case normalization at all entry points that accept pubkey strings, or alternatively using case-insensitive dictionary comparisons (though normalization is preferred for consistency).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L8-32)
```csharp
        public static string ToHex(this ByteString bytes, bool withPrefix = false)
        {
            var offset = withPrefix ? 2 : 0;
            var length = bytes.Length * 2 + offset;
            var c = new char[length];

            byte b;

            if (withPrefix)
            {
                c[0] = '0';
                c[1] = 'x';
            }

            for (int bx = 0, cx = offset; bx < bytes.Length; ++bx, ++cx)
            {
                b = (byte)(bytes[bx] >> 4);
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
            }

            return new string(c);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L13-23)
```csharp
    private BytesValue GetConsensusBlockExtraData(BytesValue input, bool isGeneratingTransactions = false)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);

        Assert(triggerInformation.Pubkey.Any(), "Invalid pubkey.");

        TryToGetCurrentRoundInformation(out var currentRound);

        var publicKeyBytes = triggerInformation.Pubkey;
        var pubkey = publicKeyBytes.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L55-63)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataToPublishOutValue(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L13-17)
```csharp
    /// <summary>
    ///     We can trust this because we already validated the pubkey
    ///     during `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`
    /// </summary>
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-187)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-302)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;

        // Notify Consensus Contract to update replacement information. (Update from old record.)
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** protobuf/election_contract.proto (L504-507)
```text
message ReplaceCandidatePubkeyInput {
    string old_pubkey = 1;
    string new_pubkey = 2;
}
```
