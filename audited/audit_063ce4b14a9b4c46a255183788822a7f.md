### Title
Division by Zero in Consensus Miner Count Calculation Enables Blockchain Halt

### Summary
The `SetMinerIncreaseInterval` function lacks validation to prevent setting `MinerIncreaseInterval` to zero, allowing a governance-controlled actor to halt the blockchain. When set to zero, subsequent consensus round or term transitions trigger division by zero exceptions in `GetMinersCount` and `GetAutoIncreasedMinersCount`, completely stopping blockchain progression.

### Finding Description

**Root Cause:**

The `SetMinerIncreaseInterval` function contains insufficient input validation that allows setting `State.MinerIncreaseInterval.Value` to zero. [1](#0-0) 

The validation at line 61 only checks that the new value is less than or equal to the current value (`input.Value <= State.MinerIncreaseInterval.Value`), but does not verify that `input.Value > 0`. This allows an authorized actor to set the value to zero through repeated calls with decreasing values.

**Division by Zero Locations:**

Once `MinerIncreaseInterval` is set to zero, two critical functions perform division by this value:

1. **GetAutoIncreasedMinersCount** - Used by the public view method `GetMaximumMinersCount`: [2](#0-1) 

2. **GetMinersCount** - Used during consensus round and term transitions: [3](#0-2) 

**Critical Execution Paths:**

The division by zero will be triggered during essential consensus operations:

1. **Round Transitions** - Called in `ProcessNextRound` during the first round transition: [4](#0-3) 

2. **Term Transitions** - Called in `ProcessNextTerm` via `UpdateMinersCountToElectionContract`: [5](#0-4) [6](#0-5) 

3. **Governance Operations** - Called when updating maximum miners count: [7](#0-6) 

### Impact Explanation

**Severity: CRITICAL**

This vulnerability enables a complete Denial of Service (DoS) of the blockchain's consensus mechanism:

1. **Consensus Halt**: Round and term transitions are fundamental to the AEDPoS consensus mechanism. When `GetMinersCount` fails with division by zero during `ProcessNextRound` or `ProcessNextTerm`, these critical consensus operations cannot complete.

2. **Blockchain停止**: Since consensus cannot progress to the next round or term, no new blocks can be produced. The entire blockchain becomes frozen.

3. **Scope**: Affects all main chain nodes. The blockchain cannot recover without manual intervention or a hard fork.

4. **Cascade Effects**: 
   - All transactions halt
   - Cross-chain operations freeze
   - Token transfers stop
   - Governance operations cannot execute
   - Economic rewards cannot be distributed

The default value is set to 31,536,000 seconds (1 year), as shown in the configuration: [8](#0-7) 

### Likelihood Explanation

**Likelihood: MEDIUM**

**Attacker Capabilities Required:**
- Control of the `MaximumMinersCountController` (Parliament organization by default)
- Ability to submit and execute governance proposals

**Attack Complexity:**
- LOW - Single function call after obtaining authorization
- The attacker can gradually reduce the value: first call sets it to 31,535,999, subsequent calls reduce it further, eventually reaching 0

**Feasibility Conditions:**
- Requires Parliament governance control, which is a privileged position
- However, Parliament is a multi-sig organization that could be compromised through:
  - Social engineering of Parliament members
  - Compromise of multiple member accounts
  - Accidental approval of a malicious proposal
  - Bug in proposal validation

**Realistic Scenarios:**
1. **Governance Error**: Parliament members accidentally approve a proposal setting the interval to 0, not understanding the consequences
2. **Malicious Governance**: A compromised Parliament deliberately halts the chain
3. **Gradual Attack**: Attacker with partial Parliament control gradually reduces the value over multiple proposals to avoid detection

**Detection**: 
- The value change is visible on-chain
- However, setting it to a small non-zero value first might avoid immediate detection
- Once set to 0, the impact is immediate on the next consensus transition

### Recommendation

**Immediate Fix:**

Add a validation check in `SetMinerIncreaseInterval` to ensure the value is always greater than zero:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be greater than zero.");  // ADD THIS LINE
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

**Additional Safeguards:**

1. Add the same validation during contract initialization:

```csharp
public override Empty InitialAElfConsensusContract(InitialAElfConsensusContractInput input)
{
    Assert(State.CurrentRoundNumber.Value == 0 && !State.Initialized.Value, "Already initialized.");
    State.Initialized.Value = true;

    State.PeriodSeconds.Value = input.IsTermStayOne
        ? int.MaxValue
        : input.PeriodSeconds;

    Assert(input.MinerIncreaseInterval > 0, "Miner increase interval must be greater than zero.");  // ADD THIS LINE
    State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;
    // ... rest of initialization
}
```

2. Consider adding defensive checks in the division operations themselves:

```csharp
private int GetAutoIncreasedMinersCount()
{
    if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;
    
    if (State.MinerIncreaseInterval.Value <= 0) return AEDPoSContractConstants.SupposedMinersCount;  // ADD THIS LINE

    return AEDPoSContractConstants.SupposedMinersCount.Add(
        (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
        .Div(State.MinerIncreaseInterval.Value).Mul(2));
}
```

**Testing Requirements:**

1. Add unit test attempting to set `MinerIncreaseInterval` to 0 and verify it fails
2. Add unit test attempting to set `MinerIncreaseInterval` to negative values and verify it fails
3. Add integration test verifying consensus transitions work correctly with various valid interval values
4. Add regression test ensuring the minimum valid value (1) works without causing overflow or unexpected behavior

### Proof of Concept

**Initial State:**
- Blockchain is running with `State.MinerIncreaseInterval.Value = 31536000` (default 1 year)
- Parliament governance is functioning normally
- Consensus is operating with regular round and term transitions

**Attack Steps:**

1. **Obtain Parliament Control**: Attacker gains control of Parliament organization (or compromises enough members to pass a proposal)

2. **Submit Malicious Proposal**: Create and approve a Parliament proposal to call `SetMinerIncreaseInterval` with progressively smaller values:
   - First proposal: `SetMinerIncreaseInterval(15768000)` - reduces to 6 months ✓ passes validation
   - Second proposal: `SetMinerIncreaseInterval(100)` - reduces to 100 seconds ✓ passes validation  
   - Final proposal: `SetMinerIncreaseInterval(0)` - sets to zero ✓ passes validation (0 <= 100)

3. **Trigger Division by Zero**: Wait for next consensus operation:
   - When `ProcessNextRound` executes at line 128, it calls `GetMinersCount(nextRound)`
   - `GetMinersCount` attempts to execute `.Div(State.MinerIncreaseInterval.Value)` at line 390
   - Division by zero exception occurs

**Expected Result:**
- `SetMinerIncreaseInterval(0)` should be rejected with "Miner increase interval must be greater than zero"

**Actual Result:**
- `SetMinerIncreaseInterval(0)` succeeds
- Next consensus round/term transition fails with division by zero
- Blockchain halts permanently

**Success Condition:**
The attack succeeds when `State.MinerIncreaseInterval.Value == 0` and any subsequent call to `GetMinersCount` or `GetAutoIncreasedMinersCount` causes a contract execution failure, preventing consensus progression.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L125-136)
```csharp
            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-177)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/ConsensusOptions.cs (L7-14)
```csharp
public class ConsensusOptions
{
    public List<string> InitialMinerList { get; set; }
    public int MiningInterval { get; set; }
    public Timestamp StartTimestamp { get; set; } = new() { Seconds = 0 };
    public long PeriodSeconds { get; set; } = 604800;
    public long MinerIncreaseInterval { get; set; } = 31536000;
}
```
