### Title
Unbounded Evil Miner Processing Can Cause Resource Exhaustion and Round Transition Failure

### Summary
The `ProcessNextRound()` function processes all detected evil miners without any cap, making a cross-contract call to `ElectionContract.UpdateCandidateInformation` for each one, which in turn calls `ProfitContract.RemoveBeneficiary`. If an attacker causes many miners to miss time slots through network disruption, the excessive resource token consumption from processing numerous evil miners simultaneously could exhaust the consensus contract's resource tokens, causing the round transition transaction to fail and halting consensus.

### Finding Description
The vulnerability exists in the evil miner detection and marking logic within `ProcessNextRound()`: [1](#0-0) 

The `TryToDetectEvilMiners` method returns ALL miners who have accumulated `MissedTimeSlots >= TolerableMissedTimeSlotsCount` (4320 time slots = 3 days) without any limit: [2](#0-1) 

The tolerable count is set to 3 days worth of missed slots: [3](#0-2) 

For each evil miner, `UpdateCandidateInformation` is called in the Election contract, which performs multiple state operations and makes an additional cross-contract call to `RemoveBeneficiary` in the Profit contract: [4](#0-3) [5](#0-4) 

The root cause is the absence of any cap, batching mechanism, or resource check before processing the list of evil miners. While `MaximumMinersCount` can theoretically be set to high values by governance (tests show up to 100, and it grows over time via auto-increase), there is no code-level protection against processing all evil miners in a single transaction. [6](#0-5) 

AElf uses a resource token system (WRITE, READ, STORAGE, TRAFFIC) where contracts must maintain sufficient resource token balances. The `CheckResourceToken` method is called pre-execution and will fail the transaction if the contract has insufficient resources: [7](#0-6) 

### Impact Explanation
If the consensus contract exhausts its resource tokens while processing numerous evil miners, the `ProcessNextRound` transaction will fail during the `CheckResourceToken` pre-execution check. This prevents the round transition from completing, effectively halting the consensus mechanism. 

The severity is high because:
- **Consensus breakdown**: Failed round transitions prevent block production and network progress
- **Network-wide impact**: All users and applications on the chain are affected
- **Requires governance intervention**: Restoring consensus may require emergency governance actions to add resource tokens or modify the maximum miners count

The harm is concrete and quantifiable: complete loss of consensus functionality until the issue is resolved through governance intervention.

### Likelihood Explanation
The attack requires an adversary to cause a significant number of miners (e.g., 50+ out of a potential 100 maximum) to miss time slots continuously for 3 days, allowing them to accumulate `MissedTimeSlots >= 4320`. This could be achieved through:

**Attacker Capabilities Required:**
- Large-scale network disruption (DDoS attacks on miner nodes)
- BGP hijacking or routing attacks affecting miner connectivity
- Compromise of network infrastructure serving multiple miners

**Attack Complexity:**
- **High**: Requires sustained disruption of majority of miners for 3 consecutive days
- **Expensive**: Large-scale DDoS or infrastructure attacks are costly
- **Detectable**: Network disruption affecting many miners would be immediately noticed

**Feasibility Conditions:**
- MaximumMinersCount must be set high enough (50-100+) to cause significant resource consumption
- Consensus contract must not have excessive resource token reserves
- Network infrastructure must be vulnerable to disruption

**Probability Assessment:**
While difficult and expensive to execute, such attacks are not impossible. State-level actors or well-funded adversaries could potentially execute large-scale network disruptions. Historical examples of BGP hijacking and large-scale DDoS attacks demonstrate technical feasibility.

The likelihood is **Medium** due to the high attack complexity and cost, balanced against the severity of impact and the existence of real-world precedents for large-scale network attacks.

### Recommendation
Implement the following mitigations:

1. **Add a per-round cap on evil miner processing**:
   - Process at most N evil miners per round (e.g., 10-20)
   - Track pending evil miners and process them across multiple rounds
   - Add state variable: `State.PendingEvilMiners`

2. **Add resource token check before processing**:
   - Before entering the evil miner loop, estimate required resources
   - If insufficient, defer processing or reduce the batch size
   - Add method: `CheckSufficientResources(int evilMinerCount)`

3. **Implement batched processing**:
   ```
   // Pseudocode
   var maxEvilMinersPerRound = 20;
   var evilMinersToProcess = evilMiners.Take(maxEvilMinersPerRound).ToList();
   var remainingEvilMiners = evilMiners.Skip(maxEvilMinersPerRound).ToList();
   
   foreach (var evilMiner in evilMinersToProcess)
   {
       State.ElectionContract.UpdateCandidateInformation.Send(...);
   }
   
   if (remainingEvilMiners.Any())
   {
       State.PendingEvilMiners.Value = new PendingEvilMinerList { Miners = remainingEvilMiners };
   }
   ```

4. **Add governance control for the batch size**:
   - Make `maxEvilMinersPerRound` configurable via governance
   - Allow emergency adjustment if resource exhaustion is detected

5. **Add comprehensive test coverage**:
   - Test processing of 50+ evil miners simultaneously
   - Test resource consumption under maximum load scenarios
   - Test graceful degradation when resource limits are approached

### Proof of Concept

**Initial State:**
- MaximumMinersCount set to 100 via governance
- 100 active miners in the current round
- Consensus contract has standard resource token allocation

**Attack Sequence:**

1. **Day 0-3**: Attacker launches sustained DDoS attack on 60 miner nodes
   - Prevents these miners from producing blocks
   - Each affected miner accumulates MissedTimeSlots
   - After 3 days: 60 miners have MissedTimeSlots = 4320

2. **Day 3**: A functioning miner calls `ProcessNextRound`
   - `TryToDetectEvilMiners` returns list of 60 evil miners
   - Loop attempts to process all 60 miners
   - Each iteration makes 2 cross-contract calls + multiple state operations
   - Total resource consumption: ~60 Ã— (base cost per miner)

3. **Expected Result**: Round transition completes, evil miners marked

4. **Actual Result**: 
   - `CheckResourceToken` pre-execution check fails
   - Error: "Contract balance of WRITE token is not enough. Owning X"
   - Transaction reverts, round transition fails
   - Consensus halts until governance intervention

**Success Condition**: The `ProcessNextRound` transaction fails due to resource token exhaustion, preventing the round transition and halting consensus. This can be verified by monitoring transaction execution logs and observing the assertion failure in `CheckResourceToken`.

**Notes**

The vulnerability is valid under AElf's resource token consumption model. While requiring significant attacker resources to execute, the lack of code-level protection against processing unbounded numbers of evil miners represents a real consensus DoS risk. The severity is Medium because impact is High (consensus breakdown) but likelihood is Medium (requires sustained, expensive network disruption). The recommended mitigation of batch processing with configurable caps would provide defense-in-depth against this attack vector without compromising the evil miner detection functionality.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L797-807)
```csharp
    private void RemoveBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var previousSubsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            Beneficiary = beneficiaryAddress,
            ProfitDetailId = previousSubsidyId
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L72-95)
```csharp
    public override Int32Value GetMaximumMinersCount(Empty input)
    {
        return new Int32Value
        {
            Value = Math.Min(GetAutoIncreasedMinersCount(), State.MaximumMinersCount.Value)
        };
    }
    
    public override Int64Value GetMinerIncreaseInterval(Empty input)
    {
        return new Int64Value
        {
            Value = State.MinerIncreaseInterval.Value
        };
    }

    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L602-614)
```csharp
    public override Empty CheckResourceToken(Empty input)
    {
        AssertTransactionGeneratedByPlugin();
        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayTxFeeSymbolListName))
        {
            var balance = GetBalance(Context.Sender, symbol);
            var owningBalance = State.OwningResourceToken[Context.Sender][symbol];
            Assert(balance > owningBalance,
                $"Contract balance of {symbol} token is not enough. Owning {owningBalance}.");
        }

        return new Empty();
    }
```
