### Title
Inconsistent Vote Counting After Member Replacement Allows Governance Threshold Bypass

### Summary
The `ChangeMember()` function removes members from the organization without invalidating their existing votes on active proposals. Due to inconsistent vote counting logic, removed members' votes still count toward the `MinimalVoteThreshold` but not toward approval/rejection/abstention thresholds, allowing proposals to pass with fewer current members participating than governance rules require.

### Finding Description

The vulnerability exists in the interaction between the `ChangeMember()` function and the vote threshold checking logic in `IsReleaseThresholdReached()`. [1](#0-0) 

The `ChangeMember()` function removes the old member from `organization.OrganizationMemberList` and adds the new member, but does not invalidate or remove any votes the old member cast on active proposals. The votes remain stored in the proposal's `approvals`, `rejections`, or `abstentions` lists. [2](#0-1) 

When a proposal is checked for release, the system uses different counting methods for different thresholds:

**For approval/rejection/abstention counts (FILTERED by current membership):** [3](#0-2) [4](#0-3) 

These use `.Count(organization.OrganizationMemberList.Contains)` which filters out votes from removed members.

**For total vote count (UNFILTERED):** [5](#0-4) 

This simply concatenates all vote lists and counts them without checking current membership, meaning removed members' votes still count toward `MinimalVoteThreshold`.

This inconsistency violates the governance invariant that a minimum number of **current** members must participate in voting.

### Impact Explanation

**Governance Threshold Bypass:** Proposals can be released with fewer current members participating than required by `MinimalVoteThreshold`. For example:
- Organization requires `MinimalVoteThreshold = 7` (7 members must vote)
- Organization requires `MinimalApprovalThreshold = 5` (5 must approve)
- Scenario: 5 current members approve, 2 former members (now replaced) had voted (abstained)
- Result: Proposal passes because total vote count = 7 (includes removed members), approval count = 5 (only current members)
- **Impact**: Only 5 current members participated, but the 7-vote participation requirement appears satisfied

**Who is affected:** All Association-based governance organizations, particularly those with member rotation policies or those vulnerable to malicious coalitions strategically replacing members after votes are cast.

**Severity:** HIGH - This directly undermines the core governance mechanism by allowing proposals to pass without the required level of current member participation, potentially enabling unauthorized configuration changes or fund movements.

### Likelihood Explanation

**Attacker Capabilities:** Requires governance-level action since `ChangeMember()` can only be called by the organization itself (Context.Sender must be the organization address). [6](#0-5) 

**Attack Complexity:** MEDIUM
1. A coalition of members must control enough votes to pass a `ChangeMember()` proposal
2. Timing: Members must vote on the target proposal before being replaced
3. Coordination: The replacement must occur after voting but before proposal release

**Feasibility:** HIGH
- **Intentional Exploit:** Malicious members with majority control can deliberately manipulate vote counts
- **Unintentional Trigger:** Legitimate member rotation during active proposals can unintentionally trigger this issue
- No special permissions beyond normal governance participation required
- Economic cost is just transaction fees for governance actions

**Detection:** LOW - The inconsistency is not immediately obvious from events or state, making it difficult to detect without careful analysis of vote counting logic.

### Recommendation

**Fix the inconsistency by filtering removed members' votes from the total vote count:**

Modify `CheckEnoughVoteAndApprovals()` in `Association_Helper.cs`:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough = approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter by current membership for total vote count
    var totalVoteCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
                         proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
                         proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    var isVoteThresholdReached = totalVoteCount >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

**Additional safeguard:** Consider adding a check in `ChangeMember()` to prevent member replacement while they have votes on non-expired proposals, or automatically invalidate those votes.

**Test cases:**
1. Create proposal, have members vote, replace voters, verify proposal cannot be released with insufficient current member votes
2. Verify all threshold checks consistently filter by current membership
3. Test edge cases with multiple member replacements

### Proof of Concept

**Initial Setup:**
- Organization with 10 members: A, B, C, D, E, F, G, H, I, J
- `ProposalReleaseThreshold`: MinimalVoteThreshold=7, MinimalApprovalThreshold=5, MaximalRejectionThreshold=3, MaximalAbstentionThreshold=2

**Exploitation Steps:**

1. **Create Proposal P1**: Member A creates a proposal to transfer funds
   - State: `proposal.Approvals = []`, `proposal.Abstentions = []`, `proposal.Rejections = []`

2. **Members Vote**:
   - Members A, B, C, D, E call `Approve(P1)`
   - Members F, G call `Abstain(P1)`
   - State: `proposal.Approvals = [A,B,C,D,E]`, `proposal.Abstentions = [F,G]`
   - Total votes: 7

3. **Replace Members** (via governance proposals):
   - Call `ChangeMember({OldMember: F, NewMember: K})`
   - Call `ChangeMember({OldMember: G, NewMember: L})`
   - State: `organization.OrganizationMemberList = [A,B,C,D,E,H,I,J,K,L]`
   - Proposal votes unchanged: `proposal.Approvals = [A,B,C,D,E]`, `proposal.Abstentions = [F,G]`

4. **Release Proposal**: Member A calls `Release(P1)`

**Threshold Checks in IsReleaseThresholdReached():**
- Rejection check: 0 rejections from current members (0 ≤ 3) ✓
- Abstention check: 0 abstentions from current members (0 ≤ 2) ✓ [F, G filtered out]
- Approval check: 5 approvals from current members (5 ≥ 5) ✓
- **Vote threshold check: 7 total votes including F and G (7 ≥ 7) ✓** [NOT filtered]

**Expected Result:** Proposal should FAIL because only 5 current members voted (< 7 required)

**Actual Result:** Proposal PASSES because removed members F and G are counted in total vote threshold

**Success Condition:** Proposal P1 is released and executed despite only 5 current members participating, violating the MinimalVoteThreshold requirement of 7 members.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L248-264)
```csharp
    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }
```

**File:** protobuf/association_contract.proto (L76-103)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-45)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-52)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-58)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
```
