### Title
Unbounded ReceivedTokenSymbols Growth Enables State Bloat and Iteration DoS on Profit Schemes

### Summary
The `ReceivedTokenSymbols` list in profit schemes has no size limit and can be populated by any user contributing arbitrary token types. When this list grows large (1000+ symbols), operations that iterate over all symbols—such as profit distribution and claiming—will exceed gas limits or become prohibitively expensive, causing operational DoS for legitimate scheme managers and beneficiaries.

### Finding Description

**Root Cause:**

The `ReceivedTokenSymbols` field in the Scheme structure tracks all unique token symbols that have been contributed to a profit scheme. [1](#0-0) 

This list is populated in two locations without any bound check:
1. In `DistributeProfitsForSubSchemes()` when distributing to sub-schemes [2](#0-1) 
2. In `ContributeProfits()` when anyone contributes tokens [3](#0-2) 

**Attack Entry Point:**

The `ContributeProfits()` function has no access control restricting who can contribute tokens to a scheme. [4](#0-3) 

The only validation is that the token must exist, checked via `AssertTokenExists()`. [5](#0-4) 

This means any user can contribute dust amounts (e.g., 1 unit) of any existing token on the chain to any profit scheme, causing that token symbol to be added to `ReceivedTokenSymbols`.

**Why Protections Fail:**

There is no maximum limit enforced on the size of `ReceivedTokenSymbols`. The `TokenAmountLimit` constant in the codebase only applies to method fee configuration, not to this list. [6](#0-5) 

**DoS Vectors:**

When `ReceivedTokenSymbols` contains many entries, operations that iterate over all symbols become prohibitively expensive:

1. **DistributeProfits()**: When `IsReleaseAllBalanceEveryTimeByDefault` is true and no specific amounts are provided, it iterates over ALL symbols and makes external `GetBalance` calls for each. [7](#0-6) 

2. **ProfitAllPeriods()**: When calculating profits for beneficiaries, it iterates over all symbols (or the target symbol if specified). [8](#0-7) 

3. **GetUndistributedDividends() in AEDPoS**: Iterates all symbols to calculate undistributed dividends for the consensus dividend pool. [9](#0-8) 

Each iteration involves external contract calls to the Token contract, which consume significant gas.

### Impact Explanation

**Operational DoS:**
- Scheme managers (e.g., for the consensus dividend pool) become unable to call `DistributeProfits()` if the gas cost of iterating 1000+ symbols exceeds block gas limits
- Beneficiaries may be unable to claim profits or query profit amounts if calculation functions timeout or exceed gas limits
- Critical profit schemes like the consensus dividend pool could become completely non-operational

**State Bloat:**
- Each token symbol added increases the state size of the Scheme object, increasing storage costs over time
- The state bloat is permanent as there is no mechanism to remove symbols from the list

**Affected Parties:**
- Scheme managers who need to distribute profits
- Beneficiaries attempting to claim or calculate their profits
- The protocol's consensus dividend pool if targeted
- Any high-value profit scheme

**Severity Justification:**
The vulnerability is rated **Low severity** primarily due to the cost barrier (attacker must pay transaction fees for each contribution), but the impact on critical schemes like consensus rewards could be significant, potentially warranting Medium severity for those specific cases.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker needs access to multiple token types on the chain (either existing tokens or create new ones)
- Must pay transaction fees for each `ContributeProfits()` call
- Can contribute minimal amounts (1 unit) to reduce token costs

**Attack Complexity:**
- Low technical complexity: simply call `ContributeProfits()` repeatedly with different token symbols
- Can be executed gradually over time to avoid detection
- No special permissions or contract exploitation techniques required

**Feasibility Conditions:**
- More feasible on chains with many existing token types
- Cheaper if attacker already holds various tokens
- Most impactful when targeting schemes with `IsReleaseAllBalanceEveryTimeByDefault = true`

**Economic Rationality:**
- Attack cost: N × (transaction_fee + 1_token_unit) where N is the number of symbols
- For N=1000 symbols, this is economically feasible for a motivated attacker
- Higher value if targeting critical schemes like consensus dividend pools where DoS disrupts network operations

**Detection/Operational Constraints:**
- Attack is detectable through monitoring contribution patterns
- However, contributions are legitimate transactions and difficult to prevent without access control changes
- No automatic cleanup mechanism exists

**Probability Assessment:**
Medium-Low probability. While technically feasible and economically rational for high-value targets, it requires sustained effort and upfront costs. The attack is more likely against critical infrastructure schemes (consensus, treasury) than general profit schemes.

### Recommendation

**Immediate Mitigation:**
1. Add a maximum limit on `ReceivedTokenSymbols` size:
```csharp
const int MaxReceivedTokenSymbolsCount = 50; // or appropriate limit

// In ContributeProfits() before line 716:
if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol))
{
    Assert(scheme.ReceivedTokenSymbols.Count < MaxReceivedTokenSymbolsCount, 
        "Maximum number of token symbols reached for this scheme.");
    scheme.ReceivedTokenSymbols.Add(input.Symbol);
}
```

2. Consider adding access control to `ContributeProfits()` for sensitive schemes, allowing only whitelisted contributors or the scheme manager to contribute new token types.

**Long-term Solutions:**
1. Implement a token symbol removal mechanism that cleans up symbols with zero balance
2. Add a scheme configuration option to restrict which token symbols can be contributed
3. Implement pagination for operations that iterate over `ReceivedTokenSymbols` to prevent single-transaction gas exhaustion
4. Add monitoring and alerting for schemes approaching the symbol limit

**Test Cases:**
1. Test that contribution fails when symbol limit is reached
2. Test that operations succeed with maximum allowed symbols
3. Test gas costs for distribution with various symbol counts
4. Test that legitimate multi-token schemes still function correctly

### Proof of Concept

**Initial State:**
- A profit scheme exists (e.g., scheme_id = X)
- The scheme has `IsReleaseAllBalanceEveryTimeByDefault = true`
- The scheme manager is address M
- Attacker is address A

**Attack Steps:**
1. Attacker identifies or obtains 1000 different token types (T1, T2, T3, ... T1000) on the chain
2. For each token Ti (i = 1 to 1000):
   - Attacker calls `ContributeProfits(scheme_id=X, amount=1, period=0, symbol=Ti)`
   - This adds Ti to `scheme.ReceivedTokenSymbols` if not already present
3. After 1000 contributions, `scheme.ReceivedTokenSymbols.Count == 1000`

**DoS Trigger:**
4. Scheme manager M attempts to call `DistributeProfits(scheme_id=X, period=P, amounts_map={})`
5. Since `amounts_map` is empty and `IsReleaseAllBalanceEveryTimeByDefault = true`, the function iterates all 1000 symbols
6. For each symbol, it calls `State.TokenContract.GetBalance.Call()` - 1000 external contract calls
7. The transaction either:
   - Exceeds block gas limit and fails, OR
   - Consumes excessive gas making it prohibitively expensive

**Expected Result:**
Scheme manager can successfully distribute profits with reasonable gas cost

**Actual Result:**
Transaction fails or requires unreasonable gas, preventing profit distribution and effectively DoSing the scheme

**Success Condition:**
The scheme becomes non-operational for profit distribution when no specific `amounts_map` is provided, forcing the manager to manually specify amounts for each distribution (which may not be feasible for schemes designed to auto-distribute all balances).

### Citations

**File:** protobuf/profit_contract.proto (L159-159)
```text
    repeated string received_token_symbols = 12;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L449-459)
```csharp
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L641-644)
```csharp
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-721)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
        // ReSharper disable once PossibleNullReferenceException
        var virtualAddress = scheme.VirtualAddress;

        if (input.Period == 0)
        {

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = virtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = $"Add {input.Amount} dividends."
            });
        }
        else
        {
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
        }

        // If someone directly use virtual address to do the contribution, won't sense the token symbol he was using.
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);

        State.SchemeInfos[scheme.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L851-853)
```csharp
        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L8-8)
```csharp
    public const int TokenAmountLimit = 5;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L154-158)
```csharp
                scheme.ReceivedTokenSymbols.Select(s => State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = s
                })).ToDictionary(b => b.Symbol, b => b.Balance)
```
