### Title
Missing Null Check in RequiredMethodFeeControllerSet Enables Permanent Fee Governance Deadlock

### Summary
The `RequiredMethodFeeControllerSet()` function in Parliament contract directly accesses `State.DefaultOrganizationAddress.Value` without null validation. If the contract is deployed without proper initialization and any fee-related method is called before manual initialization, the `MethodFeeController` becomes permanently locked with a null owner address, making fee governance impossible to recover.

### Finding Description

The vulnerability exists in the `RequiredMethodFeeControllerSet()` private method: [1](#0-0) 

This function creates a default `AuthorityInfo` by directly reading `State.DefaultOrganizationAddress.Value` (line 68) without checking if it's null. The value is only set during initialization: [2](#0-1) 

The `Initialize` method has no authorization check beyond preventing double-initialization (line 13), meaning anyone can call it if the contract hasn't been initialized yet.

**Attack Sequence:**

1. Parliament contract deployed without calling `Initialize` (due to deployment misconfiguration or system bug)
2. Someone calls `GetMethodFeeController` (a public view method marked with `is_view = true`): [3](#0-2) [4](#0-3) 

3. This triggers `RequiredMethodFeeControllerSet()` which creates `AuthorityInfo { OwnerAddress = null, ContractAddress = Context.Self }`
4. This broken authority is stored in `State.MethodFeeController.Value`
5. All subsequent fee operations fail because they check `Context.Sender == null`: [5](#0-4) [6](#0-5) 

6. Even if `Initialize` is called later, it cannot fix the issue because `RequiredMethodFeeControllerSet` returns early when `MethodFeeController` is already set (line 64)

**Why Existing Protections Fail:**

Other contracts like Association properly call `GetDefaultOrganizationAddress` on Parliament, which has an assertion check: [7](#0-6) [8](#0-7) 

However, Parliament's own `RequiredMethodFeeControllerSet` bypasses this protection by directly accessing the state variable.

### Impact Explanation

**Complete Loss of Fee Governance:**
- No one can call `SetMethodFee` to configure transaction fees for Parliament contract methods
- No one can call `ChangeMethodFeeController` to update the fee authority
- The comparison `Context.Sender == null` always fails since transaction senders cannot be null [9](#0-8) 

**Permanent State:**
Once the deadlock is triggered, it cannot be recovered. The `Initialize` method can only be called once, and calling it afterwards won't reset the `MethodFeeController` due to the early return check.

**Affected Parties:**
- Chain governance loses control over Parliament contract transaction fees
- Protocol cannot adjust fee economics for governance operations
- System administrators cannot correct the configuration

### Likelihood Explanation

**Attacker Capabilities Required:**
This vulnerability requires a deployment scenario where Parliament contract is deployed without the initialization list being executed. This would occur through:
- Deployment orchestration bug or misconfiguration by chain operators
- Future system modifications that bypass standard initialization
- Manual redeployment without proper initialization calls

**Execution Complexity:**
Once the misconfigured state exists, triggering the deadlock is trivial - any call to `GetMethodFeeController` (a public view method) locks the state permanently.

**Feasibility Assessment:**
In normal production Genesis deployment, `ParliamentContractInitializationProvider` always includes the `Initialize` call: [10](#0-9) 

If the inline initialization call fails, the entire deployment transaction fails and reverts: [11](#0-10) 

**Probability:**
LOW in standard deployments, but represents a critical defensive programming failure. The vulnerability is latent and would activate under any non-standard deployment scenario.

### Recommendation

**Immediate Fix:**
Add null validation in `RequiredMethodFeeControllerSet()`:

```csharp
private void RequiredMethodFeeControllerSet()
{
    if (State.MethodFeeController.Value != null) return;
    
    // Add null check for DefaultOrganizationAddress
    Assert(State.DefaultOrganizationAddress.Value != null, 
        "Parliament contract not initialized.");

    var defaultAuthority = new AuthorityInfo
    {
        OwnerAddress = State.DefaultOrganizationAddress.Value,
        ContractAddress = Context.Self
    };

    State.MethodFeeController.Value = defaultAuthority;
}
```

**Additional Safeguards:**
1. Add assertion in `Initialize` to ensure it's only callable during deployment phase
2. Add explicit initialization status check at the start of all fee-related methods
3. Consider making `Initialize` callable only by Genesis contract

**Test Cases:**
1. Attempt to call `GetMethodFeeController` before initialization - should fail with clear error
2. Verify `SetMethodFee` and `ChangeMethodFeeController` fail gracefully if called on uninitialized contract
3. Ensure initialization cannot be bypassed in any deployment scenario

### Proof of Concept

**Required Initial State:**
- Parliament contract deployed to blockchain
- `State.Initialized.Value = false`
- `State.DefaultOrganizationAddress.Value = null`
- `State.MethodFeeController.Value = null`

**Transaction Steps:**
1. **Deploy Parliament contract** without calling `Initialize` (simulated deployment bug)
2. **Call `GetMethodFeeController()`** (anyone can call this public view method)
   - Expected: Should fail with "Parliament contract not initialized"
   - Actual: Returns `AuthorityInfo { OwnerAddress = null, ContractAddress = <parliament_address> }`
   - State: `MethodFeeController.Value` now locked with null owner

3. **Attempt to call `SetMethodFee`** with any valid input
   - Expected: Should succeed if authorized
   - Actual: Fails with "Unauthorized to set method fee" because `Context.Sender == null` is always false

4. **Attempt to call `ChangeMethodFeeController`** with valid authority
   - Expected: Should succeed if authorized
   - Actual: Fails with "Unauthorized behavior" because `Context.Sender == null` is always false

5. **Attempt recovery by calling `Initialize`**
   - Expected: Should fix the MethodFeeController
   - Actual: Sets `DefaultOrganizationAddress` but MethodFeeController remains locked (early return at line 64)

**Success Condition:**
Fee governance is permanently deadlocked - no address can satisfy the `Context.Sender == null` authorization check, making fee control impossible forever.

### Citations

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L46-50)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L62-73)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.DefaultOrganizationAddress.Value,
            ContractAddress = Context.Self
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L11-37)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        var proposerWhiteList = new ProposerWhiteList();

        if (input.PrivilegedProposer != null)
            proposerWhiteList.Proposers.Add(input.PrivilegedProposer);

        State.ProposerWhiteList.Value = proposerWhiteList;
        var organizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = DefaultOrganizationMinimalApprovalThreshold,
                MinimalVoteThreshold = DefaultOrganizationMinimalVoteThresholdThreshold,
                MaximalAbstentionThreshold = DefaultOrganizationMaximalAbstentionThreshold,
                MaximalRejectionThreshold = DefaultOrganizationMaximalRejectionThreshold
            },
            ProposerAuthorityRequired = input.ProposerAuthorityRequired,
            ParliamentMemberProposingAllowed = true
        };
        var defaultOrganizationAddress = CreateNewOrganization(organizationInput);
        State.DefaultOrganizationAddress.Value = defaultOrganizationAddress;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L250-254)
```csharp
    public override Address GetDefaultOrganizationAddress(Empty input)
    {
        Assert(State.Initialized.Value, "Not initialized.");
        return State.DefaultOrganizationAddress.Value;
    }
```

**File:** protobuf/acs1.proto (L34-37)
```text
    // Query the method fee controller.
    rpc GetMethodFeeController (google.protobuf.Empty) returns (AuthorityInfo) {
        option (aelf.is_view) = true;
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L49-63)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** src/AElf.Types/Types/Address.cs (L96-99)
```csharp
        public static bool operator ==(Address address1, Address address2)
        {
            return address1?.Equals(address2) ?? ReferenceEquals(address2, null);
        }
```

**File:** src/AElf.GovernmentSystem/ParliamentContractInitializationProvider.cs (L24-39)
```csharp
    public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        var initializationData = _parliamentContractInitializationDataProvider.GetContractInitializationData();
        return new List<ContractInitializationMethodCall>
        {
            new()
            {
                MethodName = nameof(ParliamentContractContainer.ParliamentContractStub.Initialize),
                Params = new InitializeInput
                {
                    PrivilegedProposer = initializationData.PrivilegedProposer,
                    ProposerAuthorityRequired = initializationData.ProposerAuthorityRequired
                }.ToByteString()
            }
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L102-120)
```csharp
    public override Address DeploySystemSmartContract(SystemContractDeploymentInput input)
    {
        Assert(!State.Initialized.Value || !State.ContractDeploymentAuthorityRequired.Value,
            "System contract deployment failed.");
        RequireSenderAuthority();
        var name = input.Name;
        var category = input.Category;
        var code = input.Code.ToByteArray();
        var transactionMethodCallList = input.TransactionMethodCallList;

        // Context.Sender should be identical to Genesis contract address before initialization in production
        var address = DeploySmartContract(name, category, code, true, Context.Sender, false);

        if (transactionMethodCallList != null)
            foreach (var methodCall in transactionMethodCallList.Value)
                Context.SendInline(address, methodCall.MethodName, methodCall.Params);

        return address;
    }
```
