### Title
Missing Contract Address Validation Allows Malicious Authorization Controller Substitution

### Summary
The `ChangeContractDeploymentController` function fails to validate that the new controller's contract address is a legitimate system authorization contract (Parliament, Association, or Referendum). An attacker who controls the current governance organization can replace the controller with a malicious contract that bypasses all proposer whitelist validations, enabling unauthorized contract deployments with arbitrary authors.

### Finding Description

The vulnerability exists in the controller change mechanism. When `ChangeContractDeploymentController` is called, it only validates that the sender is the current owner and that the organization "exists" by calling the provided contract address itself. [1](#0-0) 

The validation uses `CheckOrganizationExist`, which makes a cross-contract call to the **attacker-provided** contract address to validate the organization: [2](#0-1) 

This creates a circular validation where the malicious contract validates itself. There is no check that `input.ContractAddress` is one of the legitimate system contracts (Parliament, Association, or Referendum).

Once a malicious controller is set, the `DecideNonSystemContractAuthor` function relies on it to validate proposers: [3](#0-2) 

The function calls `ValidateProposerAuthority` on the controller contract: [4](#0-3) 

A malicious controller implementing the ACS3 interface can return `true` for all proposers, bypassing whitelist restrictions entirely.

Test evidence shows controllers can be changed to different contract addresses without validation: [5](#0-4) 

### Impact Explanation

**Auth/Governance Impact**: This vulnerability enables complete governance bypass and privilege escalation:

1. **Unauthorized Contract Authorship**: Any user can deploy contracts with themselves as author, gaining update rights to those contracts
2. **Governance Circumvention**: All proposal and voting mechanisms can be bypassed since the malicious controller approves all actions
3. **Persistent Compromise**: Unlike a temporary parliament compromise, this replaces the security mechanism itself, making reversal difficult if the malicious contract blocks controller changes
4. **Code Check Bypass**: The same technique can compromise `CodeCheckController`, eliminating all code review requirements

**Who is affected**: The entire protocol governance and all contract deployment security is compromised. Any contract deployed through this mechanism could be malicious, affecting all protocol users.

**Severity Justification**: HIGH - While requiring initial governance control, this transforms a governable situation into an ungovernable one, permanently escalating privileges beyond normal governance powers and enabling individual attackers to bypass all security checks.

### Likelihood Explanation

**Attacker Capabilities**: Requires control over the current `ContractDeploymentController.OwnerAddress` (initially a Parliament organization). This could occur through:
- Governance attack (51% validator compromise)
- Successful malicious proposal in a misconfigured organization
- Social engineering of organization members

**Attack Complexity**: LOW once governance control is achieved:
1. Deploy malicious ACS3-compliant contract (~100 lines implementing always-true validations)
2. Create governance proposal to call `ChangeContractDeploymentController` with malicious contract address
3. Approve and release proposal through current governance
4. Repeat for `CodeCheckController` if needed

**Feasibility Conditions**: All steps are executable under normal AElf contract semantics. The malicious contract just needs to implement the ACS3 interface methods to return favorable results.

**Economic Rationality**: For an attacker who has already gained governance control (high cost), this provides persistent elevated privileges at minimal additional cost (one contract deployment + proposal fees).

**Detection Constraints**: The controller change would be visible on-chain, but by the time it's detected, the damage is done if the malicious controller prevents reversal.

### Recommendation

**Code-Level Mitigation**:

1. Add a whitelist of legitimate authorization contract addresses in the Genesis contract state:
   ```
   public SingletonState<AddressList> AuthorizedGovernanceContracts { get; set; }
   ```

2. Modify `ChangeContractDeploymentController` to validate the contract address:
   ```csharp
   public override Empty ChangeContractDeploymentController(AuthorityInfo input)
   {
       AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
       
       // NEW: Validate contract address is authorized
       var authorizedContracts = State.AuthorizedGovernanceContracts.Value;
       Assert(
           authorizedContracts.Value.Contains(input.ContractAddress),
           "Contract address must be an authorized governance contract (Parliament/Association/Referendum)."
       );
       
       var organizationExist = CheckOrganizationExist(input);
       Assert(organizationExist, "Invalid authority input.");
       State.ContractDeploymentController.Value = input;
       return new Empty();
   }
   ```

3. Initialize the whitelist during Genesis deployment with Parliament, Association, and Referendum addresses.

4. Apply the same validation to `ChangeCodeCheckController`.

**Test Cases**: Add regression tests that attempt to set arbitrary contract addresses as controllers and verify they are rejected.

### Proof of Concept

**Initial State**:
- Genesis contract initialized with Parliament as `ContractDeploymentController`
- Attacker controls Parliament organization (through voting or compromise)

**Attack Steps**:

1. **Deploy Malicious Controller Contract**:
   ```
   MaliciousController.ValidateOrganizationExist(address) → always returns BoolValue{Value: true}
   MaliciousController.ValidateProposerInWhiteList(input) → always returns BoolValue{Value: true}
   ```

2. **Create Governance Proposal**:
   - Method: `ChangeContractDeploymentController`
   - Parameter: `AuthorityInfo { ContractAddress: MaliciousController, OwnerAddress: AttackerAddress }`
   - Organization: Current Parliament

3. **Approve and Release Proposal** through Parliament voting

4. **Verify Controller Changed**:
   - Call `GetContractDeploymentController()` → returns malicious controller

5. **Exploit: Deploy Arbitrary Contract**:
   - Any user calls `ProposeNewContract` with malicious code
   - Malicious controller approves proposal (returns true for all validations)
   - Contract deploys with attacker as author
   - Attacker gains update rights to deployed contract

**Expected Result**: Proposal should fail with "Contract address must be authorized governance contract"

**Actual Result**: Proposal succeeds, malicious controller is installed, all governance checks are bypassed.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L366-373)
```csharp
    public override Empty ChangeContractDeploymentController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.ContractDeploymentController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L246-255)
```csharp
    private bool ValidateProposerAuthority(Address contractAddress, Address organizationAddress, Address proposer)
    {
        return Context.Call<BoolValue>(contractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateProposerInWhiteList),
            new ValidateProposerInWhiteListInput
            {
                OrganizationAddress = organizationAddress,
                Proposer = proposer
            }).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L860-876)
```csharp
            });

        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.ReturnValue);

        var contractDeploymentController = await GetContractDeploymentController(Tester, BasicContractZeroAddress);
        const string proposalCreationMethodName =
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ChangeContractDeploymentController);
        var proposalId = await CreateProposalAsync(Tester, contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposalCreationMethodName,
            new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = AssociationContractAddress
            });
        await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
        var txResult2 = await ReleaseProposalAsync(Tester, ParliamentAddress, proposalId);
        txResult2.Status.ShouldBe(TransactionResultStatus.Mined);
```
