### Title
Profit Scheme Permanent Lock via Zero Address Manager

### Summary
The Profit contract's `CreateScheme` and `ResetManager` methods fail to validate that the manager address is not a zero address (32 bytes of zeros). This allows profit schemes to be created or transferred with a zero address manager, permanently locking all management operations since no transaction can originate from a zero address.

### Finding Description

The vulnerability exists in two locations:

**Location 1: CreateScheme method** [1](#0-0) 

The manager address is set without validation. If `input.Manager` is provided as a zero address (not null, but 32 bytes of zeros), it bypasses the null-coalescing operator and is accepted without any validation checks.

**Location 2: ResetManager method** [2](#0-1) 

The validation uses `Value.Any()` which only checks if the ByteString has at least one byte. A zero address with 32 bytes of zeros passes this check, while only an empty address fails.

**Root Cause:**
The codebase standard for address validation is: [3](#0-2) 

However, the Profit contract does not apply this validation pattern to manager addresses. The `IsNullOrEmpty()` extension method would correctly reject zero addresses: [4](#0-3) 

**Why Protections Fail:**
All manager-only operations check `Context.Sender == scheme.Manager`: [5](#0-4) [6](#0-5) [7](#0-6) [8](#0-7) 

Since transactions cannot originate from a zero address (Context.Sender can never be a zero address), these checks permanently fail, locking the scheme.

### Impact Explanation

**Operational Impact - Denial of Service:**
- All scheme management operations become permanently inaccessible: `AddBeneficiary`, `RemoveBeneficiary`, `AddSubScheme`, `RemoveSubScheme`, `DistributeProfits`, and `ResetManager`
- Existing beneficiaries cannot be modified or removed
- New beneficiaries cannot be added
- Profits cannot be distributed to beneficiaries
- The scheme cannot be fixed by transferring management (ResetManager also requires manager authorization)

**Affected Parties:**
- Scheme creators who accidentally or maliciously set zero address managers lose all control
- Existing beneficiaries have frozen profit details
- Contributors to the scheme have their funds effectively locked (no distribution possible)
- System contracts (Treasury, TokenHolder) relying on specific schemes could be disrupted if their schemes are transferred to zero addresses

**Severity Justification:**
High severity due to permanent, irrecoverable loss of scheme functionality and potential economic impact on locked funds.

### Likelihood Explanation

**Reachable Entry Points:**
Both `CreateScheme` and `ResetManager` are public methods callable by any address.

**Attacker Capabilities:**
- Minimal: Construct an Address using `Address.FromBytes(new byte[32])` to create a zero address
- No special permissions required for CreateScheme
- ResetManager requires being the current manager

**Attack Complexity:**
Low - single transaction with deliberately crafted zero address parameter.

**Feasibility Conditions:**
- **CreateScheme**: Any user can create a DoS'd scheme (griefing attack)
- **ResetManager**: A malicious or compromised manager can permanently lock an existing scheme with beneficiaries and funds

**Economic Rationality:**
- CreateScheme scenario: Low rationality (griefing only, no direct benefit)
- ResetManager scenario: Medium rationality (malicious manager could lock scheme to prevent profit distribution, or accidental misconfiguration)

**Detection:**
The test suite already checks for empty addresses but not zero addresses: [9](#0-8) 

### Recommendation

**Code-Level Mitigation:**

1. **For CreateScheme**, add manager address validation after line 57:
```csharp
var manager = input.Manager ?? Context.Sender;
Assert(manager != null && !manager.Value.IsNullOrEmpty(), "Invalid manager address.");
```

2. **For ResetManager**, replace the validation at line 730:
```csharp
Assert(input.NewManager != null && !input.NewManager.Value.IsNullOrEmpty(), "Invalid new sponsor.");
```

**Invariant Check:**
Ensure all address parameters that represent ownership/control are validated using the standard `AssertValidInputAddress` pattern used throughout the codebase.

**Test Cases:**
Add test cases verifying rejection of zero addresses (32 bytes of zeros) in both `CreateScheme` and `ResetManager`:
```csharp
var zeroAddress = Address.FromBytes(new byte[32]);
// Test CreateScheme with zero address manager
// Test ResetManager with zero address new manager
// Verify both fail with appropriate error message
```

### Proof of Concept

**Required Initial State:**
- Deployed Profit contract
- User account with sufficient balance for transaction fees

**Attack Sequence - CreateScheme:**

1. Construct zero address: `var zeroAddress = Address.FromBytes(new byte[32])`
2. Call CreateScheme:
```
CreateSchemeInput {
    Manager = zeroAddress,
    ProfitReceivingDuePeriodCount = 10
}
```
3. Transaction succeeds, scheme created with zero address manager
4. Attempt any manager operation (AddBeneficiary, etc.) - all fail with "Only manager can..." error

**Attack Sequence - ResetManager:**

1. Create legitimate scheme (manager = attacker)
2. Add beneficiaries and contribute profits
3. Call ResetManager with `NewManager = Address.FromBytes(new byte[32])`
4. Transaction succeeds due to `.Any()` check passing
5. All subsequent management operations permanently fail

**Expected vs Actual Result:**
- **Expected**: Both transactions should fail with "Invalid manager address" or "Invalid new sponsor"
- **Actual**: Transactions succeed, creating permanently locked schemes

**Success Condition:**
Scheme exists in `State.SchemeInfos` with manager = zero address, and `State.ManagingSchemeIds[zeroAddress]` contains the scheme ID, but no operations can be performed on it.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L57-57)
```csharp
        var manager = input.Manager ?? Context.Sender;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L99-99)
```csharp
        Assert(Context.Sender == scheme.Manager, "Only manager can add sub-scheme.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L172-174)
```csharp
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L426-428)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L729-729)
```csharp
        Assert(Context.Sender == scheme.Manager, "Only scheme manager can reset manager.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L730-730)
```csharp
        Assert(input.NewManager.Value.Any(), "Invalid new sponsor.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L34-37)
```csharp
        public static bool IsNullOrEmpty(this ByteString byteString)
        {
            return byteString == null || byteString.IsEmpty;
        }
```

**File:** test/AElf.Contracts.Profit.Tests/ProfitTests.cs (L1526-1531)
```csharp
        resetRet = await creator.ResetManager.SendWithExceptionAsync(new ResetManagerInput
        {
            NewManager = new Address(),
            SchemeId = schemeId
        });
        resetRet.TransactionResult.Error.ShouldContain("Invalid new sponsor.");
```
