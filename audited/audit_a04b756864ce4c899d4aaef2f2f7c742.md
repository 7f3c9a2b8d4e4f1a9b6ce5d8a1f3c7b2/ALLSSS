### Title
Governance Bypass via Malicious Contract in MethodFeeController Validation

### Summary
The `ChangeMethodFeeController` function validates organization existence by calling `ValidateOrganizationExist` on the user-provided `ContractAddress` without verifying it's a legitimate governance contract (Parliament/Association/Referendum). An attacker can deploy a malicious contract that always returns true, then use a Parliament proposal to set this as the controller, bypassing governance checks and enabling unauthorized method fee manipulation.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist` function which performs organization validation: [1](#0-0) 

The function accepts an `AuthorityInfo` parameter containing a `ContractAddress` field and directly calls `ValidateOrganizationExist` on it via `Context.Call`. The critical flaw is that **no validation ensures the `ContractAddress` is a legitimate system governance contract** (Parliament, Association, or Referendum). [2](#0-1) 

The `ChangeMethodFeeController` function only checks that the sender is the current controller owner (line 24) and that `CheckOrganizationExist` returns true (line 26). It does not validate the contract address itself.

Legitimate governance contracts implement `ValidateOrganizationExist` by checking if the organization exists in their state: [3](#0-2) [4](#0-3) 

However, an attacker can deploy a malicious contract that implements the same method signature but always returns true, bypassing this check entirely. The AElf contract deployment mechanism allows user contract deployment (depending on chain configuration), and `Context.Call` will execute methods on any deployed contract address without additional validation.

### Impact Explanation

**Governance Bypass**: Once the malicious controller is set, all future method fee changes require approval from the fake organization structure. If the malicious contract has no real governance checks or is controlled by a single address, the attacker can:
- Unilaterally modify transaction fees for all Election contract methods
- Set prohibitively high fees to DoS specific operations
- Set zero fees to eliminate economic barriers on sensitive operations
- Extract value by manipulating fee economics

**Affected Parties**: All Election contract users and the broader AElf ecosystem, as this pattern is replicated across multiple system contracts: [5](#0-4) [6](#0-5) 

**Severity**: Critical - This undermines the core governance model requiring 2/3 miner consensus for sensitive operations, replacing it with attacker-controlled logic.

### Likelihood Explanation

**Attacker Capabilities Required**:
1. Deploy a malicious contract (feasible on most AElf networks)
2. Create a Parliament proposal with the malicious contract address
3. Achieve 2/3 miner approval (social engineering component)

**Execution Practicality**: The technical steps are straightforward:
- Deploy contract with `ValidateOrganizationExist(Address) returns (BoolValue)` that returns `{Value: true}`
- Submit Parliament proposal calling `ChangeMethodFeeController` with malicious `ContractAddress`
- Miners may not carefully inspect contract addresses in proposals, especially if disguised as legitimate governance restructuring

**Detection Constraints**: The malicious contract address appears as a regular address in proposals. Without deep inspection of the contract code at that address, validators cannot distinguish it from legitimate governance contracts.

**Probability**: Medium-High - Requires social engineering but technically simple, and the same vulnerability pattern exists across 10+ system contracts, amplifying attack surface.

### Recommendation

**Immediate Fix**: Add validation that the `ContractAddress` is a known system governance contract:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a legitimate governance contract
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid governance contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Apply Consistently**: Update the same pattern in all contracts using `CheckOrganizationExist`:
- MultiToken, Profit, Treasury, TokenHolder, TokenConverter, Vote, Configuration, Consensus, CrossChain, Economic, Referendum, Genesis contracts

**Test Cases**: Add regression tests verifying:
1. `ChangeMethodFeeController` rejects non-system contract addresses
2. Only Parliament/Association/Referendum addresses pass validation
3. Malicious contract deployment and usage attempts fail with clear error messages

### Proof of Concept

**Step 1**: Deploy malicious contract with code:
```csharp
public class MaliciousGovernance : ContractBase
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```

**Step 2**: Create Parliament proposal to call:
```
ElectionContract.ChangeMethodFeeController({
    ContractAddress: <malicious_contract_address>,
    OwnerAddress: <attacker_controlled_address>
})
```

**Step 3**: If miners approve without inspecting the contract address, proposal releases

**Expected Result**: Transaction should fail with "Invalid governance contract address"

**Actual Result**: Transaction succeeds, `State.MethodFeeController.Value` now points to malicious contract

**Success Condition**: Attacker can now submit proposals through their fake organization to change method fees without legitimate 2/3 miner consensus

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L67-72)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```
