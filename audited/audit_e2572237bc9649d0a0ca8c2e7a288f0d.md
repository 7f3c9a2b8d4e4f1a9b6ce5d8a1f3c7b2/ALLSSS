### Title
Weak Encryption in Secret Sharing Allows Potential InValue Recovery Through Ciphertext Analysis

### Summary
The AEDPoS consensus mechanism encrypts secret shares using AES-CBC with a static zero-filled initialization vector (IV) and deterministic ECDH-derived keys. This cryptographic weakness violates semantic security principles and enables pattern analysis attacks on publicly stored encrypted pieces, potentially allowing attackers to deduce information about miners' InValues and compromise random number generation.

### Finding Description

**Root Cause Location:**

The vulnerability exists in the encryption implementation at: [1](#0-0) 

The `EncryptMessage` function uses AES-CBC mode with a **static zero-filled IV** (`new byte[16]`) on line 147. The encryption key is derived from ECDH key agreement: [2](#0-1) 

**Execution Path:**

1. During consensus, miners generate secret shares of their InValues via Shamir's Secret Sharing: [3](#0-2) 

2. Each share is encrypted for recipient miners using the weak encryption at line 114. The encrypted pieces are then included in the consensus update: [4](#0-3) 

3. These encrypted pieces are stored **publicly on-chain** in the MinerInRound structure: [5](#0-4) [6](#0-5) 

**Why Protections Fail:**

1. **Deterministic Encryption**: Since miner keypairs are static, the ECDH shared secret between any sender-receiver pair remains constant across all rounds. Combined with the zero IV, encrypting the same plaintext always produces identical ciphertext, violating IND-CPA security.

2. **Pattern Leakage**: While Shamir's Secret Sharing uses random polynomial coefficients: [7](#0-6) 

The deterministic encryption still allows attackers to:
   - Identify when identical share values occur (same ciphertext)
   - Perform frequency analysis across many rounds
   - Learn statistical properties of the secret distribution
   - Potentially narrow down the InValue space through pattern correlation

3. **Public Data Exposure**: All encrypted pieces are stored on-chain and readable by anyone without any authentication.

### Impact Explanation

**Concrete Harm:**
- **Consensus Integrity Compromise**: InValues are used to generate random numbers for consensus operations. If an attacker can predict or partially recover InValues, they can:
  - Anticipate future miner ordering decisions
  - Potentially manipulate validator selection in edge cases
  - Undermine the verifiable randomness that secures consensus fairness

- **Long-term Vulnerability**: The same ECDH keys are used indefinitely. As more encrypted samples accumulate over time, statistical attacks become increasingly effective.

- **Cryptographic Standard Violation**: The implementation violates fundamental cryptographic principles (semantic security), making the system vulnerable to well-documented attacks.

**Affected Parties:**
- All consensus participants (miners)
- Network security and decentralization guarantees
- Any protocol features depending on unpredictable random number generation

**Severity Justification:** HIGH - While exploitation requires sophisticated cryptanalysis, the flaw fundamentally weakens the consensus security model and accumulates risk over time.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to read blockchain data (public, no special access)
- Cryptanalysis expertise for pattern analysis
- Computational resources to collect and analyze many rounds of data

**Attack Complexity:**
- **Collection Phase**: Low - encrypted pieces are publicly stored on-chain
- **Analysis Phase**: Medium-High - requires statistical cryptanalysis but the techniques are well-established in academic literature
- **No Authentication Barrier**: Any observer can collect the necessary data

**Feasibility Conditions:**
- The vulnerability is always present and exploitable
- Effectiveness increases with sample size (more rounds observed)
- No detection mechanism exists as the attack is passive observation

**Probability Assessment:**
Given the public availability of data, the well-known weaknesses of static IV usage in CBC mode, and the long-term accumulation of samples, this vulnerability has a **Medium-High likelihood** of exploitation by sophisticated adversaries with sufficient motivation and resources.

### Recommendation

**Immediate Fix:**

1. **Replace Zero IV with Random IV**: Modify the encryption to generate a cryptographically secure random IV for each encryption operation:

```csharp
public static byte[] EncryptMessage(byte[] senderPrivateKey, byte[] receiverPublicKey, byte[] plainText)
{
    var keyBytes = GetSharedSecret(senderPrivateKey, receiverPublicKey);
    
    // Generate random IV
    var iv = new byte[16];
    using (var rng = RandomNumberGenerator.Create())
    {
        rng.GetBytes(iv);
    }
    
    var cipher = new PaddedBufferedBlockCipher(new CbcBlockCipher(new AesEngine()));
    cipher.Init(true, new ParametersWithIV(new KeyParameter(keyBytes), iv));
    
    var cipherText = new byte[cipher.GetOutputSize(plainText.Length)];
    var len = cipher.ProcessBytes(plainText, 0, plainText.Length, cipherText, 0);
    cipher.DoFinal(cipherText, len);
    
    // Prepend IV to ciphertext for transmission
    var result = new byte[iv.Length + cipherText.Length];
    Buffer.BlockCopy(iv, 0, result, 0, iv.Length);
    Buffer.BlockCopy(cipherText, 0, result, iv.Length, cipherText.Length);
    
    return result;
}
```

2. **Update DecryptMessage** to extract and use the IV from the ciphertext prefix.

3. **Alternative: Use Authenticated Encryption**: Consider migrating to AES-GCM which provides both confidentiality and authenticity, eliminating CBC mode vulnerabilities entirely.

**Invariant Checks:**
- Add unit tests verifying that encrypting the same plaintext twice produces different ciphertexts
- Add integration tests ensuring IV randomness across multiple encryption operations
- Implement runtime assertions checking IV uniqueness in debug builds

**Migration Path:**
- Deploy the fix in a protocol upgrade
- Since this changes the ciphertext format, implement versioning in the encryption/decryption layer
- Consider a transition period where both old and new formats are accepted

### Proof of Concept

**Initial State:**
- Network has multiple active miners with static keypairs
- Consensus rounds are progressing normally
- Encrypted pieces are being stored on-chain each round

**Attack Steps:**

1. **Data Collection Phase:**
   - Attacker monitors the blockchain and collects all `encrypted_pieces` from `MinerInRound` structures across many rounds (e.g., 1000+ rounds)
   - For each sender-receiver pair, builds a database of observed ciphertexts

2. **Pattern Analysis Phase:**
   - For a specific sender-receiver pair (e.g., Miner A â†’ Miner B):
     - Identifies all ciphertexts encrypted with their shared key
     - Detects identical ciphertexts (indicating identical plaintexts)
     - Performs frequency analysis on ciphertext distributions
     - Correlates patterns across different rounds

3. **Statistical Attack:**
   - Given the deterministic nature, if the same secret share value appears in multiple rounds (statistically possible over many samples), the ciphertext will be identical
   - Uses frequency analysis and known properties of Shamir's Secret Sharing to narrow the search space
   - Potentially deduces information about the InValue distribution

**Expected Result:**
- Attacker gains non-trivial information about secret shares
- Statistical properties of InValues become partially predictable

**Actual Result:**
- Due to zero IV and deterministic keys, identical plaintexts produce identical ciphertexts, enabling the pattern analysis attack
- Over sufficient samples, the attacker can build a probabilistic model of the secret distribution

**Success Condition:**
- Attacker successfully identifies patterns or recovers partial information about InValues without possessing the decryption keys
- This compromises the security assumptions of the consensus random number generation

### Citations

**File:** src/AElf.Cryptography/CryptoHelper.cs (L142-154)
```csharp
        public static byte[] EncryptMessage(byte[] senderPrivateKey, byte[] receiverPublicKey, byte[] plainText)
        {
            var keyBytes = GetSharedSecret(senderPrivateKey, receiverPublicKey);

            var cipher = new PaddedBufferedBlockCipher(new CbcBlockCipher(new AesEngine()));
            cipher.Init(true, new ParametersWithIV(new KeyParameter(keyBytes), new byte[16]));

            var cipherText = new byte[cipher.GetOutputSize(plainText.Length)];
            var len = cipher.ProcessBytes(plainText, 0, plainText.Length, cipherText, 0);
            cipher.DoFinal(cipherText, len);

            return cipherText;
        }
```

**File:** src/AElf.Cryptography/CryptoHelper.cs (L174-192)
```csharp
        private static byte[] GetSharedSecret(byte[] privateKey, byte[] publicKey)
        {
            var curve = ECParameters.Curve;
            var domainParams = ECParameters.DomainParams;
            var privateKeyParams = new ECPrivateKeyParameters(new BigInteger(1, privateKey), domainParams);
            var publicKeyParams = new ECPublicKeyParameters(curve.Curve.DecodePoint(publicKey), domainParams);

            var agreement = AgreementUtilities.GetBasicAgreement("ECDH");
            agreement.Init(privateKeyParams);
            var secret = agreement.CalculateAgreement(publicKeyParams);

            var kdf = new Kdf2BytesGenerator(new Sha256Digest());
            kdf.Init(new KdfParameters(secret.ToByteArray(), null));

            var keyBytes = new byte[32];
            kdf.GenerateBytes(keyBytes, 0, keyBytes.Length);

            return keyBytes;
        }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L95-142)
```csharp
    private async Task CollectPiecesWithSecretSharingAsync(SecretSharingInformation secretSharingInformation,
        Hash newInValue, string selfPubkey)
    {
        var encryptedPieces = new Dictionary<string, byte[]>();
        var decryptedPieces = new Dictionary<string, byte[]>();

        var minersCount = secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        var secretShares =
            SecretSharingHelper.EncodeSecret(newInValue.ToByteArray(), minimumCount, minersCount);

        foreach (var pair in secretSharingInformation.PreviousRound.RealTimeMinersInformation
                     .OrderBy(m => m.Value.Order).ToDictionary(m => m.Key, m => m.Value.Order))
        {
            var pubkey = pair.Key;
            var order = pair.Value;

            var plainMessage = secretShares[order - 1];
            var receiverPublicKey = ByteArrayHelper.HexStringToByteArray(pubkey);
            var encryptedPiece = await _accountService.EncryptMessageAsync(receiverPublicKey, plainMessage);
            encryptedPieces[pubkey] = encryptedPiece;
            if (secretSharingInformation.PreviousRound.RealTimeMinersInformation.ContainsKey(selfPubkey) &&
                secretSharingInformation.PreviousRound.RealTimeMinersInformation[selfPubkey].EncryptedPieces
                    .ContainsKey(pubkey))
                secretSharingInformation.PreviousRound.RealTimeMinersInformation[selfPubkey]
                        .EncryptedPieces[pubkey]
                    = ByteString.CopyFrom(encryptedPiece);
            else
                continue;

            if (!secretSharingInformation.PreviousRound.RealTimeMinersInformation.ContainsKey(pubkey)) continue;

            var encryptedShares =
                secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].EncryptedPieces;
            if (!encryptedShares.Any() || !encryptedShares.ContainsKey(selfPubkey)) continue;
            var interestingMessage = encryptedShares[selfPubkey];
            var senderPublicKey = ByteArrayHelper.HexStringToByteArray(pubkey);

            var decryptedPiece =
                await _accountService.DecryptMessageAsync(senderPublicKey, interestingMessage.ToByteArray());
            decryptedPieces[pubkey] = decryptedPiece;
            secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].DecryptedPieces[selfPubkey]
                = ByteString.CopyFrom(decryptedPiece);
        }

        _encryptedPieces[secretSharingInformation.CurrentRoundId] = encryptedPieces;
        _decryptedPieces[secretSharingInformation.CurrentRoundId] = decryptedPieces;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L16-51)
```csharp
    public UpdateValueInput ExtractInformationToUpdateConsensus(string pubkey, ByteString randomNumber)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return null;

        var minerInRound = RealTimeMinersInformation[pubkey];

        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);

        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L14-41)
```csharp
        public static List<byte[]> EncodeSecret(byte[] secretMessage, int threshold, int totalParts)
        {
            // Polynomial construction.
            var coefficients = new BigInteger[threshold];
            // Set p(0) = secret message.
            coefficients[0] = secretMessage.ToBigInteger();
            for (var i = 1; i < threshold; i++)
            {
                var foo = new byte[32];
                Array.Copy(HashHelper.ComputeFrom(Guid.NewGuid().ToByteArray()).ToArray(), foo, 32);
                coefficients[i] = BigInteger.Abs(new BigInteger(foo));
            }

            var result = new List<byte[]>();
            for (var i = 1; i < totalParts + 1; i++)
            {
                var secretBigInteger = coefficients[0];
                for (var j = 1; j < threshold; j++)
                {
                    secretBigInteger += coefficients[j] * BigInteger.Pow(new BigInteger(i), j);
                    secretBigInteger %= SecretSharingConsts.FieldPrime;
                }

                result.Add(secretBigInteger.ToByteArray());
            }

            return result;
        }
```
