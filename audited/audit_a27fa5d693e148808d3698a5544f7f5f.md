### Title
Invalid Order Values Can Corrupt Block Production Sequence Through Unvalidated TuneOrderInformation

### Summary
A malicious miner can use the `TuneOrderInformation` field in `UpdateValue` transactions to set arbitrary `FinalOrderOfNextRound` values (including zero or negative) for miners, which are then directly used as `Order` values in the next round. The `NextRoundMiningOrderValidationProvider` fails to detect this because it validates `FinalOrderOfNextRound` in the newly generated round (which defaults to 0) rather than validating the actual `Order` values, allowing corrupted rounds to be committed and breaking critical consensus functions.

### Finding Description

**Root Cause:**

In `ProcessUpdateValue`, the `TuneOrderInformation` map is applied directly to miners' `FinalOrderOfNextRound` without any bounds checking: [1](#0-0) 

A miner can set `TuneOrderInformation[targetMinerPubkey] = 0` (or negative values), and this value is directly assigned to `currentRound.RealTimeMinersInformation[targetMinerPubkey].FinalOrderOfNextRound`.

**Exploitation Path:**

When `NextRound` is triggered, `GenerateNextRoundInformation` uses these `FinalOrderOfNextRound` values as the `Order` for miners in the next round: [2](#0-1) 

The `Order` field is directly assigned from `FinalOrderOfNextRound` without validation that it's a positive integer in the valid range [1, minersCount].

**Why Validation Fails:**

The `NextRoundMiningOrderValidationProvider` checks whether the count of miners with `FinalOrderOfNextRound > 0` equals the count of miners who produced blocks: [3](#0-2) 

However, the `providedRound` being validated is the newly generated next round where:
- `FinalOrderOfNextRound` is NOT set (defaults to 0 for all miners)
- `OutValue` is NOT set (defaults to null for all miners) [4](#0-3) 

Therefore, the validation becomes: `count(FinalOrderOfNextRound > 0) = 0 == count(OutValue != null) = 0`, which passes even when `Order` values are invalid (0 or negative).

### Impact Explanation

**Consensus Disruption:**

Critical consensus functions rely on valid `Order` values:

1. `GetMiningInterval()` searches for miners with `Order == 1` or `Order == 2`: [5](#0-4) 

If no miner has `Order == 1` or `Order == 2`, accessing `firstTwoMiners[1]` throws an exception, causing DoS.

2. `FirstMiner()` searches for a miner with `Order == 1`: [6](#0-5) 

If no miner has `Order == 1`, this returns null/empty, breaking time slot calculations.

**Severity:** HIGH - Complete disruption of block production and consensus progression. The blockchain would halt as no valid miner schedule exists.

### Likelihood Explanation

**Reachable Entry Point:** Yes - Any miner can submit `UpdateValue` transactions during their time slot.

**Feasible Preconditions:** 
- Attacker must be a current miner (or control a miner node)
- Attacker produces a block during their assigned time slot
- Cost: Only requires producing one block with malicious `TuneOrderInformation`

**Execution Practicality:** HIGH
- The `TuneOrderInformation` field is explicitly designed for miners to adjust orders
- No validation exists on the values in `TuneOrderInformation`
- The protobuf definition allows int32 values (including negatives): [7](#0-6) 

**Detection:** The attack only becomes visible when `NextRound` is triggered and critical functions start failing, by which time the corrupted round has been committed to state.

### Recommendation

**1. Validate TuneOrderInformation values in ProcessUpdateValue:**

```csharp
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    // Validate order is within valid range [1, minersCount]
    if (tuneOrder.Value < 1 || tuneOrder.Value > currentRound.RealTimeMinersInformation.Count)
        Assert(false, $"Invalid tune order value: {tuneOrder.Value}");
    
    // Check no duplicate orders
    if (currentRound.RealTimeMinersInformation.Values.Any(m => 
        m.Pubkey != tuneOrder.Key && m.FinalOrderOfNextRound == tuneOrder.Value))
        Assert(false, $"Duplicate order value: {tuneOrder.Value}");
    
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

**2. Add Order value validation in NextRoundMiningOrderValidationProvider:**

```csharp
// Validate actual Order values in the provided round
var orders = providedRound.RealTimeMinersInformation.Values.Select(m => m.Order).ToList();
var minersCount = providedRound.RealTimeMinersInformation.Count;

// Check all orders are positive and within range
if (orders.Any(o => o < 1 || o > minersCount))
    return new ValidationResult { Message = "Invalid Order values detected." };

// Check for duplicates
if (orders.Distinct().Count() != orders.Count)
    return new ValidationResult { Message = "Duplicate Order values detected." };
```

**3. Add defensive checks in critical functions:**

In `GetMiningInterval()` and `FirstMiner()`, add assertions that required Order values exist before accessing them.

### Proof of Concept

**Initial State:**
- 5 miners in current round (Order 1-5)
- Miner A is at Order 3
- Current round in progress

**Attack Steps:**

1. Miner A produces a block with `UpdateValue` transaction containing:
   ```
   TuneOrderInformation = {
       "MinerBPubkey": 0  // Set Miner B's FinalOrderOfNextRound to 0
   }
   ```

2. This sets `currentRound.RealTimeMinersInformation["MinerBPubkey"].FinalOrderOfNextRound = 0`

3. Later, any miner triggers `NextRound` behavior

4. `GenerateNextRoundInformation` creates next round where Miner B gets `Order = 0`

5. Validation checks:
   - `providedRound.FinalOrderOfNextRound` for all miners = 0 (default, not set)
   - `providedRound.OutValue` for all miners = null (not mined yet)
   - Count comparison: 0 == 0 âœ“ PASSES

6. Corrupted round is committed to state

7. When any function calls `GetMiningInterval()`:
   - Searches for `Order == 1` and `Order == 2`
   - If Miner B was the miner with Order 1, no miner found
   - Exception thrown or null returned
   - **Consensus halted**

**Expected Result:** Validation should reject the NextRound transaction

**Actual Result:** Validation passes, corrupted round is committed, consensus breaks

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-32)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L144-147)
```csharp
        return RealTimeMinersInformation.Count > 0
            ? RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == 1)
            // Unlikely.
            : new MinerInRound();
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```
