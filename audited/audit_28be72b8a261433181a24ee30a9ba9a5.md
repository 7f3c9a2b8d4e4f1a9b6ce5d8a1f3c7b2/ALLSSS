### Title
UnApprove Method Throws Overflow Exception When Attempting to Reduce Allowance Below Zero

### Summary
The NFT contract's `UnApprove` method contains a logic error that causes transaction failure when users attempt to unapprove an amount greater than their current allowance. The method uses checked arithmetic subtraction before validating the result, causing an `OverflowException` instead of gracefully reducing the allowance to zero as intended.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** 
The `UnApprove` method retrieves the current allowance and directly subtracts the input amount using the `Sub()` extension method, which employs checked arithmetic. [2](#0-1) 

The `Sub()` method is defined with a `checked` block that throws `OverflowException` on underflow: [3](#0-2) 

When `input.Amount > oldAllowance`, the subtraction `oldAllowance.Sub(input.Amount)` produces a negative result, triggering an overflow exception. The check on line 315 (`if (currentAllowance <= 0) currentAllowance = 0;`) becomes unreachable because the exception is thrown on line 314.

**Why Protections Fail:**
The intended protection (clamping to zero) is positioned after the arithmetic operation that causes the exception, making it ineffective. Tests confirm checked arithmetic throws `OverflowException` for underflow cases: [4](#0-3) 

**Contrast with MultiToken Contract:**
The MultiToken contract correctly handles this scenario using `Math.Min` to ensure the subtraction never goes negative: [5](#0-4) 

The MultiToken contract's approach is validated by a specific test case: [6](#0-5) 

The NFT contract lacks equivalent test coverage for this edge case: [7](#0-6) 

### Impact Explanation

**Operational Impact:**
- Users cannot successfully unapprove amounts exceeding their current allowance
- Transactions fail with `OverflowException`, requiring users to know their exact allowance before calling `UnApprove`
- Creates inconsistent behavior between NFT and MultiToken contracts, violating user expectations
- Prevents legitimate use cases like bulk revocation of approvals or "revoke all" operations

**Severity Justification (Medium):**
- No direct fund loss or theft occurs
- No authorization bypass or governance compromise
- Impact limited to operational friction and poor user experience
- Affects normal user operations (approval management)
- Inconsistency with established MultiToken contract patterns may confuse integrators

### Likelihood Explanation

**High Likelihood:**
- **Reachable Entry Point:** `UnApprove` is a public method accessible to any address with an existing allowance
- **Feasible Preconditions:** No special permissions required; users only need to have previously approved a spender
- **Execution Practicality:** Trivial to trigger - any call to `UnApprove` with `amount > current allowance`
- **Common User Behavior:** Users frequently attempt to revoke all approvals by specifying large amounts, or may not check exact allowance before unapproving
- **Low Attack Complexity:** Single transaction, no timing dependencies or complex state setup required

### Recommendation

**Code-Level Mitigation:**
Replace the direct subtraction with `Math.Min` to match the MultiToken contract pattern:

```csharp
public override Empty UnApprove(UnApproveInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    var oldAllowance = State.AllowanceMap[tokenHash][Context.Sender][input.Spender];
    var amountOrAll = Math.Min(input.Amount, oldAllowance);
    var currentAllowance = oldAllowance.Sub(amountOrAll);
    
    State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = currentAllowance;
    
    Context.Fire(new UnApproved
    {
        Owner = Context.Sender,
        Spender = input.Spender,
        Symbol = input.Symbol,
        CurrentAllowance = currentAllowance,
        TokenId = input.TokenId
    });
    return new Empty();
}
```

**Test Cases to Add:**
1. Test unapproving with amount equal to current allowance (should succeed, result in 0)
2. Test unapproving with amount greater than current allowance (should succeed, result in 0)
3. Test unapproving with amount less than current allowance (should succeed, result in difference)
4. Test unapproving when current allowance is 0 (should succeed, remain at 0)

### Proof of Concept

**Initial State:**
1. User A approves Spender B for 100 tokens of NFT (symbol: "TEST-NFTSYMBOL", tokenId: 1)
2. Current allowance: `State.AllowanceMap[tokenHash][A][B] = 100`

**Exploit Steps:**
1. User A calls `UnApprove` with:
   - `Symbol`: "TEST-NFTSYMBOL"
   - `TokenId`: 1
   - `Spender`: B
   - `Amount`: 200

**Expected Behavior:**
- Allowance should be reduced to 0
- Transaction should complete successfully
- `UnApproved` event should fire with `CurrentAllowance = 0`

**Actual Result:**
- Line 314 executes: `currentAllowance = 100.Sub(200)`
- Checked arithmetic computes: `100 - 200 = -100`
- `OverflowException` is thrown
- Transaction fails with status `Failed`
- Allowance remains at 100
- No event is fired

**Success Condition for Exploit:**
Transaction status returns `Failed` with `OverflowException` when attempting to unapprove 200 from allowance of 100, demonstrating the vulnerability.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L310-328)
```csharp
    public override Empty UnApprove(UnApproveInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var oldAllowance = State.AllowanceMap[tokenHash][Context.Sender][input.Spender];
        var currentAllowance = oldAllowance.Sub(input.Amount);
        if (currentAllowance <= 0) currentAllowance = 0;

        State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = currentAllowance;

        Context.Fire(new UnApproved
        {
            Owner = Context.Sender,
            Spender = input.Spender,
            Symbol = input.Symbol,
            CurrentAllowance = currentAllowance,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L23-26)
```csharp
        10.Sub(5).ShouldBe(5);
        10.Sub(-5).ShouldBe(15);
        Should.Throw<OverflowException>(() => { int.MaxValue.Sub(-5); });
        Should.Throw<OverflowException>(() => { uint.MinValue.Sub(5); });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L300-316)
```csharp
    public override Empty UnApprove(UnApproveInput input)
    {
        AssertValidInputAddress(input.Spender);
        var symbol = GetActualTokenSymbol(input.Symbol);
        AssertValidApproveTokenAndAmount(symbol, input.Amount);
        var oldAllowance = State.Allowances[Context.Sender][input.Spender][symbol];
        var amountOrAll = Math.Min(input.Amount, oldAllowance);
        State.Allowances[Context.Sender][input.Spender][symbol] = oldAllowance.Sub(amountOrAll);
        Context.Fire(new UnApproved
        {
            Owner = Context.Sender,
            Spender = input.Spender,
            Symbol = symbol,
            Amount = amountOrAll
        });
        return new Empty();
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L355-374)
```csharp
    public async Task MultiTokenContract_UnApprove_OutOfAmount_Test()
    {
        await CreateAndIssueMultiTokensAsync();

        var allowanceOutput = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = User1Address,
            Symbol = AliceCoinTokenInfo.Symbol
        });

        allowanceOutput.Allowance.ShouldBe(0L);
        var result = (await TokenContractStub.UnApprove.SendAsync(new UnApproveInput
        {
            Amount = 1000L,
            Spender = User1Address,
            Symbol = AliceCoinTokenInfo.Symbol
        })).TransactionResult;
        result.Status.ShouldBe(TransactionResultStatus.Mined);
    }
```

**File:** test/AElf.Contracts.NFT.Tests/NFTContractTests.cs (L186-228)
```csharp
    [Fact]
    public async Task ApproveTest()
    {
        var symbol = await TransferTest();

        await MinterNFTContractStub.Approve.SendAsync(new ApproveInput
        {
            Spender = DefaultAddress,
            Symbol = symbol,
            TokenId = 1,
            Amount = 10
        });

        {
            var allowance = (await NFTContractStub.GetAllowance.CallAsync(new GetAllowanceInput
            {
                Owner = MinterAddress,
                Spender = DefaultAddress,
                Symbol = symbol,
                TokenId = 1
            })).Allowance;
            allowance.ShouldBe(10);
        }

        await NFTContractStub.TransferFrom.SendAsync(new TransferFromInput
        {
            To = User1Address,
            Symbol = symbol,
            TokenId = 1,
            Amount = 9,
            From = MinterAddress
        });

        {
            var balance = (await MinterNFTContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = User1Address,
                Symbol = symbol,
                TokenId = 1
            })).Balance;
            balance.ShouldBe(19);
        }
    }
```
