### Title
Cross-Chain Indexing Proposal State Inconsistency Due to Inline Transaction Failure

### Summary
The `ReleaseCrossChainIndexingProposal` method executes `ReleaseIndexingProposal` and `RecordCrossChainData` sequentially, but uses `Context.SendInline` to release the Parliament proposal. Since inline transactions execute asynchronously after the parent transaction completes, if the inline Release call fails, the parent transaction still succeeds, causing `RecordCrossChainData` to commit state changes marking the proposal as "Accepted" while the Parliament proposal may remain unreleased, creating permanent state inconsistency between contracts.

### Finding Description

The vulnerability exists in the cross-chain indexing release flow: [1](#0-0) 

The `ReleaseCrossChainIndexingProposal` method calls two operations sequentially within the same transaction. The first operation, `ReleaseIndexingProposal`, attempts to release the Parliament proposal via an inline transaction: [2](#0-1) 

This method calls `HandleIndexingProposal` which uses `Context.SendInline` to invoke the Parliament contract's Release method: [3](#0-2) 

**Root Cause**: The critical issue is that `Context.SendInline` only queues the inline transaction for later execution—it does not execute synchronously: [4](#0-3) 

Inline transactions execute **after** the parent transaction completes successfully: [5](#0-4) 

Furthermore, if an inline transaction fails, it does not cause the parent transaction to revert: [6](#0-5) 

**Execution Path**:
1. Miner calls `ReleaseCrossChainIndexingProposal` (parent transaction begins)
2. `ReleaseIndexingProposal` executes and queues inline Release call
3. `RecordCrossChainData` executes and commits state changes: [7](#0-6) 

4. Parent transaction succeeds and commits all state changes
5. Inline Release transaction attempts execution
6. If inline fails (expired proposal, concurrent deletion, threshold changes, etc.), the CrossChain contract state is already committed with status "Accepted" but Parliament proposal state is inconsistent

### Impact Explanation

**Cross-Chain Integrity Compromise**:
- The CrossChain contract believes the proposal is "Accepted" and has indexed the cross-chain data
- The Parliament proposal may still exist (if Release failed before deletion) or may have been deleted without proper execution
- Creates permanent state desynchronization between governance and cross-chain contracts

**Operational Impact**:
- Subsequent attempts to clear/reset the proposal will fail due to status mismatch
- The `AcceptCrossChainIndexingProposal` method expects "Accepted" status: [8](#0-7) 

- Cross-chain data may be indexed without proper governance approval being finalized
- Breaks the invariant that indexed cross-chain data must have completed governance approval
- Could lead to incorrect merkle root tracking and verification failures

**Severity**: Medium - Does not directly enable fund theft but compromises cross-chain integrity and governance consistency, potentially affecting bridge security and requiring manual intervention to resolve.

### Likelihood Explanation

**Reachable Entry Point**: `ReleaseCrossChainIndexingProposal` is a public method callable by current miners: [1](#0-0) 

**Feasible Preconditions**: The inline Release call can fail under realistic scenarios:
- Proposal expired between approval and release attempt (timing window)
- Concurrent proposal clearing by another transaction
- State conflicts in high-throughput scenarios
- Parliament contract threshold modifications during execution
- Gas/execution limit exhaustion in inline transaction

**Execution Practicality**: No attacker action required—this is a race condition/timing vulnerability that can occur during normal operation. A miner attempting to release a proposal that becomes invalid between the ToBeReleased check and the actual Release execution will trigger the vulnerability.

**Detection Constraints**: The inconsistency may not be immediately visible as both transactions appear successful in logs, but state queries will show mismatched proposal statuses between contracts.

### Recommendation

**Code-Level Mitigation**:
Verify the inline Release transaction succeeded before proceeding with `RecordCrossChainData`. Add explicit success verification:

```csharp
public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
{
    Context.LogDebug(() => "Releasing cross chain data..");
    EnsureTransactionOnlyExecutedOnceInOneBlock();
    AssertAddressIsCurrentMiner(Context.Sender);
    Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
    
    // Verify proposals are still valid and releasable
    foreach (var chainId in input.ChainIdList)
    {
        var proposalExists = TryGetIndexingProposalWithStatus(chainId,
            CrossChainIndexingProposalStatus.Pending, out var proposal);
        Assert(proposalExists, "Chain indexing not proposed.");
        
        var crossChainIndexingController = GetCrossChainIndexingController();
        var parliamentProposal = GetCrossChainProposal(crossChainIndexingController, proposal.ProposalId);
        Assert(parliamentProposal.ToBeReleased && !parliamentProposal.Expired, 
            "Proposal not ready or expired.");
    }
    
    ReleaseIndexingProposal(input.ChainIdList);
    RecordCrossChainData(input.ChainIdList);
    return new Empty();
}
```

**Alternative**: Change `HandleIndexingProposal` to use synchronous Call instead of SendInline to detect failure immediately, or restructure to release proposals first, then have a separate transaction for recording data that verifies release succeeded.

**Invariant Checks**: Add post-release verification that Parliament proposals were successfully removed before marking CrossChain proposals as "Accepted".

**Test Cases**: Add regression tests for:
1. Proposal expiration during release
2. Concurrent proposal operations
3. Inline transaction failure scenarios
4. State consistency verification across contracts

### Proof of Concept

**Initial State**:
1. Side chain created and active
2. Cross-chain block data proposed by miner
3. Parliament proposal created with status Pending
4. Miners approve proposal (ToBeReleased = true)

**Transaction Steps**:
1. Concurrent transactions: 
   - Thread A: Miner calls `ReleaseCrossChainIndexingProposal`
   - Thread B: Time advances past proposal expiration OR another party calls `ClearProposal`

2. Thread A execution:
   - `ReleaseIndexingProposal` checks proposal exists (passes)
   - Queues inline Release call
   - `RecordCrossChainData` executes and sets status to "Accepted"
   - Parent transaction commits

3. Inline Release execution:
   - Attempts to release Parliament proposal
   - Fails due to expiration or concurrent deletion
   - Inline transaction fails but parent already committed

**Expected Result**: 
- If Release fails, RecordCrossChainData should not execute
- Both contracts should maintain consistent state

**Actual Result**:
- CrossChain contract: Proposal status = "Accepted", data indexed
- Parliament contract: Proposal deleted/expired without proper release
- State inconsistency persists permanently

**Success Condition**: Query both contracts shows mismatched states—CrossChain shows "Accepted" while Parliament shows proposal missing or unreleased.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L304-310)
```csharp
    public override Empty AcceptCrossChainIndexingProposal(AcceptCrossChainIndexingProposalInput input)
    {
        AssertCrossChainIndexingControllerAuthority(Context.Sender);
        AssertIsCrossChainBlockDataAccepted(input.ChainId);
        ResetChainIndexingProposal(input.ChainId);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L297-307)
```csharp
    private void ReleaseIndexingProposal(IEnumerable<int> chainIdList)
    {
        foreach (var chainId in chainIdList)
        {
            var pendingProposalExists = TryGetIndexingProposalWithStatus(chainId,
                CrossChainIndexingProposalStatus.Pending,
                out var pendingCrossChainIndexingProposal);
            Assert(pendingProposalExists, "Chain indexing not proposed.");
            HandleIndexingProposal(pendingCrossChainIndexingProposal.ProposalId);
        }
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L309-336)
```csharp
    private void RecordCrossChainData(IEnumerable<int> chainIdList)
    {
        var indexedSideChainBlockData = new IndexedSideChainBlockData();
        foreach (var chainId in chainIdList)
        {
            var pendingProposalExists = TryGetIndexingProposalWithStatus(chainId,
                CrossChainIndexingProposalStatus.Pending,
                out var pendingCrossChainIndexingProposal);
            Assert(pendingProposalExists, "Chain indexing not proposed.");

            if (chainId == State.ParentChainId.Value)
                IndexParentChainBlockData(pendingCrossChainIndexingProposal.ProposedCrossChainBlockData
                    .ParentChainBlockDataList);
            else
                indexedSideChainBlockData.SideChainBlockDataList.Add(IndexSideChainBlockData(
                    pendingCrossChainIndexingProposal.ProposedCrossChainBlockData.SideChainBlockDataList,
                    pendingCrossChainIndexingProposal.Proposer, chainId));

            SetCrossChainIndexingProposalStatus(pendingCrossChainIndexingProposal,
                CrossChainIndexingProposalStatus.Accepted);
        }

        if (indexedSideChainBlockData.SideChainBlockDataList.Count > 0)
        {
            State.IndexedSideChainBlockData.Set(Context.CurrentHeight, indexedSideChainBlockData);
            Context.Fire(new SideChainBlockDataIndexed());
        }
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L455-463)
```csharp
    private void HandleIndexingProposal(Hash proposalId)
    {
        var crossChainIndexingController = GetCrossChainIndexingController();
        var proposal = GetCrossChainProposal(crossChainIndexingController, proposalId);
        Assert(proposal.ToBeReleased, "Not approved cross chain indexing proposal.");
        Context.SendInline(crossChainIndexingController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release),
            proposal.ProposalId); // release if ready
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L228-237)
```csharp
    public void SendInline(Address toAddress, string methodName, ByteString args)
    {
        TransactionContext.Trace.InlineTransactions.Add(new Transaction
        {
            From = Self,
            To = toAddress,
            MethodName = methodName,
            Params = args
        });
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L180-186)
```csharp
            if (txContext.Trace.IsSuccessful())
                await ExecuteInlineTransactions(singleTxExecutingDto.Depth, singleTxExecutingDto.CurrentBlockTime,
                    txContext, internalStateCache,
                    internalChainContext,
                    singleTxExecutingDto.OriginTransactionId,
                    cancellationToken);

```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L236-246)
```csharp
            var inlineTrace = await ExecuteOneAsync(singleTxExecutingDto, cancellationToken);

            if (inlineTrace == null)
                break;
            trace.InlineTraces.Add(inlineTrace);
            if (!inlineTrace.IsSuccessful())
                // Already failed, no need to execute remaining inline transactions
                break;

            internalStateCache.Update(inlineTrace.GetStateSets());
        }
```
