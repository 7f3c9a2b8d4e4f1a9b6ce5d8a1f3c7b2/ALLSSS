### Title
Consensus Validation Bypass via Behaviour Field Mismatch in Block Header ExtraData

### Summary
The consensus validation system trusts the `Behaviour` field in block header `extraData` to select validation providers, but does not verify this field matches the actual consensus transaction being executed. A malicious miner can set `extraData.Behaviour = NextTerm` while executing a `NextRound` transaction, causing critical validators like `NextRoundMiningOrderValidationProvider` to be skipped, enabling manipulation of next round mining order.

### Finding Description

**Root Cause:**

The validation flow has a critical architectural flaw where validation provider selection is decoupled from transaction type verification: [1](#0-0) 

Provider selection is based on `extraData.Behaviour` which comes from the block header, not from the transaction type being executed. The validation service simply iterates through whatever providers are given: [2](#0-1) 

**Why Protections Fail:**

1. The `extraData` used for validation comes from the block header and is parsed without verifying it corresponds to the actual transaction: [3](#0-2) 

2. The validation is called before execution with block header extraData: [4](#0-3) [5](#0-4) 

3. Transaction generation and validation use the same trigger information, but block proposers control the final `extraData` in the block header: [6](#0-5) [7](#0-6) 

4. The transaction input types (`NextRoundInput`, `NextTermInput`) do not contain a `Behaviour` field, so there's no validation that `extraData.Behaviour` matches the transaction method: [8](#0-7) [9](#0-8) 

5. The `ValidateConsensusAfterExecution` does not verify the `Behaviour` field matches the executed transaction type: [10](#0-9) 

**Execution Path:**

1. Honest flow would have `NextRound` transaction execute with `NextRound` validation providers
2. Attack flow: Malicious miner modifies block header `extraData.Behaviour = NextTerm` while keeping `NextRound` transaction in block body
3. Validators extract `extraData` with `Behaviour = NextTerm` from block header and add only `RoundTerminateValidationProvider`, skipping `NextRoundMiningOrderValidationProvider`
4. `NextRound` transaction executes without proper validation of `FinalOrderOfNextRound` values
5. Malicious miner successfully manipulates next round mining order

### Impact Explanation

**Direct Consensus Integrity Compromise:**

The `NextRoundMiningOrderValidationProvider` enforces a critical invariant for round transitions: [11](#0-10) 

By bypassing this validator, attackers can:

1. **Manipulate mining order**: Set arbitrary `FinalOrderOfNextRound` values to position themselves or colluding miners favorably in the next round
2. **Control block production sequence**: Gain consecutive time slots or target specific block heights
3. **Break consensus fairness**: Violate the deterministic miner ordering that ensures fair block production
4. **Enable follow-up attacks**: Favorable positions enable censorship, MEV extraction, or coordination with other consensus manipulation

**Affected Parties:**
- All network participants suffer from compromised consensus integrity
- Honest miners lose fair mining opportunities
- Applications relying on consensus fairness experience unpredictable block times

**Severity Justification:**
CRITICAL - This violates the core consensus invariant of correct round transitions and miner schedule integrity. Round transitions are the foundation of AEDPoS consensus, and manipulation here compromises the entire consensus mechanism.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a valid miner in the current round (required to produce blocks)
- Must be the extra block producer to trigger `NextRound` transition
- Technical ability to modify block header `extraData` before broadcasting (simple byte manipulation)

**Attack Complexity:**
LOW - The attack requires only:
1. Waiting for turn as extra block producer
2. Modifying a single field (`Behaviour`) in block header `extraData` from `NextRound` to `NextTerm`
3. Broadcasting the modified block

**Feasibility Conditions:**
- No cryptographic protections prevent `extraData` modification (it's not part of the signature)
- Block header structure allows arbitrary `extraData` values
- No cross-validation between `extraData.Behaviour` and transaction type exists
- Attack leaves no special traces (looks like normal `NextTerm` validation followed by `NextRound` execution)

**Detection Constraints:**
- Difficult to detect: Validation logs show `NextTerm` behaviour, execution shows `NextRound` transaction
- No alerts triggered: All individual components work correctly, just with wrong combination
- After-the-fact detection requires comparing block body transactions with header `extraData`, which is not standard monitoring

**Probability Assessment:**
HIGH - Any malicious miner can execute this attack during their extra block slot. With multiple rounds, opportunities arise frequently. The low complexity and high reward make this attack highly probable if miners are economically motivated to gain favorable positions.

### Recommendation

**Code-Level Mitigation:**

1. **Add transaction type verification in `ValidateBeforeExecution`:**

After parsing `extraData`, verify the `Behaviour` field matches the transaction being executed. Add check before provider selection in `AEDPoSContract_Validation.cs`:

```csharp
// After line 60, before line 62:
// Verify extraData.Behaviour matches the actual transaction being validated
// This requires passing transaction context or adding post-execution verification
```

2. **Enhance `ValidateConsensusAfterExecution` to verify behaviour consistency:**

Add explicit check in `AEDPoSContract_ACS4_ConsensusInformationProvider.cs` after line 87 to compare `headerInformation.Behaviour` with the actual state changes that occurred (which reveal transaction type).

3. **Add behaviour field to transaction inputs:**

Modify `NextRoundInput`, `NextTermInput`, and `UpdateValueInput` protobuf messages to include a `behaviour` field that must match `extraData.Behaviour`.

**Invariant Checks to Add:**

1. `extraData.Behaviour` must correspond to the consensus transaction present in the block body
2. For `NextRound` transitions, `NextRoundMiningOrderValidationProvider` must have executed
3. Round state changes must be consistent with the validated `Behaviour` type

**Test Cases:**

1. Create block with `NextRound` transaction but `extraData.Behaviour = NextTerm` → should FAIL validation
2. Create block with `NextTerm` transaction but `extraData.Behaviour = NextRound` → should FAIL validation  
3. Create block with mismatched `UpdateValue` transaction and `NextRound` behaviour → should FAIL validation
4. Verify `NextRoundMiningOrderValidationProvider` always runs for `NextRound` transactions
5. Add integration test that attempts to manipulate `FinalOrderOfNextRound` with behaviour mismatch → should be rejected

### Proof of Concept

**Required Initial State:**
- Blockchain running with AEDPoS consensus
- Malicious miner M is part of current round's miner list
- Malicious miner M is designated as extra block producer for current round
- Current round about to complete, triggering `NextRound` transition

**Attack Steps:**

1. **Normal consensus flow generates `NextRound` transaction:**
   - Trigger information has `Behaviour = NextRound`
   - `GenerateConsensusTransactions` creates `NextRound` transaction with manipulated `FinalOrderOfNextRound` values favoring attacker

2. **Attacker modifies block header:**
   - Normal `extraData` would have `Behaviour = NextRound`
   - Attacker changes `extraData.Behaviour` to `NextTerm` in block header before broadcasting
   - Block body still contains `NextRound` transaction

3. **Other nodes validate the block:**
   - `ValidateConsensusBeforeExecution` parses `extraData` with `Behaviour = NextTerm`
   - `ValidateBeforeExecution` adds only `RoundTerminateValidationProvider` (skips `NextRoundMiningOrderValidationProvider`)
   - Validation passes without checking `FinalOrderOfNextRound` correctness

4. **Block gets executed:**
   - `NextRound` transaction executes from block body
   - State updates with attacker's manipulated `FinalOrderOfNextRound` values
   - Next round begins with attacker in favorable mining position

**Expected Result:** 
Block validation should FAIL due to behaviour mismatch

**Actual Result:**
Block passes validation and attacker successfully manipulates next round mining order, gaining unfair advantage in consensus

**Success Condition:**
Attacker observes next round state where their `FinalOrderOfNextRound` has been manipulated to a favorable position (e.g., first miner slot) despite not meeting the proper ordering criteria validated by `NextRoundMiningOrderValidationProvider`.

### Notes

The vulnerability exploits the architectural separation between validation (which uses block header `extraData`) and execution (which uses block body transactions). The `Behaviour` field was intended as metadata to help validation but became a trusted input without verification. This is particularly dangerous for consensus transitions where specific validators enforce critical invariants like mining order fairness.

The fix requires either: (1) adding cross-validation between `extraData.Behaviour` and transaction type, or (2) making validation providers transaction-aware rather than behaviour-aware. Option (1) is simpler but requires passing transaction context to validation. Option (2) is more robust but requires refactoring the validation architecture.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ValidationService.cs (L16-26)
```csharp
    public ValidationResult ValidateInformation(ConsensusValidationContext validationContext)
    {
        foreach (var headerInformationValidationProvider in _headerInformationValidationProviders)
        {
            var result =
                headerInformationValidationProvider.ValidateHeaderInformation(validationContext);
            if (!result.Success) return result;
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L119-149)
```csharp
    public async Task<bool> ValidateConsensusBeforeExecutionAsync(ChainContext chainContext,
        byte[] consensusExtraData)
    {
        var now = TimestampHelper.GetUtcNow();
        _blockTimeProvider.SetBlockTime(now, chainContext.BlockHash);

        var contractReaderContext =
            await _consensusReaderContextService.GetContractReaderContextAsync(chainContext);
        var validationResult = await _contractReaderFactory
            .Create(contractReaderContext)
            .ValidateConsensusBeforeExecution
            .CallAsync(new BytesValue { Value = ByteString.CopyFrom(consensusExtraData) });

        if (validationResult == null)
        {
            Logger.LogDebug("Validation of consensus failed before execution.");
            return false;
        }

        if (!validationResult.Success)
        {
            Logger.LogDebug($"Consensus validating before execution failed: {validationResult.Message}");
            await LocalEventBus.PublishAsync(new ConsensusValidationFailedEventData
            {
                ValidationResultMessage = validationResult.Message,
                IsReTrigger = validationResult.IsReTrigger
            });
        }

        return validationResult.Success;
    }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L195-209)
```csharp
    public async Task<byte[]> GetConsensusExtraDataAsync(ChainContext chainContext)
    {
        _blockTimeProvider.SetBlockTime(_nextMiningTime, chainContext.BlockHash);

        Logger.LogDebug(
            $"Block time of getting consensus extra data: {_nextMiningTime.ToDateTime():hh:mm:ss.ffffff}.");

        var contractReaderContext =
            await _consensusReaderContextService.GetContractReaderContextAsync(chainContext);
        var input = _triggerInformationProvider.GetTriggerInformationForBlockHeaderExtraData(
            _consensusCommand.ToBytesValue());
        var consensusContractStub = _contractReaderFactory.Create(contractReaderContext);
        var output = await consensusContractStub.GetConsensusExtraData.CallAsync(input);
        return output.Value.ToByteArray();
    }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L216-244)
```csharp
    public async Task<List<Transaction>> GenerateConsensusTransactionsAsync(ChainContext chainContext)
    {
        _blockTimeProvider.SetBlockTime(_nextMiningTime, chainContext.BlockHash);

        Logger.LogDebug(
            $"Block time of getting consensus system txs: {_nextMiningTime.ToDateTime():hh:mm:ss.ffffff}.");

        var contractReaderContext =
            await _consensusReaderContextService.GetContractReaderContextAsync(chainContext);
        var generatedTransactions =
            (await _contractReaderFactory
                .Create(contractReaderContext)
                .GenerateConsensusTransactions
                .CallAsync(_triggerInformationProvider.GetTriggerInformationForConsensusTransactions(
                    chainContext, _consensusCommand.ToBytesValue())))
            .Transactions
            .ToList();

        // Complete these transactions.
        foreach (var generatedTransaction in generatedTransactions)
        {
            generatedTransaction.RefBlockNumber = chainContext.BlockHeight;
            generatedTransaction.RefBlockPrefix =
                BlockHelper.GetRefBlockPrefix(chainContext.BlockHash);
            Logger.LogDebug($"Consensus transaction generated: \n{generatedTransaction.GetHash()}");
        }

        return generatedTransactions;
    }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusValidationProvider.cs (L58-78)
```csharp
    public async Task<bool> ValidateBlockBeforeExecuteAsync(IBlock block)
    {
        if (block.Header.Height == AElfConstants.GenesisBlockHeight)
            return true;

        var consensusExtraData = _consensusExtraDataExtractor.ExtractConsensusExtraData(block.Header);
        if (consensusExtraData == null || consensusExtraData.IsEmpty)
        {
            Logger.LogDebug($"Invalid consensus extra data {block}");
            return false;
        }

        var isValid = await _consensusService.ValidateConsensusBeforeExecutionAsync(new ChainContext
        {
            BlockHash = block.Header.PreviousBlockHash,
            BlockHeight = block.Header.Height - 1
        }, consensusExtraData.ToByteArray());
        if (!isValid) return false;

        return ValidateTransactionCount(block);
    }
```

**File:** protobuf/aedpos_contract.proto (L458-481)
```text
message NextRoundInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producers’ expecting time (second).
    int64 round_id_for_validation = 10;
    // The random number.
    bytes random_number = 11;
}
```

**File:** protobuf/aedpos_contract.proto (L484-508)
```text
message NextTermInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producers’ expecting time (second).
    int64 round_id_for_validation = 10;
    // The random number.
    bytes random_number = 11;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
