### Title
Unbounded MaximumMinersCount Enables Computational DoS via DecodeSecret Complexity

### Summary
The `SetMaximumMinersCount` function lacks upper bound validation, allowing parliament to set arbitrarily large miner counts. [1](#0-0)  When `RevealSharedInValues` executes during NextRound block production, it calls `SecretSharingHelper.DecodeSecret` with O(minimumCount²) complexity for each miner, where minimumCount = minersCount × 2/3. [2](#0-1) [3](#0-2)  Since DecodeSecret is an external library method not patched by the execution observer, its computational cost bypasses AElf's execution limits, potentially exceeding block mining time limits (300-2400ms) and causing consensus failure.

### Finding Description

**Location**: `contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs`, function `RevealSharedInValues()`

**Root Cause**:
1. `SetMaximumMinersCount` only validates `input.Value > 0` with no upper bound check [4](#0-3) , allowing parliament to set values like 500 or 1000.

2. During NextRound block production, `RevealSharedInValues` is invoked [5](#0-4)  and iterates through all previous round miners [6](#0-5) .

3. For each qualifying miner, `SecretSharingHelper.DecodeSecret` performs Lagrange polynomial interpolation with nested loops: outer loop runs `threshold` times, inner loop runs `threshold` times, resulting in O(threshold²) BigInteger operations over a 1025-bit finite field. [7](#0-6) 

4. Since `SecretSharingHelper` is an external whitelisted library [8](#0-7) , it is NOT patched by the execution observer [9](#0-8) . The observer only sees one external method call, not the thousands of internal loop iterations.

5. With `minimumCount = minersCount × 2 / 3`, total complexity can reach O(minersCount × minimumCount²) ≈ O(minersCount³) in worst case when revealing multiple miners' values.

**Why Existing Protections Fail**:
- Execution observer (`ExecutionBranchThreshold = 15000`) [10](#0-9)  does not track loops inside external library methods
- Block mining timeout (300ms for normal blocks, 2400ms for term-ending blocks) [11](#0-10)  is a soft limit that causes transaction failure rather than prevention
- No computational cost estimation or validation before setting MaximumMinersCount

### Impact Explanation

**Harm**: Consensus Denial of Service leading to chain halt.

When `minimumCount` is large (e.g., minersCount = 300 → minimumCount = 200 → 40,000 operations), the computational cost of BigInteger operations in `DecodeSecret` can exceed block mining time limits. This causes:

1. NextRound block production to timeout and fail
2. The producing miner to miss their time slot
3. Repeated failures across miners attempting NextRound transitions
4. Potential consensus stall if round cannot advance

**Affected Parties**: All network participants—miners cannot produce blocks, users cannot submit transactions, chain operation halts.

**Severity Justification**: HIGH impact (consensus failure) but MEDIUM-LOW likelihood (requires parliament governance approval). Combined severity: **MEDIUM**.

### Likelihood Explanation

**Attacker Capabilities**: Requires influencing parliament governance to approve a proposal setting `MaximumMinersCount` to a dangerous value (>200).

**Attack Complexity**: 
- Technical: Simple—single governance transaction
- Social: Requires convincing parliament members or proposing during periods of weak governance oversight

**Feasibility Conditions**:
1. Parliament approves SetMaximumMinersCount proposal with large value
2. Sufficient time passes or election manipulation increases actual miner count toward the maximum
3. NextRound block production triggers RevealSharedInValues

**Detection/Operational Constraints**: 
- Issue would be noticed when blocks start timing out
- Parliament could reactively reduce MaximumMinersCount
- However, during the window of high miner count, consensus is compromised

**Probability**: MEDIUM-LOW—while parliament governance provides a barrier, the lack of technical validation means there's no hard limit preventing misconfiguration. Production mainnet starts at 17 miners and grows by 2/year [12](#0-11) , but parliament could theoretically set much higher limits without understanding the computational implications.

### Recommendation

**Code-Level Mitigation**:

Add upper bound validation in `SetMaximumMinersCount`:

```csharp
public override Empty SetMaximumMinersCount(Int32Value input)
{
    EnsureElectionContractAddressSet();
    
    Assert(input.Value > 0, "Invalid max miners count.");
    // ADD: Upper bound check based on computational feasibility
    const int MaxSafeMinerCount = 150; // ~100 minimumCount → 10,000 operations
    Assert(input.Value <= MaxSafeMinerCount, 
        $"Max miners count cannot exceed {MaxSafeMinerCount} due to computational limits.");
    
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set max miners count.");
    
    // ... rest of implementation
}
```

**Invariant Checks**:
- Validate that `minimumCount²` operations can complete within block mining time limits
- Consider adding a configurable computational budget parameter
- Document the relationship between miner count and DecodeSecret complexity

**Test Cases**:
1. Verify SetMaximumMinersCount rejects values > 150
2. Benchmark DecodeSecret with thresholds of 50, 100, 150 to establish safe limits
3. Integration test simulating RevealSharedInValues with various miner counts to measure actual execution time
4. Regression test that parliament cannot set unreasonably high MaximumMinersCount

### Proof of Concept

**Required Initial State**:
- AEDPoS consensus contract deployed and initialized [13](#0-12) 
- Parliament organization configured as MaximumMinersCountController [14](#0-13) 

**Transaction Steps**:
1. Create parliament proposal to call `SetMaximumMinersCount(500)`
2. Parliament members approve and release proposal
3. Proposal executes, setting `State.MaximumMinersCount.Value = 500`
4. Wait for actual miner count to increase (via election or auto-increase) to approach 500
5. When NextRound block production occurs, `GetConsensusExtraDataForNextRound` calls `RevealSharedInValues`
6. `RevealSharedInValues` calculates `minimumCount = 500 × 2 / 3 = 333`
7. For each miner, `DecodeSecret(sharedParts, orders, 333)` executes 333² = 110,889 BigInteger operations
8. Total execution time exceeds `DefaultBlockMiningLimit` (300ms) or `LastBlockOfCurrentTermMiningLimit` (2400ms)

**Expected vs Actual Result**:
- Expected: Block produces successfully within time limit
- Actual: Block production times out, miner fails to produce block, consensus cannot advance to next round

**Success Condition**: Demonstrate that with `minersCount ≥ 200`, NextRound block production consistently fails due to timeout, and consensus cannot progress until MaximumMinersCount is reduced via governance.

---

**Notes**:
- AElf uses execution time limits rather than Ethereum-style gas limits
- The initial MaximumMinersCount default of `int.MaxValue` creates an unbounded attack surface
- While mainnet growth is organic (2 miners/year), governance misconfiguration could create immediate risk
- The vulnerability is exacerbated by the O(n³) worst-case complexity when revealing multiple miners' values

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L36-42)
```csharp
        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MaximumMinersCountController.Value = defaultAuthority;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L25-53)
```csharp
        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** src/AElf.CSharp.CodeOps/Validators/Whitelist/IWhitelistProvider.cs (L226-228)
```csharp
            .Namespace("AElf.Cryptography.SecretSharing", Permission.Denied, type => type
                .Type(typeof(SecretSharingHelper), Permission.Denied, member => member
                    .Member(nameof(SecretSharingHelper.DecodeSecret), Permission.Allowed)));
```

**File:** src/AElf.CSharp.CodeOps/Patchers/Module/CallAndBranchCounts/Patcher.cs (L24-24)
```csharp
        foreach (var method in module.GetAllTypes().SelectMany(t => t.Methods))
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-7)
```csharp
    public const int ExecutionCallThreshold = 15000;

    public const int ExecutionBranchThreshold = 15000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L49-60)
```csharp
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);

        /// <summary>
        ///     If this tiny block is the last one of current time slot, give half of producing time for mining.
        /// </summary>
        protected int LastTinyBlockMiningLimit => TinyBlockSlotInterval.Div(2);

        /// <summary>
        ///     If this block is of consensus behaviour NEXT_TERM, the producing time is MiningInterval,
        ///     so the limitation of mining is 8 times than DefaultBlockMiningLimit.
        /// </summary>
        protected int LastBlockOfCurrentTermMiningLimit => MiningInterval.Mul(3).Div(5);
```

**File:** docs/public-chain/introduction.md (L41-41)
```markdown
At the start of the chain, 17 nodes will be production nodes. Every year, two new producers are added. The maximum number is determined by the community by vote, to adapt to the ecological development needs.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L52-52)
```csharp
        State.MaximumMinersCount.Value = int.MaxValue;
```
