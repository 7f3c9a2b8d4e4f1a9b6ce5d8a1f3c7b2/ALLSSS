# Audit Report

## Title
Duplicate Welcome Rewards via Pubkey Replacement During Non-Mining Periods

## Summary
A candidate can receive welcome rewards multiple times by replacing their public key while not actively mining. The AEDPoS contract's conditional notification to Treasury creates a state inconsistency where replacement pubkeys retain a `LatestMinedTerm` value of zero, causing them to be incorrectly identified as new miners eligible for welcome rewards.

## Finding Description

The vulnerability stems from a coordination failure between the Election, AEDPoS, and Treasury contracts during pubkey replacement operations.

When a candidate calls `ReplaceCandidatePubkey`, the Election contract only verifies that the old pubkey is a current candidate or initial miner, without checking active mining status. [1](#0-0) 

The Election contract then notifies the AEDPoS contract via `RecordCandidateReplacement`. [2](#0-1) 

However, the AEDPoS contract only forwards this notification to Treasury if the old pubkey is present in the current round's active miner list. If not, it returns early without updating Treasury. [3](#0-2) 

The Treasury notification, when it occurs, transfers the `LatestMinedTerm` tracking from old to new pubkey. [4](#0-3) 

During reward distribution, Treasury's `Release` method identifies miners with `LatestMinedTerm == 0` (excluding initial miners) as new miners eligible for welcome rewards. [5](#0-4) 

These identified new miners receive welcome reward shares through `UpdateWelcomeRewardWeights`. [6](#0-5) 

When a replacement occurs during a non-mining period, the new pubkey retains the default `LatestMinedTerm` value of zero. Upon future election, this pubkey is incorrectly treated as a first-time miner and receives duplicate welcome rewards.

## Impact Explanation

**Financial Impact**: The vulnerability enables unauthorized drainage of the welcome reward pool (`VotesWeightRewardHash` profit scheme). Each exploitation grants full welcome reward shares for an entire term, proportional to the `MinerRewardWeightSetting.WelcomeRewardWeight` allocation.

**Affected Parties**: 
- Legitimate first-time miners receive diluted welcome rewards as the fixed pool is divided among more beneficiaries
- The Treasury's economic model is violated, as welcome rewards are designed as one-time onboarding incentives
- Overall protocol fairness is compromised

**Severity Justification**: HIGH severity due to:
1. Direct misallocation of economic rewards from a fixed pool
2. Repeatability - single entity can exploit multiple times
3. Minimal cost - only transaction fees for pubkey replacement
4. No special privileges required beyond standard candidate admin rights

## Likelihood Explanation

**Attacker Requirements**:
- Registered candidate with candidate admin address
- Previous mining history (to establish legitimacy)
- Non-mining status during replacement (naturally occurs due to voting dynamics)
- Ability to be elected in future terms

**Attack Feasibility**: HIGH
- Elections cycle regularly (approximately 7-day terms)
- Candidates naturally rotate in/out of active miner sets based on voting
- Pubkey replacement is a legitimate security operation
- The attack is indistinguishable from normal key rotation
- No on-chain validation prevents this pattern

**Detection Difficulty**: The exploitation leaves minimal audit trail since replacement operations are normal and expected for security purposes. Multiple candidates could independently discover and exploit this vulnerability.

## Recommendation

Modify the AEDPoS `RecordCandidateReplacement` method to always notify Treasury of pubkey replacements, regardless of current mining status. The Treasury should track the replacement relationship and transfer `LatestMinedTerm` state accordingly.

Alternative fix: Treasury's `RecordMinerReplacement` should handle cases where the old pubkey has no mining history (when `!input.IsOldPubkeyEvil`), using the replacement map to check if this is a legitimate replacement rather than a new miner.

Add validation in Treasury's `Release` method to cross-reference the Election contract's replacement map before treating a miner with `LatestMinedTerm == 0` as genuinely new.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up a candidate who gets elected and receives welcome rewards in term 1
2. Have the candidate mine successfully through term 1
3. Ensure the candidate is NOT elected in term 2 (not in current round)
4. Call `ReplaceCandidatePubkey` during term 2 with a new pubkey
5. Verify Treasury's `LatestMinedTerm` for new pubkey remains 0
6. Get the new pubkey elected in term 3
7. Call Treasury's `Release` for term 3
8. Verify the new pubkey is added to welcome reward beneficiaries
9. Confirm duplicate rewards granted to the same entity

The test would verify that `State.LatestMinedTerm[newPubkey]` remains 0 after replacement during non-mining periods, and that the new pubkey subsequently appears in the `newElectedMiners` list passed to `UpdateWelcomeRewardWeights`.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L175-176)
```csharp
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L136-137)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L155-156)
```csharp
        maybeNewElectedMiners = maybeNewElectedMiners
            .Where(p => State.LatestMinedTerm[p] == 0 && !GetInitialMinerList().Contains(p)).ToList();
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L585-588)
```csharp
            var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
            State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
            State.LatestMinedTerm.Remove(input.OldPubkey);
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L867-879)
```csharp
            var newBeneficiaries = new AddBeneficiariesInput
            {
                SchemeId = State.VotesWeightRewardHash.Value,
                EndPeriod = previousTermInformation.TermNumber.Add(1)
            };
            foreach (var minerAddress in newElectedMiners.Select(GetProfitsReceiver))
                newBeneficiaries.BeneficiaryShares.Add(new BeneficiaryShare
                {
                    Beneficiary = minerAddress,
                    Shares = 1
                });

            if (newBeneficiaries.BeneficiaryShares.Any()) State.ProfitContract.AddBeneficiaries.Send(newBeneficiaries);
```
