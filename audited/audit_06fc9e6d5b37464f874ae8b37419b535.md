### Title
Banned Candidates Can Rejoin Consensus Through Snapshot Replacement Mechanism

### Summary
The `GetNewestPubkey()` function does not validate that the returned pubkey is not banned, and `GetPreviousTermSnapshotWithNewestPubkey()` fails to remove banned candidates from election snapshots when no valid replacement exists. This allows banned candidates to be selected as alternative miners through `GetMinerReplacementInformation()`, enabling them to rejoin consensus and produce blocks despite being marked as evil nodes.

### Finding Description

**Root Cause:**

The `GetNewestPubkey()` function simply returns the newest pubkey from the replacement mapping without any validation: [1](#0-0) 

This function has no check that the returned pubkey is not banned via `State.BannedPubkeyMap[pubkey]`.

**Critical Flow in `GetPreviousTermSnapshotWithNewestPubkey()`:**

When processing election snapshots, the function attempts to replace banned candidates with their newest pubkeys: [2](#0-1) 

The issue is at lines 152-154: when `GetNewestPubkey(bannedCandidate)` returns the same banned candidate (because no replacement occurred after banning, so the newest pubkey points to itself), the code executes `continue`, which **skips the removal of the banned candidate from the snapshot**. The banned candidate remains in `snapshot.ElectionResult` with their vote count.

**Exploitation in `GetMinerReplacementInformation()`:**

The snapshot containing banned candidates is then used to select alternative miners: [3](#0-2) 

Lines 368-377 select candidates from the snapshot based on vote count, but **there is no check** that `cs.Key` is not in `State.BannedPubkeyMap`. Compare this to lines 387-391 where initial miners ARE filtered by banned status: [4](#0-3) 

**Consensus Integration:**

The consensus contract trusts the Election contract's response and directly adds the alternative candidate as a miner: [5](#0-4) 

Lines 313-338 add the `alternativeCandidatePubkey` to the current round without verifying it's not banned.

### Impact Explanation

**Consensus Integrity Violation:**
A banned candidate (marked as evil node) can rejoin the active miner set and produce blocks. This directly violates the critical invariant that "miner schedule integrity" must be maintained and that banned nodes should never participate in consensus.

**Attack Scenario:**
1. Candidate with pubkey P gains votes and appears in Term N snapshot
2. During Term N+1, P is detected as evil and banned via `UpdateCandidateInformation(P, IsEvilNode=true)`
3. P is removed from the candidate list but remains in the Term N snapshot
4. In Term N+2, when another miner M becomes evil, the system calls `GetMinerReplacementInformation()`
5. The Term N+1 snapshot (retrieved by `GetPreviousTermSnapshotWithNewestPubkey()`) still contains banned candidate P
6. P is selected as an alternative to replace M
7. P rejoins consensus and can produce blocks despite being banned

**Severity:**
This is a HIGH severity issue because:
- It allows malicious actors previously identified as evil to regain consensus participation
- It undermines the entire evil node detection and punishment mechanism
- Banned nodes could continue attacking the network after detection
- Block production rewards would go to banned entities

### Likelihood Explanation

**Attacker Capabilities:**
The attacker only needs to:
1. Have been a candidate with votes in a previous term
2. Get banned (detected as evil or removed via emergency organization)
3. Wait for another miner to be banned in a subsequent term

**Attack Complexity:**
The vulnerability is triggered automatically by the system during normal miner replacement operations. No special actions by the attacker are required beyond getting banned - the flawed snapshot processing will naturally include them in the alternative candidate pool.

**Feasibility:**
- The entry point `GetMinerReplacementInformation()` is called automatically by consensus during round generation
- The preconditions are realistic: evil miners are detected and banned regularly in production blockchain systems
- The execution requires no special permissions or economic cost from the attacker
- The vulnerability is deterministic and will occur whenever a banned candidate exists in a snapshot and another miner needs replacement

**Detection Constraints:**
The banned miner rejoining consensus would be difficult to detect because:
- The miner appears legitimate in the round information
- Only by cross-checking against `BannedPubkeyMap` would the issue be discovered
- No events or logs flag this as abnormal behavior

### Recommendation

**1. Add banned validation in `GetMinerReplacementInformation()`:**

After line 377, add a filter to exclude banned candidates:

```csharp
var maybeNextCandidates = latestSnapshot.ElectionResult
    .Where(cs => !State.InitialMiners.Value.Value.Contains(
        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
    .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
    .Where(cs => !IsPubkeyBanned(cs.Key))  // ADD THIS CHECK
    .OrderByDescending(s => s.Value).ToList();
```

**2. Fix `GetPreviousTermSnapshotWithNewestPubkey()` to remove banned candidates:**

Modify the logic to always remove banned candidates that cannot be replaced:

```csharp
foreach (var bannedCandidate in bannedCandidates)
{
    var newestPubkey = GetNewestPubkey(bannedCandidate);
    // If newest pubkey not exists or same as old pubkey (which is banned), remove the banned candidate
    if (newestPubkey == null || newestPubkey == bannedCandidate || IsPubkeyBanned(newestPubkey))
    {
        snapshot.ElectionResult.Remove(bannedCandidate);
        continue;
    }
    if (snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
    var electionResult = snapshot.ElectionResult[bannedCandidate];
    snapshot.ElectionResult.Add(newestPubkey, electionResult);
    snapshot.ElectionResult.Remove(bannedCandidate);
}
```

**3. Add validation in `GetNewestPubkey()` (defense in depth):**

Return null or throw assertion if the newest pubkey is banned, forcing callers to handle this case explicitly.

**4. Add regression test:**

Create a test case that:
- Registers a candidate P with votes
- Takes a snapshot in Term N
- Bans candidate P  
- Triggers miner replacement in Term N+1
- Asserts that P is NOT selected as an alternative miner

### Proof of Concept

**Initial State:**
- Term 10: Candidate with pubkey `P` has 1000 votes
- Snapshot taken at end of Term 10 includes `P` with 1000 votes
- `State.Candidates.Value` contains `P`

**Step 1 - Ban the candidate:**
```
Call: UpdateCandidateInformation({ Pubkey: P, IsEvilNode: true })
Result: 
- State.BannedPubkeyMap[P] = true
- P removed from State.Candidates
- P removed from miner list
```

**Step 2 - Term 11 proceeds:**
- Snapshot taken at end of Term 11
- P is not in this snapshot (removed from candidates)
- But Term 10 snapshot still contains P

**Step 3 - Another miner M becomes evil in Term 12:**
```
Call: GenerateNextRoundInformation()
→ Calls GetMinerReplacementInformation({ CurrentMinerList: [A, B, C, M, ...] })
  → Calls GetPreviousTermSnapshotWithNewestPubkey() [retrieves Term 11 or 10 snapshot]
    → Finds P in snapshot where IsPubkeyBanned(P) = true
    → Calls GetNewestPubkey(P) which returns P itself
    → Check: P == P → true, executes continue
    → P remains in snapshot.ElectionResult with 1000 votes
  → maybeNextCandidates includes P (no banned check!)
  → Returns: { EvilMinerPubkeys: [M], AlternativeCandidatePubkeys: [P] }
→ Consensus adds P to round.RealTimeMinersInformation
```

**Expected Result:**
Banned candidate `P` should NOT be selectable as alternative miner.

**Actual Result:**
Banned candidate `P` is added to the active miner set and can produce blocks.

**Success Condition:**
Verify that `State.BannedPubkeyMap[P] == true` AND `currentRound.RealTimeMinersInformation.ContainsKey(P) == true`, proving a banned candidate is now an active miner.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L145-161)
```csharp
        var bannedCandidates = snapshot.ElectionResult.Keys.Where(IsPubkeyBanned).ToList();
        Context.LogDebug(() => $"Banned candidates count: {bannedCandidates.Count}");
        if (!bannedCandidates.Any()) return snapshot;
        Context.LogDebug(() => "Getting snapshot and there's miner replaced during current term.");
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
        }

        return snapshot;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L363-380)
```csharp
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-392)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-339)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }
```
