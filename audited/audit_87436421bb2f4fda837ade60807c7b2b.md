### Title
Insufficient Input Validation in ChangeMaximumMinersCountController Allows Permanent DoS of Consensus Parameters

### Summary
The `ChangeMaximumMinersCountController` function lacks proper validation of the `AuthorityInfo` input, allowing a malicious Parliament proposal to set the controller to an invalid state with a zero address or contract's own address as `OwnerAddress`. This permanently disables the ability to adjust maximum miners count and miner increase interval, two critical consensus parameters.

### Finding Description

**Root Cause Location:** [1](#0-0) 

The `ChangeMaximumMinersCountController` function only performs two validations:
1. Sender authorization check via `AssertSenderAddressWith`
2. Organization existence check via `CheckOrganizationExist(input)`

**Critical Missing Validation:**

The function trusts the `input.ContractAddress` without verifying it's a legitimate governance contract (Parliament, Association, or Referendum). The `CheckOrganizationExist` implementation makes a cross-contract call to whatever address is provided: [2](#0-1) 

This means an attacker can:
1. Deploy a malicious contract with a `ValidateOrganizationExist` method that always returns `true`
2. Create a Parliament proposal calling `ChangeMaximumMinersCountController` with:
   - `input.ContractAddress` = malicious contract
   - `input.OwnerAddress` = zero address (0x00...00)
3. Once approved and executed, the validation passes because the malicious contract returns `true`

**Why Protections Fail:**

The `ValidateOrganizationExist` method in legitimate governance contracts simply checks state existence: [3](#0-2) 

But when `input.ContractAddress` is attacker-controlled, this check is meaningless.

**Correct Pattern Exists in Codebase:**

The CrossChain contract demonstrates proper validation by explicitly checking the contract address: [4](#0-3) 

### Impact Explanation

**Operational Impact - Permanent DoS:**

Once the controller is set to an invalid configuration (e.g., `OwnerAddress` = zero address), the following critical functions become permanently unusable:

1. **SetMaximumMinersCount** - Line 17 checks `Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress`. Since `Context.Sender` can never be a zero address in AElf's execution model, this assertion will always fail. [5](#0-4) 

2. **SetMinerIncreaseInterval** - Same authorization check at line 59: [6](#0-5) 

**Affected Parties:**
- The entire blockchain network loses ability to adjust consensus parameters
- No recovery mechanism exists - the controller cannot be reset
- Maximum miners count and miner increase interval become frozen at current values

**Severity:** HIGH - This breaks critical consensus governance with no recovery path.

### Likelihood Explanation

**Preconditions:**
- Requires a malicious proposal to pass Parliament approval (2/3+ miner votes)
- Attacker must deploy a malicious contract first

**Attack Complexity: MEDIUM**

The attack is feasible through:
1. **Social Engineering:** Miners may not carefully review every proposal, especially if disguised as a routine governance change
2. **Insider Threat:** A compromised or malicious miner with proposal privileges
3. **Batch Proposal Confusion:** Hiding the malicious call among legitimate governance updates

**Execution Practicality:**

The attack is fully executable under AElf contract semantics:
- Attacker can deploy arbitrary contracts with custom logic
- Parliament proposals can call any contract method with any parameters
- No runtime validation of the governance contract address exists

**Detection Constraints:**

The malicious proposal would look superficially similar to legitimate controller changes. The key difference (malicious contract address) requires careful inspection of the `ContractAddress` field to detect.

**Overall Likelihood: MEDIUM** - While requiring Parliament approval raises the bar, the lack of input validation makes the attack technically straightforward once social/organizational conditions are met.

### Recommendation

**Immediate Fix - Add Strict Contract Address Validation:**

Modify `ChangeMaximumMinersCountController` to validate the governance contract address:

```csharp
public override Empty ChangeMaximumMinersCountController(AuthorityInfo input)
{
    RequiredMaximumMinersCountControllerSet();
    AssertSenderAddressWith(State.MaximumMinersCountController.Value.OwnerAddress);
    
    // NEW: Validate contract address is Parliament (or other authorized governance contract)
    EnsureParliamentContractAddressSet();
    Assert(input.ContractAddress == State.ParliamentContract.Value, 
        "Invalid controller contract address.");
    
    // NEW: Validate organization with Parliament-specific checks
    Assert(ValidateParliamentOrganization(input.OwnerAddress), 
        "Invalid authority input.");

    State.MaximumMinersCountController.Value = input;
    return new Empty();
}

private bool ValidateParliamentOrganization(Address organizationAddress)
{
    var organization = State.ParliamentContract.GetOrganization.Call(organizationAddress);
    return organization != null && organization.ParliamentMemberProposingAllowed;
}
```

**Additional Safeguards:**

1. Add explicit zero address validation:
```csharp
Assert(input.OwnerAddress != null && !input.OwnerAddress.Value.IsNullOrEmpty(), 
    "Owner address cannot be null or empty.");
```

2. Prevent self-reference:
```csharp
Assert(input.OwnerAddress != Context.Self, 
    "Owner address cannot be the contract itself.");
```

**Test Cases to Add:**

1. Test attempting to change controller with non-Parliament contract address (should fail)
2. Test attempting to set zero address as OwnerAddress (should fail)
3. Test attempting to set contract's own address as OwnerAddress (should fail)
4. Test legitimate controller change with valid Parliament organization (should succeed)

### Proof of Concept

**Initial State:**
- AEDPoS contract initialized
- MaximumMinersCountController set to Parliament default organization

**Attack Steps:**

1. **Deploy Malicious Contract:**
```csharp
public class MaliciousGovernance : ContractBase {
    public override BoolValue ValidateOrganizationExist(Address input) {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```

2. **Create Parliament Proposal:**
Create proposal to call `ChangeMaximumMinersCountController` with:
    - `ToAddress`: AEDPoS consensus contract
    - `ContractMethodName`: "ChangeMaximumMinersCountController"
    - `Params`: 
  - `OwnerAddress`: 0x0000000000000000000000000000000000000000 (zero address)
  - `ContractAddress`: [MaliciousGovernance contract address]

3. **Get Parliament Approval:**
Obtain 2/3+ miner approvals through social engineering or insider access

4. **Release Proposal:**
Execute the approved proposal

**Expected Result:**
Proposal execution should fail with "Invalid authority input" or "Invalid controller contract address"

**Actual Result:**
- Proposal executes successfully
- `State.MaximumMinersCountController.Value` is set to `{OwnerAddress: 0x00..00, ContractAddress: MaliciousGovernance}`
- All subsequent calls to `SetMaximumMinersCount` fail with "No permission to set max miners count"
- All subsequent calls to `SetMinerIncreaseInterval` fail with "No permission to set miner increase interval"
- No recovery mechanism exists - consensus parameters are permanently locked

**Success Condition:**
The controller is permanently broken, proven by the inability to call either `SetMaximumMinersCount` or `SetMinerIncreaseInterval` from any address including legitimate Parliament proposals.

### Notes

This vulnerability exists because the AEDPoS contract follows a generic `CheckOrganizationExist` pattern used across many contracts, but doesn't add the additional contract address validation that security-critical operations require. The CrossChain contract shows this pattern is known in the codebase but wasn't applied consistently. The severity is elevated because there is no recovery mechanism - once the controller is broken, it cannot be reset without a contract upgrade.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L45-54)
```csharp
    public override Empty ChangeMaximumMinersCountController(AuthorityInfo input)
    {
        RequiredMaximumMinersCountControllerSet();
        AssertSenderAddressWith(State.MaximumMinersCountController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MaximumMinersCountController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L83-88)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L61-74)
```csharp
    public override Empty ChangeCrossChainIndexingController(AuthorityInfo input)
    {
        AssertCrossChainIndexingControllerAuthority(Context.Sender);
        SetContractStateRequired(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);
        Assert(
            input.ContractAddress == State.ParliamentContract.Value &&
            ValidateParliamentOrganization(input.OwnerAddress), "Invalid authority input.");
        State.CrossChainIndexingController.Value = input;
        Context.Fire(new CrossChainIndexingControllerChanged
        {
            AuthorityInfo = input
        });
        return new Empty();
    }
```
