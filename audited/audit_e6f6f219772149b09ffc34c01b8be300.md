### Title
Case-Sensitive Pubkey Comparison Causes Valid Miner Rejection After Candidate Replacement

### Summary
When a candidate's public key is replaced through `ReplaceCandidatePubkey`, the new pubkey string is not normalized to lowercase before being stored in `RealTimeMinersInformation`. However, during block production and validation, pubkeys are always converted to lowercase hex via `ToHex()`. This case mismatch causes the `MiningPermissionValidationProvider` to incorrectly reject valid miners when performing case-sensitive string comparisons, preventing them from producing blocks.

### Finding Description

**Root Cause:**

The vulnerability stems from inconsistent case handling of hex-encoded public keys across the candidate replacement and consensus validation flows:

1. **Normal Round Generation**: Pubkeys are stored in `RealTimeMinersInformation` using `ToHex()`, which produces lowercase hex characters (a-f). [1](#0-0) 

The `ToHex()` implementation uses `b + 0x37 + 0x20` for values 10-15, which produces lowercase 'a'-'f' (ASCII 97-102). [2](#0-1) 

2. **Candidate Replacement Flow**: When `ReplaceCandidatePubkey` is called, the input strings are validated as valid hex but NOT normalized to lowercase. The original user-provided strings are passed directly to the consensus contract. [3](#0-2) 

3. **Consensus Update**: The `RecordCandidateReplacement` method uses the input strings AS-IS as dictionary keys in `RealTimeMinersInformation`, without any case normalization. [4](#0-3) 

4. **Block Production**: When a miner requests consensus extra data to produce a block, their pubkey is converted to lowercase via `ToHex()`. [5](#0-4) 

This lowercase pubkey is then used to access `RealTimeMinersInformation`, which will fail if the key was stored with uppercase characters. [6](#0-5) 

5. **Validation Failure**: The `MiningPermissionValidationProvider` performs case-sensitive comparison using `Contains()` on the string keys. [7](#0-6) 

The `SenderPubkey` property always produces lowercase via `ToHex()`. [8](#0-7) 

### Impact Explanation

**Concrete Harm:**
- A valid miner whose pubkey was replaced with an uppercase or mixed-case hex string becomes unable to produce blocks
- The miner cannot retrieve consensus extra data (fails at dictionary access)
- Even if consensus data is somehow obtained, the block validation will reject it as the pubkey won't be found in the miner list

**Affected Parties:**
- The specific miner whose pubkey was replaced with non-lowercase hex encoding
- Network consensus health if this affects multiple miners or critical miners

**Severity Justification (Low):**
While this directly impacts consensus operation, the severity is Low because:
- Requires candidate admin role (semi-trusted position)
- Only affects one miner at a time
- Easily detectable (miner immediately cannot produce blocks)
- Easily recoverable (call `ReplaceCandidatePubkey` again with correct lowercase hex)
- More likely to occur accidentally than maliciously (user error with manual hex input)

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a candidate admin for an active miner
- Must provide uppercase or mixed-case hex string for `NewPubkey` parameter

**Attack Complexity:**
- Very low - single transaction call with uppercase hex string
- No complex state manipulation or timing requirements

**Feasibility Conditions:**
- Candidate admin uses manual input instead of SDK-generated values
- SDK tooling typically generates lowercase hex, so requires intentional deviation or direct API call

**Detection/Operational Constraints:**
- Immediately detectable when miner attempts block production
- Blockchain monitoring would show miner suddenly stops producing blocks
- Easy to diagnose via consensus contract state inspection

**Probability Reasoning:**
- More likely accidental than malicious (user error)
- Low probability if standard tooling is used
- Could occur during manual administrative operations or custom integrations

### Recommendation

**Code-Level Mitigation:**

1. Normalize pubkey strings to lowercase in `PerformReplacement` before sending to consensus contract:
```csharp
State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
{
    OldPubkey = oldPubkey.ToLower(),
    NewPubkey = newPubkey.ToLower()
});
``` [3](#0-2) 

2. Alternatively, normalize in `RecordCandidateReplacement` itself:
```csharp
var normalizedOldPubkey = input.OldPubkey.ToLower();
var normalizedNewPubkey = input.NewPubkey.ToLower();
// Use normalized values throughout
``` [9](#0-8) 

3. Add validation to ensure hex strings are lowercase in `ReplaceCandidatePubkey`:
```csharp
Assert(input.OldPubkey == input.OldPubkey.ToLower(), "Pubkey must be lowercase hex.");
Assert(input.NewPubkey == input.NewPubkey.ToLower(), "Pubkey must be lowercase hex.");
```

**Test Cases:**
- Test replacing candidate pubkey with uppercase hex string
- Verify miner can still produce blocks after replacement
- Test mixed-case hex string replacement
- Verify `RealTimeMinersInformation` keys are always lowercase after replacement

### Proof of Concept

**Initial State:**
1. Miner "Alice" has pubkey "abc123def456" (lowercase) in current round's `RealTimeMinersInformation`
2. Alice is an active miner in the consensus round

**Attack Sequence:**

**Step 1**: Candidate admin calls `ReplaceCandidatePubkey`:
```
Input: {
    OldPubkey: "abc123def456",
    NewPubkey: "ABC123DEF456"  // Uppercase
}
``` [10](#0-9) 

**Step 2**: Election contract calls `RecordCandidateReplacement`:
```
Input: {
    OldPubkey: "abc123def456",
    NewPubkey: "ABC123DEF456"  // Not normalized
}
``` [3](#0-2) 

**Step 3**: Consensus contract updates `RealTimeMinersInformation`:
- Removes key "abc123def456"
- Adds key "ABC123DEF456" with miner information [11](#0-10) 

**Step 4**: Alice attempts to produce a block:
- Miner's pubkey bytes are converted: `publicKeyBytes.ToHex()` → "abc123def456" (lowercase)
- Contract tries to access: `RealTimeMinersInformation["abc123def456"]`
- **Fails**: Key not found (key is stored as "ABC123DEF456") [5](#0-4) 

**Step 5**: Validation also fails:
- `SenderPubkey` property returns "abc123def456" (lowercase)
- Check: `RealTimeMinersInformation.Keys.Contains("abc123def456")` → false
- **Result**: Valid miner rejected [7](#0-6) 

**Expected Result**: Miner Alice produces block successfully

**Actual Result**: Alice cannot produce blocks due to case mismatch

**Success Condition**: The vulnerability is confirmed when a miner with a replaced pubkey using uppercase hex cannot produce blocks, but the same miner with lowercase hex can.

### Citations

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L22-29)
```csharp
            for (int bx = 0, cx = offset; bx < bytes.Length; ++bx, ++cx)
            {
                b = (byte)(bytes[bx] >> 4);
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
            }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Extensions/MinerListExtensions.cs (L15-37)
```csharp
        var sortedMiners =
            (from obj in miners.Pubkeys.Distinct()
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i * miningInterval + miningInterval).ToTimestamp();
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-143)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L22-23)
```csharp
        var publicKeyBytes = triggerInformation.Pubkey;
        var pubkey = publicKeyBytes.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L58-62)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L17-17)
```csharp
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();
```
