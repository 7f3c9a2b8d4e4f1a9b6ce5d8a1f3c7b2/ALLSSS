### Title
Election Deposit Refund Mismatch After Contract Upgrade Due to Hard-Coded Constant

### Summary
The `LockTokenForElection` constant is used directly in both lock (AnnounceElection) and unlock (QuitElection) operations without storing the actual locked amount. If the contract is upgraded with a different constant value, candidates who locked tokens under the old value will receive incorrect refunds under the new value, leading to either complete denial of service (if constant increases) or permanent fund loss (if constant decreases).

### Finding Description

The vulnerability exists in the Election contract's candidate deposit mechanism across three key code locations:

**Lock Operation:** The `LockCandidateNativeToken()` method locks exactly `ElectionContractConstants.LockTokenForElection` tokens when a candidate announces election. [1](#0-0) 

**Constant Definition:** The constant is defined as a compile-time value of 100,000 tokens (with 8 decimals). [2](#0-1) 

**Unlock Operation:** The `QuitElection` method retrieves the lock ID from storage but reads the constant value again to determine the unlock amount. [3](#0-2) 

**Root Cause:** The contract only stores the `AnnouncementTransactionId` in `CandidateInformation`, not the actual locked amount. [4](#0-3) 

**Why Protections Fail:** The contract state has no field to store the locked deposit amount, and C# constants are compile-time values embedded in bytecode that change with contract upgrades. [5](#0-4) 

**Balance Validation:** When `TransferFrom` attempts to transfer more tokens than exist in the virtual address, the `ModifyBalance` method will assert with "Insufficient balance" error. [6](#0-5) 

### Impact Explanation

**Scenario 1 - Constant Increases (DoS Impact):**
If the constant increases from 100,000 to 200,000 tokens:
- All existing candidates who locked 100,000 tokens cannot quit election
- `QuitElection` attempts to unlock 200,000 tokens from virtual addresses containing only 100,000
- Transaction fails with "Insufficient balance" assertion
- Complete denial of service for all pre-upgrade candidates

**Scenario 2 - Constant Decreases (Direct Fund Loss):**
If the constant decreases from 100,000 to 50,000 tokens:
- Candidates who locked 100,000 tokens receive only 50,000 tokens back
- Remaining 50,000 tokens are permanently locked in the virtual address
- Direct fund loss of (old_value - new_value) per candidate

**Quantified Impact:** With 100 active candidates and a 50,000 token decrease, total permanent loss would be 5,000,000 tokens. The test suite confirms the refund amount is expected to match the constant exactly. [7](#0-6) 

**Affected Parties:** All candidates who announced election before the contract upgrade are affected. The sponsor may be the recipient of the refund if one exists. [8](#0-7) 

### Likelihood Explanation

**Attacker Capabilities:** No attacker is needed - this is a protocol design flaw triggered by legitimate contract upgrades through governance.

**Attack Complexity:** None - the issue manifests automatically when:
1. Contract is upgraded via the standard governance process with a modified constant
2. Any pre-upgrade candidate attempts to quit election

**Feasibility Conditions:** 
- Contract upgrades are normal governance operations in AElf
- C# constants are compile-time values that change between contract versions
- No migration logic exists to handle constant value changes

**Practical Scenario:** If developers decide to adjust the election deposit requirement (e.g., increase due to token price changes or decrease to lower barriers), updating the constant would seem like the natural approach, but it would immediately break all existing candidate deposits.

**Probability:** HIGH - Contract upgrades are routine maintenance operations, and the constant value could legitimately need adjustment over the protocol's lifetime.

### Recommendation

**Code-Level Mitigation:**
1. Store the actual locked amount in `CandidateInformation` message:
```protobuf
message CandidateInformation {
    // ... existing fields ...
    int64 locked_amount = 8; // Add this field
}
```

2. Modify `AnnounceElection` to store the locked amount:
```csharp
candidateInformation.LockedAmount = ElectionContractConstants.LockTokenForElection;
```

3. Modify `QuitElection` to use the stored amount:
```csharp
Amount = candidateInformation.LockedAmount, // Instead of constant
```

**Invariant Checks:**
- Add assertion in `QuitElection` to verify virtual address balance >= stored locked amount
- Add contract initialization check that constant hasn't changed from previous version without migration

**Test Cases:**
1. Test contract upgrade with increased constant value, verify pre-upgrade candidates can still quit with original amount
2. Test contract upgrade with decreased constant value, verify no funds are locked permanently
3. Add integration test simulating contract upgrade scenario with active candidates

### Proof of Concept

**Initial State:**
- Election contract V1 deployed with `LockTokenForElection = 100_000_00000000`
- Candidate Alice calls `AnnounceElection`, locking 100,000 tokens
- Virtual address (derived from transaction ID) now holds 100,000 tokens
- `CandidateInformation.AnnouncementTransactionId` stores the lock ID

**Contract Upgrade:**
- Governance approves contract upgrade to V2
- V2 has `LockTokenForElection = 200_000_00000000` (increased to 200,000)
- V2 is deployed, replacing V1

**Exploitation (Unintentional):**
- Alice calls `QuitElection` on V2 contract
- V2 reads `ElectionContractConstants.LockTokenForElection = 200_000_00000000`
- V2 attempts `TransferFrom(virtualAddress, alice, 200_000_00000000)`
- Virtual address only has 100,000 tokens
- `ModifyBalance` detects insufficient balance (need 200k, have 100k)
- Transaction reverts with "Insufficient balance" error

**Expected Result:** Alice receives 100,000 tokens back (amount originally locked)

**Actual Result:** Transaction fails, Alice cannot retrieve deposit, permanent DoS

**Success Condition:** The vulnerability is confirmed if candidates cannot quit election after contract upgrade with modified constant, or if they receive incorrect refund amounts.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L140-140)
```csharp
        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L239-249)
```csharp
        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L3-6)
```csharp
public static class ElectionContractConstants
{
    public const long LockTokenForElection = 100_000_00000000;

```

**File:** protobuf/election_contract.proto (L365-380)
```text
message CandidateInformation {
    // Candidateâ€™s public key.
    string pubkey = 1;
    // The number of terms that the candidate is elected.
    repeated int64 terms = 2;
    // The number of blocks the candidate has produced.
    int64 produced_blocks = 3;
    // The time slot for which the candidate failed to produce blocks.
    int64 missed_time_slots = 4;
    // The count of continual appointment.
    int64 continual_appointment_count = 5;
    // The transaction id when the candidate announced.
    aelf.Hash announcement_transaction_id = 6;
    // Indicate whether the candidate can be elected in the current term.
    bool is_current_candidate = 7;
}
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L23-23)
```csharp
    public MappedState<string, CandidateInformation> CandidateInformationMap { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ElectionTests.cs (L146-150)
```csharp
        foreach (var quitCandidate in quitCandidates)
        {
            var balance = await GetNativeTokenBalance(quitCandidate.PublicKey);
            balance.ShouldBe(balancesBeforeQuiting[quitCandidate] + ElectionContractConstants.LockTokenForElection);
        }
```
