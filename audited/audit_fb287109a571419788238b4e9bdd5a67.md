### Title
User Contract Proposal Identity Masking Undermines Governance Accountability

### Summary
The `SendUserContractProposal` function sets `OriginProposer` to `Context.Self` (Genesis contract) instead of the actual user, masking the real proposer's identity in governance contract records. This creates an accountability gap where external observers cannot identify who proposed potentially malicious user contracts during the code check phase, enabling bad actors to probe the system without public attribution.

### Finding Description

In `SendUserContractProposal`, the system creates a code check proposal for user contract deployments/updates: [1](#0-0) 

The real user (`Context.Sender`) is stored only as `Author` in the Genesis contract's internal state (line 321), while `OriginProposer` is set to `Context.Self` (Genesis contract) in line 336. This `OriginProposer` value is what gets recorded in the governance contract (Parliament/Association): [2](#0-1) 

When the Parliament contract creates the proposal, it sets `Proposer = Context.Sender`, which in this case is the Genesis contract calling via `CreateProposalBySystemContract`: [3](#0-2) 

The critical issue is that the `Author` field exists only in Genesis contract's `ContractProposingInputMap`: [4](#0-3) 

However, there is **no public view method** to query this mapping. The Genesis contract's RPC interface does not expose any method to retrieve `ContractProposingInput` data: [5](#0-4) 

Furthermore, the `CodeCheckRequired` event emitted when a user contract is proposed does not include proposer information: [6](#0-5) 

This contrasts with the normal contract deployment flow where `OriginProposer = Context.Sender` (the real user): [7](#0-6) 

### Impact Explanation

**Harm Caused:**
- External observers (users, security researchers, dApp developers) querying Parliament/Association proposals see only the Genesis contract as the proposer, not the real user
- If a malicious user contract proposal is submitted but rejected during code check, there is no public record of who proposed it
- Bad actors can repeatedly submit malicious contracts to probe the system without public attribution or reputational damage
- The deterrent effect of public accountability is eliminated for user contract proposals during the code check phase
- Governance transparency is significantly reduced compared to regular contract deployments

**Who is Affected:**
- Ecosystem participants relying on governance transparency
- Security researchers attempting to track malicious proposers
- The broader community that depends on accountability to deter bad behavior

**Severity Justification (Medium):**
- Does not directly enable fund theft or unauthorized contract execution (miners must still approve)
- Does significantly undermine governance principles and accountability mechanisms
- Creates an information asymmetry that favors malicious actors
- While the `Author` is eventually revealed upon successful deployment, rejected proposals leave no public trace of the proposer

### Likelihood Explanation

**Attacker Capabilities:**
- Any user can call `DeployUserSmartContract` or `UpdateUserSmartContract` (public methods on side chains)
- No special privileges or resources required beyond ability to transact

**Attack Complexity:**
- Trivial: simply call the public methods with malicious contract code
- The identity masking happens automatically due to the implementation

**Feasibility Conditions:**
- Side chain environment where user contract deployment is enabled
- User must be in Parliament whitelist on public side chains: [8](#0-7) 

**Detection/Operational Constraints:**
- External observers have no way to detect the real proposer during code check phase
- Only internal Genesis contract state contains the `Author` field
- Miners can see the code but public queries reveal only Genesis as proposer

**Probability:**
- High likelihood of exploitation for probing malicious contracts
- Reduces risk for bad actors, making repeated attempts more attractive

### Recommendation

**Code-Level Mitigation:**

1. Add a public view method to query `ContractProposingInput` by hash:

```protobuf
rpc GetContractProposingInput (aelf.Hash) returns (ContractProposingInput) {
    option (aelf.is_view) = true;
}
```

2. Include the real proposer in the `CodeCheckRequired` event:

```protobuf
message CodeCheckRequired {
    option (aelf.is_event) = true;
    bytes code = 1;
    aelf.Hash proposed_contract_input_hash = 2;
    sint32 category = 3;
    bool is_system_contract = 4;
    bool is_user_contract = 5;
    aelf.Address proposer = 6; // Add this field
}
```

3. Consider passing the real user as `OriginProposer` while maintaining Genesis as the caller for authorization purposes, or add a separate `ActualProposer` field in `CreateProposalBySystemContractInput`.

**Invariant Checks:**
- Ensure all proposals (user or regular) maintain traceability to the actual initiating user
- Governance proposal records should always allow external queries to identify the real proposer

**Test Cases:**
- Verify that external observers can query and retrieve the real proposer for user contract proposals
- Test that rejected user contract proposals maintain an auditable trail to the original proposer
- Ensure events expose sufficient information for off-chain monitoring and accountability

### Proof of Concept

**Initial State:**
- Side chain with user contract deployment enabled
- User address: `UserA`
- Genesis contract address: `GenesisContract`
- Parliament contract with code check controller configured

**Exploitation Steps:**

1. `UserA` calls `DeployUserSmartContract` with malicious contract code
2. `SendUserContractProposal` executes:
   - Stores `Author = UserA` in Genesis contract's internal state
   - Creates proposal via `CreateProposalBySystemContractInput` with `OriginProposer = GenesisContract`
3. Parliament contract receives the proposal and stores `Proposer = GenesisContract` (since `Context.Sender` is Genesis)
4. External observer queries Parliament's `GetProposal`:
   - **Expected**: Should see `Proposer = UserA`
   - **Actual**: Sees `Proposer = GenesisContract`
5. Miners reject the malicious proposal
6. External observer attempts to identify who proposed the malicious code:
   - **Expected**: Should be able to query and find `UserA`
   - **Actual**: No public method exists to retrieve the `Author` field; `UserA` remains anonymous

**Success Condition:**
The real proposer (`UserA`) successfully avoids public attribution for a malicious contract proposal that was rejected, demonstrating the accountability gap.

### Notes

This vulnerability represents a design choice that prioritizes a simplified user contract deployment flow over governance transparency. While the `Author` field is preserved internally and eventually revealed upon successful deployment, the lack of public queryability during the proposal phase creates a significant accountability gap. The issue is particularly concerning for rejected proposals, where the proposer's identity is effectively lost to external observers, undermining the deterrent effect of public accountability in the governance system.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L312-342)
```csharp
    private void SendUserContractProposal(Hash proposingInputHash, string releaseMethodName, ByteString @params)
    {
        var registered = State.ContractProposingInputMap[proposingInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var proposedInfo = new ContractProposingInput
        {
            Proposer = Context.Self,
            Status = ContractProposingInputStatus.CodeCheckProposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod()),
            Author = Context.Sender
        };
        State.ContractProposingInputMap[proposingInputHash] = proposedInfo;

        var codeCheckController = State.CodeCheckController.Value;
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName = releaseMethodName,
                Params = @params,
                OrganizationAddress = codeCheckController.OwnerAddress,
                ExpiredTime = proposedInfo.ExpiredTime
            },
            OriginProposer = Context.Self
        };

        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L68-76)
```csharp
    public override Hash CreateProposalBySystemContract(CreateProposalBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Unauthorized to propose.");
        AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);

        var proposalId = CreateNewProposal(input.ProposalInput);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L225-253)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** protobuf/basic_contract_zero.proto (L17-61)
```text
service BasicContractZero {
    option (aelf.csharp_state) = "AElf.Contracts.Genesis.BasicContractZeroState";
    
    // Initialize the genesis contract.
    rpc Initialize (InitializeInput) returns (google.protobuf.Empty) {
    }
    
    // Set initial controller address for CodeCheckController and ContractDeploymentController.
    rpc SetInitialControllerAddress (aelf.Address) returns (google.protobuf.Empty) {
    }
    
    // Modify the contract deployment controller authority. 
    // Note: Only old controller has permission to do this.
    rpc ChangeContractDeploymentController (AuthorityInfo) returns (google.protobuf.Empty) {
    } 
    
    // Modify the contract code check controller authority. 
    // Note: Only old controller has permission to do this.
    rpc ChangeCodeCheckController (AuthorityInfo) returns (google.protobuf.Empty) {
    }
    
    rpc SetContractProposalExpirationTimePeriod(SetContractProposalExpirationTimePeriodInput) returns(google.protobuf.Empty){
    }

    rpc SetCodeCheckProposalExpirationTimePeriod(google.protobuf.Int32Value) returns(google.protobuf.Empty){
    }
    
    // Query the ContractDeploymentController authority info.
    rpc GetContractDeploymentController (google.protobuf.Empty) returns (AuthorityInfo) {
        option (aelf.is_view) = true;
    }
    
    // Query the CodeCheckController authority info.
    rpc GetCodeCheckController(google.protobuf.Empty) returns (AuthorityInfo){
        option (aelf.is_view) = true;
    }
    
    rpc GetContractProposalExpirationTimePeriod(google.protobuf.Empty) returns (google.protobuf.Int32Value){
        option (aelf.is_view) = true;
    }

    rpc GetCodeCheckProposalExpirationTimePeriod(google.protobuf.Empty) returns (google.protobuf.Int32Value){
        option (aelf.is_view) = true;
    }
}
```

**File:** protobuf/basic_contract_zero.proto (L68-77)
```text
message ContractProposingInput{
    // The address of proposer for contract deployment/update.
    aelf.Address proposer = 1;
    // The status of proposal.
    ContractProposingInputStatus status = 2;
    // The expiration time of proposal.
    google.protobuf.Timestamp expired_time = 3;
    // The author of the contract.
    aelf.Address author = 4;
}
```

**File:** protobuf/acs0.proto (L248-261)
```text
message CodeCheckRequired
{
    option (aelf.is_event) = true;
    // The byte array of the contract code.
    bytes code = 1;
    // The id of the proposed contract.
    aelf.Hash proposed_contract_input_hash = 2;
    // The category of contract code(0: C#).
    sint32 category = 3;
    // Indicates if the contract is the system contract.
    bool is_system_contract = 4;
    // Indicates if the contract is the user contract.
    bool is_user_contract = 5;
}
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L143-165)
```csharp
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName =
                    nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.ProposeContractCodeCheck),
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(DeploySmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = input.Category,
                    IsSystemContract = false
                }.ToByteString(),
                OrganizationAddress = State.ContractDeploymentController.Value.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
            },
            OriginProposer = Context.Sender
        };
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput.ToByteString());
```
