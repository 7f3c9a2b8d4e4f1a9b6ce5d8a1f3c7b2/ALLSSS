### Title
Token Contract Upgrade Enables Fee Accumulation Without Burning/Distribution

### Summary
When the Token contract is upgraded and changes its `IsTokenAvailableForMethodFee` logic or token burnability properties, previously set method fees remain valid in state without revalidation. This causes the fee burning mechanism to silently fail, resulting in permanent accumulation of collected fees that should have been burned or distributed to the Treasury, breaking the protocol's tokenomics model.

### Finding Description

**Exact Code Locations:**

The vulnerability exists in the interaction between fee validation at setup time and fee burning at execution time:

1. **Fee Setting Validation** [1](#0-0) 
   - `AssertValidToken` validates tokens only once during `SetMethodFee` by calling `IsTokenAvailableForMethodFee`
   - Fees are stored in state without any versioning or dependency tracking

2. **Token Validation Logic** [2](#0-1) 
   - `IsTokenAvailableForMethodFee` checks if `tokenInfo.IsBurnable` is true
   - This logic can change via Token contract upgrade

3. **Silent Failure in Fee Burning** [3](#0-2) 
   - `TransferTransactionFeesToFeeReceiver` silently returns without burning if token is not burnable
   - No error thrown, no event emitted, fees remain trapped

4. **Token Contract Upgrade Mechanism** [4](#0-3) 
   - Token contract can be upgraded via governance proposal system
   - Contract state preserved but code logic changes

**Root Cause:**

The root cause is a time-of-check-time-of-use (TOCTOU) vulnerability where:
- Fee token validity is checked at fee configuration time [5](#0-4) 
- No revalidation occurs when fees are charged [6](#0-5) 
- Token contract upgrade can invalidate previously valid assumptions about token properties
- Fee burning fails silently without reverting the transaction

**Why Existing Protections Fail:**

The system lacks cross-contract upgrade coordination. When the Token contract is upgraded via [7](#0-6) , all dependent contracts continue using cached fee configurations that may no longer satisfy current validation rules.

### Impact Explanation

**Direct Fund Impact:**
- All transaction fees collected in affected tokens become permanently trapped in the MultiToken contract
- Fees accumulate without limit as the silent return prevents burning/distribution
- No recovery mechanism exists to reclaim or redistribute trapped funds

**Tokenomics Breakdown:**
- The designed fee mechanism fails completely: [8](#0-7) 
- 10% should be burned to reduce supply
- 90% should go to Treasury dividend pool on mainchain or fee receiver on sidechain
- Instead, 100% accumulates indefinitely

**System-Wide Affect:**
All system contracts implementing ACS1 are vulnerable to the same issue, including Parliament, Association, Referendum, Treasury, Election, Consensus, CrossChain, Profit, TokenHolder, TokenConverter, Configuration, and Vote contracts. Each has identical validation patterns. [9](#0-8) 

**Severity Justification:**
HIGH severity due to permanent fund loss, complete breakdown of critical tokenomics mechanism, and system-wide impact affecting all governance and economic operations.

### Likelihood Explanation

**Governance Upgrade Path:**
Token contract upgrades follow the standard AElf governance process requiring proposal approval through Parliament or other authorization contracts. While this requires governance participation, it is a designed and expected operational activity.

**Legitimate Scenarios:**
- Bug fixes in Token contract validation logic
- Feature additions that modify `IsTokenAvailableForMethodFee` implementation
- Security patches that change token property checks
- Optimization updates that alter validation paths

**No Safeguards:**
The system has no mechanisms to:
- Detect when Token contract upgrade invalidates existing fee configurations
- Alert when fee burning silently fails
- Force revalidation of cached fee settings
- Prevent upgrade if it would break fee collection

**Silent Failure Mode:**
The vulnerability manifests through early return rather than explicit revert [10](#0-9) , making it difficult to detect and debug in production.

**Probability Assessment:**
MEDIUM-HIGH - While requiring governance approval for Token contract upgrade, such upgrades are legitimate operational events that will occur during the protocol's lifecycle. The lack of safeguards means any upgrade touching validation logic risks triggering this vulnerability.

### Recommendation

**Immediate Mitigations:**

1. **Replace Silent Failure with Assertion** in `TransferTransactionFeesToFeeReceiver`:
   ```
   Assert(tokenInfo.IsBurnable, $"Token {symbol} is not burnable, cannot process fee burning");
   ```
   This converts silent failure to explicit revert, preventing fee accumulation.

2. **Add Revalidation in Fee Charging** [11](#0-10) :
   Verify token still satisfies `IsTokenAvailableForMethodFee` before charging fees.

3. **Implement Emergency Recovery Mechanism:**
   Add authorized method to transfer trapped fees or force burn with override flag.

**Long-term Solutions:**

4. **Version-Aware Fee Configuration:**
   Store Token contract version hash with each fee configuration and invalidate on upgrade.

5. **Upgrade Coordination Hooks:**
   Add pre-upgrade validation in Genesis contract to check if upgrade would break existing fee configurations.

6. **Monitoring and Alerting:**
   Emit events when fee burning fails and implement off-chain monitoring.

**Test Coverage:**

Add integration tests covering:
- Token contract upgrade with validation logic changes
- Fee charging after upgrade with non-burnable tokens
- Fee burning failure scenarios
- Recovery mechanisms for trapped fees

### Proof of Concept

**Initial State:**
1. Token "EXAMPLE" exists with `IsBurnable = true` [12](#0-11) 
2. EconomicContract.SetMethodFee configures fees in "EXAMPLE" token
3. Validation passes via `IsTokenAvailableForMethodFee` check [13](#0-12) 

**Exploit Sequence:**
1. Governance proposes Token contract upgrade via `ProposeUpdateContract` [4](#0-3) 
2. Proposal approved and executed via `UpdateSmartContract` [14](#0-13) 
3. Upgraded Token contract changes validation logic or "EXAMPLE" token becomes non-burnable
4. User transactions continue being charged fees in "EXAMPLE" token [15](#0-14) 
5. Miner calls `ClaimTransactionFees` with accumulated fees [16](#0-15) 
6. `TransferTransactionFeesToFeeReceiver` called with "EXAMPLE" fees [17](#0-16) 
7. Check `if (!tokenInfo.IsBurnable) return;` triggers early exit [10](#0-9) 

**Expected vs Actual:**
- **Expected**: Fees burned (10%) and transferred to Treasury (90%), `Burned` event emitted
- **Actual**: Function returns silently, fees remain in contract, no events emitted, balance accumulates

**Success Condition:**
MultiToken contract balance of "EXAMPLE" token continuously increases without corresponding `Burned` or `DonateInput` events, proving fees are trapped indefinitely.

### Citations

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L13-17)
```csharp
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;
```

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L78-87)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L252-257)
```csharp
    private bool IsTokenAvailableForMethodFee(string symbol)
    {
        var tokenInfo = GetTokenInfo(symbol);
        if (tokenInfo == null) throw new AssertionException("Token is not found.");
        return tokenInfo.IsBurnable;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-53)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-895)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
        var claimTransactionExecuteHeight = State.ClaimTransactionFeeExecuteHeight.Value;

        Assert(claimTransactionExecuteHeight < Context.CurrentHeight,
            $"This method already executed in height {State.ClaimTransactionFeeExecuteHeight.Value}");
        State.ClaimTransactionFeeExecuteHeight.Value = Context.CurrentHeight;
        Context.LogDebug(() => $"Claim transaction fee. {input}");
        State.LatestTotalTransactionFeesMapHash.Value = HashHelper.ComputeFrom(input);
        foreach (var bill in input.Value)
        {
            var symbol = bill.Key;
            var amount = bill.Value;
            ModifyBalance(Context.Self, symbol, amount);
            Context.Fire(new TransactionFeeClaimed
            {
                Symbol = symbol,
                Amount = amount,
                Receiver = Context.Self
            });
            
            TransferTransactionFeesToFeeReceiver(symbol, amount);
        }

        Context.LogDebug(() => "Finish claim transaction fee.");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1144-1168)
```csharp
    /// <summary>
    /// Burn 10% of tx fees.
    /// If Side Chain didn't set FeeReceiver, burn all.
    /// </summary>
    /// <param name="symbol"></param>
    /// <param name="totalAmount"></param>
    private void TransferTransactionFeesToFeeReceiver(string symbol, long totalAmount)
    {
        Context.LogDebug(() => "Transfer transaction fee to receiver.");

        if (totalAmount <= 0) return;

        var tokenInfo = GetTokenInfo(symbol);
        if (!tokenInfo.IsBurnable)
        {
            return;
        }

        var burnAmount = totalAmount.Div(10);
        if (burnAmount > 0)
            Context.SendInline(Context.Self, nameof(Burn), new BurnInput
            {
                Symbol = symbol,
                Amount = burnAmount
            });
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-232)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);

        Assert((input.Address == Context.Self || info.SerialNumber > 0) && input.ContractOperation == null ||
               info.SerialNumber == 0 && input.ContractOperation != null, "Not compatible.");

        if (input.ContractOperation != null)
        {
            ValidateContractOperation(input.ContractOperation, info.Version, codeHash);
            RemoveOneTimeSigner(input.ContractOperation.Deployer);
            AssertSameDeployer(input.Address, input.ContractOperation.Deployer);
        }

        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();

        // Create proposal for contract update
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName =
                    nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.ProposeContractCodeCheck),
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(UpdateSmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = info.Category,
                    IsSystemContract = info.IsSystemContract
                }.ToByteString(),
                OrganizationAddress = State.ContractDeploymentController.Value.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
            },
            OriginProposer = Context.Sender
        };
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);

        Context.Fire(new ContractProposed
        {
            ProposedContractInputHash = proposedContractInputHash
        });

        return proposedContractInputHash;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L324-337)
```csharp
    public override Address UpdateSmartContract(ContractUpdateInput input)
    {
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        var inputHash = CalculateHashFromInput(input);

        if (!TryClearContractProposingData(inputHash, out _))
            Assert(Context.Sender == info.Author, "No permission.");

        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);

        return contractAddress;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L124-132)
```csharp
        var contractInfo = Context.UpdateSmartContract(contractAddress, reg, null, info.ContractVersion);
        Assert(contractInfo.IsSubsequentVersion,
            $"The version to be deployed is lower than the effective version({info.ContractVersion}), please correct the version number.");

        info.ContractVersion = contractInfo.ContractVersion;
        reg.ContractVersion = info.ContractVersion;

        State.ContractInfos[contractAddress] = info;
        State.SmartContractRegistrations[reg.CodeHash] = reg;
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L80-89)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L325-326)
```csharp
        var tokenInfo = AssertValidToken(symbol, amount);
        Assert(tokenInfo.IsBurnable, "The token is not burnable.");
```
