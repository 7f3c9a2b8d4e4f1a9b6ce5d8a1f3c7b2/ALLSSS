### Title
Threshold Secret Sharing DoS: Incorrect DecryptedPieces Count Check Defeats Fault Tolerance

### Summary
The `RevealSharedInValues()` function incorrectly requires 100% of miners' decrypted pieces instead of the intended 2/3 threshold, allowing any single miner to DoS the secret revelation mechanism by withholding one piece. This defeats the fault-tolerance property of Shamir's Secret Sharing and forces the system to use predictable fallback values, degrading consensus randomness quality.

### Finding Description

The vulnerability exists in the secret sharing revelation logic where miners attempt to recover other miners' `InValue` secrets from the previous round. [1](#0-0) 

The code correctly calculates a 2/3 threshold (`minimumCount`) for the secret sharing scheme. [2](#0-1) 

However, line 36 requires `DecryptedPieces.Count >= minersCount` (100% of pieces) instead of `>= minimumCount` (2/3 threshold). This contradicts the cryptographic design where Shamir's Secret Sharing only requires the threshold number of pieces to reconstruct the secret. [3](#0-2) 

The actual secret reconstruction at line 50 correctly uses `minimumCount` as the threshold parameter, proving the system is designed to work with 2/3 pieces, not all pieces. [4](#0-3) 

The `DecodeSecret` implementation uses only the first `threshold` pieces for reconstruction, confirming that additional pieces beyond the threshold are unnecessary. [5](#0-4) 

The test suite explicitly validates that secret recovery succeeds once `decryptedValues.Count >= MinimumCount`, demonstrating the intended 2/3 threshold behavior.

The same bug exists in the application layer: [6](#0-5) 

### Impact Explanation

**Operational DoS of Secret Revelation:**
When any single miner withholds their decrypted piece, the count falls below `minersCount`, triggering the `continue` statement that skips secret revelation for that miner's `InValue`. This can be repeated across multiple rounds to systematically prevent secret revelation.

**Degradation of Consensus Randomness:**
When secrets cannot be revealed, the system falls back to predictable values: [7](#0-6) 

These "fake" `PreviousInValue` entries are computed from the miner's public key and block height, making them predictable rather than cryptographically random.

**Defeat of Fault Tolerance:**
The 2/3 threshold design specifically tolerates up to 1/3 Byzantine or offline miners. Requiring 100% participation eliminates this safety margin, making the system vulnerable to any single point of failure.

**Manipulation of Consensus Order:**
The signature derived from `PreviousInValue` determines mining order for the next round: [8](#0-7) 

By selectively preventing certain secrets from being revealed, an attacker can influence which miners use predictable fallback values, potentially biasing the next round's mining order.

**Who is Affected:**
All consensus participants suffer from reduced randomness quality and increased predictability in round transitions. The entire network's security properties degrade when operating on fallback values instead of proper secret sharing.

### Likelihood Explanation

**Attacker Capabilities:**
Any active miner in the consensus set can execute this attack. The attacker simply needs to participate in normal consensus but omit submitting one or more decrypted pieces when producing their block.

**Attack Complexity:**
Trivial. The attacker performs normal block production but intentionally excludes specific decrypted pieces from their trigger information. This requires no special cryptographic knowledge or complex coordination. [9](#0-8) 

Decrypted pieces are added during the `UpdateLatestSecretPieces` phase—the attacker simply provides an incomplete set.

**Detection and Operational Constraints:**
The attack is difficult to distinguish from legitimate network issues (packet loss, timing problems, or node failures). The validation logic permits empty `PreviousInValue`: [10](#0-9) 

This means blocks with unrevealed secrets pass validation, making the attack operationally undetectable.

**Economic Rationality:**
The attack costs nothing beyond normal consensus participation. The attacker suffers no penalties and can execute the attack repeatedly. There is no on-chain evidence distinguishing malicious withholding from accidental omissions.

### Recommendation

**Code-Level Mitigation:**

Change line 36 in `AEDPoSContract_SecretSharing.cs` from:
```csharp
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```
to:
```csharp
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

Apply the same fix to line 162 in `src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs`.

**Invariant to Enforce:**
Secret revelation must succeed with any subset of decrypted pieces meeting the threshold: `DecryptedPieces.Count >= minersCount * 2 / 3`.

**Test Cases:**
1. Test secret revelation succeeds with exactly `minimumCount` pieces (not all N pieces)
2. Test secret revelation with `minimumCount + 1` pieces yields same result as with all N pieces
3. Test that revealed `InValue` matches expected value even when 1/3 of miners withhold pieces
4. Add integration test simulating Byzantine miner withholding pieces to verify system continues normal operation

### Proof of Concept

**Initial State:**
- Network has 7 miners (N=7)
- Threshold calculated as `minimumCount = 7 * 2 / 3 = 4` (rounded down)
- Round R-1 completed with Miner A producing a block containing encrypted pieces for all 6 other miners

**Attack Sequence:**

Step 1: Miners B, C, D, E, F decrypt their pieces from Miner A and submit them in their blocks during round R.

Step 2: Miner G (attacker) produces their block but intentionally omits their decrypted piece for Miner A.

Step 3: Round R transitions to Round R+1. The extra block producer calls `RevealSharedInValues()`. [11](#0-10) 

**Expected Result (Correct Behavior):**
With 6 out of 7 decrypted pieces available (exceeding the threshold of 4), Miner A's `InValue` should be successfully revealed and used for signature calculation.

**Actual Result (Buggy Behavior):**
- At line 36, check evaluates: `6 < 7` → true
- Execution hits `continue`, skipping Miner A's secret revelation
- Miner A's `PreviousInValue` remains `Hash.Empty` or uses a predictable fallback value [12](#0-11) 

**Success Condition:**
The attack succeeds if `currentRound.RealTimeMinersInformation[MinerA].PreviousInValue` remains unrevealed despite having sufficient pieces (>= threshold) available. This can be verified by checking that the value equals `Hash.Empty` or the predictable fallback instead of the cryptographically derived secret.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-48)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/InValueRecoveryTest.cs (L52-58)
```csharp
            if (decryptedValues.Count >= MinimumCount)
            {
                decryptResult = SecretSharingHelper.DecodeSecret(
                    decryptedValues.Values.ToList(),
                    Enumerable.Range(1, MinimumCount).ToList(), MinimumCount);
                break;
            }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L161-162)
```csharp
            if (minerInRound.EncryptedPieces.Count < minimumCount) continue;
            if (minerInRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L96-102)
```csharp
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```
