### Title
Bancor Formula Domain Violation Causes DOS When Buying Large Amounts

### Summary
The `GetAmountToPayFromReturn()` function in BancorHelper fails to validate that the requested amount is within the mathematical domain constraints of the natural logarithm calculation. When a user attempts to buy tokens with `amountToReceive >= toConnectorBalance / 2`, the calculation of `x = bt / (bt - a)` produces a value ≥ 2, causing `Ln(x)` to throw an exception and revert the transaction, effectively DOSing the token purchase functionality for legitimate large purchases.

### Finding Description

The root cause lies in the mathematical constraint of the `Ln()` function and missing input validation in the token purchase flow.

In `GetAmountToPayFromReturn()`, the function calculates `x = bt / (bt - a)` where `bt` is the to-connector balance and `a` is the amount to receive: [1](#0-0) 

This value is then passed to the exponential calculation that includes `Ln(x)`: [2](#0-1) 

The `Ln()` function has a strict domain constraint - it requires the input parameter `a` to satisfy `0 < a < 2`, enforced by this check: [3](#0-2) 

For `x = bt / (bt - a)` to satisfy `x < 2`, we need:
- `bt / (bt - a) < 2`
- `bt < 2(bt - a)`
- `bt < 2bt - 2a`
- `2a < bt`
- **`a < bt / 2`**

This means `amountToReceive` must be less than half of `toConnectorBalance` for the calculation to succeed.

However, the `Buy()` function calls `GetAmountToPayFromReturn()` with user-controlled `input.Amount` without any validation: [4](#0-3) 

The only validations performed are basic checks that don't enforce the domain constraint: [5](#0-4) 

Additionally, even the special case for equal weights doesn't properly handle the constraint: [6](#0-5) 

The try-catch at line 81-89 handles division by zero but with a misleading error message about "Insufficient account balance to deposit" when the actual issue is the mathematical domain violation.

### Impact Explanation

**Operational Impact - DOS of Token Purchase Functionality:**

1. **Immediate DOS**: Any user attempting to buy tokens with `amount >= toConnectorBalance / 2` will experience transaction reversion with the confusing error message "must be 0 < a < 2", preventing legitimate large token purchases.

2. **User Experience Degradation**: Users receive cryptic mathematical error messages instead of clear business logic errors about insufficient liquidity or maximum purchase limits.

3. **Function Scope**: This affects both:
   - The `Buy()` transaction function (line 112-159)
   - The `GetNeededDeposit()` view function which also calls `GetAmountToPayFromReturn()`: [7](#0-6) 

4. **Business Logic Violation**: The Bancor pricing model inherently cannot support single purchases exceeding 50% of the connector balance due to its mathematical formulation, but this constraint is neither documented nor properly enforced with appropriate error handling.

**Who is Affected:**
- Users attempting to make large token purchases (≥50% of available liquidity)
- DApps integrating with the TokenConverter contract expecting reasonable error handling
- Contract operators unable to properly calculate deposit requirements when `amountOutOfTokenConvert >= totalSupply / 2`

### Likelihood Explanation

**High Likelihood - Trivial to Trigger:**

1. **Attack Complexity**: VERY LOW
   - Attacker simply calls `Buy()` with `amount >= currentConnectorBalance / 2`
   - No special permissions required
   - No complex setup or state manipulation needed

2. **Preconditions**: MINIMAL
   - Connector must be enabled for purchase (normal operational state)
   - User needs approval for the base token (standard requirement)
   - No race conditions or timing dependencies

3. **Economic Cost**: NEGLIGIBLE
   - Only gas costs for the failed transaction
   - No tokens need to be locked or risked
   - Can be executed repeatedly

4. **Detection**: EASY
   - Anyone monitoring connector balances can identify vulnerable states
   - Public view functions expose all necessary information
   - The error is deterministic and reproducible

5. **Real-World Scenario**: LIKELY
   - Legitimate users may attempt large purchases during:
     - Initial liquidity provision
     - Market volatility when liquidity pools are small
     - Token migrations or system upgrades
   - Automated trading bots might hit this limit during normal operations

### Recommendation

**Immediate Fix - Add Domain Constraint Validation:**

Add explicit validation in `GetAmountToPayFromReturn()` before the calculation:

```csharp
public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
    long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
{
    if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
        throw new InvalidValueException("Connector balance needs to be a positive number.");

    if (amountToReceive <= 0) 
        throw new InvalidValueException("Amount needs to be a positive number.");
    
    // NEW: Validate Bancor formula domain constraint
    if (amountToReceive >= toConnectorBalance)
        throw new InvalidValueException("Amount to receive must be less than connector balance.");
    
    // NEW: Validate Ln domain constraint (x < 2 requires a < bt/2)
    if (amountToReceive * 2 >= toConnectorBalance)
        throw new InvalidValueException("Amount to receive exceeds maximum single purchase limit (50% of connector balance).");
    
    // ... rest of function
}
```

**Additional Recommendations:**

1. **Update Buy() Function**: Add pre-validation with clear error messages: [8](#0-7) 

2. **Documentation**: Document the 50% maximum single purchase limit in the contract comments and user-facing documentation.

3. **Test Cases**: Add regression tests for boundary conditions:
   - `amount = toConnectorBalance / 2 - 1` (should succeed)
   - `amount = toConnectorBalance / 2` (should fail with clear message)
   - `amount = toConnectorBalance / 2 + 1` (should fail with clear message)
   - `amount >= toConnectorBalance` (should fail with clear message)

4. **View Function Protection**: Ensure `GetNeededDeposit()` handles this constraint gracefully when calculating needed deposits.

### Proof of Concept

**Initial State:**
- Token pair enabled: RESOURCE ↔ (NT)RESOURCE  
- Connector balances: fromConnector = 1,000,000 ELF, toConnector = 500,000 RESOURCE
- User has sufficient ELF balance and approval

**Attack Steps:**

1. **Attempt to Buy 50% of Connector Balance:**
   ```
   Call: Buy(symbol: "RESOURCE", amount: 250,000, payLimit: 0)
   ```

2. **Execution Flow:**
   - `Buy()` calls `GetAmountToPayFromReturn(1000000, 0.5, 500000, 0.5, 250000)`
   - Line 91: `x = 500000 / (500000 - 250000) = 500000 / 250000 = 2`
   - Line 93: Attempts `Ln(2)`
   - Line 130 in `Ln()`: `x = 1 - 2 = -1`
   - Line 131: `Math.Abs(-1) >= 1` → TRUE
   - Line 132: Throws `InvalidValueException("must be 0 < a < 2")`

3. **Attempt to Buy >50% of Connector Balance:**
   ```
   Call: Buy(symbol: "RESOURCE", amount: 300,000, payLimit: 0)
   ```
   - Line 91: `x = 500000 / (500000 - 300000) = 500000 / 200000 = 2.5`
   - Line 93: Attempts `Ln(2.5)`
   - Line 130: `x = 1 - 2.5 = -1.5`
   - Line 131: `Math.Abs(-1.5) >= 1` → TRUE
   - Line 132: Throws same exception

**Expected Result:** 
Transaction should fail with clear business logic error: "Amount exceeds maximum single purchase limit"

**Actual Result:**
Transaction reverts with cryptic error: "must be 0 < a < 2"

**Success Condition for Attack:**
Any call to `Buy()` with `amount >= toConnectorBalance / 2` causes transaction reversion, effectively DOSing large purchases.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L70-73)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L80-89)
```csharp
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-91)
```csharp
        var x = bt / (bt - a);
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L93-93)
```csharp
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L131-132)
```csharp
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-119)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L81-83)
```csharp
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
```
