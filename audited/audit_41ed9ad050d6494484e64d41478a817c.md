### Title
NFT Contract Allowance Front-Running Vulnerability Enables Double-Spend of Approvals

### Summary
The NFT contract's `Approve()` function directly overwrites allowances without considering the current value, enabling a classic front-running attack. An approved spender can monitor pending approval changes and execute `TransferFrom()` to drain both the old and new allowance amounts, stealing significantly more tokens than the owner intended to authorize.

### Finding Description

The vulnerability exists in the interaction between two functions in `NFTContract_UseChain.cs`:

**Vulnerable Approval Mechanism:**
The `Approve()` function uses direct assignment to set allowances [1](#0-0) , completely overwriting the previous allowance value without any validation of the current state.

**Allowance Consumption:**
The `TransferFrom()` function reads the current allowance, validates it, and decrements it by the transferred amount [2](#0-1) .

**Root Cause:**
The direct assignment approach in `Approve()` creates a race condition. When an owner wants to change an existing approval (e.g., from 100 to 50), the approved spender can observe the pending transaction in AElf's transaction pool and submit a `TransferFrom()` transaction with higher priority to execute before the approval change. After draining the old allowance, the new approval takes effect, allowing the attacker to drain again.

**Why Existing Protections Fail:**
- No checks prevent approval changes when allowances are non-zero
- No atomic approval update mechanism exists
- No nonce or versioning system tracks approval changes
- The `UnApprove()` function only decreases allowances and doesn't prevent the same race condition [3](#0-2) 

### Impact Explanation

**Direct Financial Loss:**
Token owners suffer direct theft when reducing or changing approvals. If an owner approved 100 tokens initially and later wants to reduce it to 50 tokens, the attacker can steal 150 tokens total (100 + 50) instead of the intended 50.

**Affected Parties:**
- NFT owners who need to modify existing approvals
- Marketplaces and escrow systems that manage user approvals
- DeFi protocols integrating with the NFT contract

**Severity Justification (High):**
- Results in direct theft of NFT tokens
- Exploitable by any approved spender without special privileges
- No way for victims to prevent the attack once approval transaction is submitted
- Impact scales with the allowance amounts (could be thousands of valuable NFTs)
- Well-documented attack pattern with proven exploitation history in other blockchain systems

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an already-approved spender (legitimate precondition for TransferFrom)
- Ability to monitor the transaction pool for pending transactions
- Ability to submit transactions with higher priority (via higher fees or MEV strategies)

**Attack Complexity:**
Low - This is a straightforward front-running attack requiring only basic blockchain monitoring tools and transaction submission capabilities.

**Feasibility Conditions:**
- AElf blockchain has a transaction pool where transactions have "PENDING" status before inclusion in blocks
- Miners select transactions for blocks, allowing transaction ordering manipulation
- No technical barriers prevent transaction monitoring or priority bidding

**Detection & Operational Constraints:**
- Attack is difficult to detect in advance since both transactions appear legitimate
- No on-chain mechanism to prevent or detect the attack
- Attack completes within seconds (time between pending tx observation and block confirmation)

**Probability Assessment:**
High - The attack is economically rational whenever the value of stolen tokens exceeds the cost of higher transaction fees. Given that NFTs can have significant value, this threshold is easily met.

### Recommendation

**Primary Mitigation - Implement Incremental Allowance Changes:**

Replace the direct assignment pattern with separate increase/decrease functions:

```solidity
public override Empty IncreaseAllowance(IncreaseAllowanceInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    var currentAllowance = State.AllowanceMap[tokenHash][Context.Sender][input.Spender];
    State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = currentAllowance.Add(input.Amount);
    // emit event
}

public override Empty DecreaseAllowance(DecreaseAllowanceInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    var currentAllowance = State.AllowanceMap[tokenHash][Context.Sender][input.Spender];
    Assert(currentAllowance >= input.Amount, "Allowance underflow.");
    State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = currentAllowance.Sub(input.Amount);
    // emit event
}
```

**Secondary Mitigation - Add Require-Zero Check:**

Modify the existing `Approve()` function to require the current allowance to be zero before setting a new non-zero value:

```solidity
public override Empty Approve(ApproveInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    var currentAllowance = State.AllowanceMap[tokenHash][Context.Sender][input.Spender];
    
    // Require current allowance to be zero when setting non-zero approval
    if (input.Amount > 0)
        Assert(currentAllowance == 0, "Current allowance must be zero. Use IncreaseAllowance/DecreaseAllowance instead.");
    
    State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = input.Amount;
    // emit event
}
```

**Test Cases to Add:**
1. Test that `IncreaseAllowance()` correctly adds to existing allowance
2. Test that `DecreaseAllowance()` prevents underflow
3. Test that `Approve()` with require-zero check rejects non-zero-to-non-zero changes
4. Regression test simulating the front-running scenario to ensure it fails after fixes

### Proof of Concept

**Initial State:**
- Alice owns 200 NFT tokens (Symbol="NFT", TokenId=1)
- Alice has previously approved Bob for 100 tokens
- Current allowance: `State.AllowanceMap[tokenHash][Alice][Bob] = 100`

**Attack Sequence:**

1. **Alice submits transaction T1** (at block height N):
   - Function: `Approve(spender=Bob, symbol="NFT", tokenId=1, amount=50)`
   - Intent: Reduce Bob's allowance from 100 to 50
   - Status: Pending in transaction pool

2. **Bob observes T1 in mempool and submits T2** (at block height N):
   - Function: `TransferFrom(from=Alice, to=Bob, symbol="NFT", tokenId=1, amount=100)`
   - Transaction fee: Higher than T1 to ensure priority
   - Status: Pending in transaction pool

3. **Miner includes transactions in block N+1 in order: T2, then T1**

4. **T2 executes:**
   - Checks allowance: 100 >= 100 ✓
   - Transfers 100 tokens from Alice to Bob
   - Updates allowance: `State.AllowanceMap[tokenHash][Alice][Bob] = 0`
   - Alice's balance: 100 tokens remaining

5. **T1 executes:**
   - Sets allowance: `State.AllowanceMap[tokenHash][Alice][Bob] = 50`
   - No validation of previous allowance or recent transfers

6. **Bob submits T3** (at block height N+1):
   - Function: `TransferFrom(from=Alice, to=Bob, symbol="NFT", tokenId=1, amount=50)`

7. **T3 executes:**
   - Checks allowance: 50 >= 50 ✓
   - Transfers 50 tokens from Alice to Bob
   - Alice's balance: 50 tokens remaining

**Expected Result (Secure Behavior):**
Bob should only be able to transfer 50 tokens total (the new intended allowance).

**Actual Result (Vulnerability Exploited):**
Bob successfully transferred 150 tokens (100 + 50), stealing an additional 100 tokens beyond Alice's intent.

**Success Condition:**
Bob's final balance shows 150 tokens transferred from Alice, while Alice only intended to authorize 50 tokens.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L64-66)
```csharp
            var allowance = State.AllowanceMap[tokenHash][input.From][Context.Sender];
            Assert(allowance >= input.Amount, "Not approved.");
            State.AllowanceMap[tokenHash][input.From][Context.Sender] = allowance.Sub(input.Amount);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L298-298)
```csharp
        State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = input.Amount;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L310-328)
```csharp
    public override Empty UnApprove(UnApproveInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var oldAllowance = State.AllowanceMap[tokenHash][Context.Sender][input.Spender];
        var currentAllowance = oldAllowance.Sub(input.Amount);
        if (currentAllowance <= 0) currentAllowance = 0;

        State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = currentAllowance;

        Context.Fire(new UnApproved
        {
            Owner = Context.Sender,
            Spender = input.Spender,
            Symbol = input.Symbol,
            CurrentAllowance = currentAllowance,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```
