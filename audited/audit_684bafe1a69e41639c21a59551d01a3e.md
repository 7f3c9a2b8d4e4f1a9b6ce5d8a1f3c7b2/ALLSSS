### Title
Duplicate FinalOrderOfNextRound Values Bypass Validation Due to Incorrect Distinctness Check and Wrong Round Validation

### Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` contains two critical bugs that allow colluding miners to set duplicate `FinalOrderOfNextRound` values, corrupting the next round's mining schedule. The validation incorrectly applies `.Distinct()` to `MinerInRound` objects instead of their order values, and checks the wrong round (next round instead of current round), allowing duplicate orders to pass validation and break consensus integrity.

### Finding Description

**Root Cause - Bug #1: Incorrect Use of .Distinct()**

The validation attempts to verify that `FinalOrderOfNextRound` values are unique by calling `.Distinct()` on a collection of `MinerInRound` objects: [1](#0-0) 

This code applies `.Distinct()` to the entire `MinerInRound` objects, not to their `FinalOrderOfNextRound` field values. Since each miner is a distinct object with a unique `Pubkey`, they will always be considered distinct even if they have identical `FinalOrderOfNextRound` values. The correct implementation should be `.Select(m => m.FinalOrderOfNextRound).Where(o => o > 0).Distinct().Count()`.

**Root Cause - Bug #2: Validating Wrong Round**

The validation checks `providedRound` (the next round being proposed), but when the next round is generated, `FinalOrderOfNextRound` is not copied from the current round: [2](#0-1) 

The generation code only copies `FinalOrderOfNextRound` from current round miners to set `Order` in the next round. The `FinalOrderOfNextRound` field in the next round remains at its default value (0). Therefore, the validation checking `providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)` will always find zero miners, making the check meaningless.

**Attack Vector: Unvalidated TuneOrderInformation**

During `UpdateValue` transactions, miners can set `TuneOrderInformation` to assign `FinalOrderOfNextRound` values, including duplicates: [3](#0-2) 

These values are applied directly without any uniqueness validation. The `UpdateValueValidationProvider` only validates `OutValue` and `PreviousInValue`, not order uniqueness: [4](#0-3) 

The `NextRoundMiningOrderValidationProvider` is only invoked for `NextRound` behavior, not `UpdateValue`: [5](#0-4) 

**Consensus Corruption**

When the next round is generated, duplicate `FinalOrderOfNextRound` values from the current round cause multiple miners to be assigned the same `Order`: [6](#0-5) 

Since `nextRound.RealTimeMinersInformation` is a dictionary keyed by `Pubkey`, only the last miner with a duplicate order value would remain in that slot. However, the `occupiedOrders` calculation would count the order as occupied multiple times: [7](#0-6) 

This results in fewer available orders for miners who didn't mine, causing some miners to be incorrectly assigned or left unassigned, corrupting the entire round schedule.

### Impact Explanation

**Consensus Integrity Failure (Critical)**

The vulnerability allows colluding miners to corrupt the mining schedule for the next round:

1. **Schedule Corruption**: Multiple miners assigned duplicate `FinalOrderOfNextRound` values will cause incorrect `Order` assignments in the next round, as only one miner can occupy each order slot but the dictionary assignment will overwrite previous entries.

2. **Miner Displacement**: The `occupiedOrders` list will incorrectly mark orders as occupied even when they were overwritten, reducing the number of available orders for non-mining miners.

3. **Consensus Halt Risk**: With a malformed round schedule where miners have incorrect or missing orders, the consensus mechanism cannot properly coordinate block production, potentially causing chain halts or skipped blocks.

4. **Fairness Violation**: Colluding miners can manipulate which miners get assigned to favorable time slots, breaking the fairness guarantees of the consensus algorithm.

The attack directly violates the critical invariant: "Correct round transitions and time-slot validation, miner schedule integrity" - miners' orders must be unique and properly assigned for consensus to function correctly.

### Likelihood Explanation

**High Likelihood - Practical Attack**

1. **Reachable Entry Point**: The attack uses the public `UpdateValue` method that all miners call during normal block production.

2. **Feasible Preconditions**: 
   - Requires 2+ colluding miners (common in PoS systems with concentrated stake)
   - No special permissions beyond normal miner status needed
   - Attack can be executed during any round

3. **Execution Practicality**:
   - Miner A calls `UpdateValue` with `TuneOrderInformation = {"MinerB": 5, "MinerC": 5}` to set duplicates
   - Miner B and C produce blocks normally
   - When `NextRound` is triggered, the validation passes due to the bugs
   - The generated round has corrupted order assignments

4. **Economic Rationality**:
   - Low cost: only requires coordinating UpdateValue transactions
   - High impact: disrupts consensus for entire network
   - Difficult to attribute: appears as normal mining behavior until NextRound reveals corruption

5. **Detection Constraints**: The bug is in the validation logic itself, so malicious transactions appear valid until the corrupted round is generated. By then, the damage is done and the chain may need manual intervention to recover.

### Recommendation

**Fix #1: Validate FinalOrderOfNextRound Uniqueness in Current Round**

Modify `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var currentRound = validationContext.BaseRound; // Check CURRENT round, not providedRound
    
    // Get all distinct FinalOrderOfNextRound values
    var finalOrders = currentRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0)
        .Select(m => m.FinalOrderOfNextRound) // Extract the VALUES
        .ToList();
    
    var distinctCount = finalOrders.Distinct().Count();
    var minersWhoMined = currentRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null);
    
    if (distinctCount != minersWhoMined || distinctCount != finalOrders.Count)
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound - duplicates detected.";
        return validationResult;
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

**Fix #2: Add Validation During UpdateValue**

Add a new validation provider for `UpdateValue` that checks `TuneOrderInformation` for duplicates before applying:

```csharp
public class TuneOrderValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var providedRound = validationContext.ProvidedRound;
        var finalOrders = providedRound.RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound > 0)
            .Select(m => m.FinalOrderOfNextRound)
            .ToList();
            
        if (finalOrders.Count != finalOrders.Distinct().Count())
        {
            return new ValidationResult { Message = "Duplicate FinalOrderOfNextRound values in TuneOrderInformation" };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Add this provider to the UpdateValue validation chain in `AEDPoSContract_Validation.cs`.

**Fix #3: Add Invariant Tests**

Add unit tests that verify:
- No duplicate `FinalOrderOfNextRound` values can exist in any round
- `NextRound` generation fails if current round has duplicate orders
- `TuneOrderInformation` with duplicates is rejected during validation

### Proof of Concept

**Initial State:**
- Current round has 5 miners (A, B, C, D, E)
- Miners A, B, C have produced blocks (OutValue != null)
- Round number: 100

**Attack Sequence:**

**Step 1:** Miner A produces block and calls `UpdateValue` with malicious `TuneOrderInformation`:
```
UpdateValueInput {
    OutValue: [MinerA's hash],
    Signature: [MinerA's sig],
    TuneOrderInformation: {
        "MinerB": 3,
        "MinerC": 3  // Duplicate order!
    },
    ...
}
```

**Step 2:** The `ProcessUpdateValue` method applies these values without validation:
- `currentRound.RealTimeMinersInformation["MinerB"].FinalOrderOfNextRound = 3`
- `currentRound.RealTimeMinersInformation["MinerC"].FinalOrderOfNextRound = 3`

**Step 3:** Miner A triggers `NextRound`. The validation executes:
- Checks `providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0).Distinct().Count()`
- In the generated next round, all `FinalOrderOfNextRound` values are 0 (default)
- Result: `distinctCount = 0`, comparison passes (0 == 0)

**Step 4:** `GenerateNextRoundInformation` processes miners with duplicate orders:
- Processes MinerB: assigns `Order = 3` in next round
- Processes MinerC: assigns `Order = 3` in next round (overwrites MinerB's entry!)
- `occupiedOrders = [1, 3, 3, ...]` (contains duplicate)
- `ableOrders` calculation thinks order 3 is occupied, even though only MinerC occupies it

**Expected Result:** Validation should reject duplicate `FinalOrderOfNextRound` values.

**Actual Result:** Validation passes, and the next round is generated with corrupted order assignments where MinerB's order slot was overwritten by MinerC, causing schedule corruption.

**Success Condition:** Chain enters a state where the next round has malformed miner orders, potentially causing consensus failure or incorrect block production timing.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
