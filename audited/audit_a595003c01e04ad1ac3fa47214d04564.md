### Title
Balance Requirement DoS in NFT Recast Function - Distributed Token Holders Can Permanently Lock Metadata Updates

### Summary
The `Recast()` function requires the caller to hold the entire quantity of an NFT to update its metadata, URI, or alias. When NFTs are minted with multiple quantities and distributed to different holders, any single holder can permanently prevent metadata updates by refusing to transfer their tokens back to the minter, creating an irrecoverable coordination problem with no alternative update mechanism.

### Finding Description

The vulnerability exists in the `Recast()` function's balance requirement check: [1](#0-0) 

This assertion requires that `nftInfo.Quantity` (the total minted quantity of the NFT) equals the caller's balance. This means the minter must hold **all** tokens of that NFT to perform a recast.

The issue arises through the following execution path:

1. **Minting with Quantity > 1**: NFTs can be minted with multiple quantities, as seen in the minting logic: [2](#0-1) 

2. **Token Distribution**: Minted tokens can be freely transferred to multiple holders via the `Transfer()` function: [3](#0-2) 

3. **Balance Tracking**: Each transfer reduces the sender's balance and increases the recipient's balance: [4](#0-3) 

4. **Total Quantity Tracking**: The `nftInfo.Quantity` tracks the total minted amount and is set during minting: [5](#0-4) 

Once tokens are distributed, the minter's balance no longer equals `nftInfo.Quantity`, making the recast assertion fail. The minter would need all token holders to voluntarily transfer their tokens back, but there is no enforcement mechanism, no incentive structure, and no alternative update path.

### Impact Explanation

**Operational Impact - Permanent Metadata Lock:**

The `Recast()` function is the **only** mechanism to update an NFT's metadata, URI, and alias after minting: [6](#0-5) 

When recasting is blocked, the following harms occur:

1. **Metadata Errors Cannot Be Fixed**: Typos, incorrect information, or invalid metadata keys cannot be corrected
2. **URI Updates Impossible**: Token URIs pointing to incorrect or outdated resources cannot be updated
3. **No Adaptability**: NFTs cannot evolve or be updated based on changing requirements
4. **Protocol Rigidity**: The NFT protocol definition confirms this is the designated update mechanism: [7](#0-6) 

**Affected Parties:**
- NFT creators who need to maintain and update their collections
- NFT holders whose assets have incorrect or outdated metadata
- Platform operators who cannot fix protocol-level issues

**Severity Justification:** Medium severity because while no direct fund loss occurs, it creates a permanent operational denial that affects core NFT functionality and value.

### Likelihood Explanation

**High Likelihood Due to Common Use Case:**

1. **Multi-Edition NFTs Are Standard**: Creating NFTs with quantity > 1 is a legitimate and common pattern for limited edition collectibles, event tickets, or membership tokens

2. **Distribution is Expected Behavior**: The primary purpose of NFTs is to distribute them to collectors/users, making token distribution the norm, not the exception

3. **Realistic Failure Scenarios**:
   - **Lost Keys**: Any holder who loses their private key makes their tokens permanently unrecoverable
   - **Inactive Users**: Holders may become unreachable or inactive
   - **Griefing**: Malicious holders can intentionally refuse to cooperate
   - **Economic Demands**: Holders may demand payment or favorable terms to return tokens
   - **Legal/Regulatory**: Holders may be legally prevented from transferring

4. **No Coordination Mechanism**: The contract provides:
   - No governance override for recasting
   - No timelock mechanism to force updates
   - No incentive structure for token returns
   - No partial recast capability

5. **Zero Attack Cost**: Holders passively prevent recasting simply by holding their tokens - no active attack required

**Execution Practicality:** The vulnerability triggers through normal contract usage without any special conditions or elevated privileges beyond being an authorized minter.

### Recommendation

**Immediate Fix - Remove Balance Requirement:**

Modify the `Recast()` function to only require minter permission, not full token ownership:

```csharp
public override Empty Recast(RecastInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
    Assert(minterList.Value.Contains(Context.Sender), "No permission.");
    var nftInfo = GetNFTInfoByTokenHash(tokenHash);
    
    // REMOVE THIS LINE:
    // Assert(nftInfo.Quantity != 0 && nftInfo.Quantity == State.BalanceMap[tokenHash][Context.Sender],
    //     "Do not support recast.");
    
    // ADD THIS LINE:
    Assert(nftInfo.Quantity != 0, "NFT does not exist or has been fully burned.");
    
    // ... rest of function
}
```

**Alternative Fix - Governance Override:**

If the full ownership requirement is intentional for some security reason, add a governance-controlled override mechanism:

```csharp
// Add to recast logic:
var protocolInfo = State.NftProtocolMap[input.Symbol];
bool hasFullOwnership = nftInfo.Quantity == State.BalanceMap[tokenHash][Context.Sender];
bool hasCreatorOverride = Context.Sender == protocolInfo.Creator;

Assert(hasFullOwnership || hasCreatorOverride, "Insufficient permission for recast.");
```

**Testing Requirements:**

1. Test recast with distributed tokens across multiple holders
2. Test recast with quantity = 1 (current implicit assumption)
3. Test recast permission boundaries (minter vs non-minter)
4. Test partial ownership scenarios
5. Add integration tests for realistic NFT distribution and update scenarios

### Proof of Concept

**Initial State:**
- Protocol "COLLECT" created with minter Alice
- Total supply: 1000

**Transaction Sequence:**

1. **Alice mints NFT with quantity = 100**
   - Input: `Mint({ Symbol: "COLLECT", TokenId: 1, Quantity: 100, Owner: Alice })`
   - Result: 
     - `nftInfo.Quantity = 100`
     - `State.BalanceMap[tokenHash][Alice] = 100`

2. **Alice distributes tokens to collectors**
   - `Transfer({ To: Bob, Symbol: "COLLECT", TokenId: 1, Amount: 40 })`
   - `Transfer({ To: Carol, Symbol: "COLLECT", TokenId: 1, Amount: 30 })`
   - Result:
     - `nftInfo.Quantity = 100` (unchanged)
     - `State.BalanceMap[tokenHash][Alice] = 30`
     - `State.BalanceMap[tokenHash][Bob] = 40`
     - `State.BalanceMap[tokenHash][Carol] = 30`

3. **Alice discovers metadata error and attempts to recast**
   - Input: `Recast({ Symbol: "COLLECT", TokenId: 1, Metadata: { "fixed": "value" } })`
   - Expected: Metadata should update successfully (Alice is authorized minter)
   - Actual: Transaction fails with "Do not support recast."
   - Reason: `nftInfo.Quantity (100) != State.BalanceMap[tokenHash][Alice] (30)`

4. **Alice requests tokens back from Bob and Carol**
   - If Bob returns 40 tokens and Carol returns 30 tokens: Alice can recast ✓
   - If Bob loses his keys: Alice can NEVER recast ✗
   - If Carol refuses to return: Alice can NEVER recast ✗
   - If Carol demands payment: Alice faces extortion to update her own NFT ✗

**Success Condition for Vulnerability:** Any scenario where tokens cannot be returned to the minter results in permanent inability to update metadata, demonstrating the DoS condition.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L21-35)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L52-54)
```csharp
        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L262-263)
```csharp
        Assert(nftInfo.Quantity != 0 && nftInfo.Quantity == State.BalanceMap[tokenHash][Context.Sender],
            "Do not support recast.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L264-280)
```csharp
        if (input.Alias != null) nftInfo.Alias = input.Alias;

        if (input.Uri != null) nftInfo.Uri = input.Uri;

        var oldMetadata = nftInfo.Metadata.Clone();
        var metadata = new Metadata();
        // Need to keep reserved metadata key.
        foreach (var reservedKey in GetNftMetadataReservedKeys())
        {
            if (oldMetadata.Value.ContainsKey(reservedKey))
                metadata.Value[reservedKey] = oldMetadata.Value[reservedKey];

            if (input.Metadata.Value.ContainsKey(reservedKey)) input.Metadata.Value.Remove(reservedKey);
        }

        metadata.Value.Add(input.Metadata.Value);
        nftInfo.Metadata = metadata;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L402-402)
```csharp
        var quantity = input.Quantity > 0 ? input.Quantity : 1;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L424-424)
```csharp
                Quantity = quantity,
```

**File:** protobuf/nft_contract.proto (L54-56)
```text
    // Modify metadata of one nft.
    rpc Recast (RecastInput) returns (google.protobuf.Empty) {
    }
```
