### Title
Unvalidated PreviousInValue Overwrite Allows VRF Commit-Reveal Protocol Manipulation

### Summary
The `RecoverFromUpdateValue()` function unconditionally overwrites `PreviousInValue` for ALL miners from attacker-controlled block header data, while only the sender's own `PreviousInValue` is cryptographically validated. This allows a malicious miner to inject fake `PreviousInValue` data for other miners who haven't revealed yet, completely breaking the VRF commit-reveal security guarantees and enabling random number manipulation.

### Finding Description

**Root Cause:** In `RecoverFromUpdateValue()`, lines 28-29 blindly copy `PreviousInValue` for ALL miners from the `providedRound` parameter (which comes from the block producer's header data) without any cryptographic validation: [1](#0-0) 

This function is called during block validation from two locations: [2](#0-1) [3](#0-2) 

**Why Validations Fail:** The only validation of `PreviousInValue` data occurs in `UpdateValueValidationProvider`, which checks ONLY the sender's own `PreviousInValue`: [4](#0-3) 

Notice line 38 explicitly limits validation to `validationContext.SenderPubkey` - no validation occurs for the other miners' `PreviousInValue` values being mass-overwritten in the loop at RecoverFromUpdateValue lines 28-29.

**Attack Path:** The block header round data is constructed via `GetUpdateValueRound()`, which includes ALL miners' `PreviousInValue` fields: [5](#0-4) 

A malicious miner can modify their node software to inject fake `PreviousInValue` data for other miners into the `RevealedInValues` during block header generation: [6](#0-5) 

These fake values propagate through to the transaction execution without validation: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Breach (Critical):** The VRF commit-reveal protocol is the foundation of AEDPoS consensus security. The protocol requires:
1. Miners commit to a random `InValue` by publishing `OutValue = Hash(InValue)`
2. Later, they reveal `InValue`, which anyone can verify: `Hash(InValue) == OutValue`
3. Random numbers are derived from these revealed values

By injecting fake `PreviousInValue` for other miners, an attacker can:
- **Manipulate randomness**: Control unrevealed InValues to bias random number generation in their favor
- **Front-run reveals**: Reveal fake values before legitimate miners, affecting mining order and LIB calculation
- **Break fairness**: Predetermined mining schedules and reward distribution rely on unpredictable randomness

**Affected Parties:**
- All network participants suffer from compromised consensus fairness
- Honest miners face biased block production opportunities
- Token holders exposed to consensus manipulation risks
- Cross-chain bridges depend on consensus integrity for security

**Severity:** Critical - violates fundamental consensus security invariant with direct exploitation path requiring only malicious miner participation.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active miner with block production rights (feasible - anyone can become a candidate and get elected)
- Must modify node software to inject fake `RevealedInValues` (trivial for technical attackers)
- No special privileges beyond normal miner status needed

**Attack Complexity:** Low
- Single malicious block is sufficient to inject fake data
- No timing constraints or race conditions
- No need to compromise other miners or infrastructure
- Attack succeeds deterministically if validation accepts the block

**Detection Difficulty:** High
- Fake `PreviousInValue` data looks identical to legitimate revealed values
- No cryptographic proof distinguishes real from fake reveals in current validation
- Would require off-chain monitoring of expected vs actual reveals to detect

**Economic Rationality:** Highly profitable
- Cost: Standard block production costs (gas, node operation)
- Benefit: Ability to bias randomness for favorable mining slots, potentially worth significant block rewards over time
- Risk: Low if detection mechanisms don't exist

**Probability:** High - all preconditions are readily achievable for motivated attackers.

### Recommendation

**Immediate Fix:** Add cryptographic validation for ALL revealed `PreviousInValue` entries, not just the sender's:

In `RecoverFromUpdateValue()` or a new validation provider, add:
```csharp
// After line 21, before the foreach loop at line 22:
if (TryToGetPreviousRoundInformation(out var previousRound))
{
    foreach (var information in providedRound.RealTimeMinersInformation)
    {
        // Skip if no PreviousInValue being set
        if (information.Value.PreviousInValue == null || 
            information.Value.PreviousInValue == Hash.Empty)
            continue;
            
        // Skip sender - already validated by UpdateValueValidationProvider
        if (information.Key == pubkey)
            continue;
            
        // CRITICAL: Validate revealed InValue matches previous OutValue
        if (previousRound.RealTimeMinersInformation.ContainsKey(information.Key))
        {
            var expectedOutValue = previousRound.RealTimeMinersInformation[information.Key].OutValue;
            var revealedInValue = information.Value.PreviousInValue;
            
            Assert(
                HashHelper.ComputeFrom(revealedInValue) == expectedOutValue,
                $"Invalid revealed InValue for miner {information.Key}: hash mismatch with committed OutValue"
            );
        }
    }
}
```

**Additional Invariant Checks:**
1. Ensure only miners with sufficient decrypted pieces can have revealed InValues (for secret sharing)
2. Add test cases verifying rejection of blocks with fake revealed InValues
3. Implement monitoring to detect unexpected InValue reveals in production

### Proof of Concept

**Initial State:**
- Round N: Miner A produced block with OutValue_A = Hash(InValue_A)
- Round N: Miner B produced block with OutValue_B = Hash(InValue_B)  
- Round N+1: Miner C is about to produce block and should reveal InValue_C

**Attack Sequence:**

1. **Attacker (Miner C) produces block with fake reveals:**
   - Set triggerInformation.RevealedInValues["B"] = FakeInValue_B (where Hash(FakeInValue_B) ≠ OutValue_B)
   - This gets included in block header via GetConsensusExtraData → UpdateLatestSecretPieces (line 148-152)
   - Block header Round contains: PreviousInValue["B"] = FakeInValue_B

2. **Block validation (ValidateBeforeExecution):**
   - RecoverFromUpdateValue called with attacker's providedRound
   - Line 28-29 copies: state.PreviousInValue["B"] = FakeInValue_B
   - Only Miner C's PreviousInValue validated (UpdateValueValidationProvider line 38)
   - Miner B's fake PreviousInValue NOT validated
   - Validation passes ✓

3. **Block execution (ProcessUpdateValue):**
   - Line 295-296 persists FakeInValue_B to state
   - No validation occurs
   - State corruption successful ✓

**Expected Result:** Block should be REJECTED due to invalid revealed InValue for Miner B

**Actual Result:** Block is ACCEPTED, fake PreviousInValue for Miner B persists in state, VRF protocol broken

**Success Condition:** After attack block, query `State.Rounds[N+1].RealTimeMinersInformation["B"].PreviousInValue` returns FakeInValue_B instead of legitimate value, and Hash(FakeInValue_B) ≠ OutValue_B from round N.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-92)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L44-52)
```csharp
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```
