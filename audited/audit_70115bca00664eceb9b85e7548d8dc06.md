### Title
Insufficient TermNumber Validation in NextRound Transitions Allows Consensus Desynchronization

### Summary
The `ValidationForNextRound` method lacks validation of the `TermNumber` field in `NextRoundInput`, allowing malicious miners to store Round objects with incorrect term numbers. This desynchronization causes `GetConsensusBehaviourToTerminateCurrentRound()` to make incorrect decisions about term transitions, potentially delaying critical consensus term changes that affect miner elections, reward distributions, and treasury releases.

### Finding Description

**Location and Root Cause:**

The vulnerability exists in the round termination validation logic: [1](#0-0) 

The `ValidationForNextRound` method only validates that the `RoundNumber` increments correctly and that `InValue` fields are null. It does **not** validate that `TermNumber` remains unchanged (as it should for same-term round transitions).

In contrast, the corresponding NextRound processing: [2](#0-1) 

Never validates or updates `State.CurrentTermNumber`, allowing divergence between the stored Round's TermNumber and the authoritative term number state variable.

**How TermNumber Should Work:**

For NextRound (same term): [3](#0-2) 

The `TermNumber` should remain unchanged from the current round.

For NextTerm (term change): [4](#0-3) 

Both `RoundNumber` and `TermNumber` increment.

**The Desynchronization Mechanism:**

The decision to use NextRound vs NextTerm is made here: [5](#0-4) 

This relies on `CurrentRound.TermNumber` via the `NeedToChangeTerm` check: [6](#0-5) 

If `CurrentRound.TermNumber` (from stored Round object at `State.Rounds[State.CurrentRoundNumber.Value]`) differs from the actual term that should be in effect, the decision will be incorrect.

**Why Protections Fail:**

1. No validation compares `NextRoundInput.TermNumber` against `State.CurrentTermNumber.Value`
2. No validation ensures `NextRoundInput.TermNumber` equals `currentRound.TermNumber` (should be unchanged)
3. The validation system uses `baseRound` (from storage) which could itself be incorrect: [7](#0-6) 

The validation context uses `baseRound.TermNumber` but doesn't verify it matches `State.CurrentTermNumber.Value`, allowing accumulated desynchronization.

### Impact Explanation

**Concrete Harm:**

1. **Delayed Term Changes**: A malicious miner can submit a NextRound transaction with an incremented TermNumber (e.g., 2 when it should be 1). This gets stored without validation. Subsequent miners checking whether to change terms will use this incorrect TermNumber, causing them to delay the actual term transition.

2. **Missed Election Updates**: Term changes trigger miner list updates from election results. Delaying term changes means newly elected miners cannot join, and miners who should be removed stay active.

3. **Treasury Release Disruption**: Term changes trigger treasury profit releases: [8](#0-7) 

Delayed term changes postpone these treasury distributions, affecting the entire economic model.

4. **Reward Misallocation**: Mining rewards are donated per term: [9](#0-8) 

Delaying term changes accumulates rewards in the wrong term period, distorting economic incentives.

**Severity Justification:**

This is a **Medium** severity issue because:
- It disrupts critical consensus transitions but doesn't allow complete system halt
- Impact is bounded (typically one round delay before self-correction via `NeedToChangeTerm` threshold)
- Affects economic distribution but doesn't enable direct fund theft
- Requires attacker to be an active miner at round termination

### Likelihood Explanation

**Attacker Capabilities Required:**

1. Must be in the current miner list (elected/staked position)
2. Must be the extra block producer terminating the current round
3. Must have technical capability to craft custom consensus transaction data

**Attack Complexity:**

**Low to Medium** - The attacker:
1. Calls `GetConsensusBlockExtraData` to generate valid consensus data
2. Modifies the `TermNumber` field in the resulting `NextRoundInput` before submission
3. Submits the `NextRound` transaction
4. Validation passes because TermNumber is not checked

**Feasibility Conditions:**

The attack is feasible because:
- `NextRoundInput` structure is transparent: [10](#0-9) 

- The `ToRound()` method directly copies the `TermNumber` without validation
- No cryptographic binding prevents field manipulation between generation and submission

**Detection Constraints:**

The attack is difficult to detect immediately because:
- The transaction appears structurally valid (correct RoundNumber, valid signatures)
- Only subsequent round's term change behavior would reveal the issue
- Monitoring requires comparing stored Round.TermNumber against expected values from State.CurrentTermNumber

**Probability Reasoning:**

Probability is **Medium** because:
- Requires being selected as round terminator (~1/N chance per round where N = miner count)
- But miners are long-running participants who will eventually get this position
- Economic incentive exists if attacker is about to lose miner status in next election
- Can extend their mining position by one round, earning additional block rewards

### Recommendation

**Code-Level Mitigation:**

Add TermNumber validation to `ValidationForNextRound`:

```
Location: contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs
```

Add after line 30:
```csharp
// Validate TermNumber remains unchanged for NextRound
if (validationContext.BaseRound.TermNumber != extraData.Round.TermNumber)
    return new ValidationResult { Message = "Term number must not change in NextRound transition." };

// Additional check: verify stored round's TermNumber matches state variable
if (validationContext.BaseRound.TermNumber != validationContext.CurrentTermNumber)
    return new ValidationResult { Message = "Stored round TermNumber desynchronized from consensus state." };
```

**Invariant Checks to Add:**

1. In `ProcessNextRound`, assert that `nextRound.TermNumber == State.CurrentTermNumber.Value`
2. In `TryToGetCurrentRoundInformation`, verify `round.TermNumber == State.CurrentTermNumber.Value` and log warning if mismatch
3. Add state consistency check in contract initialization/upgrade logic

**Test Cases:**

1. Test that NextRound transaction with manipulated (incremented) TermNumber is rejected
2. Test that NextRound transaction with decremented TermNumber is rejected
3. Test detection and rejection when stored Round.TermNumber differs from State.CurrentTermNumber.Value
4. Test that legitimate NextTerm transition still works correctly with proper validations

### Proof of Concept

**Initial State:**
- Current round: 100
- State.CurrentTermNumber.Value: 1
- State.Rounds[100].TermNumber: 1
- State.CurrentRoundNumber.Value: 100
- Attacker is miner "MaliciousMiner" scheduled as extra block producer

**Attack Steps:**

1. **Attacker calls GetConsensusBlockExtraData** with NextRound behavior:
   - Returns proper Round object with RoundNumber=101, TermNumber=1

2. **Attacker modifies the data before submission**:
   - Changes TermNumber from 1 to 2 in the NextRoundInput
   - Keeps all other fields valid (RoundNumber=101, proper miner info, etc.)

3. **Attacker submits NextRound transaction**:
   - Validation checks RoundNumber: 100 + 1 == 101 âœ“ (passes)
   - Validation does NOT check TermNumber (missing validation)
   - Transaction executes successfully

4. **Result - Stored State**:
   - State.Rounds[101].TermNumber: 2 (incorrect)
   - State.CurrentTermNumber.Value: 1 (unchanged, correct)
   - State.CurrentRoundNumber.Value: 101 (correct)

5. **Impact on Next Round**:
   - Next miner calls GetConsensusBehaviourToTerminateCurrentRound()
   - Retrieves CurrentRound = State.Rounds[101] with TermNumber=2
   - Calls NeedToChangeTerm with currentTermNumber=2
   - IsTimeToChangeTerm checks: actual_period != (2-1) = 1
   - If actual_period = 0 (still in first term), check fails incorrectly
   - Returns NextRound when NextTerm is actually needed
   - Term change delayed by one round

**Expected vs Actual Result:**

**Expected**: NextRound stores Round with TermNumber=1, maintaining synchronization

**Actual**: NextRound stores Round with TermNumber=2, causing desynchronization and incorrect future term change decisions

**Success Condition**: Query State.Rounds[101].TermNumber returns 2 while State.CurrentTermNumber.Value returns 1, demonstrating desynchronization.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L21-22)
```csharp
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L40-41)
```csharp
        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```
