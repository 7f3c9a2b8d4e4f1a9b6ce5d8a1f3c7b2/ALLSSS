### Title
Side Chain Validators Can Prevent Validator Set Updates by Omitting Consensus Data from Cross-Chain Indexing

### Summary
Side chain validators can permanently maintain control by proposing parent chain blocks without consensus information in the cross-chain indexing process. The validation logic does not enforce the inclusion of consensus data, allowing colluding validators to prevent validator set updates while maintaining cross-chain functionality. This creates an irreversible centralization risk where initial validators retain permanent control of the side chain.

### Finding Description

Side chains use `NextRound` behavior exclusively and never trigger `NextTerm` for validator set updates. [1](#0-0) 

Instead, validator set updates occur through cross-chain indexing when parent chain blocks containing consensus information are indexed. [2](#0-1) 

The consensus data is extracted from the `extra_data` field of `ParentChainBlockData` and passed to the consensus contract. [3](#0-2) 

When consensus information is received, the side chain's `MainChainCurrentMinerList` is updated. [4](#0-3) 

During next round generation, if the main chain miner list has changed, a new first round is created with updated validators. [5](#0-4) 

**Root Cause**: The `ValidateParentChainBlockData` function validates chain ID, sequential height, and merkle tree root, but does NOT validate the presence of consensus data in the `extra_data` field. [6](#0-5) 

The `extra_data` field in `ParentChainBlockData` is defined as an optional map. [7](#0-6) 

Validators propose cross-chain indexing data and must be current miners. [8](#0-7) 

### Impact Explanation

**Permanent Validator Control**: Colluding side chain validators can omit consensus data from their cross-chain indexing proposals, preventing validator set updates indefinitely while maintaining other cross-chain functionality.

**Complete Centralization**: The initial validator set gains permanent control with no mechanism for rotation or replacement, even as the main chain updates its validator set through elections.

**Attack Capabilities**: Malicious validators controlling the side chain can:
- Censor any transactions
- Extract maximum MEV without competition
- Double-spend by reorganizing blocks
- Refuse cross-chain transactions selectively
- Hold the side chain hostage for ransom

**System-Wide Impact**: This undermines the AElf security model where side chains are expected to inherit security guarantees from the main chain through validator synchronization. Users and applications on the side chain lose the protection that should come from main chain validator rotation.

**Affected Parties**: All side chain users, dApps, and assets are subject to the control of the initial validator set with no recovery mechanism.

### Likelihood Explanation

**Attacker Capabilities**: Requires collusion among initial side chain validators. Once validators decide to maintain permanent control, execution is trivial.

**Attack Complexity**: Very low - validators simply propose `ParentChainBlockData` without the `extra_data["Consensus"]` field when calling `ProposeCrossChainIndexing`. No sophisticated techniques required.

**Feasibility**: Highly feasible. Validators have legitimate authority to propose cross-chain data and can selectively include/exclude fields. The system continues operating normally for other cross-chain operations, making the attack difficult to detect.

**Detection Constraints**: No monitoring exists to verify that consensus data is being indexed. The side chain appears functional since other cross-chain operations continue working. Users cannot easily verify if the validator set is properly synchronized with the main chain.

**Economic Rationality**: Attackers gain permanent control at zero cost (simply omitting data). Expected value is extremely high if the side chain has significant economic activity.

**Probability**: Medium to High - while requires initial validator collusion, the incentive structure makes this attractive for compromised or malicious validator sets, especially for economically significant side chains.

### Recommendation

**Immediate Fix**: Add mandatory validation in `ValidateParentChainBlockData` to require consensus data in parent chain block proposals:

```csharp
// In ValidateParentChainBlockData, add after line 729:
if (!blockData.ExtraData.ContainsKey(ConsensusExtraDataName) || 
    blockData.ExtraData[ConsensusExtraDataName].IsEmpty)
    return false;
```

**Additional Protection**: Implement a maximum age threshold for `MainChainRoundNumber` - reject block production if the side chain's `MainChainRoundNumber` is too far behind the actual main chain round number. This forces validators to index recent consensus data.

**Monitoring**: Add events and state queries to expose when the last consensus update occurred, allowing external observers to detect stale validator sets.

**Test Coverage**: Add test cases verifying:
1. Cross-chain indexing fails without consensus data
2. Side chain blocks are rejected if validator set is stale
3. Round generation properly uses updated main chain miner lists

### Proof of Concept

**Initial State**:
- Side chain initialized with validators A, B, C
- Main chain has updated its validator set to D, E, F through term change
- Validators A, B, C collude to maintain control

**Attack Sequence**:
1. Validator A proposes parent chain blocks via `ProposeCrossChainIndexing` with `ParentChainBlockData` containing valid `chain_id`, `height`, `transaction_status_merkle_tree_root`, but **omitting** `extra_data["Consensus"]`
2. Proposal passes validation in `ValidateParentChainBlockData` since consensus data is not checked
3. Proposal is approved and accepted through the normal governance flow
4. `IndexParentChainBlockData` processes the blocks, but line 783's condition `blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes)` returns false
5. `UpdateConsensusInformation` is never called
6. `State.MainChainCurrentMinerList` remains unchanged
7. During next round generation, `IsMainChainMinerListChanged` returns false
8. Validators A, B, C continue producing blocks indefinitely

**Expected Result**: Side chain validator set updates to match main chain validators D, E, F

**Actual Result**: Side chain validator set remains A, B, C permanently, with no mechanism for recovery

**Success Condition**: After multiple main chain term changes, side chain continues operating with original validator set while cross-chain indexing shows recent parent chain heights, proving consensus data was intentionally omitted.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-23)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L227-234)
```csharp
    private void UpdateConsensusInformation(ByteString bytes)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        Context.SendInline(State.CrossChainInteractionContract.Value,
            nameof(State.CrossChainInteractionContract.UpdateInformationFromCrossChain),
            new BytesValue { Value = bytes });
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L720-743)
```csharp
    private bool ValidateParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData,
        out Dictionary<int, List<ParentChainBlockData>> validatedParentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
        foreach (var blockData in parentChainBlockData)
        {
            if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
                blockData.TransactionStatusMerkleTreeRoot == null)
                return false;
            if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
                    State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
                    State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
                return false;

            currentHeight += 1;
        }

        if (parentChainBlockData.Count > 0)
            validatedParentChainBlockData[parentChainId] = parentChainBlockData.ToList();

        return true;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L783-788)
```csharp
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L46-61)
```csharp
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-295)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }
```

**File:** protobuf/acs7.proto (L109-122)
```text
message ParentChainBlockData {
    // The height of parent chain.
    int64 height = 1;
    // The merkle tree root computing from side chain roots.
    CrossChainExtraData cross_chain_extra_data = 2;
    // The parent chain id.
    int32 chain_id = 3;
    // The merkle tree root computing from transactions status in parent chain block.
    aelf.Hash transaction_status_merkle_tree_root = 4;
    // Indexed block height from side chain and merkle path for this side chain block
    map<int64, aelf.MerklePath> indexed_merkle_path = 5;
    // Extra data map.
    map<string, bytes> extra_data = 6;
}
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-291)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }
```
