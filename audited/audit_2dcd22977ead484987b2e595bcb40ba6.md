### Title
Parliament Proposal Threshold Calculations Use Dynamic Miner Count Leading to Incorrect Approval/Rejection Outcomes

### Summary
The Parliament contract calculates proposal approval thresholds using the current miner list count at the time of release/checking, rather than the miner count when votes were cast or when the proposal was created. When the parliament size changes during term transitions (miners added or removed), proposals that legitimately met approval thresholds can fail to release, or proposals that should be rejected can pass, violating governance integrity.

### Finding Description

The Parliament contract stores proposal votes as address lists but does not snapshot the parliament size at creation time. [1](#0-0) 

When checking if a proposal meets release thresholds, the contract retrieves the CURRENT miner list from the consensus contract dynamically. [2](#0-1) 

The current miner list is obtained by calling the consensus contract's `GetCurrentMinerList()` method, which returns miners from the current round's `RealTimeMinersInformation`. [3](#0-2) [4](#0-3) 

All threshold calculations use `parliamentMembers.Count` as the denominator, which represents the current parliament size at check time, not when votes were cast:

- **Approval threshold**: `approvedMemberCount * AbstractVoteTotal >= MinimalApprovalThreshold * parliamentMembers.Count` [5](#0-4) 
- **Rejection threshold**: `rejectionMemberCount * AbstractVoteTotal > MaximalRejectionThreshold * parliamentMembers.Count` [6](#0-5) 
- **Abstention threshold**: `abstentionMemberCount * AbstractVoteTotal > MaximalAbstentionThreshold * parliamentMembers.Count` [7](#0-6) 
- **Vote threshold**: `totalVotes * AbstractVoteTotal >= MinimalVoteThreshold * parliamentMembers.Count` [8](#0-7) 

The Release method checks `IsReleaseThresholdReached()` which performs these calculations using the current miner count. [9](#0-8) 

The miner list changes during consensus term transitions, which updates `State.MinerListMap` and can add or remove miners from the current parliament. This creates a window of vulnerability between proposal creation/voting and release.

### Impact Explanation

**Governance Manipulation:**
- **Legitimate proposals fail**: A proposal with 7 approvals from a 9-member parliament (77.8%) meets a 66.67% threshold. If parliament grows to 12 members before release, those same 7 votes represent only 58.3%, failing the threshold despite legitimate approval.
- **Invalid proposals pass**: A proposal with 2 rejections from a 10-member parliament (20%) stays under a 20% rejection threshold (check uses `>` operator). If parliament shrinks to 8 members, those 2 rejections become 25%, exceeding the threshold and incorrectly rejecting a proposal.

**Affected Parties:**
- All parliament organizations (default organization, custom organizations, emergency response organization)
- Any governance action requiring parliament approval (system upgrades, configuration changes, treasury operations)
- Users and contracts relying on governance outcomes

**Severity Justification:**
This is HIGH severity because:
1. Affects core governance integrity - the fundamental invariant that proposals meeting approval thresholds should pass is violated
2. No special privileges required - happens through normal term transitions
3. Can affect critical system operations (upgrades, fee changes, cross-chain operations)
4. Silent failure mode - proposals appear valid but fail unexpectedly or vice versa

### Likelihood Explanation

**Attacker Capabilities:**
No special attacker capabilities are required. This vulnerability is triggered by normal blockchain operations:
- Consensus term transitions occur regularly (term changes when election results change miner set)
- Any user can call `Release()` on a proposal once it appears to meet thresholds

**Attack Complexity:**
- **Low complexity**: An attacker can monitor pending proposals and time their release attempts around known term transitions
- **Passive exploitation**: Even without malicious intent, legitimate proposals can fail due to this flaw during natural term transitions

**Feasibility Conditions:**
- Term transitions occur regularly in AEDPoS consensus
- Proposals typically have multi-day expiration windows, overlapping with term transition windows
- The test suite confirms term changes are expected (`IsTermStayOne = true` in tests suggests production has `IsTermStayOne = false`) [10](#0-9) 

**Probability:**
HIGH - This will occur whenever:
1. A proposal is created before a term transition
2. The miner count changes during the term transition
3. The proposal is released after the term transition
4. The vote count is near the threshold boundary

Given term transitions happen regularly and proposals have multi-day lifetimes, this scenario is highly probable.

### Recommendation

**Code-level Mitigation:**

1. **Snapshot parliament size at proposal creation:**
   - Add `int64 parliament_member_count_at_creation` field to `ProposalInfo` message in `parliament_contract.proto`
   - Store `GetCurrentMinerList().Count` in this field when creating proposals in `CreateNewProposal()`
   - Use this stored count instead of dynamically retrieving current count in threshold calculations

2. **Update threshold calculation methods:**
   - Modify `IsReleaseThresholdReached()`, `IsProposalRejected()`, `IsProposalAbstained()`, and `CheckEnoughVoteAndApprovals()` to accept parliament member count as a parameter
   - Pass `proposal.ParliamentMemberCountAtCreation` instead of calling `GetCurrentMinerList().Count`

3. **Filter votes by validity:**
   - When counting approvals/rejections/abstentions, only count addresses that were parliament members at creation time
   - This prevents new members from voting on old proposals and ensures vote counts remain consistent

**Invariant Checks:**
- Assert that votes are only counted from addresses that were parliament members when the proposal was created
- Add validation that parliament member count used in calculations matches stored snapshot

**Test Cases:**
- Test proposal approval with parliament size increase between voting and release
- Test proposal rejection with parliament size decrease between voting and release  
- Test vote threshold calculation with miner list changes
- Test abstention threshold calculation with miner list changes
- Verify that proposals maintain consistent approval status across term transitions

### Proof of Concept

**Initial State:**
- Parliament has 9 members (miners)
- Organization has MinimalApprovalThreshold = 6667 (66.67%)
- Proposal created targeting a system upgrade

**Transaction Steps:**

1. **T0 - Proposal Creation:**
   - Call `CreateProposal()` with 9-member parliament
   - Required approvals to pass: `ceil(6667 * 9 / 10000) = 7 votes`

2. **T1 - Voting Phase:**
   - 7 miners approve the proposal
   - Check: `7 * 10000 >= 6667 * 9` → `70000 >= 60003` → TRUE (proposal meets threshold)

3. **T2 - Term Transition:**
   - Consensus `NextTerm()` is called
   - Miner list updated to 12 members
   - Parliament size now = 12

4. **T3 - Release Attempt:**
   - Proposer calls `Release(proposalId)`
   - Contract checks: `7 * 10000 >= 6667 * 12` → `70000 >= 80004` → FALSE
   - Transaction fails with "Not approved" error

**Expected Result:**
Proposal should release successfully since it had 7/9 (77.8%) approvals, exceeding the 66.67% threshold.

**Actual Result:**
Proposal fails to release because the same 7 approvals now represent only 7/12 (58.3%) of the enlarged parliament, falling below the 66.67% threshold.

**Success Condition:**
The vulnerability is confirmed when a legitimately approved proposal (meeting thresholds at voting time) fails to release due to parliament size changes, or when a proposal that should be rejected incorrectly passes due to parliament size reduction.

### Citations

**File:** protobuf/parliament_contract.proto (L116-143)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L13-20)
```csharp
    private List<Address> GetCurrentMinerList()
    {
        RequireConsensusContractStateSet();
        var miner = State.ConsensusContract.GetCurrentMinerList.Call(new Empty());
        var members = miner.Pubkeys.Select(publicKey =>
            Address.FromPublicKey(publicKey.ToByteArray())).ToList();
        return members;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-70)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L72-78)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(parliamentMembers.Contains);
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L94-102)
```csharp
    private bool IsVoteThresholdReached(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
                .Count(parliamentMembers.Contains) * AbstractVoteTotal >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold * parliamentMembers.Count;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L31-42)
```csharp
    public override MinerList GetCurrentMinerList(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var round)
            ? new MinerList
            {
                Pubkeys =
                {
                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))
                }
            }
            : new MinerList();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTestBase.cs (L151-161)
```csharp
    private async Task InitializeConsensusAsync()
    {
        await ConsensusContractStub.InitialAElfConsensusContract.SendAsync(new InitialAElfConsensusContractInput
        {
            IsTermStayOne = true
        });
        var minerList = new MinerList
            { Pubkeys = { InitialMinersKeyPairs.Select(m => ByteStringHelper.FromHexString(m.PublicKey.ToHex())) } };
        await ConsensusContractStub.FirstRound.SendAsync(
            minerList.GenerateFirstRoundOfNewTerm(MiningInterval, BlockchainStartTime));
    }
```
