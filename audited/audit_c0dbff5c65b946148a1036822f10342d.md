### Title
Miners Lose Term Credit When Replacing Pubkey Before Term End Due to Stale Round Data

### Summary
When a miner replaces their public key via `ReplaceCandidatePubkey`, their candidateInformation is transferred to the new pubkey and removed from the old pubkey. However, the consensus contract's stored round data for previous rounds still contains the old pubkey. When `TakeSnapshot` is called at term end, it retrieves miners from the stored round data (containing old pubkeys), but the early return at line 485 prevents updating the Terms list because the old pubkey's candidateInformation is null. This causes miners to lose credit for terms where they successfully produced blocks.

### Finding Description

The vulnerability exists in the interaction between pubkey replacement and term snapshot logic.

**Root Cause:**

When `ReplaceCandidatePubkey` is called, the Election contract removes the old pubkey's candidateInformation: [1](#0-0) 

The consensus contract is notified and updates the **current** round's `RealTimeMinersInformation` to use the new pubkey: [2](#0-1) 

However, previous rounds that are already stored in state remain unchanged and still contain the old pubkey.

**Failure Point:**

When a term ends, `TakeSnapshot` is called by the consensus contract: [3](#0-2) 

It calls `GetPreviousTermMinerPubkeyList`, which returns pubkeys directly from the stored round data without applying any pubkey replacement mapping: [4](#0-3) 

For each pubkey in this list, `UpdateCandidateInformation` is called. This private method has an early return when candidateInformation is null: [5](#0-4) 

**Why Protections Fail:**

The code has a `GetNewestPubkey` function that maps old pubkeys to their newest replacements: [6](#0-5) 

This function is used correctly in other parts of the codebase (e.g., when withdrawing votes): [7](#0-6) 

However, it is **not used** in the `TakeSnapshot` flow before calling `UpdateCandidateInformation`, causing the old (now null) pubkey to be used instead of the new one.

### Impact Explanation

**Direct Impact:**
- Miners who replace their pubkeys lose credit for any terms where they produced blocks if the replacement happens before the term ends and `TakeSnapshot` is called
- The `Terms` list in candidateInformation becomes incomplete, missing terms where the miner actually participated
- The `ContinualAppointmentCount` is not updated correctly, breaking continuity tracking

**Affected Parties:**
- Any miner who uses the pubkey replacement feature
- Voters who rely on candidate history to make informed voting decisions
- Any off-chain systems or UI that display miner participation history

**Severity Justification:**
- **High**: This directly affects the integrity of miner participation records, which are fundamental to the election system's transparency and accountability
- The Terms list is documented as indicating "which terms the candidate participated in" - this invariant is violated
- Missing term credits could affect future reward calculations or eligibility if the Terms list is used in such logic

### Likelihood Explanation

**Attacker Capabilities:**
- Any miner with a valid candidateInformation entry can trigger this by calling `ReplaceCandidatePubkey`
- No special privileges required beyond being a registered candidate
- The vulnerability triggers automatically when the term ends

**Attack Complexity:**
- Very simple: Just call `ReplaceCandidatePubkey` at any time during or before a term ends
- The term credit loss happens passively when `TakeSnapshot` is called by the consensus contract

**Feasibility Conditions:**
- Pubkey replacement is a legitimate feature, so using it is not suspicious
- No special timing or race conditions required
- Works with any miner in any term

**Probability:**
- **High**: This will occur for every miner who replaces their pubkey before a term ends
- The feature is specifically designed for key rotation scenarios, so usage is expected
- No detection mechanism exists to warn users of the credit loss

### Recommendation

**Code-Level Mitigation:**

Modify the `TakeSnapshot` method to translate old pubkeys to their newest replacements before updating candidate information:

```csharp
foreach (var pubkey in previousTermMinerList)
{
    var newestPubkey = GetNewestPubkey(pubkey);
    UpdateCandidateInformation(newestPubkey, input.TermNumber, previousTermMinerList);
}
```

**Invariant Checks:**
- Add assertion that if a pubkey is in previousTermMinerList but has null candidateInformation, check if it has a replacement and use that
- Add logging when pubkey translation occurs to aid debugging

**Test Cases:**
1. Test scenario where miner replaces pubkey mid-term and verify term is correctly recorded on new pubkey
2. Test scenario where miner replaces pubkey multiple times and verify all terms are recorded on final pubkey
3. Test that ContinualAppointmentCount is correctly maintained across pubkey replacements
4. Verify that both initial miners and regular candidates handle pubkey replacement correctly

### Proof of Concept

**Initial State:**
- Miner A is registered with pubkey "oldKey" 
- Miner A is selected as a block producer for term N (e.g., term 5)
- Miner A successfully produces blocks during term N

**Exploit Steps:**
1. Before term N ends, Miner A calls `ReplaceCandidatePubkey(oldKey, newKey)`
   - Election contract transfers candidateInformation from "oldKey" to "newKey"
   - Election contract removes `State.CandidateInformationMap["oldKey"]` (line 242)
   - Consensus contract updates current round to use "newKey"
   - Previous rounds still have "oldKey" in `RealTimeMinersInformation`

2. Term N ends, consensus contract calls `TakeSnapshot(termNumber: N, ...)`
   - `GetPreviousTermMinerPubkeyList` returns list including "oldKey" (from stored round data)
   - For "oldKey", `UpdateCandidateInformation("oldKey", N, ...)` is called
   - `candidateInformation = State.CandidateInformationMap["oldKey"]` returns null
   - Function returns early at line 485
   - Term N is NOT added to the Terms list

**Expected Result:**
- Term N should be added to the Terms list of the candidateInformation for "newKey"
- ContinualAppointmentCount should be updated for "newKey"

**Actual Result:**
- Term N is missing from the Terms list
- ContinualAppointmentCount is not updated
- Miner loses credit for participating in term N despite successfully producing blocks

**Success Condition:**
Query `GetCandidateInformation("newKey")` and verify that term N is missing from the Terms array, even though "oldKey" (now "newKey") was a miner during term N.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L237-242)
```csharp
        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L331-357)
```csharp
    public override StringValue GetNewestPubkey(StringValue input)
    {
        return new StringValue { Value = GetNewestPubkey(input.Value) };
    }

    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
    }

    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L402-434)
```csharp
    public override Empty TakeSnapshot(TakeElectionSnapshotInput input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        Assert(State.AEDPoSContract.Value == Context.Sender, "No permission.");

        SavePreviousTermInformation(input);

        if (State.ProfitContract.Value == null)
        {
            var profitContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            // Return if profit contract didn't deployed. (Often in test cases.)
            if (profitContractAddress == null) return new Empty();
            State.ProfitContract.Value = profitContractAddress;
        }

        // Update snapshot of corresponding voting record by the way.
        State.VoteContract.TakeSnapshot.Send(new TakeSnapshotInput
        {
            SnapshotNumber = input.TermNumber,
            VotingItemId = State.MinerElectionVotingItemId.Value
        });

        State.CurrentTermNumber.Value = input.TermNumber.Add(1);

        var previousTermMinerList =
            State.AEDPoSContract.GetPreviousTermMinerPubkeyList.Call(new Empty()).Pubkeys.ToList();

        foreach (var pubkey in previousTermMinerList)
            UpdateCandidateInformation(pubkey, input.TermNumber, previousTermMinerList);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L481-492)
```csharp
    private void UpdateCandidateInformation(string pubkey, long lastTermNumber,
        List<string> previousMiners)
    {
        var candidateInformation = State.CandidateInformationMap[pubkey];
        if (candidateInformation == null) return;
        candidateInformation.Terms.Add(lastTermNumber);
        var victories = GetVictories(previousMiners);
        candidateInformation.ContinualAppointmentCount = victories.Contains(ByteStringHelper.FromHexString(pubkey))
            ? candidateInformation.ContinualAppointmentCount.Add(1)
            : 0;
        State.CandidateInformationMap[pubkey] = candidateInformation;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L136-146)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L464-473)
```csharp
    public override PubkeyList GetPreviousTermMinerPubkeyList(Empty input)
    {
        var lastRoundNumber = State.FirstRoundNumberOfEachTerm[State.CurrentTermNumber.Value].Sub(1);
        var lastRound = State.Rounds[lastRoundNumber];
        if (lastRound == null || lastRound.RoundId == 0) return new PubkeyList();
        return new PubkeyList
        {
            Pubkeys = { lastRound.RealTimeMinersInformation.Keys }
        };
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L60-70)
```csharp
        });

        // Update related candidate
        var oldVoteOptionPublicKey = GetNewestPubkey(votingRecord.Option);
        var oldCandidateVotes = State.CandidateVotes[oldVoteOptionPublicKey];
        oldCandidateVotes.ObtainedActiveVotingRecordIds.Remove(input.VoteId);
        oldCandidateVotes.ObtainedActiveVotedVotesAmount =
            oldCandidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        oldCandidateVotes.AllObtainedVotedVotesAmount =
            oldCandidateVotes.AllObtainedVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[oldVoteOptionPublicKey] = oldCandidateVotes;
```
