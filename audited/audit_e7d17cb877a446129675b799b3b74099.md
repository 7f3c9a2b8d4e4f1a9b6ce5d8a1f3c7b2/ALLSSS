### Title
NextRound Validation Fails to Detect Duplicate Mining Orders Due to Incorrect Distinct() Usage

### Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` function incorrectly validates uniqueness of `FinalOrderOfNextRound` values by calling `.Distinct()` on `MinerInRound` objects instead of the order values themselves. This allows multiple miners to have identical `FinalOrderOfNextRound` values, which breaks the next round's mining schedule by assigning multiple miners to the same time slot, potentially causing consensus failure and chain halt.

### Finding Description

The validation logic in `NextRoundMiningOrderValidationProvider` contains a critical bug: [1](#0-0) 

This code calls `.Distinct()` on a collection of `MinerInRound` objects. Since `MinerInRound` is a protobuf-generated class [2](#0-1) , its equality comparison includes all fields (pubkey, signature, order, etc.). Different miners will always be considered distinct objects even if they share the same `FinalOrderOfNextRound` value.

**Example scenario:**
- 5 miners in current round, 3 successfully mine blocks
- Malicious extra block producer creates `NextRoundInput` where all 3 miners have `FinalOrderOfNextRound = 1`
- Validation counts: `distinctCount = 3` (3 distinct miner objects) and `OutValue count = 3`
- Validation **incorrectly passes** (3 == 3)

This validation is invoked during the `NextRound` consensus behavior: [3](#0-2) 

The validated round data is then used to generate the next round's mining schedule: [4](#0-3) [5](#0-4) 

When duplicate `FinalOrderOfNextRound` values exist, the `occupiedOrders` list contains duplicates but `.Contains()` only excludes the value once. This results in multiple miners being assigned `Order = 1` in the next round, while non-mining miners get incorrectly calculated orders.

### Impact Explanation

**Consensus Integrity Compromise:**
When multiple miners have the same `Order` value in a round:
- Multiple miners attempt to produce blocks at the same time slot
- Undefined behavior occurs as the consensus protocol expects one miner per slot
- Block production fails or creates competing blocks
- Chain may halt or fork due to invalid round structure

**Affected Parties:**
- All network participants experience consensus disruption
- Miners lose block rewards due to failed round transitions
- Chain liveness and safety guarantees are violated

**Severity: HIGH** - This directly violates the critical invariant of "miner schedule integrity" and can cause operational impact through DoS of consensus flows.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be selected as extra block producer (rotates among all miners)
- No special privileges beyond being a legitimate miner
- Attack requires crafting malicious `NextRoundInput` data

**Attack Complexity:**
- Low - simply set multiple miners' `FinalOrderOfNextRound` to same value
- The NextRound transaction is generated at: [6](#0-5) 

**Feasibility:**
- Extra block producer role rotates regularly among miners
- Malicious miner can exploit this during their turn
- No economic cost beyond normal mining operations
- Detection is difficult as it appears as normal round transition

**Probability: HIGH** - The vulnerability is easily exploitable with regular miner privileges and the validation bypass is guaranteed due to the code bug.

### Recommendation

**Code Fix:**
Modify the validation to check distinctness of the `FinalOrderOfNextRound` values, not the miner objects:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Extract the value
    .Distinct()
    .Count();
```

**Additional Validation:**
Add explicit check that all `FinalOrderOfNextRound` values are within valid range [1, minersCount] and form a contiguous set.

**Test Cases:**
1. Test with duplicate `FinalOrderOfNextRound` values - should fail validation
2. Test with gaps in order sequence - should fail validation  
3. Test with orders outside valid range - should fail validation
4. Test with correct unique orders - should pass validation

### Proof of Concept

**Initial State:**
- Current round with 5 miners: [A, B, C, D, E]
- Miners A, B, C successfully produce blocks (have `OutValue != null`)
- Miner E is selected as extra block producer for round transition

**Attack Steps:**
1. Miner E generates malicious `NextRoundInput`:
   - Set `MinerA.FinalOrderOfNextRound = 1`
   - Set `MinerB.FinalOrderOfNextRound = 1`  
   - Set `MinerC.FinalOrderOfNextRound = 1`
   - Miners D and E have `FinalOrderOfNextRound = 0` (didn't mine)

2. Miner E submits `NextRound` transaction with malicious data

3. Validation executes:
   - `distinctCount = 3` (counts 3 distinct MinerInRound objects)
   - `OutValue count = 3` (miners A, B, C have OutValue)
   - Validation passes: `3 == 3` âœ“

4. `GenerateNextRoundInformation` processes the round:
   - `occupiedOrders = [1, 1, 1]`
   - `ableOrders = [2, 3, 4, 5]` (only order 1 excluded once)
   - Miners A, B, C all assigned `Order = 1` in next round
   - Miners D, E assigned `Order = 2, 3`

**Expected Result:**
Validation should reject the malicious round data due to duplicate orders.

**Actual Result:**
Validation passes, and next round has 3 miners competing for Order=1 time slot, causing consensus failure.

**Success Condition:**
Chain enters invalid state with multiple miners assigned identical mining order, violating consensus protocol integrity.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L164-171)
```csharp
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
```
