### Title
Side Chain Validator Permanent Control Through Cross-Chain Indexing Censorship

### Summary
Side chains initialized with malicious validators can maintain permanent control by refusing to index parent chain consensus data. Since side chains never trigger NextTerm transitions and have no Election Contract, the only mechanism for validator list updates is through cross-chain indexing, which requires current validators' participation. Malicious validators can censor this process indefinitely, preventing any validator replacement.

### Finding Description

**Root Cause:** Side chains lack any autonomous mechanism for validator replacement outside of cross-chain consensus data indexing, which is controlled by the current validators themselves.

**Code Flow Analysis:**

1. **Side Chains Never Use NextTerm:** The side chain consensus behavior provider always returns `NextRound`, never `NextTerm`: [1](#0-0) 

2. **Side Chains Have No Election Contract:** During initialization, when `IsSideChain = true`, the contract sets `IsMainChain = false` and returns without initializing the Election Contract: [2](#0-1) 

3. **Only Validator Update Path for Side Chains:** The sole mechanism for updating validators on side chains is in `GenerateNextRoundInformation`, which checks if the main chain miner list has changed: [3](#0-2) 

4. **Main Chain Miner List Update Dependency:** This check depends on `State.MainChainCurrentMinerList.Value`, which is ONLY updated by `UpdateInformationFromCrossChain`: [4](#0-3) 

5. **Cross-Chain Contract Authorization:** `UpdateInformationFromCrossChain` can ONLY be called by the CrossChain contract and ONLY on side chains: [5](#0-4) 

6. **Conditional Consensus Update:** The CrossChain contract calls `UpdateConsensusInformation` (which invokes `UpdateInformationFromCrossChain`) ONLY when indexing parent chain blocks that contain consensus extra data: [6](#0-5) 

7. **Validator-Controlled Indexing:** Both proposing and releasing cross-chain indexing proposals require the caller to be a current miner: [7](#0-6) [8](#0-7) 

8. **Current Miner Verification:** The permission check delegates to the consensus contract, which verifies if the address is an active block producer: [9](#0-8) 

**Why Existing Protections Fail:**

The `RecordCandidateReplacement` mechanism requires an Election Contract sender: [10](#0-9) 

Since side chains don't initialize the Election Contract, this replacement path is unavailable. The evil node replacement logic in `GenerateNextRoundInformation` is explicitly only for main chains: [11](#0-10) 

### Impact Explanation

**Concrete Harm:**
- **Permanent Validator Control:** Malicious validators maintain indefinite control over block production, transaction inclusion, and consensus
- **Cross-Chain Censorship:** Validators can selectively index or refuse to index parent chain data, breaking cross-chain functionality
- **Governance Paralysis:** All governance actions requiring validator participation (proposal execution, emergency responses) can be blocked
- **Economic Damage:** Side chain becomes isolated from parent chain updates, unable to receive legitimate validator list changes, security patches, or protocol upgrades
- **Trust Model Violation:** The fundamental assumption that parent chain can govern side chains is broken

**Affected Parties:**
- All users and applications on the compromised side chain
- Parent chain stakeholders who expect governance authority over side chains
- Cross-chain protocols depending on reliable validator sets

**Severity Justification:** Critical - this represents a complete compromise of the side chain's security and governance model with no recovery mechanism.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control of initial validator set during side chain deployment (stated as precondition in the question)
- Ability to coordinate among colluding validators to refuse cross-chain indexing

**Attack Complexity:** 
- **Very Low** - The attack is passive; malicious validators simply don't call `ProposeCrossChainIndexing` or `ReleaseCrossChainIndexingProposal` with parent chain consensus data
- No complex transaction sequences or timing requirements
- No need to exploit cryptographic weaknesses or race conditions

**Feasibility Conditions:**
- Side chain must be initialized with malicious/colluding validator majority
- This is explicitly the scenario described in the security question

**Detection/Operational Constraints:**
- The attack is difficult to distinguish from network issues or operational failures
- No automatic circuit breakers or emergency governance overrides exist
- Parent chain has no mechanism to force side chain validator updates

**Probability Reasoning:**
If the precondition (malicious initial validators) is met, the attack succeeds with 100% probability. The design provides no countermeasures, fallbacks, or recovery mechanisms. This is a structural vulnerability in the side chain architecture.

### Recommendation

**Immediate Mitigations:**

1. **Add Governance Override Mechanism:** Implement a special method callable by parent chain governance to force validator list updates on side chains:
```
public override Empty ForceUpdateValidators(ForceUpdateValidatorsInput input) {
    // Verify caller is parent chain governance/authority
    Assert(Context.Sender == State.ParentChainGovernance.Value, "No permission.");
    
    // Update validator list directly
    State.MainChainCurrentMinerList.Value = input.NewMinerList;
    
    // Trigger immediate round regeneration with new validators
    // ...
}
```

2. **Add Automatic Cross-Chain Indexing Enforcement:** Modify consensus to automatically generate and include cross-chain indexing transactions when parent chain consensus data is available, removing validator discretion: [3](#0-2) 

3. **Add Validator Inactivity Detection:** Implement automatic validator replacement when cross-chain indexing hasn't occurred within expected time bounds.

4. **Add Emergency Pause Mechanism:** Allow parent chain to pause side chain operation and force validator updates when censorship is detected.

**Invariant Checks to Add:**
- Side chain must index parent chain consensus data within N blocks/time period
- Cross-chain indexing proposals must be created and released within defined timeframes
- Parent chain governance must retain ultimate authority over side chain validator sets

**Test Cases:**
- Test side chain with malicious validators refusing to index consensus data
- Test parent chain forced validator update capability
- Test automatic validator replacement on prolonged indexing failure
- Test emergency governance override scenarios

### Proof of Concept

**Required Initial State:**
1. Side chain initialized with validators V1, V2, V3 (all colluding/malicious)
2. Parent chain has legitimate updated validator list V4, V5, V6 in recent blocks with consensus extra data
3. Side chain is operational and producing blocks normally

**Attack Execution Steps:**

**Step 1:** Malicious validators V1, V2, V3 continue producing blocks using `NextRound` transitions
- Side chain consensus remains functional with original validator set
- `SideChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` returns `NextRound`

**Step 2:** Malicious validators refuse to call `ProposeCrossChainIndexing` with parent chain consensus data
- No proposals created to index parent chain blocks containing updated validator list
- Or validators create proposals but never call `ReleaseCrossChainIndexingProposal`

**Step 3:** Without cross-chain indexing of consensus data:
- `UpdateInformationFromCrossChain` is never invoked
- `State.MainChainCurrentMinerList.Value` never updates
- `IsMainChainMinerListChanged()` always returns false
- `GenerateNextRoundInformation` never generates new round with updated validators

**Step 4:** Malicious validators maintain control indefinitely:
- Continue producing blocks with original validator set
- Can censor any transactions or governance actions
- Can selectively index only non-consensus cross-chain data to appear operational

**Expected Result:** 
Validator list updates from parent chain are applied to side chain within reasonable timeframe.

**Actual Result:** 
Malicious validators maintain permanent control. No mechanism exists to force validator updates without their cooperation. Side chain becomes isolated from parent chain governance.

**Success Condition for Attack:** 
After 1000+ blocks (or any arbitrary period), side chain validator set remains V1, V2, V3 despite parent chain validator set being V4, V5, V6, demonstrating permanent malicious control.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-23)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L37-41)
```csharp
        if (input.IsTermStayOne || input.IsSideChain)
        {
            State.IsMainChain.Value = false;
            return new Empty();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L133-134)
```csharp
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-295)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-299)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L34-38)
```csharp
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L56-61)
```csharp

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L783-788)
```csharp
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L286-286)
```csharp
        AssertAddressIsCurrentMiner(Context.Sender);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L297-297)
```csharp
        AssertAddressIsCurrentMiner(Context.Sender);
```
