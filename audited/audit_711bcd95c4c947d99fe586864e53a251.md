### Title
Inconsistent Vote Counting Allows MinimalVoteThreshold Bypass via Member Removal

### Summary
The Association contract's vote threshold validation contains an inconsistency where individual vote type checks (approvals, rejections, abstentions) filter by current membership, but the total vote count for `MinimalVoteThreshold` includes votes from removed members. This allows proposals to satisfy participation requirements with fewer current-member votes than intended, undermining governance integrity.

### Finding Description

The vote counting logic in `Association_Helper.cs` has a critical inconsistency: [1](#0-0) [2](#0-1) [3](#0-2) 

The functions `IsProposalRejected()`, `IsProposalAbstained()`, and the approval count in `CheckEnoughVoteAndApprovals()` all filter votes using `.Count(organization.OrganizationMemberList.Contains)` to only count votes from current members. However, the total vote threshold check does NOT filter by membership - it counts all votes in the concatenated lists.

**Root Cause**: Members can vote on a proposal, then be removed from the organization via `RemoveMember()`: [4](#0-3) 

When members are removed, their addresses remain in the proposal's `Approvals`, `Rejections`, or `Abstentions` lists, but they are no longer in `OrganizationMemberList`. The inconsistent filtering creates a scenario where:
- Ex-member votes are IGNORED for rejection/abstention/approval threshold checks
- Ex-member votes are COUNTED for the MinimalVoteThreshold check

**Why Protections Fail**: The voting methods properly validate membership before adding votes: [5](#0-4) 

However, there is no mechanism to invalidate or recount votes when members are removed. The proposal state is not updated, and the vote counting logic has this filtering inconsistency.

### Impact Explanation

**Concrete Harm**:
1. **Governance Subversion**: Proposals can pass the `MinimalVoteThreshold` participation requirement while having fewer current-member votes than intended. For example, if an organization has 10 members with `MinimalVoteThreshold=8`, a proposal could pass with only 6 current-member votes if 2 members who voted are subsequently removed.

2. **Strategic Manipulation**: Organizations can strategically remove dissenting voters after they vote. Their rejection votes won't count toward `MaximalRejectionThreshold` (filtered out), but will still count toward `MinimalVoteThreshold` (not filtered), potentially enabling proposals that should fail.

3. **Threshold Semantics Violation**: The organization validation enforces `MinimalVoteThreshold <= organizationMemberCount`, establishing that thresholds are relative to current membership. The unfiltered total count violates this semantic, allowing vote counts that exceed current membership.

**Affected Parties**: All Association organizations using vote thresholds are affected. This impacts governance decisions for contract deployments, parameter changes, and treasury operations.

**Severity**: Medium - While it requires governance control to remove members, it creates an exploitable inconsistency that undermines the intended participation requirements and can enable proposals with insufficient current-member support.

### Likelihood Explanation

**Attacker Capabilities**: Requires ability to pass proposals in the organization (to trigger `RemoveMember()`). This is realistic as organizations with multiple active proposals may have legitimate member changes.

**Attack Complexity**: Moderate. The exploitation sequence is:
1. Create target proposal
2. Members vote on it
3. Pass a separate proposal to remove specific voters
4. Target proposal's vote counts are now manipulated

**Feasibility Conditions**:
- Organization must support member removal (standard feature)
- Multiple proposals must be active simultaneously
- Timing required to remove members before proposal release
- No special privileges needed beyond normal organization participation

**Detection Constraints**: This inconsistency occurs through legitimate contract operations and leaves no obvious on-chain evidence of manipulation. The vote counts in `GetProposal()` show total counts without filtering, masking the actual current-member participation. [6](#0-5) 

**Probability**: Medium - Member changes are infrequent but legitimate operations. The vulnerability manifests whenever member removal occurs while proposals have outstanding votes.

### Recommendation

**Code-Level Mitigation**: Modify `CheckEnoughVoteAndApprovals()` to filter the total vote count by current membership, matching the behavior of other vote threshold checks:

```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
    proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
    proposal.Rejections.Count(organization.OrganizationMemberList.Contains) >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**Invariant Checks**:
1. Ensure all vote counting logic consistently filters by current membership
2. Add validation that total votes counted never exceed current organization member count
3. Consider invalidating proposals when membership changes significantly (e.g., >X% of voters removed)

**Test Cases**:
1. Member votes, then is removed, verify their vote doesn't count toward any threshold
2. Proposal has 8 votes from 10 members, 3 voters removed, verify proposal fails if remaining votes < MinimalVoteThreshold
3. Verify rejection count, abstention count, and total vote count all use consistent filtering

### Proof of Concept

**Initial State**:
- Organization with 10 members: A, B, C, D, E, F, G, H, I, J
- Thresholds: `MinimalVoteThreshold=8`, `MinimalApprovalThreshold=6`, `MaximalRejectionThreshold=2`

**Exploitation Steps**:

1. Create Proposal P1 (target proposal to manipulate)

2. Members vote on P1:
   - 6 members approve: A, B, C, D, E, F
   - 2 members reject: G, H
   - Total votes = 8

3. Create and pass Proposal P2 to remove members G and H

4. Organization now has 8 members: A, B, C, D, E, F, I, J

5. Attempt to release P1:

**Expected Result**: Proposal should fail because only 6 current members voted (75% participation, below 80% implied by MinimalVoteThreshold=8 out of 10 original members)

**Actual Result**: 
- `rejectionMemberCount = 0` (G, H filtered out as ex-members)
- `approvedMemberCount = 6` (current members)
- Total vote count = 8 (includes G, H's votes)
- All thresholds pass: 0 rejections ≤ 2, 6 approvals ≥ 6, 8 votes ≥ 8
- Proposal releases successfully despite only 6 current members participating

**Success Condition**: The proposal passes MinimalVoteThreshold check with votes from removed members, demonstrating the inconsistent counting behavior.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L36-38)
```csharp
            ApprovalCount = proposal.Approvals.Count,
            RejectionCount = proposal.Rejections.Count,
            AbstentionCount = proposal.Abstentions.Count,
```

**File:** contract/AElf.Contracts.Association/Association.cs (L143-161)
```csharp
    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Rejections.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Reject),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
