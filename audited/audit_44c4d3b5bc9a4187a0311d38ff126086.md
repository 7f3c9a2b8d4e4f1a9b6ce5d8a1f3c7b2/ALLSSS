### Title
Cross-Chain NFT Protocol Creation Fails for Custom NFT Types Due to Incomplete Type Mapping Synchronization

### Summary
The `CrossChainCreate` method attempts to derive the NFT type full name from the symbol's short name prefix by looking it up in local state (`State.NFTTypeFullNameMap`), which only contains types initialized by `InitialNFTTypeNameMap()` or manually added via `AddNFTType`. When an NFT protocol using a custom type (added via `AddNFTType` on the mainchain) is created and synced to a sidechain, the cross-chain creation fails because the sidechain lacks the custom type mapping, even though the full NFT type name is already present in the token's `ExternalInfo` that was synced via `CrossChainCreateToken`.

### Finding Description

The vulnerability exists in the `CrossChainCreate` method's NFT type resolution logic. [1](#0-0) 

At line 78, `InitialNFTTypeNameMap()` is called, which only initializes 10 predefined NFT type mappings: [2](#0-1) 

The initialization creates mappings for: XX (Any), AR (Art), MU (Music), DN (DomainNames), VW (VirtualWorlds), TC (TradingCards), CO (Collectables), SP (Sports), UT (Utility), and BA (Badges). [3](#0-2) 

The code then extracts the first 2 characters of the symbol as the short name and attempts to look up the full name from `State.NFTTypeFullNameMap`. If the mapping doesn't exist (null), it throws an exception preventing the cross-chain protocol creation.

The root cause is that custom NFT types can be added on the mainchain via `AddNFTType`: [4](#0-3) 

This method requires Parliament governance approval and adds the type mapping only to the local chain's state. There is no mechanism to automatically synchronize these custom type mappings across chains.

However, when an NFT protocol is created on the mainchain, the full NFT type name is stored in the token's `ExternalInfo`: [5](#0-4) 

Line 196 adds the NFT type to external info with key `NftTypeMetadataKey`. This external info is synced to sidechains via `CrossChainCreateToken` in the MultiToken contract: [6](#0-5) 

The token info including all `ExternalInfo` is registered on the sidechain (line 492-503). The `CrossChainCreate` method correctly reads other metadata from the token's external info (baseUri, isTokenIdReuse) but fails to read the NFT type that's already available: [7](#0-6) 

The NFT type metadata key is defined as: [8](#0-7) 

### Impact Explanation

**Operational Impact - DoS of Cross-Chain NFT Flows:**
- When a custom NFT type is added on the mainchain and an NFT protocol using that type is created, users cannot access their NFT protocols on sidechains
- The cross-chain creation transaction will fail with the error "Full name of {shortName} not found. Use AddNFTType to add this new pair"
- This breaks the cross-chain functionality for all NFT protocols using custom types
- Affected parties include NFT protocol creators and users who need multi-chain NFT access

**Severity Justification (Medium):**
- This is not a fund theft or inflation vulnerability
- It's a denial of service that prevents legitimate cross-chain NFT protocol synchronization
- Workaround exists (Parliament can call `AddNFTType` on sidechains before cross-chain creation), but requires coordination and governance overhead
- The impact is limited to custom NFT types; the 10 predefined types work correctly

### Likelihood Explanation

**Reachable Entry Point:** `CrossChainCreate` is a public method callable after proper cross-chain token creation.

**Feasible Preconditions:**
1. Parliament governance adds a custom NFT type on the mainchain via `AddNFTType`
2. An NFT protocol is created on the mainchain using this custom type
3. The token is synced to a sidechain via `CrossChainCreateToken`
4. `CrossChainCreate` is called on the sidechain

**Execution Practicality:** All steps are standard operations under AElf's governance and cross-chain mechanisms. No attack is needed - this occurs during normal protocol usage.

**Probability:** HIGH - This will occur whenever:
- Custom NFT types are introduced (which is an intended feature as evidenced by `AddNFTType` and `RemoveNFTType` methods)
- There's a time lag between adding types on mainchain vs sidechains
- Lack of coordination between mainchain and sidechain governance

The vulnerability represents a design flaw rather than an intentional attack, making it highly likely to manifest in production when the custom NFT type feature is utilized.

### Recommendation

**Code-Level Mitigation:**
Replace lines 89-93 in `CrossChainCreate` with:

```csharp
var nftTypeFullName = tokenInfo.ExternalInfo.Value.TryGetValue(NftTypeMetadataKey, out var nftType) 
    ? nftType 
    : null;
if (string.IsNullOrEmpty(nftTypeFullName))
    throw new AssertionException($"NFT type not found in token external info for {input.Symbol}");
```

This reads the NFT type directly from the token's `ExternalInfo` (which is already synced via cross-chain) instead of trying to derive it from local state mappings.

**Invariant Check:**
Add validation that the NFT type in `ExternalInfo` matches expected format and is not empty during cross-chain creation.

**Test Cases:**
1. Add custom NFT type on mainchain only
2. Create NFT protocol with custom type on mainchain
3. Sync token to sidechain via `CrossChainCreateToken`
4. Call `CrossChainCreate` on sidechain - should succeed (currently fails)
5. Verify NFT protocol info on sidechain contains correct custom NFT type

### Proof of Concept

**Required Initial State:**
- Mainchain Parliament governance approves and executes `AddNFTType` with `ShortName="CU"` and `FullName="CustomType"`
- Sidechain does NOT have this custom type mapping

**Transaction Steps:**

1. **On Mainchain:** Call `Create` with:
   ```
   CreateInput {
     nft_type: "CustomType",
     protocol_name: "MyCustomNFT",
     total_supply: 10000,
     // ... other fields
   }
   ```
   - Symbol generated: "CU123456789" (assuming random number is 123456789)
   - Token created in MultiToken with ExternalInfo containing `{"aelf_nft_type": "CustomType", ...}`

2. **Cross-Chain Sync:** Token is validated and synced to sidechain:
   - `ValidateTokenInfoExists` called on mainchain
   - `CrossChainCreateToken` called on sidechain with merkle proof
   - Token info with full ExternalInfo is registered on sidechain

3. **On Sidechain:** Call `CrossChainCreate` with:
   ```
   CrossChainCreateInput {
     symbol: "CU123456789"
   }
   ```

**Expected Result:** NFT protocol should be created on sidechain with NFT type "CustomType"

**Actual Result:** Transaction fails at line 91-93 with error:
```
"Full name of CU not found. Use AddNFTType to add this new pair."
```

**Success Condition for Exploit:** The cross-chain NFT protocol creation transaction reverts, preventing legitimate users from accessing their NFT protocol on the sidechain.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L78-78)
```csharp
        InitialNFTTypeNameMap();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L87-93)
```csharp
        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L131-150)
```csharp
    public override Empty AddNFTType(AddNFTTypeInput input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        var fullName = input.FullName;
        Assert(input.ShortName.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
        Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
        State.NFTTypeFullNameMap[input.ShortName] = fullName;
        State.NFTTypeShortNameMap[fullName] = input.ShortName;
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Add(input.ShortName, fullName);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeAdded
        {
            ShortName = input.ShortName,
            FullName = input.FullName
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L184-201)
```csharp
    private ExternalInfo GetTokenExternalInfo(CreateInput input)
    {
        if (input.Metadata != null) AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var tokenExternalInfo = input.Metadata == null
            ? new ExternalInfo()
            : new ExternalInfo
            {
                Value = { input.Metadata.Value }
            };

        // Add NFT Type to external info.
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
        return tokenExternalInfo;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-62)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;

        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }

        return nftTypes;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-533)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }

        return new Empty();
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L7-7)
```csharp
    private const string NftTypeMetadataKey = "aelf_nft_type";
```
