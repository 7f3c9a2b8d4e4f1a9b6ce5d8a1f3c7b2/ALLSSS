### Title
Secret Sharing Manipulation Through Selective Decrypted Piece Withholding

### Summary
The `RevealSharedInValues()` function requires all miners (`minersCount`) to provide decrypted pieces before revealing a miner's InValue, despite the underlying Shamir's Secret Sharing scheme only needing 2/3 threshold (`minimumCount`). Any single malicious miner can intentionally withhold their decrypted pieces to prevent targeted miners' InValue revelation, forcing those miners to use predictable fake values that manipulate consensus randomness and mining order for subsequent rounds.

### Finding Description

The vulnerability exists in the secret sharing revelation logic: [1](#0-0) 

The code checks that `DecryptedPieces.Count < minersCount` (requiring 100% of miners) before attempting InValue reconstruction, but the actual secret reconstruction only requires `minimumCount` (2/3 threshold): [2](#0-1) 

This mismatch creates an attack vector. During the `UpdateValue` consensus behavior, miners provide their decrypted pieces through `UpdateValueInput`: [3](#0-2) 

These decrypted pieces are processed without validation: [4](#0-3) 

No validation exists to ensure miners provide all decrypted pieces they possess: [5](#0-4) 

When InValue revelation fails, miners without PreviousInValue use a deterministic fake value: [6](#0-5) 

This fake value is used in signature calculation that determines next round mining order: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Consensus Randomness Manipulation:** An attacker can selectively prevent specific miners' InValue revelation, forcing them to use predictable fake values instead of their actual InValues. Since mining order for the next round is calculated via `GetAbsModulus(signature.ToInt64(), minersCount) + 1`, and the signature is computed by XORing the InValue with previous round signatures, the attacker can influence which miners get favorable or unfavorable mining positions.

**Concrete Attack Path:**
1. Attacker decrypts all other miners' encrypted pieces (off-chain)
2. For each target miner, attacker calculates resulting mining orders under two scenarios:
   - Scenario A: Reveal the miner's InValue (provide decrypted piece)
   - Scenario B: Withhold decrypted piece (force fake value usage)
3. Attacker selectively withholds pieces where scenario B produces more favorable mining order for themselves
4. This manipulation can increase attacker's mining frequency, enable consecutive block production, or disadvantage competing miners

**Severity:** The cryptographic secret sharing scheme requires only 2/3 participation but the implementation requires 100%, allowing any single miner to block revelation with zero detection or penalty. This directly violates the "miner schedule integrity" critical invariant.

### Likelihood Explanation

**Attacker Capabilities:** Single malicious miner in the active miner set can execute this attack. The attacker only needs to:
1. Run standard consensus node software with minor modifications to the off-chain secret sharing service
2. Selectively omit certain pubkeys from the `DecryptedPieces` map in their `UpdateValueInput`

**Attack Complexity:** Trivial. The off-chain secret sharing service already decrypts all pieces: [9](#0-8) 

Attacker simply filters which decrypted pieces to include before calling `UpdateValue`: [10](#0-9) 

**Detection/Penalties:** None. No on-chain validation enforces providing all decrypted pieces. The system cannot distinguish between:
- Honest miner who failed to decrypt due to technical issues
- Malicious miner intentionally withholding decryptions

**Economic Rationality:** Mining order directly affects block rewards and transaction fee capture. Earlier positions in a round typically capture more transactions. Cost is zero; benefit is improved mining position.

### Recommendation

**Primary Fix:** Change the threshold check to use `minimumCount` instead of `minersCount`, aligning with the actual secret sharing scheme requirements:

```csharp
// In RevealSharedInValues() at line 36, change:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
// To:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

This change should be applied at: [11](#0-10) 

And the corresponding location: [12](#0-11) 

**Additional Safeguards:**
1. Add reputation tracking for miners who consistently fail to provide decrypted pieces
2. Consider cryptographic proofs of correct decryption to prevent selective withholding
3. Add test cases verifying InValue revelation succeeds with exactly `minimumCount` decrypted pieces

### Proof of Concept

**Initial State:**
- 5 active miners: M1 (attacker), M2, M3, M4, M5
- minimumCount = 5 * 2 / 3 = 3
- minersCount = 5
- Round N-1: M2 produced encrypted pieces for all miners
- Round N: All miners mine in sequence

**Attack Execution:**

1. **Round N, M1's turn to mine:**
   - M1 decrypts M2's encrypted piece (off-chain): `decrypted_M2 = DecryptMessage(M2.pubkey, M1.privateKey, M2.encryptedPieces[M1])`
   - M1 calculates two scenarios:
     - With M2's real InValue: `realSignature = CalculateSignature(M2.realInValue)`
     - With M2's fake InValue: `fakeSignature = CalculateSignature(HashHelper.ComputeFrom(M2.pubkey + height))`
   - M1 compares resulting mining orders and chooses favorable scenario
   - M1 submits `UpdateValue` with `DecryptedPieces` excluding M2's piece

2. **Round N, M3-M5 mine:**
   - M3, M4, M5 (honest) each provide their decrypted pieces for M2
   - After all miners complete: M2.DecryptedPieces.Count = 3 (from M3, M4, M5)

3. **Round N → Round N+1 transition:**
   - `RevealSharedInValues()` is called
   - Check: `M2.EncryptedPieces.Count >= 3` ✓ (passes)
   - Check: `M2.DecryptedPieces.Count >= 5` ✗ (fails, only 3 pieces)
   - M2's InValue is NOT revealed
   - M2 forced to use fake value in subsequent rounds

**Expected vs Actual Result:**
- Expected: With minimumCount=3 decrypted pieces, M2's InValue should be successfully revealed
- Actual: Despite having sufficient pieces cryptographically, revelation fails due to requiring 100% participation

**Success Condition:**
The attack succeeds when M1 can influence mining order by selectively preventing InValue revelation, measurable by:
1. M2's `PreviousInValue` remains empty after round transition
2. Mining order for subsequent rounds differs from what would occur with M2's real InValue
3. M1 achieves more favorable mining position without detection or penalty

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** protobuf/aedpos_contract.proto (L211-212)
```text
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-257)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L96-101)
```csharp
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L127-135)
```csharp
            var encryptedShares =
                secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].EncryptedPieces;
            if (!encryptedShares.Any() || !encryptedShares.ContainsKey(selfPubkey)) continue;
            var interestingMessage = encryptedShares[selfPubkey];
            var senderPublicKey = ByteArrayHelper.HexStringToByteArray(pubkey);

            var decryptedPiece =
                await _accountService.DecryptMessageAsync(senderPublicKey, interestingMessage.ToByteArray());
            decryptedPieces[pubkey] = decryptedPiece;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L162-162)
```csharp
            if (minerInRound.DecryptedPieces.Count < minersCount) continue;
```
