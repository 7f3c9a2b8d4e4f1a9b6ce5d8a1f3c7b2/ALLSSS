### Title
Permanent DOS of Profit Distribution Due to Lack of Error Handling for TokenContract Failures

### Summary
The Profit contract's `DistributeProfits` and `ClaimProfits` methods make multiple unchecked cross-contract calls to TokenContract for balance queries and token transfers. If TokenContract were to have unbounded loops or revert on valid inputs (due to a buggy upgrade), these calls would fail and cause permanent DOS of profit distribution for affected schemes, with no recovery mechanism available.

### Finding Description

The Profit contract references TokenContract and makes several critical calls without error handling: [1](#0-0) 

In `DistributeProfits`, the contract calls TokenContract.GetBalance multiple times: [2](#0-1) [3](#0-2) 

It then performs token transfers via virtual inline calls: [4](#0-3) [5](#0-4) 

The critical issue is the period management logic. The contract enforces strict sequential period processing: [6](#0-5) 

The CurrentPeriod only increments after successful completion: [7](#0-6) 

Similarly, `ClaimProfits` calls TokenContract.Transfer without error handling: [8](#0-7) 

**Root Cause**: The contract has no defensive programming mechanisms (try-catch, circuit breakers, or emergency recovery functions) to handle external dependency failures. If TokenContract calls fail, the entire transaction reverts, CurrentPeriod doesn't increment, and subsequent calls must still use the same period due to the Assert check. There is no mechanism to skip a failed period or manually advance CurrentPeriod.

Investigation of recovery mechanisms shows no period bypass capability - `ResetManager` only changes the manager, and `FixProfitDetail` only modifies beneficiary details, not scheme periods.

### Impact Explanation

**Operational Impact - Complete DOS of Profit Distribution:**

If TokenContract has issues (unbounded loops, reverts on valid inputs):
1. All `DistributeProfits` calls for the affected scheme fail and revert
2. CurrentPeriod remains stuck at the failed period
3. Future distribution attempts must still target the same period (enforced by Assert)
4. `ClaimProfits` also fails as it cannot transfer tokens to beneficiaries
5. The profit scheme becomes permanently non-functional with no recovery path

**Severity**: High
- **Affected parties**: All beneficiaries of the profit scheme lose access to their entitled distributions permanently
- **Scope**: The issue affects the core economic functionality of the platform
- **Permanence**: No recovery mechanism exists without contract upgrade
- **Cascading effects**: Schemes with sub-schemes create dependency chains where parent scheme DOS blocks all child schemes

While current TokenContract implementation does not have these issues, the vulnerability represents a critical design flaw in dependency management.

### Likelihood Explanation

**Precondition**: TokenContract must have unbounded loops or revert on valid inputs.

**Feasibility**:
- Contracts can be upgraded through governance via Genesis contract [9](#0-8) 
- Contract upgrades can introduce bugs unintentionally (not requiring malicious intent)
- TokenContract is a complex system contract with multiple operations where bugs could occur
- Historical precedent in blockchain systems shows contract upgrades do sometimes introduce bugs

**Complexity**: Moderate
- Does not require attacker action, but rather a system failure (buggy upgrade)
- Requires governance approval for faulty contract deployment
- Bug must specifically affect GetBalance or Transfer methods

**Detection**: The lack of defensive programming is evident in the code and violates secure smart contract design principles regardless of whether TokenContract currently has issues.

**Likelihood Assessment**: Medium - While not requiring malicious action, contract upgrade bugs are a realistic scenario in complex blockchain systems, and the complete absence of error handling creates unnecessary systemic risk.

### Recommendation

**Immediate Mitigation**:

1. Implement try-catch error handling for external TokenContract calls (if supported by AElf SDK)
2. Add emergency recovery mechanisms:
   - Allow authorized roles to manually advance CurrentPeriod under specific failure conditions
   - Implement a circuit breaker pattern to temporarily disable/skip problematic periods
   - Add a "force skip period" function callable by governance

3. Add defensive checks before TokenContract calls:
   ```
   // Verify TokenContract is operational before proceeding
   // Consider adding a health check mechanism
   ```

4. Implement alternative distribution paths:
   - Allow direct beneficiary withdrawals from virtual addresses if distribution fails
   - Provide fallback mechanisms that don't depend on successful period sequencing

5. Add events and state tracking for failed distribution attempts to aid in monitoring and recovery

**Test Cases**:
- Simulate TokenContract GetBalance failures during DistributeProfits
- Test recovery mechanisms after failed distributions
- Verify period advancement safeguards work correctly
- Test emergency pause/skip functionality

### Proof of Concept

**Initial State**:
- Profit scheme exists with SchemeId X, CurrentPeriod = 5
- Scheme has beneficiaries with shares
- Tokens exist in scheme's virtual address
- TokenContract has been upgraded with a bug causing GetBalance to revert

**Exploit Sequence**:

1. Manager calls `DistributeProfits(SchemeId: X, Period: 5)`
2. Contract validates period matches CurrentPeriod (line 479-480) âœ“
3. Contract calls `TokenContract.GetBalance()` (line 438-442)
4. TokenContract.GetBalance reverts due to bug
5. Entire transaction reverts, CurrentPeriod remains 5

6. Manager attempts recovery by calling `DistributeProfits(SchemeId: X, Period: 6)`
7. Contract checks: `Assert(input.Period == scheme.CurrentPeriod)` (line 479-480)
8. Fails: Period 6 != CurrentPeriod 5
9. Transaction reverts with "Invalid period" error

10. Any beneficiary calls `ClaimProfits(SchemeId: X)`
11. Contract attempts to transfer tokens via TokenContract (line 887-895)
12. Transfer fails due to TokenContract bug
13. Transaction reverts, no profits claimed

**Expected vs Actual**:
- Expected: Distribution continues or has recovery mechanism
- Actual: Scheme permanently stuck at period 5, no profits can be distributed or claimed

**Success Condition for Attack**: TokenContract has reversion bug, causing permanent DOS of all profit distribution operations for the scheme with no recovery path.

### Citations

**File:** contract/AElf.Contracts.Profit/ContractsReferences.cs (L8-8)
```csharp
    internal TokenContractContainer.TokenContractReferenceState TokenContract { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L438-442)
```csharp
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L453-457)
```csharp
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L478-480)
```csharp
        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L596-602)
```csharp
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L623-629)
```csharp
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = subItemVirtualAddress,
                        Amount = distributeAmount,
                        Symbol = symbol
                    }.ToByteString());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L887-895)
```csharp
                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L324-336)
```csharp
    public override Address UpdateSmartContract(ContractUpdateInput input)
    {
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        var inputHash = CalculateHashFromInput(input);

        if (!TryClearContractProposingData(inputHash, out _))
            Assert(Context.Sender == info.Author, "No permission.");

        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);

        return contractAddress;
```
