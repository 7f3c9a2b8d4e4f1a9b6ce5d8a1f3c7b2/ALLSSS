### Title
Unvalidated External Callbacks Enable Denial-of-Service on Token Operations

### Summary
Token creators can inject arbitrary external contract callbacks into `ExternalInfo` without validation. These callbacks are automatically invoked during all Transfer, Lock, and Unlock operations. A malicious callback that reverts or fails will cause the entire token operation to fail due to AElf's transaction failure propagation mechanism, enabling complete DoS of token functionality for all holders.

### Finding Description

The TokenContract allows token creators to specify external callback contracts in the `ExternalInfo` field during token creation. Three callback types are supported via keys in `TokenContractConstants`: `aelf_transfer_callback`, `aelf_lock_callback`, and `aelf_unlock_callback`. [1](#0-0) 

When tokens are transferred, locked, or unlocked, the contract invokes these callbacks via `Context.SendInline` with **no validation** of the callback contract address: [2](#0-1) [3](#0-2) [4](#0-3) 

The callbacks are invoked in critical operations after state modifications but within the same transaction: [5](#0-4) [6](#0-5) 

**Root Cause:** No whitelist, validation, or authorization check exists on callback contract addresses. Unlike other security-sensitive operations that validate system contracts or use whitelists, the callback mechanism trusts whatever address the token creator provides.

**Why Protections Fail:** AElf's transaction execution model propagates inline transaction failures to the parent transaction. The `IsSuccessful()` check explicitly fails if any inline trace fails: [7](#0-6) 

When a transaction fails, ALL state changes are rolled back: [8](#0-7) 

This means a reverting callback causes the entire Transfer/Lock/Unlock to fail and roll back, despite the main operation being valid.

### Impact Explanation

**Operational DoS Impact:**
- Any holder attempting to transfer, lock, or unlock the malicious token will have their transaction fail completely
- All balance modifications are rolled back, leaving users unable to move their tokens
- Tokens become effectively "frozen" and unusable for all holders
- If tokens are integrated into DEXs, lending protocols, or other DeFi systems, those integrations break
- Multi-token transactions fail if they include the malicious token

**Who is Affected:**
- All holders of the malicious token (not just the creator)
- DeFi protocols that accept the token
- Users who unknowingly receive the token as payment or rewards
- Cross-chain operations involving the token

**Severity Justification:** High. While not direct fund theft, this enables:
1. Complete denial of token functionality affecting all holders
2. Fund trapping in smart contracts that hold the token
3. Breaking of DeFi protocol integrations
4. Social engineering attacks (users buy "legitimate-looking" token that later gets DoS'd)

### Likelihood Explanation

**Attacker Capabilities:**
- Requires ability to create a token (obtainable via SEED NFT or whitelist)
- Requires deploying a malicious callback contract that reverts on invocation
- No special permissions or trusted role compromise needed

**Attack Complexity:** Very Low
1. Attacker creates malicious contract with method that always reverts/asserts false
2. Attacker creates token with `ExternalInfo` pointing to malicious contract
3. Attacker distributes token to victims (airdrops, sales, rewards, etc.)
4. Victims attempt to transfer â†’ automatic DoS

**Feasibility Conditions:**
- SEED NFT obtainable through normal market purchase
- Malicious contract deployment is trivial
- Token distribution happens organically through trading/airdrops
- No detection possible until users try to transfer

**Economic Rationality:**
- Low cost: Single SEED NFT + contract deployment gas
- High impact: Affects unlimited number of users
- Attack is persistent until token is abandoned
- Can be weaponized for competitor disruption or scams

**Probability:** High - Attack is practical, undetectable pre-deployment, and economically viable for malicious actors.

### Recommendation

**Immediate Mitigation:**
Implement callback contract address validation before invocation:

```csharp
private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
{
    var tokenInfo = GetTokenInfo(input.Symbol);
    if (tokenInfo.ExternalInfo == null) return;
    if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
    {
        var callbackInfo = JsonParser.Default.Parse<CallbackInfo>(
            tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
        
        // ADD VALIDATION: Check callback address is system contract or in whitelist
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Values;
        Assert(systemContractAddresses.Contains(callbackInfo.ContractAddress) || 
               State.CallbackWhitelist[callbackInfo.ContractAddress],
               "Callback contract not authorized.");
        
        Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
    }
    FireExternalLogEvent(tokenInfo, input);
}
```

**Additional Controls:**
1. Add governance-controlled callback contract whitelist
2. Require token owner/issuer to register callbacks separately from creation with validation
3. Add try-catch equivalent or optional callback execution that doesn't fail parent transaction
4. Emit warning events when callbacks are set
5. Add view method to check if token has callbacks set

**Test Cases:**
1. Verify callback address must be system contract or whitelisted
2. Verify unauthorized callback addresses are rejected
3. Verify existing legitimate callbacks (if any) continue working
4. Test that malicious callback cannot DoS token operations

### Proof of Concept

**Initial State:**
- Attacker has SEED NFT for token creation
- Attacker deploys `MaliciousCallback` contract with method that reverts

**Attack Steps:**

1. **Attacker creates malicious callback contract:**
```
MaliciousCallback.DoCallback() { Assert(false, "DoS"); }
```

2. **Attacker creates token with malicious callback:**
```
CreateInput {
    Symbol: "EVIL",
    TokenName: "Evil Token",
    TotalSupply: 1000000,
    Decimals: 8,
    Issuer: Attacker,
    ExternalInfo: {
        "aelf_transfer_callback": "{\"contract_address\":\"MaliciousCallbackAddress\",\"method_name\":\"DoCallback\"}"
    }
}
```

3. **Attacker distributes 100 EVIL tokens to Victim**

4. **Victim attempts to transfer 50 EVIL to another address:**
```
Transfer {
    Symbol: "EVIL",
    Amount: 50,
    To: RecipientAddress
}
```

**Expected Result:** Transfer succeeds, balance updated

**Actual Result:** 
- Transfer operation executes and modifies Victim's balance
- `DealWithExternalInfoDuringTransfer` invokes MaliciousCallback.DoCallback
- Callback asserts false and inline transaction fails
- Parent transaction trace marked unsuccessful per `IsSuccessful()` logic
- All state changes rolled back per `GetChanges()` logic
- Transaction reverts with error from callback
- Victim unable to transfer tokens

**Success Condition:** Victim's transaction fails despite having sufficient balance and valid transfer parameters, demonstrating complete DoS of token functionality.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-15)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
    public const string LockCallbackExternalInfoKey = "aelf_lock_callback";
    public const string UnlockCallbackExternalInfoKey = "aelf_unlock_callback";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L322-335)
```csharp
    private void DealWithExternalInfoDuringLocking(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.LockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.LockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L352-365)
```csharp
    private void DealWithExternalInfoDuringUnlock(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.UnlockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.UnlockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L195-222)
```csharp
    public override Empty Lock(LockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");

        var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
        if (allowance >= input.Amount)
            State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
        DealWithExternalInfoDuringLocking(new TransferFromInput
        {
            From = input.Address,
            To = virtualAddress,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```

**File:** src/AElf.Kernel.Core/Extensions/TransactionTraceExtensions.cs (L8-19)
```csharp
    public static bool IsSuccessful(this TransactionTrace txTrace)
    {
        if (txTrace.ExecutionStatus != ExecutionStatus.Executed) return false;

        if (txTrace.PreTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.InlineTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.PostTraces.Any(trace => !trace.IsSuccessful())) return false;

        return true;
    }
```

**File:** src/AElf.Runtime.CSharp/Executive.cs (L209-213)
```csharp
        if (!CurrentTransactionContext.Trace.IsSuccessful())
        {
            changes.Writes.Clear();
            changes.Deletes.Clear();
        }
```
