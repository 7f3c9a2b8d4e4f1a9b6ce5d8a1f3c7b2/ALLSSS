### Title
TokenHolder RemoveBeneficiary Permanent DOS via Single() Exception on Multiple ProfitDetails

### Summary
The `RemoveBeneficiary()` function in TokenHolderContract uses `.Details.Single()` which throws an exception when a beneficiary has multiple ProfitDetail entries. Since the Profit contract allows multiple details per beneficiary and normal withdrawal operations can leave residual details, beneficiaries can become permanently locked in the scheme with no way to remove them, causing operational DOS.

### Finding Description

The vulnerability exists in `RemoveBeneficiary()` where it attempts to retrieve profit details: [1](#0-0) 

The `.Details.Single()` call on line 78 will throw an `InvalidOperationException` if the Details collection contains more than one element.

**Root Cause**: The code assumes each beneficiary has exactly one ProfitDetail, but this invariant is not enforced.

**Why Multiple Details Can Exist**:

1. **Manager Direct Addition**: The Profit contract's `AddBeneficiary` method appends new ProfitDetails without checking for existing ones: [2](#0-1) 

The scheme manager (who can be any address creating a TokenHolder scheme) can directly call `ProfitContract.AddBeneficiary` multiple times for the same beneficiary since the authorization check only requires being the manager: [3](#0-2) 

2. **Withdraw with Unclaimed Profits**: When a user withdraws, `RemoveBeneficiary` is called on the Profit contract, but it doesn't always physically remove the detail: [4](#0-3) 

If the beneficiary has unclaimed profits (`LastProfitPeriod < CurrentPeriod`), the detail is kept with shortened `EndPeriod` rather than being removed (line 355). When the user calls `RegisterForProfits` again, a new detail is added, resulting in multiple details.

**Affected Functions**: The same issue exists in `AddBeneficiary`: [5](#0-4) 

Line 55 also uses `.Details.Single()`, causing the same failure.

### Impact Explanation

**Operational DOS**: Once a beneficiary has multiple ProfitDetails, they become permanently locked in the scheme:
- `RemoveBeneficiary()` cannot be called (throws exception)
- `AddBeneficiary()` cannot be called to update their shares (throws exception)  
- The manager loses control over the beneficiary list

**Affected Parties**:
- **Scheme Managers**: Cannot manage their profit schemes, cannot remove or update beneficiaries
- **Beneficiaries**: Cannot have their shares adjusted or be properly removed
- **Protocol**: TokenHolder dividend distribution becomes unreliable as stuck beneficiaries continue receiving rewards indefinitely

**Severity Justification**: HIGH - This is an operational DOS that permanently breaks core TokenHolder functionality. While it doesn't directly steal funds, it:
- Disrupts reward distribution accuracy
- Prevents proper scheme management
- Cannot be recovered without contract upgrade
- Affects legitimate users through normal operations (not requiring attack)

### Likelihood Explanation

**Likelihood**: HIGH

**Scenario A - Manager Error/Misuse**:
1. Manager creates TokenHolder scheme
2. User calls `RegisterForProfits` (1 detail created)
3. Manager accidentally/intentionally calls `ProfitContract.AddBeneficiary` directly for same user (2nd detail created)
4. Manager cannot call `TokenHolderContract.RemoveBeneficiary` → permanent DOS

**Scenario B - Normal Withdraw/Re-register Flow**:
1. User calls `RegisterForProfits` (detail A created)
2. Profits are distributed but user doesn't claim
3. Lock period expires, user calls `Withdraw`
   - RemoveBeneficiary called but detail A persists with shortened EndPeriod (unclaimed profits)
4. User calls `RegisterForProfits` again (detail B created)
5. User now has 2 details
6. Manager cannot call `TokenHolderContract.RemoveBeneficiary` → DOS

**Feasibility**: 
- Scenario A requires manager access (but manager is any scheme creator, not privileged admin)
- Scenario B happens through normal user operations with no special permissions
- Both scenarios are realistic and don't require sophisticated attacks

**Detection**: The issue is silent until `RemoveBeneficiary` or `AddBeneficiary` is called, at which point it's already unfixable without contract upgrade.

### Recommendation

**Fix 1 - Handle Multiple Details Gracefully**:

Replace `.Details.Single()` with logic that handles multiple details:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    var details = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
    {
        Beneficiary = input.Beneficiary,
        SchemeId = scheme.SchemeId
    }).Details;
    
    // Handle multiple details by summing shares
    var lockedAmount = details.Where(d => !d.IsWeightRemoved).Sum(d => d.Shares);
    
    State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = input.Beneficiary
    });
    
    if (lockedAmount > input.Amount && input.Amount != 0)
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = lockedAmount.Sub(input.Amount)
            }
        });
    
    return new Empty();
}
```

Apply similar fix to `AddBeneficiary` at line 55.

**Fix 2 - Add Invariant Check**:

Add assertion after critical operations to detect multiple details early:
```csharp
var profitDetails = State.ProfitContract.GetProfitDetails.Call(...);
Assert(profitDetails.Details.Count <= 1, "Beneficiary has multiple profit details - data corruption detected");
```

**Test Cases**:
1. Test RemoveBeneficiary with 2+ profit details
2. Test withdraw with unclaimed profits followed by re-register
3. Test manager directly calling Profit.AddBeneficiary multiple times
4. Verify all paths properly handle or prevent multiple details

### Proof of Concept

**Initial State**:
- TokenHolder scheme created with manager = Alice
- User Bob has registered via `RegisterForProfits`

**Exploit Sequence**:

**Step 1**: Bob registers for profits
```
Call: TokenHolderContract.RegisterForProfits
Input: { SchemeManager: Alice, Amount: 1000 }
Sender: Bob
Result: Bob has 1 ProfitDetail with Shares=1000
```

**Step 2**: Alice accidentally calls Profit.AddBeneficiary directly
```
Call: ProfitContract.AddBeneficiary
Input: { 
    SchemeId: <Alice's scheme>,
    BeneficiaryShare: { Beneficiary: Bob, Shares: 500 }
}
Sender: Alice
Result: Bob now has 2 ProfitDetails (Shares=1000 and Shares=500)
```

**Step 3**: Alice attempts to remove Bob
```
Call: TokenHolderContract.RemoveBeneficiary  
Input: { Beneficiary: Bob, Amount: 0 }
Sender: Alice
Expected: Bob removed from scheme
Actual: Transaction FAILS with exception "Sequence contains more than one element"
```

**Step 4**: Alice attempts to update Bob's shares
```
Call: TokenHolderContract.AddBeneficiary
Input: { Beneficiary: Bob, Shares: 2000 }
Sender: Alice  
Expected: Bob's shares updated
Actual: Transaction FAILS with same exception at line 55
```

**Success Condition**: 
- Bob is permanently locked in the scheme
- Alice has lost all management control over Bob's beneficiary status
- DOS confirmed - no recovery path without contract upgrade

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L46-56)
```csharp
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L74-78)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L342-356)
```csharp
            foreach (var profitDetail in detailsCanBeRemoved)
            {
                // set remove sign
                profitDetail.IsWeightRemoved = true;
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }
```
