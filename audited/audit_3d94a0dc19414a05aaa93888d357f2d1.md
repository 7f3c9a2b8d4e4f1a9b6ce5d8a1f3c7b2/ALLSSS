### Title
Candidate Admin Separation Invariant Can Be Bypassed Through AnnounceElectionFor

### Summary
The Election contract enforces an invariant that "Candidate cannot be others' admin" through a validation check in `AnnounceElection`. However, this check is absent from `AnnounceElectionFor` and `SetCandidateAdmin`, allowing candidates to bypass the restriction and become admins for other candidates. This violates the intended separation of roles and enables centralization of control over multiple candidate slots.

### Finding Description

The Election contract maintains two related state mappings:
- `CandidateAdmins`: maps candidate pubkey → admin address [1](#0-0) 
- `ManagedCandidatePubkeysMap`: maps admin address → list of managed candidate pubkeys [2](#0-1) 

The `AnnounceElection` method explicitly enforces that a candidate cannot be an admin for other candidates through a validation check that asserts `ManagedCandidatePubkeysMap[address] == null` with the error message "Candidate cannot be others' admin." [3](#0-2) 

However, this critical validation is **missing** from two other entry points:

1. **AnnounceElectionFor** (lines 121-142) directly calls the private `AnnounceElection` method and adds pubkeys to the admin's managed list without checking if the admin is already a candidate. [4](#0-3) 

2. **SetCandidateAdmin** (lines 19-57) allows changing a candidate's admin without validating whether the new admin is also a candidate managing others. [5](#0-4) 

**Root Cause**: The invariant check at line 102 only prevents someone who is ALREADY managing other candidates from becoming a candidate themselves. It does not prevent someone from first becoming a candidate (with self-management), then later using `AnnounceElectionFor` to register additional candidates under their control.

**Exploitation Path**:
1. Alice calls `AnnounceElection` with herself as admin → becomes a candidate managing herself (line 102 check passes since she's not managing anyone else YET)
2. After execution, `ManagedCandidatePubkeysMap[Alice]` contains Alice's pubkey
3. Alice calls `AnnounceElectionFor(BobPubkey, Alice)` → registers Bob as a candidate with Alice as admin
4. `ManagedCandidatePubkeysMap[Alice]` now contains BOTH Alice's and Bob's pubkeys
5. Result: Alice is a candidate AND manages another candidate, violating the stated invariant

### Impact Explanation

**Authorization Impact**:
- The candidate-admin manages profits receiver settings for multiple candidates through `Treasury.SetProfitsReceiver`, which checks that `Context.Sender == admin` [6](#0-5) 
- Can unilaterally quit election for managed candidates [7](#0-6) 
- Can replace candidate pubkeys at will [8](#0-7) 

**Governance Impact**:
- Centralizes control over multiple candidate slots under a single entity, violating decentralization principles
- A malicious actor can register multiple candidates to increase election chances while appearing as separate entities
- The candidate-admin can redirect profits from managed candidates by setting their profits receiver to their own address, effectively extracting rewards earned by infrastructure they don't operate

**Operational Impact**:
- Violates the explicit design invariant "Candidate cannot be others' admin"
- Creates conflicts of interest where one candidate entity controls competitors
- Undermines the integrity of the decentralized election process

**Who is Affected**: All network participants relying on fair and decentralized miner elections. Managed candidates lose autonomy over their own candidacy, profits, and operational decisions.

### Likelihood Explanation

**Reachable Entry Point**: Both `AnnounceElection` and `AnnounceElectionFor` are public RPC methods callable by any user [9](#0-8) 

**Attacker Capabilities**: Any user with sufficient tokens for candidate deposits can execute this attack. No special privileges required.

**Execution Practicality**: 
- Step 1: Call `AnnounceElection(own_address)` - requires paying candidate deposit
- Step 2: Call `AnnounceElectionFor(target_pubkey, own_address)` - requires paying another candidate deposit
- Both operations execute in normal transaction flow with no complex preconditions

**Economic Rationality**: 
- Cost: 2x candidate deposit (ElectionContractConstants.LockTokenForElection per candidate)
- Benefit: Control over multiple candidate slots, ability to redirect profits from managed candidates, increased election probability through multiple candidates
- The attack is economically rational when the attacker can extract value through profit manipulation or when they seek to centralize mining power

**Detection**: The vulnerability can be detected by querying `GetManagedPubkeys` for candidate addresses [10](#0-9)  and checking if any candidate manages multiple pubkeys including non-self pubkeys.

**Probability**: HIGH - The bypass is straightforward, requires no special timing or state conditions, and can be executed by any candidate at any time.

### Recommendation

**Code-Level Mitigation**:

1. Add the invariant check to `AnnounceElectionFor` before line 127:
```csharp
var admin = input.Admin ?? Context.Sender;
Assert(State.CandidateInformationMap[Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(admin))] == null ||
       !State.CandidateInformationMap[Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(admin))].IsCurrentCandidate,
       "Admin cannot be a candidate for others.");
Assert(State.ManagedCandidatePubkeysMap[admin] == null || 
       State.ManagedCandidatePubkeysMap[admin].Value.Count == 0,
       "Admin already managing other candidates.");
```

2. Add similar validation to `SetCandidateAdmin` at line 42, before setting the new admin:
```csharp
var newAdminAddress = input.Admin;
Assert(State.CandidateInformationMap[newAdminAddress] == null || 
       !State.CandidateInformationMap[newAdminAddress].IsCurrentCandidate ||
       State.ManagedCandidatePubkeysMap[newAdminAddress] == null ||
       State.ManagedCandidatePubkeysMap[newAdminAddress].Value.Count == 0,
       "New admin cannot be a candidate managing others.");
```

**Invariant Checks**:
- Enforce that if an address is in `Candidates` list, then `ManagedCandidatePubkeysMap[address]` either doesn't exist or contains only their own pubkey
- Add a view method to validate this invariant across all candidates for monitoring

**Test Cases**:
1. Test that `AnnounceElectionFor` fails when admin is already a candidate managing others
2. Test that `SetCandidateAdmin` fails when new admin is a candidate managing others  
3. Test that self-management (candidate being their own admin) remains allowed
4. Test edge case where candidate manages themselves then attempts to manage another candidate

### Proof of Concept

**Initial State**:
- Alice has sufficient tokens for 2 candidate deposits
- Bob provides a valid public key for candidate registration

**Transaction Sequence**:

1. **Alice announces herself as candidate with self-management**:
   - Call: `ElectionContract.AnnounceElection(Alice_address)`
   - Result: `CandidateAdmins[Alice_pubkey] = Alice_address`
   - Result: `ManagedCandidatePubkeysMap[Alice_address] = [Alice_pubkey]`
   - Expected: Success (self-management allowed)

2. **Alice registers Bob as candidate with herself as admin**:
   - Call: `ElectionContract.AnnounceElectionFor({pubkey: Bob_pubkey, admin: Alice_address})`
   - Result: `CandidateAdmins[Bob_pubkey] = Alice_address`
   - Result: `ManagedCandidatePubkeysMap[Alice_address] = [Alice_pubkey, Bob_pubkey]`
   - Expected: Should FAIL with "Candidate cannot be others' admin"
   - Actual: SUCCESS - bypasses validation

3. **Verify invariant violation**:
   - Call: `ElectionContract.GetCandidateInformation(Alice_pubkey)`
   - Result: `IsCurrentCandidate = true`
   - Call: `ElectionContract.GetManagedPubkeys(Alice_address)`
   - Result: Returns list containing both Alice_pubkey and Bob_pubkey
   - **Success Condition**: Alice is confirmed as both a candidate AND managing another candidate (Bob), violating the explicit invariant check from line 102

4. **Demonstrate impact - Alice sets Bob's profits to herself**:
   - Call: `TreasuryContract.SetProfitsReceiver({pubkey: Bob_pubkey, profitsReceiverAddress: Alice_address})`
   - Authorization check passes: `GetCandidateAdmin(Bob_pubkey) == Alice_address` ✓
   - Result: Bob's mining rewards now go to Alice
   - Impact: Alice extracts value from Bob's infrastructure/candidacy

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L68-68)
```csharp
    public MappedState<string, Address> CandidateAdmins { get; set; }
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L73-73)
```csharp
    public MappedState<Address, PubkeyList> ManagedCandidatePubkeysMap { get; set; }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-57)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;

        var pubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey));

        var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
        if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            newAdminManagedPubkeys.Value.Add(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;

        var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender] ?? new PubkeyList();
        if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[Context.Sender] = oldAdminManagedPubkeys;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L102-102)
```csharp
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-609)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L181-181)
```csharp
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** protobuf/election_contract.proto (L36-39)
```text
    rpc AnnounceElection (aelf.Address) returns (google.protobuf.Empty) {
    }
    rpc AnnounceElectionFor (AnnounceElectionForInput) returns (google.protobuf.Empty) {
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L427-430)
```csharp
    public override PubkeyList GetManagedPubkeys(Address input)
    {
        return State.ManagedCandidatePubkeysMap[input];
    }
```
