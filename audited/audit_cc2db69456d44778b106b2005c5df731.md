### Title
Incorrect Miner Count Used for Secret Sharing Validation Across Term Transitions

### Summary
The `RevealSharedInValues()` function uses the current round's miner count to validate decrypted pieces from the previous round, causing validation failures when the miner list size changes between terms. This breaks the secret sharing reconstruction mechanism, preventing legitimate InValue revelation when miner count increases, or potentially reconstructing secrets with insufficient shares when miner count decreases.

### Finding Description

The vulnerability exists in the `RevealSharedInValues()` function where miner count validation logic uses the wrong round's data: [1](#0-0) [2](#0-1) 

The function captures `minersCount` from `currentRound.RealTimeMinersInformation.Count` (line 21), then validates `previousRound` miners' `DecryptedPieces` against this count (line 36). Additionally, the `minimumCount` threshold for Shamir's Secret Sharing reconstruction is calculated based on currentRound's miner count (line 22).

The root cause is a semantic mismatch: the secret sharing scheme in `previousRound` was based on `previousRound`'s miner count (let's call it X), but validation uses `currentRound`'s miner count (Y). When terms transition, the miner list can change: [3](#0-2) [4](#0-3) 

The function is called during NextRound transitions: [5](#0-4) 

**Why existing protections fail:**

Line 30 only filters miners present in both rounds but doesn't account for the total miner count difference: [6](#0-5) 

The secret reconstruction uses the mismatched threshold: [7](#0-6) 

### Impact Explanation

**Scenario 1 - Miner Count Increases (Y > X):**
- previousRound had X miners, so DecryptedPieces.Count ≤ X
- Line 36 requires DecryptedPieces.Count ≥ Y
- If X < Y, validation always fails even with all available pieces
- PreviousInValue cannot be revealed via secret sharing
- This breaks the trustless verification mechanism of the consensus protocol

**Scenario 2 - Miner Count Decreases (Y < X):**
- If Y ≤ DecryptedPieces.Count < X, validation passes
- minimumCount = Y × 2/3 (line 22)
- Original secret threshold was X × 2/3
- If Y × 2/3 < X × 2/3, secret reconstruction uses insufficient shares
- Shamir's Secret Sharing with sub-threshold shares produces a deterministic but INCORRECT value
- This incorrect value is set as PreviousInValue (line 52)
- Subsequent UpdateValue validation fails for legitimate miners: [8](#0-7) 

**Who is affected:**
- All miners transitioning across term boundaries where miner count changes
- The consensus protocol's randomness and integrity guarantees
- Block production could be disrupted if miners cannot properly reveal their InValues

**Severity:** Medium - This is a consensus integrity issue that occurs during normal protocol operations (term transitions with miner count changes), affecting the trustless verification mechanism of the secret sharing scheme.

### Likelihood Explanation

**Reachable Entry Point:** The function is called from the public `NextRound` transaction during normal consensus operations: [9](#0-8) 

**Feasible Preconditions:**
- Miner count changes occur during term transitions via governance: [10](#0-9) 

- No attacker action required - this is a normal protocol operation
- The vulnerability triggers automatically when NextRound is called after a term transition with miner count change

**Execution Practicality:**
- Deterministic trigger during term transitions with miner count changes
- No special permissions needed beyond normal miner operations
- The issue affects the protocol's own functionality, not requiring adversarial behavior

**Probability:** While miner count changes are relatively infrequent (governance-controlled), they are a designed feature of the protocol. When they occur, the vulnerability is guaranteed to manifest for all affected miners.

### Recommendation

**Fix the validation logic to use previousRound's miner count:**

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    Context.LogDebug(() => "About to reveal shared in values.");

    if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

    if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

    // Use previousRound's miner count for validation
    var previousMinersCount = previousRound.RealTimeMinersInformation.Count;
    var minimumCount = previousMinersCount.Mul(2).Div(3);
    minimumCount = minimumCount == 0 ? 1 : minimumCount;

    foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
    {
        if (pair.Key == publicKey) continue;
        if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

        var publicKeyOfAnotherMiner = pair.Key;
        var anotherMinerInPreviousRound = pair.Value;

        if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
        // Use previousMinersCount instead of minersCount
        if (anotherMinerInPreviousRound.DecryptedPieces.Count < previousMinersCount) continue;

        // Rest of the reconstruction logic remains the same
        // ...
    }
}
```

**Additional validation:**
Add an explicit check to skip revelation when miner list just changed and sufficient data isn't available:

```csharp
// At the start of the function, after getting previousRound
if (currentRound.IsMinerListJustChanged && 
    previousRound.RealTimeMinersInformation.Count != currentRound.RealTimeMinersInformation.Count)
{
    Context.LogDebug(() => "Skipping secret revelation due to miner list change.");
    return;
}
```

**Test cases to add:**
1. Test NextRound transition immediately after term change with increased miner count
2. Test NextRound transition immediately after term change with decreased miner count
3. Verify PreviousInValue revelation works correctly across term boundaries
4. Ensure secret reconstruction uses correct threshold from the originating round

### Proof of Concept

**Initial State:**
- Term 1, Round N has 7 miners (A, B, C, D, E, F, G)
- Each miner creates secret shares with threshold = 7 × 2/3 = 4 shares needed
- All miners successfully exchange and decrypt pieces
- Miner A's DecryptedPieces.Count = 7 (has pieces from all miners)

**Attack Sequence:**

1. Governance calls `SetMaximumMinersCount(5)` reducing miners to 5
2. Term transition occurs - Term 2, Round 1 starts with 5 miners (A, B, C, D, E)
3. Miners F and G are removed, but miners A, B, C, D, E remain
4. During Term 2, Round 2 transition, miner A calls NextRound
5. `RevealSharedInValues` is executed with:
   - currentRound = Term 2 Round 1 (5 miners)
   - previousRound = Term 1 Round N (7 miners)

**Expected Result:**
Miner B's InValue from previousRound should be revealed using the 7 available decrypted pieces with threshold=4

**Actual Result:**
- Line 21: `minersCount = 5` (from currentRound)
- Line 22: `minimumCount = 5 × 2/3 = 3`
- Line 36: Checks if `DecryptedPieces.Count < 5`
- Miner B has 7 decrypted pieces, so check passes (7 ≥ 5)
- Line 50: Secret reconstructed with `minimumCount = 3` shares
- **But original secret required 4 shares minimum**
- If only 3 shares are used (due to some pieces being from removed miners F and G not being in currentRound), reconstruction produces INCORRECT InValue
- Incorrect PreviousInValue is set in currentRound

**Success Condition:**
When miner B later attempts UpdateValue with their correct PreviousInValue, validation fails because it doesn't match the incorrectly reconstructed value stored in the round data.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-21)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L30-30)
```csharp
            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L50-50)
```csharp
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L42-42)
```csharp
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L40-42)
```csharp
            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L48-48)
```csharp
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L1-1)
```csharp
using System;
```
