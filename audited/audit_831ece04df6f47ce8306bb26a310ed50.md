### Title
Missing Timestamp Validation in Vote Contract Allows Immediate Voting Through Past StartTimestamp Manipulation

### Summary
The `Register()` function in VoteContract.cs accepts any `StartTimestamp` value without validating it against `Context.CurrentBlockTime`, and the `Vote()` function does not enforce time-based voting restrictions. An attacker can register a voting item with `StartTimestamp` set to Unix epoch 0 (or any past time), bypassing intended time-delayed voting mechanisms and enabling immediate voting regardless of the intended voting schedule.

### Finding Description

The vulnerability exists in the `Register()` function where `StartTimestamp` is directly assigned from user input without validation: [1](#0-0) 

The only validation performed is in `AssertValidNewVotingItem()`, which merely checks that `EndTimestamp > StartTimestamp`: [2](#0-1) 

Critically, there is **no check** that `input.StartTimestamp >= Context.CurrentBlockTime`, allowing registration of voting items with timestamps in the distant past.

Furthermore, the `Vote()` function and its validation helper `AssertValidVoteInput()` perform no timestamp-based access control: [3](#0-2) 

The function validates voting item existence, option validity, and snapshot bounds, but never checks whether `Context.CurrentBlockTime` falls within the voting period `[StartTimestamp, EndTimestamp]`.

**Documentation-Code Mismatch**: The README explicitly states expected behavior: [4](#0-3) 

However, this protective logic is **completely absent** from the actual implementation.

### Impact Explanation

**Governance Impact**: This vulnerability enables attackers to bypass time-based voting controls in governance scenarios where voting should only commence at a specific future time. For example:
- A governance proposal intended to allow community preparation time (e.g., StartTimestamp = 7 days from now) can be immediately voted upon
- Election voting periods meant to start at synchronized times can be manipulated
- Time-locked voting mechanisms used for fairness and transparency are completely subverted

**Affected Parties**: 
- Governance systems relying on Vote contract for time-controlled voting
- Token holders expecting fair voting schedules  
- Any protocol using Vote contract for elections or referendums

**Severity Justification**: HIGH - This directly violates a critical governance invariant (proposal lifetime/expiration controls) and enables unauthorized early execution of voting processes, potentially leading to rushed decisions without proper deliberation periods.

### Likelihood Explanation

**Attacker Capabilities**: 
- Any user can call the public `Register()` function
- No special permissions required
- No economic cost beyond transaction fees

**Attack Complexity**: Trivial
1. Call `Register()` with `StartTimestamp = Timestamp(0)` (Unix epoch)
2. Set `EndTimestamp` to any future time
3. Immediately call `Vote()` to cast votes

**Feasibility**: 100% - The attack is deterministic and guaranteed to succeed:
- No preconditions required beyond token whitelist (standard setup)
- No race conditions or timing dependencies
- Works on first attempt every time

**Detection Constraints**: The malicious voting item appears as a valid registered item in contract state; off-chain monitoring would need to specifically check for anomalous StartTimestamp values.

**Economic Rationality**: Attack cost is minimal (gas fees only) while potential governance manipulation gains can be significant.

### Recommendation

**Code-Level Mitigation**:

1. Add timestamp validation in `AssertValidNewVotingItem()`:
```csharp
// After line 361, add:
if (input.StartTimestamp < Context.CurrentBlockTime)
{
    input.StartTimestamp = Context.CurrentBlockTime;
}
```

2. Add voting time window enforcement in `AssertValidVoteInput()`:
```csharp
// After line 383, add:
Assert(Context.CurrentBlockTime >= votingItem.StartTimestamp, 
    "Voting has not started yet.");
Assert(Context.CurrentBlockTime <= votingItem.EndTimestamp, 
    "Voting has already ended.");
```

**Invariant Checks**:
- Enforce: `StartTimestamp >= Context.CurrentBlockTime` at registration
- Enforce: `StartTimestamp <= Context.CurrentBlockTime <= EndTimestamp` at vote time

**Test Cases**:
- Test registering with `StartTimestamp = Timestamp(0)` - should auto-adjust
- Test voting before `StartTimestamp` - should fail
- Test voting after `EndTimestamp` - should fail  
- Test the documented behavior matches implementation

### Proof of Concept

**Initial State**:
- Vote contract deployed and initialized
- Token whitelist configured with test token
- Current block time: 2024-01-15 12:00:00 UTC

**Attack Sequence**:

1. Attacker calls `Register()` with:
   - `StartTimestamp = Timestamp(0)` (1970-01-01 00:00:00)
   - `EndTimestamp = Timestamp(future)` (2024-12-31 23:59:59)
   - `AcceptedCurrency = "ELF"`
   - Valid options

2. Registration succeeds, creating voting item with:
   - `StartTimestamp = 0` (stored without modification)
   - `CurrentSnapshotStartTimestamp = 0`

3. Attacker immediately calls `Vote()`:
   - `VotingItemId = <computed hash>`
   - `Option = "option1"`
   - `Amount = 1000`

**Expected Result** (if properly validated): Vote should fail with "Voting has not started yet" since intended StartTimestamp should be current or future time.

**Actual Result**: Vote succeeds immediately because:
- No check compares `Context.CurrentBlockTime` with `StartTimestamp`
- Voting is accepted despite `StartTimestamp` being ~54 years in the past

**Success Condition**: Transaction status = `Mined`, voting record created, voting results updated - all occurring at a time that should precede the intended voting start period.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L45-46)
```csharp
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L361-361)
```csharp
        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** contract/AElf.Contracts.Vote/README.md (L45-45)
```markdown
- If `StartTimestamp` of input value is smaller than current block time, will use current block time as `StartTimestamp`
```
