### Title
Missing Round Expiration Validation Allows Stale Rounds to be Accepted

### Summary
The `ValidateHeaderInformation()` function in `TimeSlotValidationProvider` fails to validate that a round has not expired when `ProvidedRound.RoundId` matches `BaseRound.RoundId`. The else branch only checks historical mining times without comparing against current blockchain time, allowing miners to produce blocks for rounds that should have timed out.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:**
When the provided round's `RoundId` equals the base round's `RoundId`, the validation logic enters the else branch which only calls `CheckMinerTimeSlot()`. [2](#0-1) 

The `CheckMinerTimeSlot()` function only validates internal consistency by checking if `latestActualMiningTime < endOfExpectedTimeSlot`, but crucially does NOT use `Context.CurrentBlockTime` to verify the round hasn't expired relative to current blockchain time.

**Missing Protection:**
The `Round.IsTimeSlotPassed()` method exists and properly checks time slot expiration against current block time: [3](#0-2) 

However, this method is used in consensus command generation but NOT in validation. The validation context does not include current block time: [4](#0-3) 

**Execution Path:** [5](#0-4) 

The validation retrieves `BaseRound` from state (current round number) and creates a validation context without including `Context.CurrentBlockTime`, preventing any time-based expiration checks in validation providers.

### Impact Explanation

**Consensus Integrity Compromise:**
- Miners can produce blocks for rounds that have expired in wall-clock time as long as `State.CurrentRoundNumber` hasn't been updated
- If all miners miss their time slots (network issues, coordination failure), the round remains in state indefinitely
- Any miner from that round can later produce blocks without time expiration validation
- This breaks the fundamental invariant that rounds must transition within their designated time periods

**Severity:** HIGH - Violates critical consensus invariant "Correct round transitions and time-slot validation". Allows acceptance of blocks from logically expired rounds, potentially enabling:
- Double mining opportunities
- Manipulation of round transition timing  
- Consensus confusion when stale and current blocks coexist
- Violation of the time-based scheduling that AEDPoS depends on

### Likelihood Explanation

**High Likelihood:**

**Attacker Capabilities:** Any valid miner in the current round - no special privileges required.

**Attack Complexity:** LOW
- Natural occurrence during network disruptions when no miner triggers NextRound
- Requires only waiting for the right timing conditions
- No complex transaction sequences needed

**Feasibility Conditions:**
1. Round N is active with `State.CurrentRoundNumber = N`
2. All miners' time slots pass without anyone triggering NextRound (e.g., network partition, coordinated delay)
3. Time continues significantly beyond intended round duration
4. A miner from Round N produces a block with `RoundId = N`
5. Validation sees `ProvidedRound.RoundId == BaseRound.RoundId` → enters else branch
6. `CheckMinerTimeSlot()` only validates historical timing relationships, not current time
7. Block is accepted despite round being logically expired

**Detection:** Difficult to detect as the validation passes legitimately from the contract's perspective - the missing check is the vulnerability itself.

**Economic Rationality:** Very low cost - requires only patience and timing, no economic stake at risk.

### Recommendation

**Code-Level Mitigation:**

1. Add current block time to `ConsensusValidationContext`: [4](#0-3) 

Modify to include:
```csharp
public Timestamp CurrentBlockTime { get; set; }
```

2. In validation initialization, set the current block time: [6](#0-5) 

Add: `CurrentBlockTime = Context.CurrentBlockTime`

3. Modify `TimeSlotValidationProvider.ValidateHeaderInformation()` else branch: [1](#0-0) 

Add validation:
```csharp
else
{
    // Check if round has expired based on current block time
    if (validationContext.BaseRound.IsTimeSlotPassed(
        validationContext.SenderPubkey, 
        validationContext.CurrentBlockTime))
    {
        validationResult.Message = $"Time slot expired for current round.{validationContext.SenderPubkey}";
        validationResult.IsReTrigger = true;
        return validationResult;
    }
    
    // Is sender respect his time slot?
    if (!CheckMinerTimeSlot(validationContext))
    {
        validationResult.Message = $"Time slot already passed before execution.{validationContext.SenderPubkey}";
        validationResult.IsReTrigger = true;
        return validationResult;
    }
}
```

**Invariant Check:** Ensure that `Context.CurrentBlockTime > (last miner's expected time + mining interval)` triggers NextRound requirement.

**Test Cases:**
- Test that blocks are rejected when produced after all time slots in the round have expired
- Test that round expiration is enforced even if `State.CurrentRoundNumber` hasn't updated
- Test network partition scenario where miners resume after extended delay

### Proof of Concept

**Initial State:**
- Round N active with 3 miners (A, B, C)
- Each has 4000ms time slot
- Round starts at timestamp T
- `State.CurrentRoundNumber = N`
- `State.Rounds[N] = Round N`

**Attack Steps:**

1. **T+0ms:** Round N begins, miner A expected at T+0, B at T+4000, C at T+8000
2. **T+0 to T+12000ms:** All miners encounter network issues, no blocks produced
3. **T+12000ms:** Round should have ended (all time slots expired + extra block time)
4. **T+20000ms:** Network recovers but no one has triggered NextRound yet
5. **T+20000ms:** Miner A produces block with behavior=UpdateValue, RoundId=N
6. **Validation Flow:**
   - `ValidateBeforeExecution` called with extraData.Round.RoundId = N
   - `TryToGetCurrentRoundInformation` returns BaseRound with RoundId = N (unchanged)
   - `TimeSlotValidationProvider.ValidateHeaderInformation` called
   - Line 14: `ProvidedRound.RoundId (N) != BaseRound.RoundId (N)` → FALSE
   - Line 20: Enters else branch
   - Line 24: `CheckMinerTimeSlot()` checks only that miner A's latestActualMiningTime is within expected slot
   - Since A hasn't mined yet, returns true (line 42)
   - Validation PASSES

**Expected Result:** Block should be REJECTED - round expired 8000ms ago

**Actual Result:** Block is ACCEPTED - no expiration check performed

**Success Condition:** Miner produces valid block 8+ seconds after round should have terminated, and validation accepts it without checking current time against round expiration.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L20-31)
```csharp
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-99)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L8-41)
```csharp
public class ConsensusValidationContext
{
    public long CurrentTermNumber { get; set; }
    public long CurrentRoundNumber { get; set; }

    /// <summary>
    ///     We can trust this because we already validated the pubkey
    ///     during `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`
    /// </summary>
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();

    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;

    /// <summary>
    ///     Previous round information fetch from StateDb.
    /// </summary>
    public Round PreviousRound { get; set; }

    /// <summary>
    ///     This filed is to prevent one miner produces too many continues blocks
    ///     (which may cause problems to other parts).
    /// </summary>
    public LatestPubkeyToTinyBlocksCount LatestPubkeyToTinyBlocksCount { get; set; }

    public AElfConsensusHeaderInformation ExtraData { get; set; }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-34)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```
