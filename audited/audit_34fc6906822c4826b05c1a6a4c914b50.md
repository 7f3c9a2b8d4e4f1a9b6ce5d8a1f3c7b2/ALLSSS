### Title
Repeated Welfare Profit Extension Without Additional Lock Commitment

### Summary
A voter can repeatedly call `ChangeVotingOption` with `IsResetVotingTime=true` before their vote expires to indefinitely extend their welfare profit collection period (`endPeriod`) without any additional lock time commitment. This occurs because `lockTime` is never modified during extension, but `endPeriod` is recalculated as `lockPeriod + treasury.CurrentPeriod`, where `treasury.CurrentPeriod` continuously increases. This allows voters to collect welfare profits far beyond their original lock commitment, diluting rewards for legitimate long-term voters.

### Finding Description

**Location**: [1](#0-0) 

**Root Cause**: 
When `ChangeVotingOption` is called with `IsResetVotingTime=true`, it invokes `ExtendVoterWelfareProfits` which reads `lockTime` from `State.LockTimeMap[voteId]` but never modifies it. [2](#0-1) 

The comment explicitly states "so the lockTime will *NOT* be changed." [3](#0-2) 

The `endPeriod` is calculated as `lockPeriod.Add(treasury.CurrentPeriod)`, where `lockPeriod = lockTime.Div(State.TimeEachTerm.Value)`. [4](#0-3) 

**Why Protections Fail**:
The only restriction is that the vote must not have expired: [5](#0-4) 

This check only validates `actualLockedSeconds < claimedLockingSeconds`, but does NOT prevent multiple calls to `ChangeVotingOption` before expiry. Since `State.LockTimeMap[voteId]` remains unchanged, a voter can call this function repeatedly, and each time `endPeriod` is recalculated with an increasing `treasury.CurrentPeriod`, pushing the profit collection period further into the future.

**Execution Path**:
1. `ChangeVotingOption` is called with `IsResetVotingTime=true` [6](#0-5) 
2. `ExtendVoterWelfareProfits` calculates new `endPeriod` without modifying `lockTime`
3. Profit contract's `FixProfitDetail` updates the beneficiary's profit detail with the new extended `endPeriod` [7](#0-6) 

### Impact Explanation

**Direct Harm**: 
A voter who commits to a 90-day lock (approximately 13 periods at 7 days/period) can extend their welfare profit collection to 20+ periods or more by repeatedly calling `ChangeVotingOption` before expiry. For example:
- Original vote at period 100: endPeriod = 13 + 100 = 113
- Call at period 110: endPeriod = 13 + 110 = 123 (10 extra periods)
- Call at period 111: endPeriod = 13 + 111 = 124 (11 extra periods)
- Vote expires at period 113, but voter collects profits until period 124

**Who is Affected**:
- Legitimate long-term voters who lock tokens for extended periods receive diluted welfare rewards
- The welfare profit scheme's integrity is compromised as voters gain unfair advantages
- Protocol economics are distorted as short-term voters extract long-term rewards

**Quantified Damage**:
A voter with minimum lock time can collect welfare profits for 2x-3x their actual commitment period, effectively stealing rewards from voters who genuinely commit to longer lock periods. With typical welfare profit distributions, this could represent thousands of tokens over the extended collection period.

**Severity Justification**: HIGH - Direct theft of welfare rewards through repeated exploitation of the extension mechanism without corresponding token commitment.

### Likelihood Explanation

**Attacker Capabilities**: 
Any voter with an active vote can exploit this. No special privileges required beyond normal voting participation.

**Attack Complexity**: 
Trivial - Simply call `ChangeVotingOption(voteId, sameCandidatePubkey, IsResetVotingTime=true)` repeatedly before the vote expires. The function is public and has no cooldown or rate limiting.

**Feasibility Conditions**:
- Voter must have an active vote (not yet expired)
- Can be called multiple times per period/block with no restrictions
- Works with any lock duration that satisfies minimum lock requirements [8](#0-7) 

**Economic Rationality**:
Transaction costs are negligible compared to the extended welfare profit gains. A voter who repeatedly extends can earn significantly more rewards than their lock commitment justifies.

**Detection/Operational Constraints**: 
Difficult to detect without monitoring repeated `ChangeVotingOption` calls with `IsResetVotingTime=true` on the same voteId. No on-chain safeguards prevent this behavior.

### Recommendation

**Immediate Fix**:
Modify `ChangeVotingOption` to track and enforce a "one-time extension" per vote, or reset `State.LockTimeMap[voteId]` when extending:

```csharp
if (input.IsResetVotingTime)
{
    // Track that this vote has been extended
    Assert(!State.VoteExtendedMap[input.VoteId], "Vote already extended once");
    State.VoteExtendedMap[input.VoteId] = true;
    
    // Reset the lock time to maintain the original commitment
    State.LockTimeMap[input.VoteId] = State.LockTimeMap[input.VoteId].Sub(actualLockedSeconds);
    
    ExtendVoterWelfareProfits(input.VoteId);
}
```

**Alternative Solution**:
Calculate `endPeriod` based on remaining lock time instead of total original lock time:
```csharp
var remainingLockTime = lockTime.Sub(actualLockedSeconds);
var remainingLockPeriod = remainingLockTime.Div(State.TimeEachTerm.Value);
var endPeriod = remainingLockPeriod.Add(treasury.CurrentPeriod);
```

**Invariant Checks**:
- Add state mapping to track whether a vote has been extended: `MappedState<Hash, bool> VoteExtendedMap`
- Assert that profit `endPeriod` never exceeds `originalEndPeriod + originalLockPeriod`
- Log extension events for monitoring

**Test Cases**:
1. Test that calling `ChangeVotingOption` with `IsResetVotingTime=true` twice on same voteId fails
2. Test that `endPeriod` after extension doesn't exceed reasonable bounds
3. Test that welfare profits collected match actual lock commitment duration

### Proof of Concept

**Initial State**:
- Treasury at period 100
- Voter creates vote with 90-day lock (13 periods, assuming 7 days/term)
- `State.LockTimeMap[voteId]` = 7,776,000 seconds (90 days)
- Initial profit detail: `endPeriod = 13 + 100 = 113`

**Attack Steps**:
1. **At period 110** (84 days elapsed, 6 days before expiry):
   - Call `ChangeVotingOption(voteId, candidatePubkey, IsResetVotingTime=true)`
   - Check: `actualLockedSeconds = 7,257,600 < 7,776,000` ✓ (passes assertion)
   - `lockTime` remains 7,776,000 seconds (unchanged)
   - `lockPeriod = 7,776,000 / 604,800 = 12.857 ≈ 12`
   - NEW `endPeriod = 12 + 110 = 122` (extended from 113 to 122!)

2. **At period 111** (85.7 days elapsed):
   - Call `ChangeVotingOption` again with `IsResetVotingTime=true`
   - Check: `actualLockedSeconds = 7,405,440 < 7,776,000` ✓ (still passes)
   - `lockTime` still 7,776,000 seconds
   - `lockPeriod` still 12
   - NEW `endPeriod = 12 + 111 = 123` (further extended!)

3. **At period 112.8** (89 days elapsed):
   - Call again - still passes assertion
   - `endPeriod = 12 + 112.8 = 124.8`

4. **Vote expires at period 113** (90 days complete)

5. **Periods 113-124**: Voter continues collecting welfare profits without token lock commitment for these 11 extra periods (77 days)

6. **At period 125**: Voter withdraws tokens

**Expected Result**: Voter should only collect profits until period 113 (original commitment)

**Actual Result**: Voter collects profits until period 124+ (11+ extra periods without additional commitment)

**Success Condition**: Profit detail's `endPeriod` extends beyond original commitment each time `ChangeVotingOption` is called, allowing profit collection far beyond the voter's actual lock duration.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L29-31)
```csharp
        var actualLockedSeconds = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockingSeconds = State.LockTimeMap[input.VoteId];
        Assert(actualLockedSeconds < claimedLockingSeconds, "This vote already expired.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L33-38)
```csharp
        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-160)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }

        var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L320-326)
```csharp
    private void AssertValidLockSeconds(long lockSeconds)
    {
        Assert(lockSeconds >= State.MinimumLockTime.Value,
            $"Invalid lock time. At least {State.MinimumLockTime.Value.Div(60).Div(60).Div(24)} days");
        Assert(lockSeconds <= State.MaximumLockTime.Value,
            $"Invalid lock time. At most {State.MaximumLockTime.Value.Div(60).Div(60).Div(24)} days");
    }
```
