# Audit Report

## Title
TokenConverter Exp Function Convergence Failure Due to Unbounded Connector Weight Ratios

## Summary
The TokenConverter's Bancor formula implementation uses a 20-term Taylor series approximation for the exponential function, which catastrophically overflows when connector pairs have extreme weight ratios combined with large trades relative to connector balances, causing complete DoS of affected trading pairs.

## Finding Description

The `BancorHelper.Exp` function implements exponential calculation using only 20 iterations of Taylor series [1](#0-0) , which provides accurate approximation only for small magnitude inputs (roughly |y| ≤ 10).

When governance calls `AddPairConnector`, the validation only checks that individual connector weights fall between 0 and 1 [2](#0-1) , but does NOT validate the ratio between paired connector weights [3](#0-2) . This allows extreme ratios like 0.99/0.01 = 99.

In sell operations, `GetReturnFromPaid` computes the Bancor formula by calculating `Exp(y * Ln(x))` where y is the weight ratio and x is a balance-dependent term [4](#0-3) . Similarly, buy operations use the same pattern [5](#0-4) .

When users attempt large trades on connectors with extreme weight ratios, the product y * Ln(x) can reach values like -684 or +456. The `Exp` function then attempts to compute terms like (-684)^20 / 20!, which vastly exceeds C# decimal range (±7.9 × 10^28) [6](#0-5) .

AElf contracts have overflow checking enabled, confirmed by security tests that show `OverflowException` causes transaction failure [7](#0-6) . The `Pow` function's binary exponentiation amplifies this issue as intermediate squaring operations overflow [8](#0-7) .

## Impact Explanation

**Operational DoS Impact:**
Connector pairs with extreme weight ratios become completely or partially unusable. Users attempting trades that trigger the overflow condition will have their transactions revert, preventing legitimate token exchange operations.

**Concrete Scenario:**
- Governance creates connector pair: ResourceToken (weight 0.99) ↔ NativeToken (weight 0.01)
- Connector balance depletes to 1,000 tokens (through normal trading)
- User with 999,000 tokens attempts sell operation
- Calculation: x = 1000/1000000 = 0.001, Ln(0.001) ≈ -6.908, y = 99
- Result: y * Ln(x) ≈ -684, causing Exp overflow
- Transaction reverts with `OverflowException`

**Affected Parties:**
- Users cannot complete trades on affected pairs
- Governance must disable and recreate connectors with corrected weights
- Protocol reputation damage from non-obvious failures

The severity is High due to complete loss of functionality for affected connector pairs, though limited to specific misconfigured pairs rather than system-wide impact.

## Likelihood Explanation

**Preconditions:**
1. Governance must call `AddPairConnector` with extreme weight ratios (e.g., 0.99/0.01)
2. Connectors must be enabled via `EnableConnector`
3. Users must attempt trades producing large |y * Ln(x)| values

**Realistic Assessment:**
- Current production uses safe ratios (0.05/0.05 per test configurations), but contract design allows dangerous values
- Governance error or intentional experimentation with different economic models could introduce extreme ratios
- Once misconfigured connectors exist, triggering is trivial - any user can call public `Buy`/`Sell` methods with appropriate trade sizes
- Detection is difficult as root cause (mathematical overflow in Taylor approximation) is non-obvious from transaction failures

**Attack Complexity:** Low once preconditions met - requires only standard contract interaction without special privileges.

The likelihood is Medium-Low overall due to governance preconditions, but increases to High once vulnerable connectors exist.

## Recommendation

**Immediate Fix:**
Add validation in `AddPairConnector` and `UpdateConnector` to restrict the ratio between paired connector weights:

```csharp
private void AssertValidWeightRatio(decimal weight1, decimal weight2)
{
    var ratio = weight1 / weight2;
    var inverseRatio = weight2 / weight1;
    // Limit ratio to reasonable range (e.g., 10:1 max)
    Assert(ratio <= 10m && inverseRatio <= 10m, 
        "Connector weight ratio must not exceed 10:1");
}
```

Call this validation after `AssertValidConnectorWeight` in `AddPairConnector`.

**Alternative/Additional Mitigations:**
1. Increase `_LOOPS` from 20 to 50+ terms for better Taylor approximation convergence
2. Add input validation to `Exp` function to reject |y| > threshold before computation
3. Implement alternative exponential calculation using logarithm properties to avoid large intermediate values
4. Document safe weight ratio ranges in deployment guides

## Proof of Concept

```csharp
[Fact]
public async Task Exp_Overflow_With_Extreme_Weight_Ratio_DoS()
{
    // Setup: Create connector pair with extreme weight ratio
    var resourceWeight = "0.99";  // 99% weight
    var nativeWeight = "0.01";    // 1% weight
    // Ratio: 0.99/0.01 = 99
    
    await DefaultStub.AddPairConnector.SendAsync(new PairConnectorParam
    {
        ResourceConnectorSymbol = "EXTREME",
        ResourceWeight = resourceWeight,
        NativeWeight = nativeWeight,
        NativeVirtualBalance = 100000
    });
    
    await EnableConnectorForExtremeToken();
    
    // Simulate depleted connector balance scenario
    // fromConnectorBalance = 1000 tokens
    // User attempts to sell 999,000 tokens (999x the balance)
    
    var sellResult = await DefaultStub.Sell.SendWithExceptionAsync(new SellInput
    {
        Symbol = "EXTREME",
        Amount = 999000_00000000, // Large amount
        ReceiveLimit = 0
    });
    
    // Assert: Transaction fails with overflow
    sellResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    sellResult.TransactionResult.Error.ShouldContain("OverflowException");
}
```

This test demonstrates that when extreme weight ratios exist, large trades cause transaction failure due to decimal overflow in the Exp calculation, completely preventing users from trading on affected connector pairs.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L51-53)
```csharp
        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L98-98)
```csharp
    private const int _LOOPS = 20; // Max = 20
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L104-120)
```csharp
    public static decimal Pow(decimal x, uint y)
    {
        if (y == 1)
            return x;

        var A = 1m;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;

        for (var i = t - 1; i >= 0; --i)
        {
            A *= A;
            if (e[i]) A *= x;
        }

        return A;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L92-106)
```csharp
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** test/AElf.Contracts.TestContract.Tests/ContractSecurityTests.cs (L36-36)
```csharp
        transactionResult.Error.Contains("System.OverflowException").ShouldBeTrue();
```
