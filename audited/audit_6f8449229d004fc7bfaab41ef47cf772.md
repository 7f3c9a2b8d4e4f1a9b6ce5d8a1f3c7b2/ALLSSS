### Title
Malicious Miner Can Halt Blockchain by Calling NextTerm with Empty Miner List

### Summary
A malicious authorized miner can call the public `NextTerm` RPC method with a crafted `NextTermInput` containing an empty `RealTimeMinersInformation` dictionary. This passes all validation checks and causes `ProcessNextTerm` to set the miner list to empty, permanently halting block production because no miner can be determined for subsequent blocks.

### Finding Description

**Entry Point**: The `NextTerm` method is a public RPC method that accepts `NextTermInput` directly from transaction senders. [1](#0-0) [2](#0-1) 

**Authorization Check**: The `PreCheck()` method only validates that the transaction sender is in the current or previous miner list, but does NOT validate the content of the input parameter. [3](#0-2) 

**Validation Gap**: The `RoundTerminateValidationProvider` used for `NextTerm` behavior only validates that round and term numbers increment correctly, and that InValues are null. It does NOT check if `RealTimeMinersInformation` is non-empty. When the dictionary is empty, the `Any()` check returns false, allowing validation to pass. [4](#0-3) [5](#0-4) 

**Execution Path**: In `ProcessNextTerm`, the input is converted to a Round, and then a `MinerList` is created from `RealTimeMinersInformation.Keys` without any validation. If empty, an empty `MinerList` is passed to `SetMinerList`. [6](#0-5) 

**State Corruption**: The `SetMinerList` method sets `State.MainChainCurrentMinerList.Value` and `State.MinerListMap[termNumber]` to the empty miner list WITHOUT any validation that the list contains at least one miner. [7](#0-6) 

**Chain Halt Trigger**: After the empty miner list is set, the next block production attempt calls `GetNextMinerPubkey()`, which attempts to call `.First(m => m.IsExtraBlockProducer)` on an empty collection, causing an exception. [8](#0-7) 

**Root Cause**: The `NextTermInput.Create()` method and `ToRound()` conversion accept arbitrary `RealTimeMinersInformation` dictionaries without validation, and no downstream validation exists to ensure the miner list is non-empty. [9](#0-8) 

### Impact Explanation

**Operational Catastrophe**: Once an empty miner list is set through `ProcessNextTerm`, the blockchain permanently halts because:
1. `GetNextMinerPubkey()` throws an exception when trying to determine the next block producer
2. No miner can produce blocks without a valid miner assignment
3. The consensus mechanism is completely broken
4. All network operations cease - transactions cannot be processed, cross-chain operations fail, and governance becomes impossible

**Affected Parties**: 
- All network participants lose access to the blockchain
- Token holders cannot transfer or use assets
- DApps built on the chain become inoperable
- Cross-chain bridges connected to this chain halt
- Economic activities and governance completely stop

**Severity Justification**: This is CRITICAL because it achieves complete and permanent Denial of Service of the entire blockchain with a single malicious transaction from any authorized miner. Recovery would require extraordinary measures such as hard fork or manual state intervention, assuming the chain can even be restarted.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must be an authorized miner (present in current or previous round's miner list). This is a realistic constraint as miners are elected and multiple miners exist in the network.

**Attack Complexity**: VERY LOW
1. Craft a `NextTermInput` with:
   - `round_number` = current round + 1
   - `term_number` = current term + 1  
   - `real_time_miners_information` = {} (empty dictionary)
   - Valid `random_number` (can be generated via VRF)
2. Submit transaction calling `NextTerm(input)`
3. Transaction executes successfully and corrupts state

**Feasibility Conditions**: 
- Attacker is a current miner (routine condition)
- No special timing or race conditions required
- No economic cost beyond normal transaction fee
- Attack is undetectable until after execution (appears as normal term transition)

**Detection/Operational Constraints**: The attack is virtually undetectable before execution because the validation logic doesn't check for empty miner lists. Monitoring systems would only detect the issue after the chain has already halted.

**Probability Assessment**: HIGH - Any disgruntled or compromised miner can execute this attack at any time with minimal effort and cost.

### Recommendation

**Immediate Fix**: Add validation in multiple locations to ensure miner list is non-empty:

1. **In Validation Provider**: Modify `RoundTerminateValidationProvider.ValidationForNextTerm()` to check:
```
if (extraData.Round.RealTimeMinersInformation.Count == 0)
    return new ValidationResult { Message = "Miner list cannot be empty for next term." };
``` [4](#0-3) 

2. **In ProcessNextTerm**: Add assertion before calling `SetMinerList`:
```
Assert(nextRound.RealTimeMinersInformation.Count > 0, "Cannot create term with zero miners.");
``` [10](#0-9) 

3. **In SetMinerList**: Add validation before updating state:
```
Assert(minerList.Pubkeys.Count > 0, "Miner list must contain at least one miner.");
``` [11](#0-10) 

**Test Cases**: Add regression tests that attempt to:
- Call `NextTerm` with empty `RealTimeMinersInformation`
- Verify transaction is rejected with appropriate error message
- Confirm miner list state remains unchanged after failed attempt

### Proof of Concept

**Initial State**:
- Blockchain running with N miners in current term T
- Attacker is one of the authorized miners

**Attack Steps**:
1. Attacker constructs malicious `NextTermInput`:
   - Set `round_number` = current round number + 1
   - Set `term_number` = current term number + 1
   - Set `real_time_miners_information` = empty map {}
   - Generate valid `random_number` using VRF
   - Set other fields (blockchain_age, confirmed_irreversible_block_height, etc.) to match current values

2. Attacker submits transaction: `NextTerm(maliciousInput)`

3. Transaction execution:
   - `PreCheck()` passes ✓ (attacker is authorized miner)
   - `ValidateBeforeExecution()` passes ✓ (round/term numbers correct, empty dict passes `Any()` check)
   - `ProcessNextTerm()` executes ✓
   - `SetMinerList()` sets empty list to state ✓
   - Transaction succeeds

**Expected vs Actual Result**:
- **Expected**: Transaction rejected due to empty miner list validation
- **Actual**: Transaction succeeds, state corrupted with empty miner list

**Success Condition**: 
- After transaction execution, call `GetCurrentMinerList()` → returns empty list
- Attempt to produce next block → `GetNextMinerPubkey()` throws exception
- Blockchain halted ✓

### Citations

**File:** protobuf/aedpos_contract.proto (L37-39)
```text
    // Update consensus information, create a new term.
    rpc NextTerm (NextTermInput) returns (google.protobuf.Empty) {
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-190)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L91-102)
```csharp
    public override StringValue GetNextMinerPubkey(Empty input)
    {
        if (TryToGetCurrentRoundInformation(out var round))
            return new StringValue
            {
                Value = round.RealTimeMinersInformation.Values
                            .FirstOrDefault(m => m.ExpectedMiningTime > Context.CurrentBlockTime)?.Pubkey ??
                        round.RealTimeMinersInformation.Values.First(m => m.IsExtraBlockProducer).Pubkey
            };

        return new StringValue();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```
