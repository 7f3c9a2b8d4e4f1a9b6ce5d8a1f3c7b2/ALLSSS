### Title
Insufficient Validation of Next Round ExpectedMiningTime Allows Consensus Disruption via GetMiningInterval Manipulation

### Summary
A malicious miner can manipulate `ExpectedMiningTime` values in next round data before block production, causing `GetMiningInterval()` to return incorrect values. This bypasses all validation checks and affects `IsTimeSlotPassed()` calculations for all miners in subsequent rounds, leading to incorrect consensus behaviors including premature round termination, failed round transitions, or consensus stalls.

### Finding Description

**Root Cause:**

The vulnerability exists in the consensus validation flow where next round information is not verified against deterministic regeneration. The `_isTimeSlotPassed` field is calculated in the base constructor: [1](#0-0) 

This calculation depends on `GetMiningInterval()` which computes the interval from the difference between Order 1 and Order 2 miners' `ExpectedMiningTime`: [2](#0-1) [3](#0-2) 

**Attack Path:**

1. When a miner produces a NextRound block, consensus extra data is generated containing next round information with `ExpectedMiningTime` calculated as: [4](#0-3) 

2. A malicious miner modifies their node software to intercept and alter the `ExpectedMiningTime` values (particularly for Order 1 or Order 2 miners) before including the consensus data in the block header.

3. The block validation runs through multiple providers but **none verify that ExpectedMiningTime values match the deterministic generation**: [5](#0-4) 

4. `RoundTerminateValidationProvider` only checks round number and InValues: [6](#0-5) 

5. `NextRoundMiningOrderValidationProvider` only validates FinalOrderOfNextRound values: [7](#0-6) 

6. The manipulated round data is stored directly without additional validation: [8](#0-7) [9](#0-8) 

7. Authorization check only validates the sender is a miner, not data correctness: [10](#0-9) 

### Impact Explanation

**Consensus Integrity Compromise:**

When `GetMiningInterval()` returns incorrect values, `IsTimeSlotPassed()` produces wrong results for all miners in the affected round. This directly impacts consensus behavior decisions: [11](#0-10) [12](#0-11) 

**Attack Scenarios:**

1. **Interval set extremely large (e.g., 999999 seconds)**: `IsTimeSlotPassed` always returns false, causing miners to produce TinyBlocks instead of terminating rounds, preventing round transitions and stalling consensus.

2. **Interval set extremely small (e.g., 1 millisecond)**: `IsTimeSlotPassed` returns true immediately, causing miners to attempt premature round termination or return Nothing behavior instead of UpdateValue, disrupting the consensus flow.

**Affected Parties:**
- All network participants experience consensus disruption
- Block production schedules become incorrect
- Chain progression may stall or fork
- Side chain consensus is particularly vulnerable as shown in the constructor call: [13](#0-12) 

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active miner (passes PreCheck authorization)
- Must modify node software to intercept and alter consensus extra data
- No additional permissions or trusted role compromise needed

**Attack Complexity:**
- Low to Medium: Requires node software modification but no cryptographic breaks
- Single malicious miner can affect entire network once tampered data is stored in state
- Attack persists across all nodes as State.Rounds is replicated

**Feasibility:**
- Highly feasible: Any miner can execute by modifying their node
- Detection difficult without explicit ExpectedMiningTime validation
- No cryptographic commitments prevent data tampering post-generation
- Consensus extra data is generated by node and can be intercepted before block creation: [14](#0-13) 

**Economic Rationality:**
- No direct cost to attacker beyond node modification
- Could be used for griefing or disrupting competitor chains
- May benefit from consensus disruption for various strategic reasons

### Recommendation

**Immediate Fix:**

Add validation in `RoundTerminateValidationProvider` to regenerate the next round and verify `ExpectedMiningTime` values match:

1. In `ValidationForNextRound`, call the contract's `GenerateNextRoundInformation` method to compute expected round data: [15](#0-14) 

2. Compare each miner's `ExpectedMiningTime` in the provided round against the regenerated round
3. Reject the block if any `ExpectedMiningTime` value deviates from expected

**Implementation:**
```csharp
// In RoundTerminateValidationProvider.ValidationForNextRound
// After existing checks, add:
GenerateNextRoundInformation(validationContext.BaseRound, 
    validationContext.CurrentBlockTime, out var expectedNextRound);

foreach (var minerKey in extraData.Round.RealTimeMinersInformation.Keys)
{
    if (!expectedNextRound.RealTimeMinersInformation.ContainsKey(minerKey))
        continue;
        
    var providedTime = extraData.Round.RealTimeMinersInformation[minerKey].ExpectedMiningTime;
    var expectedTime = expectedNextRound.RealTimeMinersInformation[minerKey].ExpectedMiningTime;
    
    if (providedTime != expectedTime)
        return new ValidationResult { Message = "Invalid ExpectedMiningTime in next round." };
}
```

**Additional Hardening:**
- Add integration tests that attempt to provide manipulated ExpectedMiningTime values
- Consider cryptographic commitment to generated round data before block production
- Add monitoring for abnormal miningInterval values in production

### Proof of Concept

**Initial State:**
- Blockchain with 3 active miners
- Current round number = 10
- Normal miningInterval = 4000ms

**Attack Steps:**

1. **Malicious miner modifies node software** to intercept consensus extra data generation
2. **Miner's turn to produce NextRound block** arrives
3. **Node generates proper next round** via GetConsensusBlockExtraData with correct ExpectedMiningTime values
4. **Attacker intercepts and modifies** Order 1 miner's ExpectedMiningTime from `T` to `T + 999999000` (adding ~11.5 days)
5. **Block is produced and broadcast** with manipulated consensus data
6. **Validation passes** because no validator checks ExpectedMiningTime correctness
7. **Block is accepted** and manipulated round stored in State.Rounds[11]
8. **Next round (11) begins**, all miners call GetConsensusCommand
9. **GetMiningInterval() calculates** interval as 999999000ms based on manipulated data
10. **IsTimeSlotPassed() always returns false** because currentTime < (ExpectedMiningTime + 999999 seconds)
11. **All miners produce TinyBlocks** instead of terminating round
12. **Round 11 never terminates**, consensus stalls

**Expected vs Actual:**
- Expected: Round 11 completes normally with proper time slots
- Actual: Round 11 stalls indefinitely, consensus halted

**Success Condition:**
- Round transitions fail to occur beyond round 11
- All miners stuck producing TinyBlocks
- Network consensus completely disrupted

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L35-35)
```csharp
            _isTimeSlotPassed = CurrentRound.IsTimeSlotPassed(_pubkey, _currentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L57-83)
```csharp
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L92-115)
```csharp
        private AElfConsensusBehaviour HandleMinerInNewRound()
        {
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;

            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;

            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-98)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L20-36)
```csharp
        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L44-46)
```csharp
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusExtraDataProvider.cs (L29-40)
```csharp
    public async Task<ByteString> GetBlockHeaderExtraDataAsync(BlockHeader blockHeader)
    {
        if (blockHeader.Height == AElfConstants.GenesisBlockHeight) return null;

        var consensusInformation = await _consensusService.GetConsensusExtraDataAsync(new ChainContext
        {
            BlockHash = blockHeader.PreviousBlockHash,
            BlockHeight = blockHeader.Height - 1
        });

        return consensusInformation == null ? ByteString.Empty : ByteString.CopyFrom(consensusInformation);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L285-347)
```csharp
    private void GenerateNextRoundInformation(Round currentRound, Timestamp currentBlockTime, out Round nextRound)
    {
        TryToGetPreviousRoundInformation(out var previousRound);
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();
        var isMinerListChanged = false;
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }

        currentRound.GenerateNextRoundInformation(currentBlockTime, blockchainStartTimestamp, out nextRound,
            isMinerListChanged);
    }
```
