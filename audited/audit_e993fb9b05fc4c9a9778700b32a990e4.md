### Title
NFT Contract SetMethodFee() Fails to Persist Fee Configuration, Silently Ignoring All Governance Fee Changes

### Summary
The NFT contract's `SetMethodFee()` implementation is a non-functional stub that returns empty without persisting the input fees to state, unlike the standard `State.TransactionFees[input.MethodName]` pattern used by all other AElf contracts. This causes all governance attempts to adjust NFT method fees to silently fail, permanently fixing the Create method at 100 ELF while keeping all other methods free, with no mechanism to ever change these values.

### Finding Description

The NFT contract implements the ACS1 (Transaction Fee Standard) interface but provides only stub implementations that do not persist state: [1](#0-0) 

The `SetMethodFee()` method simply returns `Empty()` without any state persistence logic. In contrast, the standard implementation pattern used by all other contracts persists fees to state: [2](#0-1) [3](#0-2) 

The root cause is that the NFT contract state does not define the required state variables at all: [4](#0-3) 

All properly implemented contracts define these state variables: [5](#0-4) [6](#0-5) 

Consequently, `GetMethodFee()` returns only hardcoded values instead of reading from persisted state: [7](#0-6) 

The standard implementation retrieves persisted fees from state: [8](#0-7) [9](#0-8) 

### Impact Explanation

**Governance Failure**: When Parliament governance creates proposals to adjust NFT contract method fees (a standard governance function for all AElf contracts), the transactions appear to succeed but have zero effect. This silently breaks the governance feedback loop and undermines trust in the governance process.

**Economic Inflexibility**: The Create method is permanently locked at 100 ELF (100_00000000 basic units), and all other NFT methods remain permanently free. If economic conditions require fee adjustments (e.g., if 100 ELF becomes too expensive and prevents adoption, or too cheap and enables spam), governance has no mechanism to respond.

**Authorization Bypass**: The stub implementation lacks the standard authorization check `Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, ...)`, allowing anyone to call `SetMethodFee()` without permission. While this has no direct effect due to the lack of persistence, it misrepresents the contract's access control model.

**Protocol Inconsistency**: The NFT contract violates the ACS1 standard that all other system contracts follow, creating an exception that complicates protocol understanding and maintenance.

### Likelihood Explanation

**Certain Occurrence**: This vulnerability will manifest with 100% certainty whenever governance attempts to adjust NFT contract fees through a Parliament proposal, which is the standard mechanism for fee governance across all AElf contracts.

**No Mitigation Possible**: Since the state variables are not defined and the method is non-functional, no workaround exists. The contract would require an upgrade to fix this issue.

**Discoverable**: Governance participants would discover this issue the first time they attempt to adjust NFT fees and observe that the fees remain unchanged despite a successful proposal execution.

**Low Complexity**: No special attacker capabilities or complex setup is required. The vulnerability is structural and permanent in the current contract implementation.

### Recommendation

**1. Add Required State Variables** to `NFTContractState.cs`:
```csharp
public MappedState<string, MethodFees> TransactionFees { get; set; }
public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

**2. Implement Proper SetMethodFee()** following the standard pattern:
```csharp
public override Empty SetMethodFee(MethodFees input)
{
    foreach (var methodFee in input.Fees)
        AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
    
    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, 
           "Unauthorized to set method fee.");
    
    State.TransactionFees[input.MethodName] = input;
    return new Empty();
}
```

**3. Implement Proper GetMethodFee()** reading from state with fallback to defaults:
```csharp
public override MethodFees GetMethodFee(StringValue input)
{
    var fees = State.TransactionFees[input.Value];
    if (fees != null && fees.Fees.Count > 0)
        return fees;
    
    // Return hardcoded defaults only if not configured
    if (input.Value == nameof(Create))
        return new MethodFees { /* existing hardcoded values */ };
    
    return new MethodFees();
}
```

**4. Implement ChangeMethodFeeController()** and **GetMethodFeeController()** following the standard pattern with Parliament authorization.

**5. Add Initialization Logic** to set default MethodFeeController to Parliament's default organization address.

**6. Add Test Cases** verifying fee persistence, authorization checks, and governance proposal execution for fee changes.

### Proof of Concept

**Initial State**: NFT contract deployed with hardcoded Create fee of 100 ELF.

**Step 1**: Governance creates Parliament proposal to change Create method fee to 50 ELF:
```
ProposalInput = {
    ContractMethodName = "SetMethodFee",
    ToAddress = NFTContractAddress,
    Params = MethodFees {
        MethodName = "Create",
        Fees = [{ Symbol = "ELF", BasicFee = 50_00000000 }]
    }
}
```

**Step 2**: Proposal approved by Parliament miners (2/3+ threshold).

**Step 3**: Proposal released and executed - transaction succeeds, returns Empty().

**Step 4**: Query GetMethodFee("Create"):

**Expected Result**: Should return 50 ELF (the newly set fee).

**Actual Result**: Returns 100 ELF (the original hardcoded value) because SetMethodFee() never persisted the change.

**Success Condition**: The fee remains at 100 ELF indefinitely despite successful governance execution, proving the vulnerability exists.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-11)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L34-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        return State.TransactionFees[input.Value];
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L37-52)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (new List<string>
            {
                nameof(ClaimTransactionFees), nameof(DonateResourceToken), nameof(ChargeTransactionFees),
                nameof(CheckThreshold), nameof(CheckResourceToken), nameof(ChargeResourceToken),
                nameof(CrossChainReceiveToken)
            }.Contains(input.Value))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        var fees = State.TransactionFees[input.Value];
        return fees;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L6-46)
```csharp
public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.Association/AssociationState.cs (L7-13)
```csharp
public partial class AssociationState : ContractState
{
    public MappedState<Address, Organization> Organizations { get; set; }
    public MappedState<Hash, ProposalInfo> Proposals { get; set; }
    public MappedState<string, MethodFees> TransactionFees { get; set; }
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
}
```

**File:** contract/AElf.Contracts.Parliament/ParliamentState.cs (L11-27)
```csharp
public class ParliamentState : ContractState
{
    public MappedState<Address, Organization> Organizations { get; set; }

    public BoolState Initialized { get; set; }

    public SingletonState<Address> DefaultOrganizationAddress { get; set; }

    internal AEDPoSContractContainer.AEDPoSContractReferenceState ConsensusContract { get; set; }
    internal TokenContractContainer.TokenContractReferenceState TokenContract { get; set; }
    internal ElectionContractContainer.ElectionContractReferenceState ElectionContract { get; set; }
    public MappedState<Hash, ProposalInfo> Proposals { get; set; }
    public MappedState<string, MethodFees> TransactionFees { get; set; }

    public SingletonState<ProposerWhiteList> ProposerWhiteList { get; set; }
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }

```
