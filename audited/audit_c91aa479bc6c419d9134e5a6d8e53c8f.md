### Title
Missing Authorization Check on InitialCoefficients Allows Malicious Fee Configuration

### Summary
The `InitialCoefficients` method in the MultiToken contract lacks any sender authorization check, allowing any caller to initialize the fee calculation coefficients if they haven't been set yet. While the method is intended to be called atomically during genesis deployment, if the contract is deployed without proper initialization or if initialization fails, an attacker can front-run legitimate initialization and set malicious fee coefficients that would affect all transaction fees system-wide.

### Finding Description

The `State.AllCalculateFeeCoefficients` state variable controls the fee calculation formulas for all transaction types (READ, STORAGE, WRITE, TRAFFIC, TX) in the MultiToken contract. [1](#0-0) 

This state can be modified by three methods:

1. **InitialCoefficients** - Has NO authorization check, only validates coefficients aren't already set: [2](#0-1) 

2. **UpdateCoefficientsForContract** - Properly protected with `AssertDeveloperFeeController()`: [3](#0-2) 

3. **UpdateCoefficientsForSender** - Properly protected with `AssertUserFeeController()`: [4](#0-3) 

The authorization assertion methods verify that only governance-controlled addresses can update coefficients: [5](#0-4) 

In normal operation, `InitialCoefficients` is called during genesis deployment:
- Main chain: via Economic contract's InitialEconomicSystem [6](#0-5) 

- Side chain: via TokenContractInitializationProvider [7](#0-6) 

These initialization calls are executed atomically during system contract deployment: [8](#0-7) 

**Root Cause**: The `InitialCoefficients` method is publicly accessible in the contract interface: [9](#0-8) 

However, it lacks the sender authorization check that would restrict it to system initialization context. The method only checks if coefficients are already initialized (line 110), creating a race condition vulnerability if the contract is ever deployed without atomic initialization.

### Impact Explanation

**Direct Fund Impact**: An attacker who successfully calls `InitialCoefficients` before legitimate initialization gains complete control over the fee calculation formulas for all transaction types. They could:
- Set coefficients to extremely high values (e.g., x^10 instead of x^2) causing exponential fee growth
- Make transaction fees prohibitively expensive, effectively extracting value from all users
- Target specific fee types (e.g., STORAGE) to drain funds from contract developers
- The fee coefficients affect ALL transactions on the chain, impacting every user

**Auth/Governance Impact**: This bypasses the entire governance framework. Legitimate fee updates require:
- DeveloperFeeController approval (Parliament + Association multi-sig) for contract fees
- UserFeeController approval (Parliament + Referendum + Association) for user fees

An attacker setting initial coefficients circumvents this completely.

**Operational Impact**: Malicious fee configuration could:
- DoS the entire chain by making transactions unaffordable
- Prevent contract deployments and updates
- Block cross-chain operations due to excessive fees
- Halt the token economy until governance can deploy fixes

**Severity Justification**: HIGH impact despite LOW likelihood because the vulnerability grants system-level control over a critical economic parameter affecting all chain participants.

### Likelihood Explanation

**Attacker Capabilities**: Any address with the ability to send transactions to the deployed token contract can call `InitialCoefficients`.

**Attack Complexity**: LOW - Single method call with Empty parameter. No complex multi-step setup required.

**Feasibility Conditions**: The attack is feasible if:
1. Token contract is deployed manually without using the standard genesis initialization flow
2. Genesis initialization sequence partially fails or is incomplete
3. Side chain deployment uses a misconfigured TokenContractInitializationProvider that omits InitialCoefficients
4. Contract upgrade/redeployment scenario where coefficients are somehow reset to null

**Detection/Operational Constraints**: 
- In production, contracts are deployed atomically via BasicContractZero.DeploySystemSmartContract with initialization calls executed inline
- However, no on-chain mechanism prevents direct contract deployment without initialization
- If coefficients are set to null through any mechanism post-deployment, they become vulnerable

**Probability Reasoning**: LOW in normal operation due to atomic genesis deployment, but the vulnerability represents a critical design flaw that violates defense-in-depth principles. The stark contrast between InitialCoefficients (no auth) and UpdateCoefficients* methods (strict auth) indicates this is unintended behavior.

### Recommendation

**Code-Level Mitigation**: Add sender authorization to `InitialCoefficients`:

```csharp
public override Empty InitialCoefficients(Empty input)
{
    Assert(State.AllCalculateFeeCoefficients.Value == null, "Coefficient already initialized");
    
    // ADD THIS: Restrict to genesis/economic contract during initialization
    if (State.Initialized.Value) // If system is initialized
    {
        // Only allow governance-controlled initialization
        AssertDeveloperFeeController();
    }
    else
    {
        // During genesis, only allow system contracts
        var economicContract = Context.GetContractAddressByName(SmartContractConstants.EconomicContractSystemName);
        Assert(Context.Sender == economicContract || Context.Sender == Context.Self, 
            "Only system contracts can initialize coefficients");
    }
    
    // ... rest of method
}
```

**Invariant Checks**: Add assertion that verifies coefficients are initialized before any fee charging operation occurs.

**Test Cases**: Add test case verifying that unauthorized callers cannot call InitialCoefficients:
```csharp
[Fact]
public async Task InitialCoefficients_Without_Authorization_Test()
{
    var randomUser = GetTester<TokenContractStub>(TokenContractAddress, UnauthorizedKeyPair);
    var result = await randomUser.InitialCoefficients.SendWithExceptionAsync(new Empty());
    result.TransactionResult.Error.ShouldContain("Only system contracts can initialize");
}
```

### Proof of Concept

**Required Initial State**:
1. MultiToken contract deployed on chain
2. `State.AllCalculateFeeCoefficients.Value == null` (coefficients not yet initialized)
3. Attacker has address with transaction sending capability

**Transaction Steps**:
1. Attacker monitors chain state for token contract deployment
2. Before legitimate initialization completes, attacker sends:
   ```
   Contract: TokenContract
   Method: InitialCoefficients
   Params: Empty()
   ```
3. Attacker's transaction includes malicious coefficient values (code modification) or relies on attacker deploying modified contract

**Expected vs Actual Result**:
- **Expected**: Transaction should fail with "No permission" or "Unauthorized" error
- **Actual**: Transaction succeeds, attacker's coefficients are set, `CalculateFeeAlgorithmUpdated` event fires with attacker-controlled values

**Success Condition**: 
- `State.AllCalculateFeeCoefficients.Value != null` after attacker's transaction
- Subsequent legitimate initialization fails with "Coefficient already initialized"
- All fee calculations use attacker's malicious coefficients

**Notes**

This vulnerability is classified as an **authorization gap** rather than dead code. The state variable `AllCalculateFeeCoefficients` is actively used throughout the fee calculation system, as evidenced by the view methods and fee charging operations that query it.

The issue is specifically that the **initialization path lacks proper access control**, while the **update paths are correctly protected** by governance controllers. This inconsistency indicates the authorization check was likely overlooked during the initial implementation of `InitialCoefficients`.

While the atomic genesis deployment mechanism provides practical protection in standard scenarios, the absence of explicit authorization violates security best practices and creates risk in edge cases (manual deployment, initialization failures, contract upgrades, or side chain configuration errors).

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L16-16)
```csharp
    public SingletonState<AllCalculateFeeCoefficients> AllCalculateFeeCoefficients { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L16-23)
```csharp
    public override Empty UpdateCoefficientsForContract(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        Assert(input.Coefficients.FeeTokenType != (int)FeeTypeEnum.Tx, "Invalid fee type.");
        AssertDeveloperFeeController();
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L25-32)
```csharp
    public override Empty UpdateCoefficientsForSender(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        AssertUserFeeController();
        input.Coefficients.FeeTokenType = (int)FeeTypeEnum.Tx; // The only possible for now.
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L108-130)
```csharp
    public override Empty InitialCoefficients(Empty input)
    {
        Assert(State.AllCalculateFeeCoefficients.Value == null, "Coefficient already initialized");
        var allCalculateFeeCoefficients = new AllCalculateFeeCoefficients();
        if (allCalculateFeeCoefficients.Value.All(x => x.FeeTokenType != (int)FeeTypeEnum.Read))
            allCalculateFeeCoefficients.Value.Add(GetReadFeeInitialCoefficient());
        if (allCalculateFeeCoefficients.Value.All(x => x.FeeTokenType != (int)FeeTypeEnum.Storage))
            allCalculateFeeCoefficients.Value.Add(GetStorageFeeInitialCoefficient());
        if (allCalculateFeeCoefficients.Value.All(x => x.FeeTokenType != (int)FeeTypeEnum.Write))
            allCalculateFeeCoefficients.Value.Add(GetWriteFeeInitialCoefficient());
        if (allCalculateFeeCoefficients.Value.All(x => x.FeeTokenType != (int)FeeTypeEnum.Traffic))
            allCalculateFeeCoefficients.Value.Add(GetTrafficFeeInitialCoefficient());
        if (allCalculateFeeCoefficients.Value.All(x => x.FeeTokenType != (int)FeeTypeEnum.Tx))
            allCalculateFeeCoefficients.Value.Add(GetTxFeeInitialCoefficient());
        State.AllCalculateFeeCoefficients.Value = allCalculateFeeCoefficients;

        Context.Fire(new CalculateFeeAlgorithmUpdated
        {
            AllTypeFeeCoefficients = allCalculateFeeCoefficients
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L383-397)
```csharp
    private void AssertDeveloperFeeController()
    {
        Assert(State.DeveloperFeeController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");

        Assert(Context.Sender == State.DeveloperFeeController.Value.RootController.OwnerAddress, "no permission");
    }

    private void AssertUserFeeController()
    {
        Assert(State.UserFeeController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");
        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == State.UserFeeController.Value.RootController.OwnerAddress, "no permission");
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L36-36)
```csharp
        State.TokenContract.InitialCoefficients.Send(new Empty());
```

**File:** src/AElf.Kernel.Token/TokenContractInitializationProvider.cs (L53-57)
```csharp
            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.InitialCoefficients),
                Params = new Empty().ToByteString()
            });
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L115-117)
```csharp
        if (transactionMethodCallList != null)
            foreach (var methodCall in transactionMethodCallList.Value)
                Context.SendInline(address, methodCall.MethodName, methodCall.Params);
```

**File:** protobuf/token_contract.proto (L99-101)
```text
    // Initialize coefficients of every type of tokens supporting charging fee.
    rpc InitialCoefficients (google.protobuf.Empty) returns (google.protobuf.Empty){
    }
```
