# Audit Report

## Title
Continuous Blocks Limit Bypass via RoundNumber Manipulation in UpdateValue/TinyBlock Behaviors

## Summary
The AEDPoS consensus contract fails to validate `RoundNumber` in consensus extra data for `UpdateValue` and `TinyBlock` behaviors. A malicious miner can set `RoundNumber ≤ 2` in block headers to bypass `ContinuousBlocksValidationProvider` enforcement, allowing unlimited consecutive block production beyond the intended limit of 8 blocks (or miner count).

## Finding Description

The vulnerability exists due to an asymmetry in validation logic across consensus behaviors.

**Root Cause Analysis:**

The `GetUpdateValueRound` and `GetTinyBlockRound` methods copy `RoundNumber` directly from the current round state without any validation mechanism: [1](#0-0) [2](#0-1) 

For `NextRound` and `NextTerm` behaviors, `RoundTerminateValidationProvider` enforces that the provided `RoundNumber` must increment by exactly 1: [3](#0-2) 

However, this validation provider is **only added for NextRound and NextTerm behaviors**, not for UpdateValue or TinyBlock: [4](#0-3) 

The `ContinuousBlocksValidationProvider`, which prevents miners from producing too many consecutive blocks, relies on `ProvidedRound.RoundNumber` from the block header: [5](#0-4) 

The `ProvidedRound` is directly sourced from unvalidated block header extra data: [6](#0-5) 

**Exploitation Path:**

1. During `ValidateBeforeExecution`, recovery methods are called but **do not modify `RoundNumber`** - they only merge miner-specific fields: [7](#0-6) 

2. The validation context uses the manipulated `ProvidedRound.RoundNumber` from the header, allowing the miner to bypass the continuous blocks check by setting it to ≤2.

3. After block execution, `ValidateConsensusAfterExecution` calls recovery again and **overwrites the header round with the corrected state round**: [8](#0-7) 

4. The hash validation compares the corrected round against itself, so it passes: [9](#0-8) 

5. The `GetHash` method includes `RoundNumber` in its calculation, but uses the corrected value from state: [10](#0-9) 

## Impact Explanation

**Consensus Integrity Violation:**

The continuous blocks limit exists to ensure fair block production distribution. The limit is defined as: [11](#0-10) 

When a miner exhausts this limit, the counter becomes negative, and the advisory check in `GetConsensusCommand` suggests producing a `NextRound` block instead: [12](#0-11) 

By bypassing validation, a malicious miner can:
- **Monopolize block production**: Produce unlimited consecutive blocks beyond the 8-block limit
- **Starve other miners**: Prevent honest miners from producing blocks and earning rewards
- **Misallocate rewards**: Capture a disproportionate share of mining rewards
- **Centralize consensus**: Undermine the distributed nature of block production

The counter mechanism is critical to consensus fairness: [13](#0-12) 

## Likelihood Explanation

**Attack Feasibility: HIGH**

Any active miner in the consensus set can exploit this vulnerability with minimal effort:

1. **Access Requirements**: Only requires being an elected miner (no special privileges needed)
2. **Technical Complexity**: Low - simple modification of `RoundNumber` field in consensus extra data generation
3. **Detection Difficulty**: High - the manipulated value is corrected during post-execution recovery, making it invisible in final state
4. **Economic Cost**: None beyond normal mining operation costs
5. **Preventive Measures**: The advisory check in `GetConsensusCommand` can be bypassed by ignoring the recommendation and manually constructing blocks

The attack requires modifying node software to:
- Override the `GetUpdateValueRound`/`GetTinyBlockRound` output
- Set `RoundNumber` to 1 or 2 before including in block header
- Submit the block to the network

## Recommendation

Add `RoundNumber` validation for `UpdateValue` and `TinyBlock` behaviors by checking that the provided `RoundNumber` matches the current round number from state:

```csharp
// In UpdateValueValidationProvider or a new dedicated validator
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    if (validationContext.ProvidedRound.RoundNumber != validationContext.BaseRound.RoundNumber)
    {
        return new ValidationResult 
        { 
            Message = "Provided RoundNumber does not match current round number." 
        };
    }
    
    // ... rest of validation
    return new ValidationResult { Success = true };
}
```

Then add this validation provider for both `UpdateValue` and `TinyBlock` behaviors in `ValidateBeforeExecution`:

```csharp
case AElfConsensusBehaviour.UpdateValue:
    validationProviders.Add(new RoundNumberValidationProvider());
    validationProviders.Add(new UpdateValueValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider());
    break;
case AElfConsensusBehaviour.TinyBlock:
    validationProviders.Add(new RoundNumberValidationProvider());
    break;
```

This ensures that miners cannot manipulate `RoundNumber` in consensus extra data to bypass continuous blocks validation.

## Proof of Concept

```csharp
[Fact]
public async Task ContinuousBlocksLimitBypass_Via_RoundNumberManipulation()
{
    // Setup: Initialize consensus with multiple miners
    var initialMiners = await InitialAElfConsensusContract();
    var miner = initialMiners[0];
    
    // Produce blocks until continuous blocks limit is exhausted
    for (int i = 0; i < AEDPoSContractConstants.MaximumTinyBlocksCount + 1; i++)
    {
        await ProduceTinyBlock(miner);
    }
    
    // Verify that miner has exhausted the limit
    var latestCount = await GetLatestPubkeyToTinyBlocksCount();
    Assert.True(latestCount.BlocksCount < 0);
    Assert.Equal(miner.PublicKey, latestCount.Pubkey);
    
    // Attack: Create UpdateValue block with manipulated RoundNumber = 2
    var currentRound = await GetCurrentRoundInformation();
    var manipulatedRound = currentRound.GetUpdateValueRound(miner.PublicKey);
    manipulatedRound.RoundNumber = 2; // Bypass validation
    
    var extraData = new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(miner.PublicKey)),
        Round = manipulatedRound,
        Behaviour = AElfConsensusBehaviour.UpdateValue
    };
    
    // Validation should fail but passes due to vulnerability
    var validationResult = await ValidateConsensusBeforeExecution(extraData);
    
    // The block is accepted despite exceeding continuous blocks limit
    Assert.True(validationResult.Success);
    
    // Miner can continue producing blocks indefinitely by repeating this attack
    await ProduceBlockWithManipulatedRoundNumber(miner, roundNumber: 2);
    await ProduceBlockWithManipulatedRoundNumber(miner, roundNumber: 1);
    
    // Other miners are starved of block production opportunities
    var producedBlocksCount = await GetMinerProducedBlocksCount(miner.PublicKey);
    Assert.True(producedBlocksCount > AEDPoSContractConstants.MaximumTinyBlocksCount + 3);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L14-16)
```csharp
        var round = new Round
        {
            RoundNumber = RoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L61-63)
```csharp
        var round = new Round
        {
            RoundNumber = RoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-30)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-32)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-97)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```
