### Title
Consensus DoS via Null ExpectedMiningTime in Single-Node Round Validation Bypass

### Summary
The `CheckRoundTimeSlots()` validation method bypasses null checks for `ExpectedMiningTime` when only one miner exists, allowing a malicious Round to be saved to state. [1](#0-0)  Subsequent consensus operations calling `GetRoundStartTime()` will throw `NullReferenceException`, halting chain progression. [2](#0-1) 

### Finding Description

**Root Cause:**
The `CheckRoundTimeSlots()` method in Round.cs returns success immediately for single-node consensus without validating that `ExpectedMiningTime` is not null. [3](#0-2)  For multi-node rounds, the null check at line 40 catches this, but single-node rounds bypass it entirely.

**Vulnerable Code Paths:**

1. `CalculateFutureRoundStartTime()` calls `GetRoundStartTime().AddMilliseconds()` without null checks. [4](#0-3) 

2. `ArrangeAbnormalMiningTime()` calls `GetRoundStartTime()` for distance calculation. [5](#0-4) 

3. `GetRoundStartTime()` returns `FirstMiner().ExpectedMiningTime` without null validation. [6](#0-5) 

4. `FirstMiner()` can return a `MinerInRound` with null `ExpectedMiningTime`. [7](#0-6) 

5. `AddMilliseconds()` extension method will throw `NullReferenceException` when called on null. [8](#0-7) 

**Why Protections Fail:**

The validation flow uses `TimeSlotValidationProvider` which calls `CheckRoundTimeSlots()` for new rounds. [9](#0-8)  However, the single-node bypass creates a validation gap where malicious Round data can enter state.

**Execution Path:**
1. Single miner submits `NextRoundInput` with null `ExpectedMiningTime` via `NextRound()`. [10](#0-9) 
2. `ProcessNextRound()` converts input to Round and saves via `AddRoundInformation()`. [11](#0-10) 
3. Next block validation calls `IsCurrentMiner()` which invokes `GetRoundStartTime()`. [12](#0-11) 
4. `NullReferenceException` thrown, consensus halts.

### Impact Explanation

**Harm:**
Complete consensus failure - the chain cannot validate subsequent blocks or produce new rounds. Any attempt to call `IsCurrentMiner()` during block validation or `ArrangeAbnormalMiningTime()` for scheduling will throw unhandled exceptions. [13](#0-12) 

**Affected Systems:**
- Single-node consensus chains (testnets, side chains, initial bootstrap phases)
- Any chain during miner list transitions where temporary single-node operation occurs
- Development and testing environments

**Severity Justification:**
High severity due to complete consensus DoS. While limited to single-node scenarios, these are real operational states (side chain initialization, testnet phases, emergency fallback modes). Recovery requires state intervention or chain restart with corrected data.

### Likelihood Explanation

**Attacker Capabilities:**
Attacker must be a valid miner in single-node consensus. This is feasible for:
- Testnet operators
- Side chain initial operators  
- Malicious validator during bootstrap phase
- Compromised validator in single-validator fallback mode

**Attack Complexity:**
Low - simply craft `NextRoundInput` with null `ExpectedMiningTime` and submit via standard `NextRound()` transaction. The `PreCheck()` only verifies miner list membership, not Round structure validity. [14](#0-13) 

**Feasibility Conditions:**
- `RealTimeMinersInformation.Count == 1` (single-node consensus)
- Attacker controls the single miner account
- No external validation of Round structure beyond `CheckRoundTimeSlots()`

**Detection/Operational Constraints:**
Attack is immediately detectable (chain halts), but requires manual state correction. Not economically rational as self-DoS, but possible motivations include:
- Halting competitor's side chain
- Disrupting testnet operations
- Forcing chain migration/upgrade
- Accidental bug in client implementation

**Probability:**
Medium-Low - requires specific single-node scenario, but those scenarios genuinely occur in production systems (side chains, testnets, bootstrap).

### Recommendation

**Code-Level Mitigation:**

1. Remove single-node bypass from `CheckRoundTimeSlots()` - validate `ExpectedMiningTime` for all rounds: [3](#0-2) 

```
Replace lines 36-38 with null check for all miners regardless of count.
```

2. Add defensive null check in `GetRoundStartTime()`: [6](#0-5) 

```
Verify FirstMiner() and ExpectedMiningTime are not null before returning.
```

3. Add null guards in `ArrangeAbnormalMiningTime()` before timestamp arithmetic: [15](#0-14) 

**Invariant Checks:**
- All `MinerInRound` objects in state must have non-null `ExpectedMiningTime`
- `GetRoundStartTime()` must never return null
- Round validation must apply to single-node and multi-node equally

**Test Cases:**
1. Submit `NextRoundInput` with single miner having null `ExpectedMiningTime` - expect rejection
2. Verify `CheckRoundTimeSlots()` validates single-node rounds identically to multi-node
3. Test `ArrangeAbnormalMiningTime()` with defensive checks handles edge cases gracefully
4. Ensure `FirstRound()` initialization always sets valid timestamps

### Proof of Concept

**Required Initial State:**
- Chain running in single-node consensus mode (1 miner)
- Attacker controls the single miner private key

**Transaction Steps:**

1. Load current round from state via `TryToGetCurrentRoundInformation()` [16](#0-15) 

2. Craft malicious `NextRoundInput`:
   - Set `RoundNumber` = current + 1
   - Create single `MinerInRound` with attacker's pubkey
   - Set `ExpectedMiningTime` = null (omit in protobuf)
   - Set other required fields (Order, IsExtraBlockProducer)

3. Submit via `NextRound(maliciousInput)` transaction

4. Observe: `CheckRoundTimeSlots()` returns success (single-node bypass), Round saved to state

5. Next block attempts validation via `IsCurrentMiner()` → calls `GetRoundStartTime()` → accesses null → `NullReferenceException` thrown

**Expected vs Actual:**
- **Expected**: Validation rejects Round with null timestamp, consensus continues normally
- **Actual**: Validation accepts malformed Round, subsequent operations throw exception, chain halts

**Success Condition:**
Chain unable to produce/validate blocks after malicious Round is accepted and any code path attempts to use `GetRoundStartTime()` or `ArrangeAbnormalMiningTime()`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-41)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L105-107)
```csharp
    public Timestamp GetRoundStartTime()
    {
        return FirstMiner().ExpectedMiningTime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L142-147)
```csharp
    public MinerInRound FirstMiner()
    {
        return RealTimeMinersInformation.Count > 0
            ? RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == 1)
            // Unlikely.
            : new MinerInRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L19-36)
```csharp
    public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
        bool mustExceededCurrentRound = false)
    {
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }

        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L51-57)
```csharp
    private Timestamp CalculateFutureRoundStartTime(long missedRoundsCount = 0, int miningInterval = 0)
    {
        if (miningInterval == 0)
            miningInterval = GetMiningInterval();

        var totalMilliseconds = TotalMilliseconds(miningInterval);
        return GetRoundStartTime().AddMilliseconds(missedRoundsCount.Add(1).Mul(totalMilliseconds));
```

**File:** src/AElf.CSharp.Core/Extension/TimestampExtensions.cs (L16-20)
```csharp
    public static Timestamp AddMilliseconds(this Timestamp timestamp, long milliseconds)
    {
        return timestamp + new Duration
            { Seconds = milliseconds / 1000, Nanos = (int)(milliseconds % 1000).Mul(1000000) };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-156)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L140-189)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;

        Context.LogDebug(() =>
            $"Extra block producer of previous round: {currentRound.ExtraBlockProducerOfPreviousRound}");

        // Check confirmed extra block producer of previous round.
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }

        var miningInterval = currentRound.GetMiningInterval();
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;

        // Check normal time slot.
        if (timeSlotStartTime <= Context.CurrentBlockTime && Context.CurrentBlockTime <=
            timeSlotStartTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]NORMAL");
            return true;
        }

        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }

        // Check saving extra block time slot.
        var nextArrangeMiningTime =
            currentRound.ArrangeAbnormalMiningTime(pubkey, Context.CurrentBlockTime, true);
        var actualArrangedMiningTime = nextArrangeMiningTime.AddMilliseconds(-currentRound.TotalMilliseconds());
        if (actualArrangedMiningTime <= Context.CurrentBlockTime &&
            Context.CurrentBlockTime <= actualArrangedMiningTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]SAVING");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-53)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
```
