### Title
Lexicographic Backup Selection Allows Malicious Miners to Persist Without Voting Support

### Summary
The `GetVictories()` function uses lexicographic ordering (`OrderBy(p => p)`) to select backup miners when valid candidates are insufficient. An attacker can craft public keys with low lexicographic values (e.g., starting with "0000...") to guarantee priority selection as backup miners, allowing them to maintain mining privileges and rewards indefinitely during candidate shortages without proportional voting support.

### Finding Description

The vulnerability exists in the `GetVictories()` private method in `ViewMethods.cs`. When there are insufficient valid candidates to fill the required miner count (`diff > 0`), the function creates a backup pool from current miners and initial miners, then selects backups using purely lexicographic ordering: [1](#0-0) 

The backup selection process:
1. Creates a backup pool from current miners not in valid candidates, plus initial miners
2. Sorts this pool lexicographically using `OrderBy(p => p)` where `p` is the hex string representation of the public key
3. Takes the first `diff` entries from the sorted list

**Root Cause**: The lexicographic ordering is deterministic but arbitrary - it provides no merit-based selection and can be gamed through vanity address generation.

**Why Existing Protections Fail**: 
- No check for banned pubkeys in the backup selection (unlike `GetMinerReplacementInformation` which does check `State.BannedPubkeyMap`)
- No consideration of vote amounts, performance history, or any merit-based criteria
- No verification that selected backups have any community support
- Valid candidates only require `ObtainedActiveVotedVotesAmount > 0` with no meaningful threshold [2](#0-1) 

**Execution Path**:
1. Consensus contract calls `GetVictories()` during term transition via `TryToGetVictories()` [3](#0-2) 

2. The returned victories list is used directly to generate the new term's miner list
3. Attackers with low-sorting pubkeys are systematically selected first when `diff > 0`

### Impact Explanation

**Direct Harm**:
- **Reward Misallocation**: Attackers continue earning block production rewards and transaction fees without maintaining proportional community voting support. With candidate lock requirement of 100,000 ELF, mining rewards over multiple terms could far exceed this cost. [4](#0-3) 

- **Consensus Integrity Compromise**: Miners without community backing remain in the consensus set, enabling potential censorship attacks, transaction filtering, or collusion with other similarly-positioned miners.

- **Democratic Subversion**: The entire purpose of the Election contract is to allow token holders to vote for miners. This vulnerability subverts that mechanism by allowing miners to persist without votes through lexicographic gaming.

**Affected Parties**:
- Legitimate candidates with higher-sorting pubkeys who should be selected as backups
- Token holders whose votes are effectively nullified
- Ecosystem security as miners without accountability remain in control

**Severity Justification**: HIGH because it:
- Directly compromises the vote-based miner selection mechanism
- Enables persistent control during candidate shortages (common in new/struggling chains)
- Amplifies with multiple colluding attackers using coordinated low-sorting pubkeys
- No detection or removal mechanism once established

### Likelihood Explanation

**Attacker Capabilities Required**:
1. **Vanity Pubkey Generation**: Generate public keys with low lexicographic values (e.g., starting with "0000..."). This is computationally feasible - finding a pubkey starting with four zeros requires approximately 16^4 = 65,536 keypair generations on average.

2. **Initial Election**: Must get elected at least once to become a current miner. This requires:
   - Locking 100,000 ELF per candidate (maximum 64 candidates system-wide)
   - Obtaining enough votes to be in top N candidates
   - Can be achieved through: vote buying, building legitimate reputation then acting maliciously, or Sybil attacks

3. **Vote Manipulation**: After initial election, attacker can cease maintaining voting support, knowing they'll be selected as backup during shortages.

**Attack Complexity**: Moderate
- Vanity generation: Low complexity
- Initial election: Medium complexity (main barrier)
- Exploitation: Low complexity once conditions met

**Feasibility Conditions**:
- Candidate shortage occurs (`diff > 0`): More likely in new chains, ecosystems with low participation, or after mass candidate exodus
- Attacker remains in current miner list or is an initial miner
- Multiple colluding attackers amplify impact by all using low-sorting pubkeys

**Detection Constraints**: 
- Difficult to distinguish from legitimate backup selection
- No on-chain indicator that a miner was selected via backup vs voting
- Pattern only emerges over multiple terms

**Probability**: MEDIUM to HIGH in scenarios where:
- Ecosystem has persistent candidate shortages (new/struggling chains)
- Initial election barrier can be overcome (vote buying, reputation building)
- Multiple attackers coordinate with low-sorting pubkeys

### Recommendation

**Immediate Fix**: Replace arbitrary lexicographic ordering with merit-based backup selection in `GetVictories()`:

```csharp
// Instead of: victories.AddRange(backups.OrderBy(p => p)...
// Use vote-based or performance-based ordering:

var backupsWithVotes = backups
    .Select(k => new { 
        Pubkey = k, 
        Votes = State.CandidateVotes[k]?.ObtainedActiveVotedVotesAmount ?? 0,
        IsInitialMiner = State.InitialMiners.Value.Value.Contains(ByteStringHelper.FromHexString(k))
    })
    .Where(x => !State.BannedPubkeyMap[x.Pubkey]) // Filter banned pubkeys
    .OrderByDescending(x => x.IsInitialMiner) // Prioritize initial miners
    .ThenByDescending(x => x.Votes) // Then by vote amount
    .Select(x => x.Pubkey);

victories.AddRange(backupsWithVotes
    .Take(Math.Min(diff, backups.Count))
    .Select(v => ByteStringHelper.FromHexString(v)));
```

**Additional Protections**:
1. Add banned pubkey filtering in backup selection (currently missing, unlike in `GetMinerReplacementInformation`)
2. Implement minimum vote threshold even for backup selection to ensure some community support
3. Consider performance-based metrics (blocks produced, missed time slots) in backup ordering
4. Add maximum consecutive terms a backup can serve without achieving valid candidate status

**Invariant Checks**:
- Assert that selected backups are not banned: `Assert(!State.BannedPubkeyMap[pubkey], "Banned pubkey in backup selection")`
- Log backup selections for transparency and monitoring
- Emit events when backups are selected vs voted miners for auditability

**Test Cases**:
1. Test with multiple candidates having pubkeys starting with "0000..." vs "FFFF..." during candidate shortage
2. Verify banned pubkeys are excluded from backup selection
3. Test that backups with higher votes are preferred over lexicographically-lower pubkeys
4. Simulate multi-term scenarios where backups should eventually lose position if not gaining votes

### Proof of Concept

**Initial State**:
- `State.MinersCount.Value = 17` (need 17 miners)
- Current miners: 17 miners including attacker's pubkey "0000...abc"
- Valid candidates for next term: Only 10 candidates with votes > 0
- Attacker was previously elected but now has 0 votes

**Attack Sequence**:

**Step 1 - Preparation** (Before vulnerability exploit):
- Attacker generates vanity keypair with pubkey hex starting with "0000...abc"
- Attacker calls `AnnounceElection()`, locking 100,000 ELF
- Attacker obtains votes (through vote buying, legitimate reputation, or other means)
- Attacker gets elected in Term N, becomes part of `currentMiners`

**Step 2 - Exploitation** (Term N+1):
- Attacker stops maintaining votes or votes decrease to 0
- Only 10 other candidates have votes > 0 (`validCandidates.Count = 10`)
- `diff = 17 - 10 = 7` (need 7 backups)
- `GetVictories()` is called during term transition

**Step 3 - Backup Selection**:
- Current implementation: `backups.OrderBy(p => p).Take(7)`
- Attacker's "0000...abc" pubkey sorts first lexicographically
- Attacker is selected as backup despite having 0 votes
- Other miners with legitimate voting support but higher-sorting pubkeys are excluded

**Expected Result** (Vulnerable):
- Attacker remains in miner set for Term N+1 without any votes
- Continues earning mining rewards
- Process repeats in Term N+2, N+3, etc. as long as shortage persists

**Actual Result** (With Fix):
- Backups selected based on votes/performance rather than arbitrary lexicographic order
- Attacker with 0 votes is deprioritized
- Miners with higher votes or initial miner status are preferred
- System maintains democratic integrity during candidate shortages

**Success Condition** (For Attack):
- Attacker with "0000..." pubkey and 0 votes is in returned victories list
- Other miners with votes but higher-sorting pubkeys are excluded
- Attacker maintains position across multiple terms during persistent shortages

**Notes**:
- The vulnerability is most severe when multiple colluding attackers coordinate with low-sorting pubkeys (e.g., "0000...001", "0000...002", etc.), allowing them to dominate the backup pool
- The 64 candidate limit system-wide provides some protection but doesn't prevent 5-10 coordinated malicious actors from significantly impacting backup selection
- The issue is exacerbated in new or struggling ecosystems where candidate shortages are more common
- Initial miners are particularly vulnerable to this as they can persist indefinitely without ever needing to maintain votes, as long as they have low-sorting pubkeys

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L60-77)
```csharp
        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-280)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```
