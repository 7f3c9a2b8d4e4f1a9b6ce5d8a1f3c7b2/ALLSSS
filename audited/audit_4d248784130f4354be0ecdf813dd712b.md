### Title
Negative BlockchainAge Due to Missing Timestamp Monotonicity Validation

### Summary
The `GenerateNextRoundInformation()` function calculates `BlockchainAge` by subtracting `blockchainStartTimestamp` from `currentBlockTimestamp` without validating that `currentBlockTimestamp >= blockchainStartTimestamp`. If a miner produces a block with a timestamp earlier than the blockchain start (due to clock skew or malicious behavior), `BlockchainAge` becomes negative, breaking mining reward halving logic and dynamic miner count calculations.

### Finding Description [1](#0-0) 

At this line, `BlockchainAge` is calculated as `(currentBlockTimestamp - blockchainStartTimestamp).Seconds`. When `currentBlockTimestamp < blockchainStartTimestamp`, the subtraction yields a negative `Duration`, resulting in a negative `BlockchainAge` value.

**Root Cause:** No validation enforces timestamp monotonicity. The system lacks checks ensuring `Context.CurrentBlockTime >= State.BlockchainStartTimestamp.Value` or `Context.CurrentBlockTime >= previous block time`.

**Why Protections Fail:**

1. **Block Validation** only prevents future timestamps: [2](#0-1) 

This validation checks blocks aren't more than 4 seconds in the future but does NOT prevent backward timestamps.

2. **Time Slot Validation** only checks relative timing: [3](#0-2) 

This validates miners respect their assigned time slots but doesn't enforce absolute time progression.

3. **Blockchain Start Timestamp** is set once during first round transition: [4](#0-3) 

After initialization, it's never validated against subsequent block timestamps.

### Impact Explanation

**Mining Reward Calculation Breaks:** [5](#0-4) 

With negative `blockAge`, the denominator becomes negative/zero, preventing the reward halving loop from executing. Mining rewards remain at the initial 12,500,000 value indefinitely instead of halving over time, causing excessive token inflation.

**Miner Count Calculation Corrupted:** [6](#0-5) 

Line 389 calculates `(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds` for dynamic miner count adjustment. Negative values could produce miner counts below the minimum (17) or even negative, breaking consensus entirely.

**Affected Parties:**
- All network participants (incorrect mining rewards)
- Miners (incorrect miner count disrupts consensus)
- Token holders (inflation from non-halving rewards)

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an elected miner with valid consensus credentials
- Ability to set block header timestamp during block production

**Attack Complexity:**
The entry point is the `NextRound` method: [7](#0-6) 

When called, it uses `Context.CurrentBlockTime` from the block header without validation against `blockchainStartTimestamp`: [8](#0-7) 

**Feasibility:** While miners are typically trusted validators, the absence of code-level validation means:
- Severe clock skew could trigger this unintentionally
- A compromised or malicious miner could exploit this deliberately
- No explicit check prevents the invalid state

**Detection Constraints:** The consensus system would likely become unstable with backward timestamps, but damage occurs before detection.

### Recommendation

**Add Timestamp Validation:**

1. In `GenerateNextRoundInformation()`, add validation before calculating `BlockchainAge`:
```csharp
if (currentBlockTimestamp < blockchainStartTimestamp)
{
    throw new AssertionException("Block timestamp cannot be earlier than blockchain start timestamp");
}
```

2. In `BlockValidationProvider.ValidateBeforeAttachAsync()`, add monotonic timestamp check:
```csharp
// After existing validations
var previousBlock = await _blockchainService.GetBlockByHashAsync(block.Header.PreviousBlockHash);
if (previousBlock != null && block.Header.Time < previousBlock.Header.Time)
{
    Logger.LogDebug("Block timestamp {BlockTime} earlier than previous block {PreviousTime}", 
        block.Header.Time, previousBlock.Header.Time);
    return Task.FromResult(false);
}
```

3. Add test cases covering:
    - Block timestamp < blockchain start timestamp (should fail)
    - Block timestamp < previous block timestamp (should fail)
    - BlockchainAge calculation with edge case timestamps

### Proof of Concept

**Initial State:**
- Blockchain initialized with `blockchainStartTimestamp = T0` (e.g., 2024-01-01 00:00:00)
- Current round number > 1

**Attack Steps:**
1. Malicious elected miner produces a block during their valid time slot
2. Sets block header `Time = T0 - 1000` (e.g., 2023-12-31 23:43:20, 1000 seconds before start)
3. Calls `NextRound` with consensus extra data
4. `GenerateNextRoundInformation()` executes at line 23:
   - `currentBlockTimestamp = T0 - 1000`
   - `blockchainStartTimestamp = T0`
   - `BlockchainAge = (T0 - 1000 - T0).Seconds = -1000`

**Expected vs Actual:**
- **Expected:** Transaction rejected due to invalid timestamp
- **Actual:** Transaction succeeds, `BlockchainAge = -1000`, breaking reward calculations

**Success Condition:** 
Query `GetCurrentRoundInformation()` and verify `round.BlockchainAge < 0`, confirming the vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L23-23)
```csharp
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;
```

**File:** src/AElf.Kernel.Core/Blockchain/Application/IBlockValidationProvider.cs (L133-139)
```csharp
        if (block.Header.Height != AElfConstants.GenesisBlockHeight &&
            block.Header.Time.ToDateTime() - TimestampHelper.GetUtcNow().ToDateTime() >
            KernelConstants.AllowedFutureBlockTimeSpan.ToTimeSpan())
        {
            Logger.LogDebug("Future block received {Block}, {BlockTime}", block, block.Header.Time.ToDateTime());
            return Task.FromResult(false);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-50)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L117-123)
```csharp
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L143-151)
```csharp
    private long GetMiningRewardPerBlock()
    {
        var miningReward = AEDPoSContractConstants.InitialMiningRewardPerBlock;
        var blockAge = GetBlockchainAge();
        var denominator = blockAge.Div(AEDPoSContractConstants.TimeToReduceMiningRewardByHalf);
        for (var i = 0; i < denominator; i++) miningReward = miningReward.Div(2);

        return miningReward;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L285-346)
```csharp
    private void GenerateNextRoundInformation(Round currentRound, Timestamp currentBlockTime, out Round nextRound)
    {
        TryToGetPreviousRoundInformation(out var previousRound);
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();
        var isMinerListChanged = false;
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }

        currentRound.GenerateNextRoundInformation(currentBlockTime, blockchainStartTimestamp, out nextRound,
            isMinerListChanged);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```
