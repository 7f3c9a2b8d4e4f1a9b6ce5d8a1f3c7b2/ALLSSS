# Audit Report

## Title
Profit Detail Misidentification Due to Inconsistent Selection Logic for Legacy Votes with Identical Shares

## Summary
The Election contract's `GetProfitDetailByElectionVotingRecord()` uses `LastOrDefault` to identify legacy profit details by Shares value, while the Profit contract's `FixProfitDetail()` uses `OrderBy(StartPeriod).FirstOrDefault` with the same criteria. When a voter has multiple legacy votes with identical weight values, this mismatch causes the wrong profit detail to be extended during vote option changes, resulting in incorrect welfare profit distributions. [1](#0-0) [2](#0-1) 

## Finding Description

The vulnerability exists in the handling of legacy profit details created before the ProfitDetailId feature was implemented (where `profitDetail.Id` is null).

**Inconsistent Selection Logic:**

In the Election contract's `GetProfitDetailByElectionVotingRecord()`, when a profit detail cannot be found by its vote ID, the code falls back to matching by Shares value using `LastOrDefault`: [3](#0-2) 

However, in the Profit contract's `FixProfitDetail()`, the fallback logic uses a different selection strategy - it orders by StartPeriod and uses `FirstOrDefault`: [4](#0-3) 

**Execution Path:**

When a voter calls `ChangeVotingOption` with `IsResetVotingTime = true`: [5](#0-4) 

The `ExtendVoterWelfareProfits` method is invoked: [6](#0-5) 

This creates a critical mismatch:
- **Validation phase** (Election contract): Returns the LAST profit detail with matching Shares
- **Execution phase** (Profit contract): Modifies the FIRST profit detail (by StartPeriod) with matching Shares

**Weight Collision Feasibility:**

Multiple votes can have identical Shares values due to the weight calculation's rounding behavior. The calculation involves exponential operations and integer casting that can produce collisions: [7](#0-6) 

The formula `(long)(Pow(initBase, (uint)lockDays) * votesAmount)` with decimal-to-long casting can produce identical weights for different (amount, lockTime) combinations.

## Impact Explanation

**Direct Fund Impact - Reward Misallocation:**

When a voter attempts to extend Vote B's profit period, Vote A's profit detail gets extended instead. This causes:
- The intended vote (B) does not receive extended welfare profit benefits
- An unintended vote (A) continues receiving welfare profits beyond its intended period
- Direct violation of profit distribution accuracy guarantees

**Affected Parties:**
- Voters with multiple legacy votes having identical weights suffer incorrect profit allocations
- The overall welfare profit scheme distributes rewards incorrectly
- Protocol integrity is compromised as profit extension operations do not match user intentions

This is HIGH severity because it directly causes incorrect financial distributions in the welfare profit system, affecting voter rewards and potentially allowing unintended profit extensions.

## Likelihood Explanation

**Reachable Entry Point:**

The vulnerability is triggered through the public `ChangeVotingOption` function, callable by any voter: [8](#0-7) 

**Feasible Preconditions:**
1. Legacy profit details exist from before ProfitDetailId implementation (confirmed by code comments indicating "old world" data)
2. A voter has multiple legacy votes with identical calculated weights
3. Weight collisions are realistic due to rounding in the exponential calculation

**Execution Practicality:**
- No special privileges required - any voter can call `ChangeVotingOption`
- No complex state manipulation needed
- Simple transaction execution under normal AElf contract semantics

**Economic Rationality:**
- Standard gas costs for vote operations
- No economic barriers to exploitation
- Occurs naturally when voters have multiple votes with similar parameters

**Detection Constraints:**

The mismatch is silent - the transaction succeeds but modifies the wrong profit detail. No on-chain events would indicate the error occurred.

## Recommendation

Ensure consistent profit detail selection logic between the Election and Profit contracts. The recommended fix is to use the same selection strategy in both contracts:

**Option 1:** Use `FirstOrDefault` with `OrderBy(StartPeriod)` in both contracts
**Option 2:** Use `LastOrDefault` in both contracts  
**Option 3:** Add additional validation to ensure the identified profit detail matches the one being modified

The most robust solution would be to add explicit validation in `ExtendVoterWelfareProfits`:

```csharp
private void ExtendVoterWelfareProfits(Hash voteId)
{
    // ... existing code ...
    
    var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
    if (extendingDetail != null)
    {
        // Verify there are no other profit details with identical Shares
        var allDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });
        
        var matchingByShares = allDetails.Details.Where(d => 
            d.Id == null && d.Shares == electionVotingRecord.Weight).ToList();
            
        Assert(matchingByShares.Count <= 1, 
            "Multiple legacy profit details with identical shares detected.");
        
        // Proceed with FixProfitDetail...
    }
}
```

Alternatively, modify the selection logic to be consistent:

```csharp
// In GetProfitDetailByElectionVotingRecord - change to FirstOrDefault with OrderBy
if (profitDetail == null)
{
    profitDetail = profitDetails.Details
        .OrderBy(d => d.StartPeriod)
        .FirstOrDefault(d => d.Shares == electionVotingRecord.Weight);
}
```

## Proof of Concept

A test demonstrating this vulnerability would:

1. Create two legacy votes for the same voter with different lock times that produce identical weights due to rounding
2. Verify both profit details exist with `Id = null` and identical `Shares` values but different `StartPeriod` values
3. Call `ChangeVotingOption` with `IsResetVotingTime = true` for the second vote
4. Verify that the first vote's profit detail was modified instead of the second vote's profit detail

The test would confirm that `GetProfitDetailByElectionVotingRecord` returns the last profit detail while `FixProfitDetail` modifies the first profit detail by StartPeriod, proving the mismatch.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L23-44)
```csharp
    public override Empty ChangeVotingOption(ChangeVotingOptionInput input)
    {
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input.VoteId);
        Assert(Context.Sender == votingRecord.Voter, "No permission to change current vote's option.");
        var actualLockedSeconds = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockingSeconds = State.LockTimeMap[input.VoteId];
        Assert(actualLockedSeconds < claimedLockingSeconds, "This vote already expired.");

        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
        }
        else
        {
            // false, no change for EndPeroid
            State.LockTimeMap[input.VoteId] = State.LockTimeMap[input.VoteId].Sub(actualLockedSeconds);
        }

```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-160)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }

        var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L168-185)
```csharp
    private ProfitDetail GetProfitDetailByElectionVotingRecord(ElectionVotingRecord electionVotingRecord)
    {
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
            profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);
        }

        return profitDetail;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```
