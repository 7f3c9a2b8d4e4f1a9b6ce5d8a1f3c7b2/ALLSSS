### Title
Governance Downgrade via Unvalidated Controller Change Allows Single-Signature Control Over Developer Fees

### Summary
The `ChangeDeveloperController()` function only validates organization existence but not security parameters, allowing the current multi-signature governance to be replaced with a trivial single-member organization (MinimalApprovalThreshold = 1). Once changed, the new controller has sole authority over developer fee coefficients with no multi-signature protection, enabling unilateral manipulation of resource fee calculations.

### Finding Description

The vulnerability exists in `ChangeDeveloperController()` which performs insufficient validation on the new controller organization: [1](#0-0) 

The only validation is `CheckOrganizationExist(input)` at line 83, which merely confirms the organization exists: [2](#0-1) 

This calls `ValidateOrganizationExist` on the authorization contract: [3](#0-2) 

The Association contract's validation logic permits organizations with minimal security parameters: [4](#0-3) 

Lines 74 only requires `MinimalApprovalThreshold > 0`, allowing a value of 1 with a single member. After the controller change, lines 84-86 of `ChangeDeveloperController()` replace the multi-signature root controller and nullify parliament/developer controllers, leaving the new organization as the sole authority.

### Impact Explanation

**Governance Bypass**: The DeveloperFeeController is initialized with a two-layer governance structure requiring both Parliament and Developer association approval: [5](#0-4) 

By changing to a trivial organization, this multi-signature protection is eliminated. The new controller gains unilateral authority over:

1. **Developer Fee Coefficients**: Via `UpdateCoefficientsForContract()`: [6](#0-5) 

2. **Further Controller Changes**: Can perpetuate control by preventing governance restoration.

This affects all contracts on the chain, as resource fee calculations (READ, STORAGE, WRITE, TRAFFIC) can be manipulated to favor specific contracts or extract economic value through fee coefficient distortion.

### Likelihood Explanation

**Preconditions**: An attacker must:
1. Create a trivial Association organization with themselves as the sole member and MinimalApprovalThreshold = 1
2. Convince the current RootController (requiring both Parliament and Developer multi-sig approval) to approve a proposal calling `ChangeDeveloperController` with their organization address

**Attack Complexity**: MEDIUM-HIGH - Requires social engineering or proposal obfuscation. The governance body may not scrutinize the security parameters of the proposed organization address, especially if the proposal only displays the organization address without revealing its threshold/member configuration.

**Feasibility**: Test cases demonstrate that organizations with MinimalApprovalThreshold = 1 are routinely created: [7](#0-6) 

Once governance approves the change (even by mistake or incomplete review), the downgrade is irreversible without the new controller's consent.

### Recommendation

**Code-Level Mitigation**: Add validation in `ChangeDeveloperController()` to enforce minimum security requirements:

```csharp
Assert(CheckOrganizationExist(input), "Invalid authority input.");

// Validate minimum security parameters for Association organizations
if (input.ContractAddress == State.AssociationContract.Value)
{
    var org = State.AssociationContract.GetOrganization.Call(input.OwnerAddress);
    Assert(org.OrganizationMemberList.OrganizationMembers.Count >= 2, 
        "Controller must have at least 2 members");
    Assert(org.ProposalReleaseThreshold.MinimalApprovalThreshold >= 2, 
        "Controller must require at least 2 approvals");
}
```

**Alternative Approach**: Prevent controller downgrade by requiring the new controller to have security parameters at least as strong as the current controller.

**Test Cases**: Add negative test cases verifying rejection of:
- Single-member organizations
- Organizations with MinimalApprovalThreshold = 1
- Organizations with fewer approvals required than the current controller

### Proof of Concept

**Initial State**: DeveloperFeeController initialized with multi-signature governance (Parliament + Developer).

**Attack Steps**:
1. Attacker creates Association organization:
   - OrganizationMembers: [AttackerAddress]
   - MinimalApprovalThreshold: 1
   - MinimalVoteThreshold: 1

2. Attacker crafts proposal for current RootController:
   - Target: TokenContract.ChangeDeveloperController
   - Params: AttackerOrganizationAddress
   - Social engineering: "Updating developer fee governance structure"

3. Parliament approves proposal (believing it's routine governance update)

4. Developer association approves proposal

5. Proposal released, executing ChangeDeveloperController

**Expected Result**: Transaction should FAIL due to insufficient security parameters

**Actual Result**: Transaction SUCCEEDS, DeveloperFeeController.RootController set to attacker's single-member organization

**Success Condition**: Attacker can now unilaterally call UpdateCoefficientsForContract without any multi-signature approval, manipulating developer fee coefficients for all contracts.

### Notes

The vulnerability represents a governance downgrade attack vector where code-level validation fails to prevent weakening of security invariants. While exploitation requires current governance approval (making direct exploitation difficult), the lack of validation violates the principle of defense-in-depth and could enable attacks through proposal obfuscation, incomplete governance review, or social engineering. The severity is HIGH due to complete bypass of multi-signature governance controls over critical fee parameters affecting the entire chain's economics.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L80-88)
```csharp
    public override Empty ChangeDeveloperController(AuthorityInfo input)
    {
        AssertDeveloperFeeController();
        Assert(CheckOrganizationExist(input), "Invalid authority input.");
        State.DeveloperFeeController.Value.RootController = input;
        State.DeveloperFeeController.Value.ParliamentController = null;
        State.DeveloperFeeController.Value.DeveloperController = null;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L213-241)
```csharp
    private Association.CreateOrganizationBySystemContractInput GetAssociationControllerCreateInputForDeveloperFee(
        Address parliamentAddress, Address developerAddress)
    {
        var proposers = new List<Address>
        {
            developerAddress, parliamentAddress
        };
        var actualProposalCount = proposers.Count;
        return new Association.CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new Association.CreateOrganizationInput
            {
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { proposers }
                },
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = actualProposalCount,
                    MinimalVoteThreshold = actualProposalCount,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { proposers }
                }
            }
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L16-23)
```csharp
    public override Empty UpdateCoefficientsForContract(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        Assert(input.Coefficients.FeeTokenType != (int)FeeTypeEnum.Tx, "Invalid fee type.");
        AssertDeveloperFeeController();
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/MultiTokenContractReferenceFeeTest.cs (L135-156)
```csharp
    private async Task<AuthorityInfo> CreateNewParliamentAddressAsync()
    {
        var newParliament = new CreateOrganizationInput
        {
            ProposerAuthorityRequired = false,
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MaximalAbstentionThreshold = 1,
                MaximalRejectionThreshold = 1,
                MinimalApprovalThreshold = 1,
                MinimalVoteThreshold = 1
            },
            ParliamentMemberProposingAllowed = false
        };
        var parliamentCreateRet = await ParliamentContractStub.CreateOrganization.SendAsync(newParliament);
        var newParliamentAddress = parliamentCreateRet.Output;
        return new AuthorityInfo
        {
            ContractAddress = ParliamentContractAddress,
            OwnerAddress = newParliamentAddress
        };
    }
```
