# Audit Report

## Title
Retroactive Vote Weight Inequality - Early Voters Maintain Inflated Weights After Interest Rate Changes

## Summary
The `SetVoteWeightInterest()` function modifies interest rates affecting vote weight calculations for new votes, but existing votes permanently retain their original weights calculated at creation time. This creates unfair reward distribution where early voters maintain inflated profit shares indefinitely while later voters with identical parameters receive reduced shares after rate decreases.

## Finding Description

**Root Cause:**
When `SetVoteWeightInterest()` updates interest rates, it only modifies the configuration state without recalculating existing vote weights stored in the profit contract. [1](#0-0) 

**Vote Weight Calculation and Storage:**
Vote weights are calculated once at vote creation using `GetVotesWeight()` with current interest rates, then permanently stored as "shares" in the profit scheme. [2](#0-1) 

The calculated weight is passed as shares to the profit contract: [3](#0-2) 

**Why Weights Are Never Updated:**
Even when votes are extended via `ExtendVoterWelfareProfits()`, the `FixProfitDetail` method only updates period information, NOT the shares. The cloned profit detail retains the original shares value. [4](#0-3) [5](#0-4) 

**Reward Distribution Impact:**
Profit distribution uses the proportional formula where voters with higher shares receive proportionally more rewards, even if rate changes should have equalized their weights. [6](#0-5) 

## Impact Explanation

**Direct Reward Misallocation:**
- Early voters who locked in higher interest rates maintain permanently inflated profit shares
- Later voters with identical voting parameters (amount, duration) receive reduced shares and rewards
- The disparity persists for entire lock periods (potentially years)

**Quantified Example:**
1. User A votes 100 tokens for 365 days when interest rate produces weight = 200
2. Governance lowers interest rates via `SetVoteWeightInterest`
3. User B votes 100 tokens for 365 days, now receives weight = 150
4. User A receives 200/(200+150) = 57.1% of welfare rewards
5. User B receives 150/(200+150) = 42.9% of welfare rewards
6. **User A gets 33% more rewards despite identical voting parameters**

**Affected Parties:**
- All voters participating in election governance rewards
- New voters are systematically disadvantaged after rate decreases
- Protocol fairness and economic incentive alignment compromised

This violates the core invariant of fair profit distribution based on voting parameters.

## Likelihood Explanation

**Highly Practical:**
- **Entry Point**: Public `Vote()` method accessible to all users
- **Trigger**: Governance-controlled `SetVoteWeightInterest()` (legitimate governance action)
- **Attacker Capabilities**: None required beyond normal voting rights
- **No Special Preconditions**: Works with any interest rate decrease

**Exploit Scenarios:**

*Scenario 1 - Malicious Governance:*
Malicious controller and allies vote early to lock in high weights, then execute `SetVoteWeightInterest` to lower rates, ensuring competitors receive permanently reduced weights.

*Scenario 2 - Front-Running:*
Sophisticated voters monitor governance proposals and front-run rate decreases, maintaining inflated weights while regular users unknowingly receive worse terms.

*Scenario 3 - Natural Occurrence:*
Governance legitimately adjusts rates for economic reasons, and unfairness emerges without malicious intent as early voters accidentally maintain advantageous weights.

**Detection Difficulty:**
The weight disparity is not visible on-chain without comparing historical interest rates to current vote weights, making it unlikely users detect the unfairness.

## Recommendation

Implement a mechanism to recalculate and update existing vote shares when interest rates change:

1. **Option A - Batch Update on Rate Change:**
   Modify `SetVoteWeightInterest()` to iterate through active votes and recalculate their shares using the new rates.

2. **Option B - Lazy Update on Claim:**
   Recalculate shares dynamically when users claim profits, using the current interest rate configuration rather than stored shares.

3. **Option C - Rate Change Restrictions:**
   Only allow interest rate increases (never decreases) to prevent existing voters from being disadvantaged, or implement a grace period where old rates continue to apply for existing votes.

The recommended approach is Option A with careful gas optimization, as it ensures immediate fairness across all voters while maintaining transparent on-chain state.

## Proof of Concept

```csharp
[Fact]
public async Task VoteWeightInequalityAfterInterestRateChange_Test()
{
    // Setup: Announce candidate and initialize
    var candidate = ValidationDataCenterKeyPairs.First();
    await AnnounceElectionAsync(candidate);
    
    // Step 1: User A votes with current high interest rates
    const long voteAmount = 100_00000000;
    const int lockDays = 365;
    var userA = VoterKeyPairs[0];
    var userAStub = GetElectionContractTester(userA);
    
    var endTimestamp = BlockTimeProvider.GetBlockTime().AddDays(lockDays);
    var voteAResult = await userAStub.Vote.SendAsync(new VoteMinerInput
    {
        CandidatePubkey = candidate.PublicKey.ToHex(),
        Amount = voteAmount,
        EndTimestamp = endTimestamp
    });
    var voteIdA = voteAResult.Output;
    
    // Get User A's initial weight
    var weightA = await ElectionContractStub.GetCalculateVoteWeight.CallAsync(
        new VoteInformation { Amount = voteAmount, LockTime = lockDays * 86400 });
    
    // Step 2: Governance lowers interest rates
    await ParliamentReachAnAgreementAsync(new CreateProposalInput
    {
        ToAddress = ElectionContractAddress,
        Params = new VoteWeightInterestList
        {
            VoteWeightInterestInfos =
            {
                new VoteWeightInterest { Day = 365, Interest = 1, Capital = 2000 } // Halved
            }
        }.ToByteString(),
        OrganizationAddress = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty()),
        ContractMethodName = nameof(ElectionContractStub.SetVoteWeightInterest),
        ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
    });
    
    // Step 3: User B votes with same parameters after rate change
    var userB = VoterKeyPairs[1];
    var userBStub = GetElectionContractTester(userB);
    
    var voteBResult = await userBStub.Vote.SendAsync(new VoteMinerInput
    {
        CandidatePubkey = candidate.PublicKey.ToHex(),
        Amount = voteAmount,
        EndTimestamp = endTimestamp
    });
    var voteIdB = voteBResult.Output;
    
    // Get User B's weight (should be lower due to new rates)
    var weightB = await ElectionContractStub.GetCalculateVoteWeight.CallAsync(
        new VoteInformation { Amount = voteAmount, LockTime = lockDays * 86400 });
    
    // Step 4: Verify inequality - User A has higher weight despite identical parameters
    weightA.Value.ShouldBeGreaterThan(weightB.Value);
    
    // Step 5: Distribute profits and verify User A receives disproportionate rewards
    var welfareHash = ProfitItemsIds[ProfitType.CitizenWelfare];
    await TreasuryContractStub.Donate.SendAsync(new DonateInput
    {
        Symbol = "ELF",
        Amount = 1000_00000000
    });
    
    BlockTimeProvider.SetBlockTime(endTimestamp.AddDays(1));
    await TreasuryContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = welfareHash,
        Period = 1
    });
    
    // Get profit details to verify User A's shares are permanently higher
    var detailsA = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = welfareHash,
        Beneficiary = Address.FromPublicKey(userA.PublicKey)
    });
    
    var detailsB = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = welfareHash,
        Beneficiary = Address.FromPublicKey(userB.PublicKey)
    });
    
    // User A's shares should be approximately double User B's despite identical vote parameters
    detailsA.Details[0].Shares.ShouldBeGreaterThan(detailsB.Details[0].Shares);
    var ratio = (decimal)detailsA.Details[0].Shares / detailsB.Details[0].Shares;
    ratio.ShouldBeGreaterThan(1.5m); // At least 50% more rewards for User A
}
```

**Notes:**
The vulnerability is confirmed through code analysis. The view method `TransferVotingRecordToElectionVotingRecord` recalculates weights for display purposes but this recalculated weight is never stored back into the profit contract. [7](#0-6) 

The profit distribution mechanism correctly implements proportional sharing, but the underlying shares data becomes stale when interest rates change, violating the fairness invariant that equal voting parameters should yield equal rewards.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-160)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }

        var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L189-208)
```csharp
    public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
        // ReSharper disable once PossibleNullReferenceException
        foreach (var info in input.VoteWeightInterestInfos)
        {
            Assert(info.Capital > 0, "invalid input");
            Assert(info.Day > 0, "invalid input");
            Assert(info.Interest > 0, "invalid input");
        }

        Assert(input.VoteWeightInterestInfos.GroupBy(x => x.Day).Count() == input.VoteWeightInterestInfos.Count,
            "repeat day input");
        var orderList = input.VoteWeightInterestInfos.OrderBy(x => x.Day).ToArray();
        input.VoteWeightInterestInfos.Clear();
        input.VoteWeightInterestInfos.AddRange(orderList);
        State.VoteWeightInterestList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L337-355)
```csharp
    private ElectionVotingRecord TransferVotingRecordToElectionVotingRecord(VotingRecord votingRecord, Hash voteId)
    {
        var lockSeconds = State.LockTimeMap[voteId];
        return new ElectionVotingRecord
        {
            Voter = votingRecord.Voter,
            Candidate = GetNewestPubkey(votingRecord.Option),
            Amount = votingRecord.Amount,
            TermNumber = votingRecord.SnapshotNumber,
            VoteId = voteId,
            LockTime = lockSeconds,
            VoteTimestamp = votingRecord.VoteTimestamp,
            WithdrawTimestamp = votingRecord.WithdrawTimestamp,
            UnlockTimestamp = votingRecord.VoteTimestamp.AddSeconds(lockSeconds),
            IsWithdrawn = votingRecord.IsWithdrawn,
            Weight = GetVotesWeight(votingRecord.Amount, lockSeconds),
            IsChangeTarget = votingRecord.IsChangeTarget
        };
    }
```
