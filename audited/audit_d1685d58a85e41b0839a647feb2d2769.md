### Title
Missing Validation of OutValue and Signature Integrity Allows Mining Order Manipulation

### Summary
The UpdateValueValidationProvider fails to validate that the OutValue equals Hash(InValue) and that the Signature is correctly calculated. Miners can provide arbitrary OutValue and Signature values without cryptographic validation, allowing them to manipulate their mining order in subsequent rounds and gain unfair advantages in block production and rewards.

### Finding Description

The validation logic in UpdateValueValidationProvider contains a critical gap that allows miners to submit arbitrary consensus values without cryptographic verification. [1](#0-0) 

The NewConsensusInformationFilled function only checks that OutValue and Signature exist (not null and not empty), but does NOT validate that:
- OutValue = Hash(InValue) 
- Signature is correctly calculated from InValue and previous round signatures [2](#0-1) 

The ValidatePreviousInValue function validates that Hash(PreviousInValue) equals the previous round's OutValue, but explicitly allows miners to skip this check by setting PreviousInValue to Hash.Empty (line 46 returns true). [3](#0-2) 

The processing logic explicitly permits miners to not reveal their InValues, with no penalties applied. [4](#0-3) 

The arbitrary Signature value directly determines the miner's SupposedOrderOfNextRound and FinalOrderOfNextRound through modulo arithmetic (lines 19-21, 42-44). This mining order controls when miners produce blocks in the next round.

### Impact Explanation

**Consensus Integrity Violation:**
A malicious miner can manipulate mining order by:
1. Providing a crafted Signature value that produces their desired next-round position via modulo calculation
2. Setting arbitrary OutValue without any InValue constraint
3. Avoiding validation by not revealing PreviousInValue in the next round

**Direct Consequences:**
- **Unfair Mining Advantage**: Attackers can choose favorable positions in mining rotation, increasing their block production frequency
- **Reward Misallocation**: Manipulated mining order leads to unfair distribution of block rewards and transaction fees
- **Extra Block Producer Manipulation**: The first miner's signature determines extra block producer selection, allowing influence over who produces bonus blocks [5](#0-4) 

**Affected Parties:**
- Honest miners receive reduced block production opportunities and rewards
- Token holders suffer from unfair validator behavior
- Overall consensus fairness and unpredictability are compromised

### Likelihood Explanation

**Reachable Entry Point:** [6](#0-5) 

The UpdateValue method is a public entry point that any authorized miner can call during their time slot.

**Attacker Capabilities:**
- Must be an authorized miner (but this is not a privileged admin role)
- Can craft UpdateValueInput with arbitrary OutValue and Signature values
- No special cryptographic knowledge required beyond understanding modulo arithmetic

**Attack Complexity:**
1. Calculate desired next-round position
2. Reverse engineer Signature value: `signature = (desiredOrder - 1) * k + randomOffset` where k relates to miner count
3. Submit UpdateValueInput with crafted Signature and arbitrary OutValue
4. In next round, set PreviousInValue = Hash.Empty to avoid validation

**Detection Difficulty:**
The attack leaves no obvious traces since:
- Values pass all existing validation checks
- PreviousInValue = Hash.Empty is explicitly permitted
- No logging or monitoring flags the manipulation

**Economic Rationality:**
- Attack cost: negligible (just computation to craft values)
- Attack benefit: increased block rewards and transaction fees
- Risk: low, as behavior appears compliant with validation rules

### Recommendation

**Immediate Fix - Add Cryptographic Validation:**

In UpdateValueValidationProvider.ValidateHeaderInformation, add validation that:

1. **Enforce InValue Revelation**: Require miners to reveal their InValue from the current round in the next round's UpdateValueInput. Modify the protobuf to include `current_in_value` field.

2. **Validate OutValue Integrity**: When InValue is revealed in the subsequent round, verify:
```
Hash(revealed_current_in_value) == stored_out_value_from_previous_round
```

3. **Validate Signature Calculation**: When PreviousInValue is revealed, verify:
```
provided_signature == CalculateSignature(previous_in_value, previous_round_signatures)
```

4. **Remove Hash.Empty Bypass**: Change line 46 to require proper PreviousInValue revelation:
```csharp
if (previousInValue == Hash.Empty) return false; // Reject instead of allowing
```

**Alternative - Delayed Validation Approach:**

Track OutValue/Signature pairs and validate them one round later when InValues are revealed:
- Store (OutValue, Signature, RoundNumber) when submitted
- In next round, when miner reveals InValue, validate stored values
- Penalize miners who fail validation (reduce rewards, increase missed time slots)

**Test Cases:**
1. Submit UpdateValue with OutValue â‰  Hash(InValue), verify rejection
2. Submit UpdateValue with incorrect Signature, verify rejection  
3. Submit PreviousInValue = Hash.Empty, verify rejection
4. Submit valid values, verify acceptance
5. Test that InValue revelation in round N+1 correctly validates OutValue from round N

### Proof of Concept

**Initial State:**
- Attacker is authorized miner with pubkey "AttackerPubkey"
- Current round is Round N
- Attacker's current Order in Round N is 5
- Attacker wants Order 1 in Round N+1

**Attack Sequence:**

**Step 1 - Round N Block Production:**
Attacker calls UpdateValue with crafted input:
```
UpdateValueInput {
  out_value: Hash("arbitrary_value_X")  // NOT Hash of any real InValue
  signature: Hash("crafted_for_order_1")  // Crafted to yield (sigNum % minerCount) + 1 = 1
  previous_in_value: Hash("some_valid_previous")  // Valid from Round N-1
  round_id: [current_round_id]
  actual_mining_time: [current_time]
  ...
}
```

**Expected Result:** Validation should REJECT due to OutValue not being Hash of valid InValue.

**Actual Result:** [7](#0-6) 

Validation PASSES because UpdateValueValidationProvider only checks existence (lines 13-14, 16-17), not cryptographic correctness.

**Step 2 - Round N+1 Block Production:**
Attacker sets `previous_in_value = Hash.Empty` to avoid revealing that Round N's OutValue was bogus. [8](#0-7) 

Validation PASSES due to Hash.Empty bypass on line 46.

**Step 3 - Order Calculation:** [9](#0-8) 

The crafted Signature yields attacker's desired order 1 in Round N+1 via modulo arithmetic.

**Success Condition:**
Attacker achieves Order 1 in Round N+1 through Signature manipulation without any InValue constraint, gaining unfair mining advantage and increased block rewards.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-44)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-122)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
```

**File:** protobuf/aedpos_contract.proto (L29-31)
```text
    // Update consensus information.
    rpc UpdateValue (UpdateValueInput) returns (google.protobuf.Empty) {
    }
```
