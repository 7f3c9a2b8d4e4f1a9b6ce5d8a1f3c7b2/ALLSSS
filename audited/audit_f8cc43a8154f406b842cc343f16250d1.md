### Title
Seed NFT Expiration Time Overflow Enables Permanent Symbol Monopolization

### Summary
The `ExtendSeedExpirationTime` method allows seed NFT owners to set expiration times to extreme values like `long.MaxValue` without validation. This causes expiration checks to always pass, preventing expired seeds from being replaced and enabling permanent monopolization of valuable symbol namespaces.

### Finding Description

**Root Cause:**
The `ExtendSeedExpirationTime` method accepts arbitrary expiration time values without any bounds validation or reasonableness checks. [1](#0-0) 

At lines 711-712, the expiration time from user input is stored directly without validating that it represents a reasonable future timestamp or checking for overflow values.

**Expiration Check Vulnerability:**
When creating a new seed NFT for a symbol, the system validates whether an existing seed has expired through `CheckSymbolSeed`: [2](#0-1) 

The assertion at line 65 checks `Context.CurrentBlockTime.Seconds > symbolSeedExpireTime`. If the expiration time is set to `long.MaxValue` (9,223,372,036,854,775,807 seconds â‰ˆ year 292,277,026,596), this condition will never be satisfied in any realistic timeframe, preventing new seeds from being created for that symbol.

**Usage Path:**
The expiration check is also enforced during token creation when using a seed: [3](#0-2) 

At line 45, the check `Context.CurrentBlockTime.Seconds <= expirationTimeLong` ensures the seed hasn't expired when being used. With `long.MaxValue`, this check always passes, allowing indefinite seed validity.

### Impact Explanation

**Operational Denial of Service:**
- Attackers can permanently monopolize valuable symbol namespaces by setting seed expiration times to `long.MaxValue`
- Legitimate users are permanently blocked from creating new seeds for those symbols, even if the attacker never uses them
- The symbol namespace becomes fragmented with indefinitely reserved but potentially unused symbols
- No administrative override mechanism exists to force-expire or reclaim monopolized symbols

**Affected Parties:**
- Protocol users who want to create tokens with specific, desirable symbol names
- The broader ecosystem suffers from symbol namespace pollution and unavailability

**Severity Justification:**
While this doesn't result in direct fund theft, it constitutes a permanent denial of service attack on a critical protocol resource (symbol namespace). The attack is irreversible without contract upgrades and can be executed at minimal cost.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must own a seed NFT (can be acquired through creation or secondary market purchase)
- Only requires ability to call the public `ExtendSeedExpirationTime` method
- No special privileges or elevated permissions needed

**Attack Complexity:**
- Extremely simple: single transaction calling `ExtendSeedExpirationTime` with `input.ExpirationTime = 9223372036854775807L`
- No complex state manipulation or timing requirements
- No economic barriers beyond acquiring the initial seed NFT

**Feasibility Conditions:**
- The vulnerability is always exploitable for any seed owner
- Attack is undetectable until someone attempts to create a new seed for the monopolized symbol
- No rate limiting or cooldown periods exist

**Economic Rationality:**
- Attack cost: minimal (transaction fee + seed acquisition cost)
- Potential value: high for desirable/valuable symbol names
- Rational strategy for symbol squatting or competitive advantage

### Recommendation

**Immediate Mitigation:**
Add validation in `ExtendSeedExpirationTime` to enforce reasonable expiration time bounds:

```csharp
public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
{
    var tokenInfo = GetTokenInfo(input.Symbol);
    Assert(tokenInfo != null, "Seed NFT does not exist.");
    Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
    
    // Add validation for reasonable expiration time
    var maxAllowedExpiration = Context.CurrentBlockTime.Seconds + 
        TokenContractConstants.MaxSeedExpirationDuration; // e.g., 365 days
    Assert(input.ExpirationTime <= maxAllowedExpiration, 
        "Expiration time exceeds maximum allowed duration.");
    Assert(input.ExpirationTime > Context.CurrentBlockTime.Seconds,
        "Expiration time must be in the future.");
    
    // Existing code continues...
}
```

**Additional Invariant Checks:**
1. Define `MaxSeedExpirationDuration` constant (e.g., 31,536,000 seconds = 1 year)
2. Add validation during initial seed creation to prevent overflow values from the start
3. Consider adding a governance-controlled mechanism to force-expire abandoned seeds after extended periods

**Regression Prevention:**
Add test cases validating:
- Rejection of `long.MaxValue` expiration times
- Rejection of expiration times exceeding the maximum allowed duration
- Proper enforcement of maximum duration limits
- Verification that expired seeds can be replaced after maximum duration passes

### Proof of Concept

**Initial State:**
- User A owns seed NFT `SEED-1` for symbol `PREMIUM` with expiration time of `1700000000` (current time + 1 day)
- `State.SymbolSeedMap["PREMIUM"] = "SEED-1"`

**Attack Sequence:**

1. **User A extends expiration to overflow value:**
   ```
   ExtendSeedExpirationTime({
     Symbol: "SEED-1",
     ExpirationTime: 9223372036854775807 // long.MaxValue
   })
   ```
   - Transaction succeeds
   - `SEED-1` expiration time updated to `long.MaxValue`

2. **User B attempts to create new seed for expired symbol (days later):**
   ```
   CreateNFTInfo({
     Symbol: "SEED-2",
     ExternalInfo: {
       "__seed_owned_symbol": "PREMIUM",
       "__seed_exp_time": "1700086400" // current time
     }
   })
   ```
   - Calls `CheckSymbolSeed("PREMIUM")`
   - Checks `Context.CurrentBlockTime.Seconds > 9223372036854775807`
   - Condition is `false` (current time ~1.7e9 vs long.MaxValue 9.2e18)
   - Transaction reverts with "OwnedSymbol has been created"

**Expected Result:**
After User A's seed expires (after 1 day from initial creation), User B should be able to create a new seed for "PREMIUM"

**Actual Result:**
User B can never create a new seed for "PREMIUM" because the expiration check never passes, permanently monopolizing the symbol namespace

**Success Condition:**
The attack succeeds when `CheckSymbolSeed` permanently blocks new seed creation due to the overflow expiration time never being exceeded by current block time.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L695-722)
```csharp
    public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo == null)
        {
            throw new AssertionException("Seed NFT does not exist.");
        }

        Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
        var oldExpireTimeLong = 0L;
        if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                out var oldExpireTime))
        {
            long.TryParse(oldExpireTime, out oldExpireTimeLong);
        }

        tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
            input.ExpirationTime.ToString();
        State.TokenInfos[input.Symbol] = tokenInfo;
        Context.Fire(new SeedExpirationTimeUpdated
        {
            ChainId = tokenInfo.IssueChainId,
            Symbol = input.Symbol,
            OldExpirationTime = oldExpireTimeLong,
            NewExpirationTime = input.ExpirationTime
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L42-45)
```csharp
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var expirationTime)
                   && long.TryParse(expirationTime, out var expirationTimeLong) &&
                   Context.CurrentBlockTime.Seconds <= expirationTimeLong, "Invalid ownedSymbol.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L57-67)
```csharp
    private void CheckSymbolSeed(string ownedSymbol)
    {
        var oldSymbolSeed = State.SymbolSeedMap[ownedSymbol.ToUpper()];

        Assert(oldSymbolSeed == null || !GetTokenInfo(oldSymbolSeed).ExternalInfo.Value
                   .TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var oldSymbolSeedExpireTime) ||
               !long.TryParse(oldSymbolSeedExpireTime, out var symbolSeedExpireTime)
               || Context.CurrentBlockTime.Seconds > symbolSeedExpireTime,
            "OwnedSymbol has been created");
    }
```
