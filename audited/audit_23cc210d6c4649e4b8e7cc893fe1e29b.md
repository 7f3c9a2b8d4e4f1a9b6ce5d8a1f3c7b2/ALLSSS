# Audit Report

## Title
Sponsor Funds Misdirected to Wrong Address After Pubkey Replacement for Self-Announced Candidates

## Summary
When a candidate announces their candidacy via `AnnounceElection`, the `CandidateSponsorMap` is not set, leaving it null. If the candidate's public key is subsequently replaced via `ReplaceCandidatePubkey`, this null sponsor mapping is transferred to the new public key. Upon calling `QuitElection`, the locked 100,000 ELF tokens are sent to the address derived from the **new** public key instead of the original candidate's address that paid for them, resulting in permanent fund misdirection.

## Finding Description

The vulnerability arises from incorrect state management across three interacting functions in the Election contract:

**Step 1: Token Lock Without Sponsor Recording**

When a candidate calls `AnnounceElection`, tokens are locked from `Context.Sender` (the transaction signer's address). [1](#0-0) 

However, unlike `AnnounceElectionFor`, the `AnnounceElection` method does NOT set `CandidateSponsorMap` for the candidate. [2](#0-1) 

In contrast, `AnnounceElectionFor` explicitly records the sponsor: [3](#0-2) 

**Step 2: Null Sponsor Mapping Transferred During Replacement**

When `ReplaceCandidatePubkey` is executed, it transfers the sponsor mapping from the old public key to the new one. If the original mapping was null, the new mapping also becomes null: [4](#0-3) 

The `CandidateInformation` containing the original `AnnouncementTransactionId` (which identifies the locked tokens) is also transferred: [5](#0-4) 

**Step 3: Tokens Sent to Wrong Address**

When `QuitElection` is called using the new public key, it retrieves the tokens using the original `AnnouncementTransactionId` but sends them to a fallback address when the sponsor is null: [6](#0-5) 

The critical issue is that `pubkeyBytes` on line 231 is derived from `input.Value` (the current/new public key), not the original public key. When the sponsor map is null, tokens are sent to `Address.FromPublicKey(pubkeyBytes)` where `pubkeyBytes` represents the **new** public key, not the original candidate's public key.

**Root Cause**

The fallback logic `State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes)` assumes that when no sponsor exists, the tokens should go to the address derived from the current public key. This assumption is valid for candidates who never had their public key replaced, but breaks after replacement because:
- Tokens were locked from Address A (derived from original pubkey A)
- After replacement, tokens are returned to Address B (derived from new pubkey B)
- Address A â‰  Address B (different public keys generate different addresses)

## Impact Explanation

**Direct Financial Loss:**
- The original candidate loses 100,000 ELF tokens (the value of `ElectionContractConstants.LockTokenForElection`). [7](#0-6) 
- The new public key holder receives 100,000 ELF they never deposited
- This represents direct fund theft through state management failure

**Affected Users:**
- Any candidate who announced via `AnnounceElection` (self-announcement) and subsequently replaced their public key
- Common scenarios include initial miners or long-term candidates performing legitimate key rotation for security or operational reasons

**Severity: HIGH**
1. Guaranteed fund loss of significant amount (100,000 ELF = 1,000,000,000,000 in contract units)
2. Violates fundamental custody invariant: funds locked by Address A should return to Address A
3. No validation or warning prevents this scenario
4. Existing test suite has coverage gap - tests verify admin permissions but not token destinations after pubkey replacement [8](#0-7) 

## Likelihood Explanation

**Attack Prerequisites:**
- Attacker must be or control the candidate admin for a candidate who used `AnnounceElection`
- Admin authority is a legitimate role (set during candidate registration), not a privilege escalation

**Attack Complexity: LOW**
Three standard contract operations in sequence:
1. Candidate announces election via `AnnounceElection` (normal operation)
2. Admin calls `ReplaceCandidatePubkey` with attacker-controlled new public key (legitimate use case for key rotation)
3. Admin calls `QuitElection` to withdraw funds to attacker's address

**Feasibility: HIGH**
- Public key replacement is a legitimate operational requirement (key rotation, node migration, security hardening)
- Initial miners and many candidates use the `AnnounceElection` path rather than having a separate sponsor
- No contract validation prevents this sequence of operations
- The attack appears as normal administrative operations

**Economic Rationality:**
Highly profitable - attacker gains 100,000 ELF with only admin authority, which may be legitimately held or obtained through social engineering of a less-secure admin account.

**Detection Difficulty:**
The operations appear completely normal in transaction logs. The original candidate may not immediately notice the loss if they don't actively monitor balances, making this difficult to detect until after the fact.

## Recommendation

Add a check in `ReplaceCandidatePubkey` to preserve the original funding source when no sponsor exists. The sponsor mapping should be set to the original candidate's address if it's currently null:

```csharp
// In ReplaceCandidatePubkey, after line 319:
if (State.CandidateSponsorMap[input.OldPubkey] == null)
{
    // If no sponsor was set (AnnounceElection path), record the original candidate's address
    State.CandidateSponsorMap[input.NewPubkey] = Address.FromPublicKey(
        ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
}
else
{
    State.CandidateSponsorMap[input.NewPubkey] = State.CandidateSponsorMap[input.OldPubkey];
}
State.CandidateSponsorMap.Remove(input.OldPubkey);
```

Alternatively, modify `QuitElection` to track the original funding address separately from the sponsor concept, or store the original candidate address in `CandidateInformation` during announcement.

## Proof of Concept

```csharp
[Fact]
public async Task ElectionContract_ReplaceCandidatePubkey_FundMisdirection_Test()
{
    // Setup: Two different keypairs representing original candidate and new pubkey holder
    var aliceKeyPair = ValidationDataCenterKeyPairs[0]; // Original candidate
    var bobKeyPair = ValidationDataCenterKeyPairs[1];   // New pubkey holder
    var candidateAdmin = ValidationDataCenterKeyPairs.Last();
    var candidateAdminAddress = Address.FromPublicKey(candidateAdmin.PublicKey);
    
    // Record Alice's initial balance
    var aliceInitialBalance = await GetNativeTokenBalance(aliceKeyPair.PublicKey);
    
    // Alice announces election using AnnounceElection (NOT AnnounceElectionFor)
    // This locks 100,000 ELF from Alice's address but does NOT set CandidateSponsorMap
    await AnnounceElectionAsync(aliceKeyPair, candidateAdminAddress);
    
    // Verify Alice paid the 100,000 ELF deposit
    var aliceBalanceAfterAnnounce = await GetNativeTokenBalance(aliceKeyPair.PublicKey);
    aliceBalanceAfterAnnounce.ShouldBe(aliceInitialBalance - ElectionContractConstants.LockTokenForElection);
    
    // Record Bob's initial balance
    var bobInitialBalance = await GetNativeTokenBalance(bobKeyPair.PublicKey);
    
    // Admin replaces Alice's pubkey with Bob's pubkey (legitimate key rotation scenario)
    var candidateAdminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, candidateAdmin);
    await candidateAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = aliceKeyPair.PublicKey.ToHex(),
        NewPubkey = bobKeyPair.PublicKey.ToHex()
    });
    
    // Admin quits election using Bob's pubkey
    await candidateAdminStub.QuitElection.SendAsync(new StringValue
    {
        Value = bobKeyPair.PublicKey.ToHex()
    });
    
    // Verify the vulnerability: Check final balances
    var aliceFinalBalance = await GetNativeTokenBalance(aliceKeyPair.PublicKey);
    var bobFinalBalance = await GetNativeTokenBalance(bobKeyPair.PublicKey);
    
    // VULNERABILITY DEMONSTRATED:
    // Alice did NOT receive her 100,000 ELF back
    aliceFinalBalance.ShouldBe(aliceBalanceAfterAnnounce); 
    
    // Bob received Alice's 100,000 ELF instead
    bobFinalBalance.ShouldBe(bobInitialBalance + ElectionContractConstants.LockTokenForElection);
}
```

This test demonstrates that 100,000 ELF locked by Alice (Address A) is incorrectly sent to Bob (Address B) after public key replacement, confirming the fund misdirection vulnerability.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L140-140)
```csharp
        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L231-249)
```csharp
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L237-242)
```csharp
        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L320-321)
```csharp
        State.CandidateSponsorMap[newPubkey] = State.CandidateSponsorMap[oldPubkey];
        State.CandidateSponsorMap.Remove(oldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ReplaceCandidateTests.cs (L14-86)
```csharp
    public async Task ElectionContract_ReplaceCandidatePubkey_Test()
    {
        var announceElectionKeyPair = ValidationDataCenterKeyPairs.First();
        var candidateAdmin = ValidationDataCenterKeyPairs.Last();
        var candidateAdminAddress = Address.FromPublicKey(candidateAdmin.PublicKey);
        await AnnounceElectionAsync(announceElectionKeyPair, candidateAdminAddress);

        // Check candidate admin
        {
            var admin = await ElectionContractStub.GetCandidateAdmin.CallAsync(new StringValue
                { Value = announceElectionKeyPair.PublicKey.ToHex() });
            admin.ShouldBe(candidateAdminAddress);
        }

        // Check candidates.
        {
            var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
            candidates.Value.ShouldContain(ByteString.CopyFrom(announceElectionKeyPair.PublicKey));
        }

        var candidateAdminStub =
            GetTester<ElectionContractImplContainer.ElectionContractImplStub>(ElectionContractAddress,
                candidateAdmin);
        var newKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
        await candidateAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
        {
            OldPubkey = announceElectionKeyPair.PublicKey.ToHex(),
            NewPubkey = newKeyPair.PublicKey.ToHex()
        });

        // Check candidates again.
        {
            var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
            candidates.Value.ShouldContain(ByteString.CopyFrom(newKeyPair.PublicKey));
            candidates.Value.ShouldNotContain(ByteString.CopyFrom(announceElectionKeyPair.PublicKey));
        }

        // Check candidate information
        {
            var oldCandidateInformation =
                await ElectionContractStub.GetCandidateInformation.CallAsync(new StringValue
                    { Value = announceElectionKeyPair.PublicKey.ToHex() });
            oldCandidateInformation.IsCurrentCandidate.ShouldBeFalse();
            var newPubkeyInformation =
                await ElectionContractStub.GetCandidateInformation.CallAsync(new StringValue
                    { Value = newKeyPair.PublicKey.ToHex() });
            newPubkeyInformation.IsCurrentCandidate.ShouldBeTrue();
        }

        // Two pubkeys cannot quit election.
        {
            var stub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(ElectionContractAddress,
                announceElectionKeyPair);
            var result = await stub.QuitElection.SendAsync(new StringValue { Value = newKeyPair.PublicKey.ToHex() });
            result.TransactionResult.Error.ShouldContain("Only admin can quit election.");
        }
        {
            var stub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(ElectionContractAddress,
                newKeyPair);
            var result = await stub.QuitElection.SendAsync(new StringValue { Value = newKeyPair.PublicKey.ToHex() });
            result.TransactionResult.Error.ShouldContain("Only admin can quit election.");
        }

        // Only admin can quit election.
        {
            await candidateAdminStub.QuitElection.SendAsync(new StringValue
            {
                Value = newKeyPair.PublicKey.ToHex()
            });
            var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
            candidates.Value.ShouldNotContain(ByteString.CopyFrom(newKeyPair.PublicKey));
        }
    }
```
