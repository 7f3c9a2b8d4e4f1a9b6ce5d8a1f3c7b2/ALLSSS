### Title
Missing Validation of Proposal Params Enables Governance DoS and Resource Waste

### Summary
The Association contract's `Validate(ProposalInfo)` method does not validate the length or content of the `params` field, despite validating other proposal fields like title, description, and URL. This allows whitelisted proposers to create proposals with arbitrarily large (up to ~128KB due to state limits) or malformed parameter data, causing governance denial-of-service, wasted voting processes, and excessive resource consumption.

### Finding Description

The validation logic for proposals is split across two methods in the Association contract: [1](#0-0) 

The `Validate(ProposalInfo)` method only checks that `ToAddress` is not null, `ContractMethodName` is not empty, the `ProposalDescriptionUrl` has a valid scheme, and the proposal is not expired. **Critically, it never validates the `params` field.** [2](#0-1) 

The `CheckCreateProposalInput` method validates the length of `Title`, `Description`, and `ProposalDescriptionUrl` against defined constants: [3](#0-2) 

However, **no corresponding constant or check exists for `params`**. [4](#0-3) 

In `CreateNewProposal`, the params are directly copied from input without any validation at line 153. The proposal is then validated and stored in state at line 164. [5](#0-4) 

The `params` field is defined as `bytes` in the protobuf definition, allowing arbitrary binary data of any size. [6](#0-5) 

While AElf enforces a 128KB state size limit, this still permits proposals with params far exceeding what most contract methods require. [7](#0-6) 

When a proposal is released, the unchecked params are passed directly to `SendVirtualInlineBySystemContract` at lines 189-191, where they will be used to invoke the target contract method.

### Impact Explanation

**Operational DoS of Governance Infrastructure:**
- Organization members attempting to vote on proposals with oversized params (e.g., 100KB+) must load the entire proposal from state, significantly increasing gas costs and potentially making voting economically impractical
- Proposals with malformed params that don't match the target method's expected input will pass through the entire governance process (creation, voting, threshold checks) only to fail when `Release` is called, wasting all participants' time, effort, and gas
- Repeated creation of such proposals can render governance unusable

**Resource Waste:**
- State bloat: Unnecessary large params consume valuable on-chain storage
- Gas inflation: All operations that load the proposal (voting, querying, clearing) pay for processing oversized data
- Network inefficiency: Large transactions consume more bandwidth and processing time

**Griefing Attack Vector:**
- A malicious whitelisted proposer can systematically create invalid proposals to delay legitimate governance actions
- Can target specific organizations to disrupt their operations
- Cost to attacker (storage fees) may be justified by damage to governance credibility

**Severity: High** - Governance is critical protocol infrastructure. Compromising its reliability and efficiency threatens the protocol's ability to upgrade, respond to emergencies, and maintain decentralized control.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be in the organization's proposer whitelist, which is a moderate barrier but not unrealistic. Proposers are governance participants, not trusted administrators, and organizations may have multiple proposers for operational reasons
- Once whitelisted, execution is trivialâ€”simply submit a `CreateProposal` transaction with oversized or malformed params

**Attack Complexity: Low**
- No complex exploit techniques required
- No need to time attacks or coordinate multiple transactions
- Simple parameter manipulation in a standard governance flow

**Feasibility Conditions:**
- **Always feasible** once proposer whitelist access is obtained
- No dependence on market conditions, protocol state, or external factors
- Can be repeated arbitrarily

**Detection/Operational Constraints:**
- Other organization members might notice unusually large proposals, but:
  - The contract provides no mechanism to reject proposals pre-emptively based on params
  - Voting still incurs costs even if members plan to reject
  - Expired proposals persist until manually cleared, continuing to bloat state

**Economic Rationality:**
- While the attacker pays storage costs, the multiplied cost to all voters and the disruption to governance operations can justify the attack for motivated adversaries (competitors, malicious actors, disgruntled members)

**Probability: Moderate to High** - The combination of low execution complexity and potential high impact makes this a practical attack vector that is likely to be discovered and exploited.

### Recommendation

**Add Params Length Validation:**

1. Add a new constant to `AssociationConstants.cs`:
```csharp
public const int MaxLengthForParams = 4096; // 4KB reasonable limit
```

2. Modify `CheckCreateProposalInput` in `Association_Helper.cs` to include:
```csharp
Assert(input.Params.Length <= AssociationConstants.MaxLengthForParams, 
    "Params is too long.");
```

3. Optionally add format validation in `Validate(ProposalInfo)` to check if params can be deserialized for the target method (though this may be complex and gas-intensive).

**Invariant to Enforce:**
- `proposal.Params.Length <= MaxLengthForParams` must hold for all stored proposals
- The limit should be chosen based on the maximum reasonable parameter size for governance actions (typically a few KB)

**Test Cases:**
1. Attempt to create proposal with params exceeding limit (should fail)
2. Create proposal with params at exactly the limit (should succeed)
3. Create proposal with valid params under limit (should succeed and release successfully)
4. Attempt to create proposal with malformed params and verify behavior

**Apply to All Governance Contracts:**
This issue also affects Parliament and Referendum contracts: [8](#0-7) [9](#0-8) 

All governance contracts should implement consistent params validation.

### Proof of Concept

**Initial State:**
- Organization exists with proposer whitelist containing attacker's address
- Organization has multiple legitimate members who participate in governance

**Attack Sequence:**

1. **Create Oversized Proposal:**
   - Attacker (whitelisted proposer) calls `CreateProposal` with:
     - Valid `ToAddress` and `ContractMethodName`
     - `Params` filled with 120KB of arbitrary data (near state limit)
     - Valid `ExpiredTime`
   - Transaction succeeds, proposal is stored in state

2. **Legitimate Members Attempt to Vote:**
   - Member A calls `Approve(proposalId)`
   - Transaction must load 120KB proposal from state
   - Gas cost is orders of magnitude higher than normal proposals
   - Member pays excessive fees for voting

3. **Alternative: Malformed Params Attack:**
   - Attacker creates proposal with:
     - `ToAddress` pointing to MultiToken contract
     - `ContractMethodName` = "Transfer"
     - `Params` containing malformed data that cannot deserialize to `TransferInput`
   - Proposal goes through voting process successfully
   - When `Release` is called:
     - `SendVirtualInlineBySystemContract` attempts to invoke Transfer with malformed params
     - Deserialization fails or method rejects invalid input
     - Entire governance process was wasted

**Expected Result:**
- Proposal creation should fail with "Params is too long" or "Invalid params format"

**Actual Result:**
- Proposal creation succeeds
- Governance participants bear the cost of oversized/malformed proposals
- System allows waste of governance resources

**Success Condition:**
- Attacker successfully creates proposal that either makes voting prohibitively expensive OR causes Release to fail after successful voting

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L145-173)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId,
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L175-184)
```csharp
    private void CheckCreateProposalInput(CreateProposalInput input)
    {
        // Check the length of title
        Assert(input.Title.Length <= AssociationConstants.MaxLengthForTitle, "Title is too long.");
        // Check the length of description
        Assert(input.Description.Length <= AssociationConstants.MaxLengthForDescription, "Description is too long.");
        // Check the length of description url
        Assert(input.ProposalDescriptionUrl.Length <= AssociationConstants.MaxLengthForProposalDescriptionUrl,
            "Description url is too long.");
    }
```

**File:** contract/AElf.Contracts.Association/AssociationConstants.cs (L5-7)
```csharp
    public const int MaxLengthForTitle = 255;
    public const int MaxLengthForDescription = 10200;
    public const int MaxLengthForProposalDescriptionUrl = 255;
```

**File:** protobuf/acs3.proto (L78-97)
```text
message CreateProposalInput {
    // The name of the method to call after release.
    string contract_method_name = 1;
    // The address of the contract to call after release.
    aelf.Address to_address = 2;
    // The parameter of the method to be called after the release.
    bytes params = 3;
    // The timestamp at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 4;
    // The address of the organization.
    aelf.Address organization_address = 5;
    // Url is used for proposal describing.
    string proposal_description_url = 6;
    // The token is for proposal id generation and with this token, proposal id can be calculated before proposing.
    aelf.Hash token = 7;
    // Title of this proposal.
    string title = 8;
    // Description of this proposal.
    string description = 9;
}
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L157-166)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = CheckProposalNotExpired(proposal);
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```
