### Title
Insufficient Input Validation Allows Setting Dangerously Low Maximum Miner Count Leading to Network DoS

### Summary
The `SetMaximumMinersCount()` function only validates that `input.Value > 0`, allowing a value of 1 to be set despite the `SupposedMinersCount` being 17. This enables reducing a production multi-miner network to a single miner, causing complete loss of Byzantine fault tolerance and network-wide DoS if that single miner fails.

### Finding Description

The vulnerability exists in the `SetMaximumMinersCount()` function which performs inadequate input validation. [1](#0-0) 

The assertion only checks that the input value is positive but does not validate against a minimum safe threshold. The `SupposedMinersCount` constant is defined as 17, representing the baseline miner count for proper consensus operation. [2](#0-1) 

When `SetMaximumMinersCount(1)` is called, the function immediately updates the Election contract with the new miners count via `GetMinersCount(round)`: [3](#0-2) 

The `GetMinersCount()` function applies `Math.Min()` with the `MaximumMinersCount` value, capping the result at 1: [4](#0-3) 

The Election contract receives this update and stores it: [5](#0-4) 

During the next term transition, `GetVictories()` uses this stored value to select miners, taking only 1 miner regardless of available candidates: [6](#0-5) 

The term transition process then sets this single-miner list as the new consensus miner set: [7](#0-6) 

While single-node mode is intentionally supported for development scenarios, there is no protection against transitioning from a multi-miner production network to single-miner mode. [8](#0-7) 

### Impact Explanation

**Network Centralization and DoS**: Reducing from 17 miners to 1 miner centralizes the entire network to a single node. If that node experiences downtime, network failures, or connectivity issues, the entire blockchain halts as no other nodes can produce blocks.

**Byzantine Fault Tolerance Broken**: The AEDPoS consensus relies on a 2/3 threshold for Byzantine fault tolerance. With only 1 miner, `MinersCountOfConsent` becomes 1, eliminating all redundancy: [9](#0-8) 

**Recovery Difficulty**: Once reduced to a single miner, the network cannot self-recover through normal governance processes if that miner becomes unavailable. Manual intervention would be required to restore multi-miner operation.

**Affected Parties**: All network participants (users, dApps, token holders) would be unable to perform transactions or interact with smart contracts during any downtime of the single miner.

### Likelihood Explanation

**Attacker Capabilities**: The attack requires control of the Parliament organization, which defaults to the default organization address composed of current miners: [10](#0-9) 

**Attack Complexity**: The attack is straightforward once Parliament control is achieved. A single proposal to set `MaximumMinersCount` to 1 would be sufficient: [11](#0-10) 

**Feasibility**: Test cases demonstrate setting values like 3 and 7 (below the supposed count of 17), but no test validates the safety of setting to 1: [12](#0-11) 

**Economic Rationality**: Parliament could be compromised through various attack vectors (collusion, bribery, key compromise), or an honest mistake could occur (e.g., intending to type "10" but entering "1"). The lack of validation provides no safeguard against either scenario.

### Recommendation

Add a minimum bound validation that prevents setting dangerously low miner counts. The fix should:

1. **Add minimum threshold check**: Validate that `input.Value` is at least 3 (minimum for basic BFT) or preferably equal to or greater than `SupposedMinersCount` (17):

```csharp
Assert(input.Value >= AEDPoSContractConstants.SupposedMinersCount, 
    $"Maximum miners count must be at least {AEDPoSContractConstants.SupposedMinersCount}.");
```

2. **Alternative approach**: If values below 17 are intentionally allowed, add a check preventing reduction below current active miner count by more than a safe percentage (e.g., 30%):

```csharp
TryToGetCurrentRoundInformation(out var round);
var currentMinerCount = round.RealTimeMinersInformation.Count;
Assert(input.Value >= currentMinerCount.Mul(70).Div(100), 
    "Cannot reduce maximum miners count by more than 30% of current active miners.");
```

3. **Add comprehensive test cases**: Create tests validating that attempting to set extremely low values (1, 2) is properly rejected, especially when transitioning from a multi-miner configuration.

### Proof of Concept

**Initial State**: 
- Network operating with 17 active miners
- Parliament organization controls `MaximumMinersCountController`

**Attack Steps**:
1. Attacker gains Parliament control (through compromise or as malicious insider)
2. Creates and approves Parliament proposal calling `SetMaximumMinersCount(1)`
3. Proposal is released and executed
4. `State.MaximumMinersCount.Value` is set to 1
5. Election contract's `MinersCount` is updated to 1
6. Wait for next term transition (determined by `PeriodSeconds`)
7. `GetVictories()` selects only 1 miner from all candidates
8. New term begins with single-miner consensus

**Expected Result**: The network should reject values below a safe minimum threshold.

**Actual Result**: The network accepts the value and reduces to a single miner at the next term transition, creating a single point of failure.

**Success Condition**: When the single miner experiences any downtime or network connectivity issues, the entire blockchain halts as no other nodes can produce blocks, constituting a complete network DoS.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L14-14)
```csharp
        Assert(input.Value > 0, "Invalid max miners count.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L17-18)
```csharp
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L22-26)
```csharp
        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L31-43)
```csharp
    private void RequiredMaximumMinersCountControllerSet()
    {
        if (State.MaximumMinersCountController.Value != null) return;
        EnsureParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MaximumMinersCountController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L154-157)
```csharp
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-83)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L176-190)
```csharp
        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L30-35)
```csharp
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L27-29)
```csharp
    [InlineData(7)]
    [InlineData(3)]
    public async Task SetMaximumMinersCountTest(int targetMinersCount)
```
