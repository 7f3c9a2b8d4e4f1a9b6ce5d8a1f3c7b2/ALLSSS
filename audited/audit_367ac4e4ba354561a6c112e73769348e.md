### Title
Unverified Secret Shares Enable Byzantine Corruption of PreviousInValue State for Offline Miners

### Summary
The `RevealSharedInValues()` function and related secret sharing mechanisms accept `DecryptedPieces` without cryptographic verification, allowing malicious miners to submit fake decrypted shares. When these fake shares are used to reconstruct InValues via Shamir's Secret Sharing, the resulting garbage values are assigned as `PreviousInValue` without validation against the committed `OutValue`. This enables Byzantine miners to corrupt the consensus state for miners who fail to produce blocks.

### Finding Description

**Root Cause:**

The secret sharing implementation has a critical verification gap at multiple points:

1. **No Verification of DecryptedPieces on Submission:** [1](#0-0) 

When miners submit `DecryptedPieces` via `PerformSecretSharing()`, these are blindly added to the round state without any cryptographic verification that they correctly decrypt the corresponding `EncryptedPieces`.

2. **No Verification in UpdateLatestSecretPieces:** [2](#0-1) 

The `UpdateLatestSecretPieces()` function accepts `DecryptedPieces` and `RevealedInValues` from trigger information without verification. Critically, at lines 148-152, it sets `PreviousInValue` based on `RevealedInValues` without checking that `hash(revealedInValue) == OutValue`.

3. **Unconditional Assignment in RevealSharedInValues:** [3](#0-2) 

The `RevealSharedInValues()` function collects `DecryptedPieces` and uses `SecretSharingHelper.DecodeSecret()` to reconstruct the InValue. At line 52, it unconditionally assigns the reconstructed value as `PreviousInValue` without verifying it matches the `OutValue` commitment from the previous round.

4. **Off-chain Reconstruction Without Verification:** [4](#0-3) 

The off-chain `SecretSharingService.RevealPreviousInValues()` performs the same reconstruction using unverified `DecryptedPieces` from on-chain state and passes the results to the on-chain contract via trigger information.

**Why Existing Protections Fail:**

While `UpdateValueValidationProvider.ValidatePreviousInValue()` does verify that a miner's self-submitted `PreviousInValue` matches their previous `OutValue`: [5](#0-4) 

This validation only applies to the miner's **own** submission. It does NOT validate reconstructed values set via `RevealedInValues` in `UpdateLatestSecretPieces()`. The condition at line 150-151 only checks if `PreviousInValue` is Empty or null, not whether the value being set is cryptographically valid.

**Execution Path:**

1. Round N-1: Honest Miner A commits `OutValue_A = hash(InValue_A)` and publishes encrypted shares
2. Round N: Byzantine Miner B submits `DecryptedPieces[A] = fake_bytes` instead of correctly decrypting
3. Off-chain: `SecretSharingService` reconstructs using all pieces including fake one
4. Due to Shamir's Secret Sharing properties, even one corrupted share causes `DecodeSecret()` to produce garbage
5. The garbage value `hash(DecodeSecret(corrupted_shares))` is passed as `trigger.RevealedInValues[A]`
6. On-chain: `UpdateLatestSecretPieces()` sets `A.PreviousInValue = garbage_value` without verification
7. If Miner A is offline/faulty and doesn't produce blocks, this wrong value persists in the round state

### Impact Explanation

**Concrete Harm:**

1. **State Corruption:** Byzantine miners can force incorrect `PreviousInValue` assignments for any miner who fails to produce blocks, violating the cryptographic commitment invariant that `hash(PreviousInValue) == OutValue`.

2. **Consensus State Integrity:** The corrupted `PreviousInValue` values are stored in the round state and included in block consensus extra data, polluting the consensus mechanism with unverified data.

3. **Limited Scope:** The impact is constrained because:
   - Honest miners who DO produce blocks submit their correct `PreviousInValue` which is validated and takes precedence
   - The conditions in `ApplyNormalConsensusData` and `UpdateLatestSecretPieces` prevent overwriting already-set valid values
   - Only miners who are offline/faulty during a round are vulnerable

**Affected Parties:**
- Miners who experience downtime or fail to produce blocks in a given round have their consensus state corrupted
- The overall system integrity is degraded by having unverified data in the round state
- Future protocol features that might rely on historical `PreviousInValue` data would be affected

**Severity Justification:**
While this violates the cryptographic commitment scheme and enables state corruption, it does NOT enable:
- Direct fund theft or token manipulation
- Consensus takeover or invalid block acceptance
- Affecting honest miners' ability to produce valid blocks
- Unauthorized state transitions beyond data corruption

The severity is elevated because it's a fundamental violation of the secret sharing verification requirement, but mitigated by the limited practical impact.

### Likelihood Explanation

**Attacker Capabilities:**
- Any miner in the consensus set can submit arbitrary `DecryptedPieces`
- No special permissions or compromised keys required beyond being an active miner
- Byzantine miners (up to 1/3 of the miner set) can coordinate to corrupt multiple miners' states

**Attack Complexity:**
- Low complexity: Simply submit fake bytes instead of correct decryptions
- No cryptographic breaking required
- Standard transaction submission process

**Feasibility Conditions:**
- Target miner must be offline or fail to produce blocks in the round
- Requires at least one Byzantine miner in the consensus set
- Attack is detectable in logs but not prevented by the contract

**Detection Constraints:**
- Off-chain monitoring could detect mismatches between `OutValue` and reconstructed `PreviousInValue`
- On-chain, there's no automatic detection or rejection of invalid reconstructions
- The wrong values remain in the round state unless overwritten by honest miner's submission

**Probability:**
- Highly probable if Byzantine miners exist and honest miners experience downtime
- The attack cost is negligible (just transaction fees)
- Economic incentive is low unless combined with other attacks targeting offline miners

### Recommendation

**Immediate Mitigation:**

1. **Add Verification in UpdateLatestSecretPieces:** [6](#0-5) 

Modify lines 148-152 to verify reconstructed values:
```csharp
foreach (var revealedInValue in triggerInformation.RevealedInValues)
{
    if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
    {
        var previousOutValue = GetPreviousRoundOutValue(revealedInValue.Key);
        if (previousOutValue != null && 
            HashHelper.ComputeFrom(revealedInValue.Value) != previousOutValue)
        {
            // Reject invalid reconstructed value
            continue;
        }
        
        if (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
            updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null)
        {
            updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
        }
    }
}
```

2. **Add Verification in RevealSharedInValues:** [7](#0-6) 

Before line 52, add validation:
```csharp
// Verify reconstructed value matches OutValue commitment
if (previousRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue != null &&
    previousRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue != revealedInValue)
{
    Context.LogDebug(() => $"Invalid reconstructed InValue for {publicKeyOfAnotherMiner}");
    continue;
}
```

3. **Add Invariant Checks:**
Implement a helper function to validate all PreviousInValue/OutValue pairs maintain the commitment property throughout the consensus flow.

**Test Cases:**
1. Test Byzantine miner submitting fake DecryptedPieces
2. Verify reconstruction fails validation with corrupted shares
3. Test that honest miner's submission overrides invalid reconstructions
4. Test offline miner scenario with both valid and invalid reconstructions

### Proof of Concept

**Initial State:**
- 5 miners in consensus set: A (honest), B (Byzantine), C, D, E (honest)
- Round N-1: Miner A generates `InValue_A`, publishes `OutValue_A = hash(InValue_A)`
- Miner A splits `InValue_A` into 5 shares using Shamir's Secret Sharing (threshold 3)
- Encrypted shares distributed to all miners

**Attack Sequence:**

1. Round N begins, Miner A is experiencing network issues and cannot produce blocks

2. Byzantine Miner B submits UpdateValue transaction with:
   - `DecryptedPieces[A] = 0x1234...fake_bytes` (arbitrary garbage instead of correct decryption)
   - This is stored on-chain in `previousRound.RealTimeMinersInformation[A].DecryptedPieces[B]`

3. Honest Miner C produces a block:
   - Off-chain: `SecretSharingService.RevealPreviousInValues()` collects all DecryptedPieces for A
   - Includes B's fake piece: `[correct_piece_from_C, correct_piece_from_D, fake_piece_from_B, ...]`
   - Calls `SecretSharingHelper.DecodeSecret(corrupted_shares, orders, 3)`
   - Result: garbage value due to corrupted input
   - Computes `revealedInValue = hash(garbage) â‰  OutValue_A`

4. Miner C's trigger information includes:
   - `RevealedInValues[A] = hash(garbage)`

5. On-chain during C's block execution:
   - `UpdateLatestSecretPieces()` sets `currentRound.RealTimeMinersInformation[A].PreviousInValue = hash(garbage)`
   - NO verification that `hash(garbage) == OutValue_A`

**Expected Result:**
The contract should reject the invalid reconstructed value and either:
- Not set PreviousInValue for A, leaving it Empty
- Log an error indicating verification failure

**Actual Result:**
The wrong value `hash(garbage)` is stored as A's PreviousInValue in the round state, corrupting the consensus data. If Miner A remains offline, this incorrect value persists.

**Success Condition:**
The attack succeeds if `currentRound.RealTimeMinersInformation[A].PreviousInValue == hash(garbage)` and `hash(garbage) != OutValue_A`, demonstrating unverified data has been accepted into the consensus state.

### Notes

The vulnerability is real and violates the cryptographic commitment invariant, but its practical impact is limited by the protocol's design where honest miners' self-submissions take precedence. The primary risk is state corruption for offline miners rather than active consensus manipulation. The fix requires adding verification against OutValue commitments at all points where reconstructed InValues are used.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-152)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;

        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-52)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L166-180)
```csharp
            var orders = minerInRound.DecryptedPieces.Select((t, i) =>
                    round.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    minerInRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = minerInRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            Logger.LogDebug($"Revealed in value of {pubkey} of round {round.RoundNumber}: {revealedInValue}");

            revealedInValues[pubkey] = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```
