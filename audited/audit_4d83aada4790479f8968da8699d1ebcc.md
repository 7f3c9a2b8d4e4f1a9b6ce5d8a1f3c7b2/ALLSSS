### Title
Division by Zero in Bancor Price Calculation Causes DoS of Token Purchase Functionality

### Summary
The `GetAmountToPayFromReturn()` function in `BancorHelper.cs` performs division operations without validating that the requested amount is less than the available balance. When connector weights differ (the common case), an unhandled division by zero exception occurs at line 91, causing any Buy transaction with excessive amounts to fail and creating a denial-of-service vector for the TokenConverter contract.

### Finding Description

The vulnerability exists in the `GetAmountToPayFromReturn()` function which calculates the cost to purchase a specified amount of tokens using the Bancor formula. [1](#0-0) 

**Root Cause**: The function only validates that inputs are positive (lines 70-73) but fails to check that `amountToReceive < toConnectorBalance`. This allows the denominator `(bt - a)` to become zero or negative in the division operations.

**Two Vulnerable Code Paths**:

1. **Line 84** (when `wf == wt`): Protected by try-catch block that catches the exception and throws "Insufficient account balance to deposit" - but this is a runtime error catch, not proper validation.

2. **Line 91** (when `wf != wt`): `var x = bt / (bt - a);` - This line is OUTSIDE the try-catch block and will throw an unhandled `DivideByZeroException` when `amountToReceive >= toConnectorBalance`.

**Entry Point**: The public `Buy()` function calls this vulnerable function without validation: [2](#0-1) 

The Buy function passes `input.Amount` (user-controlled) directly as the `amountToReceive` parameter without checking if it exceeds the available token balance retrieved by `GetSelfBalance(toConnector)`.

### Impact Explanation

**Operational Impact - DoS of Buy Functionality**:
- Any user can cause the Buy function to fail by requesting to purchase an amount equal to or exceeding the available token balance
- When connector weights differ (e.g., 0.5 vs 0.6, as seen in test configurations), the unhandled exception at line 91 causes transaction failure
- The TokenConverter becomes unusable for legitimate users attempting to buy tokens after an attacker triggers this condition
- Different connector weights are the standard configuration for Bancor models, making this the common case rather than an edge case [3](#0-2) 

**Affected Users**: All users attempting to buy tokens from the TokenConverter contract when an attacker submits a malicious transaction.

**Severity Justification**: High - While this doesn't result in fund loss, it creates a complete denial of service for a critical protocol function (token purchasing), which is a core feature of the TokenConverter contract.

### Likelihood Explanation

**Reachable Entry Point**: The `Buy()` function is a public method callable by any user without special permissions.

**Attacker Capabilities**: 
- No special privileges required
- Attacker only needs to call Buy with `input.Amount >= GetSelfBalance(toConnector)`
- The `input.Amount` parameter is completely user-controlled

**Attack Complexity**: Trivial
1. Query current token balance available in the connector
2. Call Buy with Amount = balance (or any value >= balance)
3. Transaction fails with division by zero

**Feasibility Conditions**:
- Works immediately after contract deployment
- No specific timing or state requirements
- Cost is minimal (only gas for the failed transaction)
- Can be repeated indefinitely

**Detection Constraints**: The attack is difficult to prevent as it uses the normal Buy interface with valid-looking parameters.

**Probability**: Very High - This is not a race condition or complex exploit chain. It's a straightforward input validation failure that any user can trigger intentionally or accidentally.

### Recommendation

**Immediate Fix**: Add validation in `GetAmountToPayFromReturn()` before any division operations:

```csharp
public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
    long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
{
    if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
        throw new InvalidValueException("Connector balance needs to be a positive number.");
    
    if (amountToReceive <= 0) 
        throw new InvalidValueException("Amount needs to be a positive number.");
    
    // ADD THIS CHECK:
    if (amountToReceive >= toConnectorBalance)
        throw new InvalidValueException("Amount to receive must be less than available balance.");
    
    // ... rest of function
}
```

**Additional Protection**: Add validation in the `Buy()` function before calling the Bancor helper:

```csharp
public override Empty Buy(BuyInput input)
{
    var toConnector = State.Connectors[input.Symbol];
    Assert(toConnector != null, "[Buy]Can't find to connector.");
    Assert(toConnector.IsPurchaseEnabled, "can't purchase");
    
    // ADD THIS CHECK:
    var availableBalance = GetSelfBalance(toConnector);
    Assert(input.Amount < availableBalance, "Insufficient tokens available for purchase.");
    
    // ... rest of function
}
```

**Test Cases**: Add regression tests covering:
1. Attempting to buy exactly the available balance
2. Attempting to buy more than available balance
3. Testing both equal weights (wf == wt) and different weights (wf != wt) scenarios

### Proof of Concept

**Initial State**:
- TokenConverter contract deployed and initialized
- Connector pair enabled (e.g., ELF â†” WRITE tokens)
- WRITE connector has balance of 10,000 tokens
- Connector weights: ELF weight = 0.5, WRITE weight = 0.6 (different weights)

**Attack Steps**:
1. Attacker queries available WRITE token balance: 10,000 tokens
2. Attacker calls `Buy(BuyInput { Symbol: "WRITE", Amount: 10000, PayLimit: 0 })`
3. Buy function calls `GetAmountToPayFromReturn(...)` with `amountToReceive = 10000`
4. Since weights differ (0.5 != 0.6), execution reaches line 91
5. Line 91 attempts: `var x = bt / (bt - a)` = `10000 / (10000 - 10000)` = `10000 / 0`
6. **Result**: `DivideByZeroException` thrown, transaction fails

**Expected vs Actual**:
- **Expected**: Transaction should be rejected with clear error: "Insufficient tokens available"
- **Actual**: Transaction fails with unhandled division by zero exception

**Success Condition**: The Buy transaction fails, demonstrating the DoS vulnerability. Any subsequent legitimate Buy attempts may also fail if this condition persists.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-94)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-123)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** test/AElf.Contracts.TokenConverter.Internal.Tests/BancorHelperTest.cs (L14-32)
```csharp
    {
        _writeConnector = new Connector
        {
            Symbol = "WRITE",
            VirtualBalance = 50_0000,
            Weight = "0.5",
            IsVirtualBalanceEnabled = false,
            IsPurchaseEnabled = true
        };

        _elfConnector = new Connector
        {
            Symbol = "ELF",
            VirtualBalance = 100_0000,
            Weight = "0.6",
            IsPurchaseEnabled = true,
            IsVirtualBalanceEnabled = false
        };
    }
```
