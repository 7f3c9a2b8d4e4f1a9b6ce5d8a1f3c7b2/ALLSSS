### Title
Connector Symbol Collision in AddPairConnector() Causes State Corruption and Incorrect Token Pricing

### Summary
The `AddPairConnector()` function fails to validate that the newly constructed native connector symbol (prefixed with "(NT)") doesn't collide with an existing connector's Symbol. This allows overwriting of existing connectors, breaking the bidirectional pairing relationship between resource and deposit connectors. When `Buy()` or `Sell()` operations subsequently look up connectors via `RelatedSymbol`, they retrieve the wrong connector with incorrect balance and weight values, resulting in incorrect Bancor pricing calculations and potential economic loss.

### Finding Description

The vulnerability exists in the `AddPairConnector()` function where a native connector symbol is constructed by prefixing "(NT)" to the input resource symbol: [1](#0-0) 

The function only validates that the resource connector symbol doesn't already exist: [2](#0-1) 

However, there is **no validation** that `nativeConnectorSymbol` (e.g., "(NT)XYZ") doesn't already exist before writing to state: [3](#0-2) 

**Root Cause:** Missing collision check for the computed `nativeConnectorSymbol` before state mutation at line 108.

**Why Protections Fail:** The assertion at line 85-86 only prevents reusing a resource symbol, but doesn't prevent creating a native symbol that collides with an existing connector's Symbol. The connector pairing design assumes bidirectional references where Connector A's `RelatedSymbol` points to Connector B, and B's `RelatedSymbol` points back to A. Breaking this invariant by overwriting one connector corrupts the pairing.

**Execution Path:**
1. Existing state: Connector pair with Symbol="ABC"/RelatedSymbol="(NT)XYZ" and Symbol="(NT)XYZ"/RelatedSymbol="ABC"
2. Call `AddPairConnector(ResourceConnectorSymbol="XYZ")` via governance
3. Function creates `nativeConnectorSymbol = "(NT)XYZ"` 
4. Check at line 85-86 passes (no connector with Symbol="XYZ")
5. Line 108 overwrites `State.Connectors["(NT)XYZ"]` with new connector having RelatedSymbol="XYZ"
6. Original connector "ABC" still references RelatedSymbol="(NT)XYZ", but now points to wrong connector

### Impact Explanation

**Direct Fund Impact:** When users execute `Buy()` or `Sell()` operations on the affected connector pair, the lookup via `RelatedSymbol` retrieves the wrong connector: [4](#0-3) [5](#0-4) 

The Bancor pricing formula uses balance and weight from the wrong connector: [6](#0-5) 

This results in:
- **Incorrect token pricing**: Users pay wrong amounts or receive wrong amounts
- **Economic loss**: Mispriced tokens can be exploited for profit or cause losses to the protocol/users
- **State corruption**: Original connector pair becomes permanently unusable
- **Protocol integrity**: Breaks the core invariant of connector pairing

**Affected Parties:** All users trading on the corrupted connector pair, and the protocol's treasury/reserve system.

**Severity Justification:** HIGH - Violates critical "Pricing & Reserves" invariant, causes direct economic impact through incorrect Bancor calculations, and results in permanent state corruption that cannot be reversed without migration.

### Likelihood Explanation

**Attacker Capabilities:** Requires connector controller authority (typically Parliament default organization governance): [7](#0-6) 

**Attack Complexity:** LOW - Single function call with carefully chosen symbol parameter. An attacker with governance access (or governance making an honest mistake) needs only to:
1. Identify existing connector with Symbol starting with "(NT)" prefix (e.g., "(NT)XYZ")
2. Call `AddPairConnector(ResourceConnectorSymbol="XYZ")` to create collision

**Feasibility Conditions:** 
- Realistic scenario: Governance legitimately adds new connector pairs without realizing the collision
- No test coverage exists for this collision scenario (tests only check resource symbol collision)
- Token symbols are user-defined strings, making collisions possible during normal operations [8](#0-7) 

**Detection/Operational Constraints:** The collision may not be immediately apparent. Only when users attempt Buy/Sell on the corrupted pair will incorrect pricing become evident.

**Probability Reasoning:** MEDIUM to HIGH - While requiring governance authority, this can occur through legitimate governance actions (not malicious). As the system scales with more connector pairs, the probability of accidental collision increases.

### Recommendation

**Code-Level Mitigation:**

Add validation in `AddPairConnector()` to check for native connector symbol collision before state mutation:

```csharp
public override Empty AddPairConnector(PairConnectorParam input)
{
    AssertPerformedByConnectorController();
    Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
        "resource token symbol should not be empty");
    var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
    Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
        "resource token symbol has existed");
    
    // ADD THIS CHECK:
    Assert(State.Connectors[nativeConnectorSymbol] == null,
        "native connector symbol already exists");
    
    // ... rest of function
}
```

**Invariant Checks:**
1. Before adding any connector pair, verify both Symbol values don't exist in state
2. Add validation that RelatedSymbol of any connector always points to an existing, compatible connector
3. Consider reserving the "(NT)" prefix exclusively for deposit connectors managed by the system

**Test Cases:**
1. Test attempting to add connector with ResourceConnectorSymbol that would create native symbol collision
2. Test that existing connector pairs maintain bidirectional RelatedSymbol integrity after AddPairConnector
3. Test GetPairConnector after collision attempt to verify state consistency [9](#0-8) 

### Proof of Concept

**Initial State:**
1. Deploy TokenConverter with existing connector pair:
   - Resource connector: Symbol="ABC", RelatedSymbol="(NT)XYZ", Weight="0.5"
   - Deposit connector: Symbol="(NT)XYZ", RelatedSymbol="ABC", Weight="0.5", VirtualBalance=1000000

2. Verify Buy/Sell works correctly for "ABC" token using GetPairConnector

**Exploitation Steps:**
1. Governance proposes and executes: `AddPairConnector(ResourceConnectorSymbol="XYZ", ResourceWeight="0.3", NativeWeight="0.3", NativeVirtualBalance=500000)`

2. Function execution:
   - Line 84: Creates `nativeConnectorSymbol = "(NT)XYZ"`
   - Line 85-86: Check passes (no connector with Symbol="XYZ")
   - Line 108: **Overwrites** `State.Connectors["(NT)XYZ"]` with new connector having RelatedSymbol="XYZ", Weight="0.3", VirtualBalance=500000

**Expected vs Actual Result:**

**Expected:** Transaction fails with "native connector symbol already exists"

**Actual:** 
- Transaction succeeds
- State.Connectors["(NT)XYZ"] now points to new connector with different properties
- Original connector "ABC" with RelatedSymbol="(NT)XYZ" now references wrong connector
- GetPairConnector("ABC") returns inconsistent pair (ABC points to deposit with RelatedSymbol="XYZ", not "ABC")
- Buy("ABC") or Sell("ABC") uses wrong balance/weight values in Bancor calculation

**Success Condition:** 
After calling `AddPairConnector("XYZ")`, execute `GetPairConnector("ABC")` and observe that the returned deposit connector's RelatedSymbol no longer matches "ABC", confirming state corruption.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L81-81)
```csharp
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L84-84)
```csharp
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L85-86)
```csharp
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L107-108)
```csharp
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L114-119)
```csharp
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L163-167)
```csharp
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L88-88)
```csharp
    [InlineData("WRITE", "0.5", "0.5", "resource token symbol has existed")]
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L37-54)
```csharp
    public override PairConnector GetPairConnector(TokenSymbol input)
    {
        var targetConnector = State.Connectors[input.Symbol];
        Connector relatedConnector = null;
        if (targetConnector != null)
            relatedConnector = State.Connectors[targetConnector.RelatedSymbol];
        if (targetConnector != null && targetConnector.IsDepositAccount)
            return new PairConnector
            {
                ResourceConnector = relatedConnector,
                DepositConnector = targetConnector
            };
        return new PairConnector
        {
            ResourceConnector = targetConnector,
            DepositConnector = relatedConnector
        };
    }
```
