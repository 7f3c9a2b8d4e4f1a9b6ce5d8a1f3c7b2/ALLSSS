### Title
Dictionary Key Mismatch in RecoverFromUpdateValue Causes Consensus Validation DoS During Miner Replacement

### Summary
The `RecoverFromUpdateValue` function contains a critical flaw where it iterates over all miners in the provided round and accesses `RealTimeMinersInformation[information.Key]` without checking if the key exists in the current round. This causes a `KeyNotFoundException` when the provided round contains miners not present in the current round (e.g., during miner replacement or term transitions), resulting in DoS of consensus validation before the system's miner replacement validation logic can be reached.

### Finding Description

The vulnerability exists in the `RecoverFromUpdateValue` function: [1](#0-0) 

**Root Cause:**
The function performs an early check to verify the sender pubkey exists in both rounds (lines 10-12), but then proceeds to iterate over ALL miners in `providedRound.RealTimeMinersInformation` (lines 22-30). For each miner, it directly accesses `RealTimeMinersInformation[information.Key]` without verifying the key exists, causing a `KeyNotFoundException` when `information.Key` is not present in the current round.

**Why Existing Protections Fail:**
This function is called during consensus validation in two critical paths:

1. **Before Execution Validation:** [2](#0-1) 

2. **After Execution Validation:** [3](#0-2) 

In the after-execution path, there IS miner replacement validation logic, but it only executes AFTER `RecoverFromUpdateValue` completes: [4](#0-3) 

The miner replacement validation at lines 103-123 is unreachable because the exception is thrown at line 91 before this logic can execute.

**Pattern Inconsistency:**
The codebase consistently uses `ContainsKey` checks before accessing `RealTimeMinersInformation` in other locations, indicating this is the expected defensive pattern. The missing check in lines 22-30 breaks this pattern.

### Impact Explanation

**Operational DoS Impact:**
- Blocks containing consensus data with mismatched miner lists (legitimate during miner replacement or malicious) will fail validation with an unhandled exception
- Consensus validation process is disrupted when nodes have different views of the miner list during replacement transitions
- The system's designed miner replacement validation logic (lines 103-123) becomes unreachable

**Affected Parties:**
- All validators attempting to validate blocks during miner replacement events
- The network during term transitions when miner lists change
- Block producers whose blocks get rejected due to validation failures

**Attack Vectors:**
1. **Legitimate Failure:** During miner replacement via `RecordCandidateReplacement`, nodes may have different miner list states, causing legitimate blocks to fail validation [5](#0-4) 

2. **Malicious Exploitation:** A malicious miner can craft consensus extra data containing additional miner pubkeys not in the current round, causing validation failures on other nodes

**Severity Justification:** High - This creates a DoS vector in the critical consensus validation path that can occur both through legitimate state transitions and malicious exploitation.

### Likelihood Explanation

**Reachable Entry Point:**
The validation functions are invoked during block validation when nodes receive blocks from the network: [6](#0-5) 

**Feasible Preconditions:**
1. **Legitimate Scenario:** Miner replacement occurs mid-round, causing different nodes to have different miner list states
2. **Malicious Scenario:** A valid miner (already passed permission checks) crafts consensus data with extra miner pubkeys

**Execution Practicality:**
- The consensus extra data is generated client-side and can include arbitrary miner information [7](#0-6) 

- The provided round is derived from the block header's consensus data, which is controlled by the block producer

**Economic Rationality:**
- Legitimate occurrence during normal miner replacement operations (high probability)
- Malicious miners can cause disruption during their time slots at minimal cost
- The attack causes more disruption to the network than cost to the attacker

**Probability:** High - Miner replacement is a normal operational event, making this a recurring issue during legitimate protocol operations.

### Recommendation

**Immediate Fix:**
Add `ContainsKey` checks in the foreach loop at lines 22-30 of `Round_Recover.cs`:

```csharp
foreach (var information in providedRound.RealTimeMinersInformation)
{
    if (!RealTimeMinersInformation.ContainsKey(information.Key))
        continue; // Skip miners not in current round
        
    RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
        information.Value.SupposedOrderOfNextRound;
    RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
        information.Value.FinalOrderOfNextRound;
    RealTimeMinersInformation[information.Key].PreviousInValue =
        information.Value.PreviousInValue;
}
```

**Invariant Enforcement:**
- All dictionary accesses to `RealTimeMinersInformation` must be guarded by `ContainsKey` checks
- Validation logic for miner replacement should execute before recovery operations that assume key existence

**Test Cases:**
1. Test block validation during active miner replacement with different node states
2. Test recovery function with provided round containing extra/missing miners
3. Test after-execution validation with mismatch scenarios to ensure replacement logic is reached
4. Negative test: Verify malicious consensus data with invalid miners is properly rejected without DoS

### Proof of Concept

**Initial State:**
- Current round has miners: `["Alice", "Bob", "Charlie"]`
- Miner "Alice" is replaced with "David" via `RecordCandidateReplacement`
- Node A has processed replacement: current round = `["David", "Bob", "Charlie"]`
- Node B has NOT processed replacement: current round = `["Alice", "Bob", "Charlie"]`

**Transaction Steps:**
1. Node A produces block with consensus extra data containing `["David", "Bob", "Charlie"]`
2. Node B receives this block for validation
3. Node B calls `ValidateConsensusAfterExecution` with the block's consensus data
4. Line 91: `RecoverFromUpdateValue` is called with:
   - `this.RealTimeMinersInformation` = `["Alice", "Bob", "Charlie"]`
   - `providedRound.RealTimeMinersInformation` = `["David", "Bob", "Charlie"]`
   - `pubkey` = "David"
5. Line 10-12: Check fails because "David" is NOT in Node B's current round
6. Function returns `this` without modification

**Alternative Malicious Scenario:**
1. Malicious miner "Alice" crafts block with consensus data containing `["Alice", "Bob", "Charlie", "Mallory"]`
2. Other nodes validate this block
3. Line 10-12: Check passes ("Alice" exists in both rounds)
4. Lines 22-30: Iteration reaches "Mallory"
5. Line 24: `RealTimeMinersInformation["Mallory"]` throws `KeyNotFoundException`
6. Validation fails with exception

**Expected vs Actual Result:**
- **Expected:** Validation should gracefully handle miner mismatches and reach the miner replacement validation logic (lines 103-123)
- **Actual:** Exception thrown or early return, preventing proper validation and causing DoS

**Success Condition:**
The vulnerability is confirmed if attempting to validate a block with mismatched miner lists results in validation failure before the miner replacement logic (lines 103-123 in `ValidateConsensusAfterExecution`) can execute.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-92)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L99-124)
```csharp
            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-145)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusValidationProvider.cs (L58-78)
```csharp
    public async Task<bool> ValidateBlockBeforeExecuteAsync(IBlock block)
    {
        if (block.Header.Height == AElfConstants.GenesisBlockHeight)
            return true;

        var consensusExtraData = _consensusExtraDataExtractor.ExtractConsensusExtraData(block.Header);
        if (consensusExtraData == null || consensusExtraData.IsEmpty)
        {
            Logger.LogDebug($"Invalid consensus extra data {block}");
            return false;
        }

        var isValid = await _consensusService.ValidateConsensusBeforeExecutionAsync(new ChainContext
        {
            BlockHash = block.Header.PreviousBlockHash,
            BlockHeight = block.Header.Height - 1
        }, consensusExtraData.ToByteArray());
        if (!isValid) return false;

        return ValidateTransactionCount(block);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L55-134)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataToPublishOutValue(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        Assert(triggerInformation.InValue != null, "In value should not be null.");

        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
        var previousInValue = Hash.Empty; // Just initial previous in value.

        if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
        {
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
        }

        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);

        Context.LogDebug(
            () => "Previous in value after ApplyNormalConsensusData: " +
                  $"{updatedRound.RealTimeMinersInformation[pubkey].PreviousInValue}");

        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;

        // Update secret pieces of latest in value.
        
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }

        // To publish Out Value.
        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = updatedRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```
