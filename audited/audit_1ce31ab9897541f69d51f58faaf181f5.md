### Title
Premature Loop Exit in Transaction Fee Token Selection Causes Delegation Payment Failure

### Summary
The `GetAvailableSymbolToPayTxFee()` function uses `break` instead of `continue` when a delegation check fails, causing the loop to exit prematurely without checking remaining tokens in the list. This results in legitimate transactions failing with "Transaction fee not enough" even when delegatees have sufficient delegation allowances for alternative tokens later in the configured list.

### Finding Description

The vulnerability exists in the `GetAvailableSymbolToPayTxFee()` function where a delegation validation check causes premature loop termination: [1](#0-0) 

**Root Cause:**
When `delegations != null`, the function checks if the current token has sufficient delegation allowance via `IsDelegationEnoughBaseOnPrimaryToken()`. If the check fails (`delegationEnough == false`), the code executes `break`, immediately exiting the entire foreach loop without evaluating subsequent tokens.

**Execution Path:**
1. The function is called from `ChargeSizeFee()` with a list of alternative tokens configured for transaction size fees: [2](#0-1) 

2. When `GetAvailableSymbolToPayTxFee()` returns `null` due to the premature break, the charging process fails: [3](#0-2) 

3. This causes the entire transaction fee charging to fail in `TryToChargeTransactionFee()`: [4](#0-3) 

**Why Existing Protections Fail:**
The function initializes fallback variables (`availableSymbolWithEnoughBalance`, `availableSymbolWithEnoughBalancePlusAllowance`, etc.) that should capture valid alternatives, but these are never populated because the loop exits before reaching tokens that pass the delegation check: [5](#0-4) 

The fallback logic at the end cannot help if the loop never evaluates viable tokens: [6](#0-5) 

### Impact Explanation

**Denial of Service Impact:**
Users relying on transaction fee delegation will experience transaction failures for legitimate operations. When multiple tokens are configured for paying transaction size fees (a common production setup), if the first token in the list lacks sufficient delegation allowance but subsequent tokens have adequate allowances, all transactions will fail incorrectly.

**Affected Parties:**
- Users who depend on delegatees to pay their transaction fees
- Delegatees who have allocated sufficient allowances for alternative tokens
- Smart contract operations requiring fee delegation functionality

**Severity Justification:**
Medium severity - This causes operational disruption and denial of service for the delegation feature, which is a critical component of the fee payment system. While it doesn't result in direct fund loss, it blocks legitimate transactions and renders the multi-token delegation feature partially non-functional when token lists contain entries with insufficient delegation allowances before valid ones.

### Likelihood Explanation

**Attack Complexity:**
This is not a malicious attack but a systematic failure that occurs during normal operations. No special attacker capabilities are required - it happens automatically when:
1. Multiple tokens are configured via `SetSymbolsToPayTxSizeFee()` (standard configuration)
2. A delegation relationship exists (the delegation feature is in active use)
3. Token ordering places a token with insufficient delegation before tokens with sufficient delegation

**Feasibility Conditions:**
- **Reachable Entry Point:** The bug is triggered through the public `ChargeTransactionFees()` method called automatically by the ACS1 pre-plugin service for every transaction [7](#0-6) 

- **Realistic Preconditions:** Multi-token fee configuration is explicitly supported by the system and commonly used in production environments [8](#0-7) 

- **High Probability:** The bug triggers whenever the token list ordering places tokens with insufficient delegation before valid ones, which is not controllable by users and can easily occur in real deployments.

**Detection Constraints:**
The issue manifests as a generic "Transaction fee not enough" error, making it difficult to diagnose the root cause without code inspection.

### Recommendation

**Code-Level Fix:**
Change line 480 in `TokenContract_Fees.cs` from:
```csharp
if (!delegationEnough) break;
```
to:
```csharp
if (!delegationEnough) continue;
```

This allows the loop to skip tokens with insufficient delegation allowances while continuing to evaluate remaining tokens in the list.

**Additional Validation:**
Add comprehensive test cases covering:
1. Multi-token delegation scenarios where earlier tokens fail delegation checks
2. Verification that the function returns valid tokens appearing later in the list
3. Edge cases with mixed delegation allowances across different token types

**Invariant to Enforce:**
The token selection function must evaluate all configured tokens before returning null, ensuring that tokens with sufficient delegation allowances are never skipped due to preceding tokens with insufficient allowances.

### Proof of Concept

**Initial State:**
1. Configure three tokens for transaction size fees: `[TokenA, TokenB, TokenC]`
2. User establishes delegation with DelegateeX
3. DelegateeX has delegation allowances: `{TokenA: 0, TokenB: 1000, TokenC: 500}`
4. DelegateeX has sufficient balances for all tokens

**Transaction Steps:**
1. User submits a transaction requiring 100 units (primary token equivalent) for size fee
2. System calls `ChargeTransactionFees()` which invokes `ChargeSizeFee()`
3. `GetAvailableSymbolToPayTxFee()` is called with delegation parameter
4. Loop begins: First iteration processes TokenA
5. `IsDelegationEnoughBaseOnPrimaryToken(TokenA)` returns false (0 < 100)
6. Code executes `break` at line 480, exiting loop
7. Function returns `null` without checking TokenB or TokenC

**Expected Result:**
Function should continue iterating, find TokenB (delegation: 1000 >= 100), and return TokenB as available symbol.

**Actual Result:**
Function returns `null`, causing `ChargeSizeFee()` to return `false` at line 411-414, leading to transaction failure with "Transaction fee not enough" even though TokenB has sufficient delegation allowance.

**Success Condition:**
After fix, the function continues past TokenA, evaluates TokenB, finds sufficient delegation (1000 >= 100), and returns TokenB, allowing the transaction to succeed.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-32)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L118-121)
```csharp
        ModifyBalance(fromAddress, bill, allowanceBill);
        var chargingOutput = new ChargeTransactionFeesOutput { Success = chargingResult };
        if (!chargingResult)
            chargingOutput.ChargingInformation = "Transaction fee not enough.";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L396-398)
```csharp
            var availableSymbol = GetAvailableSymbolToPayTxFee(allSymbolToTxFee, fromAddress, txSizeFeeAmount,
                transactionFeeFreeAllowancesMap, symbolChargedForBaseFee, amountChargedForBaseFee,
                amountChargedForBaseAllowance, delegations);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L410-414)
```csharp
            //For delegation,if there is no available token,return false,no need to generate bill
            if (delegations != null && availableSymbol == null)
            {
                return false;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L467-470)
```csharp
        SymbolToPayTxSizeFee availableSymbol = null;
        SymbolToPayTxSizeFee availableSymbolWithAnything = null;
        SymbolToPayTxSizeFee availableSymbolWithEnoughBalance = null;
        SymbolToPayTxSizeFee availableSymbolWithEnoughBalancePlusAllowance = null;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L475-481)
```csharp
            if (delegations != null)
            {
                var delegationEnough = IsDelegationEnoughBaseOnPrimaryToken(symbolToPlayTxSizeFee,
                    symbolChargedForBaseFee, amountChargedForBaseFee.Add(amountChargedForBaseAllowance),
                    txSizeFeeAmount, delegations);
                if (!delegationEnough) break;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L513-516)
```csharp
        availableSymbol ??= availableSymbolWithEnoughBalancePlusAllowance ??
                            availableSymbolWithEnoughBalance ?? availableSymbolWithAnything;

        return availableSymbol;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L616-649)
```csharp
    public override Empty SetSymbolsToPayTxSizeFee(SymbolListToPayTxSizeFee input)
    {
        AssertControllerForSymbolToPayTxSizeFee();
        if (input == null)
            throw new AssertionException("invalid input");
        var isPrimaryTokenExist = false;
        var symbolList = new List<string>();
        var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty());
        Assert(!string.IsNullOrEmpty(primaryTokenSymbol.Value), "primary token does not exist");
        foreach (var tokenWeightInfo in input.SymbolsToPayTxSizeFee)
        {
            if (tokenWeightInfo.TokenSymbol == primaryTokenSymbol.Value)
            {
                isPrimaryTokenExist = true;
                Assert(tokenWeightInfo.AddedTokenWeight == 1 && tokenWeightInfo.BaseTokenWeight == 1,
                    $"symbol:{tokenWeightInfo.TokenSymbol} weight should be 1");
            }

            Assert(tokenWeightInfo.AddedTokenWeight > 0 && tokenWeightInfo.BaseTokenWeight > 0,
                $"symbol:{tokenWeightInfo.TokenSymbol} weight should be greater than 0");
            Assert(!symbolList.Contains(tokenWeightInfo.TokenSymbol),
                $"symbol:{tokenWeightInfo.TokenSymbol} repeat");
            AssertSymbolToPayTxFeeIsValid(tokenWeightInfo.TokenSymbol, out var addedTokenTotalSupply);
            symbolList.Add(tokenWeightInfo.TokenSymbol);
        }

        Assert(isPrimaryTokenExist, $"primary token:{primaryTokenSymbol.Value} not included");
        State.SymbolListToPayTxSizeFee.Value = input;
        Context.Fire(new ExtraTokenListModified
        {
            SymbolListToPayTxSizeFee = input
        });
        return new Empty();
    }
```
