### Title
PreviousInValue Can Be Overwritten Multiple Times During Miner List Changes, Violating Consensus Finality

### Summary
The `ProcessUpdateValue` function allows `PreviousInValue` to be set multiple times per miner per round without validation when the miner list changes. The `RevealSharedInValues()` function itself is ineffective (dead code), but the actual vulnerability exists in the execution path where `PerformSecretSharing` unconditionally overwrites `PreviousInValue` values, and validation is bypassed when `IsMinerListJustChanged` is true, allowing malicious miners to manipulate consensus state.

### Finding Description

**Root Cause:**

The `RevealSharedInValues()` function in `AEDPoSContract_SecretSharing.cs` unconditionally sets `PreviousInValue` without checking if already set: [1](#0-0) 

However, this function is dead code because it modifies `currentRound` which is never persisted to state. The modified round is not included in the returned header information: [2](#0-1) 

**The actual vulnerability** exists in the execution path where `ProcessUpdateValue` processes UpdateValue transactions:

1. Line 264 sets the miner's own `PreviousInValue` without checking if already set: [3](#0-2) 

2. `PerformSecretSharing` (called at line 256) unconditionally overwrites other miners' `PreviousInValue` from `input.MinersPreviousInValues`: [4](#0-3) 

**Why Protection Fails:**

While header generation includes protections against overwriting: [5](#0-4) [6](#0-5) 

The execution path lacks these protections. More critically, validation excludes `PreviousInValue` from verification when the miner list changes: [7](#0-6) [8](#0-7) 

**Attack Vector:**

The `MinersPreviousInValues` field in `UpdateValueInput` includes all miners' `PreviousInValue` data: [9](#0-8) 

A malicious miner can manipulate their node to inject false `PreviousInValue` values into the block header. During rounds where `IsMinerListJustChanged` is true, these manipulated values bypass validation and are written to state during execution.

### Impact Explanation

**Concrete Harm:**

`PreviousInValue` is used in signature calculation which determines mining order: [10](#0-9) [11](#0-10) 

By manipulating `PreviousInValue` values for other miners, an attacker can:
1. **Bias mining order** in subsequent rounds by influencing signature calculations
2. **Violate consensus finality** by overwriting previously committed values
3. **Undermine random number generation** used for consensus decisions
4. **Gain unfair advantage** in block production and rewards

**Who is Affected:**
- All miners in the network (mining order can be biased)
- Network integrity (consensus finality violated)
- Block reward distribution (influenced by mining order manipulation)

**Severity:** High - Violates critical consensus invariant that "PreviousInValue is only set once per miner per round"

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be a miner with block production rights
- Attacker must modify their local node software to inject false `MinersPreviousInValues` in block headers

**Attack Complexity:**
- Medium - Requires being a miner and waiting for miner list changes
- The validation gap exists and is exploitable when `IsMinerListJustChanged` is true
- Attack window occurs during every miner list change

**Feasibility:**
- Entry point: `UpdateValue` method (public, callable by miners): [12](#0-11) 
- Preconditions: Attacker is a miner, miner list has changed
- Execution: Modify block header with false `MinersPreviousInValues`, validation passes because hash excludes `PreviousInValue`
- No detection mechanism exists for this manipulation

**Probability:** Medium - Miner list changes occur periodically, providing regular attack opportunities

### Recommendation

**Immediate Fix:**

1. Add overwrite protection in `PerformSecretSharing`:
```
foreach (var previousInValue in input.MinersPreviousInValues)
    if (round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue == null ||
        round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue == Hash.Empty)
        round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
``` [4](#0-3) 

2. Add similar protection at line 264: [3](#0-2) 

3. Include `PreviousInValue` in validation even when miner list changes, or add separate validation for these values.

4. Remove or fix the dead code in `RevealSharedInValues()`: [13](#0-12) 

**Invariant Check:**
Assert that `PreviousInValue` is only set once: before setting, verify it's `null` or `Hash.Empty`.

**Test Cases:**
- Test that `PreviousInValue` cannot be overwritten after initial setting
- Test validation with `IsMinerListJustChanged=true` includes `PreviousInValue` verification
- Test that multiple `UpdateValue` calls in same round cannot modify already-set `PreviousInValue`

### Proof of Concept

**Initial State:**
- Network with 5 miners: A, B, C, D, E
- Round N with miner list change (`IsMinerListJustChanged=true`)
- Miner A is malicious

**Attack Steps:**

1. Round N begins with miner list change
2. Miner B produces first block, sets `PreviousInValue` for miners C, D, E via legitimate secret sharing
3. Miner A (malicious) produces second block:
   - Modifies local node to inject false `PreviousInValue` values in `MinersPreviousInValues`
   - Block header includes manipulated values for miners C, D, E
4. Validation runs with `IsMinerListJustChanged=true`:
   - `GetHash(false)` excludes `PreviousInValue` from hash calculation
   - Validation passes despite manipulated values
5. `ProcessUpdateValue` executes:
   - Line 296 overwrites miners C, D, E's `PreviousInValue` with false values
   - No protection exists to prevent overwrite
6. Round state saved with manipulated values: [14](#0-13) 

**Expected Result:**
`PreviousInValue` should remain unchanged after initial legitimate setting

**Actual Result:**
`PreviousInValue` is overwritten with attacker-controlled values, influencing mining order in next round

**Success Condition:**
Query round state after Miner A's block - observe that `PreviousInValue` for miners C, D, E differ from legitimate values set by Miner B

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-203)
```csharp
        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L263-264)
```csharp
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-114)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L194-194)
```csharp
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L99-101)
```csharp
            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
