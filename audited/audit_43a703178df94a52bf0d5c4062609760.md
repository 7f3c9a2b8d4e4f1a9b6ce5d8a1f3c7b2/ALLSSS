### Title
Per-Chain IndexingFeeController Allows Security Degradation Through Unvalidated Controller Changes

### Summary
Each side chain's `IndexingFeeController` can be changed without validation of the new controller's security properties, allowing an initial secure 2/2 multisig governance to be downgraded to weak single-party control. Combined with the lack of maximum fee bounds, this enables DoS attacks or resource drain for the affected side chain once the controller is weakened.

### Finding Description

The `GetSideChainIndexingFeeController()` function returns a per-chain `IndexingFeeController` stored in each `SideChainInfo` structure. [1](#0-0) 

During side chain creation, each chain's controller is initialized with a secure 2/2 multisig Association organization containing both the side chain creator and the global `CrossChainIndexingController` owner address. [2](#0-1) 

The default organization requires ALL members to approve (2/2 threshold). [3](#0-2) 

**Root Cause 1 - Unvalidated Controller Change:**
The `ChangeSideChainIndexingFeeController` function only validates that the current controller's organization address is the sender and that the new organization exists. [4](#0-3) 

The validation function `ValidateAuthorityInfoExists` merely checks organization existence, not its security properties (member count, approval thresholds, etc.). [5](#0-4) 

This allows the initial secure 2/2 multisig to be replaced with a weaker organization (e.g., 1/1 single-party control), removing the global controller's oversight.

**Root Cause 2 - No Fee Bounds:**
The `AdjustIndexingFeePrice` function only validates that fees are non-negative (>= 0) but has no maximum bound check. [6](#0-5) 

Once a controller is weakened to single-party control, that party can set the indexing fee to 0 (allowing free indexing) or to MAX int64 value (causing effective DoS).

### Impact Explanation

**Direct Impact:**
- **Resource Drain**: Setting indexing fee to 0 allows free indexing, draining parent chain resources without payment
- **DoS Attack**: Setting indexing fee to maximum int64 value (9,223,372,036,854,775,807) makes indexing prohibitively expensive, effectively disabling that side chain's indexing functionality
- **Governance Loss**: Once controller is downgraded, the global `CrossChainIndexingController` permanently loses oversight of that chain's fee policy

**Scope:**
- Impact is limited to the specific side chain whose controller is compromised (isolation by design works correctly)
- Other side chains remain unaffected due to per-chain controller separation
- However, with many side chains, this creates multiple potential attack surfaces

**Severity:** Medium - While isolation limits blast radius to one chain, the ability to completely disable a chain's indexing or drain resources is significant. The attack requires initial compromise of two parties (creator + global controller) but afterwards enables single-party control.

### Likelihood Explanation

**Attacker Capabilities Required:**
1. **Phase 1 (Controller Change)**: Requires compromising OR colluding with BOTH:
   - Side chain creator's private key/account
   - Global `CrossChainIndexingController` organization (typically Parliament)
   
2. **Phase 2 (Fee Manipulation)**: After controller is changed, only single party control needed

**Attack Complexity:**
- **Initial Change**: Medium complexity - requires social engineering, compromise of two independent parties, or malicious intent from both
- **Post-Change Exploitation**: Low complexity - straightforward function call by single party

**Feasibility Conditions:**
- Creator key compromise is realistic (private key theft, phishing, insider threat)
- Global controller approval might occur through:
  - Social engineering (disguised as legitimate governance update)
  - Compromise of Parliament/Association organization
  - Legitimate but poorly evaluated governance proposal
- Once controller is changed, exploitation is trivial

**Detection Constraints:**
- Controller changes emit `SideChainIndexingFeeControllerChanged` event, providing some transparency
- However, validating whether a new controller maintains appropriate security properties requires off-chain monitoring
- Fee adjustments also lack on-chain bounds checking

**Probability:** Medium - Requires multi-party compromise initially, but creates permanent security weakness afterwards.

### Recommendation

**1. Validate New Controller Security Properties:**

Add validation in `ChangeSideChainIndexingFeeController` to enforce minimum security requirements for the new controller:

```csharp
// In CrossChainContract.cs, modify ChangeSideChainIndexingFeeController
public override Empty ChangeSideChainIndexingFeeController(ChangeSideChainIndexingFeeControllerInput input)
{
    var sideChainInfo = State.SideChainInfo[input.ChainId];
    var authorityInfo = sideChainInfo.IndexingFeeController;
    Assert(authorityInfo.OwnerAddress == Context.Sender, "No permission.");
    Assert(ValidateAuthorityInfoExists(input.AuthorityInfo), "Invalid authority input.");
    
    // NEW: Validate minimum security properties
    Assert(ValidateControllerSecurityProperties(input.AuthorityInfo), 
        "New controller must maintain minimum security requirements.");
    
    sideChainInfo.IndexingFeeController = input.AuthorityInfo;
    State.SideChainInfo[input.ChainId] = sideChainInfo;
    Context.Fire(new SideChainIndexingFeeControllerChanged
    {
        ChainId = input.ChainId,
        AuthorityInfo = input.AuthorityInfo
    });
    return new Empty();
}

private bool ValidateControllerSecurityProperties(AuthorityInfo authorityInfo)
{
    // Verify minimum member count and approval threshold
    // For Association: require at least 2 members and appropriate thresholds
    // For Parliament: verify proper organization structure
    var organization = Context.Call<Organization>(
        authorityInfo.ContractAddress,
        nameof(AssociationContractContainer.AssociationContractReferenceState.GetOrganization),
        authorityInfo.OwnerAddress);
    
    Assert(organization.OrganizationMemberList.OrganizationMembers.Count >= 2, 
        "Controller must have at least 2 members.");
    Assert(organization.ProposalReleaseThreshold.MinimalApprovalThreshold >= 2,
        "Controller must require at least 2 approvals.");
    
    return true;
}
```

**2. Add Maximum Fee Bounds:**

Add upper bound validation in `AdjustIndexingFeePrice`:

```csharp
// In CrossChainContract.cs, modify AdjustIndexingFeePrice
public override Empty AdjustIndexingFeePrice(AdjustIndexingFeeInput input)
{
    var info = State.SideChainInfo[input.SideChainId];
    Assert(info != null && info.SideChainStatus != SideChainStatus.Terminated,
        "Side chain not found or incorrect side chain status.");
    
    // Validate fee bounds
    Assert(input.IndexingFee >= 0, "Invalid side chain fee price.");
    const long MaxIndexingFee = 1000000000000000; // Define reasonable maximum
    Assert(input.IndexingFee <= MaxIndexingFee, "Indexing fee exceeds maximum allowed.");
    
    var expectedOrganizationAddress = info.IndexingFeeController.OwnerAddress;
    Assert(expectedOrganizationAddress == Context.Sender, "No permission.");
    info.IndexingPrice = input.IndexingFee;
    State.SideChainInfo[input.SideChainId] = info;
    return new Empty();
}
```

**3. Test Cases:**

Add comprehensive tests for:
- Attempting to change controller to single-member organization (should fail)
- Attempting to change controller with weak approval thresholds (should fail)
- Attempting to set indexing fee above maximum bound (should fail)
- Attempting to set indexing fee to 0 or negative (should fail for 0 if not intended)
- Successful controller change with proper multi-party organization
- Successful fee adjustment within valid bounds

### Proof of Concept

**Initial State:**
- Side chain created with ID `chainId`
- IndexingFeeController = Association organization with:
  - Members: [Creator, GlobalControllerAddress]
  - MinimalApprovalThreshold: 2
  - MinimalVoteThreshold: 2

**Attack Sequence:**

1. **Attacker compromises Creator's private key**

2. **Creator creates malicious Association organization:**
   - Members: [Creator only]
   - MinimalApprovalThreshold: 1
   - MinimalVoteThreshold: 1
   - Call: `AssociationContract.CreateOrganization(maliciousOrgInput)`
   - Result: `maliciousOrgAddress`

3. **Creator proposes controller change in current controller:**
   - Create proposal via current IndexingFeeController organization
   - Call: `AssociationContract.CreateProposal` with method `ChangeSideChainIndexingFeeController`
   - Input: `{ ChainId: chainId, AuthorityInfo: { ContractAddress: AssociationContract, OwnerAddress: maliciousOrgAddress }}`

4. **Creator approves proposal:**
   - Call: `AssociationContract.Approve(proposalId)`

5. **Attacker social engineers GlobalController to approve:**
   - GlobalController approves (believing it's legitimate governance update)
   - Call: `AssociationContract.Approve(proposalId)` from GlobalController

6. **Release controller change:**
   - Call: `AssociationContract.Release(proposalId)`
   - Result: `ChangeSideChainIndexingFeeController` executed successfully
   - New controller = `maliciousOrgAddress` (1/1 single party)

7. **Attacker now has full control - DoS Attack:**
   - Create proposal in malicious organization to set fee to MAX
   - Call: `AssociationContract.CreateProposal` for `AdjustIndexingFeePrice`
   - Input: `{ SideChainId: chainId, IndexingFee: 9223372036854775807 }`
   - Creator approves (only 1 approval needed)
   - Call: `AssociationContract.Release`
   - Result: Indexing fee set to maximum, making indexing prohibitively expensive

**OR - Resource Drain Attack:**
   - Set fee to 0 instead, allowing free indexing without payment

**Success Condition:**
- IndexingFeeController changed from secure 2/2 to vulnerable 1/1
- Indexing fee manipulated to extreme value (0 or MAX)
- Side chain indexing either disabled (DoS) or free (resource drain)
- Global controller permanently excluded from governance

**Notes:**
The per-chain controller design provides good isolation (compromising one chain doesn't affect others), but the lack of validation when changing controllers creates a path for permanent security degradation. The authorization complexity is inherent to the per-chain model, but the vulnerability lies in allowing that complexity to be weaponized through unvalidated governance changes.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L209-214)
```csharp
    public override AuthorityInfo GetSideChainIndexingFeeController(Int32Value input)
    {
        var sideChainInfo = State.SideChainInfo[input.Value];
        Assert(sideChainInfo != null, "Side chain not found.");
        return sideChainInfo.IndexingFeeController;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L143-154)
```csharp
        var sideChainInfo = new SideChainInfo
        {
            Proposer = input.Proposer,
            SideChainId = chainId,
            SideChainStatus = SideChainStatus.Active,
            IndexingPrice = sideChainCreationRequest.IndexingPrice,
            IsPrivilegePreserved = sideChainCreationRequest.IsPrivilegePreserved,
            CreationTimestamp = Context.CurrentBlockTime,
            CreationHeightOnParentChain = Context.CurrentHeight,
            IndexingFeeController = CreateDefaultOrganizationForIndexingFeePriceManagement(input.Proposer)
        };
        State.SideChainInfo[chainId] = sideChainInfo;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L244-255)
```csharp
    public override Empty AdjustIndexingFeePrice(AdjustIndexingFeeInput input)
    {
        var info = State.SideChainInfo[input.SideChainId];
        Assert(info != null && info.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");
        Assert(input.IndexingFee >= 0, "Invalid side chain fee price.");
        var expectedOrganizationAddress = info.IndexingFeeController.OwnerAddress;
        Assert(expectedOrganizationAddress == Context.Sender, "No permission.");
        info.IndexingPrice = input.IndexingFee;
        State.SideChainInfo[input.SideChainId] = info;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L257-271)
```csharp
    public override Empty ChangeSideChainIndexingFeeController(ChangeSideChainIndexingFeeControllerInput input)
    {
        var sideChainInfo = State.SideChainInfo[input.ChainId];
        var authorityInfo = sideChainInfo.IndexingFeeController;
        Assert(authorityInfo.OwnerAddress == Context.Sender, "No permission.");
        Assert(ValidateAuthorityInfoExists(input.AuthorityInfo), "Invalid authority input.");
        sideChainInfo.IndexingFeeController = input.AuthorityInfo;
        State.SideChainInfo[input.ChainId] = sideChainInfo;
        Context.Fire(new SideChainIndexingFeeControllerChanged
        {
            ChainId = input.ChainId,
            AuthorityInfo = input.AuthorityInfo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L626-648)
```csharp
    private CreateOrganizationInput GenerateOrganizationInputForIndexingFeePrice(
        IList<Address> organizationMembers)
    {
        var createOrganizationInput = new CreateOrganizationInput
        {
            ProposerWhiteList = new ProposerWhiteList
            {
                Proposers = { organizationMembers }
            },
            OrganizationMemberList = new OrganizationMemberList
            {
                OrganizationMembers = { organizationMembers }
            },
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = organizationMembers.ToList().Count,
                MinimalVoteThreshold = organizationMembers.ToList().Count,
                MaximalRejectionThreshold = 0,
                MaximalAbstentionThreshold = 0
            }
        };
        return createOrganizationInput;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L676-681)
```csharp
    private bool ValidateAuthorityInfoExists(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```
