# Audit Report

## Title
Alias-to-Alias Mapping Enables Circular References and Incomplete Symbol Resolution

## Summary
The token alias system allows creating aliases that point to other aliases instead of actual token symbols. The `GetActualTokenSymbol` function performs only one level of alias resolution, causing balance queries, transfers, and other token operations to fail or return incorrect results when chained or circular aliases are used.

## Finding Description

The vulnerability exists in two critical components that enable alias-to-alias mappings without proper validation:

**1. Single-Level Alias Resolution**

The `GetActualTokenSymbol` function performs only one lookup in the `SymbolAliasMap`. [1](#0-0)  If an alias points to another alias, the resolution stops at the intermediate alias instead of continuing to resolve to the actual token symbol. This affects all token operations including balance queries [2](#0-1) , approvals [3](#0-2) , and allowance checks [4](#0-3) .

**2. Missing Validation in Alias Creation**

The `SetTokenAlias` function extracts symbol-to-alias mappings from `TokenInfo.ExternalInfo` and directly sets the mapping without validating that the target symbol is not itself an alias. [5](#0-4)  The function only validates the alias format via `CheckTokenAlias`, which checks that the alias matches the collection prefix but never validates the target symbol. [6](#0-5) 

**3. Attack Vectors**

This vulnerability is exploitable through two code paths:

- **NFT Collection Creation**: During token creation, if `ExternalInfo` contains alias settings, the code directly calls `SetTokenAlias` without validating the target symbol. [7](#0-6)  The `ExternalInfo` from user input is directly used with no content validation by `AssertValidCreateInput`. [8](#0-7) 

- **Cross-Chain Token Synchronization**: The `CrossChainCreateToken` method receives token information from another chain and constructs a `TokenInfo` with the unvalidated `ExternalInfo` directly from the cross-chain message. [9](#0-8)  This then calls `SyncSymbolAliasFromTokenInfo`, which triggers `SetTokenAlias` without additional validation. [10](#0-9) 

## Impact Explanation

**Operational Disruption:**
- Balance queries using chained aliases return incorrect results (typically 0) because the intermediate alias doesn't correspond to an actual token symbol in `State.TokenInfos`
- Transfer and approval operations fail or affect unintended tokens when aliases resolve to invalid intermediate symbols
- Lock/unlock operations fail for tokens accessed via chained aliases
- The helper `GetBalance` method performs a second call to `GetActualTokenSymbol`, providing two levels of resolution, but chains of 3+ aliases or circular references still fail [11](#0-10) 

**Economic Impact:**
- Users lose access to their token balances through alias-based queries
- Token metadata becomes inaccessible, breaking NFT marketplace integrations
- Cross-chain token operations can propagate broken alias chains to other chains, creating system-wide corruption that persists across the entire multi-chain ecosystem
- Smart contracts relying on alias resolution receive incorrect data, leading to flawed business logic execution

**Severity Justification:**
While this doesn't directly steal funds, it creates a permanent denial-of-service condition for affected tokens and can corrupt the alias mapping state across the entire system including cross-chain deployments. The impact extends to all users attempting to interact with the affected tokens through their aliases.

## Likelihood Explanation

**Attacker Capabilities:**
- Requires only standard NFT collection creation rights (seed NFT ownership or whitelist access)
- Standard token creation flow allows setting arbitrary `ExternalInfo` during the `Create` call
- No governance approval or trusted role needed beyond normal token creation permissions

**Attack Complexity:**
- Low complexity: Single transaction to create NFT collection with crafted `ExternalInfo` like `{"EXISTING_ALIAS":"NEW_ALIAS"}`
- No timing requirements or race conditions
- Exploitation works reliably every time
- The public `SetSymbolAlias` method also lacks validation and only checks that the alias doesn't already exist, not that the target symbol is valid [12](#0-11) 

**Feasibility Conditions:**
- Attacker needs ability to create NFT collections (standard user capability with seed NFT)
- Cost is minimal: standard token creation gas fees
- No preconditions beyond having one existing alias to target

**Detection Constraints:**
- Cannot be prevented by monitoring since `ExternalInfo` is a legitimate parameter
- No runtime checks exist to detect or prevent alias-to-alias mappings
- Test suite contains no tests for chained aliases or circular references [13](#0-12) 
- Silent failure mode makes detection difficult until users report operational issues

**Probability Assessment:**
HIGH - The attack is trivial to execute through normal contract interfaces, requires no special access beyond standard NFT collection creation rights, and has immediate effect.

## Recommendation

Add validation in `SetTokenAlias` to ensure the target symbol is a valid token and not an alias:

```csharp
private void SetTokenAlias(TokenInfo tokenInfo)
{
    var (symbol, alias) = ExtractAliasSetting(tokenInfo);
    
    // Validate that symbol is an actual token, not an alias
    var tokenInfo = State.TokenInfos[symbol];
    Assert(tokenInfo != null && !string.IsNullOrEmpty(tokenInfo.Symbol), 
        $"Symbol {symbol} must be a valid token, not an alias.");
    
    // Ensure symbol is not already mapped as an alias
    Assert(!State.SymbolAliasMap.Values.Contains(symbol), 
        $"Symbol {symbol} is already an alias and cannot be used as a target.");
    
    State.SymbolAliasMap[alias] = symbol;
    CheckTokenAlias(alias, tokenInfo.Symbol);
    
    Context.Fire(new SymbolAliasAdded
    {
        Symbol = symbol,
        Alias = alias
    });
}
```

Additionally, consider implementing recursive resolution in `GetActualTokenSymbol` with cycle detection:

```csharp
private string GetActualTokenSymbol(string aliasOrSymbol, int maxDepth = 10)
{
    var visited = new HashSet<string>();
    var current = aliasOrSymbol;
    
    while (maxDepth-- > 0)
    {
        if (State.TokenInfos[current] != null)
            return current;
            
        if (visited.Contains(current))
            throw new AssertionException($"Circular alias reference detected: {aliasOrSymbol}");
            
        visited.Add(current);
        var next = State.SymbolAliasMap[current];
        if (next == null)
            return current;
            
        current = next;
    }
    
    throw new AssertionException($"Alias chain too deep for: {aliasOrSymbol}");
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ChainedAliasResolution_Fails()
{
    // Setup: Create first NFT collection with valid alias
    var collection1 = await CreateNftCollectionAsync(new TokenInfo
    {
        Symbol = "COL1-",
        TokenName = "Collection 1",
        Decimals = 0,
        Issuer = DefaultAddress,
        ExternalInfo = new ExternalInfo
        {
            Value = { { TokenAliasExternalInfoKey, "{\"COL1-1\":\"COL1\"}" } }
        }
    });
    
    // Attack: Create second NFT collection with alias pointing to first alias
    var collection2Result = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "COL2-",
        TokenName = "Collection 2",
        Decimals = 0,
        Issuer = DefaultAddress,
        ExternalInfo = new ExternalInfo
        {
            Value = { { TokenAliasExternalInfoKey, "{\"COL1\":\"COL2\"}" } }
        }
    });
    
    // Verify: Alias chain exists but resolution fails
    // COL2 -> COL1 -> COL1-1 (actual token)
    var symbolFromAlias = await TokenContractStub.GetSymbolByAlias.CallAsync(
        new StringValue { Value = "COL2" });
    symbolFromAlias.Value.ShouldBe("COL1"); // Returns intermediate alias, not actual token
    
    // Balance query fails because "COL1" is not a real token
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "COL1-1",
        Amount = 100,
        To = DefaultAddress
    });
    
    var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = "COL2" // Using the chained alias
    });
    
    // Balance will be 0 or incorrect because resolution stops at "COL1"
    balance.Balance.ShouldBe(0); // Should be 100 if resolution worked correctly
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L39-48)
```csharp
    public override GetBalanceOutput GetBalance(GetBalanceInput input)
    {
        var symbol = GetActualTokenSymbol(input.Symbol);
        return new GetBalanceOutput
        {
            Symbol = input.Symbol,
            Owner = input.Owner,
            Balance = GetBalance(input.Owner, symbol)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L51-55)
```csharp
    public override GetAllowanceOutput GetAllowance(GetAllowanceInput input)
    {
        var symbol = GetActualTokenSymbol(input.Symbol);
        return new GetAllowanceOutput
        {
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L286-294)
```csharp
    private string GetActualTokenSymbol(string aliasOrSymbol)
    {
        if (State.TokenInfos[aliasOrSymbol] == null)
        {
            return State.SymbolAliasMap[aliasOrSymbol] ?? aliasOrSymbol;
        }

        return aliasOrSymbol;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-79)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L81-85)
```csharp
        if (IsAliasSettingExists(tokenInfo))
        {
            Assert(symbolType == SymbolType.NftCollection, "Token alias can only be set for NFT Item.");
            SetTokenAlias(tokenInfo);
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L261-268)
```csharp
    public override Empty Approve(ApproveInput input)
    {
        AssertValidInputAddress(input.Spender);
        var actualSymbol = GetActualTokenSymbol(input.Symbol);
        AssertValidApproveTokenAndAmount(actualSymbol, input.Amount);
        Approve(input.Spender, actualSymbol, input.Amount);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L492-505)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L738-779)
```csharp
    public override Empty SetSymbolAlias(SetSymbolAliasInput input)
    {
        // Alias setting can only work for NFT Item for now.
        // And the setting exists on the TokenInfo of the NFT Collection.

        // Can only happen on Main Chain.
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "Symbol alias setting only works on MainChain.");

        var collectionSymbol = GetNftCollectionSymbol(input.Symbol, true);

        // For now, token alias can only be set once.
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");

        CheckTokenAlias(input.Alias, collectionSymbol);

        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");

        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);

        State.SymbolAliasMap[input.Alias] = input.Symbol;

        Context.LogDebug(() => $"Token alias added: {input.Symbol} -> {input.Alias}");

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = input.Symbol,
            Alias = input.Alias
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L781-797)
```csharp
    private bool SyncSymbolAliasFromTokenInfo(TokenInfo newTokenInfo)
    {
        var maybePreviousTokenInfo = State.TokenInfos[newTokenInfo.Symbol]?.Clone();

        if (maybePreviousTokenInfo != null && IsAliasSettingExists(maybePreviousTokenInfo))
        {
            return false;
        }

        if (IsAliasSettingExists(newTokenInfo))
        {
            SetTokenAlias(newTokenInfo);
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L826-838)
```csharp
    private void SetTokenAlias(TokenInfo tokenInfo)
    {
        var (symbol, alias) = ExtractAliasSetting(tokenInfo);
        State.SymbolAliasMap[alias] = symbol;

        CheckTokenAlias(alias, tokenInfo.Symbol);

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = symbol,
            Alias = alias
        });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L840-852)
```csharp
    private void CheckTokenAlias(string alias, string collectionSymbol)
    {
        if (collectionSymbol == null)
        {
            throw new AssertionException("Token alias can only be set for NFT Item.");
        }

        // Current Rule: Alias must be the seed name.
        var parts = collectionSymbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(parts.Length == 2, $"Incorrect collection symbol: {collectionSymbol}.");
        Assert(parts.Last() == TokenContractConstants.CollectionSymbolSuffix, "Incorrect collection symbol suffix.");
        Assert(alias == parts.First(), $"Alias for an item of {collectionSymbol} cannot be {alias}.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L166-172)
```csharp
    private long GetBalance(Address address, string symbol)
    {
        AssertValidInputAddress(address);
        var actualSymbol = GetActualTokenSymbol(symbol);
        Assert(!string.IsNullOrWhiteSpace(actualSymbol), "Invalid symbol.");
        return State.Balances[address][actualSymbol];
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenAliasTests.cs (L1-379)
```csharp
using System.Threading.Tasks;
using AElf.Types;
using Google.Protobuf.WellKnownTypes;
using Shouldly;
using Xunit;

namespace AElf.Contracts.MultiToken;

public partial class MultiTokenContractTests
{
    public const string TokenAliasExternalInfoKey = "aelf_token_alias";

    [Fact]
    public async Task SetTokenAlias_NFTCollection_Test()
    {
        var symbols = await CreateNftCollectionAndNft();
        await TokenContractStub.SetSymbolAlias.SendAsync(new SetSymbolAliasInput
        {
            Symbol = symbols[1],
            Alias = "TP"
        });

        {
            // Check TokenInfo of NFT Collection.
            var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
            {
                Symbol = symbols[0]
            });
            tokenInfo.ExternalInfo.Value.ContainsKey(TokenAliasExternalInfoKey);
            tokenInfo.ExternalInfo.Value[TokenAliasExternalInfoKey].ShouldBe("{\"TP-31175\":\"TP\"}");
        }

        {
            // Check TokenInfo of NFT Item.
            var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
            {
                Symbol = "TP"
            });
            tokenInfo.Symbol.ShouldBe(symbols[1]);
        }

        {
            // Check alias.
            var alias = await TokenContractStub.GetTokenAlias.CallAsync(new StringValue { Value = "TP-31175" });
            alias.Value.ShouldBe("TP");
        }

        {
            var alias = await TokenContractStub.GetSymbolByAlias.CallAsync(new StringValue { Value = "TP" });
            alias.Value.ShouldBe("TP-31175");
        }
    }

    [Fact]
    public async Task SetTokenAlias_NFTCollection_CollectionSymbol_Test()
    {
        await CreateNftCollectionAndNft();
        await TokenContractStub.SetSymbolAlias.SendAsync(new SetSymbolAliasInput
        {
            Symbol = "TP-0",
            Alias = "TP"
        });

        {
            // Check TokenInfo of NFT Collection.
            var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
            {
                Symbol = "TP-0"
            });
            tokenInfo.ExternalInfo.Value.ContainsKey(TokenAliasExternalInfoKey);
            tokenInfo.ExternalInfo.Value[TokenAliasExternalInfoKey].ShouldBe("{\"TP-0\":\"TP\"}");
        }

        {
            // Check TokenInfo of NFT Item.
            var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
            {
                Symbol = "TP"
            });
            tokenInfo.Symbol.ShouldBe("TP-0");
        }

        {
            // Check alias.
            var alias = await TokenContractStub.GetTokenAlias.CallAsync(new StringValue { Value = "TP-0" });
            alias.Value.ShouldBe("TP");
        }

        {
            var alias = await TokenContractStub.GetSymbolByAlias.CallAsync(new StringValue { Value = "TP" });
            alias.Value.ShouldBe("TP-0");
        }
    }

    [Fact]
    public async Task SetTokenAlias_FT_Test()
    {
        await CreateNormalTokenAsync();

        // Set token alias for FT.
        var result = await TokenContractStub.SetSymbolAlias.SendWithExceptionAsync(new SetSymbolAliasInput
        {
            Symbol = AliceCoinTokenInfo.Symbol,
        });
        result.TransactionResult.Error.ShouldContain("Token alias can only be set for NFT Item.");
    }

    [Fact]
    public async Task CreateTokenWithAlias_Test()
    {
        var createCollectionResult = await CreateNftCollectionAsync(NftCollection1155WithAliasInfo);
        createCollectionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        await CreateNftAsync(NftCollection1155WithAliasInfo.Symbol, Nft721Info);

        {
            // Check alias.
            var alias = await TokenContractStub.GetTokenAlias.CallAsync(new StringValue { Value = "TP-31175" });
            alias.Value.ShouldBe("TP");
        }

        {
            // Check TokenInfo of NFT Item.
            var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
            {
                Symbol = "TP"
            });
            tokenInfo.Symbol.ShouldBe("TP-31175");
        }
    }

    [Fact]
    public async Task CreateTokenWithAlias_FT_Test()
    {
        var createInput = new CreateInput
        {
            Symbol = AliceCoinTokenInfo.Symbol,
            TokenName = AliceCoinTokenInfo.TokenName,
            TotalSupply = AliceCoinTokenInfo.TotalSupply,
            Decimals = AliceCoinTokenInfo.Decimals,
            Issuer = AliceCoinTokenInfo.Issuer,
            Owner = AliceCoinTokenInfo.Issuer,
            IsBurnable = AliceCoinTokenInfo.IsBurnable,
            LockWhiteList =
            {
                BasicFunctionContractAddress,
                OtherBasicFunctionContractAddress,
                TokenConverterContractAddress,
                TreasuryContractAddress
            },
            ExternalInfo = new ExternalInfo
            {
                Value =
                {
                    { TokenAliasExternalInfoKey, "{\"ALICE-111\":\"ALICE\"}" }
                }
            }
        };
        await CreateSeedNftAsync(TokenContractStub, createInput);
        var result = await TokenContractStub.Create.SendWithExceptionAsync(createInput);
        result.TransactionResult.Error.ShouldContain("Token alias can only be set for NFT Item.");
    }

    [Fact]
    public async Task TransferViaAlias_Test()
    {
        await CreateTokenWithAlias_Test();

        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = "TP-31175",
            Amount = 1,
            To = DefaultAddress
        });

        {
            var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = DefaultAddress,
                Symbol = "TP"
            });
            balance.Balance.ShouldBe(1);
        }

        await TokenContractStub.Transfer.SendAsync(new TransferInput
        {
            // Transfer via alias.
            Symbol = "TP",
            Amount = 1,
            To = User1Address
        });

        {
            var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = User1Address,
                Symbol = "TP"
            });
            balance.Balance.ShouldBe(1);
        }
    }

    [Fact]
    public async Task ApproveAndTransferFromViaAlias_Test()
    {
        await CreateTokenWithAlias_Test();

        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = "TP-31175",
            Amount = 1,
            To = DefaultAddress
        });

        await TokenContractStub.Approve.SendAsync(new ApproveInput
        {
            Symbol = "TP",
            Amount = 1,
            Spender = User1Address
        });

        await TokenContractStubUser.TransferFrom.SendAsync(new TransferFromInput
        {
            Symbol = "TP",
            Amount = 1,
            From = DefaultAddress,
            To = User2Address,
        });

        {
            var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = User2Address,
                Symbol = "TP"
            });
            balance.Balance.ShouldBe(1);
        }
    }

    [Fact]
    public async Task GetBalanceOfNotExistToken_Test()
    {
        var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = User2Address,
            Symbol = "TP"
        });
        balance.Balance.ShouldBe(0);
    }

    [Fact]
    public async Task GetAllowanceOfNotExistToken_Test()
    {
        var allowance = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
        {
            Owner = User2Address,
            Symbol = "TP",
            Spender = DefaultAddress
        });
        allowance.Allowance.ShouldBe(0);
    }

    [Fact]
    public async Task BatchApproveWithAlias_Test()
    {
        await SetTokenAlias_NFTCollection_Test();
        await CreateTokenAndIssue();
        var approveBasisResult = (await TokenContractStub.BatchApprove.SendAsync(new BatchApproveInput
        {
            Value =
            {
                new ApproveInput
                {
                    Symbol = SymbolForTest,
                    Amount = 2000L,
                    Spender = BasicFunctionContractAddress
                },
                new ApproveInput
                {
                    Symbol = "TP",
                    Amount = 1000L,
                    Spender = OtherBasicFunctionContractAddress
                },
                new ApproveInput
                {
                    Symbol = SymbolForTest,
                    Amount = 5000L,
                    Spender = TreasuryContractAddress
                }
            }
        })).TransactionResult;
        approveBasisResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var basicAllowanceOutput = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = BasicFunctionContractAddress,
            Symbol = SymbolForTest
        });
        basicAllowanceOutput.Allowance.ShouldBe(2000L);
        var otherBasicAllowanceOutput = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = OtherBasicFunctionContractAddress,
            Symbol = "TP"
        });
        otherBasicAllowanceOutput.Allowance.ShouldBe(1000L);
        var treasuryAllowanceOutput = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = TreasuryContractAddress,
            Symbol = SymbolForTest
        });
        treasuryAllowanceOutput.Allowance.ShouldBe(5000L);

        approveBasisResult = (await TokenContractStub.BatchApprove.SendAsync(new BatchApproveInput
        {
            Value =
            {
                new ApproveInput
                {
                    Symbol = "TP",
                    Amount = 1000L,
                    Spender = BasicFunctionContractAddress
                },
                new ApproveInput
                {
                    Symbol = SymbolForTest,
                    Amount = 3000L,
                    Spender = BasicFunctionContractAddress
                },
                new ApproveInput
                {
                    Symbol = SymbolForTest,
                    Amount = 3000L,
                    Spender = TreasuryContractAddress
                }
            }
        })).TransactionResult;
        approveBasisResult.Status.ShouldBe(TransactionResultStatus.Mined);
        basicAllowanceOutput = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = BasicFunctionContractAddress,
            Symbol = SymbolForTest
        });
        basicAllowanceOutput.Allowance.ShouldBe(3000L);

        treasuryAllowanceOutput = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = TreasuryContractAddress,
            Symbol = SymbolForTest
        });
        treasuryAllowanceOutput.Allowance.ShouldBe(3000L);
    }

    private TokenInfo NftCollection1155WithAliasInfo => new()
    {
        Symbol = "TP-",
        TokenName = "Trump Digital Trading Cards #1155",
        TotalSupply = TotalSupply,
        Decimals = 0,
        Issuer = DefaultAddress,
        IssueChainId = _chainId,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                {
                    NftCollectionMetaFields.ImageUrlKey,
                    "https://i.seadn.io/gcs/files/0f5cdfaaf687de2ebb5834b129a5bef3.png?auto=format&w=3840"
                },
                { NftCollectionMetaFields.NftType, NftType },
                { TokenAliasExternalInfoKey, "{\"TP-31175\":\"TP\"}" }
            }
        }
    };
}
```
