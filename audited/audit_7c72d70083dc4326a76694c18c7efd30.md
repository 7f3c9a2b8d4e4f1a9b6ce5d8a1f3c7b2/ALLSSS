### Title
Manager Can Erase Self-Registered User Shares via AddBeneficiary Due to Uncaptured Return Value

### Summary
The `AddBeneficiary` method in TokenHolderContract fails to capture the return value of the `shares.Add()` extension method, causing existing beneficiary shares to be discarded instead of accumulated. This allows a scheme manager to arbitrarily reduce or eliminate profit shares of users who self-registered via `RegisterForProfits` and locked tokens, while those tokens remain locked.

### Finding Description

**Root Cause Location:** [1](#0-0) 

The `AddBeneficiary` method attempts to preserve existing beneficiary shares when re-adding a beneficiary, but fails due to not capturing the return value of the `Add` extension method.

**Technical Details:**

The `Add` method is a SafeMath extension that returns a new value rather than modifying the original: [2](#0-1) 

In `AddBeneficiary`, when a beneficiary already exists, the code retrieves their existing shares, removes them, and attempts to combine old and new shares: [3](#0-2) 

Line 55 calls `shares.Add(detail.Details.Single().Shares)` but does not assign the result back to `shares`. The correct code should be: `shares = shares.Add(detail.Details.Single().Shares)`.

**Why Existing Protections Fail:**

1. Authorization only checks that `Context.Sender` is the scheme manager - there is no distinction between manager-added and self-registered beneficiaries: [4](#0-3) 

2. The underlying Profit contract allows both manager and TokenHolder contract to modify beneficiaries, with no separation of concerns: [5](#0-4) 

3. Users who call `RegisterForProfits` lock tokens and receive shares equal to locked amount: [6](#0-5) 

4. These locked tokens cannot be withdrawn until the minimum lock period expires: [7](#0-6) 

**Execution Path:**
1. User calls `RegisterForProfits(amount=1000)` → locks 1000 tokens, gets 1000 shares
2. Manager calls `AddBeneficiary(beneficiary=User, shares=100)` → line 55 fails to add shares → User re-added with only 100 shares
3. User's 1000 tokens remain locked but profit entitlement reduced by 90%

### Impact Explanation

**Direct Financial Impact:**
- Users lose profit entitlement proportional to the difference between their locked token amount and manager-assigned shares
- If User locked 1000 tokens (1000 shares) and manager assigns 1 share, user loses 99.9% of profit entitlement
- Tokens remain locked for the minimum period while shares are arbitrarily reduced
- Total scheme shares decrease, causing all other beneficiaries (including manager) to receive proportionally larger dividends at expense of manipulated users

**Affected Parties:**
- All users who self-register via `RegisterForProfits` are vulnerable to share manipulation by the scheme manager
- Legitimate users bear opportunity cost of locked tokens with minimal/no profit returns

**Severity Justification:**
HIGH severity due to:
- Direct theft/misallocation of profit distributions
- Asymmetric impact: user's capital locked, manager's share allocation unrestricted
- No on-chain mechanism to detect or prevent the manipulation
- Violation of core invariant: "Profit/Treasury/TokenHolder share calculations... dividend distribution and settlement accuracy"

### Likelihood Explanation

**Attacker Capabilities:**
- Requires scheme manager role (legitimate but potentially malicious manager)
- Manager role is obtained by calling `CreateScheme` - any address can become a manager for their own schemes [8](#0-7) 

**Attack Complexity:**
- Simple: Single transaction calling `AddBeneficiary` with manipulated share values
- No complex preconditions or timing requirements
- Does not require exploiting multiple contracts or edge cases

**Feasibility Conditions:**
- Users must have registered via `RegisterForProfits` (normal expected usage)
- Manager calls `AddBeneficiary` on those users (legitimate function, used maliciously)
- No external dependencies or special states required

**Detection Constraints:**
- Behavior appears as legitimate manager action
- Existing test case documents this behavior as expected: [9](#0-8) 
The test shows TotalShares becomes 2 (not 3) after adding 1 then 2 shares, confirming shares are replaced rather than accumulated.

**Probability Assessment:**
HIGH likelihood because:
- Bug affects core functionality called in normal operations
- Manager incentive exists to maximize own share of profits
- No technical barriers prevent execution
- Pattern could occur unintentionally through legitimate manager operations

### Recommendation

**Code-Level Mitigation:**
Fix line 55 in `TokenHolderContract.cs` to capture the return value:
```csharp
shares = shares.Add(detail.Details.Single().Shares);
```

**Additional Invariant Checks:**
1. Add separation between manager-controlled shares and user-locked shares by tracking them in separate ProfitDetail entries with distinct IDs
2. Prevent `AddBeneficiary` from being called on addresses that have active locks via `RegisterForProfits`:
```csharp
Assert(State.LockIds[Context.Sender][input.Beneficiary] == null, 
    "Cannot use AddBeneficiary on self-registered users with active locks.");
```

3. Add events that emit both old and new share amounts when modifying beneficiaries to enable off-chain monitoring

**Test Cases:**
1. Test that calls `RegisterForProfits(1000)` then `AddBeneficiary(100)` and verifies TotalShares equals 1100 (not 100)
2. Test that users can withdraw locked tokens with correct shares preserved
3. Test profit distribution calculations match locked token amounts for self-registered users

### Proof of Concept

**Initial State:**
- Manager creates TokenHolder scheme with symbol "ELF", minimum lock time 10 minutes
- User has 1000 ELF tokens, approves TokenHolder contract

**Transaction Sequence:**

1. **User self-registers (Period 0):**
   - User calls `RegisterForProfits(schemeManager=Manager, amount=1000)`
   - Expected: User's 1000 ELF locked, ProfitDetails[User].Shares = 1000, scheme.TotalShares = 1000

2. **Manager manipulates shares (Period 0):**
   - Manager calls `AddBeneficiary(beneficiary=User, shares=50)`
   - Line 40-44: Retrieves User's ProfitDetails (1000 shares)
   - Line 50-54: Removes User as beneficiary
   - Line 55: Calls `shares.Add(1000)` but result not captured
   - Line 58-66: Re-adds User with shares=50 (not 1050)
   - Actual Result: ProfitDetails[User].Shares = 50, scheme.TotalShares = 50

3. **Profit distribution (Period 1):**
   - 1000 ELF contributed to scheme
   - User receives 1000 × (50/50) = 1000 ELF if sole beneficiary
   - BUT if Manager also has 950 shares: User receives 1000 × (50/1000) = 50 ELF instead of expected 500 ELF
   - User lost 95% of profit entitlement while 1000 tokens remain locked

**Success Condition:**
After step 2, querying `GetProfitDetails(User)` returns Shares=50 instead of expected 1050, demonstrating the vulnerability. The locked tokens cannot be withdrawn yet minimum lock period has not elapsed, proving user capital is trapped with reduced profit rights.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-39)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L40-66)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }

        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = shares
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L168-176)
```csharp
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-105)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L120-134)
```csharp
    public async Task AddBeneficiary_Repeatedly_Test()
    {
        await AddBeneficiaryTest();
        var tokenHolderProfitScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
        var newShare = 2;
        await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
        {
            Beneficiary = UserAddresses.First(),
            Shares = newShare
        });

        {
            var originScheme = await ProfitContractStub.GetScheme.CallAsync(tokenHolderProfitScheme.SchemeId);
            originScheme.TotalShares.ShouldBe(newShare);
        }
```
