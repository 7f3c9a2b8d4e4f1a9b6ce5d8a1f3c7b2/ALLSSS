# Audit Report

## Title
TokenConverter Deposit Balance Manipulation via EnableConnector Re-enabling Attack

## Summary
The `EnableConnector` function lacks protection against multiple invocations and uses a SET operation to overwrite accumulated deposit balances. An attacker can donate resource tokens to manipulate the balance calculation in `GetNeededDeposit`, then call `EnableConnector` to overwrite `State.DepositBalance` with an artificially low value, breaking the Bancor reserve ratio and enabling token purchases at manipulated prices.

## Finding Description

The vulnerability stems from three critical design flaws in the TokenConverter contract's `EnableConnector` function:

**1. Asymmetric Balance Tracking**

The contract establishes asymmetric balance tracking where resource token connectors use `IsDepositAccount = false` [1](#0-0) , causing their balance to be read from the actual MultiToken contract balance [2](#0-1) . In contrast, native token (deposit) connectors use `IsDepositAccount = true` [3](#0-2) , reading from internal `State.DepositBalance` accounting.

**2. Missing Re-enable Protection**

The `EnableConnector` function lacks any check to prevent re-enabling already active connectors [4](#0-3) . This contrasts with `UpdateConnector`, which explicitly prevents updates after activation [5](#0-4) . Additionally, there is no authorization check (no `AssertPerformedByConnectorController()` call), unlike other administrative functions.

**3. Overwrite Instead of Addition**

The critical line uses a SET operation (`=`) rather than ADD (`+=`) to establish deposit balance [6](#0-5) . This overwrites any previously accumulated balance from legitimate `Buy` operations [7](#0-6) .

**4. Manipulable Balance Calculation**

The `GetNeededDeposit` function queries the actual token balance from the MultiToken contract [8](#0-7) , which can be inflated through direct token transfers. This inflated balance reduces the calculated `amountOutOfTokenConvert` [9](#0-8) , resulting in a lower `needDeposit` value [10](#0-9) .

**Attack Execution:**

1. Legitimate `Buy` operations accumulate significant `State.DepositBalance[ntSymbol]` (e.g., 1,000,000 ELF)
2. Attacker directly transfers X resource tokens to the TokenConverter contract
3. Attacker calls `EnableConnector` with the resource token symbol
4. `GetNeededDeposit` calculates a lower deposit requirement due to the inflated balance
5. Line 297 overwrites the accumulated deposit balance with the manipulated lower value
6. The Bancor formula now operates with severely imbalanced reserves (high resource tokens, low recorded deposits)
7. Subsequent buyers can purchase resource tokens at artificially deflated prices, extracting value from the protocol

## Impact Explanation

**Financial Impact:** The attack directly compromises the protocol's financial integrity by manipulating the Bancor reserve ratio. When `State.DepositBalance` is artificially lowered while the actual resource token balance remains high (or is inflated), the Bancor pricing formula used in `Buy` operations [11](#0-10)  produces incorrect prices.

**Quantified Loss:** If legitimate operations accumulated 1,000,000 ELF in deposits and an attacker donates 500,000 resource tokens, the recalculated deposit might drop to 100,000 ELF or even zero (if enough tokens are donated to make `amountOutOfTokenConvert <= 0`). This creates massive price distortion, allowing users to buy resource tokens at 90%+ discounts.

**Protocol Solvency:** The protocol loses the difference between the actual accumulated deposit value and the manipulated recorded value. All subsequent trading is affected by the distorted pricing, leading to systematic value extraction until the imbalance is corrected.

**Severity:** HIGH - Direct financial loss, protocol invariant break (Bancor reserve integrity), affects all users through manipulated pricing.

## Likelihood Explanation

**Attacker Requirements:**
- Ability to transfer resource tokens to the contract (publicly available, no restrictions)
- Ability to call `EnableConnector` function (public, no authorization check)
- Capital: Amount of resource tokens for donation (moderate, depends on desired manipulation scale)

**Attack Complexity:** LOW
- Only two simple operations: token transfer + function call
- No complex timing requirements
- No need for governance privileges or special access
- No sophisticated state manipulation needed

**Economic Feasibility:** For high-value tokens with substantial accumulated deposits, the attack becomes economically rational. The cost of donated tokens (which remain in the contract but unaccounted) must be weighed against the profit from buying tokens at manipulated prices. For valuable resource tokens with large deposit pools, this calculation favors the attacker.

**Detection Difficulty:** Token transfers to the contract appear as normal operations. `EnableConnector` calls might appear legitimate for new connector activation. Price manipulation may only be detected after exploitation when users notice abnormal pricing.

**Probability:** MEDIUM to HIGH - Technically trivial to execute, publicly accessible, requires moderate capital. The main barrier is economic viability, which increases with token value and deposit pool size.

## Recommendation

Implement the following protections in `EnableConnector`:

1. **Add re-enable protection:**
```csharp
Assert(!toConnector.IsPurchaseEnabled, "Connector already enabled");
Assert(!fromConnector.IsPurchaseEnabled, "Connector already enabled");
```

2. **Add authorization check:**
```csharp
AssertPerformedByConnectorController();
```

3. **Consider using ADD instead of SET for deposit balance** (if re-enabling is intended behavior):
```csharp
State.DepositBalance[toConnector.Symbol] = 
    State.DepositBalance[toConnector.Symbol].Add(needDeposit.NeedAmount);
```

4. **Validate that the connector is in the expected initial state** before enabling, ensuring deposit balance is zero or below expected threshold.

The most critical fix is adding the re-enable protection check, which prevents the attack entirely by disallowing multiple invocations of `EnableConnector` on already-active connectors.

## Proof of Concept

```csharp
// Test: Demonstrate EnableConnector re-enable attack
[Fact]
public async Task EnableConnector_ReenableAttack_ManipulatesDepositBalance()
{
    // Setup: Initialize connector pair (CPU resource and (NT)CPU deposit)
    // Assume connectors already exist and are enabled
    
    // Step 1: Legitimate Buy operations accumulate deposit balance
    await TokenConverterStub.Buy.SendAsync(new BuyInput
    {
        Symbol = "CPU",
        Amount = 1000,
        PayLimit = 10000
    });
    // State.DepositBalance["(NT)CPU"] now has accumulated value
    
    var depositBeforeAttack = await TokenConverterStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = "CPU" });
    
    // Step 2: Attacker donates CPU tokens to manipulate balance calculation
    await TokenStub.Transfer.SendAsync(new TransferInput
    {
        To = TokenConverterAddress,
        Symbol = "CPU",
        Amount = 100000 // Large donation to inflate balance
    });
    
    // Step 3: Attacker calls EnableConnector (should fail but doesn't)
    var result = await TokenConverterStub.EnableConnector.SendAsync(
        new ToBeConnectedTokenInfo
        {
            TokenSymbol = "CPU",
            AmountToTokenConvert = 0
        });
    
    // Verify: Deposit balance has been overwritten to lower value
    var depositAfterAttack = await TokenConverterStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = "CPU" });
    
    // Assert: Deposit balance decreased (VULNERABILITY DEMONSTRATED)
    Assert.True(depositAfterAttack.Value < depositBeforeAttack.Value,
        "Deposit balance was manipulated through re-enabling");
    
    // Impact: Resource tokens can now be bought at artificially low prices
    var priceAfter = CalculateBuyPrice("CPU", 1000);
    // priceAfter is now significantly lower than it should be
}
```

**Note:** This test demonstrates the core vulnerability where `EnableConnector` can be called on already-enabled connectors, overwriting accumulated deposit balances with manipulated values calculated from donated token balances.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L64-64)
```csharp
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L87-93)
```csharp
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L96-108)
```csharp
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L141-141)
```csharp
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L67-72)
```csharp
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-73)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L75-84)
```csharp
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```
