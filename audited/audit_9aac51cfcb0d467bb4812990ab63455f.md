### Title
Quadratic Complexity in Round Generation Can Cause Consensus DoS via Unbounded MaximumMinersCount

### Summary
The `GenerateNextRoundInformation()` function contains O(N²) computational complexity at line 41 when creating the `ableOrders` list, combined with an O(N) loop at lines 42-56. With no upper bound validation on `SetMaximumMinersCount`, governance could set an excessively large miner count, causing block production to timeout during round transitions and resulting in consensus failure.

### Finding Description

The vulnerability exists in the round generation logic that executes during block production when miners need to transition to the next round. [1](#0-0) 

**Primary Issue - O(N²) Complexity at Line 41:**
The creation of `ableOrders` uses `Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i))`. Since `List<T>.Contains()` is O(n), this results in O(minersCount × occupiedOrders.Count) complexity. In the worst case where half the miners produce blocks, this becomes O(N²/2). For N=10,000 miners, this is approximately 50 million comparison operations.

**Secondary Issue - Loop at Lines 42-56:**
The loop iterates `minersNotMinedCurrentRound.Count` times (bounded by minersCount), performing dictionary insertions and object creations. While each iteration is O(1), with N=10,000 this adds 10,000 additional operations.

**No Upper Bound Validation:** [2](#0-1) 

The `SetMaximumMinersCount` function only validates `input.Value > 0` with no upper bound check. This allows governance to set arbitrarily large values including Int32.MaxValue (~2 billion).

**Critical Execution Path:** [3](#0-2) 

This function is called during block production when generating consensus extra data for the next round, making it a critical consensus path where timeouts directly impact block production.

### Impact Explanation

**Consensus DoS:**
If `MaximumMinersCount` is set to a large value (e.g., 10,000) and enough candidates exist in the election system to fill these slots, the O(N²) operation would perform approximately 50 million comparisons plus 10,000 loop iterations during each round transition. This could exceed block mining time limits, causing:
- Current miner unable to produce blocks within their time slot
- Round transition failures preventing consensus progress
- Complete consensus halt if the issue persists across multiple time slots

**Who Is Affected:**
All network participants are affected as block production stops, preventing any transactions from being processed.

**Severity Justification:**
MEDIUM severity is appropriate because:
- **High Impact**: Complete consensus failure and network halt
- **Low-Medium Likelihood**: Requires governance to set unrealistic miner counts, but no technical barrier prevents this

### Likelihood Explanation

**Attack Vector:**
1. Governance proposes and passes a vote to set `MaximumMinersCount` to a large value (e.g., 10,000+)
2. Over time, the auto-increase mechanism or direct miner list updates cause actual miner count to approach this limit [4](#0-3) 
3. Election system has sufficient candidates to fill the slots [5](#0-4) 
4. During round transition, `GenerateNextRoundInformation` executes with large minersCount
5. O(N²) operation causes timeout in consensus block generation

**Feasibility:**
- **Governance Control**: Parliament (default controller) could pass such a proposal either maliciously or through misconfiguration [6](#0-5) 
- **No Technical Barriers**: No upper bound validation exists
- **Practical Constraints**: Typical DPoS systems have 21-101 validators, but reaching thousands is theoretically possible given enough time and candidates

**Detection:**
Easy to detect as block production would visibly halt or slow significantly.

### Recommendation

**1. Add Upper Bound Validation:**
Modify `SetMaximumMinersCount` to enforce a reasonable maximum (e.g., 1,000 or based on system requirements):
```csharp
public override Empty SetMaximumMinersCount(Int32Value input)
{
    EnsureElectionContractAddressSet();
    
    Assert(input.Value > 0, "Invalid max miners count.");
    Assert(input.Value <= MAXIMUM_ALLOWED_MINERS_COUNT, "Exceeds maximum allowed miner count.");
    // ... rest of implementation
}
```

**2. Optimize Line 41 Complexity:**
Replace the O(N²) list Contains operation with an O(N) HashSet lookup:
```csharp
var occupiedOrdersSet = new HashSet<int>(minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound));
var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrdersSet.Contains(i)).ToList();
```

**3. Add Execution Time Monitoring:**
Add logging or assertions to detect when round generation takes excessive time, allowing operators to identify misconfigurations before they cause consensus failure.

**4. Test Cases:**
- Test `SetMaximumMinersCount` with boundary values (0, negative, very large)
- Test round generation performance with 100, 1000, 10000 miners
- Test consensus timeout behavior with large miner counts

### Proof of Concept

**Initial State:**
- Consensus contract deployed and initialized
- Parliament governance active
- Default MaximumMinersCount = 17

**Attack Sequence:**
1. Parliament proposes `SetMaximumMinersCount(10000)`
2. Proposal passes and executes [7](#0-6) 
3. Over time (or through rapid candidate registration), election system accumulates sufficient candidates
4. During term transition, `GetVictories` returns large miner list
5. `GenerateNextRoundInformation` is called during round transition
6. Line 41 performs ~50 million operations (10000 × 5000)
7. Block production times out as consensus extra data generation exceeds time limit
8. Miner misses their time slot, round cannot progress

**Expected Result:** Block produced normally within time slot
**Actual Result:** Block production timeout, consensus DoS

**Success Condition:** Network halt observable when MaximumMinersCount set to excessive value with sufficient candidates to approach that limit.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-56)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-28)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L31-43)
```csharp
    private void RequiredMaximumMinersCountControllerSet()
    {
        if (State.MaximumMinersCountController.Value != null) return;
        EnsureParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MaximumMinersCountController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-187)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```
