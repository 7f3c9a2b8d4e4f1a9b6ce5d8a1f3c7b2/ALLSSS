### Title
Banned Miners Can Be Re-Selected Through GetVictories Backup Mechanism

### Summary
The `GetVictories()` function's backup selection mechanism fails to check `State.BannedPubkeyMap` when selecting miners from `currentMiners` and `InitialMiners` lists. This allows evil/banned nodes that were marked for exclusion to be automatically re-selected as block producers for the next consensus term, completely bypassing the node banning security mechanism.

### Finding Description

The vulnerability exists in the private `GetVictories()` method in the Election contract. When there are insufficient valid candidates (candidates with active votes), the function uses a backup mechanism to fill the required miner count: [1](#0-0) 

The critical flaw occurs at lines 66-74 where the backup selection logic:
1. Adds current miners that aren't in validCandidates (line 66)
2. Adds initial miners not already in backups (lines 67-69)  
3. Takes miners from this backup list without any banned status verification (lines 71-74)

The `GetValidCandidates()` method only filters candidates based on having votes > 0, not banned status: [2](#0-1) 

When miners are banned through `UpdateCandidateInformation(IsEvilNode=true)`, they are marked in `State.BannedPubkeyMap` and removed from the candidates list: [3](#0-2) 

Similarly, when pubkeys are replaced, the old pubkey is banned: [4](#0-3) 

**Why Existing Protections Fail:**

The contract has a properly functioning `GetMinerReplacementInformation()` method that DOES check for banned miners during mid-term replacement: [5](#0-4) [6](#0-5) 

However, `GetVictories()` lacks this same validation when selecting backups for new term generation.

**Execution Path:**

The consensus contract calls `GetVictories()` to determine miners for the next term: [7](#0-6) 

This occurs during first round generation of a new term: [8](#0-7) 

### Impact Explanation

**Consensus Integrity Violation:**
- Evil/banned nodes that were explicitly marked for exclusion via `UpdateCandidateInformation(IsEvilNode=true)` can automatically rejoin consensus in the next term
- Completely defeats the node banning security mechanism designed to protect the network
- Allows continued block production by malicious nodes that should be permanently excluded

**Who Is Affected:**
- The entire blockchain network's security and liveness
- Honest miners who must operate alongside nodes that were banned for malicious behavior
- Token holders who rely on consensus integrity for asset security

**Severity Justification:**
This is **Critical** because:
1. It directly violates the "miner schedule integrity" invariant under Consensus & Cross-Chain critical invariants
2. Banned nodes can continue earning block rewards they should not receive
3. Malicious behavior that caused the ban (e.g., censoring transactions, double-signing) can continue
4. No manual intervention can prevent this - it happens automatically at term transitions

### Likelihood Explanation

**Attack Preconditions:**
1. The number of valid candidates (with votes > 0) must be less than `State.MinersCount.Value` (triggers `diff > 0` condition)
2. A miner must be in `currentMiners` or `InitialMiners` lists
3. That miner must have been banned via `UpdateCandidateInformation(IsEvilNode=true)` or `ReplaceCandidatePubkey`

**Attacker Capabilities Required:**
- None. This vulnerability triggers automatically during normal term transitions. The banned node doesn't need to take any action - the system re-selects them automatically.

**Feasibility:**
- **High Probability**: In chains with low election participation or during bootstrap phases, having insufficient valid candidates is common
- **Zero Attack Complexity**: No special transactions or exploits needed - happens through normal consensus operation
- **Undetectable**: Appears as legitimate term transition; no distinguishable attack signature

**Realistic Scenario:**
1. Network has 5 initial miners, requires 5 miners per term
2. Only 3 candidates announce election and receive votes (validCandidates = 3)
3. One initial miner gets banned for evil behavior during term N
4. At term N+1 start, `GetVictories()` is called: diff = 5 - 3 = 2
5. Backup mechanism adds initial miners to fill gap
6. The banned initial miner is added WITHOUT ban check
7. Banned miner operates in term N+1 despite being marked as evil

### Recommendation

**Immediate Fix:**
Add banned status validation in the backup selection logic. Modify lines 66-74 in `GetVictories()`:

```csharp
// Line 66: Filter currentMiners for banned status
var backups = currentMiners
    .Where(k => !validCandidates.Contains(k))
    .Where(k => !State.BannedPubkeyMap[k])  // ADD THIS CHECK
    .ToList();

// Lines 67-69: Filter InitialMiners for banned status  
if (State.InitialMiners.Value != null)
    backups.AddRange(
        State.InitialMiners.Value.Value.Select(k => k.ToHex())
            .Where(k => !backups.Contains(k))
            .Where(k => !State.BannedPubkeyMap[k]));  // ADD THIS CHECK
```

**Invariant to Enforce:**
- All miners in the victories list returned by `GetVictories()` must have `State.BannedPubkeyMap[pubkey] == false`
- Add assertion before returning: `Assert(victories.All(v => !State.BannedPubkeyMap[v.ToHex()]), "Cannot select banned miners");`

**Regression Test:**
Create unit test that:
1. Initializes election contract with initial miners
2. Bans one initial miner via `UpdateCandidateInformation(IsEvilNode=true)`
3. Creates scenario with insufficient valid candidates
4. Calls `GetVictories()` 
5. Verifies banned miner is NOT in returned victories list

### Proof of Concept

**Initial State:**
- 5 initial miners: M1, M2, M3, M4, M5
- MinersCount = 5 (requires 5 miners)
- Only 2 candidates with votes: C1, C2
- Current term miners: M1, M2, M3, M4, M5

**Attack Steps:**

1. **Ban Initial Miner M3:**
   - Consensus contract or emergency organization calls `UpdateCandidateInformation`
   - Input: `{ Pubkey: "M3", IsEvilNode: true }`
   - Result: `State.BannedPubkeyMap["M3"] = true`, M3 removed from candidates

2. **Term Transition Occurs:**
   - Consensus contract calls `State.ElectionContract.GetVictories.Call(new Empty())`
   - `GetValidCandidates()` returns [C1, C2] (count = 2)
   - `diff = 5 - 2 = 3` (need 3 more miners)

3. **Backup Selection Executes:**
   - Line 66: `backups = currentMiners.Where(k => !validCandidates.Contains(k))` 
   - Returns [M1, M2, M3, M4, M5] (M3 included despite being banned!)
   - Lines 71-74: Take first 3 from backups = [M1, M2, M3]

4. **Result:**
   - victories = [C1, C2, M1, M2, M3]
   - Consensus contract uses this list for term N+1
   - **M3 (banned evil node) is now a miner in the new term**

**Expected vs Actual:**
- **Expected:** victories = [C1, C2, M1, M2, M4] (M3 excluded as banned)
- **Actual:** victories = [C1, C2, M1, M2, M3] (M3 incorrectly included)

**Success Condition:**
The banned miner M3 appears in the `GetVictories()` return value and is subsequently added to the consensus miner list for the next term, despite having `State.BannedPubkeyMap["M3"] == true`.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-391)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L245-246)
```csharp
        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-232)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```
