### Title
Off-By-One Error in Continuous Block Production Limit Allows Miners to Exceed Maximum Consecutive Blocks

### Summary
The validation check for continuous block production uses `BlocksCount < 0` instead of `BlocksCount <= 0`, allowing miners to produce 9 consecutive blocks instead of the intended maximum of 8. This off-by-one error exists in both the validation logic and consensus command generation, enabling any miner to gain a 12.5% unfair advantage in consecutive block production.

### Finding Description

The vulnerability exists in two critical locations where `BlocksCount` is checked to prevent excessive continuous block production:

**Location 1: Validation Check** [1](#0-0) 

The validation only rejects when `BlocksCount < 0`, allowing `BlocksCount == 0` to pass.

**Location 2: Command Generation** [2](#0-1) 

Similarly, the forced `NextRound` behavior only triggers when `BlocksCount < 0`.

**Root Cause:**
The `BlocksCount` field represents remaining blocks allowed. It starts at 7 (MaximumTinyBlocksCount - 1) and decrements with each block: [3](#0-2) [4](#0-3) 

**Execution Flow:**
1. First block: `BlocksCount` initialized to 7
2. Blocks 2-8: `BlocksCount` decrements from 7 to 1, each validation passes (not < 0)
3. **Block 9: `BlocksCount = 0`, validation check `0 < 0` is FALSE, validation PASSES** (BUG)
4. After block 9: `BlocksCount` decrements to -1
5. Block 10: `BlocksCount = -1`, validation check `-1 < 0` is TRUE, validation FAILS

The validation occurs before block processing: [5](#0-4) 

### Impact Explanation

**Direct Consensus Impact:**
- Miners can produce 9 consecutive blocks instead of 8, exceeding the maximum by 12.5%
- Violates the core invariant designed to prevent blockchain centralization
- Unfair distribution of block production power among miners

**Reward Misallocation:**
- Extra block production translates to additional mining rewards
- Systematic advantage accumulates over time for any miner exploiting this
- Undermines fair reward distribution mechanisms

**Consensus Integrity:**
- The limit exists to prevent issues from one miner dominating block production (as documented in the validation context) [6](#0-5) 

- Exceeding this limit could cause the problems this mechanism was designed to prevent

**Severity: Medium** - While not causing direct fund theft, it provides an unfair consensus advantage and violates protocol invariants for continuous block production limits.

### Likelihood Explanation

**Reachable Entry Point:**
Any miner in the consensus pool can reach this code path through normal block production. The validation is triggered automatically via: [7](#0-6) 

**Feasible Preconditions:**
- Attacker must be a valid miner in the current consensus round
- No additional permissions or special conditions required
- Happens naturally when producing consecutive blocks

**Execution Practicality:**
- Simply produce blocks consecutively until `BlocksCount` reaches 0
- The system allows the 9th block automatically due to the flawed check
- No complex transaction sequences or timing manipulations needed

**Economic Rationality:**
- Zero additional cost beyond normal block production
- Direct benefit: extra block reward for the 9th block
- No risk of detection as it's permitted by the validation logic

**Detection Constraints:**
- No monitoring exists to flag this behavior
- Appears as legitimate consecutive block production
- Cannot be distinguished from normal operation

**Probability: High** - Will occur naturally whenever any miner produces maximum consecutive blocks. The vulnerability is deterministic and exploitable by all miners.

### Recommendation

**Immediate Fix:**
Change the boundary check from `<` to `<=` in both locations:

1. In `ContinuousBlocksValidationProvider.ValidateHeaderInformation()`:
```csharp
if (latestPubkeyToTinyBlocksCount.BlocksCount <= 0)  // Changed from < 0
{
    validationResult.Message = "Sender produced too many continuous blocks.";
    return validationResult;
}
```

2. In `GetConsensusCommand()`:
```csharp
if (State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount <= 0)  // Changed from < 0
    return GetConsensusCommand(AElfConsensusBehaviour.NextRound, ...);
```

**Invariant Enforcement:**
Add explicit assertion that `BlocksCount` semantics are preserved:
- When `BlocksCount == 0`, it should mean "zero remaining blocks allowed"
- The check must prevent any block production when remaining count is 0 or negative

**Test Cases:**
Add regression tests to verify:
1. Miner producing exactly 8 consecutive blocks succeeds
2. Attempt to produce 9th consecutive block fails validation
3. `BlocksCount == 0` triggers rejection and forces `NextRound` behavior
4. Proper reset behavior when different miner produces block

### Proof of Concept

**Initial State:**
- Consensus initialized with multiple miners
- `State.LatestPubkeyToTinyBlocksCount.Value` is null
- Miner A is in the valid miner list for current round

**Exploitation Steps:**

1. **Block 1 by Miner A:**
   - Validation: `latestPubkeyToTinyBlocksCount == null`, validation passes
   - Processing: `BlocksCount` set to 7
   - Result: Block mined successfully

2. **Blocks 2-8 by Miner A:**
   - Validation: `BlocksCount` ranges from 7 down to 1, check `X < 0` is false for all, validation passes
   - Processing: `BlocksCount` decrements each time
   - Result: All blocks mined successfully

3. **Block 9 by Miner A (Exploit):**
   - Validation: `BlocksCount == 0`, check `0 < 0` evaluates to FALSE
   - **Expected:** Validation should fail (9 > MaximumTinyBlocksCount)
   - **Actual:** Validation PASSES due to off-by-one error
   - Processing: `BlocksCount` decremented to -1
   - Result: **9th consecutive block mined successfully (EXPLOIT SUCCESS)**

4. **Block 10 by Miner A:**
   - Validation: `BlocksCount == -1`, check `-1 < 0` is true, validation FAILS
   - Result: Block rejected with message "Sender produced too many continuous blocks"

**Success Condition:**
Miner A successfully produces 9 consecutive blocks instead of the maximum allowed 8, demonstrating the off-by-one vulnerability that allows exceeding the continuous block production limit by 12.5%.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-74)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L34-38)
```csharp
    /// <summary>
    ///     This filed is to prevent one miner produces too many continues blocks
    ///     (which may cause problems to other parts).
    /// </summary>
    public LatestPubkeyToTinyBlocksCount LatestPubkeyToTinyBlocksCount { get; set; }
```
