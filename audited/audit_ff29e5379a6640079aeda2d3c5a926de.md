### Title
Permanent Authorization Escalation via ChangeMethodFeeController Allows Temporary Parliament Control to Become Permanent Method Fee Control

### Summary
An attacker who temporarily gains control of the Parliament default organization (e.g., by compromising 51%+ block producer nodes) can escalate this temporary access to permanent control over the Genesis contract's method fee controller by calling `ChangeMethodFeeController` to transfer control to a malicious Association organization they control permanently. The validation only checks organization existence, not security properties, allowing substitution of a decentralized Parliament with a single-member Association.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController` function which validates only that the new organization exists, but does not validate its security properties or governance equivalence to the original controller. [1](#0-0) 

The authorization check requires the sender to be the current controller's OwnerAddress (typically Parliament default organization), which an attacker with temporary Parliament control satisfies: [2](#0-1) 

The organization validation only verifies existence via `CheckOrganizationExist`, which makes a cross-contract call to `ValidateOrganizationExist`: [3](#0-2) 

The `ValidateOrganizationExist` implementation in both Parliament and Association contracts only checks if the organization exists in state storage: [4](#0-3) [5](#0-4) 

**Root Cause**: The validation logic fails to verify that the new controller organization maintains equivalent security properties (member count, approval thresholds, governance structure) to the original Parliament-based controller. This allows an attacker to substitute a decentralized Parliament organization (requiring majority BP approval) with a centralized Association organization (single member, minimal thresholds).

**Test Evidence**: The codebase explicitly supports and tests changing from Parliament to Association control with minimal security: [6](#0-5) 

This test demonstrates creating an Association with a single member and minimal thresholds (MinimalApprovalThreshold=1, MinimalVoteThreshold=1), then successfully changing the method fee controller to it.

### Impact Explanation

**Direct Authorization Impact**: An attacker gains permanent control over the Genesis contract's method fee controller, which has authority to call `SetMethodFee` to set arbitrary transaction fees: [7](#0-6) 

**Concrete Harm**:
1. **Economic Disruption**: Attacker can set method fees to zero (eliminating fee revenue) or prohibitively high amounts (economic DoS)
2. **Operational DoS**: Making critical Genesis contract operations economically infeasible
3. **Permanence**: Control persists indefinitely after temporary Parliament access is lost
4. **Systemic Impact**: Affects all method fee operations for the foundational Genesis contract

**Affected Parties**: All users and protocols relying on the Genesis contract, as method fees control the economic cost of fundamental operations like contract deployment and updates.

**Severity Justification**: CRITICAL - combines permanent privilege escalation with control over critical economic parameters, where temporary access (days/weeks of BP control) converts to permanent control (years/indefinitely).

### Likelihood Explanation

**Attacker Capabilities Required**: 
- Temporary control of Parliament default organization (51%+ block producer nodes)
- Ability to create Association organization (permissionless operation)
- Ability to propose and approve Parliament proposals (available during temporary control)

**Attack Complexity**: LOW
1. Create malicious Association with self as sole member
2. Propose `ChangeMethodFeeController` via Parliament to switch to malicious Association
3. Approve proposal using temporary Parliament control
4. Release proposal to execute controller change

**Feasibility Conditions**:
- Temporary BP compromise scenarios: coordinated attack, vulnerability in BP software, economic incentives for collusion
- Time window: Parliament proposals typically have ~24 hour approval periods, giving sufficient time
- No additional checks or time-locks prevent immediate execution after approval

**Detection Constraints**: While the controller change would be visible on-chain, by the time it's detected and governance responds, the attacker already has permanent control via their Association and can block any attempts to change it back.

**Economic Rationality**: The cost of temporarily compromising 51%+ BPs (which might be achieved through various means including software vulnerabilities) is finite and time-limited, while the benefit of permanent method fee control is indefinite, making this attack economically rational for sophisticated adversaries.

### Recommendation

**Code-Level Mitigation**: Add validation to ensure the new controller organization maintains equivalent or stronger security properties:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // NEW: Validate controller change is to equivalent governance type
    Assert(input.ContractAddress == State.MethodFeeController.Value.ContractAddress,
        "Controller must remain same governance contract type.");
    
    // NEW: For Parliament controller, validate it remains Parliament
    if (State.MethodFeeController.Value.ContractAddress == State.ParliamentContract.Value)
    {
        Assert(input.ContractAddress == State.ParliamentContract.Value,
            "Parliament controller cannot be changed to different governance type.");
    }
    
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

**Invariant Checks to Add**:
1. Controller governance contract type cannot be downgraded (Parliament → Association/Referendum)
2. For system-critical controllers, require time-locked multi-step process for controller changes
3. Add minimum organization security thresholds (member count, approval percentages)

**Test Cases to Add**:
1. Test that ChangeMethodFeeController rejects Parliament → Association downgrade
2. Test that ChangeMethodFeeController rejects Association with insufficient members/thresholds
3. Test attempted authorization escalation attack scenario explicitly

### Proof of Concept

**Initial State**:
- Genesis contract deployed with MethodFeeController = Parliament default organization
- Parliament default organization controlled by 5 block producers with MinimalApprovalThreshold=66.67%

**Attack Execution**:

**Step 1**: Attacker temporarily compromises 4 out of 5 block producer nodes (80% control)

**Step 2**: Attacker creates malicious Association organization:
```
CreateOrganization({
  ProposerWhiteList: { AttackerAddress },
  OrganizationMembers: { AttackerAddress },
  MinimalApprovalThreshold: 1,
  MinimalVoteThreshold: 1
})
Returns: MaliciousAssociationAddress
```

**Step 3**: Attacker creates proposal via Parliament to change controller:
```
CreateProposal({
  OrganizationAddress: ParliamentDefaultOrg,
  ToAddress: GenesisContract,
  MethodName: "ChangeMethodFeeController",
  Params: {
    OwnerAddress: MaliciousAssociationAddress,
    ContractAddress: AssociationContract
  }
})
Returns: ProposalId
```

**Step 4**: Attacker approves proposal with compromised BP nodes (4 approvals = 80% > 66.67% threshold)

**Step 5**: Attacker releases proposal:
```
Release(ProposalId)
→ Executes ChangeMethodFeeController
→ CheckOrganizationExist validates MaliciousAssociationAddress exists ✓
→ State.MethodFeeController.Value = { MaliciousAssociationAddress, AssociationContract }
```

**Expected Result**: Change should be rejected due to governance downgrade

**Actual Result**: Change succeeds. Method fee controller is now the attacker's single-member Association.

**Success Condition**: After Step 5, even when attacker loses BP control:
- `GetMethodFeeController()` returns attacker's Association
- Attacker can unilaterally call `SetMethodFee()` via their Association (single approval required)
- Legitimate governance cannot reclaim control without attacker's cooperation

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L9-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L1273-1315)
```csharp
    public async Task ChangeMethodFeeControllerByAssociation_Test()
    {
        var createOrganizationResult = await Tester.ExecuteContractWithMiningAsync(AssociationContractAddress,
            nameof(AssociationContractImplContainer.AssociationContractImplStub.CreateOrganization),
            new Association.CreateOrganizationInput
            {
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { AnotherMinerAddress }
                },
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { AnotherMinerAddress }
                }
            });

        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.ReturnValue);

        var methodFeeController = await GetMethodFeeController(Tester, BasicContractZeroAddress);
        const string proposalCreationMethodName =
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ChangeMethodFeeController);
        var proposalId = await CreateProposalAsync(Tester, methodFeeController.ContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName,
            new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = AssociationContractAddress
            });
        await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
        var txResult2 = await ReleaseProposalAsync(Tester, ParliamentAddress, proposalId);
        txResult2.Status.ShouldBe(TransactionResultStatus.Mined);

        var methodFeeControllerAfterChange =
            await GetMethodFeeController(Tester, BasicContractZeroAddress);

        methodFeeControllerAfterChange.ContractAddress.ShouldBe(AssociationContractAddress);
        methodFeeControllerAfterChange.OwnerAddress.ShouldBe(organizationAddress);
    }
```
