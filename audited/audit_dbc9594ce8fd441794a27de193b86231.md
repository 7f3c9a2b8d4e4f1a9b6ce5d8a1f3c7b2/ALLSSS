# Audit Report

## Title
Negative DepositBalance Accounting Error in TokenConverter Sell Function

## Summary
The `Sell()` function in TokenConverter uses Bancor pricing with `VirtualBalance + DepositBalance` but only decrements `DepositBalance`. When Bancor returns `amountToReceive > DepositBalance`, the contract allows negative `DepositBalance` values, corrupting reserve accounting and enabling price manipulation across connector pairs.

## Finding Description

The vulnerability arises from a mismatch between how connector balances are calculated for pricing versus how they are tracked in state.

**Vulnerable Flow:**

1. For deposit connectors with `IsVirtualBalanceEnabled = true`, `GetSelfBalance()` returns the sum of virtual and real balances [1](#0-0) 

2. The `Sell()` function uses this inflated balance in Bancor calculations [2](#0-1) 

3. The Bancor formula treats `VirtualBalance + DepositBalance` as actual reserves and calculates withdrawal amounts accordingly [3](#0-2) 

4. Only `DepositBalance` is decremented by the full `amountToReceive` [4](#0-3) 

5. Since `DepositBalance` is a signed `long` type [5](#0-4) , and `SafeMath.Sub()` only prevents overflow/underflow beyond `long` bounds [6](#0-5) , negative values are permitted

6. The token transfer succeeds if the contract holds sufficient total base tokens (from other connectors or deposits) [7](#0-6) 

7. Future queries via `GetDepositConnectorBalance()` return `VirtualBalance + (negative DepositBalance)`, a value less than `VirtualBalance` alone [8](#0-7) 

**Security Invariant Broken:** The protocol assumes `DepositBalance` represents actual tokens held by the contract for that connector. Negative values violate this assumption and cause the reported balance to drop below the virtual floor that was meant to provide price stability.

**Malicious Input Example:**
- Connector A: `VirtualBalance = 100,000`, `DepositBalance = 5,000`
- Connector B: `VirtualBalance = 100,000`, `DepositBalance = 10,000`
- Attacker sells enough of Connector A's resource token such that Bancor calculates `amountToReceive = 8,000`
- Transfer succeeds (contract has 15,000 total)
- Result: Connector A's `DepositBalance = -3,000`, future pricing uses 97,000 instead of 105,000

## Impact Explanation

**Medium-High Severity** due to:

1. **Reserve Accounting Corruption:** Breaks the fundamental invariant that `DepositBalance` tracks real token holdings per connector. Negative balances render the accounting system meaningless.

2. **Price Manipulation:** Future Bancor calculations use corrupted balances (`VirtualBalance + negative DepositBalance`), producing artificially low prices for affected connectors. This creates exploitable arbitrage opportunities.

3. **Cross-Connector Subsidy:** One connector's reserves can be drained beyond its actual deposits while relying on tokens meant for other connector pairs. This breaks the isolation between different trading pairs.

4. **Cascading Mispricing:** As `DepositBalance` becomes increasingly negative through repeated exploitation, the price diverges further from intended values, compounding the damage.

While this doesn't directly steal locked funds in a single transaction, it corrupts protocol economics and enables attackers to extract value through repeated trades across mispriced connectors.

## Likelihood Explanation

**High Likelihood** because:

1. **No Privileges Required:** The `Sell()` function is public [9](#0-8)  - any user with resource tokens can trigger it.

2. **Common Configuration:** Connectors with `VirtualBalance >> DepositBalance` are intentional design for price smoothing, making the precondition naturally satisfied.

3. **Multi-Connector Deployments:** Production systems typically have multiple connector pairs sharing the same base token pool, ensuring sufficient total balance exists even when individual `DepositBalance` values are low.

4. **No Validation Present:** No check prevents `amountToReceive` from exceeding `DepositBalance` before the subtraction.

5. **Silent Failure:** Transactions succeed without errors; negative `DepositBalance` is only visible through state inspection, delaying detection.

The attack requires only:
- Off-chain calculation of trade size (using public Bancor formula)
- Sufficient resource tokens to execute the trade
- Contract configuration typical of production deployments

## Recommendation

Add validation in the `Sell()` function to ensure `amountToReceive` does not exceed the actual `DepositBalance`:

```csharp
public override Empty Sell(SellInput input)
{
    var fromConnector = State.Connectors[input.Symbol];
    Assert(fromConnector != null, "[Sell]Can't find from connector.");
    Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[Sell]Can't find to connector.");
    
    var amountToReceive = BancorHelper.GetReturnFromPaid(
        GetSelfBalance(fromConnector), GetWeight(fromConnector),
        GetSelfBalance(toConnector), GetWeight(toConnector),
        input.Amount
    );

    // ADD THIS VALIDATION
    if (toConnector.IsDepositAccount)
    {
        var currentDeposit = State.DepositBalance[toConnector.Symbol];
        Assert(amountToReceive <= currentDeposit, 
            "Insufficient deposit balance for this connector");
    }

    var fee = Convert.ToInt64(amountToReceive * GetFeeRate());
    // ... rest of function
}
```

Alternatively, calculate the effective withdrawable balance excluding `VirtualBalance` and use it as an upper bound for Bancor calculations.

## Proof of Concept

```csharp
[Fact]
public async Task NegativeDepositBalance_Vulnerability_Test()
{
    // Setup: Initialize contract with two connector pairs
    await InitializeTokenConverterContract();
    await CreateWriteToken();
    await CreateReadToken(); // Second resource token
    
    // Enable both connectors with VirtualBalance >> DepositBalance
    // Connector A (WRITE): VirtualBalance=100,000, initial DepositBalance will be ~5,000
    // Connector B (READ): VirtualBalance=100,000, initial DepositBalance will be ~10,000
    
    await PrepareToBuyAndSell();
    await PrepareToBuyAndSell_ReadToken();
    
    // Record initial state
    var initialDepositA = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = "WRITE" });
    
    // Attacker executes large sell on Connector A
    // This will cause Bancor to calculate amountToReceive based on 
    // (VirtualBalance + DepositBalance) but only decrement DepositBalance
    var largeAmount = 50000L; // Large enough to trigger amountToReceive > DepositBalance
    
    await DefaultStub.Sell.SendAsync(new SellInput
    {
        Symbol = "WRITE",
        Amount = largeAmount,
        ReceiveLimit = 0
    });
    
    // Verify: DepositBalance is now negative
    var finalDepositA = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = "WRITE" });
    
    // VULNERABILITY CONFIRMED: finalDepositA < VirtualBalance (100,000)
    // This should never happen - deposit balance should not go below virtual balance
    Assert.True(finalDepositA.Value < 100000, 
        "Deposit balance corrupted: now less than VirtualBalance alone");
}
```

**Notes:**
- The vulnerability requires understanding the interaction between `VirtualBalance` (pricing parameter) and `DepositBalance` (actual reserves tracked).
- This is particularly dangerous in multi-connector deployments where the contract holds pooled base tokens across all pairs.
- The issue could be exploited gradually to avoid detection, with each sell transaction pushing `DepositBalance` further negative.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-162)
```csharp
    public override Empty Sell(SellInput input)
    {
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L186-192)
```csharp
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs (L19-19)
```csharp
    public MappedState<string, long> DepositBalance { get; set; }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L93-102)
```csharp
    public override Int64Value GetDepositConnectorBalance(StringValue symbolInput)
    {
        var connector = State.Connectors[symbolInput.Value];
        Assert(connector != null && !connector.IsDepositAccount, "token symbol is invalid");
        var ntSymbol = connector.RelatedSymbol;
        return new Int64Value
        {
            Value = State.Connectors[ntSymbol].VirtualBalance + State.DepositBalance[ntSymbol]
        };
    }
```
