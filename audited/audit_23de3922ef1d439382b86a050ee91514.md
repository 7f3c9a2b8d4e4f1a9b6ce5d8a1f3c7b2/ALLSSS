### Title
Hash Collision Vulnerability in NFT Token Hash Calculation Allows Cross-NFT Data Corruption

### Summary
The `CalculateTokenHash` method uses simple string concatenation of symbol and tokenId without a delimiter, allowing two different NFT tokens from different protocols to produce identical token hashes. This causes `GetNFTInfo` to return incorrect NFT information and enables balance/metadata corruption when `IsTokenIdReuse` is enabled, or denial-of-service for specific tokenId values when disabled.

### Finding Description

The root cause is in the `CalculateTokenHash` method which computes the token hash using direct string concatenation: [1](#0-0) 

This implementation concatenates the symbol (string) with tokenId (long converted to string) without any delimiter or separator. This creates collision scenarios where:
- Protocol with symbol="ABC" and tokenId=456 produces: `hash("ABC456")`
- Protocol with symbol="ABC4" and tokenId=56 produces: `hash("ABC456")`

Both combinations result in identical token hashes.

The `GetNFTInfo` method relies on this flawed hash calculation: [2](#0-1) 

When a collision occurs, `GetNFTInfo` returns data for the wrong NFT. The state storage `State.NftInfoMap[tokenHash]` maps hash to NFT information: [3](#0-2) 

The vulnerability manifests differently based on the `IsTokenIdReuse` flag in the minting logic: [4](#0-3) 

**Scenario 1 - IsTokenIdReuse=false (DoS):** When the collision check is active and an NFT with the colliding hash already exists, the assertion fails, preventing legitimate minting of the second NFT.

**Scenario 2 - IsTokenIdReuse=true (Data Corruption):** When the check is bypassed, the minting logic updates the existing NFT's data: [5](#0-4) 

This causes quantities, minters, and balances from different NFT protocols to be mixed together under the same tokenHash.

Symbol validation allows alphanumeric characters, permitting both "ABC" and "ABC4" as valid protocol symbols: [6](#0-5) 

The `CrossChainCreate` method allows arbitrary symbols (as long as they exist in the token contract), making collisions feasible in cross-chain scenarios: [7](#0-6) 

### Impact Explanation

**Data Integrity Impact (HIGH):**
- `GetNFTInfo` returns completely incorrect NFT metadata, including wrong symbol, creator, URI, and metadata for query inputs
- Users querying NFT information receive data for a different NFT entirely
- Marketplace integrations, wallets, and dApps display wrong NFT details to users

**Financial Impact (CRITICAL when IsTokenIdReuse=true):**
- NFT balances are merged between different protocols under the same tokenHash
- State storage maps (`BalanceMap`, `AllowanceMap`) indexed by tokenHash cause balance confusion
- Transfers affect wrong NFT balances since all operations use the same colliding hash [8](#0-7) 

- Quantity tracking becomes corrupted as increments apply to the wrong NFT's total supply

**Operational Impact (HIGH when IsTokenIdReuse=false):**
- Denial-of-service for specific tokenId values that collide with existing hashes
- NFT protocol creators cannot mint tokens with legitimate tokenIds if they collide
- Protocol functionality is permanently blocked for those tokenId ranges

### Likelihood Explanation

**Attacker Capabilities Required:**
- Knowledge of existing NFT protocol symbols (publicly visible on-chain)
- Ability to create new NFT protocols or tokens (via CrossChainCreate or standard creation)
- Ability to calculate tokenId values that produce collisions (deterministic computation)

**Attack Complexity: MEDIUM**
- While auto-generated protocol symbols (e.g., "AR123456789") make natural collisions unlikely, the system permits arbitrary symbols via cross-chain creation
- Symbols like "NFT", "TEST", "GAME" are valid and can easily produce collisions
- Example: "GAME" + tokenId 100 vs "GAME1" + tokenId 00 → "GAME100"

**Feasibility Conditions:**
- Cross-chain NFT protocol deployment allows arbitrary symbols without format enforcement
- Multiple NFT protocols with similar symbol prefixes can coexist (no overlap prevention)
- TokenId selection is user-controlled during minting [9](#0-8) 

**Economic Rationality:**
- Creating NFT protocols and minting tokens has standard gas costs
- The benefit of corrupting competitor NFTs or causing DoS may outweigh costs for malicious actors
- In cross-chain scenarios, attack costs may be lower on side chains

**Probability: MEDIUM to HIGH**
- Auto-generated symbols reduce natural collision probability
- However, CrossChainCreate and human-chosen symbols significantly increase risk
- Any deployment using short, common symbol patterns is vulnerable

### Recommendation

**Primary Fix - Add Delimiter to Hash Calculation:**
Modify the `CalculateTokenHash` method to include an unambiguous delimiter:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}-{tokenId}");
}
```

Or use the more robust `ConcatAndCompute` method that separately hashes each component:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol),
        HashHelper.ComputeFrom(tokenId)
    );
}
```

**Additional Mitigations:**
1. Enforce strict symbol format validation for NFT protocols to prevent ambiguous prefixes
2. Add explicit collision detection when storing NFT info to detect and reject hash collisions
3. Implement comprehensive regression tests covering collision scenarios

**Test Cases to Add:**
- Verify different (symbol, tokenId) pairs produce different hashes
- Test collision scenarios: ("ABC", 456) vs ("ABC4", 56)
- Validate GetNFTInfo returns correct data after fix
- Test cross-chain NFT creation with various symbol formats

### Proof of Concept

**Initial State:**
- Two NFT protocols can be created with symbols "GAME" and "GAME1"
- Both protocols have IsTokenIdReuse configured differently

**Attack Sequence:**

1. **Protocol 1 Creation:**
   - Create NFT protocol with symbol "GAME"
   - Mint NFT with symbol="GAME", tokenId=100
   - TokenHash = Hash("GAME100")
   - State.NftInfoMap[Hash("GAME100")] = {symbol:"GAME", tokenId:100, quantity:1, ...}

2. **Protocol 2 Creation:**
   - Create NFT protocol with symbol "GAME1"
   - Attempt to mint NFT with symbol="GAME1", tokenId=00 (which is 0)
   - TokenHash = Hash("GAME10") - No collision

   Better collision:
   - Mint NFT with symbol="GAME1", tokenId=00
   
   Actually, let me use a clearer example:
   - Mint NFT with tokenId=0 → "GAME10" (no collision with "GAME100")
   
   Correct collision example:
   - Mint NFT with symbol="GAME1", tokenId=0 gives "GAME10"
   - We need symbol="GAME", tokenId=100 → "GAME100"
   - And symbol="GAME10", tokenId=0 → "GAME100" ✓ COLLISION

3. **Collision Result (IsTokenIdReuse=true):**
   - Second mint updates the first NFT's quantity
   - State.NftInfoMap[Hash("GAME100")] now has mixed data
   - Balances for both NFTs share the same storage location

4. **Verification:**
   - Call GetNFTInfo({symbol:"GAME10", tokenId:0})
   - Expected: NFTInfo for "GAME10" token 0
   - Actual: NFTInfo for "GAME" token 100 (wrong symbol, wrong tokenId, wrong metadata)

5. **Collision Result (IsTokenIdReuse=false):**
   - Second mint fails with "Token id 0 already exists"
   - Protocol "GAME10" cannot mint tokenId 0 despite it being valid
   - Permanent DoS for that specific tokenId

**Success Condition:** The vulnerability is confirmed if different (symbol, tokenId) inputs to GetNFTInfo return the same NFTInfo object, proving the hash collision causes data retrieval errors.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L23-24)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L392-396)
```csharp
        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-437)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L14-18)
```csharp
    public override NFTInfo GetNFTInfo(GetNFTInfoInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        return GetNFTInfoByTokenHash(tokenHash);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L20-30)
```csharp
    public override NFTInfo GetNFTInfoByTokenHash(Hash input)
    {
        var nftInfo = State.NftInfoMap[input];
        if (nftInfo == null) return new NFTInfo();
        var nftProtocolInfo = State.NftProtocolMap[nftInfo.Symbol];
        nftInfo.ProtocolName = nftProtocolInfo.ProtocolName;
        nftInfo.Creator = nftProtocolInfo.Creator;
        nftInfo.BaseUri = nftProtocolInfo.BaseUri;
        nftInfo.NftType = nftProtocolInfo.NftType;
        return nftInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L18-21)
```csharp
    private static bool IsValidSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+(-[0-9]+)?$");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-85)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");
```
