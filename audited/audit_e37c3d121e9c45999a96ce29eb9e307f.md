### Title
KeyNotFoundException in IsCurrentMiner Due to Missing Existence Check for Removed Miners

### Summary
The `IsCurrentMiner(string pubkey)` function skips the `ContainsKey` check when `IsMinerListJustChanged` is true, incorrectly assuming all queried pubkeys must exist in the current round. This causes a `KeyNotFoundException` when checking recently removed miners whose pubkeys are retrieved from the previous round by `ConvertAddressToPubkey`, resulting in transaction failures for critical system operations.

### Finding Description

The vulnerability exists in the `IsCurrentMiner` function chain: [1](#0-0) 

The root cause is the flawed logic at lines 142-144. When `IsMinerListJustChanged` is true, the function skips the `ContainsKey` check, assuming the pubkey must exist in the current round. However, this assumption fails when:

1. **Miner Replacement Process**: During round transitions with miner replacement, evil miners are removed from the current round and alternatives are added: [2](#0-1) 

2. **State Persistence**: The modified current round is used to generate the next round, but the previous round remains unchanged in state. Only the next round (with `IsMinerListJustChanged = true`) is saved: [3](#0-2) 

3. **Pubkey Resolution**: The `ConvertAddressToPubkey` function searches both current and previous rounds, potentially returning a removed miner's pubkey: [4](#0-3) 

4. **Unchecked Access**: At line 158, the code directly accesses the dictionary without verification: [5](#0-4) 

This contrasts with other methods in the codebase that properly check existence: [6](#0-5) 

### Impact Explanation

The vulnerability causes **Denial of Service** for critical system operations:

1. **Genesis Contract**: Code deployment and updates require mining permission checks: [7](#0-6) 

2. **Parliament Contract**: Governance operations validate miner authority: [8](#0-7) 

3. **Additional Affected Contracts**: MultiToken (resource donation), CrossChain (indexing permissions) also rely on `IsCurrentMiner`.

When `IsCurrentMiner` throws `KeyNotFoundException`, any cross-contract call fails, blocking:
- Smart contract deployment/updates
- Governance proposal creation/voting by removed miners
- Resource token donations
- Cross-chain indexing operations

The impact is **Medium severity** because:
- No direct fund loss or unauthorized access
- Temporary (only during the round with `IsMinerListJustChanged = true`)
- Affects operational availability, not integrity
- Limited to specific timing window after miner removal

### Likelihood Explanation

**Preconditions**:
1. A miner must be detected as evil and removed (missing too many time slots)
2. The system must be in a round where `IsMinerListJustChanged = true`
3. Someone must call `IsCurrentMiner` for the removed miner's address

**Attack Vectors**:
1. **Direct**: Removed miner attempts privileged operations requiring mining permission
2. **Indirect**: Other contracts or users check the removed miner's mining status

**Feasibility**: Medium likelihood because:
- Evil miner detection occurs regularly in production
- Removed miners may legitimately attempt operations unaware of their removal
- External contracts may query miner status for any address
- The vulnerability window lasts one full round (several minutes to hours)

**Detection**: Transaction failures with `KeyNotFoundException` would be visible in logs and could alert malicious actors to repeatedly trigger the issue.

### Recommendation

**Immediate Fix**: Always check key existence before dictionary access, regardless of `IsMinerListJustChanged` status:

```csharp
private bool IsCurrentMiner(string pubkey)
{
    if (pubkey == null) return false;

    if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

    // Always check existence - removed miners from previous round may be queried
    if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return false;

    // Rest of the logic...
    var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
    // ...
}
```

**Alternative Approach**: Use `TryGetValue` pattern for safe dictionary access:

```csharp
if (!currentRound.RealTimeMinersInformation.TryGetValue(pubkey, out var minerInRound))
    return false;
```

**Additional Safeguards**:
1. Add test case simulating miner removal followed by `IsCurrentMiner` query for removed miner
2. Consider restricting `ConvertAddressToPubkey` to only search current round when `IsMinerListJustChanged` is true
3. Document the state consistency model for miner list transitions

### Proof of Concept

**Initial State**:
- Round 100: Miners = [A, B, C]
- Miner B has missed excessive time slots (evil miner)

**Attack Sequence**:

1. **NextRound Transaction** (Round 100 → 101):
   - Evil miner B detected via `TryToDetectEvilMiners`
   - Alternative miner D selected via `GetMinerReplacementInformation`
   - Round 101 created: Miners = [A, C, D], `IsMinerListJustChanged = true`
   - Round 100 remains in state with [A, B, C]

2. **Trigger Transaction** (During Round 101):
   - Removed miner B calls Genesis contract method requiring `AssertCurrentMiner()`
   - OR any user calls `IsCurrentMiner(B's address)`

3. **Execution Flow**:
   ```
   IsCurrentMiner(B's address)
   → ConvertAddressToPubkey(B's address)
     → Searches Round 101: A, C, D (B not found)
     → Searches Round 100: A, B, C (B found!)
     → Returns B's pubkey
   → IsCurrentMiner(B's pubkey)
     → Gets Round 101
     → IsMinerListJustChanged = true → skips ContainsKey check
     → Line 158: currentRound.RealTimeMinersInformation[B]
     → KeyNotFoundException thrown!
   ```

**Expected Result**: Function should return `false` (B is not a current miner)

**Actual Result**: Transaction fails with `KeyNotFoundException`, blocking the operation

**Success Condition**: Any transaction calling `IsCurrentMiner` for a removed miner during the round immediately after removal will fail with an exception instead of returning `false`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L125-134)
```csharp
    private string ConvertAddressToPubkey(Address address)
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);

        return possibleKeys.FirstOrDefault(k =>
            Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)) == address);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L136-144)
```csharp
    private bool IsCurrentMiner(string pubkey)
    {
        if (pubkey == null) return false;

        if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L157-159)
```csharp
        var miningInterval = currentRound.GetMiningInterval();
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L309-341)
```csharp
            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-87)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L296-302)
```csharp
    private void AssertCurrentMiner()
    {
        RequireConsensusContractStateSet();
        var isCurrentMiner = State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value;
        Context.LogDebug(() => $"Sender is currentMiner : {isCurrentMiner}.");
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L212-218)
```csharp
    private void AssertCurrentMiner()
    {
        RequireConsensusContractStateSet();
        var isCurrentMiner = State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value;
        Context.LogDebug(() => $"Sender is currentMiner : {isCurrentMiner}.");
        Assert(isCurrentMiner, "No permission.");
    }
```
