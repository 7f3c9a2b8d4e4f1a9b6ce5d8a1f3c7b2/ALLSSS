# Audit Report

## Title
Missing Order Consistency Validation Allows Manipulation of Mining Sequence During Round Transitions

## Summary
The `NextRoundMiningOrderValidationProvider` validates the wrong round context during round transitions, checking internal consistency of the newly generated round N+1 (where `FinalOrderOfNextRound` and `OutValue` are unset) instead of verifying that the `Order` assignments in round N+1 match the collectively-determined `FinalOrderOfNextRound` values from round N stored in state. This allows the miner producing the NextRound block to arbitrarily manipulate mining orders.

## Finding Description

**Vulnerability Location:**

The flawed validation logic is in the `NextRoundMiningOrderValidationProvider`: [1](#0-0) 

The validator checks `validationContext.ProvidedRound` (the next round N+1), comparing miners with `FinalOrderOfNextRound > 0` against miners with `OutValue != null`. However, at round transition time:
- `ProvidedRound` is the newly generated round N+1
- In round N+1, `FinalOrderOfNextRound` defaults to 0 (for future round N+2, not yet set)
- In round N+1, `OutValue` is null (no blocks mined yet)
- The check becomes: 0 == 0, which trivially passes

**How Orders Should Work:**

During round N, miners collectively determine their positions in round N+1 by setting `FinalOrderOfNextRound` values through `UpdateValue` operations: [2](#0-1) 

These `FinalOrderOfNextRound` values are calculated cryptographically from miners' signatures: [3](#0-2) 

When generating round N+1, these `FinalOrderOfNextRound` values from round N should be used to assign the `Order` field in round N+1: [4](#0-3) 

**The Attack Vector:**

When a miner produces the NextRound block, they locally generate the next round: [5](#0-4) 

Since this generation happens locally in the block producer's node, they can modify the generated round structure to assign arbitrary `Order` values before including it in the block header.

**Validation Context:**

The validation context distinguishes between `BaseRound` (current round N from state) and `ProvidedRound` (the block producer's claimed next round N+1): [6](#0-5) 

The validator is added during `ValidateBeforeExecution`: [7](#0-6) 

**Missing Protection:**

The `RoundTerminateValidationProvider` only checks round number increment and null `InValue` fields, not order consistency: [8](#0-7) 

After validation, `ProcessNextRound` simply stores the provided round without additional checks: [9](#0-8) [10](#0-9) 

**What Should Be Validated:**

The validator should verify: `ProvidedRound[miner].Order == BaseRound[miner].FinalOrderOfNextRound` for all miners who successfully mined in round N. This ensures the cryptographic commitments made during round N are respected in round N+1.

## Impact Explanation

**Consensus Protocol Violation:**
The AEDPoS consensus protocol relies on miners collectively determining their next-round positions through cryptographic signatures. This creates a fair, deterministic mining schedule. The vulnerability completely breaks this guarantee, allowing arbitrary schedule manipulation.

**Direct Economic Harm:**
- **Block Reward Theft:** The attacker can position themselves at the start of rounds to capture block rewards intended for other miners
- **MEV Extraction:** Early block positions enable maximum extractable value through transaction ordering control
- **Compounding Advantage:** Repeated exploitation across multiple rounds accumulates significant economic benefits

**Protocol Integrity Damage:**
- Breaks the cryptographic binding between miners' signatures and their mining positions
- Undermines the decentralization and fairness properties of the consensus mechanism
- Creates information asymmetry where honest miners expect their determined positions but receive manipulated ones
- Reduces trust in the consensus system

**Severity: HIGH** - This affects a critical consensus invariant protecting the integrity of the mining schedule and block production fairness.

## Likelihood Explanation

**Attacker Requirements:**
- Must be a registered miner (achievable by staking tokens - no special privileges required)
- Must be selected to produce the NextRound block (happens deterministically every round to some miner)
- Only requires modifying local node code or the generated round data structure

**Attack Complexity: LOW**
- No cryptographic breaking required
- No need to compromise multiple nodes or coordinate attacks
- Simple modification of the `Order` field in locally generated round data
- The broken validation makes detection impossible during block validation

**Opportunity Frequency:**
- Every round transition (approximately once per round)
- Any miner producing a NextRound block has this capability
- Significant economic incentive (block rewards + MEV)

**Detection Difficulty:**
- The validation appears to pass correctly (returns success)
- Other nodes cannot easily detect manipulation without storing historical `FinalOrderOfNextRound` values and comparing them
- No on-chain evidence or events indicate order manipulation
- Honest miners may not realize their expected positions were changed

**Likelihood: MEDIUM-HIGH** - The opportunity arises frequently, requires minimal sophistication, and offers significant economic incentive with low detection risk.

## Recommendation

**Fix the Validation Logic:**

The `NextRoundMiningOrderValidationProvider` should compare the provided round's `Order` values against the base round's `FinalOrderOfNextRound` values:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound;
    var providedRound = validationContext.ProvidedRound;
    
    // Get miners who successfully mined in the current round
    var minedMiners = baseRound.RealTimeMinersInformation.Values
        .Where(m => m.OutValue != null)
        .ToList();
    
    // Verify each miner's Order in the provided round matches their 
    // FinalOrderOfNextRound from the base round
    foreach (var miner in minedMiners)
    {
        if (!providedRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
        {
            validationResult.Message = $"Miner {miner.Pubkey} missing from next round";
            return validationResult;
        }
        
        var expectedOrder = miner.FinalOrderOfNextRound;
        var actualOrder = providedRound.RealTimeMinersInformation[miner.Pubkey].Order;
        
        if (expectedOrder != actualOrder)
        {
            validationResult.Message = 
                $"Order mismatch for {miner.Pubkey}: expected {expectedOrder}, got {actualOrder}";
            return validationResult;
        }
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

**Additional Recommendations:**
1. Add unit tests that explicitly verify order consistency between rounds
2. Add monitoring/logging to track order assignments for forensic analysis
3. Consider adding a grace period where historical round data is retained longer to enable post-facto verification

## Proof of Concept

Since this vulnerability requires modifying the consensus contract behavior itself (the miner must run modified node software to generate manipulated rounds), a traditional unit test cannot fully demonstrate the exploit. However, the following test demonstrates that the current validator accepts any order assignment without comparing against `FinalOrderOfNextRound`:

```csharp
[Fact]
public void NextRoundMiningOrderValidation_AcceptsArbitraryOrders()
{
    // Setup: Create round N with miners having set FinalOrderOfNextRound values
    var baseRound = new Round { RoundNumber = 100 };
    baseRound.RealTimeMinersInformation["MinerA"] = new MinerInRound
    {
        Pubkey = "MinerA",
        Order = 1,
        FinalOrderOfNextRound = 1,  // MinerA should be first in next round
        OutValue = Hash.FromString("outA")
    };
    baseRound.RealTimeMinersInformation["MinerB"] = new MinerInRound
    {
        Pubkey = "MinerB",
        Order = 2,
        FinalOrderOfNextRound = 2,  // MinerB should be second in next round
        OutValue = Hash.FromString("outB")
    };
    
    // Create round N+1 with MANIPULATED orders (reversed)
    var providedRound = new Round { RoundNumber = 101 };
    providedRound.RealTimeMinersInformation["MinerA"] = new MinerInRound
    {
        Pubkey = "MinerA",
        Order = 2  // WRONG: Should be 1
    };
    providedRound.RealTimeMinersInformation["MinerB"] = new MinerInRound
    {
        Pubkey = "MinerB",
        Order = 1  // WRONG: Should be 2
    };
    
    var context = new ConsensusValidationContext
    {
        BaseRound = baseRound,
        ProvidedRound = providedRound,
        ExtraData = new AElfConsensusHeaderInformation
        {
            Round = providedRound,
            Behaviour = AElfConsensusBehaviour.NextRound
        }
    };
    
    var validator = new NextRoundMiningOrderValidationProvider();
    var result = validator.ValidateHeaderInformation(context);
    
    // BUG: Validation passes even though orders don't match FinalOrderOfNextRound
    Assert.True(result.Success);  // This should FAIL but currently PASSES
}
```

This test proves that the validator does not compare orders between rounds, allowing arbitrary order manipulation to pass validation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-260)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-47)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-36)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-203)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L8-41)
```csharp
public class ConsensusValidationContext
{
    public long CurrentTermNumber { get; set; }
    public long CurrentRoundNumber { get; set; }

    /// <summary>
    ///     We can trust this because we already validated the pubkey
    ///     during `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`
    /// </summary>
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();

    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;

    /// <summary>
    ///     Previous round information fetch from StateDb.
    /// </summary>
    public Round PreviousRound { get; set; }

    /// <summary>
    ///     This filed is to prevent one miner produces too many continues blocks
    ///     (which may cause problems to other parts).
    /// </summary>
    public LatestPubkeyToTinyBlocksCount LatestPubkeyToTinyBlocksCount { get; set; }

    public AElfConsensusHeaderInformation ExtraData { get; set; }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-92)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```
