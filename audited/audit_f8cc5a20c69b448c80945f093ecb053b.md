# Audit Report

## Title
State Size Limit Denial of Service via Large Voting Result Aggregation

## Summary
The Vote contract allows registration of voting items with up to 64 options of 1024 characters each. When votes are aggregated, the VotingResult's results map stores full option strings as keys, causing the serialized protobuf state to exceed the 128 KB limit enforced by the AElf runtime. This results in permanent DoS of voting operations once sufficient options receive votes.

## Finding Description

The Vote contract defines option limits that, when combined with multi-byte UTF-8 encoding, create a state size overflow scenario. [1](#0-0) 

During vote registration, options are copied directly from input without validation of their cumulative state impact. [2](#0-1) 

The VotingResult protobuf structure uses a map where option strings become keys. [3](#0-2) 

When a vote is cast, `UpdateVotingResult` adds the option string as a map key if it doesn't already exist. [4](#0-3) 

The critical vulnerability occurs when the VotingResult is written to state, where the AElf runtime automatically enforces size validation. [5](#0-4) 

The runtime's `ValidateStateSize` method serializes the object and throws `StateOverSizeException` if it exceeds the limit. [6](#0-5) 

The state size limit is hardcoded. [7](#0-6) 

This validation is automatically injected before all state writes by the contract patcher. [8](#0-7) 

**Size Calculation (Worst Case):**
With 64 options using 4-byte UTF-8 characters (emoji, some Chinese characters):
- String content: 64 Ã— 1024 Ã— 4 = 262,144 bytes (just keys)
- Int64 values: 64 Ã— 8 = 512 bytes  
- Protobuf overhead: ~500 bytes
- Other VotingResult fields: ~100 bytes
- **Total: ~263,256 bytes (exceeds 128 KB by 2Ã—)**

Even with 2-byte UTF-8 encoding: 64 Ã— 1024 Ã— 2 = 131,072 bytes plus overhead exceeds the limit.

## Impact Explanation

**Operational DoS Impact:**
- Once VotingResult exceeds 128 KB, all `Vote()` transactions fail with `StateOverSizeException`
- The `Withdraw()` method also fails when attempting to update the oversized VotingResult. [9](#0-8) 
- Legitimate voters cannot participate, freezing the voting process permanently
- No recovery mechanism exists without contract upgrade or manual state intervention

**Severity Justification:**
This is HIGH severity because:
1. Completely disables core voting functionality
2. Impact is irreversible through normal operations
3. Multiple voting items can be affected simultaneously  
4. Attack parameters are within contract-specified limits

## Likelihood Explanation

**Attacker Capabilities:**
- Any user can create a voting item (sponsor role)
- Can craft 64 option strings with multi-byte UTF-8 characters
- May coordinate multiple voters or wait for organic votes to different options

**Attack Complexity:**
- MEDIUM - Requires understanding of UTF-8 encoding and state size limits
- Option strings can be programmatically generated
- No special privileges beyond basic user access

**Feasibility:**
The contract's own validation enforces the limits that enable this attack. The `AddOptions` method checks individual option lengths and total count, but not cumulative serialized size. [10](#0-9) 

Multi-byte UTF-8 strings are valid input with no encoding restrictions in the validation logic.

**Economic Rationale:**
- Attack cost: minimal transaction fees
- No token lockup required if `IsLockToken = false`
- Strategic value in disrupting governance or preventing unfavorable outcomes
- **Probability: HIGH** - straightforward attack using intended functionality

## Recommendation

Implement cumulative state size validation during voting item registration and option management:

1. **Add pre-registration validation**: Calculate the maximum possible serialized size based on all options and reject registration if it would exceed safe limits (e.g., 80% of 128 KB to allow for overhead)

2. **Enforce conservative per-option limits**: Reduce `OptionLengthLimit` to account for multi-byte UTF-8 encoding (e.g., 256 characters instead of 1024)

3. **Add option count limits based on average size**: Dynamically calculate maximum options based on their actual byte sizes rather than character counts

4. **Consider alternative storage patterns**: Store option identifiers (hashes) as map keys instead of full strings, with a separate mapping to retrieve option text

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task VotingResult_StateSize_DoS_Test()
{
    // Create 64 options with 1024 multi-byte UTF-8 characters each
    var options = new List<string>();
    for (int i = 0; i < 64; i++)
    {
        // Use 4-byte UTF-8 characters (emoji)
        options.Add(new string('ðŸ˜€', 1024));
    }
    
    // Register voting item with maximum options
    var votingItemId = await RegisterVotingItemAsync(options);
    
    // Have multiple voters vote for different options
    for (int i = 0; i < 64; i++)
    {
        await VoteAsync(votingItemId, options[i], voter: GetVoter(i));
    }
    
    // After enough options receive votes, the next vote should fail
    // with StateOverSizeException
    var result = await VoteAsync(votingItemId, options[0], voter: GetNewVoter());
    
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("exceeds limit of 131072");
}
```

**Notes:**
- The vulnerability stems from the interaction between contract-level parameter limits (64 options Ã— 1024 characters) and runtime-level state size enforcement (128 KB)
- UTF-8 encoding allows legitimate multi-byte characters that exponentially increase serialized size
- The `Register()` method lacks validation on the cumulative state impact of the options array
- Once triggered, the voting item is permanently frozen without external intervention

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-6)
```csharp
    public const int MaximumOptionsCount = 64;
    public const int OptionLengthLimit = 1024;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L49-49)
```csharp
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L174-174)
```csharp
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L180-180)
```csharp
        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L222-222)
```csharp
        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L292-296)
```csharp
    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** protobuf/vote_contract.proto (L165-166)
```text
    // The voting result, option -> amount of votes,
    map<string, int64> results = 2;
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L148-160)
```csharp
    public object ValidateStateSize(object obj)
    {
        var stateSizeLimit = AsyncHelper.RunSync(() => _smartContractBridgeService.GetStateSizeLimitAsync(
            new ChainContext
            {
                BlockHash = _transactionContext.PreviousBlockHash,
                BlockHeight = _transactionContext.BlockHeight - 1
            }));
        var size = SerializationHelper.Serialize(obj).Length;
        if (size > stateSizeLimit)
            throw new StateOverSizeException($"State size {size} exceeds limit of {stateSizeLimit}.");
        return obj;
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** src/AElf.CSharp.CodeOps/Instructions/IStateWrittenInstructionInjector.cs (L30-33)
```csharp
                {typeof(SingletonState).FullName, new HashSet<string> {"set_Value"}},
                {typeof(ReadonlyState).FullName, new HashSet<string> {"set_Value"}},
                {typeof(MappedState).FullName, new HashSet<string> {"set_Item", "Set"}}
            });
```
