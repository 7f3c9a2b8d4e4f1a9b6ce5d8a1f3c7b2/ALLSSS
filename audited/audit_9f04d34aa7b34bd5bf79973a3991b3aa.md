# Audit Report

## Title
Memory Exhaustion via Unbounded Consensus Extra Data Parsing in Block Validation

## Summary
The AEDPoS consensus validation pipeline performs protobuf deserialization of consensus extra data without size validation, allowing a malicious elected miner to craft blocks with oversized payloads (up to 100MB) that cause memory exhaustion on validating nodes before semantic validation can reject them.

## Finding Description

The vulnerability exists in the block validation flow where consensus extra data undergoes **two separate parsing operations** before any size or semantic validation:

**First Parsing Location:**
When a block arrives, `AEDPoSExtraDataExtractor.ExtractConsensusExtraData` immediately deserializes the consensus extra data to verify the sender's public key matches the block signer. [1](#0-0) 

**Second Parsing Location:**
The consensus contract's `ValidateConsensusBeforeExecution` method performs another deserialization before delegating to semantic validation logic. [2](#0-1) 

**Root Cause:** The `AElfConsensusHeaderInformation` protobuf structure contains unbounded collections: [3](#0-2) 

The nested `Round` message contains a map of miner information: [4](#0-3) 

Each `MinerInRound` includes unbounded repeated fields and maps: [5](#0-4) 

A malicious miner can craft blocks with hundreds of fake miner entries, large `actual_mining_times` arrays, and oversized `encrypted_pieces`/`decrypted_pieces` maps.

**Why Existing Protections Fail:**

The network enforces a 100MB gRPC message limit: [6](#0-5) 

However, this limit still allows payloads large enough to cause memory pressure. The 5MB transaction size limit does not apply to block header extra data.

Legitimate block production uses cleanup methods to optimize consensus data: [7](#0-6) [8](#0-7) 

These cleanup methods (`GetUpdateValueRound`, `DeleteSecretSharingInformation`) create lightweight versions of the Round data. However, a malicious miner can bypass this standard flow by manually constructing block headers with full, unoptimized Round structures containing inflated data.

The semantic validation in `ValidateBeforeExecution` only executes **after** both parsing operations have already allocated memory: [9](#0-8) 

## Impact Explanation

**Operational Denial of Service:**
- Validating nodes experience memory spikes proportional to payload size (up to ~100MB per block, doubled by two parsing operations)
- Complex nested protobuf structures amplify CPU overhead during deserialization
- Resource-constrained nodes may crash with out-of-memory errors
- Network-wide consensus participation is disrupted while nodes recover

**Affected Parties:** All non-malicious validator nodes receiving blocks from the malicious miner.

**Attack Amplification:** The malicious miner can produce multiple consecutive blocks during their assigned time slot, repeatedly triggering memory exhaustion across the network.

**Severity Rationale:** This is a **Medium severity** operational DoS vulnerability. While it does not compromise funds, state integrity, or consensus correctness, it provides a reliable mechanism for degrading network availability and forcing node restarts. The impact is bounded by the attacker's time slot duration and eventual detection through rejected blocks.

## Likelihood Explanation

**Attack Prerequisites:**
- Attacker must be elected as a consensus miner through the Election contract
- Miners are economically staked and subject to monitoring
- However, a compromised or malicious miner can execute this attack during their scheduled blocks

**Attack Complexity:** **LOW** - The attacker simply constructs an `AElfConsensusHeaderInformation` protobuf with inflated data (many fake miners, large arrays/maps) and includes it in block headers, bypassing the standard `GetConsensusExtraData` optimization flow.

**Detection:** Malicious blocks are signed by the attacker and will be rejected after validation, making attribution trivial. However, memory allocation and parsing overhead occur **before** rejection.

**Economic Disincentives:** The attacker faces potential loss of staked tokens and mining rewards. However, if the goal is disruption rather than profit maximization, these costs may be acceptable to a motivated adversary.

**Probability Assessment:** **MEDIUM** - Requires trusted role (miner) compromise, which is a significant barrier. However, once miner status is achieved, the attack is technically trivial to execute and guaranteed to impact validating nodes during the exploitation window.

## Recommendation

Implement size validation **before** protobuf deserialization in both parsing locations:

1. **In `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`:**
   - Add a size check before line 29
   - Reject consensus extra data exceeding a reasonable threshold (e.g., 1MB for typical consensus data)

2. **In `ValidateConsensusBeforeExecution`:**
   - Add a size check before line 79
   - Validate `input.Value.Length` against the same threshold

3. **Define a constant for maximum consensus extra data size:**
   ```csharp
   // In AEDPoSContractConstants.cs
   public const int MaxConsensusExtraDataSize = 1024 * 1024; // 1MB
   ```

4. **Validation logic example:**
   ```csharp
   // Before parsing
   if (consensusExtraData.Length > AEDPoSContractConstants.MaxConsensusExtraDataSize)
   {
       Logger.LogDebug($"Consensus extra data exceeds maximum size: {consensusExtraData.Length} bytes");
       return null; // or throw appropriate exception
   }
   var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);
   ```

This prevents memory exhaustion attacks while allowing legitimate consensus data to pass through validation.

## Proof of Concept

A proof of concept would involve:

1. Creating a test where a malicious miner constructs a `Round` object with:
   - 100+ fake miner entries in `RealTimeMinersInformation`
   - Each miner having 1000+ entries in `ActualMiningTimes`
   - Large byte arrays in `EncryptedPieces` and `DecryptedPieces` maps

2. Serializing this into `AElfConsensusHeaderInformation` without calling cleanup methods

3. Including this as consensus extra data in a block header

4. Demonstrating that validating nodes allocate significant memory (approaching 100MB) during parsing operations before the block is eventually rejected by semantic validation

The test would measure memory allocation at the parsing points and confirm that resource exhaustion occurs before validation rejection.

---

**Notes:**
- This vulnerability requires **elected miner privileges**, which significantly raises the barrier to exploitation but does not eliminate the threat entirely
- The 100MB network limit prevents even larger attacks but still allows payloads sufficient for operational DoS
- The double parsing (in extractor and contract) amplifies the memory pressure
- While blocks are eventually rejected, the damage (memory allocation, CPU overhead) occurs before rejection
- This represents a trade-off between validation thoroughness and denial-of-service resilience in the current architecture

### Citations

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L29-29)
```csharp
        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L79-80)
```csharp
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
```

**File:** protobuf/aedpos_contract.proto (L243-264)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producersâ€™ expecting time (second).
    int64 round_id_for_validation = 10;
}
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** protobuf/aedpos_contract.proto (L303-310)
```text
message AElfConsensusHeaderInformation {
    // The sender public key.
    bytes sender_pubkey = 1;
    // The round information.
    Round round = 2;
    // The behaviour of consensus.
    AElfConsensusBehaviour behaviour = 3;
}
```

**File:** src/AElf.OS.Network.Grpc/GrpcConstants.cs (L28-29)
```csharp
    public const int DefaultMaxReceiveMessageLength = 100 * 1024 * 1024;
    public const int DefaultMaxSendMessageLength = 100 * 1024 * 1024;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L31-31)
```csharp
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L50-50)
```csharp
        if (!isGeneratingTransactions) information.Round.DeleteSecretSharingInformation();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-20)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```
