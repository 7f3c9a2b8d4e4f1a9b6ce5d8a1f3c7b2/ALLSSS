### Title
Missing IssueChainId Validation Allows Cross-Chain Token Issuance on Wrong Chains

### Summary
The `CrossChainCreate()` function does not validate that `tokenInfo.IssueChainId` matches the chain where the token was actually created, and the underlying `MultiToken.CreateToken()` method allows arbitrary `IssueChainId` values without validation. This enables attackers to create NFT tokens on the mainchain with an incorrect `IssueChainId` pointing to a sidechain, then use cross-chain mechanisms to enable token issuance on the wrong chain, breaking the fundamental invariant that tokens should only be issued on their designated chain.

### Finding Description

**Root Cause 1:** In the NFT contract's `CrossChainCreate()` function, the `IssueChainId` is directly copied from `tokenInfo` without any validation: [1](#0-0) 

At line 102, the code assigns `IssueChainId = tokenInfo.IssueChainId` without verifying this value matches the chain where the token was actually created or issued.

**Root Cause 2:** In the MultiToken contract's `CreateToken()` method, when a non-zero `IssueChainId` is provided, it is used directly without validation: [2](#0-1) 

At line 76, the logic `IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId` allows setting an arbitrary `IssueChainId` that doesn't match `Context.ChainId` when the input is non-zero.

**Root Cause 3:** The NFT contract's `Create()` method passes the user-supplied `IssueChainId` directly to MultiToken without validation: [3](#0-2) 

At line 29, `IssueChainId = input.IssueChainId` is passed through without checking it matches the mainchain's `Context.ChainId`.

**Why Existing Protections Fail:** The `Issue()` method validates that tokens can only be issued on their designated `IssueChainId`: [4](#0-3) 

However, this protection only enforces issuance on whatever chain the `IssueChainId` field claims, not where the token was actually created. If `IssueChainId` is set incorrectly during creation, this check becomes meaningless.

### Impact Explanation

**Cross-Chain Token Integrity Violation:**
- Tokens created on mainchain can be configured to be issued on sidechains, bypassing the governance model that NFT protocols must be created on mainchain
- This breaks the fundamental invariant that `IssueChainId` represents the actual chain where tokens should be issued

**Concrete Attack Scenario:**
1. Attacker creates an NFT collection on mainchain (AELF) with `IssueChainId = SideChainA`
2. Token is stored on mainchain with incorrect `IssueChainId`
3. Attacker calls `CrossChainCreate()` on SideChainA using a valid merkle proof from mainchain
4. SideChainA creates the NFT protocol info with `IssueChainId = SideChainA`
5. Attacker can now issue tokens on SideChainA instead of mainchain
6. Tokens cannot be issued on mainchain where they were created (Issue check fails)

**Who Is Affected:**
- Cross-chain token users who rely on correct `IssueChainId` for token provenance
- Token holders who expect tokens to be issued only on their designated chains
- Cross-chain bridge security that depends on accurate chain identification

**Severity Justification:** HIGH - This violates a critical cross-chain security invariant and allows tokens to be issued on arbitrary chains, undermining the entire cross-chain token model and governance structure.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to call `NFT.Create()` on mainchain (public method, requires seed NFT or whitelist)
- Ability to execute cross-chain transactions (standard functionality)
- No special privileges beyond normal NFT protocol creation

**Attack Complexity:** LOW
- Single call to `NFT.Create()` with malicious `IssueChainId` parameter
- Standard cross-chain operation to propagate to sidechain
- No complex state manipulation required

**Feasibility Conditions:**
- NFT protocol creation is a normal operation
- Cross-chain propagation is standard functionality
- No special timing or race conditions needed

**Detection Constraints:**
- The incorrect `IssueChainId` would be stored on-chain but may not trigger immediate alerts
- Token issuance on wrong chain might not be detected until governance review
- No automatic validation prevents this attack

**Probability:** HIGH - The attack is straightforward, uses standard contract interfaces, and requires no special conditions or timing.

### Recommendation

**Mitigation 1 - Validate IssueChainId in CrossChainCreate:**
Add validation in `NFTContract_Create.cs` at line 102:
```csharp
// After line 102, add:
Assert(tokenInfo.IssueChainId == input.FromChainId, 
    "IssueChainId must match the source chain where token was created.");
```

**Mitigation 2 - Validate IssueChainId in CreateToken:**
In `TokenContract_Actions.cs` at line 76, enforce that `IssueChainId` must match `Context.ChainId`:
```csharp
// Replace line 76 with:
IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
// Add after line 76:
Assert(tokenInfo.IssueChainId == Context.ChainId, 
    "IssueChainId must match the current chain for token creation.");
```

**Mitigation 3 - Validate IssueChainId in NFT.Create:**
In `NFTContract_Create.cs` at line 29, add validation:
```csharp
// After line 29, add:
Assert(input.IssueChainId == 0 || input.IssueChainId == Context.ChainId,
    "IssueChainId must match mainchain for NFT protocol creation.");
```

**Test Cases to Add:**
1. Test that creating NFT with `IssueChainId != Context.ChainId` fails
2. Test that `CrossChainCreate` rejects tokens with mismatched `IssueChainId`
3. Test that tokens can only be issued on the chain where they were created

### Proof of Concept

**Initial State:**
- Mainchain ID: 9992731 (AELF)
- SideChain ID: 1866392 (tDVV)
- Attacker has seed NFT to create protocols

**Exploitation Steps:**

1. **Create NFT on Mainchain with Wrong IssueChainId:**
```
Call NFT.Create() on mainchain with:
    - NftType: "ART"
    - ProtocolName: "Malicious NFT"
    - IssueChainId: 1866392 (SideChain tDVV, not mainchain)
    - Other valid parameters
```

2. **Verify Token Info on Mainchain:**
```
Result: Token created with IssueChainId = 1866392
Issue() on mainchain will FAIL with "Unable to issue token with wrong chainId"
```

3. **Call ValidateTokenInfoExists on Mainchain:**
```
Call MultiToken.ValidateTokenInfoExists() with token info
Result: Succeeds, proving token exists with IssueChainId = 1866392
```

4. **Execute CrossChainCreate on SideChain:**
```
Call NFT.CrossChainCreate() on tDVV sidechain with:
    - Merkle proof from mainchain ValidateTokenInfoExists
    - Symbol from step 1
Result: NFT protocol created on sidechain with IssueChainId = 1866392
```

5. **Issue Tokens on SideChain:**
```
Call MultiToken.Issue() on tDVV sidechain
Expected: Should FAIL (token was created on mainchain)
Actual: SUCCEEDS (IssueChainId matches sidechain ID)
```

**Success Condition:** Tokens successfully issued on sidechain even though the NFT protocol was created on mainchain, proving the `IssueChainId` validation bypass.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L23-34)
```csharp
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L95-108)
```csharp
        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-162)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

```
