### Title
Transfer Blacklist Bypass - Recipient Address Not Validated

### Summary
The transfer blacklist implementation only validates the sender (FROM) address but fails to check the recipient (TO) address in `DoTransfer`. This allows blacklisted addresses to receive tokens through multiple paths including Unlock, direct Transfer, Issue, and CrossChainReceiveToken operations, completely bypassing the blacklist's intended purpose of freezing an address's token activity.

### Finding Description

The root cause is in `DoTransfer` which only checks if the FROM address is blacklisted: [1](#0-0) 

The blacklist check at line 101 only validates `from` but never checks if `to` is blacklisted. This creates multiple bypass vectors:

**Primary Attack Path (Lock/Unlock Bypass):**
1. User locks tokens via Election/Vote contracts before being blacklisted
2. User gets added to transfer blacklist
3. Election/Vote contract calls `Unlock` to return tokens
4. `Unlock` invokes `Transfer` via `SendVirtualInline` with virtual address as sender: [2](#0-1) 

5. `Transfer` calls `DoTransfer(virtualAddress, blacklistedUser, ...)` which only checks if virtualAddress is blacklisted (it's not), allowing tokens to reach the blacklisted user [3](#0-2) 

**Additional Bypass Vectors:**

Direct transfers TO blacklisted addresses succeed because `DoTransfer` is used but only checks the sender.

Issue operations bypass blacklist by calling `ModifyBalance` directly without any blacklist check: [4](#0-3) 

CrossChainReceiveToken also bypasses by using `ModifyBalance` directly: [5](#0-4) 

The test suite confirms Lock is blocked for blacklisted senders but does NOT test Unlock to blacklisted recipients: [6](#0-5) 

### Impact Explanation

**Direct Operational Impact:** The transfer blacklist feature is rendered ineffective. Blacklisted addresses can:
- Receive tokens from any sender via Transfer/TransferFrom
- Unlock previously locked tokens from Election/Vote contracts
- Receive issued tokens from token issuers
- Receive cross-chain transferred tokens

**Protocol Damage:** When governance adds an address to the blacklist (e.g., for regulatory compliance, compromised keys, or malicious actors), the expectation is that the address is frozen from ALL token activity. However, the address can still accumulate tokens and access previously locked funds, defeating the security measure.

**Affected Parties:** 
- Governance (Parliament/Association) cannot effectively enforce blacklist decisions
- Protocol security is compromised as malicious actors retain token access
- Legitimate users who locked tokens before being blacklisted can bypass the restriction

**Severity Justification:** HIGH - Core security feature (blacklist) is fundamentally broken, allowing unrestricted token reception by addresses that should be frozen.

### Likelihood Explanation

**Reachable Entry Points:** Multiple public methods accessible without special permissions:
- `Unlock` callable by Election/Vote contracts (whitelisted) or the user themselves
- `Transfer` callable by any address
- `Issue` callable by token issuer
- `CrossChainReceiveToken` callable with valid cross-chain proof

**Attack Complexity:** TRIVIAL
- Lock/Unlock path: User simply needs to have locked tokens before blacklisting
- Direct transfer path: Any address can send tokens to blacklisted address immediately

**Feasibility Conditions:**
- No special permissions required for exploitation
- No economic cost to attacker (just gas fees)
- Works on any blacklisted address immediately

**Detection Constraints:** The bypass is silent - blacklisted addresses receive tokens through normal contract operations that emit standard events. Governance has no way to prevent this without contract upgrade.

**Probability:** HIGH - This is not a race condition or timing issue. It's a permanent logic gap that affects 100% of blacklisted addresses and is trivially exploitable by any party.

### Recommendation

**Code-Level Mitigation:**

Add recipient blacklist validation in `DoTransfer`:

```csharp
private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
{
    Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
    Assert(!IsInTransferBlackListInternal(to), "To address is in transfer blacklist.");
    Assert(from != to, "Can't do transfer to sender itself.");
    // ... rest of function
}
```

This single fix protects Transfer, TransferFrom, Lock, Unlock, TransferToContract, and AdvanceResourceToken paths.

**Additional Protection for Direct ModifyBalance Calls:**

Add blacklist check in `ModifyBalance` when adding tokens:

```csharp
private void ModifyBalance(Address address, string symbol, long addAmount)
{
    var before = GetBalance(address, symbol);
    if (addAmount > 0)
        Assert(!IsInTransferBlackListInternal(address), "To address is in transfer blacklist.");
    // ... rest of function
}
```

This protects Issue and CrossChainReceiveToken paths.

**Test Cases:**
1. Test that Transfer TO blacklisted address fails
2. Test that Unlock TO blacklisted address fails  
3. Test that Issue TO blacklisted address fails
4. Test that CrossChainReceiveToken TO blacklisted address fails
5. Test that tokens locked before blacklisting cannot be unlocked to blacklisted recipient

### Proof of Concept

**Initial State:**
- User A has 10,000 ELF
- User A locks 5,000 ELF via Election contract Vote operation
- Tokens are held in virtual address controlled by Election contract

**Exploitation Steps:**

1. **Blacklist User A:**
```
Parliament creates proposal: AddToTransferBlackList(UserA)
Miners approve and release proposal
UserA.IsInTransferBlackList() == true
```

2. **Verify Lock is Blocked (Expected):**
```
ElectionContract.Vote(UserA, 1000 ELF) 
    -> Calls TokenContract.Lock(UserA, virtualAddr, 1000)
    -> Calls DoTransfer(UserA, virtualAddr, 1000)
    -> FAILS: "From address is in transfer blacklist"
```

3. **Bypass via Unlock (Vulnerability):**
```
Wait for lock period to expire
ElectionContract.Withdraw(UserA)
    -> Calls VoteContract.Withdraw() 
    -> Calls TokenContract.Unlock(UserA, 5000)
    -> Calls Transfer(virtualAddr â†’ UserA, 5000)
    -> Calls DoTransfer(virtualAddr, UserA, 5000)
    -> Only checks virtualAddr (not blacklisted)
    -> SUCCESS: UserA receives 5,000 ELF
```

4. **Alternative Bypass via Direct Transfer:**
```
UserB.Transfer(UserA, 1000 ELF)
    -> Calls DoTransfer(UserB, UserA, 1000)
    -> Only checks UserB (not blacklisted)  
    -> SUCCESS: UserA receives 1,000 ELF
```

**Expected Result:** All operations to blacklisted UserA should fail

**Actual Result:** UserA successfully receives tokens via Unlock and Transfer, bypassing blacklist

**Success Condition:** After exploitation, blacklisted UserA has received tokens and increased balance, violating the blacklist invariant that blacklisted addresses should have frozen token activity.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L99-114)
```csharp
    private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
    {
        Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
        Assert(from != to, "Can't do transfer to sender itself.");
        AssertValidMemo(memo);
        ModifyBalance(from, symbol, -amount);
        ModifyBalance(to, symbol, amount);
        Context.Fire(new Transferred
        {
            From = from,
            To = to,
            Symbol = symbol,
            Amount = amount,
            Memo = memo ?? string.Empty
        });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-178)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(input.To, input.Symbol, input.Amount);

        Context.Fire(new Issued
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = input.To,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L224-252)
```csharp
    public override Empty Unlock(UnlockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");

        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        Context.SendVirtualInline(fromVirtualAddress, Context.Self, nameof(Transfer), new TransferInput
        {
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        DealWithExternalInfoDuringUnlock(new TransferFromInput
        {
            From = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress),
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L591-638)
```csharp
    public override Empty CrossChainReceiveToken(CrossChainReceiveTokenInput input)
    {
        var transferTransaction = Transaction.Parser.ParseFrom(input.TransferTransactionBytes);
        var transferTransactionId = transferTransaction.GetHash();

        Assert(!State.VerifiedCrossChainTransferTransaction[transferTransactionId],
            "Token already claimed.");

        var crossChainTransferInput =
            CrossChainTransferInput.Parser.ParseFrom(transferTransaction.Params.ToByteArray());
        var symbol = crossChainTransferInput.Symbol;
        var amount = crossChainTransferInput.Amount;
        var receivingAddress = crossChainTransferInput.To;
        var targetChainId = crossChainTransferInput.ToChainId;
        var transferSender = transferTransaction.From;

        var tokenInfo = AssertValidToken(symbol, amount);
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
        Assert(targetChainId == Context.ChainId, "Unable to claim cross chain token.");
        var registeredTokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        AssertCrossChainTransaction(transferTransaction, registeredTokenContractAddress,
            nameof(CrossChainTransfer));
        Context.LogDebug(() =>
            $"symbol == {tokenInfo.Symbol}, amount == {amount}, receivingAddress == {receivingAddress}, targetChainId == {targetChainId}");

        CrossChainVerify(transferTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);

        State.VerifiedCrossChainTransferTransaction[transferTransactionId] = true;
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(receivingAddress, tokenInfo.Symbol, amount);

        Context.Fire(new CrossChainReceived
        {
            From = transferSender,
            To = receivingAddress,
            Symbol = tokenInfo.Symbol,
            Amount = amount,
            Memo = crossChainTransferInput.Memo,
            FromChainId = input.FromChainId,
            ParentChainHeight = input.ParentChainHeight,
            IssueChainId = issueChainId,
            TransferTransactionId = transferTransactionId
        });
        return new Empty();
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L1973-1984)
```csharp
        // Lock should fail when sender is in blacklist
        var lockId = HashHelper.ComputeFrom("lockId");
        var lockTokenResult = (await BasicFunctionContractStub.LockToken.SendWithExceptionAsync(new LockTokenInput
        {
            Address = DefaultAddress,
            Amount = Amount,
            Symbol = AliceCoinTokenInfo.Symbol,
            LockId = lockId,
            Usage = "Testing."
        })).TransactionResult;
        lockTokenResult.Status.ShouldBe(TransactionResultStatus.Failed);
        lockTokenResult.Error.ShouldContain("From address is in transfer blacklist");
```
