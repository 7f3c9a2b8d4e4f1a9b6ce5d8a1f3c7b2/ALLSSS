### Title
Extra Block Producer Receives Incorrect Mining Time After Order Swap in BreakContinuousMining

### Summary
When the extra block producer is assigned to the last order position, the `BreakContinuousMining` method swaps their order with the second-to-last miner to prevent continuous mining. However, `ArrangeAbnormalMiningTime` incorrectly calculates the EBP's mining time using `GetExtraBlockMiningTime()`, which always returns the time slot of the miner with the highest order, not the actual extra block producer after the swap. This causes the extra block producer to receive an incorrect mining time slot, potentially disrupting consensus round termination.

### Finding Description

**Root Cause:**
The vulnerability stems from an inconsistency between two methods:
- `GetExtraBlockProducerInformation()` identifies the extra block producer by the `IsExtraBlockProducer` flag [1](#0-0) 

- `GetExtraBlockMiningTime()` calculates the extra block time slot based on the miner with the highest `Order` value, not the `IsExtraBlockProducer` flag [2](#0-1) 

**Problematic Code Path:**

During round generation, `BreakContinuousMining` is designed to prevent continuous mining by swapping orders. When the last miner (highest order) is the extra block producer, it swaps this miner with the second-to-last miner: [3](#0-2) 

After this swap:
- The extra block producer retains `IsExtraBlockProducer = true` but now has `Order = N-1`
- A different miner now has `Order = N` (the highest order)

In `ArrangeAbnormalMiningTime`, the special extra block producer logic checks if the calling miner is the EBP using the flag, but then returns a time calculated based on the highest order: [4](#0-3) 

This creates a mismatch: the EBP (with swapped Order = N-1) receives the time slot calculated for Order = N.

**Why Existing Protections Fail:**
The code has no validation that `GetExtraBlockProducerInformation()` and the miner with the highest order in `GetExtraBlockMiningTime()` refer to the same miner. The swap in `BreakContinuousMining` updates the `Order` field but not the corresponding time slot calculation logic.

### Impact Explanation

**Consensus Timing Disruption:**
- The extra block producer is assigned an incorrect mining time that doesn't correspond to their actual order position
- This causes the EBP to attempt mining at the wrong time slot (the time slot meant for another miner)
- The EBP is responsible for terminating rounds via the `TerminateRoundCommandStrategy` [5](#0-4) 

**Concrete Impact:**
1. **Round Termination Delays**: The EBP may miss their actual time slot or mine at an incorrect time, delaying round transitions
2. **Time Slot Conflicts**: Two miners may believe they own overlapping time slots
3. **Consensus Validation Issues**: The `IsCurrentMiner` check uses the same flawed logic, potentially rejecting valid blocks or accepting invalid ones [6](#0-5) 

**Severity Justification:**
This is a **Medium** severity issue because:
- It directly affects consensus protocol correctness (Critical Invariant #2: miner schedule integrity)
- It causes operational disruption but doesn't lead to fund theft
- The incorrect timing can cause consensus delays and confusion but the system can recover in subsequent rounds

### Likelihood Explanation

**Probability:**
- This occurs deterministically whenever the extra block producer is calculated to be at the last order position
- `CalculateNextExtraBlockProducerOrder()` uses pseudo-random selection: `(signature % minerCount) + 1` [7](#0-6) 
- With N miners, the probability is approximately 1/N per round
- For a typical 17 miner setup, this occurs ~6% of rounds

**Reachable Entry Point:**
- The issue is triggered automatically during normal consensus operation
- No attacker action required - it's a deterministic bug in the round generation logic
- Affects the production consensus flow in every deployed chain

**Feasibility:**
- **Preconditions**: Multi-miner setup (N ≥ 2) and EBP calculated at last order
- **Complexity**: Zero - occurs naturally during consensus
- **Detection**: Difficult to detect as the system continues operating with timing confusion

**Economic Rationality:**
- Not an exploit but a protocol bug affecting all participants
- No cost to trigger - happens automatically

### Recommendation

**Fix 1: Use EBP's Actual Order in GetExtraBlockMiningTime**
Modify `GetExtraBlockMiningTime()` to use the extra block producer's actual order instead of always using the highest order:

```csharp
public Timestamp GetExtraBlockMiningTime()
{
    var extraBlockProducer = GetExtraBlockProducerInformation();
    return extraBlockProducer.ExpectedMiningTime.AddMilliseconds(GetMiningInterval());
}
```

**Fix 2: Update ArrangeAbnormalMiningTime Logic**
Alternatively, have `ArrangeAbnormalMiningTime` use the EBP's actual `ExpectedMiningTime`:

```csharp
if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
{
    var ebpInfo = GetExtraBlockProducerInformation();
    var distance = (ebpInfo.ExpectedMiningTime.AddMilliseconds(miningInterval) - currentBlockTime).Milliseconds();
    if (distance > 0) return ebpInfo.ExpectedMiningTime;
}
```

**Invariant Check:**
Add assertion that the EBP's `ExpectedMiningTime` matches the calculated extra block time, or document that they can differ after order swaps.

**Test Cases:**
1. Test round generation when EBP is at last order and verify correct time assignment after swap
2. Test `ArrangeAbnormalMiningTime` returns correct time for swapped EBP
3. Test `IsCurrentMiner` correctly validates swapped EBP's time slot

### Proof of Concept

**Initial State:**
- 5 miners in a round with 4000ms mining interval
- Round starts at timestamp T = 1000000

**Step 1: Round Generation**
- `CalculateNextExtraBlockProducerOrder()` returns 5 (last order)
- Initial assignments:
  - Miner A: Order 1, ExpectedMiningTime = T + 4000
  - Miner B: Order 2, ExpectedMiningTime = T + 8000
  - Miner C: Order 3, ExpectedMiningTime = T + 12000
  - Miner D: Order 4, ExpectedMiningTime = T + 16000
  - Miner EBP: Order 5, ExpectedMiningTime = T + 20000, IsExtraBlockProducer = true

**Step 2: BreakContinuousMining Swap**
- Detects last miner is EBP
- Swaps orders 4 and 5:
  - Miner EBP: Order 4, ExpectedMiningTime = T + 16000, IsExtraBlockProducer = true
  - Miner D: Order 5, ExpectedMiningTime = T + 20000

**Step 3: ArrangeAbnormalMiningTime Called for EBP**
```
pubkey = "EBP"
currentBlockTime = T + 15000
```

**Expected Result:**
EBP should receive time = T + 16000 (their actual ExpectedMiningTime)

**Actual Result:**
- Line 26 condition: `GetExtraBlockProducerInformation().Pubkey == "EBP"` → TRUE
- Line 28: `GetExtraBlockMiningTime()` calculates:
  - `OrderBy(Order).Last()` = Miner D (Order 5)
  - Returns T + 20000 + 4000 = T + 24000
- Line 30: distance = 24000 + 4000 - 15000 = 13000 > 0 → returns T + 24000

**Outcome:**
EBP receives T + 24000 instead of their correct time T + 16000 - an 8000ms (2 mining intervals) discrepancy.

**Success Condition:**
The vulnerability is confirmed when `ArrangeAbnormalMiningTime` returns a time that doesn't match the EBP's `ExpectedMiningTime` after an order swap by `BreakContinuousMining`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L26-31)
```csharp
        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L92-107)
```csharp
        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L25-26)
```csharp
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```
