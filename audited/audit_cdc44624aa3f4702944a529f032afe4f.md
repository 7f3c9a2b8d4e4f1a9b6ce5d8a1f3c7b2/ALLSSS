### Title
Reserved External Info Key Collision Enables Arbitrary Contract Execution During Token Operations

### Summary
The MultiToken contract allows attackers to create tokens with ExternalInfo keys that collide with reserved callback keys (`aelf_transfer_callback`, `aelf_lock_callback`, `aelf_unlock_callback`, `aelf_log_event`). When users interact with these malicious tokens, attacker-controlled callbacks are executed via `Context.SendInline()`, enabling reentrancy attacks, fund theft, and denial-of-service.

### Finding Description

The vulnerability exists in the token creation flow where user-provided ExternalInfo is accepted without validation against reserved keys. [1](#0-0) 

The reserved callback keys are defined but never used for validation: [2](#0-1) 

The `GetReservedExternalInfoKeyList()` view function exposes these keys but is never called for validation: [3](#0-2) 

**Why Protections Fail:**

When tokens are transferred, locked, or unlocked, the contract unconditionally executes callbacks specified in ExternalInfo without verifying the token creator's authority: [4](#0-3) [5](#0-4) [6](#0-5) 

The CallbackInfo structure allows specifying arbitrary contract addresses and method names: [7](#0-6) 

These callbacks are invoked during normal token operations: [8](#0-7) [9](#0-8) [10](#0-9) 

### Impact Explanation

**Direct Fund Impact:**
- **Reentrancy Attacks**: Malicious callbacks can re-enter the token contract during transfers, potentially draining funds from users who have approved the attacker's contracts
- **Theft via Approved Allowances**: Callbacks can invoke `TransferFrom` on behalf of users who approved other contracts, stealing their tokens
- **Cross-Contract Exploitation**: Callbacks execute with the context of the token operation, potentially exploiting other contracts that trust the MultiToken contract

**Operational Impact:**
- **Denial of Service**: Callbacks can revert, blocking all transfers/locks/unlocks of the malicious token
- **Event Log Pollution**: The `aelf_log_event` key allows injecting arbitrary events that appear to originate from the MultiToken contract
- **Gas Exhaustion**: Callbacks can consume excessive gas, making token operations prohibitively expensive

**Affected Parties:**
- Any user who receives or transfers the malicious token
- Contracts and users with token approvals that the callback can exploit
- The entire token ecosystem's trust model is compromised

**Severity Justification:** CRITICAL - Combines arbitrary code execution with easy exploitability, directly threatening user funds and protocol integrity.

### Likelihood Explanation

**Attacker Capabilities:**
Any user who can create a token can exploit this vulnerability. Token creation requires: [11](#0-10) 

Users need either:
1. A SEED NFT (obtainable through normal means)
2. Membership in the create whitelist (for special addresses only)

**Attack Complexity:** LOW
1. Acquire a SEED NFT for the desired token symbol
2. Create `CreateInput` with ExternalInfo containing reserved keys
3. Set callback to point to attacker's malicious contract
4. Call `Create()` to register the malicious token
5. Distribute tokens to victims through airdrops or social engineering
6. When victims transfer/lock/unlock, callbacks execute automatically

**Feasibility Conditions:**
- ✅ No special permissions required beyond seed NFT ownership
- ✅ No race conditions or timing dependencies
- ✅ Works on any chain running this contract version
- ✅ Victims don't need to explicitly interact with attacker's contract

**Detection/Operational Constraints:**
- Malicious tokens are indistinguishable from legitimate ones at creation time
- No on-chain mechanism to detect or blacklist malicious callbacks
- Users cannot easily verify token safety before receiving/transferring

**Probability:** HIGH - The attack is straightforward, economically viable (low cost), and difficult to detect until exploited.

### Recommendation

**Immediate Mitigation:**

Add validation in `CreateToken` to reject reserved external info keys:

```csharp
private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
{
    AssertValidCreateInput(input, symbolType);
    
    // NEW: Validate external info keys
    if (input.ExternalInfo != null && input.ExternalInfo.Value.Count > 0)
    {
        var reservedKeys = new[]
        {
            TokenContractConstants.TransferCallbackExternalInfoKey,
            TokenContractConstants.LockCallbackExternalInfoKey,
            TokenContractConstants.UnlockCallbackExternalInfoKey,
            TokenContractConstants.LogEventExternalInfoKey
        };
        
        foreach (var key in input.ExternalInfo.Value.Keys)
        {
            Assert(!reservedKeys.Contains(key), 
                $"External info key '{key}' is reserved and cannot be used.");
        }
    }
    
    // ... rest of existing code
}
```

**Additional Protections:**

1. **Whitelist Callback Contracts**: If callbacks are intended functionality, restrict them to approved system contracts:
   - Add `State.ApprovedCallbackContracts` mapping
   - Validate callback contract addresses against whitelist
   - Require governance approval for new callback contracts

2. **Restrict Callback Setters**: Only allow token owners/issuers to set callback info, and only for specific trusted use cases

3. **Add Callback Permissions**: Create separate permission system for callback registration requiring multi-sig approval

**Test Cases:**

1. Test that token creation fails when ExternalInfo contains `aelf_transfer_callback`
2. Test that token creation fails when ExternalInfo contains `aelf_lock_callback`
3. Test that token creation fails when ExternalInfo contains `aelf_unlock_callback`
4. Test that token creation fails when ExternalInfo contains `aelf_log_event`
5. Test that token creation succeeds with other custom external info keys
6. Test cross-chain token creation also validates external info keys

### Proof of Concept

**Required Initial State:**
- Attacker holds a valid SEED NFT for token symbol "MAL"
- Attacker deploys malicious contract `MaliciousCallback` with method `StealFunds(TransferFromInput input)`

**Exploitation Steps:**

1. **Create Malicious Token:**
```
CreateInput {
    Symbol: "MAL",
    TokenName: "Malicious Token",
    TotalSupply: 1000000,
    Decimals: 8,
    Issuer: attacker_address,
    IsBurnable: true,
    ExternalInfo: {
        "aelf_transfer_callback": "{\"contract_address\":\"[MaliciousCallback_Address]\",\"method_name\":\"StealFunds\"}"
    }
}
```

2. **Distribute to Victim:**
Issue tokens and send to victim address

3. **Victim Transfers Token:**
When victim calls `Transfer()` or `TransferFrom()`, the callback executes: [12](#0-11) 

4. **Malicious Callback Executes:**
`MaliciousCallback.StealFunds()` is invoked via `Context.SendInline()`, which can:
   - Call `TransferFrom` on other tokens using victim's approvals
   - Re-enter MultiToken contract
   - Drain funds from contracts victim approved
   - Revert to DoS all transfers of this token

**Expected vs Actual Result:**
- **Expected**: Token creation should fail with "reserved key" error
- **Actual**: Token created successfully; callback executes on every transfer, enabling arbitrary code execution

**Success Condition:** 
Attacker successfully registers callback that executes during normal token operations, confirmed by:
1. Token exists with reserved keys in ExternalInfo
2. Transfer/Lock/Unlock operations invoke attacker's contract
3. Attacker's callback can execute arbitrary logic including fund theft

### Notes

The vulnerability is particularly severe because:

1. **Trust Model Violation**: Users trust the MultiToken contract as a system contract, but it enables arbitrary external code execution
2. **No User Warning**: Victims cannot easily detect malicious tokens before interaction
3. **Widespread Impact**: Affects all token operations (Transfer, Lock, Unlock) across regular tokens and NFTs
4. **Cross-Chain Risk**: Malicious tokens created on one chain can be transferred cross-chain, spreading the attack vector

The `GetReservedExternalInfoKeyList()` function appears to have been designed for validation purposes but was never integrated into the token creation flow, suggesting this protection was intended but not implemented.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L51-66)
```csharp
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L195-222)
```csharp
    public override Empty Lock(LockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");

        var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
        if (allowance >= input.Amount)
            State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
        DealWithExternalInfoDuringLocking(new TransferFromInput
        {
            From = input.Address,
            To = virtualAddress,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L224-252)
```csharp
    public override Empty Unlock(UnlockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");

        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        Context.SendVirtualInline(fromVirtualAddress, Context.Self, nameof(Transfer), new TransferInput
        {
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        DealWithExternalInfoDuringUnlock(new TransferFromInput
        {
            From = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress),
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-16)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
    public const string LockCallbackExternalInfoKey = "aelf_lock_callback";
    public const string UnlockCallbackExternalInfoKey = "aelf_unlock_callback";
    public const string LogEventExternalInfoKey = "aelf_log_event";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L238-250)
```csharp
    public override StringList GetReservedExternalInfoKeyList(Empty input)
    {
        return new StringList
        {
            Value =
            {
                TokenContractConstants.LockCallbackExternalInfoKey,
                TokenContractConstants.LogEventExternalInfoKey,
                TokenContractConstants.TransferCallbackExternalInfoKey,
                TokenContractConstants.UnlockCallbackExternalInfoKey
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L322-335)
```csharp
    private void DealWithExternalInfoDuringLocking(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.LockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.LockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L352-365)
```csharp
    private void DealWithExternalInfoDuringUnlock(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.UnlockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.UnlockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** protobuf/token_contract.proto (L530-533)
```text
message CallbackInfo {
    aelf.Address contract_address = 1;
    string method_name = 2;
}
```
