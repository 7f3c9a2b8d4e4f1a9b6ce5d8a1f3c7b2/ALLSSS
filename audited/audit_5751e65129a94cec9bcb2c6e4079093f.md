### Title
Evil Miner Detection Bypassed During Term Transitions Allowing Persistent Consensus Violations

### Summary
The `ProcessNextTerm` method fails to detect and mark evil miners before resetting their `MissedTimeSlots` counters to zero. While `ProcessNextRound` correctly identifies miners who have exceeded the tolerable threshold (4,320 missed time slots = 3 days), term transitions bypass this check entirely, allowing malicious or unreliable miners to indefinitely avoid penalties by exploiting predictable term boundaries.

### Finding Description

**Root Cause:**
The evil miner detection mechanism (`TryToDetectEvilMiners`) is only invoked during normal round transitions but is completely absent from term transitions. [1](#0-0) 

In contrast, `ProcessNextTerm` performs the following sequence without any evil miner detection: [2](#0-1) 

The critical flaw occurs at lines 168 and 179-183 where:
1. `CountMissedTimeSlots()` is called to increment counters for the current round
2. Immediately after, `MissedTimeSlots` is reset to 0 for all miners in the next term
3. No check is performed to detect if any miner has exceeded `TolerableMissedTimeSlotsCount` (4,320 slots) [3](#0-2) 

The `TryToDetectEvilMiners` method exists and correctly identifies miners whose missed slots exceed the threshold: [4](#0-3) 

However, grep search confirms it is only called once in the entire codebase - within `ProcessNextRound`, never in `ProcessNextTerm`.

**Why Existing Protections Fail:**
- The Election Contract's `UpdateCandidateInformation` method can mark evil nodes, but it relies on the Consensus Contract to send `IsEvilNode = true`: [5](#0-4) 

- During term transitions, only accumulated statistics are sent (via `UpdateCurrentMinerInformationToElectionContract`), never the evil node flag
- Terms change predictably based on `PeriodSeconds` configuration (default 604,800 seconds = 7 days): [6](#0-5) 

### Impact Explanation

**Consensus Integrity Compromise:**
- Miners can accumulate up to 4,319 missed time slots (just below the 4,320 threshold) repeatedly across term boundaries without ever being marked as evil nodes
- Even miners who exceed the threshold during a term transition escape detection due to the immediate counter reset
- This undermines the fundamental consensus mechanism designed to ensure reliable block production and penalize non-performing validators

**Affected Parties:**
- **Blockchain network:** Reduced block production reliability and increased likelihood of consensus delays
- **Token holders:** Reduced network security and value as unreliable miners remain active
- **Honest miners:** Unfair competition as malicious miners face no consequences for poor performance

**Severity Justification:**
This is a **High severity** vulnerability because:
1. It completely bypasses a critical security mechanism (evil miner detection)
2. It allows persistent violations of consensus rules without consequences
3. It affects core blockchain integrity rather than isolated features
4. The exploit is deterministic and repeatable indefinitely

### Likelihood Explanation

**Attacker Capabilities:**
- Any active miner in the consensus set can exploit this vulnerability
- No special permissions or complex attack setup required
- The attacker only needs to monitor term transition timing (publicly observable via blockchain state)

**Attack Complexity:**
- **Low complexity:** The exploit occurs automatically during normal term transitions
- Miners simply need to time their absences to coincide with or span across term boundaries
- Terms change predictably every `PeriodSeconds` (default 7 days), making timing trivial

**Feasibility Conditions:**
- Term transitions occur regularly and predictably on the main chain
- The `NeedToChangeTerm` check requires two-thirds of miners to have produced blocks past the term boundary, but this is a normal operational condition
- No special network conditions or elevated privileges required

**Detection Constraints:**
- The vulnerability leaves no obvious on-chain evidence since missed time slots are reset during term transitions
- Historical analysis would show patterns of miners consistently avoiding evil node detection across term boundaries
- However, individual term statistics appear normal since counters are reset

**Probability Assessment:**
- **High probability** of exploitation by rational actors
- Miners have economic incentive to minimize effort while maintaining validator status
- The predictable 7-day term cycle provides regular exploitation opportunities
- Over a year, a malicious miner could miss approximately 15% of their time slots (4,319 out of ~30,240 weekly slots) repeatedly without consequences

### Recommendation

**Immediate Fix:**
Add evil miner detection in `ProcessNextTerm` before resetting the `MissedTimeSlots` counter:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    RecordMinedMinerListOfCurrentRound();

    // Count missed time slot of current round.
    CountMissedTimeSlots();
    
    // ** ADD EVIL MINER DETECTION HERE **
    if (TryToGetCurrentRoundInformation(out var currentRound))
    {
        if (State.IsMainChain.Value && 
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected during term transition.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
    }

    Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");
    // ... rest of existing code
}
```

**Location for patch:** [7](#0-6) 

**Invariant to Enforce:**
- Evil miner detection MUST occur before any `MissedTimeSlots` counter reset
- This invariant should hold for both `ProcessNextRound` and `ProcessNextTerm`

**Test Cases to Add:**
1. Test that miners with 4,320+ missed slots during term transition are marked as evil
2. Test that miners with exactly 4,319 missed slots across a term boundary accumulate correctly in the next term
3. Test that evil detection occurs before counter reset in term transitions
4. Test multiple consecutive term transitions with accumulating missed slots

### Proof of Concept

**Initial State:**
- Blockchain is operational with main chain consensus
- Current term number: N
- Term period: 604,800 seconds (7 days, default)
- Malicious miner M is part of the active validator set
- `TolerableMissedTimeSlotsCount` = 4,320 time slots

**Exploitation Steps:**

1. **Days 1-3 of Term N:** Miner M misses 2,000 time slots
   - `MissedTimeSlots[M]` = 2,000
   - No evil detection triggered (below 4,320 threshold)

2. **Days 4-6 of Term N:** Miner M misses another 2,000 time slots
   - `MissedTimeSlots[M]` = 4,000
   - Still below threshold, no detection

3. **Day 7 of Term N:** Miner M misses 300 more time slots
   - `MissedTimeSlots[M]` = 4,300
   - Still below 4,320 threshold

4. **Term Transition (Day 7):** `ProcessNextTerm` is called
   - Line 168: `CountMissedTimeSlots()` may increment by 1 if M missed final slot
   - `MissedTimeSlots[M]` could now be 4,301 (still below threshold) or even 4,321 (above threshold)
   - **CRITICAL:** Lines 179-183 reset `MissedTimeSlots[M]` = 0
   - No `TryToDetectEvilMiners()` call occurs
   - Miner M is NOT marked as evil

5. **Term N+1 Begins:** Miner M starts fresh with `MissedTimeSlots[M]` = 0
   - Can immediately repeat the pattern for another 4,300+ missed slots

**Expected vs Actual Result:**
- **Expected:** Miner M should be marked as evil and removed from consensus after accumulating 4,320+ missed slots
- **Actual:** Miner M escapes detection during term transition, counter is reset, and M remains an active validator indefinitely

**Success Condition:**
The exploit succeeds if a miner can maintain validator status despite missing thousands of time slots per term across multiple terms without being marked as an evil node. This can be verified by:
1. Monitoring `EvilMinerDetected` events - they will never fire for the exploiting miner
2. Checking `State.BannedPubkeyMap[minerPubkey]` - it remains false/null
3. Observing miner remains in active consensus set despite poor performance

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```
