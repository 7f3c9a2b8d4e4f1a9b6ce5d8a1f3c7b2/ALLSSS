### Title
Removed System Contract Can Still Release Previously Created Proposals

### Summary
The `CreateProposalBySystemContract` function validates that the caller is a system contract only at proposal creation time, storing the system contract address as the proposer. However, the `Release` function does not re-validate that the proposer is still a valid system contract at release time. This allows a system contract that has been removed or replaced from the system contract mapping to still release proposals it created earlier, undermining security responses to compromised or outdated system contracts.

### Finding Description

The vulnerability exists in the Parliament contract's proposal lifecycle validation:

**At Proposal Creation:** [1](#0-0) 

The `CreateProposalBySystemContract` function validates that `Context.Sender` is in the system contract mapping at creation time, then stores this address as the proposal's proposer: [2](#0-1) 

**At Proposal Release:** [3](#0-2) 

The `Release` function only verifies that `Context.Sender` equals the stored proposer address and that the release threshold is reached. It does **not** re-validate whether the proposer is still a valid system contract.

**Root Cause:**
System contracts can be updated or replaced, changing their addresses in the system contract mapping managed by the Genesis contract. When a system contract is updated, the old address is no longer in the mapping, but proposals created by that old address remain valid with the old address as proposer. The Release function's authorization check only compares addresses without checking current system contract status.

### Impact Explanation

**Concrete Harm:**
- A system contract that has been removed or replaced (e.g., due to security vulnerabilities or upgrades) can still release proposals it created before removal
- This creates a "time bomb" effect where compromised system contracts retain execution privileges through pre-created proposals
- Undermines the security response mechanism when a system contract is identified as malicious or vulnerable

**Who Is Affected:**
- The Parliament governance system and all organizations using it
- Any proposals created by system contracts that are later updated or removed
- The security model assumes system contract privileges are revocable, but this assumption is violated

**Severity Justification:**
Medium severity because:
1. Requires the proposal to be approved by parliament (governance layer still active)
2. But parliament approved based on trust in the system contract proposer at that time
3. Once a system contract is deemed unsafe and removed, it should lose ALL privileges immediately
4. The vulnerability allows persistent execution rights after privilege revocation

### Likelihood Explanation

**Attacker Capabilities:**
- Control of or access to a system contract's private key (either through compromise or being the old deployment)
- Ability to create proposals before the system contract is updated or removed
- Wait for parliament approval before the security issue is discovered

**Attack Complexity:**
Low - the exploit requires only:
1. Creating proposals via `CreateProposalBySystemContract` 
2. Waiting for parliament approval
3. Calling `Release` after the system contract has been removed/updated

**Feasibility Conditions:**
- System contract updates/replacements are normal operational procedures in AElf
- When a system contract is upgraded, the old address stops being recognized as a system contract
- The Genesis contract manages the system contract name-to-address mapping, and updates change these mappings [4](#0-3) 

**Probability:**
Medium - System contracts are periodically updated for bug fixes, security patches, or feature additions. Any proposals created before an update remain exploitable by the old contract address.

### Recommendation

Add a re-validation check in the `Release` function to ensure the proposer is still authorized:

```csharp
public override Empty Release(Hash proposalId)
{
    var proposalInfo = GetValidProposal(proposalId);
    Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
    
    // Re-validate proposer authorization at release time
    var systemContracts = Context.GetSystemContractNameToAddressMapping().Values;
    bool isCurrentSystemContract = systemContracts.Contains(proposalInfo.Proposer);
    
    if (!isCurrentSystemContract)
    {
        // If proposer is no longer a system contract, verify it's still authorized as a regular proposer
        AssertIsAuthorizedProposer(proposalInfo.OrganizationAddress, proposalInfo.Proposer);
    }
    
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    // ... rest of existing code
}
```

**Additional Invariant Check:**
Store a flag in `ProposalInfo` indicating whether the proposal was created via `CreateProposalBySystemContract`, and enforce that system contract proposals can only be released if the proposer is still a valid system contract.

**Test Cases:**
1. Create proposal via system contract → update system contract → attempt release from old address → should fail
2. Create proposal via system contract → remove from mapping → attempt release → should fail
3. Create proposal via regular method → release after proposer loses authorization → should fail

### Proof of Concept

**Initial State:**
- System Contract A (address 0xSYS_A) is registered in the system contract mapping
- Parliament organization exists with standard approval thresholds

**Exploit Steps:**

1. **Proposal Creation** - System Contract A creates a proposal:
   ```
   CreateProposalBySystemContract({
     ProposalInput: {
       OrganizationAddress: parliamentOrg,
       ToAddress: targetContract,
       ContractMethodName: "MaliciousMethod",
       Params: maliciousParams,
       ExpiredTime: futureTime
     },
     OriginProposer: legitimateUser
   })
   ```
   Result: Proposal created with Proposer = 0xSYS_A

2. **Parliament Approves** - Miners approve the proposal (appears legitimate)
   Result: Proposal reaches release threshold

3. **System Contract Updated** - System Contract A is updated to 0xSYS_B
   - Genesis contract updates NameAddressMapping
   - 0xSYS_A is no longer in system contract mapping
   Result: 0xSYS_A loses system contract status

4. **Malicious Release** - Old address 0xSYS_A calls Release:
   ```
   Release(proposalId)
   ```
   
**Expected Result:** Release should fail because 0xSYS_A is no longer a valid system contract

**Actual Result:** Release succeeds because:
- Context.Sender (0xSYS_A) == Proposer (0xSYS_A) ✓
- IsReleaseThresholdReached returns true ✓
- No re-validation of system contract status
- Malicious proposal executes despite system contract removal

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L68-76)
```csharp
    public override Hash CreateProposalBySystemContract(CreateProposalBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Unauthorized to propose.");
        AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);

        var proposalId = CreateNewProposal(input.ProposalInput);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L225-253)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L324-337)
```csharp
    public override Address UpdateSmartContract(ContractUpdateInput input)
    {
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        var inputHash = CalculateHashFromInput(input);

        if (!TryClearContractProposingData(inputHash, out _))
            Assert(Context.Sender == info.Author, "No permission.");

        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);

        return contractAddress;
    }
```
