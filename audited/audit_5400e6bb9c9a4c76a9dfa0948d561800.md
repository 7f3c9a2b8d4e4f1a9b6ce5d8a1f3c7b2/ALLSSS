# Audit Report

## Title
Unvalidated Negative Order Assignment Enables Mining Schedule Corruption

## Summary
The `ProcessUpdateValue` function in the AEDPoS consensus contract accepts arbitrary `int32` values through `TuneOrderInformation` and directly assigns them to miners' `FinalOrderOfNextRound` without validation. A malicious miner can inject negative order values that corrupt the next round's mining schedule, causing past-dated timestamps, order gaps, and potential consensus failures.

## Finding Description

The vulnerability chain begins in `ProcessUpdateValue` where `TuneOrderInformation` values are directly assigned without any bounds checking: [1](#0-0) 

The protobuf schema defines both `tune_order_information` and `final_order_of_next_round` as `int32`, which permits negative values: [2](#0-1) [3](#0-2) 

When `GenerateNextRoundInformation` processes the next round, it directly uses these potentially negative `FinalOrderOfNextRound` values: [4](#0-3) 

The negative order value is used as a multiplier for calculating `ExpectedMiningTime`, resulting in timestamps in the past. The `ableOrders` range check only generates positive orders (1 to minersCount), so negative values in `occupiedOrders` don't filter any valid positions, creating order gaps: [5](#0-4) 

The `BreakContinuousMining` function expects miners at specific order positions and uses `.First()` which throws `InvalidOperationException` if no element matches: [6](#0-5) [7](#0-6) 

The validation layer provides no protection against this attack. The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue` fields: [8](#0-7) 

Access control only verifies the caller is a legitimate miner, not the validity of order values: [9](#0-8) 

**Attack Scenario:**
1. Malicious miner M1 calls `UpdateValue` with `TuneOrderInformation` mapping miner M2's pubkey to order value `-1`
2. `ProcessUpdateValue` applies this without validation, storing `FinalOrderOfNextRound = -1` for M2
3. When extra block producer generates the next round using `GenerateNextRoundInformation`:
   - M2 receives `Order = -1` and `ExpectedMiningTime` in the past
   - `occupiedOrders` includes `-1`, leaving a positive order position unassigned
   - `BreakContinuousMining` attempts to find miners at orders 1, 2, minersCount, minersCount-1
   - If any expected order is missing due to the negative value displacement, `.First()` throws an exception
4. NextRound transaction fails, preventing round advancement and stalling consensus

## Impact Explanation

**Consensus Integrity Violation:**
This vulnerability breaks the fundamental guarantee that mining rounds progress with properly ordered, chronologically sequenced blocks. The impacts include:

1. **Mining Schedule Corruption**: Negative orders create past-dated `ExpectedMiningTime` values, breaking the temporal ordering that AEDPoS consensus relies on for time slot validation and LIB calculation
2. **Order Sequence Gaps**: If 5 miners exist and one receives order -1, the valid range (1-5) will have a missing position, leaving some miners unable to mine
3. **Consensus Deadlock**: The `BreakContinuousMining` logic using `.First()` will throw exceptions when expected order positions are missing, causing `NextRound` transactions to fail and preventing round transitions
4. **Network-Wide Impact**: All nodes attempting to process the corrupted next round will fail, requiring manual intervention and potentially causing chain stalls

The severity is **Medium** because while it doesn't directly steal funds, it can completely halt block production and require emergency governance intervention to recover.

## Likelihood Explanation

**Attacker Requirements:**
- Must be a legitimate miner (passes `PreCheck` validation that verifies miner list membership)
- This is a realistic assumption as miners can be compromised, or malicious actors may become miners through the election process

**Attack Complexity:**
- **Low**: Single transaction with crafted `TuneOrderInformation` parameter
- No timing windows or race conditions required
- Can target any miner's order, not just attacker's own
- Attack is undetectable until next round generation occurs

**Economic Incentives:**
- Minimal cost: Standard transaction fee for `UpdateValue` call
- Potential benefits: Disrupting competitor miners, manipulating block production order for MEV opportunities
- Low risk of attribution since the corruption only manifests in the next round

**Probability Assessment: Medium**
While the attacker must be a miner, this is achievable through:
- Compromised miner node infrastructure
- Malicious operators in mining pools
- Intentional exploitation by elected miners with adversarial incentives

The attack's simplicity and lack of validation make it highly executable once miner status is obtained.

## Recommendation

Add validation in `ProcessUpdateValue` to ensure all `TuneOrderInformation` values are within the valid range `[1, minersCount]`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;

    // Validate TuneOrderInformation values
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(tuneOrder.Value > 0 && tuneOrder.Value <= minersCount, 
            $"Invalid order value: {tuneOrder.Value}. Must be between 1 and {minersCount}.");
        Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key),
            "Cannot tune order for non-existent miner.");
    }

    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    // ... rest of the method
}
```

Alternatively, add validation in `UpdateValueValidationProvider` to check order bounds before state changes occur.

## Proof of Concept

```csharp
[Fact]
public async Task NegativeOrderAssignment_CorruptsConsensus()
{
    // Setup: Initialize consensus with 5 miners
    var initialMiners = GenerateMiners(5);
    await InitializeConsensusAsync(initialMiners);
    
    // Attacker is miner at index 0
    var attackerKeyPair = initialMiners[0];
    var victimPubkey = initialMiners[1].PublicKey.ToHex();
    
    // Attacker crafts UpdateValue with negative order for victim
    var maliciousInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("test"),
        Signature = HashHelper.ComputeFrom("sig"),
        RoundId = 1,
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        SupposedOrderOfNextRound = 1,
        TuneOrderInformation = 
        {
            { victimPubkey, -1 } // Inject negative order
        },
        RandomNumber = ByteString.CopyFromUtf8("random")
    };
    
    // Execute malicious UpdateValue - should store negative order
    var updateResult = await ConsensusStub.UpdateValue.SendAsync(maliciousInput);
    updateResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify negative order was stored
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.RealTimeMinersInformation[victimPubkey]
        .FinalOrderOfNextRound.ShouldBe(-1); // Negative order stored!
    
    // Attempt to generate next round - should fail or produce corrupted schedule
    var nextRoundResult = await ConsensusStub.NextRound.SendAsync(new NextRoundInput());
    
    // Expected outcomes:
    // 1. Transaction fails due to BreakContinuousMining exception, OR
    // 2. Transaction succeeds but creates corrupted round with:
    //    - Miner with Order = -1
    //    - ExpectedMiningTime in the past
    //    - Missing order position in valid range
    
    if (nextRoundResult.TransactionResult.Status == TransactionResultStatus.Mined)
    {
        var nextRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
        var victimMiner = nextRound.RealTimeMinersInformation.Values
            .FirstOrDefault(m => m.Pubkey == victimPubkey);
        
        // Verify corruption
        victimMiner.Order.ShouldBe(-1); // Negative order in active round
        victimMiner.ExpectedMiningTime.ShouldBeLessThan(nextRound.RealTimeMinersInformation.Values.First().ExpectedMiningTime); // Past timestamp
        
        // Verify order gap exists
        var allOrders = nextRound.RealTimeMinersInformation.Values.Select(m => m.Order).ToList();
        allOrders.Should().Contain(-1);
        allOrders.Should().NotContain(5); // Order 5 missing if 5 miners exist
    }
}
```

## Notes

This vulnerability demonstrates a critical validation gap in the AEDPoS consensus mechanism. The protobuf schema's use of signed integers (`int32`) for order values, combined with the lack of bounds checking in `ProcessUpdateValue`, creates an exploitable path for consensus manipulation. The impact is amplified because the corruption propagates through round generation logic that assumes all order values are positive and within the valid range, leading to arithmetic errors (past timestamps) and logic failures (missing orders causing exceptions). The fix requires adding explicit validation at the entry point to reject any `TuneOrderInformation` values outside the range `[1, minersCount]`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** protobuf/aedpos_contract.proto (L208-208)
```text
    map<string, int32> tune_order_information = 7;
```

**File:** protobuf/aedpos_contract.proto (L290-290)
```text
    int32 final_order_of_next_round = 12;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-86)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L94-107)
```csharp
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```
