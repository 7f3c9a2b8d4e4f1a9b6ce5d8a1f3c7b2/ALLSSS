### Title
Authorization Bypass in Contract Update Proposals via Context.Self Author Field

### Summary
The `AssertAuthorityByContractInfo` function contains a critical logic flaw that allows any user to propose updates to contracts with `Author=Context.Self`. When contracts are deployed by non-whitelisted proposers, the system automatically sets their author to `Context.Self`, making these contracts permanently vulnerable to unauthorized update proposals from any address.

### Finding Description

The vulnerability exists in the authorization check at [1](#0-0) 

This function is invoked during contract update proposals at [2](#0-1) 

**Root Cause:**

The check evaluates `contractInfo.Author == Context.Self || address == contractInfo.Author`. When a contract has `Author = Context.Self`, the first condition is ALWAYS true regardless of the caller's identity. This bypasses the intended restriction that only contract authors should propose updates.

**How Contracts Get Author=Context.Self:**

During deployment via [3](#0-2) , the author is determined by `DecideNonSystemContractAuthor`. This function at [4](#0-3)  returns `Context.Self` when the proposer is not in the deployment whitelist.

Tests confirm this behavior at [5](#0-4)  where deployed contracts have `Author = BasicContractZeroAddress`.

**Why Existing Protections Fail:**

The check conflates two different concepts:
1. Whether the **contract's author field** equals the Genesis contract address (stored state)
2. Whether the **current caller** is the Genesis contract (execution context)

The intended logic should verify `Context.Sender == Context.Self` (caller is Genesis) OR `Context.Sender == contractInfo.Author` (caller is author), but instead checks if the author *field* contains Genesis address.

### Impact Explanation

**Authorization Bypass:**
Any user can call `ProposeUpdateContract` on contracts with `Author=Context.Self`, completely bypassing author authorization. While governance still must approve updates, the proposal stage should be restricted to authorized parties.

**Affected Contracts:**
All contracts deployed when proposers were not in the deployment whitelist have `Author=Context.Self` and are vulnerable.

**Attack Vectors:**
1. **DoS via Proposal Spam:** Attackers can flood the governance system with malicious update proposals for these contracts
2. **Governance Exploitation:** If governance is compromised or has weak approval thresholds, malicious code updates could be pushed through
3. **Reputation/Confusion:** Legitimate contract owners lose exclusive control over their contract's update lifecycle

**Severity Justification:**
Critical - This violates the fundamental access control invariant that only contract authors should propose updates. The flaw creates a permanent vulnerability for an entire class of contracts, with no remediation possible for already-deployed contracts.

### Likelihood Explanation

**Attacker Capabilities:**
- No special permissions required
- Any address can call `ProposeUpdateContract`
- No economic cost beyond transaction fees

**Attack Complexity:**
- Trivial single-transaction exploit
- No race conditions or timing dependencies
- Simply call `ProposeUpdateContract` with target contract address and malicious code

**Feasibility Conditions:**
- Contracts with `Author=Context.Self` exist by design when non-whitelisted proposers deploy contracts
- This is a normal operational scenario, not an edge case
- The vulnerable check executes on every update proposal

**Probability:**
High - The vulnerability is deterministic and affects all contracts meeting the author condition. Given that the system is designed to set `Author=Context.Self` for non-whitelisted deployments, affected contracts will inevitably exist.

### Recommendation

**Code-Level Fix:**

Replace the authorization check in `AssertAuthorityByContractInfo` to verify the CALLER's identity, not the stored author field:

```csharp
private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
{
    Assert(Context.Sender == Context.Self || address == contractInfo.Author, "No permission.");
}
```

This checks whether the Genesis contract itself is calling (system update) OR the caller matches the contract's author.

**Additional Safeguards:**

1. Add explicit validation in `ProposeUpdateContract` before calling `AssertAuthorityByContractInfo`
2. For contracts with `Author=Context.Self`, require governance pre-approval or special authorization path
3. Add circuit breaker to limit proposal rates per contract per address

**Test Cases:**

1. Deploy contract with `Author=Context.Self` (non-whitelisted proposer scenario)
2. Attempt `ProposeUpdateContract` from unauthorized address
3. Verify transaction fails with "No permission" error
4. Verify legitimate Genesis contract updates still work
5. Add regression test covering the specific authorization matrix

### Proof of Concept

**Initial State:**
- Genesis contract deployed and initialized
- Contract deployment authority required is true
- Attacker address is NOT in deployment whitelist

**Attack Steps:**

1. **Deploy Target Contract** (as non-whitelisted user):
   - Call `ProposeNewContract` with legitimate contract code
   - Wait for governance approval
   - Contract deploys with `Author=Context.Self` (Genesis address)

2. **Exploit Authorization Bypass** (from attacker address):
   - Call `ProposeUpdateContract` with:
     - Address: the deployed contract
     - Code: malicious bytecode
   - Authorization check passes because `contractInfo.Author == Context.Self` evaluates to TRUE
   - Update proposal created successfully with attacker as proposer

**Expected vs Actual Result:**

- **Expected:** Transaction fails with "No permission" error because attacker is not the contract author
- **Actual:** Transaction succeeds, creating update proposal that only requires governance approval

**Success Condition:**
The attacker successfully creates a contract update proposal despite not being the contract author, demonstrating complete authorization bypass for the proposal stage.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L183-183)
```csharp
        AssertAuthorityByContractInfo(info, Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L319-319)
```csharp
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L826-837)
```csharp
        creator.ShouldBe(BasicContractZeroAddress);

        var deployAddress = ContractDeployed.Parser
            .ParseFrom(deploymentResult.Logs.First(l => l.Name.Contains(nameof(ContractDeployed))).NonIndexed)
            .Address;

        deployAddress.ShouldNotBeNull();

        var author = Address.Parser.ParseFrom(await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractAuthor), deployAddress));

        author.ShouldBe(BasicContractZeroAddress);
```
