### Title
Missing Validation of Decrypted Secret Pieces Allows Consensus Randomness Manipulation

### Summary
The `UpdateLatestSecretPieces()` function accepts decrypted secret sharing pieces from miners without verifying they correspond to the encrypted pieces committed in previous rounds. This allows malicious miners to submit fake decrypted pieces, causing incorrect InValue reconstruction that affects signature calculations and miner ordering, breaking the VRF (Verifiable Random Function) randomness property of the consensus mechanism.

### Finding Description

**Vulnerable Entry Point:**
The `UpdateLatestSecretPieces()` function blindly accepts and stores decrypted pieces from miners without any validation: [1](#0-0) 

**Missing Validation in InValue Reconstruction:**
When `RevealSharedInValues()` reconstructs a miner's InValue from decrypted pieces, it performs no validation that the reconstructed value matches the originally committed OutValue: [2](#0-1) 

The critical missing check is: `Hash(DecodeSecret(decryptedPieces)) == OutValue`. The function uses `DecodeSecret()` to reconstruct the InValue and computes its hash, but never validates this against the miner's committed `OutValue` from the previous round.

**Impact on Consensus:**
The fake PreviousInValue is later used in `SupplyCurrentRoundInformation()` to calculate signatures for miners who didn't produce blocks: [3](#0-2) 

This signature directly affects miner ordering via the `CalculateSignature()` method: [4](#0-3) 

The signature value determines `FinalOrderOfNextRound` through modulo calculation: [5](#0-4) 

**Why Existing Protections Fail:**

1. **Validation Only Checks Self:** The `UpdateValueValidationProvider` only validates the block producer's own PreviousInValue, not other miners' revealed values: [6](#0-5) 

2. **No Cryptographic Authentication:** The encryption scheme uses ECDH+AES which provides confidentiality but not authenticity. Each piece is encrypted for a specific recipient, so only they can decrypt it, but there's no mechanism to prove the claimed decryption is correct: [7](#0-6) [8](#0-7) 

3. **Off-Chain Service Mirrors Vulnerability:** The off-chain `SecretSharingService` has the same issue - it reconstructs InValues without validation: [9](#0-8) 

### Impact Explanation

**Consensus Integrity Breach:**
- Malicious miners can manipulate which miners get assigned to which time slots in subsequent rounds
- This breaks the unpredictability guarantee of the VRF-based consensus mechanism
- Attackers can increase their own mining frequency or favor/punish specific miners

**Concrete Attack Scenario:**
1. Round N: Miner A commits OutValue_A = Hash(InValue_A) and shares encrypted pieces
2. Round N+1: Malicious Miner B submits fake decrypted pieces (not the actual decryption)
3. Round N+1: `RevealSharedInValues()` uses fake pieces to reconstruct fake InValue_A'
4. Round N+2: If Miner A didn't mine, `SupplyCurrentRoundInformation()` uses fake InValue_A' to calculate Miner A's signature
5. Result: Miner A gets assigned wrong order in next round, breaking randomness

**Protocol Damage:**
- Violates the "Correct round transitions and miner schedule integrity" invariant
- Undermines fairness of block production opportunities
- Enables strategic manipulation of consensus order for economic gain

**Affected Parties:**
- All honest miners whose encrypted pieces can be maliciously "decrypted"
- Network security as consensus randomness is foundational to the protocol

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a current miner (realistic - these are elected positions)
- Requires secret sharing to be enabled (controlled by configuration, typically enabled)
- No special privileges needed beyond miner status

**Attack Complexity:**
- Low - attacker simply submits arbitrary bytes as "decrypted" pieces instead of actual decryption
- No complex cryptographic attacks required
- Can be executed during normal block production

**Feasibility Conditions:**
- Secret sharing must be enabled (checked via `IsSecretSharingEnabled()`)
- Target miners must have submitted encrypted pieces in previous rounds
- Attacker needs to be mining when UpdateValue behavior occurs

**Detection Difficulty:**
- Very hard to detect - fake pieces look identical to real ones on-chain
- No way to verify claimed decryption without recipient's private key
- Would require off-chain analysis to identify statistical anomalies in miner ordering

**Economic Rationality:**
- Attack cost: minimal (just submitting wrong data during normal mining)
- Potential gain: improved mining positions, favoring allies, punishing competitors
- Risk: low (undetectable through normal validation)

### Recommendation

**Immediate Fix:**
Add validation in `RevealSharedInValues()` to check reconstructed InValues against committed OutValues:

```csharp
// After line 50 in AEDPoSContract_SecretSharing.cs
var revealedInValue =
    HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// ADD THIS VALIDATION:
if (anotherMinerInPreviousRound.OutValue != null && 
    revealedInValue != anotherMinerInPreviousRound.OutValue)
{
    Context.LogDebug(() => 
        $"Invalid secret sharing: revealed InValue {revealedInValue} doesn't match OutValue {anotherMinerInPreviousRound.OutValue} for miner {publicKeyOfAnotherMiner}");
    continue; // Skip setting PreviousInValue for this miner
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**Additional Safeguards:**
1. Apply same validation in off-chain `SecretSharingService.RevealPreviousInValues()`
2. When processing `RevealedInValues` in `UpdateLatestSecretPieces()`, validate before setting PreviousInValue
3. Add monitoring/alerting for failed InValue reconstructions indicating potential attacks

**Test Cases:**
1. Test that fake decrypted pieces are rejected when reconstructed InValue doesn't match OutValue
2. Test that honest decrypted pieces are accepted when hash matches
3. Test that signature calculations use only validated InValues
4. Test attack scenario where malicious miner submits fake pieces and verify it's blocked

### Proof of Concept

**Initial State:**
- Secret sharing enabled in configuration
- 5 miners active in Round N: MinerA, MinerB (malicious), MinerC, MinerD, MinerE
- MinerA generates InValue_A = Hash("secret_A")
- MinerA publishes OutValue_A = Hash(InValue_A) = Hash(Hash("secret_A"))
- MinerA encrypts secret shares for all other miners

**Attack Steps:**

1. **Round N+1 - UpdateValue behavior by MinerB:**
   - MinerB receives encrypted piece for MinerA's InValue_A
   - Instead of correctly decrypting to get piece_B = Decrypt(encrypted_B)
   - MinerB submits fake_piece_B = Hash("malicious_data")
   - `UpdateLatestSecretPieces()` accepts fake_piece_B without validation

2. **Round N+1 - NextRound behavior:**
   - `RevealSharedInValues()` collects decrypted pieces including fake_piece_B
   - Reconstructs fake_InValue_A = Hash(DecodeSecret([fake_piece_B, piece_C, piece_D, piece_E]))
   - Sets MinerA's PreviousInValue = fake_InValue_A (no validation against OutValue_A)

3. **Round N+2 - MinerA didn't mine:**
   - `SupplyCurrentRoundInformation()` retrieves MinerA's PreviousInValue = fake_InValue_A
   - Calculates fake_signature_A = CalculateSignature(fake_InValue_A)
   - MinerA assigned wrong FinalOrderOfNextRound based on fake_signature_A

**Expected Result:**
- System should reject fake_piece_B by validating Hash(DecodeSecret(pieces)) == OutValue_A
- MinerA's order should be based on real InValue_A

**Actual Result:**
- Fake pieces accepted without validation
- MinerA assigned manipulated order in next round
- Consensus randomness compromised

**Success Condition:**
- Attacker successfully changes target miner's order by â‰¥1 position compared to honest reconstruction
- Attack undetectable through standard validation flows

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L46-52)
```csharp
            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-114)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-48)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** src/AElf.Cryptography/CryptoHelper.cs (L142-153)
```csharp
        public static byte[] EncryptMessage(byte[] senderPrivateKey, byte[] receiverPublicKey, byte[] plainText)
        {
            var keyBytes = GetSharedSecret(senderPrivateKey, receiverPublicKey);

            var cipher = new PaddedBufferedBlockCipher(new CbcBlockCipher(new AesEngine()));
            cipher.Init(true, new ParametersWithIV(new KeyParameter(keyBytes), new byte[16]));

            var cipherText = new byte[cipher.GetOutputSize(plainText.Length)];
            var len = cipher.ProcessBytes(plainText, 0, plainText.Length, cipherText, 0);
            cipher.DoFinal(cipherText, len);

            return cipherText;
```

**File:** src/AElf.Cryptography/CryptoHelper.cs (L156-171)
```csharp
        public static byte[] DecryptMessage(byte[] senderPublicKey, byte[] receiverPrivateKey, byte[] cipherText)
        {
            var keyBytes = GetSharedSecret(receiverPrivateKey, senderPublicKey);

            var cipher = new PaddedBufferedBlockCipher(new CbcBlockCipher(new AesEngine()));
            cipher.Init(false, new ParametersWithIV(new KeyParameter(keyBytes), new byte[16]));

            var temp = new byte[cipher.GetOutputSize(cipherText.Length)];
            var len = cipher.ProcessBytes(cipherText, 0, cipherText.Length, temp, 0);
            len += cipher.DoFinal(temp, len);

            // Remove padding
            var plainText = new byte[len];
            Array.Copy(temp, 0, plainText, 0, len);

            return plainText;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L172-180)
```csharp
            var sharedParts = minerInRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            Logger.LogDebug($"Revealed in value of {pubkey} of round {round.RoundNumber}: {revealedInValue}");

            revealedInValues[pubkey] = revealedInValue;
```
