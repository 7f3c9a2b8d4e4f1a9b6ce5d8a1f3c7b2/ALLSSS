### Title
Banned Miners Can Continue Producing Blocks for One Round Due to Missing Ban Status Check in Mining Permission Validation

### Summary
The `MiningPermissionValidationProvider` only verifies if a miner's public key exists in `RealTimeMinersInformation.Keys` but does not check the `BannedPubkeyMap` state maintained by the Election contract. This creates a one-round window where miners detected as evil and banned can continue producing blocks because they remain in `RealTimeMinersInformation` until the next round transition, allowing them to earn rewards and participate in consensus despite being punished.

### Finding Description

The root cause is in `MiningPermissionValidationProvider.ValidateHeaderInformation()` which only performs a simple key existence check: [1](#0-0) 

The validation does not query the Election contract's `BannedPubkeyMap` to verify if the miner has been banned.

**Timing Vulnerability Flow:**

1. **Round N ends - Evil miner detection:** When `ProcessNextRound` is called, evil miners are detected based on missed time slots and marked in `BannedPubkeyMap`: [2](#0-1) 

The detection logic identifies miners who missed too many time slots: [3](#0-2) 

2. **Marking in BannedPubkeyMap:** The Election contract's `UpdateCandidateInformation` sets the ban flag: [4](#0-3) 

3. **Round N+1 generation timing issue:** The next round (N+1) is generated by the extra block producer BEFORE `ProcessNextRound` executes. When `GenerateNextRoundInformation` is called, it queries for evil miners: [5](#0-4) 

The `GetMinerReplacementInformation` checks `BannedPubkeyMap`: [6](#0-5) 

However, at this point the miner hasn't been marked as banned yet (that happens later in `ProcessNextRound`), so they remain in Round N+1's `RealTimeMinersInformation`.

4. **Round N+1 execution:** The banned miner can produce blocks because validation only checks `RealTimeMinersInformation.Keys`: [7](#0-6) 

5. **Round N+2 generation - Finally removed:** Only when Round N+2 is generated does `GetEvilMinersPubkeys` find the banned miner and remove them from `RealTimeMinersInformation`: [8](#0-7) 

The `ConsensusValidationContext` passed to validation providers contains no reference to Election contract state or ban status: [9](#0-8) 

### Impact Explanation

**Consensus Integrity Impact:**
- Evil miners who missed too many time slots (≥4,320 slots over 3 days per constants) can continue participating in consensus for one additional round [10](#0-9) 

- They can produce blocks, earn mining rewards, and influence consensus decisions during the grace period

**Reward Misallocation:**
- Banned miners continue receiving block production rewards for blocks mined during the vulnerability window
- Legitimate alternative candidates who should have replaced them lose potential rewards

**Punishment Mechanism Bypass:**
- The slashing/punishment mechanism is weakened as it doesn't take immediate effect
- Malicious miners can exploit the known one-round delay to maximize damage before removal

**Chain Stability Risk:**
- Evil miners with a history of missing time slots can continue producing blocks inconsistently
- This undermines the reliability guarantees that the evil miner detection mechanism was designed to provide

### Likelihood Explanation

**Certainty: High**
- This is not an attack but an inherent timing gap in the consensus state machine
- Occurs automatically whenever any miner meets the evil miner criteria (missing ≥4,320 time slots)

**No Special Preconditions Required:**
- No attacker-specific actions needed beyond normal mining participation
- The vulnerability is triggered by the consensus protocol's own detection mechanism

**Execution Complexity: None**
- Once a miner is detected as evil, they automatically get the one-round grace period
- No special transactions or state manipulation required

**Detection: Transparent**
- The banned miner's continued participation is visible on-chain
- However, by design, validators have no mechanism to reject their blocks during the grace round

**Economic Rationality:**
- Minimal cost to the evil miner (they're already being removed)
- They gain additional block rewards during the grace period
- No additional risk since they're already marked for removal

### Recommendation

**Immediate Fix:** Add ban status verification to `MiningPermissionValidationProvider`:

```csharp
public class MiningPermissionValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        // NEW: Check if miner is banned
        if (validationContext.IsMinerBanned != null && validationContext.IsMinerBanned(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is banned.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
}
```

**Required Changes:**

1. Extend `ConsensusValidationContext` to include a ban status check function that queries the Election contract's `BannedPubkeyMap`

2. Modify the validation setup in `AEDPoSContract_Validation.cs` to provide the Election contract reference to the validation context

3. Alternatively, implement immediate removal: When `ProcessNextRound` detects evil miners, immediately update the current round's `RealTimeMinersInformation` to remove them before saving the next round

**Invariant to Enforce:**
- Any miner with `BannedPubkeyMap[pubkey] == true` must not be able to produce blocks, regardless of their presence in `RealTimeMinersInformation`

**Test Cases:**
1. Detect a miner as evil at round N transition
2. Verify the banned miner cannot produce any blocks in round N+1
3. Verify alternative candidate immediately takes their place
4. Test that emergency bans (via `RemoveEvilNode`) are also enforced immediately

### Proof of Concept

**Initial State:**
- Round N in progress
- Miner A has accumulated MissedTimeSlots = 4,320 (meets evil threshold)
- Miner A is in Round N's `RealTimeMinersInformation`
- `BannedPubkeyMap[A]` = false

**Transaction Sequence:**

**Step 1 - Round N Ends:**
- Extra block producer generates Round N+1 via `GetConsensusExtraDataForNextRound`
- `GenerateNextRoundInformation` calls `GetMinerReplacementInformation`
- `GetEvilMinersPubkeys` checks `BannedPubkeyMap[A]` → returns false (not yet banned)
- Miner A remains in Round N+1's `RealTimeMinersInformation`
- Extra block is produced with Round N+1 data

**Step 2 - Block Processing:**
- `ProcessNextRound` executes
- `TryToDetectEvilMiners` identifies Miner A (MissedTimeSlots ≥ 4,320)
- `UpdateCandidateInformation` called with `IsEvilNode = true`
- `BannedPubkeyMap[A]` set to true
- Round N+1 saved with Miner A still present

**Step 3 - Round N+1 Block Production:**
- Miner A's time slot arrives in Round N+1
- Miner A produces a block
- `ValidateBeforeExecution` is called
- `MiningPermissionValidationProvider.ValidateHeaderInformation` checks:
  - `RealTimeMinersInformation.Keys.Contains(A)` → true ✓
  - **BUG: Does not check `BannedPubkeyMap[A]` → true** ✗
- Validation passes, block accepted
- Miner A receives block reward

**Expected vs Actual:**
- **Expected:** Miner A's block rejected, validation fails with "Sender is banned"
- **Actual:** Miner A's block accepted, continues mining through Round N+1

**Success Condition:**
The banned miner successfully produces at least one block during Round N+1 before being removed in Round N+2 generation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L300-305)
```csharp
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L337-338)
```csharp
                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-75)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L8-41)
```csharp
public class ConsensusValidationContext
{
    public long CurrentTermNumber { get; set; }
    public long CurrentRoundNumber { get; set; }

    /// <summary>
    ///     We can trust this because we already validated the pubkey
    ///     during `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`
    /// </summary>
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();

    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;

    /// <summary>
    ///     Previous round information fetch from StateDb.
    /// </summary>
    public Round PreviousRound { get; set; }

    /// <summary>
    ///     This filed is to prevent one miner produces too many continues blocks
    ///     (which may cause problems to other parts).
    /// </summary>
    public LatestPubkeyToTinyBlocksCount LatestPubkeyToTinyBlocksCount { get; set; }

    public AElfConsensusHeaderInformation ExtraData { get; set; }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```
