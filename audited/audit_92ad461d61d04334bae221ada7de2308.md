# Audit Report

## Title
Scheme Manager Can Dilute User Profits by Adding Phantom Shares Without Token Locking

## Summary
The TokenHolder contract allows scheme managers to add beneficiaries with arbitrary shares without requiring token locking, while regular users must lock tokens to receive shares. This creates an exploitable asymmetry where managers can dilute legitimate users' profits by adding phantom shares immediately before distribution.

## Finding Description

The TokenHolder contract provides two fundamentally different paths for becoming a profit beneficiary, creating a critical economic imbalance:

**Regular User Path (RegisterForProfits):** Users must lock tokens to participate. The function enforces a 1:1 correspondence between locked tokens and profit shares. [1](#0-0) 

**Manager Path (AddBeneficiary):** The scheme manager can directly add any beneficiary with arbitrary shares without any token locking requirement. The only check is that the caller must be the scheme manager. [2](#0-1) 

The underlying Profit contract authorization allows both the scheme manager and TokenHolder contract to add beneficiaries, but performs no validation of economic backing. [3](#0-2) 

When profits are distributed, all shares are treated equally using proportional allocation, with no distinction between shares backed by locked tokens and unbacked phantom shares. [4](#0-3) 

**Critical Timing Vulnerability:** TokenHolder schemes do not set `DelayDistributePeriodCount` when created, meaning it defaults to 0. [5](#0-4)  This allows newly added shares to participate in the current period's distribution immediately. [6](#0-5) 

The manager has exclusive control over distribution timing, enabling atomic addition of phantom shares followed by immediate distribution. [7](#0-6) 

## Impact Explanation

This vulnerability enables direct theft of user funds through profit dilution. When legitimate users lock tokens to receive profit shares, a malicious manager can add themselves as a beneficiary with massive unbacked shares, proportionally reducing each user's profit allocation.

**Concrete Example:**
- User A locks 1,000 tokens → receives 1,000 shares
- 10,000 tokens contributed as profits
- Manager calls `AddBeneficiary` adding themselves with 9,000 phantom shares (no tokens locked)
- Manager calls `DistributeProfits`
- Total shares: 10,000 (1,000 legitimate + 9,000 phantom)
- User A receives: (1,000/10,000) × 10,000 = 1,000 tokens (should have been 10,000)
- Manager receives: (9,000/10,000) × 10,000 = 9,000 tokens (with zero economic contribution)

The attack scales with profit amounts and can completely drain user entitlements. The scheme manager role is not a privileged system position requiring governance approval - any address can create a scheme and become its manager. [8](#0-7) 

This violates the fundamental economic invariant that profit shares should correspond to locked economic value, as explicitly documented for RegisterForProfits. [9](#0-8) 

## Likelihood Explanation

The attack has HIGH likelihood due to:

**Low Complexity:** Requires only a single `AddBeneficiary` transaction specifying the manager's address and desired share amount, followed by `DistributeProfits`. No complex state manipulation needed.

**Full Control:** The manager has complete control over distribution timing, eliminating any front-running risk or timing constraints. They can add phantom shares in the same block as distribution.

**Zero Cost:** No token locking or economic stake required for the attack. The manager risks nothing and gains proportional profit share.

**Difficult Detection:** Users cannot predict when the manager will add beneficiaries or trigger distribution. The attack is only observable post-execution through reduced profit amounts.

**Economic Rationality:** For any scheme where managers have financial incentive to maximize profits, this attack is economically rational with guaranteed success.

Anyone can create schemes and become manager without restrictions, meaning this is not limited to compromised privileged accounts.

## Recommendation

Implement one or more of the following mitigations:

1. **Require Token Backing for All Shares:** Modify `AddBeneficiary` to require the manager to lock tokens equal to the shares being added, ensuring economic backing for all shares regardless of entry path.

2. **Implement Mandatory Delay:** Set a non-zero `DelayDistributePeriodCount` for TokenHolder schemes to prevent newly added shares from immediately participating in the current period's distribution.

3. **Add Transparency Checks:** Emit events when beneficiaries are added and enforce a minimum time delay between `AddBeneficiary` and `DistributeProfits` calls to give users visibility.

4. **Restrict Manager Powers:** Remove the manager's ability to call `AddBeneficiary` directly, requiring all beneficiaries to enter through `RegisterForProfits` with token locking.

The recommended fix is option 1 combined with option 2, as it preserves the manager's administrative capabilities while ensuring economic fairness.

## Proof of Concept

```csharp
// Test demonstrating profit dilution attack
public async Task ManagerCanDiluteUserProfits()
{
    // 1. Manager creates scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 0
    });
    
    // 2. User locks 1000 tokens and registers
    await TokenContractStub.Approve.SendAsync(new ApproveInput 
    { 
        Spender = TokenHolderContractAddress,
        Symbol = "ELF", 
        Amount = 1000 
    });
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = ManagerAddress,
        Amount = 1000
    });
    
    // 3. Someone contributes 10000 tokens profit
    await ContributeProfits(10000);
    
    // 4. ATTACK: Manager adds themselves with 9000 phantom shares (no locking)
    await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = ManagerAddress,
        Shares = 9000
    });
    
    // 5. Manager distributes profits
    await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeManager = ManagerAddress
    });
    
    // 6. Verify dilution
    await TokenHolderContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeManager = ManagerAddress,
        Beneficiary = UserAddress
    });
    
    var userBalance = await GetBalance(UserAddress, "ELF");
    var managerBalance = await GetBalance(ManagerAddress, "ELF");
    
    // User should have received 10000 but only gets 1000 (10%)
    // Manager receives 9000 (90%) without locking any tokens
    Assert.Equal(1000, userBalance); // User gets only 10% instead of 100%
    Assert.Equal(9000, managerBalance); // Manager gets 90% with zero contribution
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-68)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }

        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = shares
            }
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L134-135)
```csharp
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-176)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** docs/resources/smart-contract-apis/token-holder.md (L95-97)
```markdown
**RegisterForProfitsInput**:
- **scheme manager**: manager of the scheme; when creating the scheme the Sender is set to manager. 
- **amount**: the amount of tokens to lock (and will correspond to the amount of shares). 
```
