### Title
Method Fee Controller Can Be Irreversibly Changed to Uncontrolled Organization

### Summary
The `ChangeMethodFeeController()` function allows the current controller to change the method fee controller to any valid organization address without verifying that the caller has authority over the new organization. This enables accidental or malicious lockout scenarios where control over method fees is transferred to an organization that the previous controller cannot access, requiring difficult or impossible governance intervention for recovery.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController()` method which validates the new controller organization insufficiently. [1](#0-0) 

The root cause is at lines 29-30, where `CheckOrganizationExist(input)` only validates that the new organization exists in storage, but does NOT verify that the caller has any authority, membership, or proposal rights in that organization. [2](#0-1) 

The `CheckOrganizationExist` implementation confirms this insufficient validation - it merely checks if `State.Organizations[address]` is not null: [3](#0-2) 

This pattern is consistent across all governance contracts (Association, Referendum, Parliament), meaning any of them can be the target of this lockout scenario. [4](#0-3) 

### Impact Explanation

**Operational Impact**: Loss of control over method fee configuration for the AEDPoS consensus contract, affecting protocol economics and transaction cost management. Method fees are critical for:
- Preventing spam attacks
- Economic sustainability of the network
- Resource allocation and pricing

**Affected Parties**: The current controller organization loses its ability to:
- Set method fees via `SetMethodFee()`
- Change the controller back via `ChangeMethodFeeController()`

**Recovery Difficulty**: No emergency override mechanism exists in the codebase. Recovery requires governance intervention through the NEW organization, which may be:
- Controlled by different parties with conflicting interests
- Configured with unreachable thresholds
- Effectively abandoned or misconfigured
- Impossible to access if the organization was chosen maliciously

**Severity Justification**: Medium severity because while it requires the current controller to execute the change (not an arbitrary attacker), the consequences are severe and potentially irreversible. The impact extends beyond a single contract - this pattern affects all 15 system contracts implementing ACS1.

### Likelihood Explanation

**Attacker Capabilities**: Requires being (or influencing) the current method fee controller. For the default case, this means controlling the Parliament default organization (typically requiring 2/3 miner approval).

**Attack Complexity**: Low - a single approved governance proposal can change the controller to any valid organization. The test suite demonstrates this exact scenario: [5](#0-4) 

**Feasibility Conditions**:
1. **Accidental Scenario**: A governance proposal with a typo or incorrect organization address gets approved
2. **Malicious Scenario**: A compromised or malicious proposal intentionally changes the controller to lock out current governance
3. **Migration Scenario**: During governance restructuring, the new organization is set before ensuring proper access rights

**Detection**: The change is permanent upon execution with no rollback mechanism. The unauthorized access attempt would only be detected when trying to set fees or change controller again, at which point the lockout has already occurred.

**Probability**: Moderate - governance systems regularly undergo proposals for controller changes, increasing the risk of accidental misconfiguration or malicious exploitation.

### Recommendation

**Code-Level Mitigation**:

1. Add validation that the caller (or current controller) has authority in the new organization before allowing the change:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // NEW: Verify caller has authority in the new organization
    var hasAuthority = Context.Call<BoolValue>(
        input.ContractAddress,
        nameof(ValidateProposerInWhiteList),
        new ValidateProposerInWhiteListInput
        {
            OrganizationAddress = input.OwnerAddress,
            Proposer = Context.Sender
        }).Value;
    Assert(hasAuthority, "Caller has no authority in the new organization.");
    
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

2. Implement a two-step handoff mechanism with confirmation from the new organization:
   - Step 1: Current controller proposes new controller
   - Step 2: New controller must accept/claim the role
   - Timeout period after which the proposal expires

3. Add an emergency recovery path through a designated fallback organization (e.g., always allow the Genesis contract or a predefined emergency organization to reset the controller).

**Invariant Checks**: Add assertion that any controller change must be reversible by the current caller before committing the change.

**Test Cases**: Add regression tests for:
- Attempting to change controller to an organization where caller is not a member
- Attempting to change controller to an organization with unreachable thresholds
- Two-step handoff flow validation
- Emergency recovery mechanism validation

### Proof of Concept

**Initial State**:
- Method fee controller is Parliament default organization (controlled by miners with keys A, B, C)
- Association organization X exists with members D, E, F only

**Attack Steps**:

1. Miners A, B, C create a Parliament proposal to call `ChangeMethodFeeController` with:
   ```
   AuthorityInfo {
     ContractAddress: AssociationContractAddress,
     OwnerAddress: OrganizationX_Address
   }
   ```

2. Proposal gets 2/3 miner approval and is released

3. `ChangeMethodFeeController` executes:
   - Line 28: ✓ Sender is Parliament default organization (current controller)
   - Line 29-30: ✓ Organization X exists in Association contract
   - Line 32: Controller changed to Organization X

**Result**: 
- **Expected**: Change should be rejected because miners A, B, C have no authority in Organization X
- **Actual**: Change succeeds, miners A, B, C are now locked out
- **Success Condition**: Any subsequent call to `SetMethodFee()` or `ChangeMethodFeeController()` by the Parliament organization fails with "Unauthorized behavior."

**Recovery**: Requires convincing members D, E, F of Organization X to create an Association proposal to change the controller back, which they may refuse or be unable to do.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L25-34)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L83-88)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/ACS1ImplTest.cs (L14-47)
```csharp
    public async Task ChangeMethodFeeController_Test()
    {
        var createOrganizationResult =
            await ParliamentContractStub.CreateOrganization.SendAsync(
                new CreateOrganizationInput
                {
                    ProposalReleaseThreshold = new ProposalReleaseThreshold
                    {
                        MinimalApprovalThreshold = 1000,
                        MinimalVoteThreshold = 1000
                    }
                });
        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.TransactionResult.ReturnValue);

        var methodFeeController = await AEDPoSContractStub.GetMethodFeeController.CallAsync(new Empty());
        var defaultOrganization = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
        methodFeeController.OwnerAddress.ShouldBe(defaultOrganization);

        const string proposalCreationMethodName =
            nameof(AEDPoSContractImplContainer.AEDPoSContractImplStub.ChangeMethodFeeController);
        var proposalId = await CreateProposalAsync(ConsensusContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName, new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = methodFeeController.ContractAddress
            });
        await ApproveWithMinersAsync(proposalId);
        var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
        releaseResult.TransactionResult.Error.ShouldBeNullOrEmpty();
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var newMethodFeeController = await AEDPoSContractStub.GetMethodFeeController.CallAsync(new Empty());
        Assert.True(newMethodFeeController.OwnerAddress == organizationAddress);
    }
```
