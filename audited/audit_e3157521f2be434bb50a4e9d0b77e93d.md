# Audit Report

## Title
Evil Miners Continue Block Production After Being Banned Until Next Round Transition

## Summary
When a miner is marked as evil through `UpdateCandidateInformation()` or `RemoveEvilNode()`, the Election contract sets `BannedPubkeyMap` to true but the Consensus contract does not immediately enforce this ban. Evil miners remain in the current round's `RealTimeMinersInformation` and can continue producing blocks until the next round transition, creating a vulnerability window where officially banned miners participate in consensus.

## Finding Description
When an evil node is detected (either automatically or via governance), the Election contract's `UpdateCandidateInformation()` method is invoked with `IsEvilNode=true`. This sets the banned status in the Election contract's state. [1](#0-0) 

The governance path via `RemoveEvilNode()` allows the emergency response organization to ban miners mid-round. [2](#0-1) 

However, the Consensus contract's permission checks do not consult the banned status. The `PreCheck()` method only verifies miner list membership. [3](#0-2) 

The `IsInMinerList()` method performs no banned status check, only checking dictionary membership. [4](#0-3) 

The `MiningPermissionValidationProvider` similarly only validates miner list presence without checking banned status. [5](#0-4) 

Evil miner replacement only occurs during `GenerateNextRoundInformation()`, which is called when preparing the next round's consensus data. [6](#0-5) 

The Election contract's `GetMinerReplacementInformation()` checks `BannedPubkeyMap` to identify evil miners for replacement. [7](#0-6) 

This check only happens during next round generation, not during the current round's block production. [8](#0-7) 

## Impact Explanation
This breaks the critical consensus security invariant that only authorized, non-malicious miners should participate in block production. When emergency response organization (requiring 90% approval) takes action to ban a miner, the expectation is immediate enforcement, yet the banned miner continues operating.

**Consensus Integrity Violation**: Evil miners marked as banned continue earning mining rewards and producing blocks, undermining the AEDPoS security model.

**Vulnerability Window Duration**: With typical configuration of 17 miners and 4-second intervals, a round spans approximately 68 seconds. If a miner is banned early in their round participation, they could produce multiple additional blocks before round transition.

**Attack Opportunities**: During this window, the evil miner can censor transactions, include malicious transactions, continue earning undeserved rewards, and coordinate with other compromised nodes while officially banned.

The automatic detection threshold is 4320 missed time slots (3 days). [9](#0-8) 

## Likelihood Explanation
**Trigger Path 1 (Lower Risk)**: Automatic detection during `ProcessNextRound()` identifies miners who missed too many time slots and marks them as evil. [10](#0-9)  Since this occurs during round transition, the vulnerability window is minimal.

**Trigger Path 2 (Higher Risk)**: Governance action via `RemoveEvilNode()` can occur at any point during a round, creating a significant vulnerability window. This requires emergency response organization approval but represents a realistic scenario where swift action is needed against a malicious miner.

The vulnerability automatically manifests once either trigger occurs - no additional attacker capabilities are required beyond being the banned miner with remaining time slots in the current round.

## Recommendation
Implement immediate ban enforcement by adding `BannedPubkeyMap` checks to the permission validation logic:

1. **Modify `PreCheck()` method** to query Election contract's `BannedPubkeyMap` and reject blocks from banned miners
2. **Update `MiningPermissionValidationProvider.ValidateHeaderInformation()`** to check banned status before validating miner list membership
3. **Add cross-contract state check** in Consensus contract to consult Election contract's ban status during block validation

Alternative approach: Implement immediate miner list updates when `UpdateCandidateInformation(IsEvilNode=true)` is called, triggering mid-round miner list adjustment rather than waiting for round transition.

## Proof of Concept
The skipped test in the codebase demonstrates awareness of this issue. [11](#0-10)  The test marks a node as evil, then requires mining to the next round before verifying the evil node is removed from the miner list, confirming the delayed enforcement behavior.

To reproduce:
1. Set up test network with multiple active miners
2. Execute emergency organization proposal to `RemoveEvilNode()` mid-round
3. Verify `BannedPubkeyMap[miner] == true` in Election contract
4. Observe miner still present in `RealTimeMinersInformation` in Consensus contract
5. Verify banned miner can still produce blocks during their remaining time slots
6. Confirm miner only removed from active list after round transition

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-351)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L285-347)
```csharp
    private void GenerateNextRoundInformation(Round currentRound, Timestamp currentBlockTime, out Round nextRound)
    {
        TryToGetPreviousRoundInformation(out var previousRound);
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();
        var isMinerListChanged = false;
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }

        currentRound.GenerateNextRoundInformation(currentBlockTime, blockchainStartTimestamp, out nextRound,
            isMinerListChanged);
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-404)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
    }

    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** test/AElf.Contracts.Economic.AEDPoSExtension.Tests/EvilNodeRelatedTests.cs (L22-66)
```csharp
    [Fact(Skip = "Need fix.")]
    internal async Task MarkEvilNodeTest()
    {
        UpdateParliamentStubs(MissionedECKeyPairs.InitialKeyPairs);
        var newCandidates = MissionedECKeyPairs.ValidationDataCenterKeyPairs.Take(18).ToList();
        await NodesAnnounceElection(newCandidates);
        await BlockMiningService.MineBlockToNextTermAsync();

        var miners = newCandidates.Take(17).ToList();
        //UpdateParliamentStubs(miners);

        await BlockMiningService.MineBlockToNextRoundAsync();

        var defaultOrganizationAddress =
            await ParliamentStubs.First().GetDefaultOrganizationAddress.CallAsync(new Empty());
        await ParliamentReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ParliamentSmartContractAddressNameProvider.Name],
            ContractMethodName = "CreateEmergencyResponseOrganization",
            Params = new Empty().ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        var eroAddress =
            await ParliamentStubs.First().GetEmergencyResponseOrganizationAddress.CallAsync(new Empty());
        var evilNodePubkey = MissionedECKeyPairs.ValidationDataCenterKeyPairs.First().PublicKey.ToHex();
        await EmergencyResponseOrganizationReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ElectionSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ElectionStub.RemoveEvilNode),
            Params = new StringValue
            {
                Value = evilNodePubkey
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = eroAddress
        });
        await BlockMiningService.MineBlockToNextRoundAsync();
        miners.Remove(MissionedECKeyPairs.ValidationDataCenterKeyPairs.First());
        miners.Add(MissionedECKeyPairs.ValidationDataCenterKeyPairs.Skip(17).Take(1).First());
        UpdateParliamentStubs(miners);

        var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
        currentRound.RealTimeMinersInformation.Keys.ShouldNotContain(evilNodePubkey);
    }
```
