### Title
Unauthorized Manager Assignment in CreateScheme Enables Unbounded List Growth DoS Attack

### Summary
The `CreateScheme` function allows any caller to specify an arbitrary address as the scheme manager without authorization, enabling an attacker to create unlimited schemes for a victim address. This causes unbounded growth of the `ManagingSchemeIds` list, leading to gas exhaustion and denial of service on critical manager operations including `ResetManager`, `GetManagingSchemeIds`, and subsequent scheme creation attempts.

### Finding Description

The root cause is the lack of authorization validation in the `CreateScheme` function. The manager parameter is accepted without verifying the caller has permission from the specified manager address: [1](#0-0) 

The function unconditionally adds the new scheme ID to the manager's list: [2](#0-1) 

The only validation is a duplicate scheme ID check, which an attacker can bypass by providing unique `Token` values in the input to generate unique scheme IDs: [3](#0-2) 

When `createSchemeInput.Token` is provided, the scheme ID is deterministically generated from that token, allowing unlimited unique schemes. The protobuf definition confirms the `Token` parameter exists for this purpose: [4](#0-3) 

**Execution Path:**
1. Attacker calls `CreateScheme` with `Manager = VictimAddress` and unique `Token` values
2. Each call generates a unique scheme ID via `GenerateSchemeId`
3. Each scheme ID is appended to `State.ManagingSchemeIds[VictimAddress]`
4. No maximum limit exists on list size
5. List grows unbounded until operations fail

### Impact Explanation

**Primary DoS Impact - ResetManager Failure:**
The `ResetManager` function performs O(n) operations on the scheme ID list, reading the entire list, removing one element, and writing it back: [5](#0-4) 

With a list containing millions of entries, the `Remove` operation on the protobuf repeated field requires scanning the entire list and the subsequent state write exceeds gas limits. The victim cannot transfer management of their legitimate schemes.

**Secondary DoS Impact - View Function Failure:**
The `GetManagingSchemeIds` view function returns the entire list: [6](#0-5) 

Large lists exceed response size limits or timeout, preventing the victim from querying their schemes and breaking off-chain systems that depend on this data.

**Tertiary DoS Impact - Scheme Creation Degradation:**
Legitimate scheme creation by the victim becomes expensive due to read-modify-write operations on the inflated list: [2](#0-1) 

**Affected Parties:** Any address can be targeted as a victim. Particularly impactful against:
- System contracts (Treasury, TokenHolder) that manage profit schemes
- DApp developers who rely on profit distribution mechanisms
- Economic actors who need to adjust scheme management

### Likelihood Explanation

**Attacker Capabilities:** Any user can execute this attack with a standard account. No special permissions, stake, or trusted role compromise required.

**Attack Complexity:** Trivial. The attacker simply calls `CreateScheme` in a loop with incrementing `Token` values:
```
for i = 0 to 1000000:
    CreateScheme({Manager: VictimAddress, Token: Hash(i)})
```

**Economic Feasibility:** Attack cost is CreateScheme gas cost multiplied by the number of schemes created. To cause permanent DoS, approximately 10,000-100,000 schemes would suffice (depending on gas limits), making this economically viable for targeted attacks against high-value victims.

**Detection Constraints:** The attack leaves clear on-chain evidence (many schemes with same manager from same attacker), but by the time it's detected, the damage is done. No rate limiting or prevention mechanism exists.

**Probability:** HIGH - The entry point is public, the vulnerability is straightforward to exploit, and there are no technical barriers to execution.

### Recommendation

**Immediate Fix:** Add authorization check in `CreateScheme` to ensure only the manager themselves can create schemes with their address as manager:

```csharp
public override Hash CreateScheme(CreateSchemeInput input)
{
    ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);
    
    var manager = input.Manager ?? Context.Sender;
    
    // NEW: Validate caller authorization
    Assert(manager == Context.Sender, 
        "Only the manager themselves can create schemes with their address as manager.");
    
    // ... rest of existing code
}
```

**Alternative Approach:** If delegated scheme creation is a legitimate use case, implement an explicit authorization mechanism where managers can grant creation permissions to specific addresses via a whitelist.

**Additional Protection:** Implement a maximum limit on schemes per manager address:

```csharp
const int MaxSchemesPerManager = 1000;

var schemeIds = State.ManagingSchemeIds[scheme.Manager];
if (schemeIds != null)
{
    Assert(schemeIds.SchemeIds.Count < MaxSchemesPerManager, 
        "Maximum number of schemes per manager exceeded.");
}
```

**Test Cases:**
1. Verify only sender can be manager when creating schemes
2. Test that specifying a different manager address fails
3. Verify maximum scheme limit is enforced
4. Test ResetManager gas usage remains reasonable with maximum allowed schemes

### Proof of Concept

**Initial State:**
- Victim address: `0xVICTIM`
- Attacker address: `0xATTACKER`
- No existing schemes for victim

**Attack Sequence:**

1. Attacker creates 100,000 schemes with victim as manager:
```csharp
for (int i = 0; i < 100000; i++)
{
    Hash uniqueToken = HashHelper.ComputeFrom(i);
    await AttackerStub.CreateScheme.SendAsync(new CreateSchemeInput
    {
        Manager = VictimAddress,
        Token = uniqueToken
    });
}
```

2. Victim attempts to call `GetManagingSchemeIds`:
```csharp
var result = await VictimStub.GetManagingSchemeIds.CallAsync(
    new GetManagingSchemeIdsInput { Manager = VictimAddress }
);
```
**Expected:** Returns list of 100,000 scheme IDs
**Actual:** Transaction fails due to response size limit or timeout

3. Victim attempts to reset manager on their legitimate scheme:
```csharp
await VictimStub.ResetManager.SendAsync(new ResetManagerInput
{
    SchemeId = legitimateSchemeId,
    NewManager = newManagerAddress
});
```
**Expected:** Manager successfully transferred
**Actual:** Transaction fails with "Insufficient resources" due to gas exhaustion from deserializing, removing from, and re-serializing the 100,000-entry list

**Success Condition:** The attack succeeds when the victim's `ResetManager` call fails with gas exhaustion, permanently preventing the victim from managing their legitimate schemes.

### Notes

The vulnerability is confirmed through code analysis showing no authorization check exists at the manager assignment point. The protobuf definition explicitly includes a `Token` parameter designed to allow unique scheme ID generation, which inadvertently enables this attack vector. System contracts like Treasury use `ResetManager` to transfer scheme control, making this a high-impact vulnerability for protocol-level operations.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L57-57)
```csharp
        var manager = input.Manager ?? Context.Sender;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L733-738)
```csharp
        var oldManagerSchemeIds = State.ManagingSchemeIds[scheme.Manager];
        oldManagerSchemeIds.SchemeIds.Remove(input.SchemeId);
        State.ManagingSchemeIds[scheme.Manager] = oldManagerSchemeIds;
        var newManagerSchemeIds = State.ManagingSchemeIds[input.NewManager] ?? new CreatedSchemeIds();
        newManagerSchemeIds.SchemeIds.Add(input.SchemeId);
        State.ManagingSchemeIds[input.NewManager] = newManagerSchemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** protobuf/profit_contract.proto (L120-133)
```text
message CreateSchemeInput {
    // Period of profit distribution.
    int64 profit_receiving_due_period_count = 1;
    // Whether all the schemes balance will be distributed during distribution each period.
    bool is_release_all_balance_every_time_by_default = 2;
    // Delay distribute period.
    int32 delay_distribute_period_count = 3;
    // The manager of this scheme, the default is the creator.
    aelf.Address manager = 4;
    // Whether you can directly remove the beneficiary.
    bool can_remove_beneficiary_directly = 5;
    // Use to generate scheme id.
    aelf.Hash token = 6;
}
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```
