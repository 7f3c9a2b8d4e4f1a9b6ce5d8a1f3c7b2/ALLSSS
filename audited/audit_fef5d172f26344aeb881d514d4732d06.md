# Audit Report

## Title
LIB Monotonicity Violation via Unvalidated NextRound and TinyBlock Consensus Behaviors

## Summary
The AEDPoS consensus contract applies `LibInformationValidationProvider` only to `UpdateValue` behavior, creating a critical validation gap. The `NextRound` and `TinyBlock` behaviors also modify Last Irreversible Block (LIB) values in consensus state but lack this validation. A malicious miner can exploit this gap to submit consensus data with regressed (lowered) LIB values, violating the fundamental invariant that LIB height must be monotonically increasing and poisoning consensus state across subsequent rounds.

## Finding Description

**Root Cause:** Selective validation application creates an exploitable gap in LIB monotonicity enforcement.

The `LibInformationValidationProvider` validates that LIB values do not regress by checking that `ConfirmedIrreversibleBlockHeight`, `ConfirmedIrreversibleBlockRoundNumber`, and per-miner `ImpliedIrreversibleBlockHeight` should not decrease. [1](#0-0) 

However, this validator is **only** added for `UpdateValue` behavior in the validation service configuration: [2](#0-1) 

**Vulnerability in NextRound Behavior:**

When a miner produces a NextRound block, they provide a `NextRoundInput` that includes `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields: [3](#0-2) 

These fields are included when converting to a `Round` object via the `ToRound()` method: [4](#0-3) 

The legitimate code path copies these values forward from the current round: [5](#0-4) 

However, a malicious miner can modify the `NextRoundInput` to contain **lower** LIB values before submission. The `ProcessNextRound` method converts the input to a Round object and directly stores it to state without LIB validation: [6](#0-5) [7](#0-6) 

The `AddRoundInformation` method directly writes the malicious round to state: [8](#0-7) 

**Vulnerability in TinyBlock Behavior:**

During TinyBlock processing, the `RecoverFromTinyBlock` method applies the provided `ImpliedIrreversibleBlockHeight` to the miner's state: [9](#0-8) 

Without `LibInformationValidationProvider`, a miner can submit a TinyBlock with a **lower** `ImpliedIrreversibleBlockHeight` than previously reported, and this regressed value gets stored: [10](#0-9) 

The `TryToUpdateRoundInformation` method writes the corrupted round back to state: [11](#0-10) 

**Why Existing Protections Fail:**

The validation context properly distinguishes between `BaseRound` (current state) and `ProvidedRound` (miner-submitted data): [12](#0-11) 

The validation service iterates through providers and fails on the first unsuccessful validation: [13](#0-12) 

However, since `LibInformationValidationProvider` is not added to the provider list for NextRound or TinyBlock behaviors, the LIB regression check never executes.

## Impact Explanation

**Consensus Integrity Violation (High):**
- LIB height is a critical consensus invariant that must be monotonically increasing
- Regressing LIB values in consensus state violates this fundamental safety property
- Future rounds inherit the corrupted baseline, as shown by the code that copies LIB values from previous rounds: [14](#0-13) [15](#0-14) 

**State Poisoning with Cascading Effects:**
- Once a malicious round with lowered LIB is stored, subsequent rounds built on it inherit the corrupted baseline
- The `LibInformationValidationProvider` becomes ineffective because it compares against the already-poisoned `baseRound`
- Future `UpdateValue` operations use the corrupted state as their validation baseline

**System Inconsistency:**
- While the system-level LIB (chain's `LastIrreversibleBlockHeight`) is protected by guards in `IrreversibleBlockFoundLogEventProcessor`: [16](#0-15) [17](#0-16) 

- The consensus contract's Round state would contain **inconsistent** LIB values diverging from the chain's actual LIB
- This creates a fundamental discrepancy between the consensus contract's view of finality and the blockchain's actual finality state

## Likelihood Explanation

**High Likelihood - Practical Exploitation:**

**Reachable Entry Point:**
- `NextRound` and `TinyBlock` are public consensus methods callable by authorized miners: [18](#0-17) 

**Feasible Preconditions:**
- Attacker must be in the active miner set (realistic for a compromised validator)
- Authorization check only verifies miner list membership: [19](#0-18) 

**Execution Practicality:**
- Attacker modifies `NextRoundInput.ConfirmedIrreversibleBlockHeight` to a lower value before submission
- Or modifies `ImpliedIrreversibleBlockHeight` in TinyBlock data
- Transaction passes all validations except the missing LIB check
- State gets corrupted immediately upon successful block execution

**Economic Rationality:**
- Attack cost: Standard block production cost (negligible)
- No additional stakes or bonds at risk
- Attack is detectable in logs but not preventable by existing validation

## Recommendation

Add `LibInformationValidationProvider` to the validation provider list for both `NextRound` and `TinyBlock` behaviors in the `ValidateBeforeExecution` method.

**Fixed Code:**
```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // Add LIB validation
        break;
    case AElfConsensusBehaviour.TinyBlock:
        validationProviders.Add(new LibInformationValidationProvider()); // Add LIB validation
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // Add LIB validation for safety
        break;
}
```

This ensures that all consensus behaviors that modify LIB-related values in state are subject to monotonicity validation, preventing regression attacks.

## Proof of Concept

```csharp
// Test case demonstrating LIB regression via NextRound
[Fact]
public async Task NextRound_Can_Regress_LIB_Without_Validation()
{
    // Setup: Initialize consensus with LIB at height 1000
    var initialRound = GenerateRoundWithLIB(1000);
    await InitializeConsensusState(initialRound);
    
    // Malicious miner creates NextRoundInput with LOWERED LIB
    var maliciousNextRoundInput = new NextRoundInput
    {
        RoundNumber = initialRound.RoundNumber + 1,
        RealTimeMinersInformation = { /* valid miner info */ },
        ConfirmedIrreversibleBlockHeight = 500, // REGRESSED from 1000 to 500
        ConfirmedIrreversibleBlockRoundNumber = initialRound.ConfirmedIrreversibleBlockRoundNumber - 1
        // ... other fields
    };
    
    // Execute NextRound with malicious input
    await ConsensusStub.NextRound.SendAsync(maliciousNextRoundInput);
    
    // Verify: LIB has regressed in consensus state
    var newRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // VULNERABILITY: The following assertion passes, showing LIB regression succeeded
    Assert.Equal(500, newRound.ConfirmedIrreversibleBlockHeight); // LIB regressed!
    Assert.True(newRound.ConfirmedIrreversibleBlockHeight < initialRound.ConfirmedIrreversibleBlockHeight);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-30)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L16-17)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L27-28)
```csharp
        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-308)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L126-131)
```csharp
    private bool TryToUpdateRoundInformation(Round round)
    {
        var ri = State.Rounds[round.RoundNumber];
        if (ri == null) return false;
        State.Rounds[round.RoundNumber] = round;
        return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L43-43)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ValidationService.cs (L16-26)
```csharp
    public ValidationResult ValidateInformation(ConsensusValidationContext validationContext)
    {
        foreach (var headerInformationValidationProvider in _headerInformationValidationProviders)
        {
            var result =
                headerInformationValidationProvider.ValidateHeaderInformation(validationContext);
            if (!result.Success) return result;
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L244-245)
```csharp
        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L292-293)
```csharp
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockFoundLogEventProcessor.cs (L60-61)
```csharp
            if (chain.LastIrreversibleBlockHeight > irreversibleBlockFound.IrreversibleBlockHeight)
                return;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockFoundLogEventProcessor.cs (L77-79)
```csharp
                    if (currentChain.LastIrreversibleBlockHeight < blockIndex.BlockHeight)
                        await _blockchainService.SetIrreversibleBlockAsync(currentChain, blockIndex.BlockHeight,
                            blockIndex.BlockHash);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```
