### Title
Missing Validation of Mining Order Manipulation via TuneOrderInformation in UpdateValue

### Summary
The `UpdateValue` consensus behavior lacks validation for `TuneOrderInformation` entries, allowing a malicious miner to manipulate `FinalOrderOfNextRound` values for any miner in the network. This enables mining order manipulation, unfair advantages, and potential consensus disruption through invalid order assignments.

### Finding Description

The consensus system uses two order fields per miner: [1](#0-0) 

In `ApplyNormalConsensusData`, both fields are initially set to the same calculated value, with conflict resolution logic modifying other miners' `FinalOrderOfNextRound`: [2](#0-1) 

The conflict resolution modifies other miners' orders: [3](#0-2) 

These discrepancies are communicated via `TuneOrderInformation`: [4](#0-3) 

During `ProcessUpdateValue`, this tuning information is applied without validation: [5](#0-4) 

**Root Cause:** The `UpdateValueValidationProvider` performs NO validation of `TuneOrderInformation`: [6](#0-5) 

The `NextRoundMiningOrderValidationProvider` which validates order values is only applied to `NextRound` behavior, not `UpdateValue`: [7](#0-6) 

### Impact Explanation

A malicious miner can modify their local `ApplyNormalConsensusData` logic to set arbitrary `FinalOrderOfNextRound` values for any miner, bypassing legitimate conflict resolution. This enables:

1. **Mining Order Manipulation**: Set own order to 1 to always mine first in the next round, gaining timing advantages and potential MEV opportunities
2. **Invalid Order Values**: Assign orders of 0, negative, or > `minersCount`, disrupting the round generation logic: [8](#0-7) 

3. **Duplicate Orders**: Create multiple miners with identical `FinalOrderOfNextRound`, causing non-deterministic mining time assignment
4. **Competitor Disruption**: Assign high/invalid orders to competing miners, delaying their mining slots

The impact affects consensus integrity by allowing unfair manipulation of the miner schedule for the subsequent round, violating the deterministic order calculation based on signatures.

### Likelihood Explanation

**Attacker Capabilities:** Any active miner in the consensus rotation can perform this attack by modifying their local node's consensus logic in `ApplyNormalConsensusData`.

**Attack Complexity:** Medium
- Requires local node code modification
- No special privileges beyond being an active miner
- Single transaction (UpdateValue) execution
- No dependency on external conditions

**Feasibility:** The attack is practical because:
1. Entry point is the standard `UpdateValue` method called during normal block production
2. No validation exists to detect malicious `TuneOrderInformation`
3. The consensus header hash validation includes order values, but both header and execution result contain the same malicious values, so hashes match: [9](#0-8) 

**Detection:** Difficult to detect in real-time as the malicious orders appear in both the consensus header and execution result, passing hash validation: [10](#0-9) 

### Recommendation

1. **Add Order Validation for UpdateValue**: Extend validation provider chain to include order checks for `UpdateValue` behavior:

```csharp
case AElfConsensusBehaviour.UpdateValue:
    validationProviders.Add(new UpdateValueValidationProvider());
    validationProviders.Add(new UpdateValueOrderValidationProvider()); // NEW
    validationProviders.Add(new LibInformationValidationProvider());
    break;
```

2. **Implement UpdateValueOrderValidationProvider**: Create validator that checks:
   - All `FinalOrderOfNextRound` values are in range [1, minersCount]
   - No duplicate `FinalOrderOfNextRound` values among miners who mined
   - `TuneOrderInformation` only contains miners whose supposed order legitimately conflicts
   - Tuned orders follow valid conflict resolution pattern (sequential search from conflict point)

3. **Add Bounds Checks in ProcessUpdateValue**:
```csharp
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount, 
        "Invalid tuned order value");
    Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key),
        "Cannot tune order for non-existent miner");
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

4. **Test Coverage**: Add test cases verifying rejection of:
   - Order values outside [1, minersCount]
   - Duplicate final orders
   - Malicious tuning of unrelated miners

### Proof of Concept

**Initial State:**
- 5 miners: A, B, C, D, E in consensus rotation
- Current round: Miner B's turn to produce block
- Legitimate orders for next round: A=3, C=5, D=2, E=4

**Attack Sequence:**

1. Malicious Miner B modifies local `ApplyNormalConsensusData`:
   - Sets own `SupposedOrderOfNextRound` = 5 (from signature calculation)
   - Sets own `FinalOrderOfNextRound` = 1 (MALICIOUS)
   - Sets Miner A's `FinalOrderOfNextRound` = 999 (MALICIOUS - invalid value)
   - Sets Miner C's `FinalOrderOfNextRound` = 1 (MALICIOUS - duplicate)

2. B generates block with `UpdateValue` transaction containing:
   - `SupposedOrderOfNextRound` = 5 for self
   - `TuneOrderInformation` = {"B": 1, "A": 999, "C": 1}

3. Other nodes validate block:
   - `ValidateConsensusBeforeExecution`: Passes (no order validation)
   - `ProcessUpdateValue`: Applies malicious `TuneOrderInformation`
   - `ValidateConsensusAfterExecution`: Passes (hash includes malicious orders in both header and state)

4. Next round generation uses malicious `FinalOrderOfNextRound` values:
   - Miner B mines first (order 1) instead of legitimate position
   - Miner C also has order 1 (conflict, non-deterministic sorting)
   - Miner A has order 999 (invalid, disrupts order calculation)

**Expected Result:** Validation should reject the block with error "Invalid FinalOrderOfNextRound values in TuneOrderInformation"

**Actual Result:** Block accepted, next round uses malicious mining order, granting unfair advantage to Miner B

### Citations

**File:** protobuf/aedpos_contract.proto (L287-290)
```text
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-40)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```
