# Audit Report

## Title
NextTerm Validation Bypass Allows Outdated Miner Keys After Replacement

## Summary
The `ValidateConsensusAfterExecution` method contains a circular validation logic for NextTerm blocks. The state round is updated directly from the header input during execution, causing the post-execution validation to always succeed without verifying miner replacements. This allows a new term to begin with outdated or compromised miner public keys even after `ReplaceCandidatePubkey` has been executed.

## Finding Description

The vulnerability exists in the consensus validation flow for NextTerm blocks, which transitions the blockchain to a new term with a new miner set.

**The Core Issue:**

The `ValidateConsensusAfterExecution` method validates that consensus state was updated correctly after block execution. [1](#0-0) 

The validation compares the header round hash against the current state round hash. If they differ, it performs miner replacement validation by calling `GetNewestPubkey` from the Election contract. However, for NextTerm blocks, this check is fundamentally broken.

During execution, `ProcessNextTerm` directly sets the consensus state from the NextTerm input without validation. [2](#0-1) 

The critical line is where `AddRoundInformation(nextRound)` writes the input round directly to state. [3](#0-2) 

This creates a circular validation: the post-execution validation retrieves the round that was just written from the header, compares it with itself, finds they match, and skips the replacement check entirely.

**Why Existing Protections Fail:**

1. `ValidateBeforeExecution` for NextTerm only validates round number increments via `RoundTerminateValidationProvider`, not miner list correctness. [4](#0-3) 

2. The `RoundTerminateValidationProvider` only checks that round and term numbers increment properly, not that the miner list matches current election results. [5](#0-4) 

3. `RecordCandidateReplacement` only updates the current round if the old pubkey is present in it, but does not affect already-generated NextTerm blocks waiting in the block pool. [6](#0-5) 

4. The NextTerm round is generated by calling `GetVictories` from the Election contract at block generation time, creating a snapshot of the miner list that becomes stale if replacements occur afterward. [7](#0-6) 

## Impact Explanation

**Consensus Security Violation:** This vulnerability directly compromises consensus integrity, which is the foundation of blockchain security.

If a miner's key is replaced (typically due to key compromise or security concerns), the protocol guarantees that the old key should be immediately excluded from block production. This vulnerability breaks that guarantee for NextTerm transitions.

**Concrete Impact:**
- **Compromised Key Participation**: If miner A's key was replaced with A' due to compromise, the old compromised key A can still produce blocks for an entire term
- **Legitimate Miner DoS**: The legitimate new key holder A' cannot produce blocks, losing rewards and reducing network decentralization
- **Trust Model Violation**: Breaks the fundamental assumption that key replacement immediately revokes mining permissions

**Severity Justification:** This is a **High** severity issue because:
1. It affects consensus security directly
2. Allows potentially compromised validators to continue participating
3. Violates a critical protocol security invariant
4. Can persist for an entire term duration (not just a single block)

## Likelihood Explanation

**Realistic Trigger Scenarios:**

1. **Chain Reorganizations**: During a chain reorg, blocks are revalidated in a different chain context. A NextTerm block generated before a replacement can be validated after the replacement has been finalized in the reorganized chain.

2. **Network Propagation Delays**: In a distributed network, a NextTerm block may be generated by one node while another node executes `ReplaceCandidatePubkey`. Due to network delays, the NextTerm block arrives for validation after the replacement is already in the node's state.

3. **Race Condition**: Normal timing overlap where NextTerm block generation and candidate replacement transaction execution occur in close temporal proximity on different parts of the network.

**Feasibility Assessment:**
- **No Special Privileges Required**: The attacker only needs timing coordination; `ReplaceCandidatePubkey` is a legitimate operation called by candidate admins. [8](#0-7) 
- **Protocol-Native Operations**: Uses only legitimate protocol mechanisms
- **Medium Complexity**: Requires timing coordination but exploits inherent protocol race conditions

## Recommendation

Add explicit miner list validation in `ProcessNextTerm` to verify that the miners in the NextTerm input match the current `GetVictories` results after applying `GetNewestPubkey` mapping.

**Recommended Fix:**

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // NEW: Validate that miner list matches current election results
    if (State.IsMainChain.Value && TryToGetVictories(out var currentVictories))
    {
        var inputMiners = nextRound.RealTimeMinersInformation.Keys.ToList();
        var expectedMiners = currentVictories.Pubkeys.Select(p => p.ToHex()).ToList();
        
        // Apply GetNewestPubkey mapping to both lists
        var mappedInputMiners = inputMiners
            .Select(m => State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = m }).Value)
            .OrderBy(m => m).ToList();
        var mappedExpectedMiners = expectedMiners
            .Select(m => State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = m }).Value)
            .OrderBy(m => m).ToList();
            
        Assert(
            mappedInputMiners.Count == mappedExpectedMiners.Count &&
            mappedInputMiners.SequenceEqual(mappedExpectedMiners),
            "NextTerm miner list does not match current election results after applying replacements.");
    }
    
    // ... rest of existing ProcessNextTerm logic
}
```

Alternatively, add validation in `ValidateBeforeExecution` specifically for NextTerm to check miner list validity before execution occurs.

## Proof of Concept

```csharp
[Fact]
public async Task NextTerm_WithReplacedCandidate_ShouldRejectOutdatedMinerList()
{
    // Setup: Initialize blockchain with miners [A, B, C]
    var minerA = SampleAccount.Accounts[0].KeyPair;
    var minerB = SampleAccount.Accounts[1].KeyPair;
    var minerC = SampleAccount.Accounts[2].KeyPair;
    var minerAPrime = SampleAccount.Accounts[3].KeyPair; // New key for A
    
    await InitializeChainWithMiners(new[] { minerA, minerB, minerC });
    
    // Step 1: Generate NextTerm block at time T1
    // This calls GetVictories() which returns [A, B, C]
    var nextTermBlock = await GenerateNextTermBlock(minerA);
    var nextTermInput = GetNextTermInputFromBlock(nextTermBlock);
    
    // Verify the block contains miner A (old key)
    var minersInBlock = nextTermInput.RealTimeMinersInformation.Keys;
    Assert.Contains(minerA.PublicKey.ToHex(), minersInBlock);
    
    // Step 2: Execute ReplaceCandidatePubkey(A → A')
    await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(
        new ReplaceCandidatePubkeyInput
        {
            OldPubkey = minerA.PublicKey.ToHex(),
            NewPubkey = minerAPrime.PublicKey.ToHex()
        });
    
    // Verify replacement was recorded
    var newestPubkey = await ElectionContractStub.GetNewestPubkey.CallAsync(
        new StringValue { Value = minerA.PublicKey.ToHex() });
    Assert.Equal(minerAPrime.PublicKey.ToHex(), newestPubkey.Value);
    
    // Step 3: Validate and execute the NextTerm block generated earlier
    // This should FAIL but currently SUCCEEDS due to the vulnerability
    var validationResult = await AEDPoSContractStub.ValidateConsensusBeforeExecution.CallAsync(
        nextTermBlock.Header.ConsensusExtraData);
    Assert.True(validationResult.Success); // Pre-execution validation passes
    
    // Execute the block
    await AEDPoSContractStub.NextTerm.SendAsync(nextTermInput);
    
    // Post-execution validation
    var afterValidationResult = await AEDPoSContractStub.ValidateConsensusAfterExecution.CallAsync(
        nextTermBlock.Header.ConsensusExtraData);
    
    // BUG: This validation SHOULD fail but currently succeeds
    Assert.True(afterValidationResult.Success); // ❌ Vulnerability: validation passes
    
    // Verify the current miner list contains OLD key A instead of A'
    var currentMiners = await AEDPoSContractStub.GetCurrentMinerList.CallAsync(new Empty());
    Assert.Contains(currentMiners.Pubkeys, p => p.ToHex() == minerA.PublicKey.ToHex()); // ❌ Old key still active
    Assert.DoesNotContain(currentMiners.Pubkeys, p => p.ToHex() == minerAPrime.PublicKey.ToHex()); // ❌ New key not active
    
    // EXPECTED: Validation should fail and reject the outdated NextTerm block
    // ACTUAL: Block is accepted and term starts with compromised key A
}
```

This test demonstrates that a NextTerm block containing an outdated miner key passes all validations even after `ReplaceCandidatePubkey` has been executed, allowing the compromised key to continue participating in consensus for the new term.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-257)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }

        var rankingList = State.DataCentersRankingList.Value;
        //the profit receiver is not exist but candidate in the data center ranking list
        if (rankingList.DataCenters.ContainsKey(input.OldPubkey))
        {
            rankingList.DataCenters.Add(input.NewPubkey, rankingList.DataCenters[input.OldPubkey]);
            rankingList.DataCenters.Remove(input.OldPubkey);
            State.DataCentersRankingList.Value = rankingList;

            // Notify Profit Contract to update backup subsidy profiting item.
            if (State.ProfitContract.Value == null)
                State.ProfitContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            
            var oldProfitReceiver = GetProfitsReceiverOrDefault(input.OldPubkey);
            var profitReceiver = oldProfitReceiver.Value.Any()
                ? oldProfitReceiver
                : null;
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
        }

        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }

        //     For CandidateVotes and CandidateInformation, just replace value of origin pubkey.
        var candidateVotes = State.CandidateVotes[input.OldPubkey];
        if (candidateVotes != null)
        {
            candidateVotes.Pubkey = newPubkeyBytes;
            State.CandidateVotes[input.NewPubkey] = candidateVotes;
            State.CandidateVotes.Remove(input.OldPubkey);
        }

        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }

        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;

        ReplaceCandidateProfitsReceiver(input.OldPubkey, input.NewPubkey);
        
        Context.Fire(new CandidatePubkeyReplaced
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey
        });

        return new Empty();
    }
```
