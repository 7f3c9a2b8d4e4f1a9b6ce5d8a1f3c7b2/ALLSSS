### Title
Inconsistent Vote Counting Allows Governance Threshold Bypass Through Member Removal

### Summary
The Association contract contains an inconsistency in how votes are counted for threshold checks. While `IsProposalAbstained()` correctly filters abstentions by current membership, the `CheckEnoughVoteAndApprovals()` function counts total votes without filtering by current membership. This allows attackers to bypass `MaximalAbstentionThreshold` and `MaximalRejectionThreshold` by removing members after they vote, while their votes still count towards `MinimalVoteThreshold`.

### Finding Description

The vulnerability exists in the vote threshold checking logic in `Association_Helper.cs`. [1](#0-0) 

The `IsProposalAbstained()` function correctly filters abstentions to only count votes from current organization members using the `Contains()` check. Similarly: [2](#0-1) 

The `IsProposalRejected()` function also filters by current membership. [3](#0-2) 

However, in `CheckEnoughVoteAndApprovals()`, while line 49 correctly filters approvals by current membership, lines 55-57 count ALL votes (approvals + rejections + abstentions) without filtering by current membership. This inconsistency allows votes from removed members to count towards `MinimalVoteThreshold` but not towards `MaximalAbstentionThreshold` or `MaximalRejectionThreshold`.

The attack is feasible because: [4](#0-3) 

The `RemoveMember()` function can be called (by the organization through a proposal) to remove members who have already voted, without any check for active proposals or vote invalidation. [5](#0-4) [6](#0-5) 

While voting methods correctly enforce that only current members can vote at the time of voting, once votes are cast, they remain in the proposal's vote lists even after member removal.

### Impact Explanation

**Governance Impact**: This vulnerability allows attackers to bypass critical governance safeguards (`MaximalAbstentionThreshold` and `MaximalRejectionThreshold`) designed to block proposals with insufficient support or too much opposition.

**Concrete Attack Scenario**: 
- Organization with 15 members has thresholds: `MinimalVoteThreshold=10`, `MinimalApprovalThreshold=6`, `MaximalAbstentionThreshold=3`
- Malicious proposal created requiring 6 approvals
- 6 colluding members approve, 7 honest members abstain
- Proposal blocked because 7 abstentions > 3 `MaximalAbstentionThreshold`
- Attackers pass a second proposal to remove the 7 abstaining members
- First proposal now evaluates as: Total votes=13 (includes removed members) ≥ 10, Approvals from current=6 ≥ 6, Abstentions from current=0 ≤ 3
- Proposal can now be released despite originally having majority abstention

**Who is Affected**: Any Association organization where attackers control enough members to pass a `RemoveMember` proposal (typically requiring majority approval threshold). This compromises the integrity of the governance system.

**Severity**: Medium - requires attacker to already have significant influence (ability to pass proposals), but allows complete bypass of rejection/abstention safeguards.

### Likelihood Explanation

**Reachable Entry Points**: All entry points are standard public methods:
1. Members vote via `Approve()`, `Reject()`, `Abstain()`
2. Organization removes members via `RemoveMember()` (through proposal execution)
3. Proposer releases via `Release()`

**Feasible Preconditions**: Attackers need:
- Sufficient members in the organization to meet `MinimalApprovalThreshold` for both proposals
- Access to proposer whitelist for creating proposals
- This is realistic for organizations where attackers have significant but not complete control

**Execution Practicality**: The attack sequence is straightforward:
1. Create target proposal
2. Gather enough approvals from colluding members
3. Wait for honest members to reject/abstain (blocking the proposal)
4. Create and pass a `RemoveMember` proposal for those who voted against
5. Release original proposal (now passes all thresholds)

**Detection**: The attack leaves clear on-chain evidence (member removal followed by proposal release), but by the time it's detected, the malicious proposal has already executed.

**Economic Rationality**: If the malicious proposal yields sufficient value (e.g., transferring organization funds, changing critical parameters), the cost of executing two proposals is negligible.

### Recommendation

**Code-Level Mitigation**: Modify `CheckEnoughVoteAndApprovals()` to filter total votes by current membership:

```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
    proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
    proposal.Rejections.Count(organization.OrganizationMemberList.Contains) >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

This ensures all threshold checks consistently use current membership, preventing removed members' votes from being counted.

**Alternative Fix**: Clear all votes from a member when they are removed:

```csharp
// In RemoveMember(), add:
// Remove this member's votes from all active proposals
foreach (var proposalId in GetActiveProposalIds(Context.Sender))
{
    var proposal = State.Proposals[proposalId];
    proposal.Approvals.Remove(input);
    proposal.Rejections.Remove(input);
    proposal.Abstentions.Remove(input);
    State.Proposals[proposalId] = proposal;
}
```

**Test Cases**: Add tests verifying:
1. Member removal invalidates their existing votes
2. Total vote count only includes current members
3. Proposals blocked by abstention/rejection thresholds cannot pass after removing opposing voters

### Proof of Concept

**Initial State**:
- Organization address: `org_addr`
- Members: M1-M6 (attackers), M7-M13 (honest), total 13 members
- Thresholds: `MinimalVoteThreshold=10`, `MinimalApprovalThreshold=6`, `MaximalAbstentionThreshold=3`

**Transaction Sequence**:
1. M1 creates malicious proposal P1 (e.g., transferring organization funds)
2. M1-M6 call `Approve(P1)` - 6 approvals
3. M7-M13 call `Abstain(P1)` - 7 abstentions
4. M1 attempts `Release(P1)` - **FAILS** because abstentions from current members (7) > MaximalAbstentionThreshold (3)
5. M1 creates proposal P2 to remove M7-M13 via `RemoveMember()`
6. M1-M6 call `Approve(P2)` - 6 approvals, meets threshold
7. M1 calls `Release(P2)` - **SUCCEEDS**, M7-M13 removed from organization
8. M1 calls `Release(P1)` - **SUCCEEDS** because:
   - Total votes: 13 (still counts removed members) ≥ 10 ✓
   - Approvals from current: 6 ≥ 6 ✓  
   - Abstentions from current: 0 ≤ 3 ✓

**Expected Result**: P1 should remain blocked after member removal because only 6 current members participated

**Actual Result**: P1 can be released, bypassing the abstention threshold safeguard

**Success Condition**: Transaction 8 succeeds when it should fail, demonstrating the threshold bypass vulnerability

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L163-181)
```csharp
    public override Empty Abstain(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Abstentions.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Abstain),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
