# Audit Report

## Title
Unvalidated MinersPreviousInValues Allows Consensus State Manipulation

## Summary
The AEDPoS consensus contract allows any miner to inject arbitrary `PreviousInValue` data for other miners through the `UpdateValue` transaction's `MinersPreviousInValues` field. These values are applied to the round state without validation, enabling manipulation of the consensus randomness chain and miner ordering for subsequent rounds.

## Finding Description

The vulnerability exists in the secret sharing mechanism of the consensus update flow when `IsSecretSharingEnabled()` returns true.

**Collection Phase**: The `ExtractInformationToUpdateConsensus()` method collects all miners' `PreviousInValues` from the current round state and packages them into `UpdateValueInput.MinersPreviousInValues`. [1](#0-0) 

**Application Phase**: When the `UpdateValue` transaction executes, `PerformSecretSharing()` unconditionally applies all values from `MinersPreviousInValues` to the round state, directly overwriting each miner's `PreviousInValue` field. [2](#0-1) 

**Validation Gap**: The `UpdateValueValidationProvider` only validates the sender's own `PreviousInValue` by checking it against their previous round's `OutValue`. It retrieves the sender's public key and validates only that specific entry, never iterating through or validating the `MinersPreviousInValues` map containing other miners' values. [3](#0-2) 

**Critical Difference**: Unlike `UpdateLatestSecretPieces()` which only sets `PreviousInValue` when it's currently empty or null, `PerformSecretSharing()` unconditionally overwrites existing values regardless of their state. [4](#0-3) 

**Attack Vector**: A malicious miner can modify their `UpdateValueInput` transaction parameter before signing to inject arbitrary `PreviousInValues` for other miners. Since miners control their own consensus nodes, they can intercept the transaction generation flow and manipulate the `MinersPreviousInValues` map before submitting their block.

## Impact Explanation

**Consensus Randomness Manipulation**: The `PreviousInValue` directly affects consensus ordering through the signature calculation mechanism. The `ApplyNormalConsensusData()` method uses the signature to calculate `SupposedOrderOfNextRound` via modulo arithmetic, which determines mining order for the next round. [5](#0-4) 

**State Overwrite Attack**: When `SupplyCurrentRoundInformation()` fills data for miners who didn't produce blocks, it uses the stored `PreviousInValue` from the current round state to calculate their signature. If this value has been maliciously overwritten, it corrupts the signature calculation for absent miners. [6](#0-5) 

**Secret Sharing Bypass**: The legitimate secret sharing mechanism in `RevealSharedInValues()` uses Shamir Secret Sharing to cryptographically reveal previous InValues through threshold-based decryption. This vulnerability allows attackers to bypass this cryptographic guarantee by directly injecting fake values. [7](#0-6) 

**Severity**: Medium-High. While this doesn't directly steal funds, it corrupts critical consensus invariants including randomness integrity, miner ordering fairness, and the cryptographic guarantees of the secret sharing mechanism. This can lead to consensus manipulation and unfair miner advantages.

## Likelihood Explanation

**Highly Exploitable**:
- **Entry Point**: Any active miner can trigger this through the public `UpdateValue` method during their normal block production. [8](#0-7) 
- **Attack Complexity**: Low. The attacker simply needs to modify the `UpdateValueInput.MinersPreviousInValues` map in their consensus transaction before signing it.
- **No Special Privileges**: Any miner in the current round can execute this attack. The `ProcessConsensusInformation` method only checks that the sender is in the miner list via `PreCheck()`, which any active miner satisfies. [9](#0-8) 
- **Precondition**: Only requires secret sharing to be enabled, which is a standard configuration for production networks.

## Recommendation

Add validation in `PerformSecretSharing()` or in a dedicated validation provider to ensure that:

1. **Validate Source**: Only allow `PreviousInValues` for miners whose DecryptedPieces have reached the minimum threshold for secret reconstruction
2. **Cryptographic Verification**: Verify that each revealed `PreviousInValue` in `MinersPreviousInValues` is cryptographically valid by checking it matches the expected reconstruction from DecryptedPieces
3. **Prevent Overwriting**: Add a check similar to `UpdateLatestSecretPieces()` to only set `PreviousInValue` if it's currently empty or null
4. **Sender Restriction**: Only allow the sender to update their own `PreviousInValue`, not other miners'

Example fix for `PerformSecretSharing()`:
```csharp
private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
    string publicKey)
{
    minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
    foreach (var decryptedPreviousInValue in input.DecryptedPieces)
        round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
            .Add(publicKey, decryptedPreviousInValue.Value);

    // FIXED: Only allow sender to update their own PreviousInValue
    // Other miners' values should only be set through legitimate RevealSharedInValues
    foreach (var previousInValue in input.MinersPreviousInValues)
    {
        // Only allow updating sender's own PreviousInValue
        if (previousInValue.Key == publicKey &&
            (round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue == Hash.Empty ||
             round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue == null))
        {
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
        }
    }
}
```

## Proof of Concept

A malicious miner can execute this attack by:

1. Running their consensus node normally until it's their turn to produce a block
2. Intercepting the `UpdateValue` transaction generation
3. Modifying the `UpdateValueInput.MinersPreviousInValues` to inject fake values for other miners
4. Signing and submitting the modified transaction in their block

The injected values will be applied unconditionally by `PerformSecretSharing()` without any validation, corrupting the consensus state for all affected miners. This can be repeated in every block the attacker produces, allowing sustained manipulation of the consensus randomness chain.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-47)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);

        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-47)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L171-220)
```csharp
    private void SupplyCurrentRoundInformation()
    {
        var currentRound = GetCurrentRoundInformation(new Empty());
        Context.LogDebug(() => $"Before supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
        TryToGetPreviousRoundInformation(out var previousRound);
        foreach (var miner in notMinedMiners)
        {
            Context.LogDebug(() => $"Miner pubkey {miner.Pubkey}");

            Hash previousInValue = null;
            Hash signature = null;

            // Normal situation: previous round information exists and contains this miner.
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }

            // Fill this two fields at last.
            miner.InValue = previousInValue;
            miner.Signature = signature;

            currentRound.RealTimeMinersInformation[miner.Pubkey] = miner;
        }

        TryToUpdateRoundInformation(currentRound);
        Context.LogDebug(() => $"After supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```
