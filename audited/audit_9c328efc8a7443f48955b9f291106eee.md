# Audit Report

## Title
Evil Miners Continue Block Production After Being Banned Until Next Round Transition

## Summary
When a miner is marked as evil through `UpdateCandidateInformation(IsEvilNode=true)`, the Election contract updates its `BannedPubkeyMap` but the Consensus contract does not immediately remove the miner from the current round's active miner list. The evil miner can continue producing blocks until the next round transition, creating a vulnerability window where consensus integrity is compromised.

## Finding Description

When an evil node is detected (either through automatic detection when missed time slots exceed the threshold, or through governance action via `RemoveEvilNode`), the `UpdateCandidateInformation()` method in the Election contract is called with `IsEvilNode=true`. This sets `State.BannedPubkeyMap[input.Pubkey] = true` and removes the candidate from the Election contract's state. [1](#0-0) 

However, this update to the Election contract does NOT immediately affect the Consensus contract's current round state. The banned miner remains in the current round's `RealTimeMinersInformation` map, which is the authoritative list used for block production validation.

The Consensus contract's `PreCheck()` method only verifies that a miner exists in the current or previous round's miner list, without checking the banned status: [2](#0-1) 

The `IsInMinerList()` method simply checks membership in `RealTimeMinersInformation`: [3](#0-2) 

Similarly, the `MiningPermissionValidationProvider` used during block header validation only checks the `RealTimeMinersInformation` keys: [4](#0-3) 

The `BannedPubkeyMap` is ONLY checked during round transitions when `GenerateNextRoundInformation()` calls `GetMinerReplacementInformation()`: [5](#0-4) 

The Election contract's `GetEvilMinersPubkeys()` filters miners by checking the `BannedPubkeyMap`: [6](#0-5) 

This check only happens during next round generation when `GetConsensusExtraDataForNextRound()` is called: [7](#0-6) 

## Impact Explanation

**Consensus Integrity Violation**: The core security guarantee of AEDPoS consensus is that only authorized, non-malicious miners can produce blocks. This vulnerability breaks that invariant by allowing banned miners to continue participating after being officially marked as evil.

**Time Window**: The vulnerability window extends from the moment `UpdateCandidateInformation(IsEvilNode=true)` is called until the next round transition occurs. Since AElf rounds contain one time slot per active miner and rounds can span significant time periods, this window can encompass multiple blocks.

**Reward Misallocation**: The evil miner continues earning block production rewards during this window. The `DonateMiningReward()` method calculates rewards based on total blocks produced in the round, which includes blocks produced by the evil miner after being banned: [8](#0-7) 

**Attack Opportunities**: During the vulnerability window, the evil miner can:
- Continue producing blocks with full consensus authority
- Include or exclude specific transactions (censorship)
- Potentially coordinate with other compromised nodes
- Undermine network security while officially banned

**Affected Parties**: All network participants are affected as the consensus mechanism's security guarantees are compromised.

## Likelihood Explanation

**Reachable Entry Points**: The vulnerability can be triggered through two realistic paths:

1. Automatic detection when `ProcessNextRound()` detects miners exceeding the missed time slot threshold: [9](#0-8) 

2. Governance action via `RemoveEvilNode()` by the emergency response organization: [10](#0-9) 

**Feasible Preconditions**: 
- A node is currently an active miner in the current round's miner list
- The node is detected as evil or reported through governance
- Standard protocol operation

**Execution Practicality**: The vulnerability occurs automatically once the conditions are met. No special attacker capabilities are required beyond being a current miner who gets detected as evil. The evil miner simply continues their normal block production until the round naturally ends.

**Attack Complexity**: Low - this is an inherent design issue in the separation between the Election and Consensus contracts. Once a miner is marked as evil, they automatically continue producing blocks without any additional action.

**Detection**: The evil behavior that triggered the banning may be detected, but the continued block production during the vulnerability window appears legitimate from a consensus validation perspective since the miner remains in `RealTimeMinersInformation`.

## Recommendation

Implement immediate synchronization between the Election and Consensus contracts when a miner is banned. Two possible approaches:

**Option 1: Immediate Round Update**
When `UpdateCandidateInformation(IsEvilNode=true)` is called, have the Consensus contract immediately update the current round state to remove the evil miner from `RealTimeMinersInformation`. This requires adding a callback from the Election contract to the Consensus contract.

**Option 2: Additional Validation Check**
Add a validation check in `PreCheck()` and `MiningPermissionValidationProvider` to verify that the miner is not in the `BannedPubkeyMap` by calling the Election contract. This adds a cross-contract call overhead but provides immediate protection.

Example for Option 2:
```csharp
// In PreCheck() method
if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
    !previousRound.IsInMinerList(_processingBlockMinerPubkey))
    return false;

// Add this check:
if (State.ElectionContract.Value != null)
{
    var isBanned = State.ElectionContract.IsPubkeyBanned.Call(
        new StringValue { Value = _processingBlockMinerPubkey });
    if (isBanned.Value)
        return false;
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Starting with an active miner in the current round
2. Calling `RemoveEvilNode()` or triggering automatic detection via `ProcessNextRound()`
3. Verifying that `BannedPubkeyMap` is set to true in the Election contract
4. Observing that the evil miner can still successfully call consensus methods (NextRound, UpdateValue, etc.) because `PreCheck()` returns true
5. Confirming that the evil miner is only removed when `GenerateNextRoundInformation()` is called during the next round transition
6. During the window, the evil miner's `ProducedBlocks` counter continues incrementing and they receive mining rewards

The test would verify that between steps 3 and 5, the banned miner can continue producing blocks despite being marked as evil in the Election contract.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-351)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-319)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L118-121)
```csharp
        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });
```
