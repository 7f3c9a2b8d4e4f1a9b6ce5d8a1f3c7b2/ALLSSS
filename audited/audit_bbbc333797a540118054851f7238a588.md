# Audit Report

## Title
Insufficient Contract Type Validation in CheckOrganizationExist Allows Permanent Method Fee Controller Takeover

## Summary

The Genesis contract's `ChangeMethodFeeController` method accepts arbitrary contract addresses without validating they are legitimate organization contracts (Parliament/Association/Referendum). An attacker can deploy a malicious contract that always returns `true` for `ValidateOrganizationExist`, then pass a single Parliament proposal to install it as the method fee controller, gaining permanent unilateral control over Genesis contract method fees without further governance oversight.

## Finding Description

The vulnerability exists in the interaction between `ChangeMethodFeeController` [1](#0-0)  and `CheckOrganizationExist` [2](#0-1) .

**Root Cause:**

The `CheckOrganizationExist` helper performs a cross-contract call to `ValidateOrganizationExist` on whatever contract address is provided in `AuthorityInfo.ContractAddress`, without any validation that this contract is a legitimate organization contract. There is no check that the provided address is Parliament [3](#0-2) , Association [4](#0-3) , or Referendum [5](#0-4)  contracts.

**Exploitation Path:**

1. **Deploy Malicious Contract:** On main/public chains, user contract deployment is permissionless [6](#0-5) . An attacker deploys a contract with a `ValidateOrganizationExist` method that always returns `true`.

2. **Create Parliament Proposal:** Attacker creates a proposal to call `ChangeMethodFeeController` with `AuthorityInfo` containing:
   - `OwnerAddress` = attacker's controlled address
   - `ContractAddress` = malicious contract address

3. **Proposal Execution:** When approved and released by Parliament, the sender is the Parliament organization address, passing the authorization check. The malicious contract's `ValidateOrganizationExist` returns `true`, and the controller is updated to the attacker's setup.

4. **Post-Exploit:** The attacker can directly call `SetMethodFee` [7](#0-6) , which only verifies that `Context.Sender == State.MethodFeeController.Value.OwnerAddress`.

**Why Existing Protections Fail:**

The test suite validates organization existence but never validates contract address legitimacy [8](#0-7) . All tests use legitimate system contract addresses, missing this attack vector entirely.

## Impact Explanation

**Governance Impact:**
The attacker achieves permanent privilege escalation from "must pass Parliament proposals for each fee change" to "can change fees unilaterally at will." This completely bypasses the intended governance oversight mechanism.

**Denial of Service:**
The attacker can set prohibitively high fees for critical Genesis contract methods:
- `DeploySmartContract` / `UpdateSmartContract` - blocks all contract deployment/updates
- `ProposeNewContract` / `ProposeUpdateContract` - prevents proposing new contracts  
- `ReleaseApprovedContract` / `ReleaseCodeCheckedContract` - prevents releasing approved contracts

This effectively halts the entire smart contract deployment and upgrade system for the chain, constituting a chain-level DoS attack.

**Economic Manipulation:**
- Setting zero fees bypasses intended economic controls
- Discriminatory fee structures can favor/harm specific users
- Fee extraction through manipulated pricing

**Severity Justification:**
HIGH severity due to: (1) Permanent governance bypass violating critical security invariants, (2) Chain-level DoS capability affecting all participants, (3) Economic manipulation potential, (4) Requires only ONE successful proposal for lasting damage.

## Likelihood Explanation

**Attacker Requirements:**
- Deploy a user contract (permissionless on main/public side chains per code)
- Pass ONE Parliament proposal (requires 2/3 miner approval)

**Attack Complexity:**
LOW - The malicious contract is trivial (single method returning `true`). The proposal parameters are complex enough to obscure intent from voters who would need to inspect the target contract code, recognize it's not a legitimate organization contract, and understand the privilege escalation implications.

**Feasibility:**
While passing a Parliament proposal requires 2/3 miner approval (a high bar), this is feasible during:
- Governance inattention or rushed voting periods
- Coordinated attacks with compromised miner nodes
- Social engineering framing the proposal as a legitimate governance upgrade

**Economic Rationality:**
The cost is minimal (contract deployment + political capital for one proposal), while the benefit is permanent control over fee structures with significant economic advantage and/or DoS capability. The risk-reward ratio strongly favors exploitation.

The one-time nature (only need one successful proposal ever) significantly increases overall risk compared to attacks requiring repeated governance actions.

## Recommendation

Add contract address validation to `CheckOrganizationExist`:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a known organization contract
    var systemContracts = Context.GetSystemContractNameToAddressMapping();
    var parliamentAddress = systemContracts[SmartContractConstants.ParliamentContractSystemHashName];
    var associationAddress = systemContracts[SmartContractConstants.AssociationContractSystemHashName];
    var referendumAddress = systemContracts[SmartContractConstants.ReferendumContractSystemHashName];
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid organization contract address."
    );
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

This ensures only legitimate governance contracts (Parliament/Association/Referendum) can be used as method fee controllers.

## Proof of Concept

```csharp
[Fact]
public async Task ChangeMethodFeeController_MaliciousContract_Attack()
{
    // 1. Deploy malicious contract with fake ValidateOrganizationExist
    var maliciousContractCode = GetMaliciousContractCode(); // Returns true always
    var maliciousAddress = await DeployUserContractAsync(maliciousContractCode);
    
    // 2. Create Parliament proposal to change controller to malicious contract
    var methodFeeController = await GetMethodFeeController(Tester, BasicContractZeroAddress);
    var proposalId = await CreateProposalAsync(
        Tester, 
        methodFeeController.ContractAddress,
        methodFeeController.OwnerAddress,
        nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ChangeMethodFeeController),
        new AuthorityInfo
        {
            OwnerAddress = AttackerAddress, // Attacker controls this
            ContractAddress = maliciousAddress // Points to malicious contract
        }
    );
    
    // 3. Approve and release proposal (simulates 2/3 miner approval)
    await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
    var releaseResult = await ReleaseProposalAsync(Tester, ParliamentAddress, proposalId);
    
    // Vulnerability: This succeeds when it should fail
    releaseResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // 4. Verify attacker now controls method fees
    var newController = await GetMethodFeeController(Tester, BasicContractZeroAddress);
    newController.OwnerAddress.ShouldBe(AttackerAddress);
    newController.ContractAddress.ShouldBe(maliciousAddress);
    
    // 5. Attacker can now set arbitrary fees without governance
    var attackerTester = GetTester(AttackerPrivateKey);
    var setFeeResult = await attackerTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.SetMethodFee),
        new MethodFees
        {
            MethodName = nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.DeploySmartContract),
            Fees = { new MethodFee { Symbol = "ELF", BasicFee = 1000000000 } } // Prohibitively high
        }
    );
    
    // Attack successful: Attacker has permanent fee control
    setFeeResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L9-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L218-221)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L1255-1270)
```csharp
        // Invalid organization address
        var methodFeeController = await GetMethodFeeController(Tester, BasicContractZeroAddress);
        const string proposalCreationMethodName =
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ChangeMethodFeeController);
        var proposalId = await CreateProposalAsync(Tester, methodFeeController.ContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName,
            new AuthorityInfo
            {
                OwnerAddress = SampleAddress.AddressList[4],
                ContractAddress = ParliamentAddress
            });
        await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
        var txResult2 = await ReleaseProposalAsync(Tester, ParliamentAddress, proposalId);
        txResult2.Status.ShouldBe(TransactionResultStatus.Failed);
        txResult2.Error.Contains("Invalid authority input.").ShouldBeTrue();
    }
```
