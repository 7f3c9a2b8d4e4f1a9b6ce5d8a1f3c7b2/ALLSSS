# Audit Report

## Title
ChangeMethodFeeController Orphans Pending Parliament Proposals for Method Fee Changes

## Summary
The `ChangeMethodFeeController` function in ACS1-implementing contracts (including Referendum) can migrate the method fee controller to a new organization without checking for pending Parliament proposals targeting `SetMethodFee`. When these approved proposals are later released, the authorization check fails because `Context.Sender` (the old Parliament organization address) no longer matches the updated controller address, causing legitimate governance actions to permanently fail.

## Finding Description

The Referendum contract (and all ACS1-implementing contracts) initializes its `MethodFeeController` to Parliament's default organization address. [1](#0-0) 

The `ChangeMethodFeeController` function only validates that the sender is the current controller owner and that the new organization exists, but performs no check for pending proposals that would become orphaned. [2](#0-1) 

When Parliament releases a proposal, it executes the target method using `Context.SendVirtualInlineBySystemContract` with a virtual hash derived from the organization's hash and creation token. [3](#0-2) 

This virtual address IS the organization address, as confirmed by the organization address calculation logic. [4](#0-3) 

Therefore, when a Parliament proposal calls `SetMethodFee`, `Context.Sender` equals the Parliament organization address. However, `SetMethodFee` enforces a strict authorization check. [5](#0-4) 

**Attack Sequence:**
1. Proposal A: `SetMethodFee` on Referendum created and approved by miners
2. Proposal B: `ChangeMethodFeeController` on Referendum created, approved, and **released first**
3. State.MethodFeeController.Value.OwnerAddress now points to the new organization
4. When Proposal A is released, Context.Sender (old Parliament org) â‰  State.MethodFeeController.Value.OwnerAddress (new org)
5. Authorization assertion fails: "Unauthorized to set method fee."

This breaks the governance invariant that approved proposals meeting all thresholds should be executable.

## Impact Explanation

**Governance Disruption:** Approved Parliament proposals for method fee adjustments cannot be implemented despite meeting 2/3 miner approval thresholds, violating the fundamental governance guarantee that approved proposals are executable.

**Wasted Resources:** Proposers expend transaction fees for proposal creation, miner coordination effort for voting, and execution gas that ultimately results in failed transactions.

**Operational Delays:** Critical method fee updates must be re-proposed under the new controller, causing delays in protocol operations and potentially leaving incorrect fee structures in place longer than intended.

**Malicious Exploitation:** An attacker with sufficient governance influence could strategically change the controller to block specific fee adjustments that are politically unfavorable but close to approval, weaponizing the controller migration to veto legitimate governance decisions.

**Systemic Issue:** This affects ALL ACS1-implementing contracts (Parliament, Association, Referendum, Token, Vote, Election, Treasury, Profit, TokenConverter, TokenHolder, Consensus, CrossChain, Economic, NFT), making it a protocol-wide governance vulnerability rather than isolated to Referendum.

The impact justifies **Medium severity** as it disrupts protocol governance operations without direct fund loss, but undermines the integrity of the governance system.

## Likelihood Explanation

All preconditions are realistic within standard governance operations:

**Entry Point:** `ChangeMethodFeeController` is a public governance-controlled method reachable through Parliament proposals. [6](#0-5) 

**Execution Practicality:** Parliament proposal workflows (creation, approval, release) are standard operations used extensively throughout the protocol, as confirmed by production test suites. [7](#0-6) 

**Economic Rationality:** Creating two Parliament proposals costs minimal gas fees, and the attacker doesn't need special privileges beyond standard proposal creation rights available to any whitelisted proposer or miner.

**Timing Window:** Parliament proposals can remain in approved-but-not-released state for extended periods (proposals have expiry times but can stay pending), creating a natural window where controller changes can orphan existing proposals.

**Expected Scenario:** Controller migrations are legitimate governance operations expected during protocol evolution (e.g., migrating from Parliament to Association control, or creating specialized governance bodies), making this collision realistic rather than theoretical.

**No Protection:** The codebase provides no warning mechanism, pending proposal check, grace period, or proposal migration logic to prevent this issue.

The likelihood is **Medium to High** because controller changes are expected protocol operations with no safeguards against pending proposal collisions.

## Recommendation

Implement one of the following mitigations:

**Option 1: Pending Proposal Check**
Before allowing controller changes, verify no pending proposals target `SetMethodFee` on the contract. This requires maintaining a registry of active proposals or querying the governance contract.

**Option 2: Grace Period**
Store the previous controller for a grace period (e.g., 7 days) after migration. Modify `SetMethodFee` to accept `Context.Sender` matching either the current controller OR the previous controller within the grace window.

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // Store previous controller with expiry
    State.PreviousMethodFeeController.Value = State.MethodFeeController.Value;
    State.ControllerMigrationTime.Value = Context.CurrentBlockTime;
    
    State.MethodFeeController.Value = input;
    return new Empty();
}

public override Empty SetMethodFee(MethodFees input)
{
    foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
    RequiredMethodFeeControllerSet();
    
    var isCurrentController = Context.Sender == State.MethodFeeController.Value.OwnerAddress;
    var isPreviousControllerInGracePeriod = false;
    
    if (State.PreviousMethodFeeController.Value != null && State.ControllerMigrationTime.Value != null)
    {
        var gracePeriodDays = 7;
        var gracePeriodExpiry = State.ControllerMigrationTime.Value.AddDays(gracePeriodDays);
        isPreviousControllerInGracePeriod = Context.Sender == State.PreviousMethodFeeController.Value.OwnerAddress 
            && Context.CurrentBlockTime < gracePeriodExpiry;
    }
    
    Assert(isCurrentController || isPreviousControllerInGracePeriod, "Unauthorized to set method fee.");
    State.TransactionFees[input.MethodName] = input;
    
    return new Empty();
}
```

**Option 3: Documentation Warning**
At minimum, document this behavior clearly and establish governance procedures requiring coordination checks before controller migrations.

## Proof of Concept

```csharp
[Fact]
public async Task ChangeMethodFeeController_Orphans_Pending_SetMethodFee_Proposal()
{
    // Setup: Get default Parliament organization (initial controller)
    var defaultOrganization = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    var initialController = await ReferendumContractStub.GetMethodFeeController.CallAsync(new Empty());
    initialController.OwnerAddress.ShouldBe(defaultOrganization);
    
    // Step 1: Create Proposal A - SetMethodFee (approved but not released)
    var setMethodFeeInput = new MethodFees
    {
        MethodName = nameof(ReferendumContractStub.CreateProposal),
        Fees = { new MethodFee { Symbol = "ELF", BasicFee = 5000_0000L } }
    };
    var proposalA = await ParliamentContractStub.CreateProposal.SendAsync(new CreateProposalInput
    {
        ToAddress = ReferendumContractAddress,
        Params = setMethodFeeInput.ToByteString(),
        ContractMethodName = nameof(ReferendumContractStub.SetMethodFee),
        ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1),
        OrganizationAddress = defaultOrganization
    });
    var proposalAId = proposalA.Output;
    await ApproveWithMinersAsync(proposalAId); // Approved but NOT released yet
    
    // Step 2: Create new Parliament organization for controller migration
    var newOrgResult = await ParliamentContractStub.CreateOrganization.SendAsync(
        new Parliament.CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 1000,
                MinimalVoteThreshold = 1000
            }
        });
    var newOrganization = Address.Parser.ParseFrom(newOrgResult.TransactionResult.ReturnValue);
    
    // Step 3: Create and release Proposal B - ChangeMethodFeeController BEFORE releasing A
    var proposalB = await ParliamentContractStub.CreateProposal.SendAsync(new CreateProposalInput
    {
        ToAddress = ReferendumContractAddress,
        Params = new AuthorityInfo
        {
            OwnerAddress = newOrganization,
            ContractAddress = ParliamentContractAddress
        }.ToByteString(),
        ContractMethodName = nameof(ReferendumContractStub.ChangeMethodFeeController),
        ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1),
        OrganizationAddress = defaultOrganization
    });
    var proposalBId = proposalB.Output;
    await ApproveWithMinersAsync(proposalBId);
    await ParliamentContractStub.Release.SendAsync(proposalBId); // Release Proposal B first
    
    // Verify controller changed
    var newController = await ReferendumContractStub.GetMethodFeeController.CallAsync(new Empty());
    newController.OwnerAddress.ShouldBe(newOrganization);
    
    // Step 4: Try to release Proposal A - SHOULD FAIL with "Unauthorized"
    var releaseResult = await ParliamentContractStub.Release.SendWithExceptionAsync(proposalAId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Unauthorized to set method fee");
    
    // Verify the method fee was NOT updated (proposal failed)
    var methodFee = await ReferendumContractStub.GetMethodFee.CallAsync(new StringValue
    {
        Value = nameof(ReferendumContractStub.CreateProposal)
    });
    methodFee.Fees.Count.ShouldBe(0); // No fee set, proposal was orphaned
}
```

## Notes

This vulnerability is **systemic across all ACS1-implementing contracts** in the AElf ecosystem, not limited to Referendum. Any contract using the standard ACS1 method fee controller pattern is vulnerable to pending proposal orphaning during controller migrations. The same issue affects Parliament, Association, Token, Vote, Election, Treasury, Profit, and all other system contracts implementing the ACS1 standard.

### Citations

**File:** contract/AElf.Contracts.Referendum/ReferendumContract_ACS1_TransactionFeeProvider.cs (L15-15)
```csharp
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
```

**File:** contract/AElf.Contracts.Referendum/ReferendumContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/ReferendumContract_ACS1_TransactionFeeProvider.cs (L49-63)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L138-140)
```csharp
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L293-305)
```csharp
    private OrganizationHashAddressPair CalculateOrganizationHashAddressPair(
        CreateOrganizationInput createOrganizationInput)
    {
        var organizationHash = HashHelper.ComputeFrom(createOrganizationInput);
        var organizationAddress =
            Context.ConvertVirtualAddressToContractAddressWithContractHashName(
                CalculateVirtualHash(organizationHash, createOrganizationInput.CreationToken));
        return new OrganizationHashAddressPair
        {
            OrganizationAddress = organizationAddress,
            OrganizationHash = organizationHash
        };
    }
```

**File:** test/AElf.Contracts.Referendum.Tests/ReferendumContractTest.cs (L878-915)
```csharp
    [Fact]
    public async Task SetMethodFee_Test()
    {
        var inputFee = new MethodFees
        {
            MethodName = nameof(ReferendumContractStub.CreateProposal),
            Fees =
            {
                new MethodFee
                {
                    Symbol = "ELF",
                    BasicFee = 5000_0000L
                }
            }
        };
        var defaultOrganization = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
        var result = await ParliamentContractStub.CreateProposal.SendAsync(new CreateProposalInput
        {
            ToAddress = ReferendumContractAddress,
            Params = inputFee.ToByteString(),
            ContractMethodName = nameof(ReferendumContractStub.SetMethodFee),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1),
            OrganizationAddress = defaultOrganization
        });
        var proposalId = result.Output;
        await ApproveWithMinersAsync(proposalId);
        await ParliamentContractStub.Release.SendAsync(proposalId);

        var feeResult = await ReferendumContractStub.GetMethodFee.CallAsync(new StringValue
        {
            Value = nameof(ReferendumContractStub.CreateProposal)
        });
        feeResult.Fees.First().ShouldBe(new MethodFee
        {
            Symbol = "ELF",
            BasicFee = 5000_0000L
        });
    }
```
