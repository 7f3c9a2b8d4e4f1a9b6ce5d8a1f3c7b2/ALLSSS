# Audit Report

## Title
Next Round Order Manipulation via Unvalidated FinalOrderOfNextRound Values in UpdateValue

## Summary
A malicious miner can manipulate `FinalOrderOfNextRound` values for all miners during `UpdateValue` block production, granting themselves favorable positions (such as first miner or extra block producer) in subsequent rounds. The consensus validation logic fails to verify that order values are correctly calculated from signatures, allowing manipulated values to propagate through the system and determine the next round's mining schedule.

## Finding Description

The vulnerability exists in the AEDPoS consensus update flow where order values for the next round are not cryptographically validated against their expected calculation.

**Block Creation Flow:** When a miner produces an UpdateValue block, `GetUpdateValueRound()` creates a simplified round containing `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` for **all miners**. [1](#0-0)  These values are copied from the current round state into the block header without any cryptographic commitment to their correctness.

**Validation Flow:** During validation in `ValidateBeforeExecution`, the system calls `RecoverFromUpdateValue()` which blindly copies order values from the block header into consensus state for **all miners**. [2](#0-1)  The validation provider only checks that `OutValue` and `Signature` are filled, and that `PreviousInValue` is correct - **there is no validation** that order values match their expected calculation. [3](#0-2) 

**Correct Calculation Not Enforced:** The protocol specifies that `supposedOrderOfNextRound` should be calculated as `GetAbsModulus(signature.ToInt64(), minersCount) + 1`, followed by deterministic conflict resolution. [4](#0-3)  However, this calculation is only performed locally during block creation in `GetConsensusExtraDataToPublishOutValue`, and is never re-validated by other nodes. [5](#0-4) 

**State Persistence:** In `ProcessUpdateValue`, the system directly applies the provided order values and `TuneOrderInformation` without verification. [6](#0-5)  These manipulated values then persist in state and determine the mining schedule for subsequent rounds.

**Ineffective Hash Validation:** The hash check in `ValidateConsensusAfterExecution` compares the header's round with the current round **after** `RecoverFromUpdateValue` has already copied the manipulated values into the current round, making this check ineffective. [7](#0-6) 

**Attack Execution:** A malicious miner modifies their local node to set arbitrary order values in the Round object after `ApplyNormalConsensusData` completes but before block generation. Both the block header (via `GetUpdateValueRound`) and transaction (via `ExtractInformationToUpdateConsensus`) are generated from the same manipulated Round object, so they remain internally consistent while violating the protocol's signature-based ordering rules.

## Impact Explanation

**Consensus Integrity Violation:** This vulnerability fundamentally breaks the consensus mechanism's fairness and randomness guarantees. The attacker can arbitrarily determine the mining order for the next round, subverting the cryptographic randomness that should govern block producer selection.

**Direct Economic Impact:**
- The attacker can assign themselves `FinalOrderOfNextRound = 1` to consistently mine first in subsequent rounds
- Mining first provides advantages in capturing block production rewards and transaction fees
- The attacker can manipulate which miner becomes the extra block producer (who produces an additional block per round)
- Other honest miners suffer reduced mining opportunities and economic rewards

**Severity Justification - CRITICAL:**
1. Any active miner can exploit this without requiring special privileges beyond normal mining rights
2. The attack directly subverts consensus fairness, a core security property
3. It enables sustained reward manipulation across multiple rounds
4. The consensus system's security model fundamentally assumes order values reflect cryptographic randomness from signatures - this assumption is violated

## Likelihood Explanation

**Attacker Capabilities:** Any miner in the active consensus set can execute this attack. The attacker only needs to run a modified node that manipulates the Round object before calling block generation functions.

**Attack Complexity:** Low. The attacker modifies their local consensus client to set desired order values after the correct calculation completes. Both the block header and transaction are generated locally with the same manipulated values, so internal consistency checks pass.

**Feasibility:** The attack is immediately executable. The validation logic has no checks for order value correctness. The hash-based validation only confirms consistency between header and transaction data, not correctness against protocol rules.

**Detection Constraints:** The attack is difficult to detect because manipulated order values pass all existing validation checks. Only manual auditing comparing order assignments against the signature-based calculation formula would reveal the manipulation.

**Economic Rationality:** Attack cost is zero (no additional resources beyond normal block production), while benefits include increased mining rewards and strategic control over consensus timing.

## Recommendation

Implement cryptographic validation of order values during consensus validation:

1. **In UpdateValueValidationProvider**, add validation logic that:
   - Extracts the signature from the provided round
   - Recalculates `supposedOrder = GetAbsModulus(signature.ToInt64(), minersCount) + 1`
   - Verifies that the provided `SupposedOrderOfNextRound` matches the recalculated value
   - Verifies that `FinalOrderOfNextRound` follows the correct conflict resolution algorithm

2. **Add validation for TuneOrderInformation**:
   - Verify that order adjustments in `TuneOrderInformation` are legitimate conflict resolutions
   - Ensure no miner can arbitrarily modify order values for other miners
   - Validate that the deterministic conflict resolution algorithm was correctly applied

3. **Strengthen hash validation**:
   - Compare the hash of the header's round against a freshly calculated round that applies `ApplyNormalConsensusData` with the provided signature
   - This ensures order values are derived from the cryptographic signature, not arbitrarily set

## Proof of Concept

A test would need to:
1. Set up a consensus round with multiple miners
2. Have a malicious miner create an UpdateValue block where they manually set `FinalOrderOfNextRound = 1` for themselves and arbitrary values for others in the Round object
3. Submit this block through the validation pipeline
4. Verify that validation passes (demonstrating the vulnerability)
5. Verify that the manipulated order values persist in state
6. Show that the next round uses these manipulated orders for mining schedule determination

The vulnerability is confirmed by the absence of order value validation in `UpdateValueValidationProvider` and the blind copying in `RecoverFromUpdateValue`, combined with direct application in `ProcessUpdateValue` without cryptographic verification.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L35-53)
```csharp
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-260)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```
