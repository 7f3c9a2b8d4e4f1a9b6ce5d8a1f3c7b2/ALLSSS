### Title
Unbounded Token Symbol Accumulation Causes DoS in Profit Distribution

### Summary
The Profit Contract allows unlimited token symbols to be added to `scheme.ReceivedTokenSymbols` through the public `ContributeProfits` function without any size limit. When `DistributeProfits()` is called with `IsReleaseAllBalanceEveryTimeByDefault = true` and an empty `AmountsMap`, it iterates through all accumulated symbols making multiple cross-contract calls per symbol, causing excessive gas consumption that can DoS critical economic functions like Treasury miner rewards and TokenHolder distributions.

### Finding Description

**Root Cause**: The `ReceivedTokenSymbols` field in the Scheme proto definition is an unbounded repeated string field [1](#0-0)  with no size constraint enforced in the contract logic.

**Attack Vector**: The public `ContributeProfits` method [2](#0-1)  allows any caller to contribute tokens to a scheme. At line 716, when a new token symbol is contributed, it is unconditionally added to `ReceivedTokenSymbols` if not already present [3](#0-2) , with only validation that the token exists [4](#0-3)  and amount is positive [5](#0-4) .

**Gas Consumption Path**: When `DistributeProfits` is called with `IsReleaseAllBalanceEveryTimeByDefault = true` and empty `AmountsMap`, the function enters a critical path [6](#0-5)  where it iterates through ALL symbols in `ReceivedTokenSymbols`, making a `GetBalance` cross-contract call for each symbol. Subsequently, `UpdateDistributedProfits` makes another `GetBalance` call per symbol [7](#0-6) , and `PerformDistributeProfits` iterates again [8](#0-7) , resulting in O(N) cross-contract calls where N is the number of symbols.

**Missing Protection**: While a `TokenAmountLimit` constant exists with value 5 [9](#0-8) , it is only enforced in the `SetMethodFee` function [10](#0-9)  and is NOT validated in `DistributeProfits`. There is no check limiting `ReceivedTokenSymbols.Count` or `AmountsMap.Count` in the distribution logic [11](#0-10) .

**Affected Schemes**: Critical system schemes vulnerable to this attack include all Treasury schemes (MinerReward, Basic Reward, Treasury, Subsidy, Welfare, Flexible Reward, Welcome Reward) [12](#0-11)  and all TokenHolder schemes [13](#0-12) , as they all set `IsReleaseAllBalanceEveryTimeByDefault = true`.

### Impact Explanation

**Operational DoS**: An attacker can permanently prevent profit distribution for critical economic schemes by causing `DistributeProfits` transactions to exceed gas limits. This directly impacts:
- **Miner Rewards**: Consensus validators cannot receive mining rewards, potentially causing them to stop block production
- **Treasury Operations**: All 7 Treasury schemes become non-functional, halting the entire economic reward system
- **TokenHolder Dividends**: Users cannot receive staking rewards

**Severity**: High/Medium severity because while no funds are stolen, the attack disrupts core economic incentives that keep the blockchain operational. Miners losing access to rewards could lead to consensus instability.

**Irreversibility**: There is no mechanism to remove symbols from `ReceivedTokenSymbols` (no `Clear` or `Remove` operations exist in the codebase), making the DoS permanent unless the scheme is recreated with a new ID.

### Likelihood Explanation

**Reachable Entry Point**: `ContributeProfits` is a fully public method with no authorization checks beyond token ownership.

**Attacker Capabilities Required**:
1. Access to multiple valid token symbols (realistic in any active blockchain ecosystem with multiple tokens)
2. Small amounts of each token (minimum 1 unit per symbol required)
3. Token approval for the Profit Contract
4. Transaction fees (~1 ELF per `ContributeProfits` call based on default fees)

**Attack Complexity**: Low. The attacker simply calls `ContributeProfits` repeatedly with different token symbols. For example, with 100 different tokens:
- Cost: ~100 ELF in transaction fees + 100 token units (total minimal value)
- Result: `DistributeProfits` makes 200+ cross-contract calls (2 GetBalance calls per symbol + transfer operations)

**Economic Rationality**: The attack cost is reasonable (~100-200 ELF) compared to the impact (DoS of entire economic reward system). A motivated attacker or competitor could execute this to disrupt the network.

**Detection Constraints**: The attack appears as normal profit contributions and would only be detected when `DistributeProfits` begins failing due to gas exhaustion.

### Recommendation

**Immediate Fix**: Enforce the existing `TokenAmountLimit` constant in `DistributeProfits`:

```csharp
// In DistributeProfits method, after line 420
if (input.AmountsMap.Any())
{
    Assert(input.AmountsMap.Count <= ProfitContractConstants.TokenAmountLimit, 
           $"Cannot distribute more than {ProfitContractConstants.TokenAmountLimit} token types at once.");
    Assert(input.AmountsMap.All(a => !string.IsNullOrEmpty(a.Key)), "Invalid token symbol.");
}
else if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
{
    Assert(scheme.ReceivedTokenSymbols.Count <= ProfitContractConstants.TokenAmountLimit,
           $"Scheme has accumulated too many token symbols ({scheme.ReceivedTokenSymbols.Count}). Use explicit AmountsMap.");
}
```

**Additional Protection**: Add validation in `ContributeProfits` before adding new symbols:

```csharp
// At line 716, before adding to ReceivedTokenSymbols
if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol))
{
    Assert(scheme.ReceivedTokenSymbols.Count < ProfitContractConstants.TokenAmountLimit,
           $"Scheme has reached maximum token symbol limit of {ProfitContractConstants.TokenAmountLimit}");
    scheme.ReceivedTokenSymbols.Add(input.Symbol);
}
```

**Long-term Solution**: Implement a mechanism to remove unused symbols or allow managers to reset `ReceivedTokenSymbols` with proper authorization checks.

**Test Cases**: Add tests verifying:
1. `ContributeProfits` rejects contributions when symbol limit is reached
2. `DistributeProfits` rejects calls when `ReceivedTokenSymbols.Count` exceeds limit
3. Explicit `AmountsMap` can override the limit (up to 5 symbols) for manager-controlled distributions

### Proof of Concept

**Initial State**:
- Treasury contract has initialized 7 profit schemes with `IsReleaseAllBalanceEveryTimeByDefault = true`
- Attacker has access to 100 different valid token symbols (e.g., various tokens deployed on the network)
- Attacker has 1 unit of each token and has approved the Profit Contract

**Attack Steps**:
1. Attacker identifies the Treasury's MinerReward scheme ID
2. For each of 100 token symbols:
   - Attacker calls `ContributeProfits(schemeId: MinerReward, symbol: TOKEN_N, amount: 1, period: 0)`
   - Transaction succeeds, adds TOKEN_N to `scheme.ReceivedTokenSymbols`
   - Total cost: ~100 ELF in fees + 100 token units
3. Treasury manager attempts to call `DistributeProfits(schemeId: MinerReward, period: X, amountsMap: {})`
4. Function enters the loop at line 451, attempting to iterate through 100 symbols
5. Makes 100 GetBalance calls (lines 453-457) + 100 more in UpdateDistributedProfits (lines 574-578)
6. Transaction runs out of gas and reverts
7. Miner rewards cannot be distributed

**Expected Result**: `DistributeProfits` succeeds and distributes profits

**Actual Result**: `DistributeProfits` fails with out-of-gas error, permanently blocking profit distribution for the scheme

**Success Condition**: The transaction consistently fails due to gas exhaustion when symbol count exceeds ~50-100 (exact threshold depends on gas limits and other operations in the transaction).

### Citations

**File:** protobuf/profit_contract.proto (L159-159)
```text
    repeated string received_token_symbols = 12;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L419-420)
```csharp
        if (input.AmountsMap.Any())
            Assert(input.AmountsMap.All(a => !string.IsNullOrEmpty(a.Key)), "Invalid token symbol.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L449-459)
```csharp
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L570-580)
```csharp
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L588-603)
```csharp
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
            Context.LogDebug(() => $"Distributing {remainAmount} {symbol} tokens.");
            // Transfer remain amount to individuals' receiving profits address.
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-721)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
        // ReSharper disable once PossibleNullReferenceException
        var virtualAddress = scheme.VirtualAddress;

        if (input.Period == 0)
        {

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = virtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = $"Add {input.Amount} dividends."
            });
        }
        else
        {
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
        }

        // If someone directly use virtual address to do the contribution, won't sense the token symbol he was using.
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);

        State.SchemeInfos[scheme.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L8-8)
```csharp
    public const int TokenAmountLimit = 5;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L14-14)
```csharp
        Assert(input.Fees.Count <= ProfitContractConstants.TokenAmountLimit, "Invalid input.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-67)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```
