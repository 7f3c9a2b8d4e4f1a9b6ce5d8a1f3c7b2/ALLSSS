# Audit Report

## Title
Method Fee Controller Can Be Irreversibly Changed to Uncontrolled Organization

## Summary
The `ChangeMethodFeeController()` function in all ACS1-implementing contracts allows the current controller to transfer method fee control to any valid organization address without verifying that the controller has authority over the new organization. This enables irreversible lockout scenarios where control is accidentally or maliciously transferred to an inaccessible organization, with no recovery mechanism available.

## Finding Description

The vulnerability exists in the `ChangeMethodFeeController()` implementation across all 15+ system contracts. The method validates the new controller organization insufficiently by only checking existence, not authority. [1](#0-0) 

The root cause is the `CheckOrganizationExist` validation which makes a cross-contract call to verify only that the organization exists in storage: [2](#0-1) 

The `ValidateOrganizationExist` implementation in all three governance contracts confirms this insufficient validation - it merely checks if the organization is stored, without verifying caller authority: [3](#0-2) [4](#0-3) [5](#0-4) 

The same vulnerable pattern exists in all ACS1 implementations including MultiToken and Parliament contracts: [6](#0-5) [7](#0-6) [8](#0-7) [9](#0-8) 

The recovery mechanism only initializes the controller to default when it's null, providing no emergency override: [10](#0-9) 

Test evidence demonstrates that a controller can successfully change to a newly created organization with arbitrary thresholds and members, without verifying access: [11](#0-10) 

## Impact Explanation

**Critical Governance Lockout**: The current controller permanently loses the ability to set method fees or change the controller back. Method fees are fundamental to:
- Anti-spam protection through transaction cost enforcement
- Network economic sustainability
- Resource allocation and pricing mechanisms

**No Recovery Path**: The only way to regain control is through the NEW organization's approval process, which may be:
- Controlled by different stakeholders with conflicting interests
- Configured with impossible-to-reach approval thresholds
- Effectively abandoned or misconfigured
- Maliciously chosen to permanently lock out honest governance

**Systemic Risk**: This vulnerability affects all 15+ system contracts implementing ACS1 (Consensus, MultiToken, Parliament, Association, Referendum, Treasury, Profit, TokenConverter, CrossChain, Economic, Election, Genesis, Configuration, Vote, TokenHolder, NFT), creating multiple potential lockout points across the protocol.

The impact is on **authorization** - a core security property. Once control is lost, protocol economics and spam protection become unmanageable without emergency hard fork intervention.

## Likelihood Explanation

**Preconditions**: Requires current method fee controller approval (typically Parliament default organization with 2/3 miner threshold).

**Attack Vectors**:
1. **Accidental Misconfiguration**: Governance proposal contains typo in organization address or selects wrong organization during migration
2. **Social Engineering**: Malicious actor influences proposal creation to include an organization they control
3. **Compromised Proposer**: Attacker with proposal rights submits malicious controller change
4. **Migration Error**: During governance restructuring, new organization is set before verifying access rights

**Execution Complexity**: Low - requires a single approved governance proposal to execute the controller change. No complex exploit chain needed.

**Detection Difficulty**: The vulnerability is only discovered after execution when attempting to use `SetMethodFee()` or `ChangeMethodFeeController()` again, at which point the lockout is already permanent.

**Realistic Probability**: Moderate to High - governance systems regularly propose controller changes during upgrades and migrations. Human error in address verification is common, and the lack of authority validation creates a dangerous footgun in critical governance operations.

## Recommendation

Add validation to verify the caller has authority over the new organization before allowing the controller change:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // NEW: Verify caller has authority over new organization
    var hasAuthority = CheckControllerAuthority(input, Context.Sender);
    Assert(hasAuthority, "Caller does not have authority over new organization.");
    
    State.MethodFeeController.Value = input;
    return new Empty();
}

private bool CheckControllerAuthority(AuthorityInfo authorityInfo, Address sender)
{
    // For Association: Check if sender is in organization member list
    // For Parliament: Check if sender is valid parliament member
    // For Referendum: Check if sender has sufficient token balance for proposals
    return Context.Call<BoolValue>(
        authorityInfo.ContractAddress,
        "ValidateProposerInWhiteList", // or equivalent authority check method
        new ValidateProposerInWhiteListInput 
        { 
            OrganizationAddress = authorityInfo.OwnerAddress, 
            Proposer = sender 
        }
    ).Value;
}
```

Alternatively, implement a time-delayed controller change with a challenge period, or require the new organization to accept the transfer via a separate confirmation transaction.

## Proof of Concept

The existing test suite already demonstrates this vulnerability. The test `ChangeMethodFeeController_Test` successfully changes the controller to a newly created organization without verifying that the current controller has any access to it: [11](#0-10) 

This test shows:
1. A new Parliament organization is created with arbitrary thresholds (lines 865-875)
2. A proposal is created to change the method fee controller to this new organization (lines 883-888)
3. The change succeeds after approval (lines 890-893)
4. The controller is now the new organization, with no validation that the previous controller has access to it (line 896)

To demonstrate the lockout, any subsequent attempt to call `SetMethodFee()` or `ChangeMethodFeeController()` by the original controller would fail with "Unauthorized to set method fee" or "Unauthorized behavior" errors, confirming permanent loss of control.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L25-34)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L83-88)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L218-221)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L91-109)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo();

        // Parliament Auth Contract maybe not deployed.
        if (State.ParliamentContract.Value != null)
        {
            defaultAuthority.OwnerAddress =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L56-60)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L863-897)
```csharp
    public async Task ChangeMethodFeeController_Test()
    {
        var createOrganizationResult =
            await ParliamentContractStub.CreateOrganization.SendAsync(
                new Parliament.CreateOrganizationInput
                {
                    ProposalReleaseThreshold = new ProposalReleaseThreshold
                    {
                        MinimalApprovalThreshold = 1000,
                        MinimalVoteThreshold = 1000
                    }
                });
        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.TransactionResult.ReturnValue);

        var methodFeeController = await AssociationContractStub.GetMethodFeeController.CallAsync(new Empty());
        var defaultOrganization = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
        methodFeeController.OwnerAddress.ShouldBe(defaultOrganization);

        const string proposalCreationMethodName = nameof(AssociationContractStub.ChangeMethodFeeController);

        var proposalId = await CreateFeeProposalAsync(AssociationContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName, new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = ParliamentContractAddress
            });

        await ApproveWithMinersAsync(proposalId);
        var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
        releaseResult.TransactionResult.Error.ShouldBeNullOrEmpty();
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var newMethodFeeController = await AssociationContractStub.GetMethodFeeController.CallAsync(new Empty());
        Assert.True(newMethodFeeController.OwnerAddress == organizationAddress);
    }
```
