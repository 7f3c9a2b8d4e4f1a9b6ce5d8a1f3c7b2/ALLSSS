### Title
Negative LIB Height Bypasses Validation in NextRound, Causing Consensus DoS

### Summary
The `NextRoundInput.Create()` function does not validate that `ConfirmedIrreversibleBlockHeight` is non-negative, and the consensus validation framework does not apply `LibInformationValidationProvider` to `NextRound` behavior. A malicious miner can exploit this to inject a negative LIB height into the round state, which corrupts the LIB tracking system and triggers a severe mining status that limits all miners to producing only 1 block at a time, effectively causing a denial-of-service attack on consensus block production.

### Finding Description

**Root Cause:** The `NextRoundInput.Create()` method directly copies `round.ConfirmedIrreversibleBlockHeight` without any validation that the value is non-negative: [1](#0-0) 

The field is defined as `int64` (signed) in the protobuf definition, allowing negative values: [2](#0-1) 

**Why Protections Fail:** During consensus validation, the `ValidateBeforeExecution` method applies different validators based on behavior type. For `NextRound` behavior, it only adds `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider`, but critically **does not** add `LibInformationValidationProvider`: [3](#0-2) 

In contrast, `UpdateValue` behavior receives LIB validation: [4](#0-3) 

The `RoundTerminateValidationProvider` only checks round number increment and that InValues are null, but does not validate LIB height: [5](#0-4) 

**Execution Path:** When `NextRound` is processed, the malicious `NextRoundInput` is converted to a `Round` object and stored to state without validation: [6](#0-5) 

The corrupted LIB height is stored via `AddRoundInformation`: [7](#0-6) 

### Impact Explanation

**Concrete Harm:** The negative LIB height causes critical malfunction in `GetMaximumBlocksCount()`, which reads the corrupted value: [8](#0-7) 

When calculating the distance to LIB with a negative `libBlockHeight` (e.g., -1) and a positive `currentHeight` (e.g., 1000), the subtraction produces an artificially huge distance (1001): [9](#0-8) 

This triggers `Severe` mining status, which limits **all miners** to producing only 1 block at a time instead of the normal maximum. This represents a **denial-of-service attack on consensus** that severely degrades blockchain performance and throughput.

**Persistent Damage:** The negative value propagates to future rounds because `GenerateNextRoundInformation` copies the LIB height forward: [10](#0-9) 

**Who is Affected:** All network participants suffer from degraded block production. The entire consensus mechanism operates in crippled mode until manual intervention.

### Likelihood Explanation

**Attacker Capabilities:** The attacker must be a current miner (verified by `PreCheck`): [11](#0-10) 

**Attack Complexity:** The attack is straightforward:
1. Malicious miner produces a block with `NextRound` consensus behavior
2. In the consensus extra data (block header), they modify the `Round` object to set `ConfirmedIrreversibleBlockHeight` to a negative value (e.g., -1)
3. The block passes validation because `LibInformationValidationProvider` is not applied to `NextRound`
4. The malicious round is stored to state, corrupting LIB tracking

**Feasibility:** The attack requires:
- Attacker is in the current miner list (realistic for any elected miner)
- No special state setup required
- Single transaction execution
- No economic cost beyond normal block production

**Detection:** The attack would be immediately visible in system logs showing `IrreversibleBlockHeightUnacceptable` events and drastically reduced block production rate, but by then the damage is done and persists across rounds.

### Recommendation

**Code-Level Mitigation:**

1. Add validation in `NextRoundInput.Create()`:
```csharp
public static NextRoundInput Create(Round round, ByteString randomNumber)
{
    Assert(round.ConfirmedIrreversibleBlockHeight >= 0, 
           "ConfirmedIrreversibleBlockHeight cannot be negative.");
    Assert(round.ConfirmedIrreversibleBlockRoundNumber >= 0,
           "ConfirmedIrreversibleBlockRoundNumber cannot be negative.");
    // ... rest of method
}
```

2. Apply `LibInformationValidationProvider` to `NextRound` behavior in `ValidateBeforeExecution`:
```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

**Test Cases:**
1. Test that `NextRound` with negative `ConfirmedIrreversibleBlockHeight` is rejected during validation
2. Test that `NextRound` with LIB height lower than current state is rejected
3. Test that malformed consensus extra data with negative LIB height fails block validation

### Proof of Concept

**Initial State:**
- Chain is operating normally with miners in rotation
- Current round has `ConfirmedIrreversibleBlockHeight = 1000`
- Current block height is 1500

**Attack Steps:**
1. Malicious miner (MinerA) waits for their turn to propose a block that should trigger `NextRound` behavior
2. MinerA generates consensus extra data by calling `GetConsensusExtraData`
3. Before including it in the block header, MinerA modifies the `Round` object in the consensus extra data:
   - Sets `ConfirmedIrreversibleBlockHeight = -1`
   - Sets `ConfirmedIrreversibleBlockRoundNumber = -1`
4. MinerA produces and broadcasts the block with malicious consensus data
5. Other nodes validate the block:
   - `ValidateConsensusBeforeExecution` is called
   - Only `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` run
   - Neither validator checks LIB height
   - Validation passes âœ“
6. Block is executed, `NextRound` is called with malicious input
7. `ProcessNextRound` stores the malicious round to state via `AddRoundInformation`
8. State now contains: `State.Rounds[roundNumber].ConfirmedIrreversibleBlockHeight = -1`

**Expected Result:** 
- Validation should reject the block
- LIB height should remain valid

**Actual Result:**
- Block is accepted and executed
- Next call to `GetMaximumBlocksCount()` calculates: `distance = 1500 - (-1) = 1501`
- Mining status becomes `Severe` because distance is huge
- `IrreversibleBlockHeightUnacceptable` event is fired
- All miners are limited to producing 1 block at a time
- System performance degrades by ~90%
- Negative LIB propagates to all subsequent rounds

**Success Condition:** The attack succeeds when the malicious block is accepted, stored to state, and `GetMaximumBlocksCount()` returns 1 instead of the normal maximum (8), causing observable consensus degradation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** protobuf/aedpos_contract.proto (L471-472)
```text
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L24-31)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-294)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
```
