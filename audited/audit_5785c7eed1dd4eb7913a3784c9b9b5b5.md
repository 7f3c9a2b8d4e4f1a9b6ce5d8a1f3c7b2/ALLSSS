### Title
Continuous Blocks Validation Bypass via ProvidedRound Manipulation in UpdateValue/TinyBlock Behaviors

### Summary
A malicious miner can bypass the continuous blocks validation by providing a fake `ProvidedRound` with `RoundNumber â‰¤ 2` in the consensus header extra data when submitting `UpdateValue` or `TinyBlock` transactions. This allows unlimited consecutive block production, violating consensus fairness guarantees and enabling potential chain monopolization.

### Finding Description

The `ContinuousBlocksValidationProvider` checks whether a miner has produced too many continuous blocks using the condition: [1](#0-0) 

The validation relies on `ProvidedRound.RoundNumber` from the consensus header extra data provided by the miner. For `UpdateValue` and `TinyBlock` behaviors, there is **no validation** that ensures `ProvidedRound.RoundNumber` matches the actual current round number stored in state.

The validation flow in `ValidateBeforeExecution` applies different validation providers based on behavior: [2](#0-1) 

For `UpdateValue` and `TinyBlock`, only basic providers (MiningPermission, TimeSlot, ContinuousBlocks) and `UpdateValueValidationProvider`/`LibInformationValidationProvider` are applied. Critically, `RoundTerminateValidationProvider`, which validates round number transitions, is **only applied** to `NextRound` and `NextTerm` behaviors: [3](#0-2) 

**Root Cause:**
The `ProvidedRound` (from `extraData.Round`) is used for validation decisions but is never validated to match `BaseRound.RoundNumber` for `UpdateValue` and `TinyBlock` behaviors. While `BaseRound` is recovered with some fields from `ProvidedRound`: [4](#0-3) 

The recovery methods only merge specific fields (OutValue, Signature, ActualMiningTimes) and do not validate or enforce round number consistency: [5](#0-4) 

The `TimeSlotValidationProvider` compares `RoundId` (not `RoundNumber`) to determine if it's a new round: [6](#0-5) 

Since `RoundId` is calculated from the sum of miners' `ExpectedMiningTime.Seconds`: [7](#0-6) 

An attacker can copy the current round structure with same expected mining times (preserving `RoundId`) but change only the `RoundNumber` field to 2.

**Why Protections Fail:**
While `State.CurrentRoundNumber` is protected by `TryToUpdateRoundNumber` which enforces strict increment-by-1 logic: [8](#0-7) 

This only protects the state storage, not the validation logic which relies on untrusted `ProvidedRound` data from block headers. The header extraction only validates signature matching: [9](#0-8) 

### Impact Explanation

**Consensus Integrity Violation:**
The continuous blocks validation exists to prevent any single miner from monopolizing block production. The limit is enforced through `LatestPubkeyToTinyBlocksCount` tracking: [10](#0-9) 

By bypassing this check, a malicious miner can:
1. Produce unlimited consecutive tiny blocks
2. Effectively monopolize the chain during their time slot
3. Prevent other miners from participating in block production
4. Violate the AEDPoS consensus fairness guarantees

**Affected Parties:**
- Other honest miners lose opportunities to produce blocks and earn rewards
- The network experiences reduced decentralization
- Chain liveness may be impacted if the malicious miner becomes dominant

**Severity:** This is a **Critical** consensus vulnerability as it undermines the core fairness mechanism designed to ensure decentralized block production.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active miner (in the current round's miner list)
- Ability to craft custom consensus header extra data
- No special privileges beyond normal miner status

**Attack Complexity:** Low
1. Query current round information via public view method
2. Copy the current round structure
3. Modify only the `RoundNumber` field to 2
4. Include this fake round in consensus header extra data when submitting `UpdateValue` or `TinyBlock` transactions
5. Keep all other fields (especially `ExpectedMiningTime`) identical to preserve `RoundId`

**Feasibility Conditions:**
- Attacker is already in the active miner set (passes `PreCheck` and `MiningPermissionValidationProvider`)
- Can be executed on every block the attacker produces
- No additional state setup or governance actions required

**Detection Difficulty:** 
The attack is difficult to detect as the fake `ProvidedRound` is only used for validation, while actual state updates use the correct `BaseRound` from storage: [11](#0-10) 

**Probability:** HIGH - Any malicious miner can exploit this consistently without significant cost or complexity.

### Recommendation

**Immediate Fix:**
Add explicit round number validation for `UpdateValue` and `TinyBlock` behaviors in `ValidateBeforeExecution`:

```csharp
// After line 50 in AEDPoSContract_Validation.cs
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue || 
    extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
{
    if (extraData.Round.RoundNumber != baseRound.RoundNumber)
    {
        return new ValidationResult 
        { 
            Message = $"Incorrect round number. Expected {baseRound.RoundNumber}, got {extraData.Round.RoundNumber}." 
        };
    }
}
```

**Invariant to Enforce:**
For `UpdateValue` and `TinyBlock` behaviors: `ProvidedRound.RoundNumber MUST equal BaseRound.RoundNumber`

**Test Cases:**
1. Verify that `UpdateValue` with mismatched round number fails validation
2. Verify that `TinyBlock` with mismatched round number fails validation  
3. Verify that `UpdateValue` with correct round number passes validation
4. Confirm continuous blocks validation is not bypassed with fake round numbers

### Proof of Concept

**Initial State:**
- Blockchain at round 100 with 5 active miners
- Attacker is one of the miners
- `LatestPubkeyToTinyBlocksCount` tracking is active

**Attack Steps:**

1. **Query Current Round:**
   - Call `GetCurrentRoundInformation()` to retrieve round 100 structure
   - Extract all miner information and expected mining times

2. **Craft Fake ProvidedRound:**
   ```
   FakeRound = CurrentRound.Clone()
   FakeRound.RoundNumber = 2  // Bypass continuous blocks validation
   // Keep RoundId same by preserving ExpectedMiningTime values
   ```

3. **Submit Malicious Transaction:**
   - Create `UpdateValue` or `TinyBlock` transaction
   - Include `FakeRound` in consensus header extra data
   - Sign with attacker's miner key

4. **Validation Flow:**
   - `MiningPermissionValidationProvider`: PASS (attacker is legitimate miner in BaseRound)
   - `TimeSlotValidationProvider`: PASS (RoundId matches due to copied structure)
   - `ContinuousBlocksValidationProvider`: SKIPPED (ProvidedRound.RoundNumber = 2, not > 2)
   - `UpdateValueValidationProvider`: PASS (valid signature and out value)

5. **Result:**
   - Attacker produces unlimited consecutive blocks without triggering continuous blocks validation
   - Other miners are starved of block production opportunities
   - Chain becomes progressively centralized

**Expected vs Actual:**
- Expected: Continuous blocks validation should trigger after exceeding limit
- Actual: Validation is bypassed indefinitely due to fake round number

**Success Condition:**
The attacker successfully produces more consecutive blocks than `AEDPoSContractConstants.MaximumTinyBlocksCount` without validation failure.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-14)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-19)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L91-97)
```csharp
    private bool TryToUpdateRoundNumber(long roundNumber)
    {
        var oldRoundNumber = State.CurrentRoundNumber.Value;
        if (roundNumber != 1 && oldRoundNumber + 1 != roundNumber) return false;
        State.CurrentRoundNumber.Value = roundNumber;
        return true;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L29-33)
```csharp
        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-240)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);
```
