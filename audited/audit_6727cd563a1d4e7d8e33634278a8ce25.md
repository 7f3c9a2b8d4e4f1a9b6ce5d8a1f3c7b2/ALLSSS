# Audit Report

## Title
Case-Sensitive Pubkey Comparison Causes Valid Miner Rejection After Candidate Replacement

## Summary
When a candidate's public key is replaced through `ReplaceCandidatePubkey`, if the new pubkey string contains uppercase hex characters, it creates a case mismatch that prevents the miner from producing blocks. The root cause is that normal round generation uses lowercase hex via `ToHex()`, but the replacement flow stores the input string without case normalization, while all validation and block production logic expects lowercase keys.

## Finding Description

The vulnerability stems from inconsistent case handling across the candidate replacement and consensus flows:

**Normal Flow:** When rounds are generated, miner pubkeys are converted to lowercase hex strings using `.ToHex()` and stored as dictionary keys in `RealTimeMinersInformation`. [1](#0-0)  The `ToHex()` implementation uses the formula `b + 0x37 + 0x20` for values 10-15, which produces lowercase 'a'-'f' characters (ASCII 97-102). [2](#0-1) 

**Replacement Flow:** When `ReplaceCandidatePubkey` is called, the input hex strings are validated by `ByteArrayHelper.HexStringToByteArray`, which accepts both uppercase and lowercase hex characters. [3](#0-2)  The method passes these strings directly to the consensus contract without normalization. [4](#0-3) 

**Consensus Update:** The `RecordCandidateReplacement` method uses the input strings AS-IS as dictionary keys. [5](#0-4)  If `NewPubkey` contains uppercase characters, the dictionary key will be stored with that casing.

**Block Production Failure:** When the miner attempts to produce a block, `GetConsensusBlockExtraData` converts their pubkey to lowercase via `ToHex()`. [6](#0-5)  This lowercase key is then used to access `RealTimeMinersInformation`, which fails if the stored key has uppercase characters. [7](#0-6) 

**Validation Failure:** Even if consensus data is obtained, `MiningPermissionValidationProvider` performs case-sensitive `Contains()` checking. [8](#0-7)  The `SenderPubkey` property always produces lowercase. [9](#0-8) 

## Impact Explanation

**Severity: Low**

The impact is a consensus availability issue where a valid miner becomes unable to produce blocks. This directly affects network operation as the affected miner cannot fulfill their consensus duties. However, severity is assessed as Low because:

- Requires candidate admin role (semi-trusted position, not arbitrary attacker)
- Only affects one miner at a time (not systemic)
- Immediately detectable (miner fails to produce blocks)
- Easily recoverable (admin can call `ReplaceCandidatePubkey` again with lowercase hex)
- No fund loss or permanent state corruption
- More likely to occur accidentally than maliciously

## Likelihood Explanation

**Likelihood: Low**

While the vulnerability is technically exploitable, the probability is low because:

- Standard SDK tooling generates lowercase hex via `ToHex()`
- Requires admin to manually input or construct uppercase hex strings
- Needs intentional deviation from normal tooling or direct API calls
- Most development workflows would not produce uppercase hex

However, it can occur in scenarios like:
- Manual administrative operations during emergency procedures
- Custom integration tools that don't use standard SDK methods
- Copy-paste errors with hex strings from external sources

## Recommendation

Add case normalization in `ReplaceCandidatePubkey` before passing to the consensus contract:

```csharp
State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
{
    OldPubkey = oldPubkey.ToLower(),  // Normalize to lowercase
    NewPubkey = newPubkey.ToLower()   // Normalize to lowercase
});
```

Alternatively, normalize in `RecordCandidateReplacement` itself to ensure consistency at the consensus layer. This defense-in-depth approach protects against case mismatches from any source.

## Proof of Concept

```csharp
[Fact]
public async Task ReplaceCandidatePubkey_UppercaseHex_BreaksMining()
{
    // Setup: Create candidate and make them a miner
    var oldKeyPair = InitialCoreDataCenterKeyPairs.First();
    var newKeyPair = ValidationDataCenterKeyPairs.First();
    var admin = ValidationDataCenterKeyPairs.Last();
    
    // Replace with UPPERCASE hex
    var uppercaseNewPubkey = newKeyPair.PublicKey.ToHex().ToUpper();
    
    await adminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = oldKeyPair.PublicKey.ToHex(),
        NewPubkey = uppercaseNewPubkey  // UPPERCASE
    });
    
    // Try to get consensus extra data (simulates block production)
    var minerStub = GetConsensusStub(newKeyPair);
    var trigger = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(newKeyPair.PublicKey),
        Behaviour = AElfConsensusBehaviour.UpdateValue
    };
    
    // This should fail - pubkey will be converted to lowercase by ToHex()
    // but dictionary key is uppercase
    var result = await minerStub.GetConsensusExtraData.CallAsync(trigger.ToBytesValue());
    
    // Miner cannot produce blocks
    result.ShouldBeNull(); // or throws exception
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L16-19)
```csharp
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L38-41)
```csharp
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L15-16)
```csharp
            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L142-143)
```csharp
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L22-23)
```csharp
        var publicKeyBytes = triggerInformation.Pubkey;
        var pubkey = publicKeyBytes.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L58-61)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-20)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L17-17)
```csharp
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();
```
