### Title
Integer Overflow in GetMiningInterval Causes Consensus DoS via Malicious Round Proposal

### Summary
The `GetMiningInterval()` method unsafely casts a long duration to int without bounds checking, allowing a malicious miner to propose a round with extremely large mining intervals (≥2^31 milliseconds) that passes validation but causes integer wraparound to negative values. This breaks consensus command generation and validation, halting the blockchain.

### Finding Description

The vulnerability exists in the type mismatch between round validation and mining interval calculation:

**Validation Phase (uses long):** [1](#0-0) 

The `CheckRoundTimeSlots()` method validates mining intervals using long values from `Milliseconds()`. If a miner proposes a round where all miners are spaced exactly 2^31 milliseconds apart (≈24.855 days), this validation passes because 2,147,483,648 > 0 and all intervals are equal.

**Execution Phase (uses int with unsafe cast):** [2](#0-1) 

The `GetMiningInterval()` method casts the long value to int. When the duration is 2^31 milliseconds, the cast wraps to Int32.MinValue (-2,147,483,648). The `Math.Abs()` operation on Int32.MinValue returns the negative value unchanged (because the positive equivalent exceeds Int32.MaxValue), resulting in a negative mining interval.

**Usage in Consensus Commands:** [3](#0-2) 

This negative MiningInterval is passed to `AddMilliseconds()`, which creates a Duration with negative seconds and nanos: [4](#0-3) 

This causes `MiningDueTime` to be in the past rather than future, breaking consensus timing logic.

**Attack Entry Point:** [5](#0-4) 

Miners can directly submit `NextRoundInput` with arbitrary `ExpectedMiningTime` values via the consensus contract's public interface.

**Validation Occurs Before Execution:** [6](#0-5) 

The malicious round passes `CheckRoundTimeSlots()` validation using long values, becomes the current round, then causes failures when `GetMiningInterval()` is called on it during subsequent block production.

### Impact Explanation

**Consensus Halting DoS:**
When the malicious round becomes active, any subsequent attempt to produce blocks fails because:
1. `GetMiningInterval()` returns a negative value (Int32.MinValue)
2. Consensus command generation creates invalid mining times in the past
3. Time slot validation fails or throws exceptions
4. No miner can produce valid blocks

**Who is Affected:**
- Entire blockchain network halts
- All users, contracts, and transactions blocked
- Requires manual intervention or hard fork to recover

**Severity Justification:**
Critical - this is a consensus-breaking vulnerability that completely halts the blockchain. The attack only requires one malicious miner (out of typically 17-21 elected block producers) to execute during their time slot.

### Likelihood Explanation

**Reachable Entry Point:**
The attack uses the standard consensus flow where miners propose round transitions. Any elected block producer can call the consensus contract to propose NextRound.

**Attacker Capabilities:**
- Must be an elected block producer (requires staking/votes but achievable)
- Can craft arbitrary `NextRoundInput` protobuf messages
- Needs one successful block proposal during their time slot

**Attack Complexity:**
Low - attacker simply crafts a `NextRoundInput` with `ExpectedMiningTime` values spaced exactly 2,147,483,648 milliseconds apart (or any value ≥ 2^31), ensuring all intervals are equal to pass validation.

**Detection/Operational Constraints:**
The malicious round appears valid during validation (long values pass all checks). The issue only manifests when the round becomes active and `GetMiningInterval()` is called with the unsafe int cast.

**Probability:**
High - any compromised or malicious miner can execute this attack. The preconditions are realistic, and the attack is deterministic with no randomness involved.

### Recommendation

**Immediate Fix - Add Bounds Validation:**
In `GetMiningInterval()`, validate that the long value from `Milliseconds()` is within int range before casting:

```csharp
public int GetMiningInterval()
{
    if (RealTimeMinersInformation.Count == 1)
        return 4000;

    var firstTwoMiners = RealTimeMinersInformation.Values
        .Where(m => m.Order == 1 || m.Order == 2).ToList();
    
    var intervalMs = (firstTwoMiners[1].ExpectedMiningTime - 
                      firstTwoMiners[0].ExpectedMiningTime).Milliseconds();
    
    // Validate bounds before casting
    Assert(intervalMs > 0 && intervalMs <= int.MaxValue, 
           "Mining interval out of valid range");
    
    return (int)intervalMs;
}
```

**Additional Validation in CheckRoundTimeSlots:**
Add explicit maximum interval check:

```csharp
if (baseMiningInterval > int.MaxValue)
    return new ValidationResult { Message = "Mining interval exceeds maximum allowed value" };
```

**Test Cases:**
1. Test round proposal with intervals at Int32.MaxValue boundary
2. Test round proposal with intervals >= 2^31 milliseconds
3. Verify validation rejects both scenarios
4. Test that legitimate rounds with normal intervals (4000ms default) still work

### Proof of Concept

**Required Initial State:**
- Blockchain running with AEDPoS consensus
- Attacker is an elected block producer with valid mining rights

**Attack Steps:**

1. Attacker waits for their mining time slot
2. Attacker crafts malicious `NextRoundInput`:
   - Set first miner's `ExpectedMiningTime` = currentBlockTime + 2^31 ms
   - Set second miner's `ExpectedMiningTime` = currentBlockTime + 2×(2^31) ms
   - Continue for all miners, spacing each 2^31 milliseconds apart
3. Attacker proposes NextRound with this input via consensus contract
4. Validation passes:
   - `CheckRoundTimeSlots()` sees long value 2,147,483,648 > 0 ✓
   - All intervals equal ✓
5. Round accepted, becomes current round at block N
6. At block N+1, next miner attempts to produce block
7. Consensus validation calls `GetMiningInterval()` on current (malicious) round
8. Overflow occurs: cast wraps to Int32.MinValue
9. Negative mining interval breaks consensus logic

**Expected Result:**
Normal consensus operation continues

**Actual Result:**
- `GetMiningInterval()` returns -2,147,483,648 (negative value)
- `AddMilliseconds()` creates negative Duration
- `MiningDueTime` moves backwards in time
- Consensus breaks, no valid blocks can be produced
- Blockchain halts

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-47)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L35-35)
```csharp
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
```

**File:** src/AElf.CSharp.Core/Extension/TimestampExtensions.cs (L16-20)
```csharp
    public static Timestamp AddMilliseconds(this Timestamp timestamp, long milliseconds)
    {
        return timestamp + new Duration
            { Seconds = milliseconds / 1000, Nanos = (int)(milliseconds % 1000).Mul(1000000) };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L37-39)
```csharp
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```
