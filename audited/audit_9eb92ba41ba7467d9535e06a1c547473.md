### Title
Missing Authorization Check in SetTreasurySchemeIds Allows Profit Scheme Hijacking

### Summary
The `SetTreasurySchemeIds` method in the Election contract lacks any authorization check, allowing any caller to set critical profit scheme IDs if they can execute the call before legitimate initialization. While the method can only be called once (not "multiple times" as the question suggests), a successful front-running attack would redirect all election-related profit distributions—including voter welfare rewards and candidate subsidies—to attacker-controlled schemes, effectively stealing rewards meant for legitimate miners and voters.

### Finding Description

The vulnerability exists in the `SetTreasurySchemeIds` method which stores five profit scheme hash identifiers used throughout the election reward system. [1](#0-0) 

The method only checks that `TreasuryHash.Value == null` to prevent re-initialization, but performs **no sender authorization**. This contrasts with other maintenance methods in the same contract that properly enforce authorization:

- `UpdateCandidateInformation` restricts calls to the Consensus contract or Emergency Response Organization: [2](#0-1) 

- `UpdateMinersCount` restricts calls to the Consensus contract only: [3](#0-2) 

- `SetProfitsReceiver` restricts calls to the Treasury contract: [4](#0-3) 

The intended initialization flow shows the Economic contract should set these values after retrieving legitimate scheme IDs from the Profit contract: [5](#0-4) 

However, this call happens via `State.ElectionContract.SetTreasurySchemeIds.Send()` during `InitialEconomicSystem`, which occurs **after** the Election contract's own initialization. The Election contract deployment only includes `InitialElectionContract` in its initialization call list: [6](#0-5) 

This creates a timing window between Election contract deployment and Economic contract initialization where `TreasuryHash.Value` is still null.

### Impact Explanation

The scheme IDs stored by `SetTreasurySchemeIds` control the entire election profit distribution system:

1. **Voter Rewards**: `WelfareHash` determines where voter welfare profits are distributed. Every vote adds the voter as a beneficiary to this scheme: [7](#0-6) 

2. **Candidate Subsidies**: `SubsidyHash` determines where backup candidate subsidies are distributed. Candidates in the data center ranking list are added as beneficiaries: [8](#0-7) 

3. **Treasury Period Distributions**: Both schemes are used during snapshot/term transitions to distribute accumulated profits: [9](#0-8) 

An attacker who successfully sets malicious scheme IDs would:
- Create profit schemes under their control
- Redirect 100% of election-related rewards (voter welfare + candidate subsidies)
- Steal ongoing rewards for the entire lifetime of the chain (no recovery mechanism exists)
- Affect all voters and candidates who expect legitimate profit sharing

The only test for this method verifies the re-initialization protection, **not authorization**: [10](#0-9) 

### Likelihood Explanation

**Attack Complexity**: Low - the attacker needs only to:
1. Monitor for Election contract deployment
2. Submit a transaction calling `SetTreasurySchemeIds` with attacker-controlled scheme IDs
3. Execute before the Economic contract's initialization completes

**Timing Window**: Exists in several scenarios:
- **Test environments**: Where manual initialization steps may have delays
- **Side chain deployments**: Where initialization may follow different sequences
- **Contract redeployments**: If the Election contract is ever redeployed/upgraded
- **Development/staging chains**: Where coordination between contract deployments may be imperfect

**Production chains**: While genesis block initialization aims for atomicity, the documentation does not explicitly guarantee that external transactions cannot be inserted between system contract deployments. The Election and Economic contracts are separate deployments with separate initialization methods.

**Detection constraints**: The attack leaves no immediate trace - the malicious scheme IDs would appear as normal state until profit distributions begin failing to reach legitimate recipients.

**Economic rationality**: The cost is a single transaction fee versus the potential to redirect all future election rewards indefinitely. The reward value over time far exceeds any reasonable attack cost.

### Recommendation

Add authorization check to `SetTreasurySchemeIds` to ensure only the Economic contract can call it:

```csharp
public override Empty SetTreasurySchemeIds(SetTreasurySchemeIdsInput input)
{
    Assert(State.TreasuryHash.Value == null, "Treasury profit ids already set.");
    Assert(
        Context.GetContractAddressByName(SmartContractConstants.EconomicContractSystemName) == Context.Sender,
        "Only economic contract can set treasury scheme ids.");
    
    State.TreasuryHash.Value = input.TreasuryHash;
    State.WelfareHash.Value = input.WelfareHash;
    State.SubsidyHash.Value = input.SubsidyHash;
    State.WelcomeHash.Value = input.WelcomeHash;
    State.FlexibleHash.Value = input.FlexibleHash;
    return new Empty();
}
```

Add comprehensive test case:
```csharp
[Fact]
public async Task SetTreasurySchemeIds_Unauthorized_Fails()
{
    // Attempt to call from unauthorized address
    var result = await UnauthorizedElectionStub.SetTreasurySchemeIds.SendAsync(
        new SetTreasurySchemeIdsInput { ... }
    );
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Only economic contract can set treasury scheme ids");
}
```

### Proof of Concept

**Initial State:**
- Election contract deployed and `InitialElectionContract` called
- `State.TreasuryHash.Value == null`
- Economic contract not yet initialized

**Attack Steps:**
1. Attacker creates malicious profit schemes via Profit contract
2. Attacker calls `ElectionContract.SetTreasurySchemeIds()` with malicious scheme IDs:
   ```
   TreasuryHash: <attacker_scheme_1>
   WelfareHash: <attacker_scheme_2>
   SubsidyHash: <attacker_scheme_3>
   WelcomeHash: <attacker_scheme_4>
   FlexibleHash: <attacker_scheme_5>
   ```
3. Transaction succeeds (no authorization check)
4. `State.TreasuryHash.Value` is now non-null
5. When Economic contract attempts legitimate initialization, it fails with "Treasury profit ids already set"

**Expected Result:** Transaction should fail with "Only economic contract can set treasury scheme ids"

**Actual Result:** Transaction succeeds, permanently setting malicious scheme IDs that redirect all future election rewards to attacker-controlled profit schemes

**Success Condition:** All subsequent calls to `AddBeneficiaryToVoter` and `AddBeneficiary` use attacker's scheme IDs, causing profit distributions to flow to attacker instead of legitimate voters and candidates.

### Notes

The question's premise of calling `SetTreasurySchemeIds` "multiple times" is incorrect - the method can only be called once due to the null check at line 164. However, the vulnerability is valid because a **single unauthorized call** before legitimate initialization is sufficient to permanently hijack the profit distribution system. The lack of authorization check is inconsistent with the security pattern used throughout the Election contract for other sensitive operations.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L83-88)
```csharp
    public override Empty UpdateCandidateInformation(UpdateCandidateInformationInput input)
    {
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) ==
            Context.Sender || Context.Sender == GetEmergencyResponseOrganizationAddress(),
            "Only consensus contract can update candidate information.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L162-171)
```csharp
    public override Empty SetTreasurySchemeIds(SetTreasurySchemeIdsInput input)
    {
        Assert(State.TreasuryHash.Value == null, "Treasury profit ids already set.");
        State.TreasuryHash.Value = input.TreasuryHash;
        State.WelfareHash.Value = input.WelfareHash;
        State.SubsidyHash.Value = input.SubsidyHash;
        State.WelcomeHash.Value = input.WelcomeHash;
        State.FlexibleHash.Value = input.FlexibleHash;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L379-398)
```csharp
    public override Empty SetProfitsReceiver(SetProfitsReceiverInput input)
    {
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName) == Context.Sender,
            "No permission.");
        var rankingList = State.DataCentersRankingList;
        if (!rankingList.Value.DataCenters.ContainsKey(input.CandidatePubkey)) return new Empty();
        var beneficiaryAddress = input.PreviousReceiverAddress.Value.Any()
            ? input.PreviousReceiverAddress
            : Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.CandidatePubkey));
        //set same profits receiver address
        if (beneficiaryAddress == input.ReceiverAddress)
        {
            return new Empty();
        }
        RemoveBeneficiary(input.CandidatePubkey,beneficiaryAddress);
        AddBeneficiary(input.CandidatePubkey,input.ReceiverAddress);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L442-454)
```csharp
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.SubsidyHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.WelfareHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L187-209)
```csharp
    private void SetTreasurySchemeIdsToElectionContract()
    {
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
        var schemeIdsManagingByTreasuryContract = State.ProfitContract.GetManagingSchemeIds.Call(
            new GetManagingSchemeIdsInput
            {
                Manager = Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)
            }).SchemeIds;
        var schemeIdsManagingByElectionContract = State.ProfitContract.GetManagingSchemeIds.Call(
            new GetManagingSchemeIdsInput
            {
                Manager = Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName)
            }).SchemeIds;
        State.ElectionContract.SetTreasurySchemeIds.Send(new SetTreasurySchemeIdsInput
        {
            TreasuryHash = schemeIdsManagingByTreasuryContract[0],
            WelcomeHash = schemeIdsManagingByTreasuryContract[3],
            FlexibleHash = schemeIdsManagingByTreasuryContract[4],
            SubsidyHash = schemeIdsManagingByElectionContract[0],
            WelfareHash = schemeIdsManagingByElectionContract[1]
        });
    }
```

**File:** src/AElf.GovernmentSystem/ElectionContractInitializationProvider.cs (L29-46)
```csharp
    public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        return new List<ContractInitializationMethodCall>
        {
            new()
            {
                MethodName = nameof(ElectionContractContainer.ElectionContractStub.InitialElectionContract),
                Params = new InitialElectionContractInput
                {
                    MaximumLockTime = _economicOptions.MaximumLockTime,
                    MinimumLockTime = _economicOptions.MinimumLockTime,
                    TimeEachTerm = _consensusOptions.PeriodSeconds,
                    MinerList = { _consensusOptions.InitialMinerList },
                    MinerIncreaseInterval = _consensusOptions.MinerIncreaseInterval
                }.ToByteString()
            }
        };
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L781-795)
```csharp
    private void AddBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var subsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = beneficiaryAddress,
                Shares = 1,
            },
            ProfitDetailId = subsidyId
        });
    }
```

**File:** test/AElf.Contracts.Election.Tests/GQL/ElectionTests.cs (L40-52)
```csharp
    public async Task ElectionContract_SetTreasurySchemeIds_SetTwice_Test()
    {
        var setSchemeIdRet = await ElectionContractStub.SetTreasurySchemeIds.SendAsync(new SetTreasurySchemeIdsInput
        {
            SubsidyHash = HashHelper.ComputeFrom("Subsidy"),
            TreasuryHash = HashHelper.ComputeFrom("Treasury"),
            WelfareHash = HashHelper.ComputeFrom("Welfare"),
            WelcomeHash = HashHelper.ComputeFrom("Welcome"),
            FlexibleHash = HashHelper.ComputeFrom("Flexible")
        });
        setSchemeIdRet.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        setSchemeIdRet.TransactionResult.Error.ShouldContain("Treasury profit ids already set.");
    }
```
