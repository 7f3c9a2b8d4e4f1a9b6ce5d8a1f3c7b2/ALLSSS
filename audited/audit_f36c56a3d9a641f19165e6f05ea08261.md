# Audit Report

## Title
Missing Validation Allows Transaction Fee Free Allowance Overflow Causing DoS

## Summary
The transaction fee free allowances system lacks validation on allowance amounts during configuration, allowing parliament to set multiple symbol allowances that overflow when summed. Users holding multiple configured tokens above threshold experience transaction failures due to `OverflowException` during the pre-plugin fee charging process, resulting in a denial-of-service condition.

## Finding Description

The vulnerability exists in the transaction fee free allowances configuration and calculation logic:

**Configuration Without Validation:**
The `ConfigTransactionFeeFreeAllowances` method only validates that threshold and refresh seconds are non-negative, but performs no validation on the actual allowance amounts or their cumulative sum across multiple symbol configurations. [1](#0-0) 

**Overflow-Prone Summation:**
The `GetFreeFeeAllowanceAmount` method iterates through all configured symbols for which a user meets the threshold and sums their allowances using the `.Add()` extension method. When a user holds multiple tokens above their configured thresholds, this method builds a map containing allowance entries for each qualifying symbol, then sums all allowances for the requested fee token symbol. [2](#0-1) 

**Checked Arithmetic Throws Exception:**
The `.Add()` extension method uses C#'s `checked` keyword, which throws an `OverflowException` when the sum exceeds `long.MaxValue` (9,223,372,036,854,775,807). [3](#0-2) 

**Critical Path Integration:**
The allowance calculation occurs during transaction fee charging, which is executed as a pre-plugin transaction for every user transaction. The `ChargeTransactionFees` method calls `CalculateTransactionFeeFreeAllowances` to build the allowances map. [4](#0-3) 

This map is then passed to fee charging logic where `GetFreeFeeAllowanceAmount` is invoked to calculate available allowances. [5](#0-4) 

**Pre-Plugin Execution:**
The fee charging occurs as a pre-execution plugin that generates and executes the `ChargeTransactionFees` transaction before the user's main transaction. [6](#0-5) 

**Data Structure:**
The `TransactionFeeFreeAllowancesMap` structure is a nested map that allows multiple symbols to be configured, each with their own allowance mappings. [7](#0-6) 

The `CalculateTransactionFeeFreeAllowances` method iterates through all configured symbols and adds entries to the map for each symbol where the user's balance meets the threshold. [8](#0-7) 

**Execution Flow:**
1. Parliament configures Symbol_A with threshold=1000 and allowances={ELF: 5,000,000,000,000,000,000}
2. Parliament configures Symbol_B with threshold=1000 and allowances={ELF: 5,000,000,000,000,000,000}
3. User holds both Symbol_A >= 1000 and Symbol_B >= 1000
4. User submits any transaction
5. Pre-plugin generates `ChargeTransactionFees` transaction
6. `CalculateTransactionFeeFreeAllowances` builds map with both Symbol_A and Symbol_B entries
7. `GetFreeFeeAllowanceAmount(map, "ELF")` iterates and sums: 5e18 + 5e18 = 10e18
8. Sum exceeds `long.MaxValue` → `OverflowException` thrown
9. Pre-plugin transaction fails → User's main transaction fails

## Impact Explanation

**Operational DoS:**
When parliament configures multiple symbols with allowance amounts that sum beyond `long.MaxValue` for any fee token, all users holding those tokens above their respective thresholds become unable to execute any transactions. The overflow exception propagates up through the call stack and causes the pre-plugin fee charging transaction to fail, which blocks the user's actual transaction from executing.

**Affected Users:**
Any user who legitimately holds multiple tokens for which parliament has configured free allowances above the respective thresholds. This could affect a significant portion of the user base if commonly held tokens are misconfigured.

**System Impact:**
The blockchain's transaction processing capability is degraded for affected users until parliament reconfigures the allowances with corrected values through a governance proposal. During this remediation period, impacted users cannot perform any transactions.

**Severity Assessment:**
Medium severity - This causes significant operational disruption without direct fund loss. The impact is substantial (complete transaction DoS for affected users) but requires a configuration error by parliament rather than malicious exploitation. The issue is recoverable through governance action but requires time and coordination.

## Likelihood Explanation

**Configuration Error Likelihood:**
Parliament configures transaction fee free allowances through governance proposals. Without validation warnings, bounds checking, or cumulative sum validation, administrators could unknowingly set values that trigger the overflow condition. For example:
- Symbol1: ELF allowance = 5,000,000,000,000,000,000 (representing 50 million ELF tokens)
- Symbol2: ELF allowance = 5,000,000,000,000,000,000 (representing 50 million ELF tokens)
- Sum = 10,000,000,000,000,000,000 > `long.MaxValue` (9,223,372,036,854,775,807)

**Realistic Scenario:**
This vulnerability represents an operational error rather than a malicious attack. The likelihood is **medium** because:
1. No validation exists on individual allowance amounts
2. No validation exists on the cumulative sum across multiple symbol configurations
3. No UI warnings would alert administrators to potential overflow risks
4. Token amounts typically use large values due to decimal precision (e.g., 1 ELF = 100,000,000 base units)
5. Generous free allowance policies for multiple popular tokens could easily exceed the limit

**Automatic Trigger:**
Once the misconfiguration exists, the vulnerability triggers automatically during normal user operations (submitting any transaction) without requiring specific attacker actions beyond holding the configured tokens.

## Recommendation

Add validation in `ConfigTransactionFeeFreeAllowances` to prevent overflow scenarios:

1. **Per-Symbol Allowance Limits:** Validate that individual allowance amounts are within reasonable bounds (e.g., not exceeding `long.MaxValue / 10`)

2. **Cumulative Sum Validation:** Before storing configurations, calculate the maximum possible sum across all symbols for each fee token and validate it does not exceed `long.MaxValue`

3. **Safe Addition in GetFreeFeeAllowanceAmount:** Replace the `.Add()` method with safe addition that caps at `long.MaxValue` instead of throwing:
   ```csharp
   private long GetFreeFeeAllowanceAmount(TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, string symbol)
   {
       var allowance = 0L;
       var map = transactionFeeFreeAllowancesMap.Map;
       if (map == null) return allowance;
       
       foreach (var freeAllowances in map.Values)
       {
           freeAllowances.Map.TryGetValue(symbol, out var freeAllowance);
           var toAdd = freeAllowance?.Amount ?? 0L;
           
           // Safe addition with overflow protection
           if (toAdd > 0 && allowance > long.MaxValue - toAdd)
           {
               return long.MaxValue; // Cap at maximum instead of throwing
           }
           allowance += toAdd;
       }
       return allowance;
   }
   ```

4. **Configuration Update Validation:** When updating existing configurations, validate that the new configuration combined with existing ones does not create overflow conditions

## Proof of Concept

```csharp
[Fact]
public async Task ConfigTransactionFeeFreeAllowances_Overflow_Causes_DoS()
{
    // Setup: Parliament configures two symbols with large allowances
    const long largeAllowance = 5_000_000_000_000_000_000L; // 5e18
    
    // Configure Symbol1 with large ELF allowance
    await TokenContractStub.ConfigTransactionFeeFreeAllowances.SendAsync(
        new ConfigTransactionFeeFreeAllowancesInput
        {
            Value =
            {
                new ConfigTransactionFeeFreeAllowance
                {
                    Symbol = "SYMBOL1",
                    TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                    {
                        Value = { new TransactionFeeFreeAllowance { Symbol = "ELF", Amount = largeAllowance } }
                    },
                    RefreshSeconds = 86400,
                    Threshold = 1000_00000000
                }
            }
        });
    
    // Configure Symbol2 with large ELF allowance
    await TokenContractStub.ConfigTransactionFeeFreeAllowances.SendAsync(
        new ConfigTransactionFeeFreeAllowancesInput
        {
            Value =
            {
                new ConfigTransactionFeeFreeAllowance
                {
                    Symbol = "SYMBOL2",
                    TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                    {
                        Value = { new TransactionFeeFreeAllowance { Symbol = "ELF", Amount = largeAllowance } }
                    },
                    RefreshSeconds = 86400,
                    Threshold = 1000_00000000
                }
            }
        });
    
    // User receives both SYMBOL1 and SYMBOL2 above threshold
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = UserAddress,
        Symbol = "SYMBOL1",
        Amount = 2000_00000000
    });
    
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = UserAddress,
        Symbol = "SYMBOL2",
        Amount = 2000_00000000
    });
    
    // Attempt to execute any transaction as the user
    // This should fail with OverflowException during fee charging
    var result = await UserTokenContractStub.Transfer.SendWithExceptionAsync(new TransferInput
    {
        To = DefaultAddress,
        Symbol = "ELF",
        Amount = 1
    });
    
    // Verify DoS: Transaction fails due to overflow in allowance calculation
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Overflow");
}
```

## Notes

The vulnerability is valid and affects in-scope production contract code. The execution path is fully traceable from configuration through to the overflow exception. While parliament is considered a trusted role, this represents a mis-scoped privilege issue where parliament can inadvertently cause operational DoS through configuration errors that lack proper validation safeguards. The medium severity rating reflects the significant operational impact tempered by the requirement for governance misconfiguration rather than direct malicious exploitation.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L268-276)
```csharp
    private bool ChargeTransactionFeesToBill(ChargeTransactionFeesInput input, Address fromAddress,
        ref TransactionFeeBill bill,
        ref TransactionFreeFeeAllowanceBill allowanceBill, Dictionary<string, long> fee, bool isSizeFeeFree = false,
        TransactionFeeDelegations delegations = null)
    {
        var successToChargeBaseFee = true;

        SetOrRefreshTransactionFeeFreeAllowances(fromAddress);
        var freeAllowancesMap = CalculateTransactionFeeFreeAllowances(fromAddress);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L747-767)
```csharp
    private bool TryToChargeUserBaseFee(Dictionary<string, long> symbolToAmountMap, Address fromAddress,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, out long amount,
        out string symbolOfValidBalance, out long existingBalance, out long existingAllowance)
    {
        // priority: enough allowance -> symbolWithEnoughBalancePlusAllowance -> symbolWithEnoughBalance -> symbolWithAnything
        symbolOfValidBalance = null;
        string symbolWithAnything = null;
        string symbolWithEnoughBalance = null;
        string symbolWithEnoughBalancePlusAllowance = null;

        amount = 0;
        existingBalance = 0;
        existingAllowance = 0;
        //For user
        //Find the token that satisfies the balance of the fee,if there is no token that satisfies the balance of the fee, find the token that balance > 0
        foreach (var (symbol, value) in symbolToAmountMap)
        {
            // current token symbol
            amount = value;
            existingBalance = GetBalance(fromAddress, symbol);
            existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1241-1242)
```csharp
            Assert(allowances.Threshold >= 0, "Invalid input threshold");
            Assert(allowances.RefreshSeconds >= 0, "Invalid input refresh seconds");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1325-1352)
```csharp
        foreach (var symbol in freeAllowancesConfig.Symbols)
        {
            var balance = State.Balances[input][symbol];
            if (balance < State.TransactionFeeFreeAllowancesConfigMap[symbol].Threshold) continue;

            var lastRefreshTime = State.TransactionFeeFreeAllowancesLastRefreshTimes[input][symbol];

            var freeAllowances = freeAllowanceMap[symbol];

            if (freeAllowances == null)
            {
                transactionFeeFreeAllowancesMap.Map.Add(symbol,
                    State.TransactionFeeFreeAllowancesConfigMap[symbol].FreeAllowances.Clone());
                continue;
            }

            if (lastRefreshTime == null)
            {
                transactionFeeFreeAllowancesMap.Map.Add(symbol, freeAllowances);
            }
            else
            {
                transactionFeeFreeAllowancesMap.Map[symbol] =
                    (Context.CurrentBlockTime - lastRefreshTime).Seconds >
                    State.TransactionFeeFreeAllowancesConfigMap[symbol].RefreshSeconds
                        ? State.TransactionFeeFreeAllowancesConfigMap[symbol].FreeAllowances.Clone()
                        : freeAllowances;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L179-194)
```csharp
    private long GetFreeFeeAllowanceAmount(TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, string symbol)
    {
        var allowance = 0L;
        var map = transactionFeeFreeAllowancesMap.Map;

        if (map == null) return allowance;

        foreach (var freeAllowances in map.Values)
        {
            freeAllowances.Map.TryGetValue(symbol, out var freeAllowance);

            allowance = allowance.Add(freeAllowance?.Amount ?? 0L);
        }

        return allowance;
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/FeeChargePreExecutionPlugin.cs (L33-37)
```csharp
    protected override Transaction GetTransaction(TokenContractImplContainer.TokenContractImplStub tokenStub,
        ChargeTransactionFeesInput chargeTransactionFeesInput)
    {
        return tokenStub.ChargeTransactionFees.GetTransaction(chargeTransactionFeesInput);
    }
```

**File:** protobuf/token_contract_impl.proto (L395-397)
```text
message TransactionFeeFreeAllowancesMap {
    map<string, TransactionFeeFreeAllowanceMap> map = 1;
}
```
