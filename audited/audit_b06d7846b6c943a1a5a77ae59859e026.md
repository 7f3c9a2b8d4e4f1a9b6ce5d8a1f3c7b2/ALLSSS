### Title
Byzantine Fault Tolerance Violation in Last Irreversible Block Height Calculation Due to Insufficient Confirmation Threshold

### Summary
The Last Irreversible Block (LIB) height calculation in `AEDPoSContract_LIB.cs` uses an index selection formula that can result in a block height being marked as irreversible with fewer confirmations than required for Byzantine fault tolerance. When exactly `MinersCountOfConsent` miners participate, the selected LIB may be confirmed by only `(count - floor((count-1)/3))` miners, which is less than the BFT-required `(n - floor((n-1)/3))` miners for certain values of total miners n, allowing potential chain forks.

### Finding Description

The vulnerability exists in the `Deconstruct()` method of `LastIrreversibleBlockHeightCalculator` class. [1](#0-0) 

The threshold `MinersCountOfConsent` is calculated as `floor(n * 2 / 3) + 1` where n is the total number of miners. [2](#0-1) 

While this threshold itself ensures more than 2/3 of miners must participate, the subsequent LIB selection at index `floor((count-1)/3)` creates a secondary issue. When a sorted list of `count` implied irreversible heights is collected, selecting the element at this index means only `(count - floor((count-1)/3))` miners have confirmed that height or higher.

**Root Cause:** The index formula only considers the number of reporting miners (`count`) rather than ensuring the selected height has confirmations from at least `(n - floor((n-1)/3))` miners (the BFT safety requirement).

**Mathematical Proof of Insufficiency:**

For **n=5 total miners**:
- Maximum Byzantine miners: f = floor(4/3) = 1
- BFT requires confirmations from: 5 - 1 = **4 miners**
- MinersCountOfConsent = floor(10/3) + 1 = **4 miners**
- When exactly 4 miners report heights [h₀, h₁, h₂, h₃]:
  - Index selected: floor(3/3) = 1
  - LIB = h₁ (second lowest)
  - Confirmations: 4 - 1 = **3 miners** (only h₁, h₂, h₃)
  - **3 < 4 → Violates BFT safety**

For **n=7 total miners**:
- Maximum Byzantine miners: f = floor(6/3) = 2
- BFT requires confirmations from: 7 - 2 = **5 miners**
- MinersCountOfConsent = floor(14/3) + 1 = **5 miners**
- When exactly 5 miners report heights [h₀, h₁, h₂, h₃, h₄]:
  - Index selected: floor(4/3) = 1
  - LIB = h₁
  - Confirmations: 5 - 1 = **4 miners**
  - **4 < 5 → Violates BFT safety**

The vulnerability affects most values where n ≥ 5 and n is not a multiple of 3.

### Impact Explanation

**Consensus Integrity Violation:** The LIB mechanism is designed to mark blocks as irreversible, preventing chain reorganizations. By allowing a block height to be marked as irreversible with insufficient confirmations, the system violates its Byzantine fault tolerance guarantees.

**Concrete Attack Scenario (n=7 miners):**
1. Two Byzantine miners collude and strategically abstain from mining/reporting in the current round
2. Five honest miners (meeting the minimum threshold) provide implied heights: [100, 200, 300, 400, 500]
3. LIB is set to height 200, confirmed by only 4 miners (57% of total, below the 71.4% BFT requirement)
4. The two Byzantine miners can subsequently create a conflicting fork from height 200 since only 4 out of 7 miners confirmed it as irreversible
5. This breaks the finality guarantee of the LIB mechanism

**Who is Affected:** All participants relying on LIB finality for:
- Cross-chain bridges (accepting transfers based on irreversible blocks)
- Exchanges (crediting deposits after LIB confirmation)
- Smart contracts (making irreversible state changes based on LIB)
- End users (assuming transaction finality)

**Severity Justification:** This is a **HIGH** severity issue (not Medium as initially classified) because it directly undermines the fundamental consensus safety guarantee. Byzantine miners can exploit this to create chain forks, potentially enabling double-spend attacks or invalidating cross-chain operations.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control of up to f = floor((n-1)/3) miners (standard Byzantine assumption)
- Ability to coordinate their mining behavior (abstaining strategically)
- No additional privileges beyond normal miner capabilities

**Attack Complexity:** Low
- The attack simply requires Byzantine miners to not participate in specific rounds
- No complex timing coordination needed beyond normal mining operations
- The vulnerability triggers automatically when exactly MinersCountOfConsent miners participate

**Feasibility Conditions:**
- Network must have n ≥ 5 miners where n is not divisible by 3 (common scenario)
- Exactly MinersCountOfConsent miners must participate (can be influenced by Byzantine miners abstaining)
- Standard network conditions with some miners offline or delayed are natural cover

**Detection Constraints:** 
- Byzantine behavior (not mining) is indistinguishable from honest nodes experiencing network issues or downtime
- The insufficient confirmations are not validated by any check [3](#0-2) 
- No alarms or monitoring for LIB confirmation count violations

**Probability Assessment:** Medium-to-High
- The condition (exactly MinersCountOfConsent participation) occurs naturally during network instability
- Byzantine miners can deliberately create this condition by abstaining
- The larger the miner set, the more opportunities for exploitation

### Recommendation

**Code-Level Mitigation:**

Replace the index selection formula in `AEDPoSContract_LIB.cs` line 32 to ensure BFT-compliant confirmations:

Current (vulnerable):
```
libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**Recommended Fix:**
```csharp
// Calculate index to ensure at least (n - f) confirmations where f = floor((n-1)/3)
// Required confirmations: n - floor((n-1)/3)
// With count heights, to get k confirmations, select index: count - k
var totalMiners = _currentRound.RealTimeMinersInformation.Count;
var maxByzantine = totalMiners.Sub(1).Div(3);
var requiredConfirmations = totalMiners.Sub(maxByzantine);
var selectedIndex = impliedIrreversibleHeights.Count.Sub(requiredConfirmations);

// Safety check: ensure index is non-negative
if (selectedIndex < 0)
{
    libHeight = 0;
    return;
}

libHeight = impliedIrreversibleHeights[selectedIndex];
```

**Invariant Checks to Add:**
1. Assert that the number of confirmations for selected LIB >= (n - floor((n-1)/3))
2. Add validation in `LibInformationValidationProvider` to verify confirmation count meets BFT requirements
3. Add runtime monitoring/logging for LIB confirmation ratios

**Test Cases to Prevent Regression:**
1. Test with n=5 miners, exactly 4 reporting → verify LIB has 4+ confirmations
2. Test with n=7 miners, exactly 5 reporting → verify LIB has 5+ confirmations  
3. Test with n=10 miners, exactly 7 reporting → verify LIB has 7+ confirmations
4. Test Byzantine scenario: (n - f - 1) miners reporting should result in libHeight = 0
5. Fuzz test with various n values and participation rates

### Proof of Concept

**Initial State:**
- Network configured with n=7 miners (common production scenario)
- Current round in progress with all miners scheduled
- Previous round has completed with various implied irreversible heights recorded

**Attack Execution:**

**Step 1:** Byzantine Setup
- Attackers control 2 out of 7 miners (within the f=2 Byzantine tolerance)
- Byzantine miners abstain from mining in the current round

**Step 2:** Honest Miners Participate  
- 5 honest miners successfully mine their blocks
- Each reports their implied irreversible height from previous round: [100, 200, 300, 400, 500]
- These are collected via `GetMinedMiners()` [4](#0-3) 

**Step 3:** LIB Calculation Triggered
- `ProcessUpdateValue` calls `LastIrreversibleBlockHeightCalculator` [5](#0-4) 
- Count = 5 (meets MinersCountOfConsent threshold of 5)
- Heights sorted: [100, 200, 300, 400, 500]
- Index calculation: floor((5-1)/3) = floor(4/3) = 1
- LIB selected: heights[1] = **200**
- Confirmations: 5 - 1 = **4 miners** (miners reporting 200, 300, 400, 500)

**Step 4:** Verify Safety Violation
- **Expected:** LIB should be confirmed by at least 5 miners (n - f = 7 - 2)
- **Actual:** LIB confirmed by only 4 miners (57% of total, below 71.4% BFT requirement)
- **Result:** Height 200 marked as irreversible despite insufficient confirmations

**Step 5:** Exploitation
- Byzantine miners can create conflicting blocks from height 200
- Since only 4 out of 7 miners committed to this height, consensus is not guaranteed
- Potential double-spend or cross-chain attack vector opened

**Success Condition:** The LIB is set to a height with fewer than (n - f) confirmations, violating Byzantine fault tolerance assumptions and enabling potential chain reorganization attacks.

**Notes:**
- The vulnerability is deterministic, not probabilistic - it occurs whenever exactly MinersCountOfConsent miners participate
- The issue compounds in larger networks (n=10, 13, 16, etc.) where the confirmation gap widens
- While `MinersCountOfConsent` correctly requires > 2/3 participation, the index selection doesn't preserve this guarantee for the final confirmation count

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```
