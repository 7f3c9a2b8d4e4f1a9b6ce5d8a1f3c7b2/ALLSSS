### Title
Missing Null Checks in Consensus Validation Causing Unhandled Exceptions and Potential DoS

### Summary
The `ValidatePreviousInValue()` function and related consensus validation methods lack null checks for `extraData.Round` and `PreviousRound.RealTimeMinersInformation`, causing `NullReferenceException` to be thrown instead of returning proper validation failures. A malicious or buggy miner can craft blocks with consensus header information containing null Round fields, causing consensus validation to crash with unhandled exceptions instead of gracefully rejecting invalid blocks, leading to denial-of-service of the block validation pipeline.

### Finding Description

**Root Cause:**
Multiple locations in the consensus validation code access `extraData.Round`, `PreviousRound`, and their `RealTimeMinersInformation` properties without null checks, assuming these objects are always non-null.

**Exact Code Locations with Missing Null Checks:**

1. In `ValidatePreviousInValue()`, line 40 accesses `PreviousRound.RealTimeMinersInformation` without null check: [1](#0-0) 

2. Line 42 accesses `extraData.Round.RealTimeMinersInformation` without null check: [2](#0-1) 

3. Lines 44-45 perform additional accesses without null checks: [3](#0-2) 

4. In `NewConsensusInformationFilled()`, line 30 accesses `ProvidedRound.RealTimeMinersInformation` (which is `extraData.Round`) without null check: [4](#0-3) 

5. In `ValidateBeforeExecution()`, lines 47 and 50 call recovery methods that will throw if `extraData.Round` is null: [5](#0-4) 

6. Line 57 can throw if `TryToGetPreviousRoundInformation` retrieves a null Round from state: [6](#0-5) 

7. The `RecoverFromUpdateValue` method accesses `providedRound.RealTimeMinersInformation` without null check: [7](#0-6) 

**Why Protections Fail:**

The `AEDPoSExtraDataExtractor` only validates that `SenderPubkey` matches but does NOT validate the `Round` field: [8](#0-7) 

In C# protobuf, message type fields (like `Round round = 2;` in the protobuf definition) can be null if not included in serialized data: [9](#0-8) 

When `MappedState` retrieves a non-existent round from state, `SerializationHelper.Deserialize<Round>(null)` returns `default(Round)` which is null for reference types: [10](#0-9) 

The `TryToGetPreviousRoundInformation` method retrieves rounds from state without handling null: [11](#0-10) 

At line 63, accessing `previousRound.IsEmpty` will throw `NullReferenceException` if `previousRound` is null.

### Impact Explanation

**Operational Impact - DoS of Consensus Validation:**
- When validation encounters null Round objects, it throws `NullReferenceException` instead of returning `ValidationResult` with `Success = false`
- This disrupts the block validation pipeline, causing unexpected failures in consensus validation
- Affects all nodes attempting to validate blocks with malformed consensus headers

**Consensus Integrity Impact:**
- The validation is SUPPOSED to gracefully reject invalid blocks by returning proper `ValidationResult`
- Exception-based failures violate this design contract and can cause undefined behavior in the validation pipeline
- May prevent honest nodes from properly validating and accepting legitimate blocks if the validation logic crashes

**Who is Affected:**
- All validator nodes in the network
- Network consensus operations become unstable
- Block propagation and validation can be disrupted

**Severity Justification:**
This is a HIGH severity issue because:
1. Directly impacts consensus validation (critical invariant #2)
2. Can cause DoS of consensus operations
3. Violates fundamental error handling design where validation should return structured results, not throw exceptions
4. Easy to exploit with miner privileges

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker needs to be a miner or compromise a miner node
- While this requires elevated privileges, it's within the realistic threat model for consensus attacks
- Miners are selected from a pool and malicious actors can attempt to become miners

**Attack Complexity:**
- Extremely simple to execute
- Just serialize `AElfConsensusHeaderInformation` protobuf without setting the `Round` field
- No complex sequence or timing requirements
- No need to bypass additional security checks

**Execution Practicality:**
- Fully executable under AElf contract semantics
- The parsing happens at the contract validation level: [12](#0-11) 

**Probability Reasoning:**
- HIGH likelihood because:
  1. No existing guards prevent null Round fields
  2. Simple to craft malformed consensus headers
  3. Will trigger consistently when malformed blocks are submitted
  4. No rate limiting or additional checks prevent this attack

### Recommendation

**Immediate Fix - Add Null Checks:**

1. In `ValidatePreviousInValue()`, add null checks at the beginning:
```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;
    
    // ADD: Null checks
    if (extraData?.Round?.RealTimeMinersInformation == null) return false;
    if (validationContext.PreviousRound?.RealTimeMinersInformation == null) return false;
    
    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;
    // ... rest of method
}
```

2. In `NewConsensusInformationFilled()`, add null check:
```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    // ADD: Null check
    if (validationContext.ProvidedRound?.RealTimeMinersInformation == null) return false;
    
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    // ... rest of method
}
```

3. In `ValidateBeforeExecution()`, add early validation:
```csharp
private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
{
    // ADD: Validate Round field is present
    if (extraData?.Round == null)
        return new ValidationResult { Success = false, Message = "Consensus Round information is missing." };
    
    // According to current round information:
    if (!TryToGetCurrentRoundInformation(out var baseRound))
        return new ValidationResult { Success = false, Message = "Failed to get current round information." };
    // ... rest of method
}
```

4. In `RecoverFromUpdateValue()` and `RecoverFromTinyBlock()`, add null checks at the start.

5. In `TryToGetPreviousRoundInformation()`, handle null round retrieval:
```csharp
private bool TryToGetPreviousRoundInformation(out Round previousRound)
{
    previousRound = new Round();
    if (!TryToGetRoundNumber(out var roundNumber)) return false;
    if (roundNumber < 2) return false;
    var targetRoundNumber = roundNumber.Sub(1);
    previousRound = State.Rounds[targetRoundNumber];
    // ADD: Null check
    if (previousRound == null) 
    {
        previousRound = new Round();
        return false;
    }
    return !previousRound.IsEmpty;
}
```

**Invariant Checks to Add:**
- Assert that `Round` field is non-null in all consensus header validation entry points
- Add validation in `AEDPoSExtraDataExtractor` to check Round field completeness
- Ensure `State.Rounds[i]` accesses are null-checked throughout validation logic

**Test Cases to Prevent Regression:**
1. Test `ValidatePreviousInValue()` with null `extraData.Round`
2. Test `ValidatePreviousInValue()` with null `PreviousRound`
3. Test `ValidatePreviousInValue()` with null `RealTimeMinersInformation` in both Round objects
4. Test `ValidateBeforeExecution()` with `AElfConsensusHeaderInformation` lacking Round field
5. Test round retrieval from state for non-existent rounds
6. Integration test: Submit block with malformed consensus header and verify graceful rejection

### Proof of Concept

**Required Initial State:**
- Consensus contract deployed and active
- At least one miner in the network
- Network at height > 1 (past genesis)

**Attack Sequence:**

1. **Attacker as Miner:** Malicious miner produces a block

2. **Craft Malformed Consensus Header:**
   - Create `AElfConsensusHeaderInformation` protobuf
   - Set `sender_pubkey` field correctly
   - Set `behaviour` field (e.g., `UpdateValue`)
   - **Do NOT set the `round` field** (leave it null)
   - Serialize this malformed header as block's consensus extra data

3. **Submit Block:** Broadcast block to network

4. **Validation Triggered:** Other nodes attempt to validate the block:
   - `ConsensusValidationProvider.ValidateBlockBeforeExecuteAsync()` extracts consensus data
   - Calls `ConsensusService.ValidateConsensusBeforeExecutionAsync()`
   - Contract method `ValidateConsensusBeforeExecution()` is invoked
   - Reaches `ValidateBeforeExecution()` which calls `UpdateValueValidationProvider`

5. **Expected Behavior:** Should return `ValidationResult` with `Success = false` and appropriate error message

6. **Actual Behavior:** Throws `NullReferenceException` when accessing `extraData.Round.RealTimeMinersInformation` at multiple locations, causing validation to fail unexpectedly with unhandled exception instead of graceful rejection

**Success Condition:** 
Block validation fails with exception instead of returning proper validation result, confirming the vulnerability. Network consensus validation is disrupted, demonstrating the DoS impact.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L29-30)
```csharp
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L40-40)
```csharp
        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L42-42)
```csharp
        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L44-45)
```csharp
        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L57-57)
```csharp
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L10-11)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L29-32)
```csharp
        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```

**File:** protobuf/aedpos_contract.proto (L303-310)
```text
message AElfConsensusHeaderInformation {
    // The sender public key.
    bytes sender_pubkey = 1;
    // The round information.
    Round round = 2;
    // The behaviour of consensus.
    AElfConsensusBehaviour behaviour = 3;
}
```

**File:** src/AElf.Types/Helper/SerializationHelper.cs (L88-91)
```csharp
        public static T Deserialize<T>(byte[] bytes)
        {
            if (bytes == null)
                return default;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L56-64)
```csharp
    private bool TryToGetPreviousRoundInformation(out Round previousRound)
    {
        previousRound = new Round();
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        if (roundNumber < 2) return false;
        var targetRoundNumber = roundNumber.Sub(1);
        previousRound = State.Rounds[targetRoundNumber];
        return !previousRound.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-80)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
```
