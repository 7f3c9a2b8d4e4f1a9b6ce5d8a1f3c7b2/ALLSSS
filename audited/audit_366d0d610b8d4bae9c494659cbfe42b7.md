### Title
Unhandled Exception in Consensus Validation Causes Block Validation DoS

### Summary
The `ValidateInformation()` method in the consensus validation service lacks exception handling around provider calls. When validation providers like `UpdateValueValidationProvider` access dictionaries without bounds checking, unhandled exceptions (e.g., `KeyNotFoundException`) propagate through the entire validation chain, crashing block validation and potentially halting consensus.

### Finding Description

The root cause is in the validation service where providers are invoked without exception handling: [1](#0-0) 

The `UpdateValueValidationProvider` performs unsafe dictionary access on the provided round information from potentially malicious block headers: [2](#0-1) 

Additionally, unsafe accesses occur when validating previous in values: [3](#0-2) 

The validation is triggered from the public ACS4 consensus interface: [4](#0-3) 

Which calls into the main validation logic: [5](#0-4) 

The consensus service calls this without exception handling: [6](#0-5) 

And block validation invokes this for every block: [7](#0-6) 

### Impact Explanation

**Operational DoS Impact:**
- Any node receiving a malicious block with crafted header information triggers unhandled `KeyNotFoundException`
- The exception propagates through the validation chain, becoming a `ContractCallException` that crashes block validation
- Without successful block validation, the node cannot process blocks, effectively halting its participation in consensus
- If multiple nodes receive such blocks (e.g., from a malicious miner or during block propagation), the network experiences consensus degradation or halt

**Attack Surface:**
- The `ValidateConsensusBeforeExecution` is a public ACS4 method called for every block before execution
- Block validation occurs in `BlockValidationService` which iterates through all validation providers
- No try-catch exists at any level of this call chain

**Severity:** Critical - Complete block validation failure without proper error handling violates the fundamental consensus integrity requirement.

### Likelihood Explanation

**Attack Feasibility:**
1. **Reachable Entry Point:** Public `ValidateConsensusBeforeExecution` method invoked for every block
2. **Low Complexity:** Attacker only needs to craft a block where:
   - Sender pubkey IS in `BaseRound.RealTimeMinersInformation` (passes `MiningPermissionValidationProvider`)
   - Behaviour is `UpdateValue` (triggers `UpdateValueValidationProvider`)
   - `ProvidedRound.RealTimeMinersInformation` does NOT contain sender's pubkey (triggers `KeyNotFoundException`)
3. **No Special Privileges Required:** Any miner can produce such blocks, or malicious nodes can propagate crafted blocks
4. **Immediate Effect:** Single malformed block triggers the exception on all validating nodes

**Detection Difficulty:** The crash manifests as contract execution failure, which may initially appear as normal validation failures, making the attack subtle until widespread impact occurs.

### Recommendation

**Immediate Fix - Add Exception Handling:**

Wrap the validation loop in `ValidateInformation()` with try-catch:
```csharp
public ValidationResult ValidateInformation(ConsensusValidationContext validationContext)
{
    try
    {
        foreach (var headerInformationValidationProvider in _headerInformationValidationProviders)
        {
            var result = headerInformationValidationProvider.ValidateHeaderInformation(validationContext);
            if (!result.Success) return result;
        }
        return new ValidationResult { Success = true };
    }
    catch (Exception ex)
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = $"Validation exception: {ex.GetType().Name} - {ex.Message}" 
        };
    }
}
```

**Defensive Fix - Safe Dictionary Access:**

In `UpdateValueValidationProvider.NewConsensusInformationFilled()`:
```csharp
if (!validationContext.ProvidedRound.RealTimeMinersInformation.TryGetValue(
    validationContext.SenderPubkey, out var minerInRound))
{
    return false;
}
```

In `UpdateValueValidationProvider.ValidatePreviousInValue()`:
```csharp
if (!extraData.Round.RealTimeMinersInformation.ContainsKey(publicKey))
    return true;
```

**Test Cases:**
1. Block with valid sender but missing from ProvidedRound
2. Block with null round information
3. Block with empty RealTimeMinersInformation dictionary
4. Ensure validation returns proper `ValidationResult` with `Success = false` instead of throwing

### Proof of Concept

**Initial State:**
- Node is validating blocks at height N
- Current round has miner with pubkey "MinerA" in BaseRound

**Attack Sequence:**

1. **Attacker (MinerA) crafts malicious block:**
   - Block header height: N+1
   - Consensus extra data contains:
     - `SenderPubkey`: "MinerA" (valid, exists in BaseRound)
     - `Behaviour`: `AElfConsensusBehaviour.UpdateValue`
     - `Round.RealTimeMinersInformation`: Empty dictionary or missing "MinerA" key

2. **Block propagation:** Malicious block broadcasts to network

3. **Victim node receives block:**
   - `BlockValidationService.ValidateBlockBeforeExecuteAsync()` called
   - `ConsensusValidationProvider.ValidateBlockBeforeExecuteAsync()` invoked
   - `ConsensusService.ValidateConsensusBeforeExecutionAsync()` executes
   - Contract's `ValidateConsensusBeforeExecution()` called

4. **Validation execution:**
   - `MiningPermissionValidationProvider` checks BaseRound - PASSES (MinerA exists)
   - `UpdateValueValidationProvider.ValidateHeaderInformation()` called
   - Line 30: Attempts `ProvidedRound.RealTimeMinersInformation[SenderPubkey]`
   - `KeyNotFoundException` thrown

5. **Exception propagation:**
   - No catch in `ValidateInformation()`
   - No catch in `ValidateBeforeExecution()`
   - No catch in `ValidateConsensusBeforeExecution()`
   - No catch in `ConsensusService.ValidateConsensusBeforeExecutionAsync()`
   - Contract execution fails, throws `ContractCallException`
   - Block validation crashes

**Expected Result:** `ValidationResult` with `Success = false` and descriptive error message

**Actual Result:** Unhandled `KeyNotFoundException` crashes validation process, node cannot validate the block

**Success Condition:** Node fails to validate block and cannot proceed with block execution, effectively experiencing a DoS.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ValidationService.cs (L16-26)
```csharp
    public ValidationResult ValidateInformation(ConsensusValidationContext validationContext)
    {
        foreach (var headerInformationValidationProvider in _headerInformationValidationProviders)
        {
            var result =
                headerInformationValidationProvider.ValidateHeaderInformation(validationContext);
            if (!result.Success) return result;
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L94-103)
```csharp
        var service = new HeaderInformationValidationService(validationProviders);

        Context.LogDebug(() => $"Validating behaviour: {extraData.Behaviour.ToString()}");

        var validationResult = service.ValidateInformation(validationContext);

        if (validationResult.Success == false)
            Context.LogDebug(() => $"Consensus Validation before execution failed : {validationResult.Message}");

        return validationResult;
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L119-149)
```csharp
    public async Task<bool> ValidateConsensusBeforeExecutionAsync(ChainContext chainContext,
        byte[] consensusExtraData)
    {
        var now = TimestampHelper.GetUtcNow();
        _blockTimeProvider.SetBlockTime(now, chainContext.BlockHash);

        var contractReaderContext =
            await _consensusReaderContextService.GetContractReaderContextAsync(chainContext);
        var validationResult = await _contractReaderFactory
            .Create(contractReaderContext)
            .ValidateConsensusBeforeExecution
            .CallAsync(new BytesValue { Value = ByteString.CopyFrom(consensusExtraData) });

        if (validationResult == null)
        {
            Logger.LogDebug("Validation of consensus failed before execution.");
            return false;
        }

        if (!validationResult.Success)
        {
            Logger.LogDebug($"Consensus validating before execution failed: {validationResult.Message}");
            await LocalEventBus.PublishAsync(new ConsensusValidationFailedEventData
            {
                ValidationResultMessage = validationResult.Message,
                IsReTrigger = validationResult.IsReTrigger
            });
        }

        return validationResult.Success;
    }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusValidationProvider.cs (L58-78)
```csharp
    public async Task<bool> ValidateBlockBeforeExecuteAsync(IBlock block)
    {
        if (block.Header.Height == AElfConstants.GenesisBlockHeight)
            return true;

        var consensusExtraData = _consensusExtraDataExtractor.ExtractConsensusExtraData(block.Header);
        if (consensusExtraData == null || consensusExtraData.IsEmpty)
        {
            Logger.LogDebug($"Invalid consensus extra data {block}");
            return false;
        }

        var isValid = await _consensusService.ValidateConsensusBeforeExecutionAsync(new ChainContext
        {
            BlockHash = block.Header.PreviousBlockHash,
            BlockHeight = block.Header.Height - 1
        }, consensusExtraData.ToByteArray());
        if (!isValid) return false;

        return ValidateTransactionCount(block);
    }
```
