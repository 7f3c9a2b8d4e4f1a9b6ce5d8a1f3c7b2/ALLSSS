### Title
First Round Mining Logic Uses Wrong Reference Point, Allowing Unauthorized Block Production

### Summary
The `IsCurrentMiner` function's first round special case logic incorrectly selects the miner with the highest Order number (rather than the chronologically latest miner) as the reference point for time-slot calculations. This allows miners to produce blocks in round 1 when insufficient time has elapsed since the actual last block, enabling unauthorized mining opportunities and extra block rewards.

### Finding Description

The vulnerability exists in the first round special case handling within the `IsCurrentMiner` function. [1](#0-0) 

**Root Cause:**

Line 197 orders miners by their Order field in descending order to find the "latest mined" miner: [2](#0-1) 

This selects the miner with the highest Order number who has mined, NOT the miner who most recently produced a block chronologically. The Order field represents the miner's predetermined sequence position in the round, not their actual mining time. [3](#0-2) 

The Order is assigned deterministically during round generation and cannot be manipulated by miners. [4](#0-3) 

**Why This Matters:**

In round 1, miners can legitimately produce multiple blocks (tiny blocks) within their time slot, with each block adding a timestamp to their `ActualMiningTimes` list. [5](#0-4) 

When calculating `passedSlotsCount`, the code uses the wrong miner's last ActualMiningTime as the reference point: [6](#0-5) 

**Why Protections Fail:**

The first round logic is specifically designed to handle cases where `ExpectedMiningTimes` are unreliable due to misconfigured StartTimestamp. [7](#0-6) 

The normal time-slot validation checks are bypassed in favor of this special first-round calculation, which then uses the flawed reference point selection.

### Impact Explanation

**Direct Harm:**
- Miners can produce blocks in round 1 when they shouldn't be authorized, earning block rewards they don't deserve
- Unauthorized miners can successfully claim transaction fees via `ClaimTransactionFees` [8](#0-7) 
- The `IsCurrentMiner` check is used by MultiToken contract to validate fee claiming permissions [9](#0-8) 

**Affected Parties:**
- Honest miners lose their fair share of round 1 block rewards
- The consensus mechanism's fairness is compromised during every term change
- With 21+ miners and mining intervals of ~4 seconds, extra blocks can be worth significant rewards

**Severity Justification:**
High severity due to concrete fund impact (block rewards and transaction fees) occurring predictably at every term transition, affecting the core consensus reward distribution mechanism.

### Likelihood Explanation

**Attacker Capabilities:**
No special privileges required - any miner in the active set can exploit this naturally or intentionally.

**Attack Complexity:**
Low to Medium. The vulnerability manifests naturally when:
1. Round 1 of any term begins
2. Multiple miners produce blocks (including tiny blocks)
3. A miner with lower Order number produces a block after a miner with higher Order number

**Feasibility Conditions:**
- Occurs at every term change when round 1 begins
- First round logic is active when ExpectedMiningTimes are misconfigured (documented to happen with `Timestamp{Seconds=0}` on AElf Main Chain)
- With 21+ miners and tiny block production, the scenario where highest-Order miner is not chronologically latest occurs frequently

**Detection:**
Difficult to detect as blocks appear valid and the `IsCurrentMiner` function returns true for all validating nodes executing the same flawed logic.

**Probability:**
High - occurs naturally during normal operation of round 1 in each term.

### Recommendation

**Code-Level Mitigation:**

Replace the Order-based selection with chronological selection at line 196-198:

```csharp
var latestMinedInfo =
    currentRound.RealTimeMinersInformation.Values
        .Where(i => i.ActualMiningTimes.Any() && i.Pubkey != pubkey)
        .OrderByDescending(i => i.ActualMiningTimes.Last())
        .FirstOrDefault();
```

This ensures the reference miner is truly the one who most recently produced a block, regardless of their Order number.

**Invariant Check:**
Add assertion that the selected reference miner's last ActualMiningTime is the maximum across all miners who have mined, excluding the current miner.

**Test Cases:**
1. Round 1 scenario where Miner #5 mines, then Miner #1 mines, verify Miner #3 timing calculation uses Miner #1 as reference
2. Round 1 with multiple tiny blocks from different miners in non-Order sequence, verify correct reference point selection
3. Round 1 edge case where all miners have mined, verify wrap-around calculation is correct

### Proof of Concept

**Initial State:**
- Round 1 of new term with 5 miners (Orders 1-5)
- Mining interval = 4000ms
- ExpectedMiningTimes misconfigured (relying on first-round logic)

**Transaction Sequence:**

1. T=1000ms: Miner #5 produces block → `ActualMiningTimes[5] = [1000]`
2. T=2000ms: Miner #5 produces tiny block → `ActualMiningTimes[5] = [1000, 2000]`
3. T=3000ms: Miner #1 produces block → `ActualMiningTimes[1] = [3000]`
4. T=4000ms: Miner #1 produces tiny block → `ActualMiningTimes[1] = [3000, 4000]`
5. T=14000ms: Miner #3 calls `IsCurrentMiner`

**Expected Result (Correct Logic):**
- Reference: Miner #1 at T=4000 (chronologically latest)
- passedSlotsCount = (14000 - 4000) / 4000 = 2
- Required slots from Miner #1 to Miner #3 = 3 - 1 + 5 = 7
- 2 ≠ 7 → **Should return FALSE**

**Actual Result (Buggy Code):**
- Reference: Miner #5 at T=2000 (highest Order who has mined)
- passedSlotsCount = (14000 - 2000) / 4000 = 3
- Required slots from Miner #5 to Miner #3 = 3 - 5 + 5 = 3
- 3 == 3 → **Returns TRUE (INCORRECT)**

**Success Condition:**
Miner #3 successfully produces block at T=14000 and claims rewards, despite insufficient time having passed since the actual last block at T=4000.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L111-118)
```csharp
    public override BoolValue IsCurrentMiner(Address input)
    {
        var pubkey = ConvertAddressToPubkey(input);
        return new BoolValue
        {
            Value = IsCurrentMiner(pubkey)
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L192-216)
```csharp
        if (currentRound.RoundNumber == 1)
        {
            Context.LogDebug(() => "First round");

            var latestMinedInfo =
                currentRound.RealTimeMinersInformation.Values.OrderByDescending(i => i.Order)
                    .FirstOrDefault(i => i.ActualMiningTimes.Any() && i.Pubkey != pubkey);
            if (latestMinedInfo != null)
            {
                var minersCount = currentRound.RealTimeMinersInformation.Count;
                var latestMinedSlotLastActualMiningTime = latestMinedInfo.ActualMiningTimes.Last();
                var latestMinedOrder = latestMinedInfo.Order;
                var currentMinerOrder =
                    currentRound.RealTimeMinersInformation.Single(i => i.Key == pubkey).Value.Order;
                var passedSlotsCount =
                    (Context.CurrentBlockTime - latestMinedSlotLastActualMiningTime).Milliseconds()
                    .Div(miningInterval);
                if (passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(1).Add(minersCount) ||
                    passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(minersCount))
                {
                    Context.LogDebug(() => "[CURRENT MINER]FIRST ROUND");
                    return true;
                }
            }
        }
```

**File:** protobuf/aedpos_contract.proto (L266-292)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-37)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L1-50)
```csharp
using AElf.CSharp.Core;
using AElf.Standards.ACS4;
using Google.Protobuf.WellKnownTypes;

namespace AElf.Contracts.Consensus.AEDPoS;

public partial class AEDPoSContract
{
    /// <summary>
    ///     Basically provides some useful fields for other strategies.
    /// </summary>
    public abstract class CommandStrategyBase : ICommandStrategy
    {
        /// <summary>
        ///     In AElf Main Chain, miner will produce 8 blocks (as fast as possible) during every time slot by default.
        /// </summary>
        private const int TinyBlocksCount = 8;

        /// <summary>
        ///     The minimum interval between two blocks of same time slot.
        /// </summary>
        protected const int TinyBlockMinimumInterval = 50;

        protected readonly Timestamp CurrentBlockTime;
        protected readonly Round CurrentRound;
        protected readonly string Pubkey;

        protected CommandStrategyBase(Round currentRound, string pubkey, Timestamp currentBlockTime)
        {
            CurrentRound = currentRound;
            Pubkey = pubkey;
            CurrentBlockTime = currentBlockTime;
        }

        protected MinerInRound MinerInRound => CurrentRound.RealTimeMinersInformation[Pubkey];
        protected int Order => CurrentRound.GetMiningOrder(Pubkey);
        protected int MiningInterval => CurrentRound.GetMiningInterval();

        /// <summary>
        ///     Producing time of every (tiny) block at most.
        /// </summary>
        private int TinyBlockSlotInterval => MiningInterval.Div(TinyBlocksCount);

        protected int MinersCount => CurrentRound.RealTimeMinersInformation.Count;

        /// <summary>
        ///     Give 3/5 of producing time for mining by default.
        /// </summary>
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/FirstRoundCommandStrategy.cs (L13-20)
```csharp
    /// <summary>
    ///     Why implement a strategy only for first round?
    ///     Because during the first round, the ExpectedMiningTimes of every miner
    ///     depends on the StartTimestamp configured before starting current blockchain,
    ///     (which AElf Main Chain use new Timestamp {Seconds = 0},)
    ///     thus we can't really give mining scheduler these data.
    ///     The ActualMiningTimes will based on Orders of these miners.
    /// </summary>
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L897-906)
```csharp
    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```
