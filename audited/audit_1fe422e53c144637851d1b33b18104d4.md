# Audit Report

## Title
Unvalidated Secret Sharing Reveals Allow Consensus State Corruption and Mining Order Manipulation

## Summary
The AEDPoS consensus contract accepts revealed InValues from block producers without cryptographic verification, allowing malicious miners to inject arbitrary `PreviousInValue` data for miners who missed their time slots. This corrupts consensus state, manipulates mining order calculations, and pollutes randomness generation.

## Finding Description

The vulnerability exists in two parallel code paths that process revealed InValues without cryptographic verification:

**Vulnerable Path 1 - UpdateLatestSecretPieces():**
The function accepts revealed InValues from trigger information and sets them directly into the round state without any cryptographic validation. [1](#0-0)  The only check performed is whether the target miner's `PreviousInValue` field is currently empty or null—no verification that the revealed value is cryptographically correct.

**Vulnerable Path 2 - PerformSecretSharing():**
During UpdateValue transaction processing, this function directly persists the `MinersPreviousInValues` dictionary to chain state without validation. [2](#0-1)  These values originated from the corrupted round state created by UpdateLatestSecretPieces.

**Validation Gap:**
The UpdateValueValidationProvider only validates the sender's own PreviousInValue, not the revealed values for other miners. [3](#0-2)  The validation explicitly checks `validationContext.SenderPubkey` and ignores the `MinersPreviousInValues` dictionary entirely.

**Legitimate Path Comparison:**
The correct implementation exists in `RevealSharedInValues()`, which performs Shamir's Secret Sharing reconstruction using `SecretSharingHelper.DecodeSecret()`. [4](#0-3)  However, this function is only called during NextRound behavior, not during UpdateValue processing.

**Attack Flow:**
1. Attacker modifies their node's `SecretSharingService.GetRevealedInValues()` to return arbitrary fake values for target victims
2. These fake values flow into `AElfConsensusTriggerInformation.RevealedInValues` [5](#0-4) 
3. When attacker produces a block, `UpdateLatestSecretPieces()` sets fake PreviousInValue for victim
4. Transaction validation passes because it only checks attacker's own PreviousInValue
5. Fake values persist to state via `PerformSecretSharing()`
6. During NextRound, `SupplyCurrentRoundInformation()` retrieves the fake PreviousInValue and uses it to calculate victim's signature [6](#0-5) 
7. The fake signature determines victim's mining order via modulo operation [7](#0-6) 

## Impact Explanation

**Consensus Integrity Violation:** The attack directly corrupts on-chain consensus state by setting incorrect `PreviousInValue`, `InValue`, and `Signature` fields for victim miners. The consensus invariant that each miner's signature must derive from their genuine InValue is violated.

**Mining Order Manipulation:** The corrupted signature directly determines the victim's `SupposedOrderOfNextRound` through the formula `GetAbsModulus(signature.ToInt64(), minersCount) + 1`. [7](#0-6)  An attacker can systematically target specific miners to alter when they can produce blocks, potentially gaining unfair advantages or causing victims to miss their slots.

**Randomness Corruption:** Miner signatures contribute to consensus randomness through XOR aggregation. [8](#0-7)  Injecting fake signatures pollutes this randomness source, enabling potential manipulation of round-based randomness used throughout the consensus system.

**State Persistence:** Once a fake `PreviousInValue` is set, the victim cannot correct it until they successfully produce a block with their real value. The fake data propagates through subsequent rounds via `SupplyCurrentRoundInformation()`, which uses the corrupted value to generate incorrect derived fields. [9](#0-8) 

## Likelihood Explanation

**Attacker Profile:** Any authorized miner in the consensus pool can execute this attack by modifying their local node software to return fake values in `GetRevealedInValues()`.

**Attack Complexity:** Low. The attacker only needs to modify their off-chain `SecretSharingService` implementation to return arbitrary values in the `_revealedInValues` dictionary. No cryptographic operations, complex timing, or multi-party coordination is required.

**Preconditions:**
1. Attacker is an active miner in the current round
2. Target victim miner misses their time slot (hasn't produced `OutValue` yet in current round)
3. Attacker produces a block before victim in the same round

**Detection Difficulty:** High. No on-chain validation flags fake revealed values, corrupted state appears as legitimate consensus data, and victims only discover issues when attempting to mine.

**Economic Feasibility:** The attack cost is minimal—only the gas cost of producing a normal block. Potential gains include unfair mining advantages, ability to manipulate specific miners' schedules, and disruption of consensus randomness.

**Operational Constraints:** None. The attack can be executed repeatedly in every round where conditions are met. Since missed time slots occur regularly in distributed networks (network latency, node failures, maintenance), attack opportunities are frequent.

## Recommendation

Implement cryptographic verification of revealed InValues before accepting them into consensus state:

1. **Add validation in UpdateLatestSecretPieces()**: Before setting `PreviousInValue` from `RevealedInValues`, perform Shamir's Secret Sharing reconstruction using the miner's encrypted and decrypted pieces to verify the revealed value is correct.

2. **Validate MinersPreviousInValues in UpdateValueValidationProvider**: Add a validation loop that checks each entry in `input.MinersPreviousInValues` to ensure revealed values match the cryptographic reconstruction from available secret pieces.

3. **Unified validation path**: Consider consolidating the UpdateValue and NextRound revelation paths to use the same cryptographically-verified `RevealSharedInValues()` logic, ensuring all revealed InValues undergo proper Shamir's Secret Sharing reconstruction.

4. **Threshold enforcement**: Only accept revealed InValues when sufficient encrypted pieces (≥ minimum threshold) and decrypted pieces (= miners count) are available for reconstruction, matching the logic in `RevealSharedInValues()`.

## Proof of Concept

A complete proof of concept would require:

1. Deploying a test AEDPoS consensus network with multiple miner nodes
2. Modifying one miner node's `SecretSharingService.GetRevealedInValues()` to return a fake hash for a target miner
3. Having the target miner miss their time slot in round N
4. Having the attacker miner produce a block with UpdateValue behavior in round N
5. Observing that the fake `PreviousInValue` is persisted to the target miner's state
6. Triggering NextRound and observing that `SupplyCurrentRoundInformation()` uses the fake value to calculate an incorrect signature
7. Verifying the target miner receives a manipulated `SupposedOrderOfNextRound` in round N+1

The core vulnerability can be demonstrated by tracing through the consensus transaction generation and validation flow, showing that:
- Trigger information from `AEDPoSTriggerInformationProvider` flows unchecked into `UpdateLatestSecretPieces()`
- `UpdateValueValidationProvider` validates only sender's PreviousInValue, not others
- `PerformSecretSharing()` persists unvalidated `MinersPreviousInValues` to state
- `SupplyCurrentRoundInformation()` trusts the corrupted state to calculate signatures

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L112-114)
```csharp
            var revealedInValues = _secretSharingService.GetRevealedInValues(hint.RoundId);
            foreach (var revealedInValue in revealedInValues)
                trigger.RevealedInValues.Add(revealedInValue.Key, revealedInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L171-220)
```csharp
    private void SupplyCurrentRoundInformation()
    {
        var currentRound = GetCurrentRoundInformation(new Empty());
        Context.LogDebug(() => $"Before supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
        TryToGetPreviousRoundInformation(out var previousRound);
        foreach (var miner in notMinedMiners)
        {
            Context.LogDebug(() => $"Miner pubkey {miner.Pubkey}");

            Hash previousInValue = null;
            Hash signature = null;

            // Normal situation: previous round information exists and contains this miner.
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }

            // Fill this two fields at last.
            miner.InValue = previousInValue;
            miner.Signature = signature;

            currentRound.RealTimeMinersInformation[miner.Pubkey] = miner;
        }

        TryToUpdateRoundInformation(currentRound);
        Context.LogDebug(() => $"After supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-114)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
```
