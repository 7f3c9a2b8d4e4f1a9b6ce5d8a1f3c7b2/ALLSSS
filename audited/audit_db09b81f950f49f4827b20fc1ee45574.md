# Audit Report

## Title
Continuous Blocks Validation Bypass via ProvidedRound Manipulation in UpdateValue/TinyBlock Behaviors

## Summary
A malicious miner can bypass the continuous blocks validation by providing a fake `ProvidedRound` with `RoundNumber ≤ 2` in the consensus header extra data when submitting `UpdateValue` or `TinyBlock` transactions. This allows unlimited consecutive block production, violating consensus fairness guarantees and enabling potential chain monopolization.

## Finding Description

The AElf consensus contract enforces a continuous blocks limit to prevent any single miner from monopolizing block production. However, this validation can be bypassed for `UpdateValue` and `TinyBlock` behaviors through manipulation of the `ProvidedRound.RoundNumber` field.

**Root Cause:**

The `ContinuousBlocksValidationProvider` checks whether a miner has produced too many consecutive blocks, but only applies this check when `ProvidedRound.RoundNumber > 2`: [1](#0-0) 

The `ProvidedRound` comes directly from the consensus header extra data and is defined as a property that returns `ExtraData.Round`: [2](#0-1) 

For `UpdateValue` and `TinyBlock` behaviors, the validation flow applies only basic validation providers and does NOT include `RoundTerminateValidationProvider`, which is responsible for validating round number transitions: [3](#0-2) 

The `RoundTerminateValidationProvider` validates that round numbers increment correctly, but it's only applied to `NextRound` and `NextTerm` behaviors: [4](#0-3) 

**Why the Attack Works:**

When `BaseRound` is recovered from `ProvidedRound` for `UpdateValue` and `TinyBlock`, only specific fields are copied (OutValue, Signature, ActualMiningTimes), but NOT the `RoundNumber` field: [5](#0-4) 

The `TimeSlotValidationProvider` compares `RoundId` (not `RoundNumber`) to determine if it's a new round: [6](#0-5) 

Since `RoundId` is calculated as the sum of miners' `ExpectedMiningTime.Seconds`: [7](#0-6) 

An attacker can craft a fake `Round` structure where:
- `RoundNumber` is set to 2 (or 1) to bypass the continuous blocks check
- All `ExpectedMiningTime` values remain identical to the current round
- `RoundId` remains the same (since it depends on `ExpectedMiningTime`, not `RoundNumber`)

**Attack Execution:**

1. Malicious miner exceeds the continuous blocks limit (8 blocks based on `MaximumTinyBlocksCount`)
2. `LatestPubkeyToTinyBlocksCount.BlocksCount` becomes negative
3. Instead of being forced to produce a `NextRound` transaction, the miner:
   - Queries current round information (e.g., Round 100)
   - Copies the entire `Round` structure
   - Changes only `RoundNumber` from 100 to 2
   - Includes this fake round in consensus header extra data
4. During validation:
   - `ContinuousBlocksValidationProvider` checks `ProvidedRound.RoundNumber > 2` → FALSE
   - The continuous blocks validation is skipped
   - No other validator catches this discrepancy for `UpdateValue`/`TinyBlock`
5. The miner successfully produces another consecutive block, bypassing the limit

While `State.CurrentRoundNumber` is protected by strict increment-by-1 validation: [8](#0-7) 

This protection only applies to state storage, not to the untrusted `ProvidedRound` data used for validation decisions. The header extraction only validates that the sender's public key matches the block signer: [9](#0-8) 

## Impact Explanation

**Severity: Critical**

This vulnerability undermines the core fairness mechanism of the AEDPoS consensus protocol. The continuous blocks validation exists specifically to prevent any single miner from monopolizing block production, which is fundamental to maintaining decentralization and ensuring fair participation.

By bypassing this check, a malicious miner can:

1. **Monopolize Block Production**: Produce unlimited consecutive tiny blocks during their time slot, effectively taking control of the chain
2. **Exclude Honest Miners**: Prevent other miners from participating in block production and earning rewards
3. **Violate Consensus Guarantees**: Break the AEDPoS consensus fairness rules that limit consecutive block production to 8 blocks: [10](#0-9) 

4. **Reduce Decentralization**: Concentrate block production power in the hands of malicious miners
5. **Impact Chain Liveness**: If the malicious miner becomes dominant, overall network health and liveness may be compromised

The continuous blocks counter is managed through state tracking: [11](#0-10) 

This tracking mechanism becomes ineffective when the validation check is bypassed.

## Likelihood Explanation

**Probability: HIGH**

The likelihood of exploitation is high because:

1. **Low Attacker Requirements**: Any active miner in the current round can exploit this vulnerability. Miners are legitimate network participants with normal mining privileges.

2. **Simple Attack Complexity**: The attack only requires:
   - Querying current round information (public view method)
   - Copying the round structure
   - Modifying a single field (`RoundNumber`)
   - No special cryptographic operations or state manipulation needed

3. **Consistent Exploitability**: The vulnerability can be exploited repeatedly on every block the malicious miner produces after exceeding the limit.

4. **No Additional Prerequisites**: No governance actions, special permissions, or complex state setup required beyond being an active miner.

5. **Difficult Detection**: The attack is subtle because:
   - The fake `ProvidedRound` is only used for validation
   - Actual state updates use the correct `BaseRound` from storage
   - State integrity appears maintained while validation is bypassed

The validation flow clearly shows that state updates use the correct round information: [12](#0-11) 

This means the chain state remains consistent while the security check is bypassed, making the attack hard to detect through state inspection alone.

## Recommendation

Add `RoundTerminateValidationProvider` to the validation provider list for `UpdateValue` and `TinyBlock` behaviors, or implement a dedicated round number validation check for these behaviors.

**Option 1: Apply RoundTerminateValidationProvider to all behaviors**

Modify the validation flow to include round number validation for `UpdateValue` and `TinyBlock`:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        validationProviders.Add(new RoundNumberValidationProvider()); // NEW
        break;
    case AElfConsensusBehaviour.TinyBlock:
        validationProviders.Add(new RoundNumberValidationProvider()); // NEW
        break;
    // ... rest of cases
}
```

**Option 2: Validate ProvidedRound.RoundNumber in ContinuousBlocksValidationProvider**

Modify `ContinuousBlocksValidationProvider` to validate that `ProvidedRound.RoundNumber` matches the current round:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    // Validate that ProvidedRound.RoundNumber matches current state
    if (validationContext.ProvidedRound.RoundNumber != validationContext.CurrentRoundNumber &&
        validationContext.ProvidedRound.RoundId == validationContext.BaseRound.RoundId)
    {
        validationResult.Message = "ProvidedRound.RoundNumber does not match current round number.";
        return validationResult;
    }

    if (validationContext.ProvidedRound.RoundNumber > 2 &&
        validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
    {
        // ... existing validation logic
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

**Option 3: Use BaseRound.RoundNumber instead of ProvidedRound.RoundNumber**

The most secure fix is to use `BaseRound.RoundNumber` (from verified state) instead of `ProvidedRound.RoundNumber` (from untrusted input) for the continuous blocks check.

## Proof of Concept

```csharp
[Fact]
public async Task ContinuousBlocksValidationBypass_Test()
{
    // Setup: Initialize consensus with multiple miners
    var initialMiners = await InitializeConsensusWithMiners(3);
    var maliciousMiner = initialMiners[0];
    
    // Step 1: Malicious miner produces 8 consecutive blocks (reaching the limit)
    for (int i = 0; i < 8; i++)
    {
        await ProduceBlockAsync(maliciousMiner, AElfConsensusBehaviour.TinyBlock);
    }
    
    // Verify that LatestPubkeyToTinyBlocksCount.BlocksCount is negative
    var latestCount = await GetLatestPubkeyToTinyBlocksCount();
    Assert.True(latestCount.BlocksCount < 0);
    
    // Step 2: Query current round information (e.g., Round 100)
    var currentRound = await GetCurrentRoundInformation();
    Assert.True(currentRound.RoundNumber > 2); // e.g., 100
    
    // Step 3: Craft fake round with RoundNumber = 2
    var fakeRound = currentRound.Clone();
    fakeRound.RoundNumber = 2; // Fake round number to bypass check
    // All other fields (especially ExpectedMiningTime) remain identical
    
    // Step 4: Create consensus header with fake round
    var fakeHeaderInfo = new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteString.CopyFrom(maliciousMiner.PublicKey),
        Round = fakeRound,
        Behaviour = AElfConsensusBehaviour.TinyBlock
    };
    
    // Step 5: Attempt to produce another consecutive block (9th block)
    var validationResult = await ValidateConsensusBeforeExecution(fakeHeaderInfo);
    
    // VULNERABILITY: Validation should fail but passes due to bypass
    Assert.True(validationResult.Success); // Should be FALSE but is TRUE
    
    // The malicious miner successfully bypasses the continuous blocks limit
    var blockResult = await ProduceBlockWithCustomHeader(maliciousMiner, fakeHeaderInfo);
    Assert.True(blockResult.Success);
    
    // Verify that state integrity is maintained (BaseRound has correct RoundNumber)
    var stateRound = await GetCurrentRoundInformation();
    Assert.Equal(currentRound.RoundNumber, stateRound.RoundNumber); // Still 100
    
    // But validation was bypassed, allowing unlimited consecutive blocks
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-14)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-30)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-14)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L91-97)
```csharp
    private bool TryToUpdateRoundNumber(long roundNumber)
    {
        var oldRoundNumber = State.CurrentRoundNumber.Value;
        if (roundNumber != 1 && oldRoundNumber + 1 != roundNumber) return false;
        State.CurrentRoundNumber.Value = roundNumber;
        return true;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L29-32)
```csharp
        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-252)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```
