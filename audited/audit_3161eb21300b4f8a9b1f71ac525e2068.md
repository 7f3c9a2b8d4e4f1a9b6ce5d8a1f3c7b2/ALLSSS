### Title
Minority Miner Coalition Can Permanently Deadlock Parliament Governance Through Rejection Threshold Exploit

### Summary
The default Parliament organization uses a 20% rejection threshold, allowing just 21% of miners (4 out of 17 on mainnet) to permanently veto all proposals by voting reject. This creates an unbreakable governance deadlock where critical system upgrades, security patches, and economic parameter changes cannot be executed, with no escape mechanism available.

### Finding Description

The vulnerability exists in the Parliament contract's proposal release validation logic. The default organization is initialized with `MaximalRejectionThreshold = 2000` (20% out of 10000). [1](#0-0) 

When a proposal is evaluated for release, the `IsProposalRejected` method checks if rejection votes exceed the threshold: `rejectionMemberCount * AbstractVoteTotal > organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count`. [2](#0-1) 

The critical flaw is in `IsReleaseThresholdReached`, which immediately returns false if a proposal is rejected, preventing release regardless of approval count. [3](#0-2) 

Parliament members (miners) can vote to reject proposals through the public `Reject` method. [4](#0-3) 

The `Release` method requires `IsReleaseThresholdReached` to return true before executing proposals. [5](#0-4) 

**Why Protections Fail:**

The only mechanism to change thresholds is `ChangeOrganizationThreshold`, which requires `Context.Sender` to equal the organization address itself. [6](#0-5) 

This creates a circular dependency: to fix the threshold, a proposal must be created, approved, and released through the same organization—but if 21% of miners reject all proposals, nothing can be released, including the fix itself.

Mainnet starts with 17 production nodes, increasing by 2 annually. [7](#0-6) 

With 17 miners, the math is: `rejectionCount * 10000 > 2000 * 17` → `rejectionCount > 3.4`. Therefore, 4 miners (23.5%) can block all proposals.

### Impact Explanation

**Complete Governance Shutdown:**
The default Parliament organization controls critical system operations including contract deployment controllers, method fee controllers, and economic parameters. [8](#0-7) 

If a minority coalition consistently rejects all proposals:
- **Security patches cannot be deployed** - contract upgrades blocked
- **Economic parameter adjustments fail** - cannot respond to market conditions
- **System configuration updates prevented** - method fees, thresholds frozen
- **Emergency responses ineffective** - even critical fixes cannot pass

The default organization is initialized during Parliament contract initialization and becomes the authority for system-level governance. [9](#0-8) 

**Permanent and Unrecoverable:**
The validation logic ensures thresholds comply with mathematical constraints but provides no upper bound enforcement on rejection thresholds to prevent minority veto scenarios. [10](#0-9) 

The EmergencyResponseOrganization exists but only authorizes specific election operations, not threshold modifications. [11](#0-10) 

### Likelihood Explanation

**Attacker Capabilities:**
Requires controlling 4 out of 17 miners (23.5%) to consistently vote reject on all proposals. This is achievable through:
- Adversarial miner coalition with aligned incentives
- Economic bribes or external pressure on minority miners
- Compromise of minority mining infrastructure

**Attack Complexity:**
Extremely simple - attackers only need to call the public `Reject` method on every new proposal. The test suite demonstrates this mechanism works as designed. [12](#0-11) 

**Feasibility Conditions:**
- Requires ongoing coordination among minority miners
- Attack is immediately detectable but unstoppable
- No economic cost beyond transaction fees for rejection votes
- Benefits from any governance-related disputes or conflicts

**Detection/Operational Constraints:**
While the attack is visible on-chain, there is no technical mitigation available once initiated. The protocol cannot forcibly remove malicious miners mid-term, and cannot bypass the threshold check.

### Recommendation

**Immediate Fix:**
1. Reduce `DefaultOrganizationMaximalRejectionThreshold` from 2000 to a value that requires true majority opposition (e.g., 4001 for >40% threshold)
2. Add validation in the `Validate` method to enforce: `MaximalRejectionThreshold + MinimalApprovalThreshold > AbstractVoteTotal` to prevent minority veto scenarios

**Long-term Improvements:**
1. Implement an emergency governance bypass mechanism requiring supermajority (>90%) of historical good-faith participants
2. Add time-weighted reputation system where consistent rejection behavior triggers automatic review
3. Create proposal priority levels where critical security patches require lower rejection thresholds

**Test Cases:**
1. Verify minority coalition (21-49%) cannot block proposals with majority approval
2. Test that threshold change proposals can be executed even under adversarial voting patterns
3. Validate emergency procedures work when normal governance is compromised

### Proof of Concept

**Initial State:**
- Mainnet running with 17 miners
- Default Parliament organization controlling system governance
- MaximalRejectionThreshold = 2000 (20%)

**Attack Sequence:**

1. **Coalition Formation:** 4 miners out of 17 (23.5%) form adversarial coalition

2. **Proposal Creation:** Legitimate proposer creates critical security patch proposal
   - Calls `CreateProposal` with system upgrade parameters

3. **Majority Approval:** 13 miners approve (76.5% approval, exceeds 66.67% threshold)
   - Each calls `Approve` method on proposal

4. **Minority Rejection:** 4 coalition miners reject
   - Each calls `Reject` method on proposal  
   - Rejection count: 4/17 = 23.5% > 20% threshold

5. **Release Attempt Fails:** 
   - `IsProposalRejected` returns true (4 * 10000 = 40000 > 2000 * 17 = 34000)
   - `IsReleaseThresholdReached` returns false due to rejection
   - `Release` method fails with "Not approved" assertion

6. **Governance Deadlock:**
   - Repeat steps 2-5 for ALL subsequent proposals
   - Including proposals to fix the threshold itself
   - System governance permanently frozen

**Expected vs Actual Result:**
- **Expected:** Proposals with 76.5% approval should pass
- **Actual:** Proposals blocked by 23.5% minority veto
- **Success Condition:** All proposals fail release, governance completely halted

**Notes**

This vulnerability represents a critical flaw in the game-theoretic design of the governance system. While the 20% rejection threshold may have been intended to give minorities a voice, it inadvertently grants them absolute veto power. The circular dependency in threshold modification creates a governance trap with no exit strategy once triggered.

The issue is particularly severe because the default Parliament organization controls system-critical operations, making this not just a governance inconvenience but a potential system-wide freeze scenario. Any significant political or economic disagreement among miners could trigger this attack, either intentionally or as a negotiation tactic.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L7-7)
```csharp
    private const int DefaultOrganizationMaximalRejectionThreshold = 2000;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-70)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L314-330)
```csharp
    private void CreateEmergencyResponseOrganization()
    {
        var createOrganizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 9000,
                MinimalVoteThreshold = 9000,
                MaximalAbstentionThreshold = 1000,
                MaximalRejectionThreshold = 1000
            },
            ProposerAuthorityRequired = false,
            ParliamentMemberProposingAllowed = true
        };

        State.EmergencyResponseOrganizationAddress.Value = CreateOrganization(createOrganizationInput);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L11-37)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        var proposerWhiteList = new ProposerWhiteList();

        if (input.PrivilegedProposer != null)
            proposerWhiteList.Proposers.Add(input.PrivilegedProposer);

        State.ProposerWhiteList.Value = proposerWhiteList;
        var organizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = DefaultOrganizationMinimalApprovalThreshold,
                MinimalVoteThreshold = DefaultOrganizationMinimalVoteThresholdThreshold,
                MaximalAbstentionThreshold = DefaultOrganizationMaximalAbstentionThreshold,
                MaximalRejectionThreshold = DefaultOrganizationMaximalRejectionThreshold
            },
            ProposerAuthorityRequired = input.ProposerAuthorityRequired,
            ParliamentMemberProposingAllowed = true
        };
        var defaultOrganizationAddress = CreateNewOrganization(organizationInput);
        State.DefaultOrganizationAddress.Value = defaultOrganizationAddress;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L96-112)
```csharp
    public override Empty Reject(Hash input)
    {
        var parliamentMemberAddress = GetAndCheckActualParliamentMemberAddress();
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedByMember(proposal, parliamentMemberAddress);
        proposal.Rejections.Add(parliamentMemberAddress);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = parliamentMemberAddress,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Reject),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L147-160)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** docs/public-chain/introduction.md (L11-11)
```markdown
Any node can apply to become a production node, and the first 17 candidates are chosen. Once a node is elected, it will participate in the production of blocks according to the consensus rules and, at the same time, obtains the block rewards.
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L66-74)
```csharp
    public override AuthorityInfo GetContractDeploymentController(Empty input)
    {
        return State.ContractDeploymentController.Value;
    }

    public override AuthorityInfo GetCodeCheckController(Empty input)
    {
        return State.CodeCheckController.Value;
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L588-607)
```csharp
            // Rejection probability > maximalRejectionThreshold
            {
                var proposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
                await TransferToOrganizationAddressAsync(organizationAddress);
                //Voted reviewer is not enough
                await ApproveAsync(InitialMinersKeyPairs[0], proposalId);
                ParliamentContractStub = GetParliamentContractTester(DefaultSenderKeyPair);
                var proposal = await ParliamentContractStub.GetProposal.CallAsync(proposalId);
                proposal.ToBeReleased.ShouldBeFalse();
                //Approve probability > minimalApprovalThreshold
                await ApproveAsync(InitialMinersKeyPairs[1], proposalId);
                ParliamentContractStub = GetParliamentContractTester(DefaultSenderKeyPair);
                proposal = await ParliamentContractStub.GetProposal.CallAsync(proposalId);
                proposal.ToBeReleased.ShouldBeTrue();
                //Rejection probability > maximalRejectionThreshold
                await RejectionAsync(InitialMinersKeyPairs[2], proposalId);
                ParliamentContractStub = GetParliamentContractTester(DefaultSenderKeyPair);
                proposal = await ParliamentContractStub.GetProposal.CallAsync(proposalId);
                proposal.ToBeReleased.ShouldBeFalse();
            }
```
