# Audit Report

## Title
Unbounded Proposal Expiration Time Enables Permanent Storage Lock in Governance Contracts

## Summary
The Association, Parliament, and Referendum contracts accept user-provided `ExpiredTime` values without enforcing maximum bounds, allowing whitelisted proposers to create proposals with expiration dates up to year 9999. Since the `ClearProposal` cleanup mechanism requires the current time to exceed the expiration time, these proposals cannot be removed from storage for thousands of years, enabling permanent storage bloat attacks.

## Finding Description

The vulnerability exists in the proposal validation logic across all three governance contracts. When a proposal is created, the `ExpiredTime` field is validated only to ensure it's non-null and in the future, with no upper bound check. [1](#0-0) 

The validation only checks that `Context.CurrentBlockTime < proposal.ExpiredTime`, allowing any future timestamp. The `ExpiredTime` is taken directly from user input without sanitization: [2](#0-1) 

The maximum Timestamp value in the AElf system is 253402300799 seconds, corresponding to December 31, 9999: [3](#0-2) 

The cleanup mechanism explicitly requires the proposal to be expired before removal: [4](#0-3) 

This enforcement at line 286 prevents cleanup of proposals with far-future expiration times. Proposals are stored in an unbounded `MappedState` structure: [5](#0-4) 

The same vulnerability pattern exists in Parliament and Referendum contracts with identical validation logic: [6](#0-5) [7](#0-6) 

Both contracts have the same cleanup requirement: [8](#0-7) [9](#0-8) 

## Impact Explanation

An attacker with ProposerWhiteList membership can create proposals with `ExpiredTime` set to year 9999 (timestamp 253402300799), causing:

1. **Permanent Storage Consumption**: Each `ProposalInfo` object occupies storage containing addresses, parameters, title, description, and vote tracking lists. These proposals cannot be cleaned up until year 9999 (approximately 8,000 years from now).

2. **Unbounded Storage Growth**: There are no limits on the number of proposals a whitelisted proposer can create. By repeatedly calling `CreateProposal` with maximum expiration times, an attacker can continuously inflate storage.

3. **Organization-Specific Impact**: The attack affects the targeted organization's proposal storage in the `State.Proposals` mapping. While other organizations remain unaffected, the victim organization experiences degraded performance and increased operational costs.

4. **Economic Griefing**: The attack cost is limited to transaction fees, making it economically feasible as a griefing vector against specific governance organizations.

The severity is **Medium** because while the impact is real and permanent, it:
- Does not enable fund theft or unauthorized execution
- Requires ProposerWhiteList membership (partial trust assumption)
- Affects specific organizations rather than the entire protocol
- Does not compromise consensus or cross-chain integrity

## Likelihood Explanation

**Attacker Capabilities Required:**
- Membership in an organization's ProposerWhiteList
- This is a partially trusted role but can be compromised through account hacking or malicious insiders

**Attack Complexity:**
- Low - simply call `CreateProposal` with `ExpiredTime.Seconds = 253402300799L`
- No complex transaction sequences or timing requirements needed
- Can be repeated arbitrarily to create multiple locked proposals

**Feasibility Conditions:**
- The `CreateProposal` function is publicly accessible with only whitelist authorization
- Transaction fees provide minimal economic deterrent
- ProposerWhiteList members may have legitimate reasons to be in the list but could act maliciously or be compromised

**Detection Constraints:**
- Proposals with far-future expiration times are valid according to current contract logic
- No monitoring or alerting mechanisms exist for abnormal expiration time values
- The attack would only become apparent when storage costs become burdensome

The likelihood is **Realistic** because ProposerWhiteList compromise scenarios (stolen keys, malicious insiders, or social engineering) are practical threat vectors in decentralized governance systems.

## Recommendation

Implement a maximum bound check on `ExpiredTime` during proposal validation. Add a constant defining the maximum allowed proposal lifetime (e.g., 1-2 years) and validate that:

```csharp
private const long MaxProposalLifetimeSeconds = 63072000; // 2 years

private bool Validate(ProposalInfo proposal)
{
    if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
        !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
        return false;

    if (proposal.ExpiredTime == null || Context.CurrentBlockTime >= proposal.ExpiredTime)
        return false;
    
    // Add maximum bound check
    var maxAllowedTime = Context.CurrentBlockTime.AddSeconds(MaxProposalLifetimeSeconds);
    if (proposal.ExpiredTime > maxAllowedTime)
        return false;

    return true;
}
```

Apply this fix to all three contracts: Association, Parliament, and Referendum.

## Proof of Concept

```csharp
[Fact]
public async Task CreateProposal_WithFarFutureExpiration_LocksStoragePermanently()
{
    // Setup: Create organization and whitelist attacker
    var attacker = SampleAccount.Accounts.First();
    var organizationAddress = await CreateOrganizationAsync();
    
    // Create proposal with year 9999 expiration
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress,
        ContractMethodName = "SomeMethod",
        ToAddress = TokenContractAddress,
        ExpiredTime = new Timestamp { Seconds = 253402300799L }, // Year 9999
        Params = ByteString.Empty,
        Title = "Malicious Proposal",
        Description = "Storage lock attack"
    };
    
    var proposalId = await AssociationContractStub.CreateProposal.SendAsync(proposalInput);
    proposalId.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify proposal was created
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId.Output);
    proposal.ExpiredTime.Seconds.ShouldBe(253402300799L);
    
    // Attempt to clear proposal - should fail because not expired
    var clearResult = await AssociationContractStub.ClearProposal.SendAsync(proposalId.Output);
    clearResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    clearResult.TransactionResult.Error.ShouldContain("Proposal clear failed");
    
    // Proposal remains in storage indefinitely
    var stillExists = await AssociationContractStub.GetProposal.CallAsync(proposalId.Output);
    stillExists.ProposalId.ShouldBe(proposalId.Output);
}
```

## Notes

This vulnerability affects all three governance contract types (Association, Parliament, Referendum) with identical root causes. While ProposerWhiteList membership is required, this represents a realistic attack vector since these lists often include external parties who may be compromised or act maliciously. The permanent nature of the storage lock (8000 years) makes this a genuine DoS/griefing vulnerability despite not directly compromising funds or authorization.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L145-173)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId,
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Election/TimestampHelper.cs (L12-15)
```csharp
    /// <summary>
    ///     9999-12-31T23:59:59.999999999Z
    /// </summary>
    public static Timestamp MaxValue => new() { Nanos = 999999999, Seconds = 253402300799L };
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/AssociationState.cs (L7-13)
```csharp
public partial class AssociationState : ContractState
{
    public MappedState<Address, Organization> Organizations { get; set; }
    public MappedState<Hash, ProposalInfo> Proposals { get; set; }
    public MappedState<string, MethodFees> TransactionFees { get; set; }
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
}
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L177-180)
```csharp
    private bool CheckProposalNotExpired(ProposalInfo proposal)
    {
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L179-186)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L154-161)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```
