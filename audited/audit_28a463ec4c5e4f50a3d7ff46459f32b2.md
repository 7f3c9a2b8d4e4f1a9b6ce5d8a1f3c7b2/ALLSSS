# Audit Report

## Title
Removed Proposers Can Still Release Approved Proposals Due to Missing Whitelist Validation in Release Function

## Summary
The Referendum, Association, and Parliament governance contracts enforce proposer whitelist validation during proposal creation but fail to re-validate whitelist membership during proposal release. This allows proposers who have been removed from the whitelist to execute their previously approved proposals, bypassing the organization's intent to revoke governance privileges.

## Finding Description

This vulnerability exists across all three AElf governance contracts and stems from incomplete authorization checks throughout the proposal lifecycle.

**Referendum Contract Vulnerability:**

During proposal creation, `CreateProposal` enforces whitelist validation: [1](#0-0) 

The whitelist check is implemented in `AssertIsAuthorizedProposer`: [2](#0-1) 

The `Contains` extension method validates whitelist membership: [3](#0-2) 

However, the `Release` function only checks that the caller is the original proposer and does NOT re-validate whitelist membership: [4](#0-3) 

Organizations can modify whitelists at any time: [5](#0-4) 

**Association Contract Has Identical Vulnerability:**

Whitelist checked during creation: [6](#0-5) 

Whitelist validation in helper: [7](#0-6) 

Release function missing whitelist check: [8](#0-7) 

Whitelist can be modified: [9](#0-8) 

**Parliament Contract Has Identical Vulnerability:**

Whitelist checked during creation: [10](#0-9) 

Whitelist validation in helper: [11](#0-10) 

Release function missing whitelist check: [12](#0-11) 

**Attack Scenario:**

1. Attacker is initially in the proposer whitelist (legitimate access)
2. Attacker creates proposal via `CreateProposal` (passes whitelist check)
3. Organization members approve the proposal (reaches threshold)
4. Organization removes attacker from whitelist via `ChangeOrganizationProposerWhiteList` due to suspicious behavior
5. Attacker calls `Release` with their approved proposal
6. Release succeeds because it only checks `Context.Sender.Equals(proposal.Proposer)`, not current whitelist status
7. Arbitrary contract method executes with organization authority via `SendVirtualInlineBySystemContract`

## Impact Explanation

**Authorization Bypass & Governance Violation:**

1. **Trust Revocation Ineffective**: When an organization removes a proposer from the whitelist, they explicitly signal loss of trust. However, the removed proposer retains execution rights for all approved proposals.

2. **Unauthorized Operations**: Removed proposers can execute arbitrary contract methods with organization authority, including:
   - Token transfers from organization addresses
   - Contract upgrades and configuration changes
   - Treasury fund releases
   - Authority modifications
   - Any other privileged operations the organization can perform

3. **Malicious Insider Attack Window**: A bad actor can:
   - Create multiple benign-looking proposals while authorized
   - Wait for approval through normal governance
   - Get removed from whitelist after detection
   - Execute all approved proposals post-removal

4. **No Direct Mitigation**: Organizations cannot directly revoke release permission. They must either:
   - Actively coordinate to reject proposals (difficult)
   - Wait for proposal expiration (may be too late)
   - Watch removed proposers continuously

This violates the critical security invariant that authorization checks must be enforced consistently throughout the governance lifecycle.

## Likelihood Explanation

**Attack is Highly Feasible:**

1. **Public Entry Point**: `Release` is a public method callable by anyone. The only authorization is matching the stored proposer address.

2. **Realistic Preconditions**:
   - Attacker needs initial whitelist access (legitimate starting point)
   - Must create proposals while authorized (normal operation)
   - Proposals must be approved (standard governance flow)
   - Removal from whitelist occurs (realistic trust loss scenario)

3. **Low Attack Cost**: Only requires standard transaction fees.

4. **High Attack Value**: Can execute privileged operations with organization authority.

5. **Detection Window**: Time gap between approval and removal provides exploitation opportunity, especially in high-activity organizations.

The likelihood is **MEDIUM-to-HIGH** because proposal approval is a normal governance operation, and the window between approval and potential removal creates a realistic exploitation scenario.

## Recommendation

Add whitelist validation to the `Release` function in all three governance contracts. The fix should re-check that the proposer is still in the whitelist at release time:

**For Referendum Contract:**
```csharp
public override Empty Release(Hash input)
{
    var proposal = GetValidProposal(input);
    Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
    
    // Add this whitelist re-validation
    AssertIsAuthorizedProposer(proposal.OrganizationAddress, proposal.Proposer);
    
    var organization = State.Organizations[proposal.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
    Context.SendVirtualInlineBySystemContract(
        CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), 
        proposal.ToAddress,
        proposal.ContractMethodName, proposal.Params);

    Context.Fire(new ProposalReleased { ProposalId = input });
    State.Proposals.Remove(input);

    return new Empty();
}
```

Apply the same fix pattern to Association and Parliament contracts by adding the `AssertIsAuthorizedProposer` call in their respective `Release` methods.

## Proof of Concept

```csharp
[Fact]
public async Task RemovedProposerCanStillReleaseApprovedProposal_Test()
{
    // Setup: Create organization with proposer in whitelist
    var proposerKeyPair = Accounts[1].KeyPair;
    var proposerAddress = Address.FromPublicKey(proposerKeyPair.PublicKey);
    var minimalApproveThreshold = 5000;
    var minimalVoteThreshold = 5000;
    
    var organizationAddress = await CreateOrganizationAsync(
        minimalApproveThreshold, 
        minimalVoteThreshold,
        10000, 10000, 
        new[] { proposerAddress });

    // Step 1: Proposer creates proposal while in whitelist
    ReferendumContractStub = GetReferendumContractTester(proposerKeyPair);
    var proposalId = await CreateProposalAsync(proposerKeyPair, organizationAddress);
    
    // Step 2: Proposal gets approved by voters
    await ApproveAllowanceAsync(Accounts[3].KeyPair, minimalApproveThreshold, proposalId);
    await ApproveAsync(Accounts[3].KeyPair, proposalId);
    
    // Verify proposal is ready for release
    var proposalBeforeRemoval = await ReferendumContractStub.GetProposal.CallAsync(proposalId);
    proposalBeforeRemoval.ToBeReleased.ShouldBeTrue();
    
    // Step 3: Organization removes proposer from whitelist (trust revoked)
    var newWhiteList = new ProposerWhiteList
    {
        Proposers = { DefaultSender } // Proposer no longer in whitelist
    };
    
    var changeWhitelistProposalId = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair, 
        newWhiteList,
        nameof(ReferendumContractStub.ChangeOrganizationProposerWhiteList), 
        organizationAddress,
        ReferendumContractAddress);
    
    await ApproveAllowanceAsync(Accounts[3].KeyPair, minimalApproveThreshold, changeWhitelistProposalId);
    await ApproveAsync(Accounts[3].KeyPair, changeWhitelistProposalId);
    ReferendumContractStub = GetReferendumContractTester(DefaultSenderKeyPair);
    await ReferendumContractStub.Release.SendAsync(changeWhitelistProposalId);
    
    // Verify proposer is no longer in whitelist
    var validateResult = await ReferendumContractStub.ValidateProposerInWhiteList.CallAsync(
        new ValidateProposerInWhiteListInput
        {
            OrganizationAddress = organizationAddress,
            Proposer = proposerAddress
        });
    validateResult.Value.ShouldBeFalse();
    
    // Verify removed proposer cannot create new proposals
    var newProposalAttempt = new CreateProposalInput
    {
        ToAddress = TokenContractAddress,
        ContractMethodName = "Transfer",
        Params = ByteString.Empty,
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(1),
        OrganizationAddress = organizationAddress
    };
    ReferendumContractStub = GetReferendumContractTester(proposerKeyPair);
    var createResult = await ReferendumContractStub.CreateProposal.SendWithExceptionAsync(newProposalAttempt);
    createResult.TransactionResult.Error.ShouldContain("Unauthorized to propose");
    
    // Step 4: VULNERABILITY - Removed proposer can still release old approved proposal
    await PrepareCreateTokenFee(organizationAddress);
    var releaseResult = await ReferendumContractStub.Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Proposal executed successfully despite proposer being removed from whitelist
    var newToken = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "NEW" });
    newToken.Issuer.ShouldBe(organizationAddress); // Token was created with organization authority
}

private async Task PrepareCreateTokenFee(Address organizationAddress)
{
    // Helper method to prepare token creation fees - implementation similar to existing test helpers
    await ApproveAndTransferCreateTokenFee(DefaultSenderKeyPair, 5000, organizationAddress);
}
```

This test demonstrates that:
1. A proposer can create and get approval for a proposal while in the whitelist
2. The organization removes the proposer from the whitelist
3. The removed proposer can no longer create new proposals (whitelist works for creation)
4. **VULNERABILITY**: The removed proposer can still release their previously approved proposal and execute privileged operations

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-58)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L18-21)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```
