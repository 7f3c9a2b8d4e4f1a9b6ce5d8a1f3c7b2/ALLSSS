### Title
Missing Validation for Empty Miner List in NextRound Allows Consensus Halt

### Summary
The `ToRound()` function converts a `NextRoundInput` to a `Round` object without validating that `RealTimeMinersInformation` is non-empty. [1](#0-0)  The consensus validation logic in `RoundTerminateValidationProvider` only checks round number correctness and InValue nullity, but does not verify that the miner list is populated. [2](#0-1)  This allows a malicious miner to inject a valid-looking but empty Round object, causing the blockchain to halt when subsequent operations attempt to access miner information.

### Finding Description
The vulnerability exists in the consensus round validation flow:

1. **ToRound() conversion**: The `ToRound()` method directly copies all fields from `NextRoundInput` to `Round` including `RealTimeMinersInformation`, with no validation that this critical dictionary contains miners. [1](#0-0) 

2. **Validation gap**: When `NextRound()` is called, the input flows through `ProcessConsensusInformation` [3](#0-2)  to `ProcessNextRound`, where it's converted to a Round object. [4](#0-3) 

3. **Insufficient validation**: The `RoundTerminateValidationProvider.ValidationForNextRound()` only validates:
   - Round number equals `baseRound.RoundNumber + 1`
   - All `InValue` fields are null
   
   It does NOT check if `RealTimeMinersInformation` is non-empty. [2](#0-1)  The check `extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)` returns false (passes validation) when the collection is empty.

4. **Storage without checks**: The malicious Round is stored via `AddRoundInformation(nextRound)` [5](#0-4)  and the round number is updated [6](#0-5)  as long as the round number is correct. [7](#0-6) 

5. **Crash trigger**: When the next round needs to be generated, `GetMiningInterval()` is called, which attempts to access miners at positions 1 and 2 without checking if the collection is empty, causing an `IndexOutOfRangeException`. [8](#0-7) 

While `PreCheck()` ensures the caller is a valid miner [9](#0-8) , it doesn't validate the content of the `NextRoundInput` being submitted.

### Impact Explanation
**Consensus Halt (Critical)**: Once a Round with empty `RealTimeMinersInformation` is stored in state:
- No miner can produce subsequent blocks because the current round has no miners
- Any attempt to call `GetMiningInterval()` for round generation crashes [10](#0-9) 
- `GenerateNextRoundInformation()` would fail when trying to generate the next round [11](#0-10) 
- The blockchain effectively halts, requiring manual intervention or a hard fork to recover

**Affected parties**: All network participants, as the entire blockchain stops producing blocks.

### Likelihood Explanation
**Attack vector**: A malicious miner running modified node software could craft consensus block header extra data with:
- Correct `RoundNumber` (currentRound + 1)
- Empty `RealTimeMinersInformation` dictionary
- All other fields properly formatted

**Feasibility**: 
- **Entry point**: `NextRound()` is a public method accessible to valid miners [12](#0-11) 
- **Preconditions**: Attacker must be an active miner (passes `PreCheck()`)
- **Bypass normal generation**: While normal operation uses `GenerateNextRoundInformation()` [13](#0-12) , block producers control their block headers and can inject custom consensus extra data
- **Detection**: The comment indicates transaction pool validation exists [14](#0-13) , but contract-level validation should provide defense-in-depth

**Likelihood**: Medium - Requires a malicious miner willing to halt the chain, but the validation gap means no defense-in-depth if node-level protections are bypassed.

### Recommendation
Add explicit validation in `RoundTerminateValidationProvider.ValidationForNextRound()`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Check round number
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // NEW: Check miners list is non-empty
    if (extraData.Round.RealTimeMinersInformation.Count == 0)
        return new ValidationResult { Message = "Next round must contain at least one miner." };
    
    // Check InValues are null
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

Additionally, add a similar check in `ProcessNextRound()` before calling `AddRoundInformation()` [15](#0-14) :

```csharp
Assert(nextRound.RealTimeMinersInformation.Count > 0, "Next round must contain miners.");
AddRoundInformation(nextRound);
```

### Proof of Concept
1. **Initial state**: Blockchain running normally with current round N containing 5 miners
2. **Attack**: Malicious miner (who is in current miner list) produces a block with consensus extra data containing:
   - `NextRoundInput` with `RoundNumber = N + 1`
   - Empty `RealTimeMinersInformation` dictionary
   - Valid `RandomNumber` for VRF verification
3. **Validation**: 
   - `RoundTerminateValidationProvider` checks: N + 1 == N + 1 ✓, no InValues to check ✓
   - Validation passes
4. **Execution**: 
   - `ToRound()` creates Round with empty miners
   - `AddRoundInformation()` stores it
   - `TryToUpdateRoundNumber(N + 1)` succeeds
   - Transaction completes successfully
5. **Result**: 
   - Current round is now N + 1 with zero miners
   - Next block production attempt crashes in `GetMiningInterval()`
   - Blockchain halts

**Success condition**: Round N + 1 stored in state with `RealTimeMinersInformation.Count == 0`, subsequent consensus operations fail.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-39)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();

        Context.LogDebug(() => $"Processing {callerMethodName}");

        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");

        State.RoundBeforeLatestExecution.Value = GetCurrentRoundInformation(new Empty());

        ByteString randomNumber = null;

        // The only difference.
        switch (input)
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-158)
```csharp
        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L91-97)
```csharp
    private bool TryToUpdateRoundNumber(long roundNumber)
    {
        var oldRoundNumber = State.CurrentRoundNumber.Value;
        if (roundNumber != 1 && oldRoundNumber + 1 != roundNumber) return false;
        State.CurrentRoundNumber.Value = roundNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-176)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```
