### Title
Permanent Method Fee Controller Hijack via Temporary Parliament Control

### Summary
An attacker who temporarily gains control of the Parliament default organization (e.g., by compromising 2/3+ miner keys) can permanently change the TokenContract method fee controller to an attacker-controlled Association organization with minimal approval thresholds. Once changed, the legitimate Parliament governance cannot regain control, resulting in permanent privilege escalation from temporary compromise.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController` method which lacks restrictions on the type of organization that can become the new controller. [1](#0-0) 

The method only performs two checks:
1. Line 27: Verifies the sender is the current controller's owner address
2. Line 28-29: Validates the new organization exists via `CheckOrganizationExist` [2](#0-1) 

The `CheckOrganizationExist` method only verifies the organization exists in the target governance contract (Parliament, Association, or Referendum), but does not validate:
- The type of organization (Parliament vs Association vs Referendum)
- The governance thresholds of the organization
- Whether the organization represents legitimate decentralized governance

Meanwhile, the Association contract allows anyone to create organizations with arbitrary thresholds, including single-member 1-of-1 multisigs: [3](#0-2) 

The initial controller is set to Parliament's default organization during initialization: [4](#0-3) 

Parliament members are the current miners from the consensus contract: [5](#0-4) 

When Parliament releases a proposal, it uses a virtual address representing the organization as the sender: [6](#0-5) 

The codebase contains a test demonstrating this exact attack vector (though not recognized as a vulnerability): [7](#0-6) 

### Impact Explanation

**Critical Governance Hijack**:
- An attacker achieves **permanent control** over method fee configuration from temporary Parliament compromise
- The attacker can set arbitrary method fees via `SetMethodFee` to:
  - Cause economic DoS by making all token operations prohibitively expensive
  - Extract value by setting high fees on critical operations
  - Completely block system functionality by setting fees higher than reasonable limits [8](#0-7) 

**No Recovery Path**:
- Once the controller is changed, the check at line 27 prevents Parliament from calling `ChangeMethodFeeController` since they are no longer the controller
- There is no emergency recovery mechanism or timelock to revert the change
- The legitimate governance loses permanent control over a critical protocol parameter

**Systemic Impact**:
- Affects all token operations across the entire blockchain
- Compromises the economic security model of the network
- Violates the critical invariant that method-fee provider authority remains under legitimate governance control

### Likelihood Explanation

**Feasible Attack Preconditions**:
- Requires temporary control of 2/3+ Parliament members (miners)
- This can occur through:
  - Temporary compromise of miner signing keys (malware, phishing, insider threat)
  - Short-term miner collusion for economic gain
  - Social engineering during emergency situations
  - Network partition scenarios where attacker controls the majority partition

**Low Attack Complexity**:
1. Attacker creates Association organization with themselves as sole member (single transaction, no restrictions)
2. Creates Parliament proposal to call `ChangeMethodFeeController` (standard proposal flow)
3. Controlled miners approve the proposal (normal voting process)
4. Attacker releases the proposal (single transaction)
5. Attack is complete and permanent

**High Impact vs Moderate Likelihood**:
- While temporary Parliament compromise is not trivial, it represents a realistic threat model in blockchain systems
- The permanence of the privilege escalation makes even a low-probability compromise catastrophic
- The attack leaves no window for detection or intervention before completion
- Once executed, recovery is impossible without a hard fork

### Recommendation

**1. Restrict Controller Types**:
Add validation that the new controller must be a Parliament organization with appropriate thresholds:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // NEW: Require new controller to be Parliament contract
    Assert(input.ContractAddress == State.ParliamentContract.Value, 
        "Method fee controller must be a Parliament organization.");
    
    // NEW: Validate minimum governance thresholds
    var organization = GetParliamentOrganization(input.OwnerAddress);
    Assert(organization.ProposalReleaseThreshold.MinimalApprovalThreshold >= 6667, 
        "Controller organization must have at least 2/3 approval threshold.");
    
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

**2. Add Timelock Mechanism**:
Implement a delay between controller change proposal and execution:
- Store pending controller changes with activation timestamp
- Require minimum 7-day delay before new controller becomes active
- Allow current controller to cancel pending changes during the delay period

**3. Add Emergency Recovery**:
Create an emergency recovery path through a dedicated emergency response organization or require multiple governance organizations to approve controller changes.

**4. Add Monitoring and Alerts**:
- Emit detailed events when controller change proposals are created
- Implement off-chain monitoring to alert stakeholders of pending controller changes
- Add circuit breakers that pause controller changes during suspected compromise

**5. Test Regression Prevention**:
Add test cases that explicitly verify:
- Controller cannot be changed to Association organizations
- Controller cannot be changed to organizations with insufficient thresholds
- Recovery mechanisms work correctly

### Proof of Concept

**Initial State**:
- TokenContract.MethodFeeController = Parliament Default Organization (2/3 approval threshold)
- Attacker temporarily controls 2/3+ of miner keys

**Attack Sequence**:

**Step 1** - Attacker creates malicious Association organization:
```
Call: AssociationContract.CreateOrganization({
    OrganizationMemberList: [AttackerAddress],
    ProposerWhiteList: [AttackerAddress],
    ProposalReleaseThreshold: {
        MinimalApprovalThreshold: 1,
        MinimalVoteThreshold: 1
    }
})
Returns: AttackerOrgAddress
```

**Step 2** - Attacker creates Parliament proposal:
```
Call: ParliamentContract.CreateProposal({
    OrganizationAddress: ParliamentDefaultOrgAddress,
    ToAddress: TokenContractAddress,
    ContractMethodName: "ChangeMethodFeeController",
    Params: AuthorityInfo {
        OwnerAddress: AttackerOrgAddress,
        ContractAddress: AssociationContractAddress
    }
})
Returns: ProposalId
```

**Step 3** - Controlled miners approve:
```
For each controlled miner (2/3+):
    Call: ParliamentContract.Approve(ProposalId)
```

**Step 4** - Attacker releases proposal:
```
Call: ParliamentContract.Release(ProposalId)
Status: SUCCESS
```

**Expected Result**: 
- TokenContract.MethodFeeController.OwnerAddress = AttackerOrgAddress
- TokenContract.MethodFeeController.ContractAddress = AssociationContractAddress

**Actual Result**: 
Same as expected (vulnerability confirmed by test at lines 1272-1315)

**Success Condition**: 
Call `TokenContract.GetMethodFeeController()` returns attacker's Association organization. Parliament can no longer call `ChangeMethodFeeController` (fails with "Unauthorized behavior").

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L91-109)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo();

        // Parliament Auth Contract maybe not deployed.
        if (State.ParliamentContract.Value != null)
        {
            defaultAuthority.OwnerAddress =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L13-20)
```csharp
    private List<Address> GetCurrentMinerList()
    {
        RequireConsensusContractStateSet();
        var miner = State.ConsensusContract.GetCurrentMinerList.Call(new Empty());
        var members = miner.Pubkeys.Select(publicKey =>
            Address.FromPublicKey(publicKey.ToByteArray())).ToList();
        return members;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L1272-1315)
```csharp
    [Fact]
    public async Task ChangeMethodFeeControllerByAssociation_Test()
    {
        var createOrganizationResult = await Tester.ExecuteContractWithMiningAsync(AssociationContractAddress,
            nameof(AssociationContractImplContainer.AssociationContractImplStub.CreateOrganization),
            new Association.CreateOrganizationInput
            {
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { AnotherMinerAddress }
                },
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { AnotherMinerAddress }
                }
            });

        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.ReturnValue);

        var methodFeeController = await GetMethodFeeController(Tester, BasicContractZeroAddress);
        const string proposalCreationMethodName =
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ChangeMethodFeeController);
        var proposalId = await CreateProposalAsync(Tester, methodFeeController.ContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName,
            new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = AssociationContractAddress
            });
        await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
        var txResult2 = await ReleaseProposalAsync(Tester, ParliamentAddress, proposalId);
        txResult2.Status.ShouldBe(TransactionResultStatus.Mined);

        var methodFeeControllerAfterChange =
            await GetMethodFeeController(Tester, BasicContractZeroAddress);

        methodFeeControllerAfterChange.ContractAddress.ShouldBe(AssociationContractAddress);
        methodFeeControllerAfterChange.OwnerAddress.ShouldBe(organizationAddress);
    }
```
