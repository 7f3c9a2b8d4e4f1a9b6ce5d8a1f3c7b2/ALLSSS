### Title
Undeclared Delegation State Reads Enable Transaction Conflicts and Potential Fee Charging Inconsistencies

### Summary
The delegation state maps (`TransactionFeeDelegateInfoMap` and `TransactionFeeDelegateesMap`) are read during both resource path declaration (`GetResourceInfo`) and transaction execution (`ChargeTransactionFees`), but are not declared as `ReadPaths`. This allows delegation state to be modified between path declaration and execution, causing transactions to access undeclared state paths and potentially charge fees from stale or incorrect delegatee lists.

### Finding Description [1](#0-0) 

The `GetDelegateeList` function reads from two delegation state maps to determine which delegatees should have their balance paths included in the transaction's resource declaration. These paths are then added via `AddPathForDelegatees`. [2](#0-1) 

However, the delegation state maps themselves are never added to `ReadPaths`, only the resulting delegatee balance paths are added to `WritePaths`. During actual transaction execution, these same delegation maps are read again: [3](#0-2) [4](#0-3) 

**Root Cause**: The AElf parallel execution model requires all state accesses to be declared upfront in `GetResourceInfo`. Delegation state maps are accessed during both resource path calculation and transaction execution, but are not declared as dependencies in `ReadPaths`. This violates the resource declaration contract.

**Why Protections Fail**: The `TransactionGrouper` groups transactions based on declared resource paths. [5](#0-4) 

Since delegation maps are not in `ReadPaths`, the system cannot detect that Transfer transactions depend on delegation state. Delegation modification operations (`SetTransactionFeeDelegateInfos`) return `NonParallelizable = true` but this only prevents them from running in parallel with each other, not with Transfer transactions. [6](#0-5) 

### Impact Explanation

**Operational Impact - Transaction Conflicts**:
1. When delegation state changes between `GetResourceInfo` and execution, transactions access undeclared state paths
2. The `ConflictingTransactionIdentificationService` detects this mismatch, marking transactions as conflicting
3. Conflicting transactions must be re-executed, consuming additional computational resources [7](#0-6) 

**Potential Fee Charging Issues**:
1. **Missed Delegatees**: If a delegatee is removed between path declaration and execution, the transaction may attempt to charge a delegatee who no longer has authorization, potentially causing transaction failure
2. **Undeclared Delegatee Access**: If a delegatee is added between path declaration and execution, the transaction reads the updated list and attempts to access their balance without having declared it, causing conflict or incorrect charging if the path overlaps with other declared paths
3. **DoS Vector**: An attacker can repeatedly call `SetTransactionFeeDelegateInfos` to modify delegation state, causing numerous Transfer transactions to fail validation and require re-execution

**Severity Justification**: High operational impact due to systematic transaction failures and re-execution overhead. While not direct fund theft, this undermines the parallel execution model's correctness guarantees and creates DoS opportunities.

### Likelihood Explanation

**Attacker Capabilities**: Any user can call `SetTransactionFeeDelegateInfos` or `SetTransactionFeeDelegations` to modify delegation state. [8](#0-7) 

**Attack Complexity**: Low. The attacker simply needs to:
1. Submit Transfer transactions from a delegator account
2. Submit `SetTransactionFeeDelegateInfos` transactions to modify delegation state in the same block
3. The timing window exists because all `GetResourceInfo` calls occur during the grouping phase before any execution

**Feasibility Conditions**: 
- Multiple transactions from the same delegator in a single block (common in high-activity scenarios)
- Delegation state modifications occurring concurrently (legitimate operation)
- No additional permissions required beyond standard transaction submission

**Detection Constraints**: The `ConflictingTransactionIdentificationService` will detect violations, but only after execution has begun, causing unnecessary computation and potential service degradation.

**Probability**: Medium-High. In production environments with active delegation usage, this race condition will occur naturally without malicious intent.

### Recommendation

**Code-Level Mitigation**: Add delegation state map paths to `ReadPaths` in `GetResourceInfo`:

```csharp
private void AddPathForDelegatees(ResourceInfo resourceInfo, Address from, Address to, string methodName)
{
    // Declare delegation state maps as read dependencies
    resourceInfo.ReadPaths.Add(
        GetPath(nameof(TokenContractState.TransactionFeeDelegateInfoMap), 
                from.ToString(), to.ToString(), methodName));
    resourceInfo.ReadPaths.Add(
        GetPath(nameof(TokenContractState.TransactionFeeDelegateesMap), 
                from.ToString()));
    
    var delegateeList = new List<string>();
    delegateeList.AddRange(GetDelegateeList(from, to, methodName));
    // ... rest of existing logic
}
```

**Invariant Checks**: Ensure that any state accessed during transaction execution is declared in `GetResourceInfo`. Add validation in test suite to verify declared paths match actual accessed paths.

**Test Cases**: 
1. Test concurrent Transfer and `SetTransactionFeeDelegateInfos` in same block
2. Verify transactions with delegation state changes are properly serialized
3. Confirm no undeclared state access violations occur

### Proof of Concept

**Initial State**:
- Delegator address `D` has delegatees `[A, B]` configured
- Delegatee `A` has sufficient balance to pay transaction fees
- Delegatee `C` exists but is not yet a delegatee for `D`

**Transaction Sequence** (submitted in same block):
1. **TX1** (Transfer from `D`): 
   - `GetResourceInfo` called → reads delegation state → sees `[A, B]` → declares balance paths for A and B
   
2. **TX2** (`SetTransactionFeeDelegateInfos` by `C`):
   - Adds `C` as delegatee for `D` → delegation state now `[A, B, C]`
   - Marked as `NonParallelizable`, executes serially

3. **TX3** (Transfer from `D`):
   - `GetResourceInfo` called → reads delegation state → sees `[A, B]` → declares balance paths for A and B
   - Executes after TX2 completes → delegation state is now `[A, B, C]`
   - `ChargeTransactionFees` re-reads delegation → sees `[A, B, C]`
   - Attempts to access delegatee `C`'s balance path (undeclared)
   - **Result**: `ConflictingTransactionIdentificationService` flags TX3, requires re-execution

**Success Condition**: TX3 is marked as conflicting due to undeclared state access, demonstrating the vulnerability where declared paths do not match actual execution paths due to delegation state modifications.

### Notes

The core issue is architectural: the delegation system requires reading state to determine which paths to declare, but those state reads themselves are dependencies that must be declared. This creates a circular dependency that the current ACS2 implementation does not handle. The vulnerability manifests as unnecessary transaction conflicts rather than direct fund theft, but represents a violation of the parallel execution model's correctness guarantees and creates DoS opportunities.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L66-68)
```csharp
            default:
                return new ResourceInfo { NonParallelizable = true };
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L113-132)
```csharp
    private void AddPathForDelegatees(ResourceInfo resourceInfo, Address from, Address to, string methodName)
    {
        var delegateeList = new List<string>();
        //get and add first-level delegatee list
        delegateeList.AddRange(GetDelegateeList(from, to, methodName));
        if (delegateeList.Count <= 0) return;
        var secondDelegateeList = new List<string>();
        //get and add second-level delegatee list
        foreach (var delegateeAddress in delegateeList.Select(a => Address.FromBase58(a)))
        {
            //delegatee of the first-level delegate is delegator of the second-level delegate
            secondDelegateeList.AddRange(GetDelegateeList(delegateeAddress, to, methodName));
        }
        delegateeList.AddRange(secondDelegateeList);
        foreach (var delegatee in delegateeList.Distinct())
        {
            AddPathForTransactionFee(resourceInfo, delegatee, methodName);
            AddPathForTransactionFeeFreeAllowance(resourceInfo, Address.FromBase58(delegatee));
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L134-146)
```csharp
    private List<string> GetDelegateeList(Address delegator, Address to, string methodName)
    {
        var delegateeList = new List<string>();
        var allDelegatees = State.TransactionFeeDelegateInfoMap[delegator][to][methodName] 
                            ?? State.TransactionFeeDelegateesMap[delegator];
            
        if (allDelegatees != null)
        {
            delegateeList.AddRange(allDelegatees.Delegatees.Keys.ToList());
        } 

        return delegateeList;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L98-116)
```csharp
        if (!chargingResult)
        {
            var transactionFeeDelegatees =
                State.TransactionFeeDelegateInfoMap[fromAddress][input.ContractAddress][input.MethodName] ??
                State.TransactionFeeDelegateesMap[fromAddress];
            if (transactionFeeDelegatees != null)
            {
                var delegateeAddress = transactionFeeDelegatees.Delegatees;
                foreach (var (delegatee, _) in delegateeAddress)
                {
                    chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                        isSizeFeeFree, Address.FromBase58(delegatee));
                    if (chargingResult)
                    {
                        break;
                    }
                }
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L167-210)
```csharp
    private bool ChargeFromDelegations(ChargeTransactionFeesInput input, ref Address fromAddress,
        ref TransactionFeeBill bill, ref TransactionFreeFeeAllowanceBill allowanceBill,
        Dictionary<string, long> fee, bool isSizeFeeFree, Address delegatorAddress)
    {
        var chargingResult = false;
        // Try to charge delegatees
        // Get delegatee list according to the delegator
        var delegationInfo =
            State.TransactionFeeDelegateInfoMap[delegatorAddress][input.ContractAddress][input.MethodName]?.Delegatees ?? 
            State.TransactionFeeDelegateesMap[delegatorAddress]?.Delegatees;

        if (delegationInfo == null)
        {
            return false;
        }

        foreach (var (delegatee, delegations) in delegationInfo)
        {
            // compare current block height with the block height when the delegatee added
            if (Context.Transaction.RefBlockNumber < delegations.BlockHeight) continue;

            var delegateeBill = new TransactionFeeBill();
            var delegateeAllowanceBill = new TransactionFreeFeeAllowanceBill();
            var delegateeAddress = Address.FromBase58(delegatee);
            var delegateeChargingResult = ChargeTransactionFeesToBill(input, delegateeAddress,
                ref delegateeBill, ref delegateeAllowanceBill, fee, isSizeFeeFree, delegations);

            if (!delegateeChargingResult) continue;

            bill = delegateeBill;
            allowanceBill = delegateeAllowanceBill;
            fromAddress = delegateeAddress;
            chargingResult = true;
            if (!delegations.IsUnlimitedDelegate)
            {
                ModifyDelegation(delegateeBill, delegateeAllowanceBill, fromAddress, input.ContractAddress,
                    input.MethodName, delegatorAddress);
            }

            break;
        }

        return chargingResult;
    }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/TransactionGrouper.cs (L115-148)
```csharp
    private List<List<Transaction>> GroupParallelizables(List<TransactionWithResourceInfo> txsWithResources)
    {
        var resourceUnionSet = new Dictionary<int, UnionFindNode>();
        var transactionResourceHandle = new Dictionary<Transaction, int>();
        var groups = new List<List<Transaction>>();
        var readOnlyPaths = txsWithResources.GetReadOnlyPaths();
        foreach (var txWithResource in txsWithResources)
        {
            UnionFindNode first = null;
            var transaction = txWithResource.Transaction;
            var transactionResourceInfo = txWithResource.TransactionResourceInfo;

            // Add resources to disjoint-set, later each resource will be connected to a node id, which will be our group id
            foreach (var resource in transactionResourceInfo.WritePaths.Concat(transactionResourceInfo.ReadPaths)
                         .Where(p => !readOnlyPaths.Contains(p))
                         .Select(p => p.GetHashCode()))
            {
                if (!resourceUnionSet.TryGetValue(resource, out var node))
                {
                    node = new UnionFindNode();
                    resourceUnionSet.Add(resource, node);
                }

                if (first == null)
                {
                    first = node;
                    transactionResourceHandle.Add(transaction, resource);
                }
                else
                {
                    node.Union(first);
                }
            }
        }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ConflictingTransactionIdentificationService.cs (L46-74)
```csharp
    private async Task<List<TransactionWithResourceInfo>> FindContractOfWrongResourcesAsync(IChainContext chainContext,
        List<ExecutionReturnSet> returnSets)
    {
        var transactionIds = returnSets.Select(rs => rs.TransactionId);
        var transactions = await _blockchainService.GetTransactionsAsync(transactionIds);

        var txnWithResources =
            await _resourceExtractionService.GetResourcesAsync(chainContext, transactions, CancellationToken.None);
        txnWithResources =
            txnWithResources.Where(t => t.TransactionResourceInfo.ParallelType == ParallelType.Parallelizable);

        var txnWithResourceList = txnWithResources.ToList();
        var readOnlyKeys = txnWithResourceList.GetReadOnlyPaths().Select(p => p.ToStateKey()).ToList();
        var returnSetLookup = returnSets.ToDictionary(rs => rs.TransactionId, rs => rs);
        var wrongTxnWithResources = new List<TransactionWithResourceInfo>();
        foreach (var txnWithResource in txnWithResourceList)
        {
            var extracted = new HashSet<string>(txnWithResource.TransactionResourceInfo.WritePaths
                .Concat(txnWithResource.TransactionResourceInfo.ReadPaths).Select(p => p.ToStateKey()));
            extracted.ExceptWith(readOnlyKeys);
            var actual = GetKeys(returnSetLookup[txnWithResource.Transaction.GetHash()]);
            actual.ExceptWith(extracted);
            if (actual.Count == 0) continue;
            Logger.LogDebug($"Conflict keys:{string.Join(";", actual)}");
            wrongTxnWithResources.Add(txnWithResource);
        }

        return wrongTxnWithResources;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L198-251)
```csharp
    public override Empty SetTransactionFeeDelegateInfos(SetTransactionFeeDelegateInfosInput input)
    {
        Assert(input.DelegatorAddress != null && input.DelegateInfoList.Count > 0,
            "Delegator address and delegate info cannot be null.");
        var toAddTransactionList = new DelegateTransactionList();
        var toUpdateTransactionList = new DelegateTransactionList();
        var toCancelTransactionList = new DelegateTransactionList();
        var delegatorAddress = input.DelegatorAddress;
        foreach (var delegateInfo in input.DelegateInfoList)
        {
            //If isUnlimitedDelegate is false,delegate info list should > 0.
            Assert(delegateInfo.IsUnlimitedDelegate || delegateInfo.Delegations.Count > 0,
                "Delegation cannot be null.");
            Assert(delegateInfo.ContractAddress != null && !string.IsNullOrEmpty(delegateInfo.MethodName),
                "Invalid contract address and method name.");

            var existDelegateeInfoList =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
                    [delegateInfo.MethodName] ?? new TransactionFeeDelegatees();
            var delegateeAddress = Context.Sender.ToBase58();
            var existDelegateeList = existDelegateeInfoList.Delegatees;
            //If the transaction contains delegatee,update delegate info.
            if (existDelegateeList.TryGetValue(delegateeAddress, out var value))
            {
                toUpdateTransactionList.Value.Add(UpdateDelegateInfo(value, delegateInfo));
            } //else,add new delegate info.
            else
            {
                Assert(existDelegateeList.Count < TokenContractConstants.DELEGATEE_MAX_COUNT,
                    "The quantity of delegatee has reached its limit");
                existDelegateeList.Add(delegateeAddress, new TransactionFeeDelegations());
                var transactionFeeDelegations = existDelegateeList[delegateeAddress];
                toAddTransactionList.Value.Add(AddDelegateInfo(transactionFeeDelegations, delegateInfo));
            }

            if (existDelegateeInfoList.Delegatees[delegateeAddress].Delegations.Count == 0 &&
                !existDelegateeInfoList.Delegatees[delegateeAddress].IsUnlimitedDelegate)
            {
                existDelegateeInfoList.Delegatees.Remove(delegateeAddress);
                toCancelTransactionList.Value.Add(new DelegateTransaction
                {
                    ContractAddress = delegateInfo.ContractAddress,
                    MethodName = delegateInfo.MethodName
                });
            }

            State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
                [delegateInfo.MethodName] = existDelegateeInfoList;
        }

        FireLogEvent(toAddTransactionList, toUpdateTransactionList, toCancelTransactionList, delegatorAddress);

        return new Empty();
    }
```
