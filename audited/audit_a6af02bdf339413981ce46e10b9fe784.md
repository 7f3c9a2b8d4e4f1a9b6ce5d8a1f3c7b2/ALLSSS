### Title
Incorrect Round Reference in Secret Sharing Validation Breaks Consensus During Miner List Expansion

### Summary
The `RevealSharedInValues` function uses the current round's miner count to validate decrypted pieces that were accumulated during the previous round. This mismatch causes valid secret reconstructions to be incorrectly rejected when the miner list expands between rounds, breaking the secret sharing mechanism critical for random number generation and consensus integrity.

### Finding Description

The vulnerability exists in the `RevealSharedInValues` function where two inconsistencies cause consensus failures: [1](#0-0) 

The function calculates `minersCount` from `currentRound`, but the `DecryptedPieces` being validated were accumulated during `previousRound`: [2](#0-1) 

The validation check at line 36 compares `DecryptedPieces.Count < minersCount`, where:
- `DecryptedPieces.Count` reflects the number of miners from `previousRound` who contributed decrypted pieces
- `minersCount` reflects the number of miners in `currentRound`

**Root Cause:** When miner lists change between rounds, this creates a critical mismatch. The correct implementation should use `previousRound.RealTimeMinersInformation.Count` for `minersCount`, as shown in the off-chain counterpart: [3](#0-2) 

**Why Protections Fail:** The function is called during next round generation: [4](#0-3) 

There are no additional checks to validate that the correct round's miner count is used for the comparison.

### Impact Explanation

**Concrete Harm:**

**Scenario: Miner List Expansion**
- Previous round has 7 miners, all contribute decrypted pieces → `DecryptedPieces.Count = 7`
- Current round has 10 miners → `minersCount = 10`
- Minimum threshold for reconstruction = `7 * 2/3 = 4` pieces needed
- Check: `if (7 < 10) continue;` → **Reconstruction SKIPPED**

**Result:** Even though 7 pieces exceed the threshold of 4 needed for Shamir's Secret Sharing reconstruction, the InValue revelation is blocked.

**Protocol Damage:**
1. **Random Number Generation Failure**: InValues are essential for generating random hashes used in consensus
2. **Consensus Integrity Broken**: PreviousInValue fields remain empty, affecting round validation
3. **Miner Scheduling Impact**: Random number generation affects fair miner ordering

**Affected Parties:**
- All network participants during term changes when miner list expands
- Occurs during governance-controlled miner elections (common operation)

**Severity:** HIGH - Breaks core consensus mechanism during normal protocol operation (term transitions with miner list expansion).

### Likelihood Explanation

**Attacker Capabilities:** None required - this is a protocol-level bug, not an attack.

**Occurrence Conditions:**
1. **Frequency:** Happens automatically during term changes when new miners are added to the network
2. **Governance Process:** Miner list expansions occur through legitimate governance voting
3. **No Manipulation Needed:** The bug triggers through normal protocol operation

**Feasibility:** 
- **Entry Point:** Triggered via `GetConsensusExtraDataForNextRound` during block production
- **Preconditions:** Simply requires miner list to expand between consecutive rounds
- **Detection:** Would manifest as missing PreviousInValue data in round information

**Probability:** VERY HIGH during network growth phases when miner slots increase. Term changes occur regularly (every few days in AElf), and miner list changes are a planned governance activity.

### Recommendation

**Fix 1: Use Correct Round for Miner Count**
Change line 21 from:
```csharp
var minersCount = currentRound.RealTimeMinersInformation.Count;
```
To:
```csharp
var minersCount = previousRound.RealTimeMinersInformation.Count;
```

**Fix 2: Consider Stricter Validation**
Change line 36 from using `<` operator to `!=` for exact count validation:
```csharp
if (anotherMinerInPreviousRound.DecryptedPieces.Count != minersCount) continue;
```

**Invariant Checks to Add:**
1. Assert that `DecryptedPieces` keys all exist in `previousRound.RealTimeMinersInformation`
2. Log warning when `DecryptedPieces.Count` significantly differs from expected count
3. Add validation in `PerformSecretSharing` to prevent accumulating pieces from non-existent miners [5](#0-4) 

**Test Cases:**
1. Test secret sharing with miner list expanding from N to N+3 miners
2. Test secret sharing with miner list shrinking from N to N-2 miners  
3. Verify all PreviousInValue fields are correctly populated after round transition
4. Test threshold reconstruction works with minimum required pieces during list changes

### Proof of Concept

**Initial State:**
- Term 1, Round 10: Active miner list = {A, B, C, D, E, F, G} (7 miners)
- All 7 miners successfully exchange and decrypt secret pieces during Round 10
- Each miner accumulates 7 entries in their `DecryptedPieces` (all miners contributed)

**Transition Steps:**
1. Governance votes to increase miner slots from 7 to 10
2. New term begins: Term 2, Round 1: Active miner list = {A, B, C, D, E, F, G, H, I, J} (10 miners)
3. Miner A produces extra block to trigger next round generation
4. `GetConsensusExtraDataForNextRound` is called with `currentRound` (Round 1 of Term 2)
5. `RevealSharedInValues(currentRound, "A")` is invoked
6. Function retrieves `previousRound` (Round 10 of Term 1 with 7 miners)
7. Line 21: `minersCount = 10` (from currentRound with 10 miners)
8. Line 25: Iterates through previousRound miners (7 miners: A-G)
9. For miner B in previousRound:
   - `DecryptedPieces.Count = 7` (all 7 miners from Round 10 contributed)
   - Line 36: `if (7 < 10) continue;` → **TRUE**
   - **Reconstruction SKIPPED** for miner B

**Expected Result:** 
Miner B's InValue should be reconstructed (7 pieces > threshold of 4) and stored in `PreviousInValue` field.

**Actual Result:** 
Miner B's InValue reconstruction is skipped. The `PreviousInValue` field remains empty/Hash.Empty.

**Success Condition:** 
Check that `nextRound.RealTimeMinersInformation["B"].PreviousInValue == Hash.Empty` (bug present) vs should contain reconstructed hash (correct behavior).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-21)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L25-36)
```csharp
        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L147-162)
```csharp
        var minersCount = round.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        var revealedInValues = new Dictionary<string, Hash>();

        foreach (var pair in round.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == selfPubkey) continue;

            var pubkey = pair.Key;
            var minerInRound = pair.Value;

            if (minerInRound.EncryptedPieces.Count < minimumCount) continue;
            if (minerInRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-189)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```
