### Title
Missing Symbol Validation in Side Chain Token Creation Allows DoS of Governance Process

### Summary
The `AssertValidSideChainTokenInfo()` function fails to validate token symbol length and character restrictions before side chain proposals are created. This allows proposals with invalid symbols (exceeding 10 characters or containing special characters) to pass initial validation and be approved by governance, but fail during execution when the MultiToken contract enforces proper validation, resulting in wasted governance effort and locked tokens.

### Finding Description

The `AssertValidSideChainTokenInfo()` function performs insufficient validation on side chain token symbols: [1](#0-0) 

This function only checks that the symbol and name are not null/empty and that total supply is positive. It does not validate:
- Symbol length (must be ≤ 10 characters for regular tokens)
- Symbol character restrictions (must match regex `^[a-zA-Z0-9]+$`)
- Token name length (must be ≤ 80 characters)

These validations are enforced by the MultiToken contract when the token is actually created: [2](#0-1) [3](#0-2) [4](#0-3) 

The execution path shows that token creation happens during proposal release: [5](#0-4) 

When `CreateSideChainToken` is called, it sends the token creation request to the MultiToken contract: [6](#0-5) 

If the symbol is invalid, the MultiToken contract's validation will fail, causing the entire transaction to revert and leaving the proposal unreleased.

### Impact Explanation

This vulnerability enables a denial-of-service attack on the governance process:

1. **Governance Resource Waste**: Governance members waste time and effort reviewing and approving proposals that will fail during execution
2. **Gas Costs**: Failed release attempts consume gas without achieving the intended outcome
3. **Locked Tokens**: Proposer's tokens remain locked in the contract until the proposal expires, reducing capital efficiency
4. **Operational Disruption**: Multiple invalid proposals can clog the governance queue and create confusion

The impact is limited to operational inefficiency rather than fund loss, as tokens are eventually unlocked upon proposal expiration. Test evidence shows the exact error messages produced: [7](#0-6) 

### Likelihood Explanation

The attack has moderate-to-low likelihood due to several factors:

**Attack Requirements:**
- Attacker must submit a side chain creation proposal with sufficient allowance
- Proposal must be approved by governance (public review process)
- Attacker or any user must call `ReleaseSideChainCreation` to trigger the failure

**Detection Opportunities:**
- Invalid symbols are detectable through off-chain validation before governance approval
- Proposal parameters are publicly visible during the review period
- Governance can implement automated validation checks

**Attack Complexity:**
- Low technical sophistication required (simply use long or special character symbols)
- Economic cost is minimal (only requires proposal submission allowance)
- Attack can be repeated with multiple proposals

**Mitigation Factors:**
- Informed governance members can reject invalid proposals during review
- Failed transactions are immediately visible, preventing repeated attempts
- Community monitoring can identify and flag malicious proposals

### Recommendation

Add comprehensive symbol validation to `AssertValidSideChainTokenInfo()` to match the MultiToken contract's requirements:

```csharp
private void AssertValidSideChainTokenInfo(SideChainTokenCreationRequest sideChainTokenCreationRequest)
{
    Assert(
        !string.IsNullOrEmpty(sideChainTokenCreationRequest.SideChainTokenSymbol) &&
        !string.IsNullOrEmpty(sideChainTokenCreationRequest.SideChainTokenName),
        "Invalid side chain token name.");
    
    // Add symbol length validation
    Assert(
        sideChainTokenCreationRequest.SideChainTokenSymbol.Length <= TokenContractConstants.SymbolMaxLength,
        "Invalid side chain token symbol length.");
    
    // Add token name length validation
    Assert(
        sideChainTokenCreationRequest.SideChainTokenName.Length <= TokenContractConstants.TokenNameLength,
        "Invalid side chain token name length.");
    
    // Add symbol character validation
    Assert(
        Regex.IsMatch(sideChainTokenCreationRequest.SideChainTokenSymbol, "^[a-zA-Z0-9]+$"),
        "Invalid side chain token symbol format.");
    
    Assert(sideChainTokenCreationRequest.SideChainTokenTotalSupply > 0, "Invalid side chain token supply.");
}
```

**Additional Recommendations:**
1. Import required constants: `TokenContractConstants.SymbolMaxLength` (10) and `TokenContractConstants.TokenNameLength` (80)
2. Add regex validation using `System.Text.RegularExpressions`
3. Add test cases covering:
   - Symbol exceeding 10 characters (e.g., "VERYLONGSYMBOL")
   - Symbol with special characters (e.g., "ABC#@!")
   - Token name exceeding 80 characters
   - Valid symbols at boundary conditions (exactly 10 characters)

### Proof of Concept

**Initial State:**
- CrossChain contract initialized
- Governance organization configured
- User has sufficient token allowance for proposal

**Attack Sequence:**

1. Attacker submits side chain creation request with invalid symbol:
   ```
   RequestSideChainCreation({
     SideChainTokenCreationRequest: {
       SideChainTokenSymbol: "THISISAVERYLONGINVALIDSYMBOL", // 29 chars, exceeds 10 char limit
       SideChainTokenName: "Test Token",
       SideChainTokenTotalSupply: 1000000,
       SideChainTokenDecimals: 8
     },
     IndexingPrice: 1,
     LockedTokenAmount: 100
   })
   ```
   **Result**: Proposal created successfully (passes weak validation)

2. Governance reviews and approves the proposal
   **Result**: Proposal status changed to approved

3. Attacker or any user calls `ReleaseSideChainCreation(proposalId)`
   **Result**: Transaction reverts with error "Invalid token symbol length"
   
4. Proposal remains unreleased, tokens stay locked until expiration

**Success Condition:** 
- The side chain creation proposal is accepted during request phase
- The proposal release transaction fails with symbol validation error
- Governance effort and gas are wasted
- This demonstrates the validation gap between CrossChain and MultiToken contracts

**Notes**

The vulnerability is confirmed through code analysis showing the validation discrepancy between the two contracts. The CrossChain contract's validation at the proposal creation stage is insufficient compared to the MultiToken contract's enforcement during execution. While the severity is low due to the lack of direct fund loss and the requirement for governance participation, the issue represents a legitimate operational risk and poor user experience that should be addressed by implementing consistent validation across both contracts.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L147-154)
```csharp
    private void AssertValidSideChainTokenInfo(SideChainTokenCreationRequest sideChainTokenCreationRequest)
    {
        Assert(
            !string.IsNullOrEmpty(sideChainTokenCreationRequest.SideChainTokenSymbol) &&
            !string.IsNullOrEmpty(sideChainTokenCreationRequest.SideChainTokenName),
            "Invalid side chain token name.");
        Assert(sideChainTokenCreationRequest.SideChainTokenTotalSupply > 0, "Invalid side chain token supply.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L176-195)
```csharp
    private void CreateSideChainToken(SideChainCreationRequest sideChainCreationRequest, int chainId,
        Address creator)
    {
        if (!IsPrimaryTokenNeeded(sideChainCreationRequest))
            return;

        // new token needed only for exclusive side chain
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        State.TokenContract.Create.Send(new CreateInput
        {
            TokenName = sideChainCreationRequest.SideChainTokenCreationRequest.SideChainTokenName,
            Decimals = sideChainCreationRequest.SideChainTokenCreationRequest.SideChainTokenDecimals,
            IsBurnable = true,
            Issuer = creator,
            IssueChainId = chainId,
            Symbol = sideChainCreationRequest.SideChainTokenCreationRequest.SideChainTokenSymbol,
            TotalSupply = sideChainCreationRequest.SideChainTokenCreationRequest.SideChainTokenTotalSupply,
            Owner = creator
        });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L28-31)
```csharp
    private bool IsValidCreateSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L305-311)
```csharp
    private void CheckSymbolLength(string symbol, SymbolType symbolType)
    {
        if (symbolType == SymbolType.Token)
            Assert(symbol.Length <= TokenContractConstants.SymbolMaxLength, "Invalid token symbol length");
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
            Assert(symbol.Length <= TokenContractConstants.NFTSymbolMaxLength, "Invalid NFT symbol length");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L98-114)
```csharp
    public override Empty ReleaseSideChainCreation(ReleaseSideChainCreationInput input)
    {
        var sideChainCreationRequest = State.ProposedSideChainCreationRequestState[Context.Sender];
        Assert(sideChainCreationRequest != null, "Release side chain creation failed.");
        if (!TryClearExpiredSideChainCreationRequestProposal(input.ProposalId, Context.Sender))
        {
            var serialNumber = State.SideChainSerialNumber.Value.Add(1);
            var chainId = GetChainId(serialNumber);
            CreateSideChainToken(sideChainCreationRequest.SideChainCreationRequest, chainId,
                sideChainCreationRequest.Proposer);
            Context.SendInline(State.SideChainLifetimeController.Value.ContractAddress,
                nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release),
                input.ProposalId);
        }

        return new Empty();
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenManagementTests.cs (L496-499)
```csharp
        createTokenInfoWithInvalidTokenName.Symbol = "ITISAVERYLONGSYMBOLNAME";
        var createTokenRet =
            await CreateSeedNftWithExceptionAsync(TokenContractStub, createTokenInfoWithInvalidTokenName);
        createTokenRet.TransactionResult.Error.ShouldContain("Invalid token symbol length");
```
