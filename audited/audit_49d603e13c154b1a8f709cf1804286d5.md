### Title
Insufficient Cryptographic Validation of OutValue and Signature in Consensus UpdateValue

### Summary
The `NewConsensusInformationFilled()` validation only checks that OutValue and Signature are non-null and non-empty, without verifying their cryptographic correctness. This allows malicious miners to provide arbitrary hash values that pass validation, enabling manipulation of extra block producer selection and disruption of the consensus mechanism's integrity guarantees.

### Finding Description

The validation occurs in `UpdateValueValidationProvider.NewConsensusInformationFilled()` where OutValue and Signature are checked: [1](#0-0) 

The validation only verifies that both fields are non-null and have at least one byte (`Any()`), with no cryptographic validation that:
1. OutValue equals `Hash(InValue)` for some InValue known to the miner
2. Signature was correctly calculated using `CalculateSignature()` from previous round data

The `ValidatePreviousInValue()` method provides the only cryptographic check, but it explicitly allows `Hash.Empty` to bypass validation: [2](#0-1) 

When a miner submits UpdateValue, their provided Signature is directly stored without verification: [3](#0-2) 

This arbitrary Signature value is then used to calculate the extra block producer order for the next round: [4](#0-3) 

The method takes the first miner's Signature, converts it to Int64, and uses modulo arithmetic to determine the extra block producer order. A malicious miner can compute which Signature value would select their preferred candidate.

### Impact Explanation

**Consensus Integrity Violation**: Miners can manipulate the extra block producer selection mechanism, which is critical for fair reward distribution and consensus security. The extra block producer receives additional mining rewards and has increased influence over the chain.

**Concrete Harm**:
- A malicious first-order miner can calculate arbitrary Signature values to ensure they or an ally becomes the extra block producer
- This breaks the intended randomness/fairness of extra block producer selection
- Repeated exploitation allows consistent unfair advantage in earning extra block rewards (configured at 12,500,000 base reward per block) [5](#0-4) 

- Secret sharing mechanism can be disrupted if miners never reveal valid InValues (always using Hash.Empty for PreviousInValue)
- Undermines the cryptographic commitment scheme that prevents miners from adaptively choosing InValues after observing others

**Who is Affected**: All honest miners suffer reduced fairness in extra block producer selection, and the overall consensus security is weakened.

### Likelihood Explanation

**Attacker Capabilities**: Any miner in the validator set can execute this attack when they produce blocks. The attack is particularly effective for miners with lower order numbers (especially order 1), as `CalculateNextExtraBlockProducerOrder()` uses the first miner's Signature.

**Attack Complexity**: LOW
- Attacker only needs to compute `GetAbsModulus(signature.ToInt64(), blockProducerCount) + 1` for different signature values
- Select the signature that produces their desired extra block producer order
- Submit it in their UpdateValue transaction

**Feasibility Conditions**:
- Attacker must be a validator (realistically achievable through election)
- No additional preconditions required
- Can be executed every round the attacker mines

**Detection**: Difficult to detect as arbitrary Signature values appear valid without comparing against the expected `CalculateSignature()` result, which requires knowing the correct PreviousInValue.

**Economic Rationality**: High - the cost is zero (just providing different bytes), and the gain is preferential selection of extra block producers leading to increased rewards.

### Recommendation

**1. Add Cryptographic Validation for Signature**:

In `UpdateValueValidationProvider`, add validation that verifies the provided Signature was correctly calculated. This requires either:
- Storing expected Signature values calculated from previous round data, OR
- Recalculating and comparing during validation using `previousRound.CalculateSignature(providedPreviousInValue)`

**2. Strengthen PreviousInValue Validation**:

Modify `ValidatePreviousInValue()` to be more restrictive about accepting `Hash.Empty`:
- Only allow `Hash.Empty` for first-time miners (not in previous round)
- Require valid PreviousInValue reveal for all other cases
- Track and penalize miners who repeatedly fail to reveal proper InValues

**3. Add OutValue Verification**:

While OutValue cannot be directly verified until InValue is revealed next round, implement:
- Deferred verification in the following round that checks stored OutValues
- Penalties or slashing for miners who consistently fail to properly reveal InValues
- Integration with evil miner detection mechanism

**Example Fix for UpdateValueValidationProvider**:
```csharp
private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    var providedSignature = validationContext.ProvidedRound
        .RealTimeMinersInformation[validationContext.SenderPubkey].Signature;
    var providedPreviousInValue = validationContext.ProvidedRound
        .RealTimeMinersInformation[validationContext.SenderPubkey].PreviousInValue;
    
    // Only allow empty signature for first-time miners
    if (providedSignature == null || !providedSignature.Value.Any())
        return false;
    
    if (providedPreviousInValue == null || providedPreviousInValue == Hash.Empty)
    {
        // Allow only if this is first appearance
        return !validationContext.PreviousRound.RealTimeMinersInformation
            .ContainsKey(validationContext.SenderPubkey);
    }
    
    // Verify signature was correctly calculated
    var expectedSignature = validationContext.PreviousRound
        .CalculateSignature(providedPreviousInValue);
    return providedSignature == expectedSignature;
}
```

**4. Test Cases**:
- Test that arbitrary Signature values are rejected
- Test that valid Signature calculated via CalculateSignature() is accepted
- Test that Hash.Empty PreviousInValue is only accepted for new miners
- Test that extra block producer selection cannot be manipulated

### Proof of Concept

**Initial State**:
- Miner A has order 1 in current round N
- There are 17 total miners (SupposedMinersCount)
- Miner A wants to ensure Miner B (or themselves) becomes extra block producer of round N+1

**Attack Steps**:

1. **Preparation**: Miner A computes offline:
   - For each possible signature value S (iterate through different hash values)
   - Calculate: `order = GetAbsModulus(S.ToInt64(), 17) + 1`
   - Identify which S produces the desired order (e.g., order = 5 for Miner B)

2. **Exploit**: When Miner A produces their block in round N:
   - Create UpdateValueInput with:
     - `OutValue = Hash([0x01])` (arbitrary non-empty hash)
     - `Signature = S` (the computed value from step 1)
     - Other fields as normal
   - Submit UpdateValue transaction

3. **Validation**: 
   - `NewConsensusInformationFilled()` checks:
     - `OutValue != null && OutValue.Value.Any()` ✓ (passes: has 1 byte)
     - `Signature != null && Signature.Value.Any()` ✓ (passes: non-empty)
   - No cryptographic validation occurs
   - Transaction accepted

4. **Round N+1**: When next round is generated:
   - Miner A provides `PreviousInValue = Hash.Empty`
   - `ValidatePreviousInValue()` returns true (line 46 accepts Hash.Empty)
   - Transaction accepted

5. **Extra Block Producer Selection**:
   - `CalculateNextExtraBlockProducerOrder()` executes
   - Uses Miner A's arbitrary Signature value S
   - Computes: `order = GetAbsModulus(S.ToInt64(), 17) + 1`
   - Returns the order Miner A chose (e.g., 5)
   - Miner B at order 5 becomes extra block producer

**Expected vs Actual**:
- **Expected**: Signature should be cryptographically derived from previous round data, providing unpredictable randomness in extra block producer selection
- **Actual**: Miner A can choose arbitrary Signature, deterministically controlling extra block producer selection

**Success Condition**: Miner B becomes extra block producer in round N+1, as selected by Miner A through Signature manipulation, rather than through the intended consensus mechanism.

### Notes

The vulnerability exists because the validation trusts that miners provide cryptographically correct OutValue and Signature, checking only for non-empty values. While the `ValidatePreviousInValue()` method provides one layer of defense by checking that revealed InValues hash to previous OutValues, it explicitly allows `Hash.Empty` bypass, enabling the exploitation.

The random number generation for consensus uses VRF (verified at line 76-78 of ProcessConsensusInformation.cs), which remains secure. However, the InValue/OutValue/Signature mechanism serves a different purpose in determining mining order and extra block producer selection, and its compromise represents a distinct consensus integrity vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-244)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L7-7)
```csharp
    public const long InitialMiningRewardPerBlock = 12500000;
```
