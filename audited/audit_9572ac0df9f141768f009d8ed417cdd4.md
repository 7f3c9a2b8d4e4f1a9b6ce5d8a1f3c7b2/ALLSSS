# Audit Report

## Title
Incomplete Dataset in LIB Calculation Due to Current Round Miner Filtering

## Summary
The Last Irreversible Block (LIB) calculation in the AEDPoS consensus contract contains a design flaw that filters previous round miner data by current round participants. When exactly `MinersCountOfConsent` miners produce blocks in the current round while more miners participated in the previous round, the algorithm proceeds with an incomplete dataset, potentially inflating the LIB height beyond what true 2/3+1 consensus from all previous round participants would determine.

## Finding Description

The vulnerability exists in the `LastIrreversibleBlockHeightCalculator.Deconstruct()` method which calculates the LIB based on miners' implied irreversible block heights from the previous round. [1](#0-0) 

The core issue is at lines 24-25 where the algorithm retrieves miners who successfully mined in the **current** round and uses their public keys to filter the **previous** round's `ImpliedIrreversibleBlockHeights`. The `GetMinedMiners()` method specifically returns only miners with `SupposedOrderOfNextRound != 0`, which are miners who produced blocks in the current round. [2](#0-1) 

The filtered heights are then validated against `MinersCountOfConsent`, which is calculated as `(minerCount * 2 / 3) + 1` based on the current round's **total** miner count, not the count of miners who actually mined in the previous round. [3](#0-2) 

**Why the protection fails:**

When a system has 10 total miners, `MinersCountOfConsent = 7`. If exactly 7 miners produce blocks in the current round but all 10 mined in the previous round:
- The count check at line 26 passes (7 >= 7)
- However, 3 miners who mined in the previous round are excluded
- If these excluded miners had systematically different (particularly lower) implied heights, the LIB calculation becomes biased

The LIB selection at line 32 picks the height at index `(count-1)/3` from a sorted list. With only 7 heights instead of 10, the selected height can be artificially inflated if the excluded miners had lower values.

**Execution path:**

This occurs during normal consensus operation when miners produce blocks. The `ProcessUpdateValue` method sets each miner's `ImpliedIrreversibleBlockHeight` and then calculates the new LIB. [4](#0-3) 

The code explicitly handles miners who don't produce blocks by incrementing their `MissedTimeSlots` counter, confirming this is an expected operational scenario. [5](#0-4) 

## Impact Explanation

**HIGH severity** - This vulnerability violates the core BFT consensus invariant that requires 2/3+1 agreement on finality.

**Concrete harms:**

1. **Premature Block Finalization**: The LIB can be artificially inflated, marking blocks as irreversible before achieving true 2/3+1 consensus from all miners who participated in the previous round.

2. **Cross-Chain Security Compromise**: The calculated LIB directly affects cross-chain operations. The `IrreversibleBlockFound` event triggers system-wide updates through the event processing chain. [6](#0-5) [7](#0-6) 

3. **Finality Violations**: Blocks marked as irreversible without true consensus create a risk of finality violations if the broader network doesn't agree on those blocks' irreversibility.

**Quantified example:**
- Previous round: 10 miners with heights [100, 101, 102, 103, 104, 150, 151, 152, 153, 154]
- Current round: 7 miners (those with heights 150-154 plus a few others) mine
- Excluded miners have heights [102, 103, 104]
- **Incorrect LIB**: Index (7-1)/3 = 2 → Height 150 (or higher depending on which 7 mined)
- **Correct LIB**: Index (10-1)/3 = 3 → Height 103
- **Result**: Blocks 104-150 prematurely marked as irreversible

This violates the fundamental security guarantee that blocks are only irreversible after achieving supermajority consensus.

## Likelihood Explanation

**MEDIUM-HIGH probability** - This vulnerability can be triggered through natural network conditions or intentional manipulation.

**No special permissions required:**
- Any miner can miss their time slot due to network issues, being offline, or deliberate inaction
- The consensus mechanism explicitly handles missed time slots as a normal operational scenario

**Attack complexity: LOW**
- Requires only that certain miners don't produce blocks in the current round
- No sophisticated timing attacks or transaction ordering needed
- Can occur naturally without malicious intent when ~30% of miners experience issues
- Coordinated attack: Miners with lower implied heights collectively skip their current round slots

**Feasibility conditions:**
- System has ≥10 miners (realistic for production)
- Exactly `MinersCountOfConsent` miners mine in current round
- Previous round had more miners actively mining
- The excluded miners have different height distributions than included miners

**Detection difficulty:**
- Hard to distinguish malicious non-mining from legitimate network issues
- The calculated LIB appears valid since it passes all checks
- No validation failures or alerts occur

The combination of natural occurrence possibility and low attack complexity makes this a credible threat.

## Recommendation

The algorithm should be modified to ensure LIB calculation uses a complete and representative dataset from the previous round. Two potential fixes:

**Option 1:** Use all miners who mined in the previous round (recommended)
```csharp
public void Deconstruct(out long libHeight)
{
    if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

    // Get all miners who actually mined in the previous round
    var previousRoundMiners = _previousRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
    var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(previousRoundMiners);
    
    // Use threshold based on previous round's mined miners
    var previousRoundConsent = (previousRoundMiners.Count * 2 / 3) + 1;
    if (impliedIrreversibleHeights.Count < previousRoundConsent)
    {
        libHeight = 0;
        return;
    }

    libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
}
```

**Option 2:** Adjust threshold to match filtered dataset
```csharp
// Calculate threshold based on actual miners in previous round, not current round total
var previousRoundMinerCount = _previousRound.RealTimeMinersInformation.Values
    .Count(m => m.ImpliedIrreversibleBlockHeight > 0);
var adjustedConsent = (previousRoundMinerCount * 2 / 3) + 1;
```

Option 1 is preferred as it maintains the intended BFT guarantee by considering all participants from the round being finalized.

## Proof of Concept

The vulnerability can be demonstrated with the following scenario:

```csharp
// Setup: Round 100 - all 10 miners mine successfully
var previousRound = new Round { RoundNumber = 100 };
for (int i = 0; i < 10; i++)
{
    previousRound.RealTimeMinersInformation[$"Miner{i}"] = new MinerInRound
    {
        Pubkey = $"Miner{i}",
        ImpliedIrreversibleBlockHeight = i < 5 ? 100 + i : 150 + i - 5,
        SupposedOrderOfNextRound = i + 1
    };
}

// Round 101 - only 7 miners mine (those with high implied heights)
var currentRound = new Round { RoundNumber = 101 };
for (int i = 5; i < 10; i++)
{
    currentRound.RealTimeMinersInformation[$"Miner{i}"] = new MinerInRound
    {
        Pubkey = $"Miner{i}",
        SupposedOrderOfNextRound = i - 4 // Non-zero indicates mined
    };
}
// Add 2 more miners who also mined in round 101
currentRound.RealTimeMinersInformation["Miner0"] = new MinerInRound { Pubkey = "Miner0", SupposedOrderOfNextRound = 6 };
currentRound.RealTimeMinersInformation["Miner1"] = new MinerInRound { Pubkey = "Miner1", SupposedOrderOfNextRound = 7 };
// Total 10 miners in round, but only 7 have SupposedOrderOfNextRound != 0

// Miners 2, 3, 4 with implied heights [102, 103, 104] are excluded

var calculator = new LastIrreversibleBlockHeightCalculator(currentRound, previousRound);
calculator.Deconstruct(out var libHeight);

// Result: libHeight will be inflated because it only considers 7 miners
// Expected with all 10: height at index 3 = 103
// Actual with only 7: height at index 2 = potentially 150 or higher
// Blocks 104-149 are incorrectly marked irreversible
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L39-56)
```csharp
        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-19)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);

    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-282)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockFoundLogEventProcessor.cs (L54-80)
```csharp
    private async Task ProcessLogEventAsync(Block block, IrreversibleBlockFound irreversibleBlockFound)
    {
        try
        {
            var chain = await _blockchainService.GetChainAsync();

            if (chain.LastIrreversibleBlockHeight > irreversibleBlockFound.IrreversibleBlockHeight)
                return;

            var libBlockHash = await _blockchainService.GetBlockHashByHeightAsync(chain,
                irreversibleBlockFound.IrreversibleBlockHeight, block.GetHash());
            if (libBlockHash == null) return;

            if (chain.LastIrreversibleBlockHeight == irreversibleBlockFound.IrreversibleBlockHeight) return;

            var blockIndex = new BlockIndex(libBlockHash, irreversibleBlockFound.IrreversibleBlockHeight);
            Logger.LogDebug($"About to set new lib height: {blockIndex.BlockHeight} " +
                            $"Event: {irreversibleBlockFound} " +
                            $"BlockIndex: {blockIndex.BlockHash} - {blockIndex.BlockHeight}");
            _taskQueueManager.Enqueue(
                async () =>
                {
                    var currentChain = await _blockchainService.GetChainAsync();
                    if (currentChain.LastIrreversibleBlockHeight < blockIndex.BlockHeight)
                        await _blockchainService.SetIrreversibleBlockAsync(currentChain, blockIndex.BlockHeight,
                            blockIndex.BlockHash);
                }, KernelConstants.UpdateChainQueueName);
```

**File:** src/AElf.CrossChain/CrossChainModuleEventHandler.cs (L25-28)
```csharp
    public async Task HandleEventAsync(NewIrreversibleBlockFoundEvent eventData)
    {
        await _crossChainService.UpdateCrossChainDataWithLibAsync(eventData.BlockHash, eventData.BlockHeight);
    }
```
