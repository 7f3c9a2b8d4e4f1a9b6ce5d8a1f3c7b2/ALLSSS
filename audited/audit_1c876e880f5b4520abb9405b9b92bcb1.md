### Title
Cache Desynchronization in RemoveBeneficiary Causes Profit Distribution Loss for Delayed Share Schemes

### Summary
The `RemoveBeneficiary` function fails to update `CachedDelayTotalShares` for shares expiring at the current period (Key=0 entries), while still subtracting these shares from `TotalShares`. This desynchronization causes `DistributeProfits` to use inflated cached share values, resulting in beneficiaries receiving less profit than deserved with remaining tokens locked in period virtual addresses.

### Finding Description

The vulnerability exists in the interaction between `RemoveBeneficiary` and `RemoveProfitDetails` functions when handling shares with `EndPeriod == CurrentPeriod` in schemes with `DelayDistributePeriodCount > 0`.

**Root Cause:**

In `RemoveProfitDetails`, shares that expire at the current period are identified and added to `removedDetails` with Key=0: [1](#0-0) 

In `RemoveBeneficiary`, the code filters out Key=0 entries when updating the cache: [2](#0-1) 

However, ALL shares (including Key=0) are subtracted from `TotalShares`: [3](#0-2) 

**Why Existing Protections Fail:**

The cache mechanism stores future `TotalShares` values for delayed distribution: [4](#0-3) 

When a period arrives, `DistributeProfits` uses the cached value (if it exists) rather than current `TotalShares`. The cached value from previous periods includes shares that have since been removed with Key=0, causing an inflated denominator in profit calculations.

**Execution Path:**

1. At period P-2: `DistributeProfits` caches `CachedDelayTotalShares[P] = 100` (includes shares expiring at period P)
2. At period P: Manager calls `RemoveBeneficiary` for shares with `EndPeriod == P` before calling `DistributeProfits`
3. `RemoveProfitDetails` adds these shares to `removedDetails[0]`
4. `RemoveBeneficiary` skips updating cache (line 243 filter excludes Key=0)
5. `TotalShares` reduced to 50 (line 260)
6. `DistributeProfits` uses cached value 100 instead of actual 50 (line 469)
7. Profit calculation uses inflated denominator: `beneficiaryShares * totalProfit / 100` instead of `/ 50`

The profit calculation occurs here: [5](#0-4) 

Using the stored inflated `TotalShares`: [6](#0-5) 

With the calculation logic: [7](#0-6) 

### Impact Explanation

**Direct Fund Impact:**
- Legitimate beneficiaries receive 50% (or proportionally less) of their deserved profits when cached shares are double the actual shares
- Remaining tokens (50% of distributed profits in the example) are locked in the period's virtual address and become unclaimable
- This is a direct loss of funds for all active beneficiaries in the scheme

**Quantified Damage:**
If a scheme has:
- 100 shares cached at period P
- 50 shares removed with Key=0 before distribution at period P  
- 1000 tokens to distribute at period P

Each remaining beneficiary with 50 shares should receive: `50/50 * 1000 = 1000` tokens
But receives: `50/100 * 1000 = 500` tokens
**Loss per beneficiary: 500 tokens (50%)**

**Who Is Affected:**
- All beneficiaries in profit schemes with `DelayDistributePeriodCount > 0`
- Particularly schemes where managers regularly call `RemoveBeneficiary` for expired shares
- Core AElf economic components (TokenHolder, Treasury) that use delayed profit distribution

**Severity Justification:** HIGH
- Direct, quantifiable loss of funds
- Affects core profit distribution mechanism
- No recovery mechanism for locked tokens in period virtual addresses
- Can occur through normal operational flows (not requiring malicious intent)

### Likelihood Explanation

**Reachable Entry Point:**
`RemoveBeneficiary` is a public function callable by scheme manager or TokenHolder contract: [8](#0-7) 

**Feasible Preconditions:**
1. Profit scheme must have `DelayDistributePeriodCount > 0` (common configuration for staking/rewards)
2. Beneficiary shares must have `EndPeriod == CurrentPeriod` (natural expiration scenario)
3. Manager calls `RemoveBeneficiary` before `DistributeProfits` in the same period

**Execution Practicality:**
- No special privileges required beyond normal manager operations
- Can occur during routine cleanup of expired beneficiaries
- Transaction ordering (RemoveBeneficiary before DistributeProfits) is under manager control
- Common in automated systems that remove expired shares before distributing

**Economic Rationality:**
- Can occur unintentionally through normal operations
- No attack cost (normal transaction fees only)
- If intentional, manager could exploit to retain tokens (though marked as removed)

**Probability Assessment:** MEDIUM-HIGH
- Requires specific timing but occurs in normal operational flows
- More likely in schemes with frequent beneficiary turnover
- Can be triggered accidentally by managers cleaning up expired shares

### Recommendation

**Code-Level Mitigation:**

Modify `RemoveBeneficiary` to handle Key=0 entries appropriately. The shares with `EndPeriod == CurrentPeriod` were included in cache entries created in previous periods, so those cache entries must be updated:

```csharp
// After line 241, before the foreach loop at line 243:
// Handle Key=0 entries (shares expiring at current period)
if (removedDetails.ContainsKey(0) && scheme.DelayDistributePeriodCount > 0)
{
    var expiringShares = removedDetails[0];
    // These shares were included in cache entries created in past periods
    // Update any remaining cache entries that include these shares
    var keysToUpdate = scheme.CachedDelayTotalShares.Keys
        .Where(period => period >= scheme.CurrentPeriod)
        .ToList();
    
    foreach (var period in keysToUpdate)
    {
        scheme.CachedDelayTotalShares[period] = 
            scheme.CachedDelayTotalShares[period].Sub(expiringShares);
    }
}
```

**Invariant Checks:**
Add assertion after line 260 to detect desynchronization:
```csharp
// Verify cache consistency
foreach (var cachedPeriod in scheme.CachedDelayTotalShares.Keys)
{
    Assert(scheme.CachedDelayTotalShares[cachedPeriod] >= 0, 
        "Cache desynchronization detected");
}
```

**Test Cases:**
1. Create scheme with `DelayDistributePeriodCount = 2`
2. Add beneficiary with shares expiring at period P
3. At period P, call `RemoveBeneficiary` then `DistributeProfits`
4. Verify beneficiaries receive correct profit proportion
5. Verify no tokens remain locked in period virtual address

### Proof of Concept

**Initial State:**
- Period 5, `DelayDistributePeriodCount = 2`
- Alice: 50 shares, `EndPeriod = 7`
- Bob: 50 shares, `EndPeriod = 100`
- `TotalShares = 100`

**Transaction Steps:**

1. **Period 5 - Setup Cache:**
   - Call `DistributeProfits(period=5, amount=1000 ELF)`
   - Result: `CachedDelayTotalShares[7] = 100`
   - Tokens distributed based on `totalShares = 0` (delay not reached)

2. **Period 7 - Trigger Vulnerability:**
   - Call `RemoveBeneficiary(beneficiary=Alice)` 
   - `RemoveProfitDetails` finds Alice's share with `EndPeriod == 7`
   - Adds `removedDetails[0] = 50`
   - `RemoveBeneficiary` skips Key=0, doesn't update `CachedDelayTotalShares[7]`
   - Updates `TotalShares = 100 - 50 = 50`

3. **Period 7 - Wrong Distribution:**
   - Call `DistributeProfits(period=7, amount=1000 ELF)`
   - Uses `CachedDelayTotalShares[7] = 100` (line 469)
   - Stores `distributedProfitsInformation.TotalShares = 100` (line 567)

4. **Claim Profits:**
   - Bob calls `ClaimProfits()`
   - Calculation: `50 * 1000 / 100 = 500 ELF` (line 873-874)
   - Bob receives 500 ELF (should receive 1000 ELF)

**Expected vs Actual Result:**
- **Expected:** Bob receives 1000 ELF (100% of profits as only active beneficiary)
- **Actual:** Bob receives 500 ELF (50% due to inflated cached shares)
- **Result:** 500 ELF locked in period 7 virtual address, unrecoverable

**Success Condition:**
The vulnerability is confirmed when `distributedProfitsInformation.TotalShares` (used for profit calculation) is 100 while actual active `TotalShares` is 50, causing beneficiaries to receive half their deserved profits.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L237-239)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L243-258)
```csharp
        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L260-260)
```csharp
        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L364-372)
```csharp
        var weightCanBeRemoved = profitDetails.Details
            .Where(d => d.EndPeriod == scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
        foreach (var profitDetail in weightCanBeRemoved)
        {
            profitDetail.IsWeightRemoved = true;
        }

        var weights = weightCanBeRemoved.Sum(d => d.Shares);
        removedDetails.Add(0, weights);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L567-567)
```csharp
        distributedProfitsInformation.TotalShares = totalShares;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```
