### Title
Round Number Validation Bypass Allows Circumvention of Continuous Blocks Protection

### Summary
For UpdateValue and TinyBlock consensus behaviors, the validation does not verify that the provided round number matches the actual current round number from state. This allows a malicious miner to supply a manipulated round number (e.g., 1 or 2) in the block header's consensus extra data to bypass the continuous blocks validation, enabling unlimited consecutive block production and centralization of the network.

### Finding Description

The root cause exists in the `ValidateBeforeExecution` method which validates consensus information before block execution: [1](#0-0) 

For UpdateValue and TinyBlock behaviors, the validation creates a context with `CurrentRoundNumber` from state but never validates that `extraData.Round.RoundNumber` (the ProvidedRound) matches it. The validation providers are: [2](#0-1) 

Critically, the `ContinuousBlocksValidationProvider` relies on `ProvidedRound.RoundNumber` to determine whether to enforce continuous blocks limits: [3](#0-2) 

When `ProvidedRound.RoundNumber <= 2`, the entire continuous blocks check is skipped. The `RoundTerminateValidationProvider` only validates round numbers for NextRound and NextTerm behaviors: [4](#0-3) 

The consensus extra data for UpdateValue is generated via `GetUpdateValueRound`, which allows setting arbitrary RoundNumber: [5](#0-4) 

Additionally, `ValidateConsensusAfterExecution` fails to catch this discrepancy due to a logic error where it compares the recovered round object with itself: [6](#0-5) 

After line 91 assigns the recovered `currentRound` to `headerInformation.Round`, both variables reference the same object, making the hash comparison always succeed.

### Impact Explanation

**Direct Impact:**
- A malicious miner can bypass the continuous blocks protection designed to prevent any single miner from producing too many consecutive blocks
- This allows centralization of block production, undermining the decentralized nature of the consensus mechanism
- The attacker can monopolize block production during their active period, excluding other miners from their rightful time slots

**Affected Parties:**
- All network participants suffer from reduced decentralization
- Honest miners lose opportunities to produce blocks and earn rewards
- Network resilience is compromised as a single point of failure is introduced

**Severity:** High - This directly violates the "Correct round transitions and time-slot validation, miner schedule integrity" invariant from the critical consensus requirements. While it doesn't directly steal funds, it fundamentally breaks the consensus mechanism's fairness and decentralization guarantees.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a valid miner in the current round (to pass `MiningPermissionValidationProvider`)
- Must control block production to set consensus extra data in block headers
- Technical knowledge to craft malicious consensus extra data

**Attack Complexity:** Low
- Simple manipulation: set `Round.RoundNumber = 1` or `2` while keeping `RoundIdForValidation` matching current round
- The attack requires only modifying two fields in the consensus header data

**Feasibility:** High
- Any miner can produce blocks with custom consensus extra data
- The `TimeSlotValidationProvider` only checks `RoundId` (calculated from expected mining times), not `RoundNumber`: [7](#0-6) 

- No cryptographic or consensus-level barriers prevent this manipulation
- The attack is repeatable and undetectable at the protocol level

**Detection/Operational Constraints:** None - The validation passes successfully, and blocks are accepted by the network as valid.

**Probability:** Medium-High - While requiring miner status, once achieved, the attack is trivial to execute and highly profitable for centralizing control.

### Recommendation

**Primary Fix:** Add explicit round number validation for UpdateValue and TinyBlock behaviors in `ValidateBeforeExecution`:

```csharp
// After line 50 in AEDPoSContract_Validation.cs
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue || 
    extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
{
    if (extraData.Round.RoundNumber != State.CurrentRoundNumber.Value)
        return new ValidationResult 
        { 
            Success = false, 
            Message = $"Provided round number {extraData.Round.RoundNumber} does not match current round number {State.CurrentRoundNumber.Value}." 
        };
}
```

**Secondary Fix:** Correct the `ValidateConsensusAfterExecution` logic to properly compare rounds by cloning before recovery:

```csharp
// Around line 87-92 in AEDPoSContract_ACS4_ConsensusInformationProvider.cs
var currentRound = TryToGetCurrentRoundInformation(out var round) ? round : new Round();
var recoveredRound = currentRound.Clone(); // Add Clone method to Round
if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
    recoveredRound = recoveredRound.RecoverFromUpdateValue(headerInformation.Round, headerInformation.SenderPubkey.ToHex());
// Then compare recoveredRound with currentRound
```

**Test Cases:**
1. Test UpdateValue with `ProvidedRound.RoundNumber = 1` when `CurrentRoundNumber = 10` - should fail validation
2. Test TinyBlock with mismatched round numbers - should fail validation
3. Test that continuous blocks protection still works correctly after the fix
4. Regression test: ensure legitimate UpdateValue/TinyBlock with correct round numbers still pass

### Proof of Concept

**Initial State:**
- Network is at round number 50 (CurrentRoundNumber = 50)
- Attacker is a valid miner in current round
- Attacker has already produced MaximumTinyBlocksCount continuous blocks
- LatestPubkeyToTinyBlocksCount shows attacker's BlocksCount < 0 (limit reached)

**Attack Steps:**
1. Attacker calls `GetConsensusCommand` to determine they should produce an UpdateValue block
2. Attacker generates consensus extra data using `GetConsensusExtraData`
3. **Attacker modifies the consensus extra data before including in block:**
   - Set `Round.RoundNumber = 1` (instead of 50)
   - Keep `Round.RoundIdForValidation = <current round's RoundId>` (to pass RoundId check)
   - Include legitimate mining information (OutValue, Signature, ActualMiningTime, etc.)
4. Attacker submits block with modified consensus extra data

**Validation Flow (Expected vs Actual):**

*Expected (with fix):* Validation fails with "Provided round number 1 does not match current round number 50"

*Actual (without fix):*
- Line 19: `baseRound` fetched from state (round 50)
- Line 47: `RecoverFromUpdateValue` merges attacker's data into `baseRound`
- Line 68: `MiningPermissionValidationProvider` passes (attacker in miner list)
- Line 71: `TimeSlotValidationProvider` passes (RoundIds match, time slot valid)
- Line 74: `ContinuousBlocksValidationProvider` **SKIPPED** (ProvidedRound.RoundNumber = 1 <= 2)
- Line 80: `UpdateValueValidationProvider` passes (consensus information valid)
- Line 82: `LibInformationValidationProvider` passes (LIB check valid)
- Validation succeeds âœ“

**Result:**
- Block accepted despite attacker exceeding continuous blocks limit
- Attacker successfully produces block when they should be blocked
- Attack repeatable indefinitely by continuing to set RoundNumber = 1 or 2
- Network centralization occurs as attacker monopolizes block production

**Success Condition:** Block with manipulated RoundNumber passes all validation and is added to chain, despite violating continuous blocks protection.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-60)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-83)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-14)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L14-16)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L14-17)
```csharp
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-14)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
```
