### Title
Finality Stall Attack via Stagnant Implied Irreversible Block Heights Bypassing Validation

### Summary
The `LibInformationValidationProvider` validation logic only prevents LIB values from decreasing but allows them to remain unchanged, enabling a majority-controlled attack where malicious miners provide non-progressing `ImpliedIrreversibleBlockHeight` values. This causes the Byzantine fault-tolerant LIB calculation to produce stagnant results, completely stalling chain finality while passing all validation checks.

### Finding Description

**Root Cause:**

The validation in `LibInformationValidationProvider.ValidateHeaderInformation()` uses strict inequality checks (`>`) rather than greater-or-equal checks, allowing both `ConfirmedIrreversibleBlockHeight` and individual miner `ImpliedIrreversibleBlockHeight` values to remain unchanged between rounds. [1](#0-0) [2](#0-1) 

**LIB Calculation Mechanism:**

The `LastIrreversibleBlockHeightCalculator` computes LIB by taking implied irreversible heights from miners who produced blocks in the current round, sorting them, and selecting the value at position `(count-1)/3` to achieve Byzantine fault tolerance (2/3 consensus). [3](#0-2) 

The `MinersCountOfConsent` threshold is calculated as `count * 2 / 3 + 1`: [4](#0-3) 

**LIB Update Logic:**

The `ProcessUpdateValue` method only updates `ConfirmedIrreversibleBlockHeight` if the newly calculated LIB is strictly greater than the current value, not when equal: [5](#0-4) 

**Miner-Provided Data:**

Miners provide their `ImpliedIrreversibleBlockHeight` in the `UpdateValueInput`, which is directly assigned to the round state: [6](#0-5) [7](#0-6) 

**Exploitation Path:**

1. Malicious miners controlling >2/3 of mining power produce blocks
2. They provide `ImpliedIrreversibleBlockHeight` values equal to their previous values (no increase)
3. Validation passes because values don't decrease (only `>` check, not `>=`)
4. When LIB is calculated, the majority of sorted implied heights are stagnant
5. The value at position `(count-1)/3` remains unchanged
6. Since calculated LIB equals current `ConfirmedIrreversibleBlockHeight`, no update occurs (line 272 check fails)
7. Chain finality progression completely stalls

### Impact Explanation

**Consensus/Cross-Chain Integrity Breakdown:**

- **Finality Stall**: The chain cannot confirm any new blocks as irreversible, violating the critical invariant that LIB must progress with the chain
- **Cross-Chain Security Failure**: Cross-chain protocols rely on irreversible block heights for safety guarantees. Stalled finality breaks parent-child chain indexing and merkle proof verification
- **Long-Range Attack Enablement**: Without advancing finality, attackers can reorganize the chain arbitrarily deep, potentially double-spending or rewriting history
- **Operational DoS**: Any protocol functionality depending on LIB (cross-chain transfers, treasury releases, election snapshots) becomes permanently blocked

**Severity Justification:** CRITICAL

This attack fundamentally breaks the consensus security model by preventing finality progression while appearing valid to all nodes. It affects the entire chain's ability to provide safety guarantees.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control >2/3 of active miners (majority mining power)
- Ability to modify local consensus data generation (run modified node software)

**Attack Complexity:** LOW
- No complex state manipulation required
- Simply provide stagnant `ImpliedIrreversibleBlockHeight` values in produced blocks
- All validations pass naturally due to weak inequality checks

**Feasibility Conditions:**
- Attack is immediately executable once majority control is achieved
- No economic cost beyond maintaining mining majority
- Undetectable through validation logic (appears as legitimate consensus behavior)

**Detection Constraints:**
- Validators see "valid" consensus data passing all checks
- External monitoring would observe finality stall but cannot prove malicious intent vs. network issues
- No automatic circuit breakers or detection mechanisms exist

**Probability Assessment:** HIGH given majority control

In delegated PoS systems like AEDPoS, if an attacker gains majority delegation through vote manipulation, economic attacks, or cartel formation, this exploit becomes trivial to execute and sustain indefinitely.

### Recommendation

**Immediate Fix:**

Modify `LibInformationValidationProvider.ValidateHeaderInformation()` to enforce forward progress:

1. Add strict progression check for `ConfirmedIrreversibleBlockHeight`:
```csharp
// After line 21, add:
if (providedRound.RoundNumber > baseRound.RoundNumber &&
    providedRound.ConfirmedIrreversibleBlockHeight <= baseRound.ConfirmedIrreversibleBlockHeight)
{
    validationResult.Message = "LIB must progress in new rounds.";
    return validationResult;
}
```

2. Enforce minimum implied height progression for miners:
```csharp
// After line 30, add:
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight < 
    Context.CurrentHeight - AEDPoSContractConstants.MaximumBlocksCount)
{
    validationResult.Message = "Implied height too far behind current height.";
    return validationResult;
}
```

3. Add bounds check on implied heights relative to round progression:
```csharp
// Ensure implied heights are within reasonable range of ConfirmedIrreversibleBlockHeight
var minAcceptableImpliedHeight = providedRound.ConfirmedIrreversibleBlockHeight;
if (providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight < minAcceptableImpliedHeight)
{
    validationResult.Message = "Implied height cannot be below confirmed LIB.";
    return validationResult;
}
```

**Invariant to Enforce:**
- `ImpliedIrreversibleBlockHeight` must be >= `ConfirmedIrreversibleBlockHeight` 
- `ImpliedIrreversibleBlockHeight` must advance reasonably with blockchain height
- Multiple rounds without LIB progression should trigger alerts

**Test Cases:**
1. Test majority miners providing identical implied heights across multiple rounds - should fail validation
2. Test implied height below current LIB - should fail validation
3. Test implied height too far behind current block height - should fail validation
4. Test normal case with progressing implied heights - should pass

### Proof of Concept

**Initial State:**
- 7 active miners in the consensus set
- Current round N with `ConfirmedIrreversibleBlockHeight = 1000`
- Current block height = 1050
- MinersCountOfConsent = 7 * 2 / 3 + 1 = 5

**Attack Execution:**

1. **Round N - Normal miners produce blocks:**
   - Miner A (honest): produces block, `ImpliedIrreversibleBlockHeight = 1050` (current height)
   - Miner B (honest): produces block, `ImpliedIrreversibleBlockHeight = 1051`
   
2. **Round N - Malicious miners produce blocks:**
   - Miner C (malicious): produces block, `ImpliedIrreversibleBlockHeight = 1000` (stagnant)
   - Miner D (malicious): produces block, `ImpliedIrreversibleBlockHeight = 1000` (stagnant)
   - Miner E (malicious): produces block, `ImpliedIrreversibleBlockHeight = 1000` (stagnant)
   - Miner F (malicious): produces block, `ImpliedIrreversibleBlockHeight = 1000` (stagnant)
   - Miner G (malicious): produces block, `ImpliedIrreversibleBlockHeight = 1000` (stagnant)

3. **Validation passes for all blocks:**
   - Each malicious miner's validation: `baseRound.ImpliedIrreversibleBlockHeight (1000) > providedRound.ImpliedIrreversibleBlockHeight (1000)` = FALSE → PASS
   - `ConfirmedIrreversibleBlockHeight` validation: `baseRound (1000) > providedRound (1000)` = FALSE → PASS

4. **LIB Calculation at round end:**
   - Sorted implied heights from miners who mined: [1000, 1000, 1000, 1000, 1000, 1050, 1051]
   - LIB = heights[(7-1)/3] = heights[2] = 1000
   - Check: `currentRound.ConfirmedIrreversibleBlockHeight (1000) < libHeight (1000)` = FALSE
   - **NO UPDATE occurs**

5. **Round N+1 starts:**
   - `ConfirmedIrreversibleBlockHeight` still = 1000 (copied from previous round)
   - Block height now = 1100
   - Malicious miners repeat: all provide `ImpliedIrreversibleBlockHeight = 1000`
   - Cycle continues indefinitely

**Expected Result:** LIB should advance to reflect new consensus
**Actual Result:** LIB permanently stuck at 1000, finality completely stalled

**Success Condition:** After multiple rounds with majority participation, `ConfirmedIrreversibleBlockHeight` remains unchanged despite blockchain height advancing by hundreds of blocks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-282)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** protobuf/aedpos_contract.proto (L217-218)
```text
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
```
