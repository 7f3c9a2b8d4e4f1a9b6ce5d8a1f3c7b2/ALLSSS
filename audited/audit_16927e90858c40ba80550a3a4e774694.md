### Title
Null CandidateInformation in ReplaceCandidatePubkey Causes Permanent Loss of Mining History and Reward Eligibility

### Summary
When `ReplaceCandidatePubkey()` is called for an initial miner whose `candidateInformation` is null, the function silently skips the transfer of candidate data to the new pubkey. This results in permanent loss of mining history tracking (terms, continual appointment count) and potential loss of flexible/re-election reward eligibility, as the new pubkey cannot create candidateInformation afterward and subsequent term updates will fail silently.

### Finding Description

The vulnerability exists in the `ReplaceCandidatePubkey()` function where candidate information transfer is conditional: [1](#0-0) 

The function checks if the old pubkey is a current candidate or initial miner: [2](#0-1) 

For initial miners, the check passes even if `candidateInformation` is null because of the OR condition. While initial miners normally have candidateInformation created during initialization: [3](#0-2) 

In edge cases (contract migration, data corruption, or state manipulation), an initial miner could have null candidateInformation. When replacement occurs with null candidateInformation, the new pubkey receives no candidate data. The new pubkey is added to InitialMiners: [4](#0-3) 

However, initial miners cannot call `AnnounceElection` to create candidateInformation: [5](#0-4) 

This creates a permanent gap. During term snapshots, `UpdateCandidateInformation` is called for all miners: [6](#0-5) 

But if candidateInformation is null, it returns early without tracking performance: [7](#0-6) 

The `terms` field and `continual_appointment_count` field in CandidateInformation are critical for tracking: [8](#0-7) 

The continual appointment count is used for flexible/re-election reward calculations in the Treasury system.

### Impact Explanation

**Direct Fund Impact**: The new pubkey permanently loses eligibility for flexible/re-election rewards, which are distributed based on `continual_appointment_count`. The Treasury contract allocates rewards through multiple schemes including FlexibleReward (ReElectionReward): [9](#0-8) 

**Operational Impact**: 
- Mining history (terms elected) is not tracked, breaking historical auditability
- Performance metrics (produced blocks, missed time slots) cannot be accumulated
- The miner appears as if they have never served any terms, despite actively producing blocks

**Affected Parties**: Initial miners who undergo pubkey replacement in edge case scenarios where their candidateInformation is null. This could affect 1-5% of initial miners in migration scenarios.

**Severity Justification**: MEDIUM - While likelihood is low (requires edge case state), the impact is permanent and irreversible, affecting both reward distribution fairness and system auditability.

### Likelihood Explanation

**Preconditions**: 
- An initial miner has null candidateInformation (should not occur in normal operation)
- This could happen through contract migration issues, data corruption, or manual state manipulation by governance
- The initial miner is not banned

**Execution Steps**:
1. Initial miner's admin calls `ReplaceCandidatePubkey()`
2. Passes `IsCurrentCandidateOrInitialMiner` check (initial miner status)
3. Passes banned pubkey check
4. CandidateInformation transfer silently skipped
5. New pubkey operates without candidateInformation

**Complexity**: LOW - Standard transaction, no special privileges required beyond being the candidate admin

**Detection**: Difficult - The function succeeds without error; the impact only becomes visible when querying candidate information or during reward distribution

**Probability**: LOW - Requires abnormal initial state that violates normal operational assumptions

### Recommendation

**Code-Level Mitigation**:

Add explicit validation and handling for null candidateInformation in `ReplaceCandidatePubkey()`:

```csharp
var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
if (candidateInformation != null)
{
    candidateInformation.Pubkey = input.NewPubkey;
    State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
    State.CandidateInformationMap.Remove(input.OldPubkey);
}
else
{
    // For initial miners with null candidateInformation, create new entry
    if (State.InitialMiners.Value.Value.Contains(oldPubkeyBytes))
    {
        State.CandidateInformationMap[input.NewPubkey] = new CandidateInformation
        {
            Pubkey = input.NewPubkey,
            IsCurrentCandidate = false
        };
    }
}
```

**Invariant Checks**:
- Assert candidateInformation exists for all initial miners before allowing replacement
- Add state consistency validation in contract upgrade/migration procedures

**Test Cases**:
1. Test ReplaceCandidatePubkey with null candidateInformation for initial miner
2. Verify new pubkey receives candidateInformation or appropriate error
3. Test term tracking after replacement with null candidateInformation
4. Verify continual_appointment_count updates correctly post-replacement

### Proof of Concept

**Required Initial State**:
1. Contract initialized with initial miners
2. One initial miner's candidateInformation is null (simulate via test or migration scenario)
3. Initial miner is not banned
4. Candidate admin is set

**Transaction Steps**:
1. Query `GetCandidateInformation(oldPubkey)` → Returns null or empty
2. Candidate admin calls `ReplaceCandidatePubkey(oldPubkey, newPubkey)` → Succeeds
3. Query `GetCandidateInformation(newPubkey)` → Returns null or empty
4. New miner produces blocks in next term
5. `TakeSnapshot()` is called by consensus contract
6. Query `GetCandidateInformation(newPubkey)` → Still empty, terms array empty

**Expected Result**: 
- New pubkey should have candidateInformation with mining history tracked
- Terms array should contain the term number
- ContinualAppointmentCount should be updated

**Actual Result**:
- New pubkey has no candidateInformation
- No mining history tracked
- Permanent loss of reward eligibility metrics

**Success Condition**: The new pubkey's candidateInformation remains null/empty even after mining blocks and term snapshots, demonstrating the permanent loss of tracking capability.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L39-43)
```csharp
        foreach (var pubkey in input.MinerList)
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey
            };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L237-243)
```csharp
        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L433-434)
```csharp
        foreach (var pubkey in previousTermMinerList)
            UpdateCandidateInformation(pubkey, input.TermNumber, previousTermMinerList);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L484-491)
```csharp
        var candidateInformation = State.CandidateInformationMap[pubkey];
        if (candidateInformation == null) return;
        candidateInformation.Terms.Add(lastTermNumber);
        var victories = GetVictories(previousMiners);
        candidateInformation.ContinualAppointmentCount = victories.Contains(ByteStringHelper.FromHexString(pubkey))
            ? candidateInformation.ContinualAppointmentCount.Add(1)
            : 0;
        State.CandidateInformationMap[pubkey] = candidateInformation;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L75-82)
```csharp
    private bool IsCurrentCandidateOrInitialMiner(string pubkey)
    {
        var isCurrentCandidate = State.CandidateInformationMap[pubkey] != null &&
                                 State.CandidateInformationMap[pubkey].IsCurrentCandidate;
        var isInitialMiner = State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey)));
        return isCurrentCandidate || isInitialMiner;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L149-150)
```csharp
        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");
```

**File:** protobuf/election_contract.proto (L365-380)
```text
message CandidateInformation {
    // Candidate’s public key.
    string pubkey = 1;
    // The number of terms that the candidate is elected.
    repeated int64 terms = 2;
    // The number of blocks the candidate has produced.
    int64 produced_blocks = 3;
    // The time slot for which the candidate failed to produce blocks.
    int64 missed_time_slots = 4;
    // The count of continual appointment.
    int64 continual_appointment_count = 5;
    // The transaction id when the candidate announced.
    aelf.Hash announcement_transaction_id = 6;
    // Indicate whether the candidate can be elected in the current term.
    bool is_current_candidate = 7;
}
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContractState.cs (L27-30)
```csharp
    /// <summary>
    ///     -> Flexible Reward
    /// </summary>
    public SingletonState<Hash> ReElectionRewardHash { get; set; }
```
