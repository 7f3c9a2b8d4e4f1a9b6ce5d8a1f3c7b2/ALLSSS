### Title
Quit Candidates Can Bypass Election Restrictions and Become Consensus Validators via InitialMiners List

### Summary
The `IsCurrentCandidateOrInitialMiner()` function fails to distinguish between original bootstrap initial miners and quit candidates who enter the InitialMiners list through pubkey replacement. This allows a candidate who has quit the election to retain privileged operations (SetCandidateAdmin, ReplaceCandidatePubkey) and be selected as a backup consensus validator, bypassing the election process entirely.

### Finding Description

The root cause is in the `IsCurrentCandidateOrInitialMiner()` function which returns true if a pubkey is either a current candidate OR in the InitialMiners list, without verifying whether the pubkey legitimately belongs in InitialMiners: [1](#0-0) 

This check is used to authorize critical operations:
1. **SetCandidateAdmin** - allows changing the admin who controls the candidate [2](#0-1) 

2. **ReplaceCandidatePubkey** - allows replacing a candidate's pubkey [3](#0-2) 

**Attack Path:**

1. Attacker announces election with pubkey A, then quits. The `QuitElection` function sets `IsCurrentCandidate = false` and removes A from the Candidates list: [4](#0-3) [5](#0-4) 

2. An initial miner (pubkey B) with a compromised or malicious admin calls `ReplaceCandidatePubkey(B -> A)`. This adds the quit candidate's pubkey A to InitialMiners while removing B: [6](#0-5) 

3. Now pubkey A is in InitialMiners but has `IsCurrentCandidate = false` and is not in the Candidates list. The pubkey A can now pass the `IsCurrentCandidateOrInitialMiner()` check and perform privileged operations.

4. **Critical Impact**: When `GetVictories()` is called to select miners for consensus and there are insufficient valid candidates, pubkeys from InitialMiners are used as backups without checking their candidate status: [7](#0-6) 

The function adds all InitialMiners to the backup list without verifying if they are current candidates, banned, or legitimately entitled to be initial miners. The quit candidate can thus be selected as a consensus validator.

**Why Existing Protections Fail:**

- Initial miners are prevented from announcing election: [8](#0-7) 

However, this only prevents original initial miners from becoming candidates. It doesn't prevent quit candidates from entering InitialMiners through replacement.

- The `QuitElection` function doesn't remove the pubkey from InitialMiners if it's present there, allowing the quit candidate to retain their position in the list.

### Impact Explanation

**Consensus Integrity Compromise (Critical):**
- A quit candidate who bypasses restrictions becomes a consensus validator without winning election
- They can produce blocks, earn mining rewards, and influence consensus decisions
- This violates the fundamental election-based validator selection mechanism

**Authorization Bypass (High):**
- Quit candidates retain admin management capabilities they should lose upon quitting
- They can perpetually cycle through pubkey replacements to maintain their InitialMiners position
- This creates an unaccountable validator position outside the election system

**Protocol Governance Impact (High):**
- The InitialMiners list is meant for trusted bootstrap nodes, not arbitrary participants
- Allowing quit candidates to occupy these slots undermines the bootstrap security model
- The attacker earns block production rewards without community approval through voting

**Affected Parties:**
- Legitimate candidates who are excluded from miner selection
- Token holders whose votes don't determine all validators
- The overall network security and decentralization

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to announce and quit election (publicly accessible)
- Cooperation from or compromise of an initial miner's admin to authorize `ReplaceCandidatePubkey`

**Attack Complexity:**
The attack requires:
1. Standard election announcement and quit (trivial)
2. Gaining control or cooperation of an initial miner's admin (moderate to difficult depending on governance)
3. Waiting for a period when valid candidates are insufficient (depends on network participation)

**Feasibility Assessment:**
- **Moderate to High**: While requiring initial miner admin cooperation/compromise is a significant barrier, this could occur through:
  - Social engineering or bribery of initial miner admins
  - Exploitation of governance processes if replacements can be forced via proposals
  - Natural key rotation scenarios where security is compromised
  
- The insufficient candidates condition naturally occurs during:
  - Network launch phases
  - Low participation periods
  - After mass candidate withdrawal events

**Economic Rationality:**
- Benefits: Block production rewards, consensus influence, validator status
- Costs: Candidate announcement deposit (recoverable on quit), initial miner admin compromise cost
- The attack is economically rational if mining rewards exceed the cost of compromising an admin

**Detection Difficulty:**
- The attack appears as a legitimate pubkey replacement transaction
- No obvious on-chain indicators distinguish malicious from legitimate replacements
- The quit candidate's historical election participation is preserved but not validated

### Recommendation

**Primary Fix: Add Current Candidate Status Check in GetVictories**

Modify the `GetVictories` backup selection logic to exclude InitialMiners who are not current candidates:

```csharp
if (State.InitialMiners.Value != null)
{
    var validInitialMiners = State.InitialMiners.Value.Value
        .Select(k => k.ToHex())
        .Where(k => !backups.Contains(k))
        .Where(k => {
            var candidateInfo = State.CandidateInformationMap[k];
            // Only include if current candidate OR never announced (original initial miner)
            return candidateInfo == null || candidateInfo.IsCurrentCandidate;
        });
    backups.AddRange(validInitialMiners);
}
```

**Alternative Fix: Track Original Initial Miners Separately**

Create a separate state variable for original initial miners that cannot be modified through replacement:
```csharp
public PubkeyList OriginalInitialMiners { get; set; }
```

Initialize during `InitialElectionContract` and never modify. Use this list for backup miner selection instead of the mutable `InitialMiners` list.

**Additional Hardening:**

1. In `IsCurrentCandidateOrInitialMiner`, verify the pubkey's legitimacy:
```csharp
private bool IsCurrentCandidateOrInitialMiner(string pubkey)
{
    var isCurrentCandidate = State.CandidateInformationMap[pubkey] != null &&
                             State.CandidateInformationMap[pubkey].IsCurrentCandidate;
    var isInitialMiner = State.InitialMiners.Value.Value.Contains(
        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey)));
    
    // If in InitialMiners but not current candidate, verify they never announced election
    if (isInitialMiner && !isCurrentCandidate)
    {
        var candidateInfo = State.CandidateInformationMap[pubkey];
        if (candidateInfo != null && candidateInfo.AnnouncementTransactionId != Hash.Empty)
        {
            // This was a candidate who announced election - should not have privileges
            return false;
        }
    }
    
    return isCurrentCandidate || isInitialMiner;
}
```

2. Add validation in `ReplaceCandidatePubkey` to prevent quit candidates from being added to InitialMiners:
```csharp
// Before line 220-226
if (initialMiners.Value.Contains(oldPubkeyBytes))
{
    var newCandidateInfo = State.CandidateInformationMap[input.NewPubkey];
    Assert(newCandidateInfo == null || newCandidateInfo.IsCurrentCandidate,
        "Cannot replace initial miner with quit candidate.");
    // ... existing replacement logic
}
```

**Test Cases to Add:**
1. Test that quit candidates in InitialMiners cannot be selected as backup miners
2. Test that quit candidates cannot call SetCandidateAdmin even if in InitialMiners
3. Test that ReplaceCandidatePubkey rejects new pubkeys that are quit candidates
4. Test original initial miners retain their privileges correctly

### Proof of Concept

**Initial State:**
- System initialized with initial miner pubkey B in InitialMiners list
- Initial miner B has admin address Admin_B
- Attacker controls address Attacker and pubkey A

**Step 1: Attacker announces and quits election**
```
Transaction 1: AnnounceElection(Admin_Attacker) 
  - Sender: Attacker (pubkey A)
  - Result: A added to Candidates, IsCurrentCandidate = true

Transaction 2: QuitElection(pubkey A)
  - Sender: Admin_Attacker
  - Result: A.IsCurrentCandidate = false, A removed from Candidates
```

**Step 2: Initial miner admin replaces their pubkey**
```
Transaction 3: ReplaceCandidatePubkey(OldPubkey: B, NewPubkey: A)
  - Sender: Admin_B (compromised/malicious)
  - Result: 
    * B removed from InitialMiners
    * A added to InitialMiners
    * B banned
    * A inherits B's candidate information
```

**Step 3: Verify bypass of restrictions**
```
Transaction 4: SetCandidateAdmin(Pubkey: A, Admin: NewAdmin)
  - Sender: Admin_Attacker
  - Expected: Should fail (A is quit candidate)
  - Actual: SUCCESS (A in InitialMiners passes IsCurrentCandidateOrInitialMiner check)
```

**Step 4: Attacker selected as backup miner**
```
State Check: Assume only 2 valid candidates but MinersCount = 5
Call: GetVictories()
  - Expected: Should not include A (quit candidate)
  - Actual: A included in backup list from InitialMiners
  - Result: A becomes consensus validator without election
```

**Success Condition:**
The attacker's quit candidate pubkey A:
1. Passes authorization checks for SetCandidateAdmin ✓
2. Appears in InitialMiners list ✓
3. Gets selected as backup miner in GetVictories ✓
4. Can produce blocks and earn rewards ✓

All while having `IsCurrentCandidate = false` and not being in the Candidates list, demonstrating complete bypass of election-based validator selection.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L21-22)
```csharp
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L75-82)
```csharp
    private bool IsCurrentCandidateOrInitialMiner(string pubkey)
    {
        var isCurrentCandidate = State.CandidateInformationMap[pubkey] != null &&
                                 State.CandidateInformationMap[pubkey].IsCurrentCandidate;
        var isInitialMiner = State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey)));
        return isCurrentCandidate || isInitialMiner;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L149-150)
```csharp
        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L252-254)
```csharp
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L298-298)
```csharp
        State.Candidates.Value.Value.Remove(publicKeyByteString);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L175-176)
```csharp
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L62-76)
```csharp
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
```
