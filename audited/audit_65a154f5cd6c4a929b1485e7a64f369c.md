### Title
Missing Input Validation in Contract Proposal Expiration Period Configuration Enables Governance DoS

### Summary
The `SetContractProposalExpirationTimePeriod` method lacks input validation, allowing a compromised ContractDeploymentController to set the expiration period to 0 or Int32.MaxValue. Setting it to 0 causes all contract deployment/update proposals to expire immediately upon creation, completely blocking the contract deployment system. Setting it to Int32.MaxValue (~68 years) causes proposals to never expire, leading to governance pollution.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The `SetContractProposalExpirationTimePeriod` method accepts any int32 value without validation and directly stores it in state.

**Root Cause:**
The method lacks the basic bounds check that exists in the similar `SetCodeCheckProposalExpirationTimePeriod` method: [2](#0-1) 

**Why Protections Fail:**

1. **For ExpirationTimePeriod = 0:**
   - The helper function returns the configured value: [3](#0-2) 
   
   - When registering proposals, ExpiredTime becomes equal to CurrentBlockTime: [4](#0-3) 
   
   - This same expired time is used when creating Parliament proposals: [5](#0-4) 
   
   - Parliament validation requires proposals NOT to be expired: [6](#0-5) 
   
   - The validation is enforced on all proposal operations (Approve, Reject, Abstain, Release): [7](#0-6) 
   
   - Since `CurrentBlockTime >= ExpiredTime` immediately after creation, all validation fails with "Invalid proposal."

2. **For ExpirationTimePeriod = Int32.MaxValue:**
   - Proposals expire ~68 years in the future, effectively never expiring in practice.

**Authorization Required:**
The method requires sender to be the ContractDeploymentController's OwnerAddress (typically a Parliament organization): [1](#0-0) 

### Impact Explanation

**Value = 0 Impact:**
- **Complete DoS of contract deployment/update system**: All contract deployment and update proposals through `ProposeNewContract` and `ProposeUpdateContract` become immediately expired and cannot be approved, rejected, or released.
- **System-wide freeze**: No new contracts can be deployed and no existing contracts can be updated until governance passes another proposal to fix the configuration.
- **Affects entire blockchain**: All users and developers are unable to deploy or update smart contracts.

**Value = Int32.MaxValue Impact:**
- **Governance pollution**: Proposals remain valid for ~68 years, allowing attackers to keep stale/malicious proposals indefinitely.
- **Storage bloat**: Expired proposals cannot be properly cleared, consuming chain resources.
- **Confusion and potential exploitation**: Valid-looking but outdated proposals can be executed long after their intended timeframe.

The default value is 259200 seconds (72 hours), demonstrating the intended reasonable timeframe: [8](#0-7) 

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control of ContractDeploymentController organization (typically requires majority of miners/validators)
- Ability to create and pass a Parliament proposal

**Attack Complexity:**
- Low technical complexity once governance control is achieved
- Single transaction to change configuration
- Immediate and persistent effect across all future proposals

**Feasibility Conditions:**
- Requires compromised governance (malicious or negligent Parliament majority)
- No on-chain detection mechanisms exist for invalid configuration values
- Once set, affects all subsequent operations until fixed

**Probability Reasoning:**
Medium likelihood - while it requires compromised governance, the lack of validation makes it trivial to execute if governance is compromised. The impact is catastrophic enough that even accidental misconfiguration (e.g., typo setting value to 0) would cause complete system failure.

### Recommendation

**Code-Level Mitigation:**
Add input validation to `SetContractProposalExpirationTimePeriod` matching the protection in `SetCodeCheckProposalExpirationTimePeriod`:

```csharp
public override Empty SetContractProposalExpirationTimePeriod(SetContractProposalExpirationTimePeriodInput input)
{
    AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
    Assert(input.ExpirationTimePeriod > 0, "Invalid expiration time period.");
    Assert(input.ExpirationTimePeriod <= MaxContractProposalExpirationTimePeriod, "Expiration time period too large.");
    State.ContractProposalExpirationTimePeriod.Value = input.ExpirationTimePeriod;
    return new Empty();
}
```

**Invariant Checks:**
- Minimum value: > 0 (prevents immediate expiration)
- Maximum value: â‰¤ reasonable upper bound (e.g., 30 days = 2,592,000 seconds) to prevent governance pollution

**Test Cases:**
1. Test setting value to 0 - should fail
2. Test setting negative values - should fail  
3. Test setting Int32.MaxValue - should fail
4. Test setting value above reasonable maximum - should fail
5. Test setting valid values (e.g., 86400, 259200) - should succeed
6. Regression test ensuring proposals created with valid configuration can complete their lifecycle

### Proof of Concept

**Initial State:**
- Parliament organization is compromised by attacker (or malicious governance actors)
- Default ContractProposalExpirationTimePeriod = 259200 seconds
- Contract deployment system functioning normally

**Attack Sequence:**

1. **Attacker creates Parliament proposal** to call `SetContractProposalExpirationTimePeriod` with `ExpirationTimePeriod = 0`

2. **Proposal gets approved** by compromised Parliament (majority miners vote in favor)

3. **Proposal is released**, executing `SetContractProposalExpirationTimePeriod(0)`
   - Configuration stored: `State.ContractProposalExpirationTimePeriod.Value = 0`

4. **Legitimate user attempts to deploy contract** via `ProposeNewContract`:
   - Line 208: `GetCurrentContractProposalExpirationTimePeriod()` returns 0
   - Line 213: `ExpiredTime = CurrentBlockTime.AddSeconds(0)` = CurrentBlockTime
   - Parliament proposal created with ExpiredTime = CurrentBlockTime

5. **Any miner attempts to approve** the proposal:
   - `GetValidProposal()` is called
   - `CheckProposalNotExpired()` checks: `CurrentBlockTime < ExpiredTime`
   - Check fails because CurrentBlockTime >= ExpiredTime
   - Transaction fails with "Invalid proposal."

6. **Result:** All contract deployment/update operations are permanently blocked until governance passes another proposal to restore a valid expiration period value.

**Expected vs Actual:**
- **Expected:** Proposals should have reasonable expiration timeframe (72 hours default)
- **Actual:** With value = 0, proposals expire immediately and cannot be executed. With value = Int32.MaxValue, proposals never expire.

**Success Condition:** 
Transaction attempting to approve any contract deployment/update proposal fails with "Invalid proposal" error, demonstrating complete DoS of the contract deployment system.

### Notes
This vulnerability is particularly critical because it affects the core governance and contract upgrade mechanism of the entire blockchain. The inconsistency between validation in `SetCodeCheckProposalExpirationTimePeriod` (which has proper checks) and `SetContractProposalExpirationTimePeriod` (which lacks checks) suggests this was an oversight rather than intentional design.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L122-173)
```csharp
    public override Hash ProposeNewContract(ContractDeploymentInput input)
    {
        // AssertDeploymentProposerAuthority(Context.Sender);
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();

        if (input.ContractOperation != null)
        {
            ValidateContractOperation(input.ContractOperation, 0, codeHash);
            
            // Remove one time signer if exists. Signer is only needed for validating signature.
            RemoveOneTimeSigner(input.ContractOperation.Deployer);
            
            AssertContractAddressAvailable(input.ContractOperation.Deployer, input.ContractOperation.Salt);
        }

        // Create proposal for deployment
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName =
                    nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.ProposeContractCodeCheck),
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(DeploySmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = input.Category,
                    IsSystemContract = false
                }.ToByteString(),
                OrganizationAddress = State.ContractDeploymentController.Value.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
            },
            OriginProposer = Context.Sender
        };
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput.ToByteString());

        Context.Fire(new ContractProposed
        {
            ProposedContractInputHash = proposedContractInputHash
        });

        return proposedContractInputHash;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L394-398)
```csharp
    public override Empty SetContractProposalExpirationTimePeriod(SetContractProposalExpirationTimePeriodInput input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        State.ContractProposalExpirationTimePeriod.Value = input.ExpirationTimePeriod;
        return new Empty();
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L401-406)
```csharp
    public override Empty SetCodeCheckProposalExpirationTimePeriod(Int32Value input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        Assert(input.Value > 0, "Invalid expiration time period.");
        State.CodeCheckProposalExpirationTimePeriod.Value = input.Value;
        return new Empty();
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L282-287)
```csharp
    private int GetCurrentContractProposalExpirationTimePeriod()
    {
        return State.ContractProposalExpirationTimePeriod.Value == 0
            ? ContractProposalExpirationTimePeriod
            : State.ContractProposalExpirationTimePeriod.Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L177-180)
```csharp
    private bool CheckProposalNotExpired(ProposalInfo proposal)
    {
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L182-188)
```csharp
    private ProposalInfo GetValidProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        Assert(proposal != null, "Proposal not found.");
        Assert(Validate(proposal), "Invalid proposal.");
        return proposal;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-5)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
```
