# Audit Report

## Title
Improper Stale Miner Check Bypass When Miner List Changes Leads to Transaction Failures and Unauthorized Actions

## Summary
The `IsCurrentMiner` method contains a critical flaw in its handling of the `IsMinerListJustChanged` flag. When set to true, the miner existence check is bypassed, causing unhandled exceptions for replaced miners and allowing replaced extra block producers to retain miner privileges during round transitions, even after being identified as malicious.

## Finding Description

The vulnerability exists in the `IsCurrentMiner` method's handling of replaced miners when the miner list changes. [1](#0-0) 

When `IsMinerListJustChanged` is true, this condition bypasses the critical containment check that verifies the miner exists in the current round. The flag is correctly set during miner replacement: [2](#0-1) 

And properly propagated to the next round: [3](#0-2) 

However, the `ConvertAddressToPubkey` helper searches both current and previous rounds: [4](#0-3) 

This allows replaced miners (present in previous round but removed from current round) to have their public key returned. When `IsCurrentMiner` is called with this pubkey:

1. The containment check is bypassed (lines 142-144)
2. Unless they're the extra block producer during transition (lines 150-155), execution continues
3. Direct dictionary access occurs without verification: [5](#0-4) 

This causes a `KeyNotFoundException` because the replaced miner doesn't exist in the current round.

Additionally, replaced miners who were the extra block producer pass the transition check: [6](#0-5) 

The extra block producer is set during round generation: [7](#0-6) 

This occurs AFTER miner replacement, allowing identified evil miners to retain privileges.

## Impact Explanation

**Primary Impact - Transaction Failures:** Replaced miners attempting to call miner-only functions like `ClaimTransactionFees`: [8](#0-7) 

Or cross-chain indexing operations: [9](#0-8) 

Will experience unhandled `KeyNotFoundException` exceptions, causing transaction failures and exposing implementation flaws.

**Secondary Impact - Unauthorized Actions:** Replaced miners who were the extra block producer can continue performing miner-only actions during the transition window, even after being identified as malicious. This violates the security invariant that replaced (potentially evil) miners should have all privileges immediately revoked. They can:

- Produce blocks during transition
- Call miner-only functions including cross-chain indexing
- Potentially inject malicious cross-chain data before the new round officially starts

The permission check at: [10](#0-9) 

Relies on the consensus contract's `IsCurrentMiner` which allows these replaced miners through.

## Likelihood Explanation

**Primary Impact Likelihood:** Medium - Miner replacement occurs regularly when miners miss time slots or are detected as malicious: [11](#0-10) 

Replaced miners could manually attempt to call miner-only functions, triggering the exception.

**Secondary Impact Likelihood:** Medium-High - Whenever a replaced miner was the extra block producer, they automatically retain privileges during the transition window. This is a deterministic vulnerability that occurs regularly during normal consensus operations when evil miners are detected and replaced.

## Recommendation

1. **Add explicit containment check before dictionary access:**

After line 144, always verify the pubkey exists in the current round before accessing the dictionary, even when `IsMinerListJustChanged` is true:

```csharp
if (!currentRound.IsMinerListJustChanged)
    if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return false;

// Add this check for replaced miners
if (currentRound.IsMinerListJustChanged && 
    !currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
{
    // Only allow if they're the extra block producer during transition
    if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
        currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        return true;
    return false;
}
```

2. **Revoke extra block producer privileges for replaced miners:**

When setting `ExtraBlockProducerOfPreviousRound`, check if the miner was replaced:

```csharp
GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

// Don't grant transition privileges to replaced miners
if (nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
    nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
else
    nextRound.ExtraBlockProducerOfPreviousRound = null; // or assign to new extra block producer
```

## Proof of Concept

This vulnerability can be demonstrated by:

1. Setting up a scenario where miner replacement occurs
2. Having the replaced miner attempt to call `ProposeCrossChainIndexing`
3. Observing the `KeyNotFoundException` for non-extra-block-producers
4. Observing successful execution for replaced extra block producers during the transition window

The vulnerability is triggered through the normal consensus flow when `IsMinerListJustChanged` is true, making it reproducible in production environments whenever miner replacement occurs.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L125-134)
```csharp
    private string ConvertAddressToPubkey(Address address)
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);

        return possibleKeys.FirstOrDefault(k =>
            Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)) == address);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L142-144)
```csharp
        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L149-155)
```csharp
        // Check confirmed extra block producer of previous round.
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L157-159)
```csharp
        var miningInterval = currentRound.GetMiningInterval();
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L298-346)
```csharp
        var isMinerListChanged = false;
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }

        currentRound.GenerateNextRoundInformation(currentBlockTime, blockchainStartTimestamp, out nextRound,
            isMinerListChanged);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-14)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-178)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-869)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L897-906)
```csharp
    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-286)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
```
