### Title
Genesis Contract Methods Execute With Only Size Fees When Base Fees Not Configured

### Summary
The Genesis contract's `GetMethodFee()` returns null for unconfigured methods, causing the fee collection system to skip base fee charging and only apply minimal transaction size fees. This allows expensive contract deployment operations like `ProposeNewContract` and `DeployUserSmartContract` to execute at drastically reduced cost, enabling spam attacks that exhaust network resources and create state bloat through cheap proposal generation.

### Finding Description

The Genesis contract implements a non-standard fee handling pattern compared to other system contracts. In `GetMethodFee()`, when a method has no configured fees in `State.TransactionFees`, the function returns `null` directly (except for the special case of `ReleaseApprovedUserSmartContract`). [1](#0-0) 

In contrast, other system contracts like VoteContract and ProfitContract return default base fees (typically 1-10 ELF) when fees are unconfigured: [2](#0-1) [3](#0-2) 

When `ChargeTransactionFees` in the token contract receives a null response from `GetMethodFee()`, it initializes an empty fee dictionary and skips base fee charging entirely: [4](#0-3) 

The charging logic then bypasses base fee collection when the fee dictionary is empty: [5](#0-4) 

This means only the transaction size fee is charged, which is typically minimal compared to the computational cost of operations like:
- `ProposeNewContract` - validates code, computes hashes, stores state, creates governance proposals
- `DeployUserSmartContract` - performs code checks, generates proposals, stores contract metadata
- `ProposeUpdateContract` - validates updates, creates proposals
- `UpdateUserSmartContract` - validates and proposes contract updates

These methods are publicly accessible. For mainchain, `DeployUserSmartContract` only requires `Context.Origin == Context.Sender`: [6](#0-5) 

And `ProposeNewContract` has no direct authorization check beyond validation that the contract doesn't already exist: [7](#0-6) 

### Impact Explanation

**Resource Exhaustion**: Attackers can spam contract deployment proposals by repeatedly calling `ProposeNewContract` or `DeployUserSmartContract`, paying only minimal transaction size fees instead of appropriate base fees for these computationally expensive operations. Each call involves:
- SHA256 hash computation of contract code
- State writes to `ContractProposingInputMap`
- Cross-contract calls to Parliament/governance contracts for proposal creation
- Event generation and logging

**State Bloat**: Each proposal consumes blockchain state storage in `State.ContractProposingInputMap` and the Parliament contract's proposal storage. Without appropriate fee barriers, an attacker could create thousands of proposals cheaply, permanently bloating chain state.

**Network DoS**: Block producers must execute these expensive operations during transaction processing. Mass creation of proposals could slow down block production and validation, affecting overall network performance.

**Economic Impact**: The disparity between actual computational cost (code validation, state storage, cross-contract calls) and fees paid (only transaction size) represents a market inefficiency that attackers can exploit. While legitimate users eventually need governance approval for proposals, the initial proposal spam costs minimal fees but imposes maximum burden on the network.

**Affected Users**: All network participants suffer from degraded performance and increased state sync costs. Block producers bear the computational burden of processing spam transactions.

### Likelihood Explanation

**Attack Complexity**: LOW - Exploitation requires only repeated calls to public methods with valid (but spam) contract code. No special permissions or complex setup needed.

**Preconditions**: The vulnerability manifests when Parliament governance has not explicitly configured fees for expensive Genesis contract methods via `SetMethodFee`. Tests show fees CAN be configured via governance proposals: [8](#0-7) 

However, there's no evidence of default fee initialization during chain bootstrap. The Genesis contract lacks the default fee pattern seen in other contracts, and no initialization code sets these fees automatically.

**Economic Rationality**: HIGHLY FAVORABLE for attackers. Transaction size fees are typically orders of magnitude smaller than appropriate base fees for contract deployment operations. An attacker could generate hundreds of spam proposals for the cost of a single legitimate contract deployment with proper fees.

**Detection Difficulty**: MODERATE - While individual spam proposals are visible on-chain, distinguishing between legitimate failed deployment attempts and malicious spam requires analysis of patterns and proposer behavior. By the time spam is identified, state bloat has already occurred.

**Exploitability Window**: PERSISTENT - Until governance explicitly configures fees for all expensive Genesis contract methods, this vulnerability remains exploitable. Given the need for explicit Parliament proposals to set each method's fee, there may be extended periods where some methods lack proper fee configuration.

### Recommendation

**Immediate Fix**: Implement default base fees in the Genesis contract's `GetMethodFee()` function, following the pattern used by VoteContract and ProfitContract. Return sensible default fees (e.g., 10 ELF for expensive operations like `ProposeNewContract`, `DeployUserSmartContract`) when `State.TransactionFees[input.Value]` is null:

```csharp
public override MethodFees GetMethodFee(StringValue input)
{
    var fees = State.TransactionFees[input.Value];
    if (fees != null) return fees;
    
    if (input.Value == nameof(ReleaseApprovedUserSmartContract))
    {
        return new MethodFees
        {
            MethodName = input.Value,
            IsSizeFeeFree = true
        };
    }
    
    // Add default fees for expensive operations
    switch (input.Value)
    {
        case nameof(ProposeNewContract):
        case nameof(ProposeUpdateContract):
        case nameof(DeployUserSmartContract):
        case nameof(UpdateUserSmartContract):
            return new MethodFees
            {
                MethodName = input.Value,
                Fees = { new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 } }
            };
        default:
            return new MethodFees
            {
                MethodName = input.Value,
                Fees = { new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 1_00000000 } }
            };
    }
}
```

**Governance Action**: Immediately propose and approve SetMethodFee transactions through Parliament for all expensive Genesis contract methods, setting appropriate base fees that reflect their computational cost.

**Testing**: Add test cases that verify:
1. All expensive methods have non-null fees returned from `GetMethodFee()`
2. Repeated calls to contract deployment methods deduct appropriate fees
3. Spam attacks are economically infeasible due to proper fee barriers

**Monitoring**: Implement chain analysis tools to detect proposal spam patterns and alert when unusual volumes of contract proposals are created from single addresses.

### Proof of Concept

**Initial State**:
- Genesis contract deployed with current implementation
- No explicit fees configured for `ProposeNewContract` via `SetMethodFee`
- Attacker has minimal ELF balance (e.g., 100 ELF)

**Attack Steps**:

1. Attacker calls `GetMethodFee("ProposeNewContract")` on Genesis contract
   - **Expected**: Returns null
   - **Actual**: Returns null

2. Attacker generates 100 different contract code samples (varying by random bytes)

3. For each code sample, attacker calls `ProposeNewContract` with:
   ```
   ContractDeploymentInput {
       Category: KernelConstants.DefaultRunnerCategory,
       Code: <spam_contract_bytes>
   }
   ```

4. Fee collection system calls `ChargeTransactionFees`:
   - Calls `GetMethodFee("ProposeNewContract")` â†’ receives null
   - Sets `fee` dictionary to empty
   - Skips base fee charging (`fee.Count == 0`)
   - Only charges minimal transaction size fee (~0.001 ELF per transaction)

5. Each `ProposeNewContract` call:
   - Computes code hash (expensive)
   - Stores proposal in `State.ContractProposingInputMap`
   - Creates Parliament proposal (cross-contract call)
   - Fires `ContractProposed` event

**Expected Result**: Each contract proposal should cost ~10 ELF base fee + size fee

**Actual Result**: Each contract proposal costs only ~0.001 ELF size fee

**Success Condition**: Attacker creates 100 spam proposals for ~0.1 ELF total cost (should cost ~1000 ELF with proper fees), causing:
- 100 entries in `ContractProposingInputMap` 
- 100 Parliament proposals created
- Significant computational burden on block producers
- State bloat requiring additional storage/sync costs for all nodes

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L34-47)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var fees = State.TransactionFees[input.Value];
        if (fees == null && input.Value == nameof(ReleaseApprovedUserSmartContract))
        {
            fees = new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        }

        return fees;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L35-59)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var tokenAmounts = State.TransactionFees[input.Value];
        if (tokenAmounts != null) return tokenAmounts;

        switch (input.Value)
        {
            case nameof(Register):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
            default:
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 1_00000000 }
                    }
                };
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L35-59)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var methodFees = State.TransactionFees[input.Value];
        if (methodFees != null) return methodFees;

        switch (input.Value)
        {
            case nameof(CreateScheme):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
            default:
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 1_00000000 }
                    }
                };
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-52)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L278-283)
```csharp
        if (fee.Count != 0)
        {
            // If base fee is set before, charge base fee.
            successToChargeBaseFee =
                ChargeBaseFee(fee, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L384-388)
```csharp
    private void AssertInlineDeployOrUpdateUserContract()
    {
        Assert(Context.Origin == Context.Sender || !IsMainChain(),
            "Deploy or update contracts using inline transactions is not allowed.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L122-173)
```csharp
    public override Hash ProposeNewContract(ContractDeploymentInput input)
    {
        // AssertDeploymentProposerAuthority(Context.Sender);
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();

        if (input.ContractOperation != null)
        {
            ValidateContractOperation(input.ContractOperation, 0, codeHash);
            
            // Remove one time signer if exists. Signer is only needed for validating signature.
            RemoveOneTimeSigner(input.ContractOperation.Deployer);
            
            AssertContractAddressAvailable(input.ContractOperation.Deployer, input.ContractOperation.Salt);
        }

        // Create proposal for deployment
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName =
                    nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.ProposeContractCodeCheck),
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(DeploySmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = input.Category,
                    IsSystemContract = false
                }.ToByteString(),
                OrganizationAddress = State.ContractDeploymentController.Value.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
            },
            OriginProposer = Context.Sender
        };
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput.ToByteString());

        Context.Fire(new ContractProposed
        {
            ProposedContractInputHash = proposedContractInputHash
        });

        return proposedContractInputHash;
    }
```

**File:** test/AElf.Contracts.EconomicSystem.Tests/BVT/TransactionFeeProviderTests.cs (L110-122)
```csharp
    public async Task Genesis_FeeProvider_Test()
    {
        await ExecuteProposalForParliamentTransaction(ContractZeroAddress, MethodName, new MethodFees
        {
            MethodName = nameof(BasicContractZeroStub.DeploySmartContract),
            Fees = { TokenAmount }
        });
        var result = await BasicContractZeroStub.GetMethodFee.CallAsync(new StringValue
        {
            Value = nameof(BasicContractZeroStub.DeploySmartContract)
        });
        result.Fees.First().ShouldBe(TokenAmount);
    }
```
