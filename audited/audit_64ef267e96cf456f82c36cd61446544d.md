### Title
Code Hash Collision Enables Permanent Blocking of Legitimate Contract Deployments

### Summary
The `ProposeNewContract` function only validates code hash uniqueness against already-deployed contracts, not against pending proposals. An attacker can front-run a legitimate proposal by submitting an identical code with different parameters (e.g., different category), creating a separate proposal that races to deployment. Whichever proposal deploys first permanently blocks all others with the same code hash, causing denial-of-service and transferring contract authorship to the attacker.

### Finding Description

The vulnerability exists in the contract proposal and deployment flow in the Genesis contract.

In `ProposeNewContract`, the code hash uniqueness check occurs at line 126: [1](#0-0) 

This check calls `AssertContractNotExists`, which only validates against deployed contracts stored in `State.SmartContractRegistrations`: [2](#0-1) 

The `proposedContractInputHash` used to track proposals is calculated from the entire `ContractDeploymentInput` structure: [3](#0-2) 

The `ContractDeploymentInput` structure contains three fields - category, code, and contract_operation: [4](#0-3) 

The proposal registration checks for duplicate `proposedContractInputHash` but NOT duplicate `codeHash`: [5](#0-4) 

**Root Cause**: Two proposals with identical code but different category or contract_operation values will have:
- Different `proposedContractInputHash` → pass the "Already proposed" check
- Identical `codeHash` → both pass `AssertContractNotExists` initially since nothing is deployed yet

The code hash is only registered in `State.SmartContractRegistrations` when actual deployment occurs: [6](#0-5) 

When the first proposal deploys successfully, it registers the code hash. Any subsequent deployment attempt with the same code hash fails at the `AssertContractNotExists` check in `DeploySmartContract`: [7](#0-6) 

**Why Protections Fail**: The system tracks proposals by their full input hash, not by code hash. This allows multiple proposals with identical code but different metadata to coexist in the proposal system simultaneously, racing to deployment.

### Impact Explanation

**Concrete Harm**:
1. **Permanent Deployment Blocking**: The legitimate user's proposal becomes undeployable. Even after governance approval and code checks, the deployment transaction fails irreversibly with "contract code has already been deployed before."

2. **Loss of Contract Authorship**: The first deployer gains authorship rights. The contract author field determines permission for critical operations:
   - Only the author can update the contract code: [8](#0-7) 
   
   - Only the author can transfer authorship: [9](#0-8) 

3. **Governance Resource Waste**: The victim's proposal consumes governance voting resources and code checking effort, only to fail at the final deployment step.

**Who is Affected**: Any user proposing contract deployments, particularly:
- Projects deploying critical infrastructure contracts
- Users deploying high-value DeFi or NFT contracts
- Scenarios where contract address or authorship has strategic importance

**Severity Justification**: HIGH - This enables a griefing attack with permanent consequences. The victim loses not just the ability to deploy, but also loses control over future contract updates. The attack can be used to steal valuable contract addresses or block competitors from deploying.

### Likelihood Explanation

**Attacker Capabilities Required**:
- Ability to monitor on-chain proposals (public information)
- Ability to submit contract deployment proposals (available to any user)
- Ability to get their proposal approved through governance (requires some coordination but not majority control)

**Attack Complexity**: MEDIUM
1. Monitor for `ContractProposed` events indicating new deployment proposals
2. Extract the contract code from the proposal parameters
3. Submit an identical proposal with modified category value (e.g., change category from 0 to 1)
4. Navigate both proposals through governance simultaneously or sequentially
5. Ensure attacker's proposal deploys first by timing the final `ReleaseCodeCheckedContract` call

**Feasibility Conditions**:
- The governance process in AElf involves multiple steps (Parliament approval → code check proposal → code check approval), providing a time window of hours to days
- Both proposals can proceed through governance in parallel since they have different `proposedContractInputHash` values
- The attacker doesn't need to control governance; they only need to participate in it
- The attack can succeed even if the attacker's proposal is approved slightly later, as long as they deploy first

**Detection Constraints**: The attack is difficult to prevent because:
- Contract code in proposals is public (required for code checking)
- The system allows multiple proposals with the same code
- No mechanism exists to reserve code hashes during the proposal phase

**Probability**: MEDIUM-HIGH in adversarial scenarios where valuable contracts are being deployed, particularly during initial ecosystem setup or when deploying strategically important infrastructure.

### Recommendation

**Immediate Mitigation**:

1. **Add Code Hash Proposal Tracking**: Track all pending proposals by code hash, not just by input hash. In `ProposeNewContract`, after computing the code hash, check both deployed contracts AND pending proposals:

```csharp
// In ProposeNewContract, after line 125
var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
AssertContractNotExists(codeHash);
AssertCodeHashNotProposed(codeHash); // NEW CHECK
```

2. **Implement Code Hash Reservation**: Add a new state mapping to track code hashes in pending proposals:

```csharp
// In BasicContractZeroState.cs
public MappedState<Hash, ContractProposingInput> ProposedCodeHashes { get; set; }
```

3. **Register Code Hash on Proposal**: Store the code hash when proposal is registered:

```csharp
// In RegisterContractProposingData or ProposeNewContract
State.ProposedCodeHashes[codeHash] = new ContractProposingInput {
    Proposer = Context.Sender,
    Status = ContractProposingInputStatus.Proposed,
    ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
};
```

4. **Clear on Deployment or Expiration**: Remove the code hash reservation when:
   - The contract is successfully deployed
   - The proposal expires
   - The proposal is explicitly cancelled

**Invariant to Add**:
- At any given time, a code hash can exist in at most ONE of: deployed contracts (`State.SmartContractRegistrations`) OR pending proposals (`State.ProposedCodeHashes`)

**Test Cases to Prevent Regression**:
1. Test that attempting to propose two contracts with identical code but different categories fails on the second attempt
2. Test that expired proposals release their code hash reservation
3. Test that successful deployment clears the code hash from pending proposals
4. Test that proposal cancellation releases the code hash

### Proof of Concept

**Required Initial State**:
- Genesis contract deployed and initialized
- Parliament governance configured
- Code check authority configured
- At least two users with proposal rights

**Attack Sequence**:

1. **Victim proposes contract**:
   - User A calls `ProposeNewContract` with `ContractDeploymentInput{category: 0, code: C, contract_operation: null}`
   - Transaction succeeds, returns `proposedContractInputHash = H1`
   - `codeHash = HashHelper.ComputeFrom(C)` stored in proposal but NOT in `State.SmartContractRegistrations`

2. **Attacker front-runs with identical code**:
   - Attacker monitors chain, sees User A's proposal
   - Attacker calls `ProposeNewContract` with `ContractDeploymentInput{category: 1, code: C, contract_operation: null}` (different category)
   - Transaction succeeds, returns `proposedContractInputHash = H2` (different from H1 because category differs)
   - Same `codeHash` but different `proposedContractInputHash`

3. **Both proposals proceed through governance**:
   - Both get Parliament approval
   - Both get code check approval
   - Both reach `ReleaseCodeCheckedContract` status

4. **Attacker deploys first**:
   - Attacker calls their release transaction first
   - `DeploySmartContract` executes successfully
   - `State.SmartContractRegistrations[codeHash]` is now populated

5. **Victim's deployment fails**:
   - User A calls their release transaction
   - `DeploySmartContract` is invoked
   - Fails at `AssertContractNotExists(codeHash)` with error: "contract code has already been deployed before"

**Expected vs Actual Result**:
- **Expected**: Either the second proposal should fail at proposal time, OR both should deploy successfully to different addresses
- **Actual**: Second proposal succeeds initially but fails permanently at deployment, wasting governance resources and blocking the legitimate user

**Success Condition**: Attacker gains authorship of the contract while victim's proposal becomes undeployable despite passing all governance checks.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L125-126)
```csharp
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L127-128)
```csharp
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L519-526)
```csharp
    public override Empty SetContractAuthor(SetContractAuthorInput input)
    {
        var info = State.ContractInfos[input.ContractAddress];
        Assert(info != null, "Contract not found.");
        var oldAuthor = info.Author;
        Assert(Context.Sender == info.Author, "No permission.");
        info.Author = input.NewAuthor;
        State.ContractInfos[input.ContractAddress] = info;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L21-22)
```csharp
        var codeHash = HashHelper.ComputeFrom(code);
        AssertContractNotExists(codeHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L71-71)
```csharp
        State.SmartContractRegistrations[reg.CodeHash] = reg;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L98-102)
```csharp
    private void UpdateSmartContract(Address contractAddress, byte[] code, Address author, bool isUserContract)
    {
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        Assert(author == info.Author, "No permission.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L379-382)
```csharp
    private void AssertContractNotExists(Hash codeHash)
    {
        Assert(State.SmartContractRegistrations[codeHash] == null, "contract code has already been deployed before.");
    }
```

**File:** protobuf/acs0.proto (L156-162)
```text
message ContractDeploymentInput {
    // The category of contract code(0: C#).
    sint32 category = 1;
    // The byte array of the contract code.
    bytes code = 2;
    ContractOperation contract_operation = 3;
}
```
