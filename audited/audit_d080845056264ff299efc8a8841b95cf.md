# Audit Report

## Title
Protocol Impersonation via Unvalidated Cross-Chain Token Creation in NFT Contract

## Summary
The NFT contract's `CrossChainCreate` function retrieves token information from local MultiToken contract state without performing cross-chain verification, unlike the properly secured `CrossChainCreateToken` method. An attacker can create a malicious token on mainchain, sync it via legitimate cross-chain mechanisms, then call `CrossChainCreate` to gain complete control over an NFT protocol on sidechains, including exclusive minting rights and creator privileges.

## Finding Description

The vulnerability exists in the NFT contract's `CrossChainCreate` method, which synchronizes NFT protocols from mainchain to sidechains. [1](#0-0) 

**Root Cause:**

The function retrieves token information by directly calling the local MultiToken contract's `GetTokenInfo` method without any cross-chain verification. [2](#0-1) 

It unconditionally trusts the `tokenInfo.Issuer` field as the NFT protocol Creator. [3](#0-2) 

This Creator is immediately set as the sole minter for the NFT protocol. [4](#0-3) 

**Why Existing Protections Fail:**

The function only checks that the NFT protocol doesn't already exist locally, not whether it was legitimately created on mainchain. [5](#0-4) 

Unlike the MultiToken contract's `CrossChainCreateToken` method which requires transaction bytes and merkle path verification, the NFT's `CrossChainCreate` performs no cryptographic verification. The `CrossChainCreateInput` message only contains a symbol field. [6](#0-5) 

The proper cross-chain flow in MultiToken includes calling `CrossChainVerify` to cryptographically validate that the transaction occurred on the source chain. [7](#0-6) [8](#0-7) 

The NFT contract's `Create` method correctly restricts creation to mainchain only, but `CrossChainCreate` bypasses this by not validating the token origin. [9](#0-8) 

When creating tokens via MultiToken, arbitrary ExternalInfo metadata can be set without validation on its contents. [10](#0-9) 

The required NFT metadata keys are publicly visible constants. [11](#0-10) 

## Impact Explanation

**Direct Authority Takeover:**

The Creator role grants exclusive rights to add and remove minters from the NFT protocol. Only the Creator can execute these privileged operations. [12](#0-11) [13](#0-12) 

**Minting Control:**

The attacker becomes the sole minter and can mint NFTs without restriction. Only addresses in the minter list have permission to mint. [14](#0-13) 

**Concrete Harm:**
- **Protocol Impersonation**: An attacker can create NFT protocols on sidechains that impersonate legitimate brands or projects
- **Economic Fraud**: Minted NFTs appear as legitimate protocol NFTs, potentially defrauding users who purchase or trade them
- **Irreversible Control**: No mechanism exists for legitimate creators to reclaim control once the malicious protocol is created
- **Race Condition Exploitation**: Attackers can front-run legitimate protocol deployments to sidechains

**Affected Parties:**
- Users who trust and purchase NFTs from the fake protocol
- Legitimate protocol creators who lose the ability to deploy to that sidechain
- Ecosystem reputation and trust

## Likelihood Explanation

**Attacker Capabilities Required:**

1. Ability to create a token on mainchain - requires Seed NFT or being whitelisted, which is publicly accessible through market mechanisms. [15](#0-14) 

2. Knowledge of required NFT metadata keys, which are publicly visible constants. [11](#0-10) 

3. Ability to execute `CrossChainCreateToken` with valid merkle proofs (standard cross-chain operation, publicly documented)

4. Ability to call the public `CrossChainCreate` function on sidechain

**Attack Complexity:** Low to Medium
- All required steps use public interfaces
- No special privileges needed beyond initial token creation capability
- Merkle proof generation is standard cross-chain functionality

**Feasibility Conditions:**
- NFT type must be registered via governance (but common types like "Art", "Game" etc. are likely pre-registered)
- Target protocol symbol must not already exist on sidechain
- All conditions are easily met for new protocols or race conditions

**Economic Rationality:**
- Cost: Minimal (seed NFT purchase + transaction fees)
- Potential gain: Unlimited through fraudulent NFT sales
- Risk/Reward ratio strongly favors the attacker

## Recommendation

The `CrossChainCreate` method must be redesigned to follow the same security pattern as MultiToken's `CrossChainCreateToken`:

1. **Add verification parameters** to `CrossChainCreateInput`:
   - `bytes transaction_bytes` - Original transaction from source chain
   - `int64 parent_chain_height` - Parent chain height for verification
   - `int32 from_chain_id` - Source chain identifier
   - `MerklePath merkle_path` - Merkle path for cryptographic verification

2. **Implement cross-chain verification** before trusting token information:
   - Parse and validate the original transaction
   - Call `CrossChainVerify` with merkle path to ensure the NFT protocol was legitimately created on the source chain
   - Only extract token information from the verified transaction, not from local state

3. **Add method-specific validation** on the source chain:
   - Create a validation method similar to `ValidateTokenInfoExists` that specifically validates NFT protocol creation
   - Ensure the verification checks that the protocol was created through the proper `Create` method on mainchain

Example fix structure:
```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    // Validate source chain is registered
    var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
    Assert(tokenContractAddress != null, "Source chain not registered.");
    
    // Parse and verify original transaction
    var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);
    AssertCrossChainTransaction(originalTransaction, nftContractAddress, nameof(ValidateNFTProtocolExists));
    
    // Perform cryptographic verification
    var originalTransactionId = originalTransaction.GetHash();
    CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
    
    // Extract verified protocol information
    var protocolInput = ValidateNFTProtocolExistsInput.Parser.ParseFrom(originalTransaction.Params);
    
    // Continue with protocol creation using VERIFIED data
    // ...
}
```

## Proof of Concept

The following test demonstrates the vulnerability:

```csharp
[Fact]
public async Task CrossChainCreate_ProtocolImpersonation_Attack()
{
    // 1. Attacker creates malicious token on mainchain with themselves as issuer
    var attackerAddress = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[1].PublicKey);
    var maliciousSymbol = "AR123456789"; // Art NFT format
    
    // Create token with NFT metadata on mainchain
    await MainChainTokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = maliciousSymbol,
        TokenName = "Fake Art Protocol",
        TotalSupply = 10000,
        Decimals = 0,
        Issuer = attackerAddress, // Attacker is issuer
        IsBurnable = true,
        IssueChainId = MainChainId,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                ["aelf_nft_type"] = "Art",
                ["aelf_nft_base_uri"] = "https://attacker.com/",
                ["aelf_nft_token_id_reuse"] = "false"
            }
        }
    });
    
    // 2. Use legitimate CrossChainCreateToken to sync to sidechain
    await SideChainTokenContractStub.CrossChainCreateToken.SendAsync(new CrossChainCreateTokenInput
    {
        FromChainId = MainChainId,
        ParentChainHeight = validHeight,
        TransactionBytes = validTransactionBytes, // Properly constructed
        MerklePath = validMerklePath // Valid merkle proof
    });
    
    // 3. Call NFT.CrossChainCreate on sidechain (NO VERIFICATION)
    await SideChainNFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
    {
        Symbol = maliciousSymbol
    });
    
    // 4. Verify attacker has full control
    var protocolInfo = await SideChainNFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = maliciousSymbol });
    Assert.Equal(attackerAddress, protocolInfo.Creator); // Attacker is Creator!
    
    var minterList = await SideChainNFTContractStub.GetMinterList.CallAsync(new StringValue { Value = maliciousSymbol });
    Assert.Contains(attackerAddress, minterList.Value); // Attacker is sole minter!
    
    // 5. Attacker can now mint NFTs and control the protocol
    await SideChainNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = maliciousSymbol,
        // Attacker mints fraudulent NFTs
    });
    
    // Result: Complete protocol takeover on sidechain
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L16-17)
```csharp
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** protobuf/nft_contract.proto (L132-134)
```text
message CrossChainCreateInput {
    string symbol = 1;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-488)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L7-9)
```csharp
    private const string NftTypeMetadataKey = "aelf_nft_type";
    private const string NftBaseUriMetadataKey = "aelf_nft_base_uri";
    private const string NftTokenIdReuseMetadataKey = "aelf_nft_token_id_reuse";
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-353)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L355-373)
```csharp
    public override Empty RemoveMinters(RemoveMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol];

        foreach (var minter in input.MinterList.Value)
            if (minterList.Value.Contains(minter))
                minterList.Value.Remove(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListRemoved
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-400)
```csharp
        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Incorrect chain.");
```
