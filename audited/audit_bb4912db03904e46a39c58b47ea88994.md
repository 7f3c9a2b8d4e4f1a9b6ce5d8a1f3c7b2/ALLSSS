# Audit Report

## Title
Pre-Validation State Corruption in UpdateValue Consensus Validation Allows Bypassing Last Irreversible Block Height Checks

## Summary
The `ValidateBeforeExecution` method in the AEDPoS consensus contract modifies the trusted `baseRound` object with untrusted miner-provided data before performing validation checks. This causes the `LibInformationValidationProvider` to compare corrupted data against itself, effectively bypassing the check designed to prevent `ImpliedIrreversibleBlockHeight` from decreasing. Any active miner can exploit this to move Last Irreversible Block (LIB) heights backwards, violating a critical consensus invariant.

## Finding Description

The vulnerability exists in the consensus validation flow where block header information is validated before execution. The validation retrieves the current round state from storage, but then immediately corrupts it with attacker-controlled data before running validation checks. [1](#0-0) 

For `UpdateValue` behavior, the method calls `RecoverFromUpdateValue` which modifies the `baseRound` object in-place: [2](#0-1) 

The `RecoverFromUpdateValue` method directly overwrites critical fields including `ImpliedIrreversibleBlockHeight` with values from the untrusted `providedRound`: [3](#0-2) 

The validation context is then created using this corrupted `baseRound`: [4](#0-3) 

The `LibInformationValidationProvider` is added to validate LIB information for UpdateValue behavior: [5](#0-4) 

The provider's validation logic compares `baseRound` against `providedRound` to ensure `ImpliedIrreversibleBlockHeight` doesn't decrease: [6](#0-5) 

However, since `baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` was already overwritten with the attacker's value at line 19 of `RecoverFromUpdateValue`, the check becomes: `attackerValue > attackerValue`, which always evaluates to false, causing validation to pass regardless of whether the LIB height actually decreased.

After validation passes, the malicious value is persisted to state: [7](#0-6) 

This corrupted `ImpliedIrreversibleBlockHeight` is then used in LIB calculations: [8](#0-7) 

## Impact Explanation

This vulnerability enables any active miner to manipulate `ImpliedIrreversibleBlockHeight` to arbitrary values, including moving it backwards, which directly violates the consensus invariant that Last Irreversible Block heights must monotonically increase.

**Critical Consensus Harms:**

1. **Finality Violation**: LIB heights determine which blocks are considered irreversible. Moving LIB backwards undermines the entire finality guarantee, potentially enabling double-spend attacks on transactions that were previously considered finalized.

2. **Consensus State Corruption**: The malicious LIB height value is permanently stored in the consensus state and used in subsequent calculations by `LastIrreversibleBlockHeightCalculator`, affecting the entire network's understanding of which blocks are irreversible.

3. **Cross-Chain Security Impact**: Cross-chain operations rely on LIB heights for finality guarantees. Backwards LIB heights could enable cross-chain message replay attacks or allow reorganization of supposedly irreversible cross-chain transfers.

4. **Protocol-Wide Propagation**: All nodes participating in consensus use these corrupted LIB values, affecting the entire blockchain's consensus mechanism rather than just isolated transactions.

The severity is **Critical** as it directly breaks the "LIB height must not decrease" invariant that is fundamental to blockchain finality and consensus integrity.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be an active miner in the current round (normal miner capability)
- Ability to craft block header consensus information (standard mining operation)
- No additional privileges or compromised keys required

**Attack Execution:**
1. Attacker waits for their scheduled mining time slot
2. Crafts a block with malicious `extraData.Round.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` set to a value lower than their current stored value
3. Includes valid `OutValue` and `Signature` to pass `UpdateValueValidationProvider` checks
4. The `LibInformationValidationProvider` check passes because it compares corrupted data against itself
5. Block is accepted and the backwards LIB value is persisted to state

**Feasibility:**
- Executable during normal consensus operation without special conditions
- No complex race conditions or timing requirements
- Detection is difficult as validation appears to succeed normally
- Cost is minimal (just block production during assigned slot)
- Can be repeated by any miner in any round

The likelihood is **High** - any malicious or compromised miner can execute this attack during their normal mining slot without any barriers beyond basic mining permissions.

## Recommendation

Perform the LIB validation check BEFORE modifying the `baseRound` object. Store the original `ImpliedIrreversibleBlockHeight` before calling `RecoverFromUpdateValue`, then validate against that original value:

```csharp
private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
{
    if (!TryToGetCurrentRoundInformation(out var baseRound))
        return new ValidationResult { Success = false, Message = "Failed to get current round information." };

    // Store original values BEFORE modification
    long originalImpliedIrreversibleBlockHeight = 0;
    if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue && 
        baseRound.RealTimeMinersInformation.ContainsKey(extraData.SenderPubkey.ToHex()))
    {
        originalImpliedIrreversibleBlockHeight = 
            baseRound.RealTimeMinersInformation[extraData.SenderPubkey.ToHex()].ImpliedIrreversibleBlockHeight;
    }

    // Now apply modifications
    if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
        baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

    if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
        baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

    var validationContext = new ConsensusValidationContext
    {
        BaseRound = baseRound,
        CurrentTermNumber = State.CurrentTermNumber.Value,
        CurrentRoundNumber = State.CurrentRoundNumber.Value,
        PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
        LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
        ExtraData = extraData,
        OriginalImpliedIrreversibleBlockHeight = originalImpliedIrreversibleBlockHeight // Pass original value
    };
    
    // ... rest of validation
}
```

Then modify `LibInformationValidationProvider` to use the original value:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var providedRound = validationContext.ProvidedRound;
    var pubkey = validationContext.SenderPubkey;
    
    // Use original value instead of corrupted baseRound
    if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
        providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
        validationContext.OriginalImpliedIrreversibleBlockHeight > 
        providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
    {
        validationResult.Message = "Incorrect implied lib height.";
        return validationResult;
    }

    validationResult.Success = true;
    return validationResult;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ValidateBeforeExecution_Should_Reject_Backwards_ImpliedIrreversibleBlockHeight()
{
    // Setup: Initialize consensus with a miner having ImpliedIrreversibleBlockHeight = 1000
    await InitializeConsensusWithMiner();
    var minerKeyPair = InitialCoreDataCenterKeyPairs[0];
    var minerPubkey = minerKeyPair.PublicKey.ToHex();
    
    // Set current ImpliedIrreversibleBlockHeight to 1000
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.RealTimeMinersInformation[minerPubkey].ImpliedIrreversibleBlockHeight = 1000;
    
    // Create malicious consensus header with backwards LIB height (500)
    var maliciousExtraData = new AElfConsensusHeaderInformation
    {
        Behaviour = AElfConsensusBehaviour.UpdateValue,
        SenderPubkey = ByteString.CopyFrom(minerKeyPair.PublicKey),
        Round = new Round
        {
            RealTimeMinersInformation =
            {
                {
                    minerPubkey,
                    new MinerInRound
                    {
                        Pubkey = minerPubkey,
                        OutValue = HashHelper.ComputeFrom("test"),
                        Signature = HashHelper.ComputeFrom("test"),
                        ImpliedIrreversibleBlockHeight = 500 // BACKWARDS from 1000 to 500
                    }
                }
            }
        }
    };
    
    // Attempt validation - should FAIL but actually PASSES due to vulnerability
    var validationResult = await AEDPoSContractStub.ValidateConsensusBeforeExecution.CallAsync(
        maliciousExtraData.ToByteString());
    
    // BUG: This passes when it should fail
    validationResult.Success.ShouldBeTrue(); // Demonstrates the vulnerability
    
    // After validation passes, the backwards value gets persisted
    var updatedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var finalHeight = updatedRound.RealTimeMinersInformation[minerPubkey].ImpliedIrreversibleBlockHeight;
    
    // VULNERABILITY CONFIRMED: LIB height moved backwards from 1000 to 500
    finalHeight.ShouldBe(500); // Should be >= 1000, but vulnerability allows 500
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L14-19)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```
