# Audit Report

## Title
ArrangeAbnormalMiningTime Returns Past Timestamp for Extra Block Producer, Violating Future Mining Time Invariant

## Summary
The `ArrangeAbnormalMiningTime()` method contains a logic error where it validates that `GetExtraBlockMiningTime() + miningInterval` exceeds `currentBlockTime`, but returns only `GetExtraBlockMiningTime()` without the offset. This creates a time window where a past timestamp is returned, causing the consensus scheduler to receive negative delays and fire immediately instead of waiting for the proper time slot.

## Finding Description

The vulnerability exists in the extra block producer timing logic. [1](#0-0) 

**Root Cause Analysis:**

The condition checks if `(GetExtraBlockMiningTime() + miningInterval) - currentBlockTime > 0`, but returns only `GetExtraBlockMiningTime()`. [2](#0-1) 

This creates a vulnerable time window:
- **When**: `GetExtraBlockMiningTime() ≤ currentBlockTime < GetExtraBlockMiningTime() + miningInterval`
- **Then**: The distance calculation `(E + M) - C > 0` passes (where E=ExtraBlockMiningTime, M=miningInterval, C=currentBlockTime)
- **But**: The returned value `E ≤ C` is in the past

**Execution Path:**

The extra block producer requests a consensus command through the standard flow: [3](#0-2) 

Which invokes the terminate round strategy: [4](#0-3) 

That delegates to the time arranging service: [5](#0-4) 

**Scheduler Impact:**

The consensus service calculates the delay as `leftMilliseconds = ArrangedMiningTime - GetUtcNow()`, which becomes negative when ArrangedMiningTime is in the past: [6](#0-5) 

The ArrangedMiningTime is passed to the event data as BlockTime: [7](#0-6) 

And the RxNet scheduler uses Observable.Timer with this negative/zero delay: [8](#0-7) 

Observable.Timer with negative or zero milliseconds fires immediately instead of waiting for the proper time slot.

**Why Validation Fails:**

Block validation only rejects blocks that are too far in the FUTURE, not blocks with timestamps in the past: [9](#0-8) 

The condition `block.Header.Time - GetUtcNow() > AllowedFutureBlockTimeSpan` only checks if blocks are too far ahead, providing no protection against past timestamps.

## Impact Explanation

**Consensus Timing Integrity Violation:**
This bug violates the fundamental invariant that arranged mining times must always be in the future. When the scheduler receives a past timestamp, it fires immediately instead of waiting for the designated time slot, causing blocks to be produced at incorrect times.

**Operational Consequences:**
- Extra block producers fire immediately when they should wait
- The carefully orchestrated block production schedule is disrupted
- Blocks may be produced before their proper time window, potentially triggering time slot validation failures [10](#0-9) 
- Round termination timing becomes unpredictable
- Consensus reliability and block production ordering are compromised

**Severity Assessment:** MEDIUM-HIGH
While this doesn't directly cause fund loss or complete consensus failure, it violates a critical timing invariant that underpins consensus correctness. The AEDPoS consensus mechanism relies on precise time-slot scheduling, and returning past timestamps breaks this fundamental assumption.

## Likelihood Explanation

**Trigger Conditions:**
This vulnerability activates automatically during normal consensus operations when:
1. The extra block producer requests a consensus command to terminate the round
2. Current time falls within the window `[GetExtraBlockMiningTime(), GetExtraBlockMiningTime() + miningInterval)`
3. This window spans the entire `miningInterval` duration (typically 100ms to 4000ms)

**Frequency:**
The vulnerable time window occurs every round during extra block production. With network latency, processing delays, and variable mining intervals, the probability of currentBlockTime falling within this window is substantial.

**No Special Privileges Required:**
This is not an attack - it's a timing bug that occurs naturally during legitimate consensus operations. Any extra block producer performing their normal duties can trigger this condition.

**Probability:** MEDIUM-HIGH
Given the size of the vulnerable time window relative to typical mining intervals and the frequency of round terminations, this condition will occur regularly in production.

## Recommendation

Modify line 30 in `Round_ArrangeAbnormalMiningTime.cs` to return the validated timestamp that includes the miningInterval offset:

**Current (buggy) code:**
```csharp
if (distance > 0) return GetExtraBlockMiningTime();
```

**Fixed code:**
```csharp
if (distance > 0) return GetExtraBlockMiningTime().AddMilliseconds(miningInterval);
```

This ensures the returned timestamp matches the validated condition, maintaining the invariant that arranged mining time is always in the future.

Alternatively, adjust the condition to match what is being returned:
```csharp
var distance = GetExtraBlockMiningTime() - currentBlockTime;
if (distance.Milliseconds() > 0) return GetExtraBlockMiningTime();
```

## Proof of Concept

The mathematical proof demonstrates the vulnerability:

**Given:**
- Let E = GetExtraBlockMiningTime() = 1000ms
- Let M = miningInterval = 100ms  
- Let C = currentBlockTime = 1050ms

**Execution:**
1. Line 28-29 calculates: `distance = (1000 + 100) - 1050 = 50ms > 0` ✓ (passes)
2. Line 30 returns: `1000ms`
3. Result: Returns `1000ms < 1050ms` (past timestamp)

**Scheduler Impact:**
1. ConsensusService calculates: `leftMilliseconds = 1000 - 1050 = -50ms`
2. RxNetScheduler receives: `Observable.Timer(TimeSpan.FromMilliseconds(-50))`
3. Timer fires immediately instead of waiting

**Verification:** This can be confirmed by examining the consensus logs when extra block producers terminate rounds, looking for cases where mining events fire immediately after consensus commands are issued, or by adding assertions that ArrangedMiningTime > currentTime in the scheduler code to catch violations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L26-31)
```csharp
        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L39-44)
```csharp
            case AElfConsensusBehaviour.NextRound:
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-38)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L22-25)
```csharp
        public static Timestamp ArrangeExtraBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return round.ArrangeAbnormalMiningTime(pubkey, currentBlockTime);
        }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L86-91)
```csharp
        // Update next mining time, also block time of both getting consensus extra data and txs.
        _nextMiningTime = _consensusCommand.ArrangedMiningTime;
        var leftMilliseconds = _consensusCommand.ArrangedMiningTime - TimestampHelper.GetUtcNow();
        leftMilliseconds = leftMilliseconds.Seconds > ConsensusConstants.MaximumLeftMillisecondsForNextBlock
            ? new Duration { Seconds = ConsensusConstants.MaximumLeftMillisecondsForNextBlock }
            : leftMilliseconds;
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L102-108)
```csharp
        var blockMiningEventData = new ConsensusRequestMiningEventData(chainContext.BlockHash,
            chainContext.BlockHeight,
            _nextMiningTime,
            TimestampHelper.DurationFromMilliseconds(limitMillisecondsOfMiningBlock),
            _consensusCommand.MiningDueTime);
        _consensusScheduler.CancelCurrentEvent();
        _consensusScheduler.NewEvent(leftMilliseconds.Milliseconds(), blockMiningEventData);
```

**File:** src/AElf.Kernel.Consensus.Scheduler.RxNet/RxNetScheduler.cs (L53-62)
```csharp
    public IDisposable Subscribe(long countingMilliseconds,
        ConsensusRequestMiningEventData consensusRequestMiningEventData)
    {
        Logger.LogDebug("Will produce block after {CountingMilliseconds} ms - {Time}", countingMilliseconds,
            TimestampHelper.GetUtcNow().AddMilliseconds(countingMilliseconds).ToDateTime()
                .ToString("yyyy-MM-dd HH.mm.ss,fff"));

        return Observable.Timer(TimeSpan.FromMilliseconds(countingMilliseconds))
            .Select(_ => consensusRequestMiningEventData).Subscribe(this);
    }
```

**File:** src/AElf.Kernel.Core/Blockchain/Application/IBlockValidationProvider.cs (L133-139)
```csharp
        if (block.Header.Height != AElfConstants.GenesisBlockHeight &&
            block.Header.Time.ToDateTime() - TimestampHelper.GetUtcNow().ToDateTime() >
            KernelConstants.AllowedFutureBlockTimeSpan.ToTimeSpan())
        {
            Logger.LogDebug("Future block received {Block}, {BlockTime}", block, block.Header.Time.ToDateTime());
            return Task.FromResult(false);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```
