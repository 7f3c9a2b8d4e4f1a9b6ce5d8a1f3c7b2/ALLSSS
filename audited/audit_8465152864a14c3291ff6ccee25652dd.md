### Title
OutValue Reuse Across Multiple Rounds Compromises VRF Randomness in Consensus

### Summary
The AEDPoS consensus mechanism fails to validate OutValue uniqueness across rounds, allowing malicious miners to reuse the same InValue (and thus same OutValue) in consecutive rounds. This breaks the VRF (Verifiable Random Function) randomness guarantee and enables predictable manipulation of next-round miner ordering.

### Finding Description

**Exact Location:**
The vulnerability exists in the validation logic that processes OutValue during consensus updates. [1](#0-0) 

**Root Cause:**
When a miner publishes their OutValue, the system computes it from the InValue provided in trigger information. However, the validation only ensures the commit-reveal chain integrity (that previous round's InValue hashes to previous OutValue) but never checks if the current OutValue differs from any previous round's OutValue. [2](#0-1) 

The `ValidatePreviousInValue` method only verifies: `Hash(PreviousInValue) == previousRound.OutValue`, which confirms the miner is revealing their previous secret correctly, but does NOT check if `currentRound.OutValue == previousRound.OutValue` (which would indicate reuse). [3](#0-2) 

The `ProcessUpdateValue` method directly assigns the provided OutValue without any uniqueness validation against previous rounds.

**Why Protections Fail:**
The InValue is generated off-chain by the miner's node and provided via trigger information. While the protocol expects fresh InValues each round (generated via signing round-specific data), there is no on-chain enforcement. [4](#0-3) 

The trigger information simply retrieves InValue from the local cache by roundId, but a malicious miner can manipulate their local cache to reuse old InValues.

**Attack Execution Path:**
1. Round N: Malicious miner generates InValue₁, computes OutValue₁ = Hash(InValue₁), publishes it
2. Round N+1: Instead of generating new InValue₂, miner reuses InValue₁, publishes same OutValue₁
3. Round N+2: Miner reveals PreviousInValue = InValue₁
4. Validation checks Hash(InValue₁) == OutValue₁ from Round N+1 ✓ (passes)
5. No validation detects that OutValue₁ in Round N+1 equals OutValue₁ from Round N

### Impact Explanation

**Consensus Randomness Compromise:**
The OutValue directly influences next-round miner ordering through the signature-based ordering calculation: [5](#0-4) 

The signature (derived from OutValue) determines `SupposedOrderOfNextRound` via modulo operation. By reusing OutValue, a malicious miner can:

1. **Predict Their Position:** Same OutValue → same signature → same next-round position
2. **Strategic Manipulation:** Choose favorable rounds to reuse OutValue, avoiding unfavorable positions
3. **Break VRF Guarantees:** VRF is supposed to provide unpredictable randomness; reuse enables predictability

**Affected Parties:**
- All honest miners suffer from manipulated ordering
- Users relying on fair block production schedule
- Protocol security depending on unpredictable randomness

**Severity Justification:**
HIGH severity because:
- Breaks core consensus randomness invariant
- Enables direct manipulation of miner ordering
- No detection mechanism exists
- Low cost to execute (just reuse old InValue)
- Cascading effect on protocol fairness and security

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an active miner in the consensus set
- Must control their node's InValue generation/caching
- Standard miner capabilities, no special privileges needed

**Attack Complexity:**
Low - attacker simply needs to:
1. Store their InValue from a favorable round
2. Modify their local InValueCache to return old InValue when new round starts
3. Continue normal block production

**Feasibility Conditions:**
- Highly feasible: InValue generation is client-side
- No cryptographic or economic barriers
- Detection requires off-chain monitoring of OutValue patterns [6](#0-5) 

The InValueCache is a simple dictionary that miners control locally, making manipulation trivial.

**Detection Constraints:**
- On-chain: No validation checks OutValue uniqueness
- Off-chain: Requires monitoring all miners' OutValues across rounds
- Malicious miner can space out reuse to avoid obvious patterns

**Probability Assessment:**
High likelihood of exploitation because:
- Simple to execute
- Low detection risk
- Potential strategic advantage for malicious miners
- No penalties for violation (validation passes)

### Recommendation

**Immediate Fix:**
Add OutValue uniqueness validation in `UpdateValueValidationProvider`:

```csharp
private bool ValidateOutValueUniqueness(ConsensusValidationContext validationContext)
{
    var publicKey = validationContext.SenderPubkey;
    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
        return true;
    
    var currentOutValue = validationContext.ProvidedRound.RealTimeMinersInformation[publicKey].OutValue;
    var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
    
    // OutValue must differ from previous round
    if (currentOutValue != null && previousOutValue != null && currentOutValue == previousOutValue)
        return false;
    
    return true;
}
```

Add this check to `ValidateHeaderInformation` method: [7](#0-6) 

Modify to include:
```csharp
if (!ValidateOutValueUniqueness(validationContext))
    return new ValidationResult { Message = "OutValue reused from previous round." };
```

**Additional Hardening:**
1. Store hash of recent OutValues (last 3-5 rounds) in contract state
2. Check new OutValue against historical values during validation
3. Add telemetry/logging for OutValue patterns

**Test Cases:**
1. Test that reusing same InValue across rounds is rejected
2. Test that OutValue changes across normal rounds
3. Test edge cases: first round, term transitions, miner replacements
4. Regression test to ensure commit-reveal chain still validates correctly

### Proof of Concept

**Initial State:**
- Active consensus round N with miner M in the miner list
- Miner M has successfully mined in round N with InValue₁ and OutValue₁

**Attack Steps:**

1. **Round N - Normal Operation:**
   - Miner M generates fresh InValue₁ via SecretSharingService
   - Computes OutValue₁ = Hash(InValue₁)
   - Publishes block with OutValue₁
   - Validation passes normally

2. **Round N+1 - Attack Begins:**
   - Miner M's turn arrives
   - Instead of letting SecretSharingService generate new InValue₂
   - Miner M modifies InValueCache to return InValue₁ for round N+1
   - AEDPoSTriggerInformationProvider retrieves InValue₁ from cache
   - GetConsensusExtraDataToPublishOutValue computes OutValue₁ = Hash(InValue₁)
   - Miner M publishes block with same OutValue₁
   - Validation: UpdateValueValidationProvider checks only Hash(PreviousInValue) == OutValue from Round N
   - **Result: Validation PASSES** (no OutValue uniqueness check)

3. **Round N+2 - Reveal Phase:**
   - Miner M reveals PreviousInValue = InValue₁
   - Validation: Hash(InValue₁) == OutValue₁ from Round N+1 ✓
   - **Result: Validation PASSES**

4. **Outcome Verification:**
   - Check Round N and Round N+1 state
   - Observe: `State.Rounds[N].RealTimeMinersInformation[M].OutValue == State.Rounds[N+1].RealTimeMinersInformation[M].OutValue`
   - Signature values in both rounds will be identical
   - Next-round ordering calculation produces same result
   - **Success Condition: Miner M successfully reused OutValue without detection**

**Expected vs Actual:**
- **Expected:** Each round should have unique OutValue per miner (VRF guarantee)
- **Actual:** Same OutValue accepted across multiple rounds, breaking randomness

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-67)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L54-67)
```csharp
        {
            var newInValue = _inValueCache.GetInValue(hint.RoundId);
            var previousInValue = _inValueCache.GetInValue(hint.PreviousRoundId);
            Logger.LogDebug($"New in value {newInValue} for round of id {hint.RoundId}");
            Logger.LogDebug($"Previous in value {previousInValue} for round of id {hint.PreviousRoundId}");
            var trigger = new AElfConsensusTriggerInformation
            {
                Pubkey = Pubkey,
                InValue = newInValue,
                PreviousInValue = previousInValue,
                Behaviour = hint.Behaviour
            };

            return trigger.ToBytesValue();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IInValueCache.cs (L14-22)
```csharp
public class InValueCache : IInValueCache, ISingletonDependency
{
    private readonly Dictionary<long, Hash> _inValues = new();

    public void AddInValue(long roundId, Hash inValue)
    {
        _inValues[roundId] = inValue;
    }

```
