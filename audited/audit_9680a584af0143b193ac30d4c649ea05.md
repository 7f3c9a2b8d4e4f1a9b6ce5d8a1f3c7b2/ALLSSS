# Audit Report

## Title
Authorization Bypass: Unauthorized Miners Can Gain Extra Block Production Rights Through Premature NextRound Execution

## Summary
The AEDPoS consensus mechanism fails to validate which miner is authorized to terminate the current round. Any miner whose time slot has passed can mine a NextRound block and automatically receive `ExtraBlockProducerOfPreviousRound` status, granting them extended block production privileges (`_maximumBlocksCount + blocksBeforeCurrentRound` blocks) in the subsequent round that should only go to the legitimately designated extra block producer.

## Finding Description

The vulnerability stems from three critical flaws in the round termination logic:

**1. Unrestricted NextRound Behavior Assignment**

Any miner whose time slot has passed can obtain NextRound consensus behavior. The `GetConsensusBehaviour()` method returns `GetConsensusBehaviourToTerminateCurrentRound()` without checking if the miner is the designated extra block producer. [1](#0-0) 

**2. Unconditional Privilege Assignment**

When processing a NextRound block, the system unconditionally assigns the terminating miner's pubkey to `ExtraBlockProducerOfPreviousRound` without validation: [2](#0-1) 

**3. Extended Block Production Rights**

Miners with their pubkey matching `ExtraBlockProducerOfPreviousRound` receive extended privileges to produce additional tiny blocks beyond the normal limit: [3](#0-2) 

**Why Existing Validations Fail:**

- **PreCheck**: Only verifies the miner is in the current or previous miner list, not whether they are the designated extra block producer [4](#0-3) 

- **RoundTerminateValidationProvider**: Only validates round number increment and that InValues are null, without checking authorization [5](#0-4) 

- **TimeSlotValidationProvider**: For NextRound (new round ID), only validates the NEW round's time slot structure, not the timing of when NextRound can be called [6](#0-5) 

**Attack Execution:**

1. The system deterministically selects one extra block producer per round [7](#0-6) 

2. Any miner whose time slot has passed can mine NextRound by modifying their node to bypass client-side timing constraints

3. The NextRound transaction is processed through `ProcessConsensusInformation` â†’ `ProcessNextRound` [8](#0-7) 

4. The attacker gains extended mining rights in the next round due to their `ExtraBlockProducerOfPreviousRound` status

## Impact Explanation

**Consensus Fairness Violation:**
This vulnerability breaks the fundamental fairness invariant of AEDPoS where block production opportunities should be deterministically distributed. The attacker gains `(_maximumBlocksCount + blocksBeforeCurrentRound)` block production rights instead of the standard `_maximumBlocksCount`, while the legitimate extra block producer loses their rightful privileges.

**Quantified Damage:**
- With typical configuration (_maximumBlocksCount = 8), the attacker gains 8 extra tiny blocks per successful exploit
- Repeated exploitation across rounds accumulates unfair advantage
- Additional block production translates to disproportionate mining rewards and transaction fee revenue
- Enables potential transaction censorship and MEV extraction through extra blocks

**Security Guarantee Broken:**
Violates the consensus invariant "Correct round transitions and time-slot validation, miner schedule integrity" by allowing unauthorized privilege escalation in the mining schedule.

## Likelihood Explanation

**Attacker Prerequisites (Realistic):**
- Must be in the current miner list (standard requirement for consensus participation)
- Requires running modified node software to bypass client-side `MiningDueTime` validation
- Needs reasonable network connectivity to propagate blocks

**Attack Complexity (Moderate):**
1. Modify node to ignore `ArrangedMiningTime` client-side checks
2. Monitor for when own time slot passes
3. Immediately mine and broadcast NextRound block
4. Win propagation race against legitimate extra block producer

**Feasibility Factors:**
- Attack window opens when any miner's time slot passes
- No cryptographic or economic barriers prevent execution
- Success depends on network latency and block propagation timing
- Difficult to distinguish from legitimate fallback scenarios (offline extra block producer)

**Assessment: HIGH**
Any miner can attempt this attack with reasonable success probability. The modified node software is straightforward to implement, and the attack can be repeated across rounds. The absence of on-chain authorization validation makes prevention challenging.

## Recommendation

**Primary Fix: Add Authorization Validation**

Validate that only the designated extra block producer can mine NextRound blocks. Add a check in `PreCheck()` or create a dedicated validation provider:

```csharp
// In PreCheck() or new NextRoundAuthorizationValidationProvider
if (behaviour == AElfConsensusBehaviour.NextRound)
{
    var expectedExtraBlockProducer = currentRound.RealTimeMinersInformation
        .Single(m => m.Value.IsExtraBlockProducer).Key;
    
    if (_processingBlockMinerPubkey != expectedExtraBlockProducer)
        return false; // or return validation failure
}
```

**Alternative/Additional Fix: Decouple Privileges**

Instead of granting privileges based on who called NextRound, grant them based on who was the designated extra block producer:

```csharp
// In GetConsensusExtraDataForNextRound
var designatedExtraBlockProducer = currentRound.RealTimeMinersInformation
    .Single(m => m.Value.IsExtraBlockProducer).Key;
nextRound.ExtraBlockProducerOfPreviousRound = designatedExtraBlockProducer;
```

**Additional Hardening:**
- Add on-chain timing validation for NextRound transactions
- Implement detection for repeated premature NextRound patterns from the same miner
- Consider economic penalties for miners who attempt unauthorized round termination

## Proof of Concept

A complete proof of concept would require:

1. **Setup**: Deploy AEDPoS consensus contract with multiple miners
2. **Attack Scenario**: 
   - Miner A is designated as extra block producer for round N
   - Miner B's time slot passes before Miner A terminates the round
   - Miner B (with modified node) mines NextRound block
3. **Verification**: 
   - Confirm Miner B's pubkey is set as `ExtraBlockProducerOfPreviousRound` in round N+1
   - Verify Miner B can produce extra tiny blocks in round N+1
   - Confirm Miner A lost their rightful extra block privileges

The test would demonstrate that on-chain validation fails to prevent unauthorized miners from gaining `ExtraBlockProducerOfPreviousRound` status by mining NextRound prematurely.

---

**Notes:**

This vulnerability represents a consensus-level privilege escalation where miners can manipulate the round termination mechanism to gain unfair block production advantages. While miners are already privileged actors in the network, the protocol should enforce that only the designated extra block producer can terminate rounds and receive associated privileges. The lack of on-chain authorization validation allows this invariant to be violated, compromising the fairness guarantees of the AEDPoS consensus mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L178-178)
```csharp
        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-34)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```
