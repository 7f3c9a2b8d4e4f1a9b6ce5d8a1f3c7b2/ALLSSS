### Title
Insufficient Validation of OutValue Allows Secret-Sharing Protocol Violation and Mining Order Manipulation

### Summary
The `UpdateValueValidationProvider.ValidateHeaderInformation()` method fails to verify that submitted `OutValue` fields correspond to legitimate secret commitments (Hash(InValue)), allowing miners to submit arbitrary values. Additionally, miners can avoid revealing their InValue in subsequent rounds by providing `Hash.Empty` as `PreviousInValue`, which passes validation. This breaks the secret-sharing protocol's integrity and enables miners to manipulate their mining order in subsequent rounds.

### Finding Description

The validation logic in `UpdateValueValidationProvider` has two critical weaknesses:

**Weakness 1: No Cryptographic Validation of Current OutValue**

The `NewConsensusInformationFilled` method only checks that `OutValue` and `Signature` are non-null and non-empty: [1](#0-0) 

This validation does not verify that:
- The `OutValue` equals `Hash(InValue)` for some legitimate InValue generated by the miner
- The `Signature` is properly computed using the `CalculateSignature` method

In contrast, legitimate OutValue generation requires: [2](#0-1) 

And legitimate Signature calculation should use: [3](#0-2) 

**Weakness 2: Optional PreviousInValue Validation**

The `ValidatePreviousInValue` method returns `true` (passes validation) if `PreviousInValue` is null or `Hash.Empty`: [4](#0-3) 

This is explicitly permitted in the processing logic: [5](#0-4) 

**Why Protections Fail:**

The only validation that occurs for PreviousInValue is: [6](#0-5) 

But this check is bypassed when miners provide no PreviousInValue, allowing them to avoid proving their previous OutValue was legitimate.

**Mining Order Impact:**

The submitted Signature value directly affects mining order calculation in the next round: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Compromise:**
- Miners can submit arbitrary OutValue and Signature values that violate the secret-sharing protocol
- The secret-sharing mechanism is designed to provide verifiable randomness through InValue commitments and subsequent revelation
- By submitting non-legitimate OutValues, miners break the cryptographic binding between commitment and revelation

**Mining Order Manipulation:**
- Miners can choose Signature values to influence their `SupposedOrderOfNextRound` calculation via modulo arithmetic
- This allows strategic positioning in favorable time slots (e.g., becoming the extra block producer or avoiding unfavorable slots)
- The randomness and fairness of the consensus mechanism is compromised

**Protocol-Wide Impact:**
- All miners participating in consensus are affected by the degraded randomness
- The unpredictability guarantee of the secret-sharing protocol is violated
- Potential for coordinated manipulation if multiple miners exploit this weakness

**Severity Justification:**
This is a High severity issue because it directly violates a critical consensus invariant (correct round transitions and miner schedule integrity) and enables strategic manipulation of block production order.

### Likelihood Explanation

**Attacker Capabilities:**
- Any miner in the active miner list can perform this attack
- No special permissions beyond being an elected miner are required
- The attacker only needs to submit a modified UpdateValue transaction with chosen OutValue and Signature values

**Attack Complexity:**
- Low complexity: Attacker simply provides arbitrary byte values for OutValue and Signature instead of computing them properly
- In the next round, provide `Hash.Empty` for PreviousInValue to avoid detection
- No sophisticated cryptographic attacks or timing manipulation required

**Feasibility Conditions:**
- Miner must be in the current round's miner list (prerequisite for mining)
- Miner must have their designated time slot (normal mining operation)
- No additional preconditions required

**Detection Constraints:**
- Other miners cannot immediately detect the manipulation during validation
- Secret sharing reconstruction could potentially reveal the mismatch, but only if 2/3+ miners collect enough decrypted pieces
- The explicit permission to omit PreviousInValue (line 262 comment) suggests this is expected behavior, reducing scrutiny

**Probability:**
High likelihood - any rational miner seeking to optimize their mining position could exploit this with minimal risk and effort.

### Recommendation

**1. Enforce Current OutValue Validation:**

Modify `UpdateValueValidationProvider.NewConsensusInformationFilled` to store and validate the InValue commitment:
- Require miners to submit their current InValue (encrypted or committed)
- Verify that `OutValue == Hash(provided InValue or commitment)`
- Or implement a deferred validation mechanism that verifies OutValue when InValue is revealed

**2. Make PreviousInValue Mandatory:**

Modify `UpdateValueValidationProvider.ValidatePreviousInValue` to enforce InValue revelation:
- Remove the early returns for null and Hash.Empty (lines 42, 46)
- Require miners to provide their PreviousInValue from the previous round
- Only allow exceptions for the first round of a term or when a miner first joins

**3. Signature Validation:**

Add validation that the Signature is properly computed:
- Retrieve the previous round information
- Recompute expected signature using `CalculateSignature(providedPreviousInValue)`
- Compare with the submitted Signature value

**4. Penalty Mechanism:**

Implement detection and penalties for miners who:
- Fail to reveal valid InValues when secret-sharing reconstruction exposes mismatches
- Consistently provide Hash.Empty for PreviousInValue without valid reasons

**Test Cases:**
- Test UpdateValue with arbitrary OutValue values and verify rejection
- Test UpdateValue with Hash.Empty PreviousInValue when one should exist
- Test UpdateValue with incorrect Signature computation
- Test successful UpdateValue with properly computed OutValue, PreviousInValue, and Signature

### Proof of Concept

**Initial State:**
- Miner M is in the active miner list for round N
- M has previously mined in round N-1 with OutValue = X

**Attack Sequence:**

**Round N - Mining Time Slot:**
1. M's node is triggered to produce a block for their time slot
2. Instead of generating legitimate InValue and computing OutValue = Hash(InValue):
   - M generates arbitrary OutValue = Y (chosen to manipulate next round order)
   - M generates arbitrary Signature = S (chosen via trial to get favorable modulo result)
3. M submits UpdateValue transaction with:
   - `OutValue = Y` (arbitrary)
   - `Signature = S` (arbitrary)
   - `PreviousInValue = Hash.Empty` (to avoid revealing previous round's manipulation)

**Validation (ValidateBeforeExecution):**
4. `NewConsensusInformationFilled` check passes (Y and S are non-null/non-empty)
5. `ValidatePreviousInValue` check passes (returns true at line 46 for Hash.Empty)
6. Block passes validation and is accepted

**Round N+1 - Order Calculation:**
7. When determining mining order for round N+1:
   - M's SupposedOrderOfNextRound = `GetAbsModulus(S.ToInt64(), minersCount) + 1`
   - M achieves their desired position (e.g., position 1 to be extra block producer)

**Expected Result:**
- UpdateValue should be rejected for invalid OutValue
- Miner should be penalized for failing to provide legitimate PreviousInValue

**Actual Result:**
- UpdateValue is accepted
- Miner successfully manipulates their next round mining position
- No penalty or detection occurs

**Success Condition:**
The attack succeeds when a miner's UpdateValue with arbitrary OutValue/Signature and Hash.Empty PreviousInValue passes validation and affects their subsequent mining order calculation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L42-46)
```csharp
        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L48-48)
```csharp
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-67)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
