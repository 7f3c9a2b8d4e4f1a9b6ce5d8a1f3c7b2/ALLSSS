### Title
Missing Size Validation on Encrypted Pieces Allows State Bloat Attack

### Summary
The `UpdateLatestSecretPieces()` function accepts and stores encrypted secret sharing pieces without validating their size. A malicious miner can exploit the 5MB transaction limit to submit grossly oversized encrypted pieces, causing persistent state bloat across up to 40,960 stored rounds. This creates a DoS vector through excessive storage consumption.

### Finding Description

The vulnerability exists in the consensus secret sharing mechanism where encrypted pieces are stored without size validation. [1](#0-0) 

The `UpdateLatestSecretPieces()` function iterates through `triggerInformation.EncryptedPieces` and `triggerInformation.DecryptedPieces`, adding them directly to the round state without any size checks. These pieces originate from the `UpdateValueInput` parameter of the public `UpdateValue()` method: [2](#0-1) 

The `ProcessUpdateValue()` function calls `PerformSecretSharing()` which adds all encrypted pieces to state: [3](#0-2) 

At line 290, `minerInRound.EncryptedPieces.Add(input.EncryptedPieces)` stores all pieces without validation. The encrypted_pieces field is defined as a protobuf bytes map with no size constraints: [4](#0-3) 

The validation provider only checks OutValue and PreviousInValue correctness, with no size validation: [5](#0-4) 

The only protection is the transaction size limit of 5MB: [6](#0-5) [7](#0-6) 

However, this limit is insufficient as bloated rounds persist in state for extended periods. The system keeps 40,960 rounds: [8](#0-7) [9](#0-8) 

### Impact Explanation

**State Bloat Severity:** Normal encrypted pieces generated by legitimate secret sharing are approximately 100-200 bytes per piece for ~17 miners, totaling ~3KB. A malicious miner can inflate this to ~4.5MB per UpdateValue transaction (leaving room for other fields within the 5MB transaction limit), achieving a 1500x bloat factor.

**Cumulative Damage:** With 40,960 rounds kept in state, if an attacker bloats even 100 rounds before detection, this results in 450MB of bloated state. A sustained attack across multiple terms could bloat hundreds of rounds, potentially reaching gigabytes of unnecessary state.

**Operational Impact:**
- Full nodes must store and synchronize bloated state data
- New nodes face significantly longer synchronization times
- State queries and consensus operations degrade in performance
- Storage infrastructure costs increase for all network participants
- Potential chain halt if state size becomes unmanageable

**Affected Parties:** All network participants (full nodes, validators, and users) suffer from the degraded performance and increased resource requirements.

### Likelihood Explanation

**Attacker Capabilities:** The attacker must be a valid miner in the current or previous round, as verified by the PreCheck: [10](#0-9) 

**Attack Complexity:** Low. The attacker simply needs to modify their node software to generate oversized encrypted_pieces bytes when calling UpdateValue. No complex cryptographic bypasses or timing attacks are required.

**Feasibility Conditions:** 
- Miner status is required but achievable through the election process
- No additional economic barriers beyond maintaining miner status
- Attack is executable immediately upon becoming a miner
- Can be repeated across multiple rounds/blocks during miner's tenure

**Detection Constraints:** The attack would eventually be detected through monitoring of unusual transaction sizes and state growth, but damage occurs before remediation. Network governance would need to vote to exclude the malicious miner, during which time additional bloat accumulates.

**Economic Rationality:** A malicious actor or compromised miner willing to sacrifice their reputation and future mining rewards could execute this attack to degrade network performance as a form of griefing or competitive attack.

### Recommendation

Implement strict size validation for encrypted and decrypted pieces in the `PerformSecretSharing()` function:

1. **Individual Piece Limit:** Validate each encrypted piece is ≤ 1KB (generous margin above legitimate ~200 byte pieces)
2. **Total Size Limit:** Validate total encrypted_pieces size is ≤ 10KB (allowing for ~17-23 miners with margin)
3. **Count Validation:** Verify number of encrypted pieces matches expected miner count
4. **Add Assertions:**

```csharp
private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round, string publicKey)
{
    const int MaxPieceSize = 1024; // 1KB
    const int MaxTotalSize = 10240; // 10KB
    
    Assert(input.EncryptedPieces.Count <= round.RealTimeMinersInformation.Count, 
        "Too many encrypted pieces.");
    
    var totalSize = 0;
    foreach (var piece in input.EncryptedPieces)
    {
        Assert(piece.Value.Length <= MaxPieceSize, 
            $"Encrypted piece for {piece.Key} exceeds maximum size.");
        totalSize += piece.Value.Length;
    }
    Assert(totalSize <= MaxTotalSize, "Total encrypted pieces size exceeds limit.");
    
    // Similar validation for decrypted pieces
    foreach (var piece in input.DecryptedPieces)
    {
        Assert(piece.Value.Length <= MaxPieceSize, 
            $"Decrypted piece for {piece.Key} exceeds maximum size.");
    }
    
    // Original logic continues...
    minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
    foreach (var decryptedPreviousInValue in input.DecryptedPieces)
        round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
            .Add(publicKey, decryptedPreviousInValue.Value);
    foreach (var previousInValue in input.MinersPreviousInValues)
        round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
}
```

### Proof of Concept

**Initial State:**
- Attacker is a valid miner in current round
- Secret sharing is enabled
- Normal encrypted pieces are ~200 bytes each

**Attack Steps:**

1. Attacker modifies their node's `AEDPoSTriggerInformationProvider` to generate 4.5MB of random bytes for encrypted_pieces instead of legitimate ECIES-encrypted secret shares

2. Attacker produces a block and calls `UpdateValue()` with the malicious `UpdateValueInput` containing bloated encrypted_pieces

3. Transaction passes validation (size < 5MB, signature valid, miner authorized)

4. `ProcessUpdateValue()` executes, calling `PerformSecretSharing()` which adds all 4.5MB to state without validation

5. Round state is stored via `State.Rounds[currentRoundNumber]` containing the bloated data

6. Attacker repeats across multiple blocks in their mining slots

**Expected vs Actual:**
- **Expected:** Encrypted pieces total ~3KB per round, cleaned up after 40,960 rounds
- **Actual:** Encrypted pieces total 4.5MB per affected round, persisting for 40,960 rounds = potential for hundreds of MB to GB of bloat

**Success Condition:** Query `GetRoundInformation()` for affected rounds and observe significantly larger response sizes compared to legitimate rounds. State database size grows abnormally relative to block height.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L136-153)
```csharp
    private void UpdateLatestSecretPieces(Round updatedRound, string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        foreach (var encryptedPiece in triggerInformation.EncryptedPieces)
            updatedRound.RealTimeMinersInformation[pubkey].EncryptedPieces
                .Add(encryptedPiece.Key, encryptedPiece.Value);

        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;

        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** protobuf/aedpos_contract.proto (L194-221)
```text
message UpdateValueInput {
    // Calculated from current in value.
    aelf.Hash out_value = 1;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 2;
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
    // Publish previous in value for validation previous signature and previous out value.
    aelf.Hash previous_in_value = 4;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    google.protobuf.Timestamp actual_mining_time = 5;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 8;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
    // The amount of produced blocks.
    int64 produced_blocks = 10;
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
    // The random number.
    bytes random_number = 13;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L3-6)
```csharp
public class TransactionPoolConsts
{
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
}
```

**File:** src/AElf.Kernel.TransactionPool/Infrastructure/BasicTransactionValidationProvider.cs (L32-41)
```csharp
        if (transaction.CalculateSize() > TransactionPoolConsts.TransactionSizeLimit)
        {
            await LocalEventBus.PublishAsync(new TransactionValidationStatusChangedEvent
            {
                TransactionId = transactionId,
                TransactionResultStatus = TransactionResultStatus.NodeValidationFailed,
                Error = "Transaction size exceeded."
            });
            return false;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L10-10)
```csharp
    public const int KeepRounds = 40960;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```
