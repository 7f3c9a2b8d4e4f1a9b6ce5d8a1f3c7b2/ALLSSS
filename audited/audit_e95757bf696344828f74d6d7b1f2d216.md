# Audit Report

## Title
Missing Cryptographic Validation in Secret Sharing Revelation Allows Consensus Manipulation and Denial of Service

## Summary
The AEDPoS consensus contract accepts revealed InValues from miners via secret sharing without validating that they hash to previously committed OutValues. This breaks the VRF commit-reveal scheme's fundamental cryptographic guarantee, allowing any miner to inject arbitrary values as another miner's PreviousInValue. This enables targeted denial-of-service attacks that prevent specific miners from producing valid blocks, disrupting consensus integrity and enabling mining reward theft.

## Finding Description

### Vulnerability Location

The vulnerability exists in **three distinct code paths** where revealed InValues are set without cryptographic validation:

**Path 1: UpdateLatestSecretPieces** - Block header generation accepts unvalidated revealed InValues from trigger information and directly sets them as other miners' PreviousInValue. [1](#0-0) 

**Path 2: PerformSecretSharing** - Transaction processing accepts unvalidated InValues from transaction input and directly sets them as other miners' PreviousInValue without any hash validation. [2](#0-1) 

**Path 3: RevealSharedInValues** - NextRound processing reconstructs InValues via secret sharing and sets them as PreviousInValue without validating against committed OutValues. [3](#0-2) 

### Root Cause Analysis

In AEDPoS consensus, the commit-reveal scheme requires:
- **Round N**: Miner commits OutValue = Hash(InValue)
- **Round N+1**: Miner reveals InValue
- **Validation**: System must verify Hash(revealed InValue) == committed OutValue

However, the existing validation **only checks the block producer's own PreviousInValue**, not the revealed InValues for other miners: [4](#0-3) 

The validation explicitly uses `validationContext.SenderPubkey` to retrieve and validate only the sender's PreviousInValue. Revealed InValues for other miners bypass this validation entirely.

### Attack Mechanism

**Step 1**: During validation, `RecoverFromUpdateValue` unconditionally copies PreviousInValues from block header to validation context for ALL miners, including unvalidated fake values: [5](#0-4) 

**Step 2**: When the victim miner later produces a block, `ApplyNormalConsensusData` checks if PreviousInValue is already set before updating it: [6](#0-5) 

If an attacker already set a fake PreviousInValue, this condition evaluates to false, and the victim's real PreviousInValue is **not set**. The block header will contain the fake value, causing validation to fail.

**Step 3**: The fake PreviousInValue gets persisted to state when the transaction is processed: [7](#0-6) 

**Step 4**: Round state is retrieved from contract state, containing the attacker's fake values: [8](#0-7) 

### Complete Attack Flow

1. **Round N**: Victim miner A mines successfully, committing OutValue_A = Hash(InValue_A)
2. **Round N+1**: Malicious miner B produces a block and includes fake_InValue for A in `miners_previous_in_values` field of UpdateValueInput transaction
3. `PerformSecretSharing` sets `round.RealTimeMinersInformation[A].PreviousInValue = fake_InValue` without validation
4. Round state is persisted with fake PreviousInValue for miner A
5. **Round N+2**: When miner A tries to produce a block:
   - `TryToGetCurrentRoundInformation` retrieves round with fake PreviousInValue
   - `ApplyNormalConsensusData` sees PreviousInValue is not empty, doesn't overwrite with real value
   - Block header contains fake PreviousInValue
   - Validation calculates Hash(fake_InValue) and compares to OutValue_A
   - Validation fails: Hash(fake_InValue) â‰  OutValue_A
   - **Miner A's block is rejected**

## Impact Explanation

This vulnerability breaks a **fundamental cryptographic invariant** of the AEDPoS consensus mechanism with critical consequences:

### Consensus Integrity Compromise
The commit-reveal VRF scheme is designed to generate unpredictable random values for consensus. By accepting unvalidated revealed InValues, the entire security model collapses. The signature calculation uses PreviousInValue, and signatures determine mining order for the next round via modulo arithmetic: [9](#0-8) 

### Targeted Denial of Service
Any miner can prevent any other specific miner from producing valid blocks. The victim's blocks will be rejected by validation, causing:
- **Mining reward loss**: Victim cannot earn block rewards
- **Network disruption**: Reduced block production capacity
- **Reputation damage**: Victim appears to be offline or malicious

### Mining Order Manipulation
Attackers can strategically block specific miners to influence mining order and timing, enabling:
- **MEV extraction opportunities**
- **Coordination with colluding miners**
- **Strategic timing attacks**

### Affected Parties
- All miners (can be selectively blocked)
- Network participants relying on consensus security
- Smart contracts depending on deterministic block production

**Severity: CRITICAL** - This is not a theoretical vulnerability. It is directly exploitable and breaks core consensus security guarantees.

## Likelihood Explanation

### Attacker Requirements
- Must be a valid miner in current or previous round (normal consensus participant)
- Ability to produce blocks in assigned time slot (standard miner capability)
- Control over off-chain secret sharing service OR transaction input parameters

### Attack Complexity: LOW
The attack requires minimal sophistication:
1. Modify off-chain `SecretSharingService.RevealPreviousInValues()` to return arbitrary hash values
2. OR directly craft `UpdateValueInput` transaction with fake values in `miners_previous_in_values` field
3. Produce block normally during assigned time slot
4. Fake values pass through without validation

### Preconditions
- Secret sharing must be enabled (controlled by configuration)
- Target miner has not already revealed their own PreviousInValue in current round
- These are normal operational conditions when secret sharing is active

### Detection Difficulty: HIGH
- Malicious revealed InValues are indistinguishable from legitimate ones on-chain
- No validation errors occur during block acceptance
- Only off-chain verification against previously committed OutValues would detect the manipulation
- By the time victim's block fails validation, the attack has succeeded

### Economic Rationality: HIGH
Attackers gain significant advantages:
- Eliminate competing miners to increase own block rewards
- Control consensus timing for MEV opportunities
- Zero cost beyond normal block production
- No risk of detection until victim attempts to mine

**Likelihood: HIGH** - This vulnerability is immediately exploitable by any miner with standard capabilities.

## Recommendation

### Immediate Fix
Add cryptographic validation in all three vulnerable paths. Before setting any revealed PreviousInValue, verify:

```csharp
// In UpdateLatestSecretPieces, PerformSecretSharing, and RevealSharedInValues
foreach (var revealedInValue in triggerInformation.RevealedInValues)
{
    if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
    {
        var targetMiner = revealedInValue.Key;
        
        // ADDED VALIDATION: Verify hash matches committed OutValue
        if (TryToGetPreviousRoundInformation(out var prevRound) &&
            prevRound.RealTimeMinersInformation.ContainsKey(targetMiner))
        {
            var committedOutValue = prevRound.RealTimeMinersInformation[targetMiner].OutValue;
            var revealedHash = HashHelper.ComputeFrom(revealedInValue.Value);
            
            if (revealedHash != committedOutValue)
            {
                // Reject invalid revealed InValue
                Context.LogDebug(() => $"Invalid revealed InValue for {targetMiner}");
                continue;
            }
        }
        
        if (updatedRound.RealTimeMinersInformation[targetMiner].PreviousInValue == Hash.Empty ||
            updatedRound.RealTimeMinersInformation[targetMiner].PreviousInValue == null)
        {
            updatedRound.RealTimeMinersInformation[targetMiner].PreviousInValue = revealedInValue.Value;
        }
    }
}
```

Apply this validation pattern to:
1. `UpdateLatestSecretPieces()` at line 148-152
2. `PerformSecretSharing()` at line 295-296  
3. `RevealSharedInValues()` at line 49-52

### Additional Hardening
Consider adding validation in `RecoverFromUpdateValue` to verify PreviousInValues during block header validation, providing defense-in-depth.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanBlockVictim_ByInjectingFakePreviousInValue()
{
    // Setup: Initialize consensus with 3 miners
    var miners = await GenerateMinersAsync(3);
    var victimMiner = miners[0];
    var attackerMiner = miners[1];
    
    // Round N: Victim miner produces block with OutValue
    var victimInValue = HashHelper.ComputeFrom("legitimate_secret");
    var victimOutValue = HashHelper.ComputeFrom(victimInValue);
    await VictimProducesBlockAsync(victimMiner, victimInValue, victimOutValue);
    
    // Round N+1: Attacker injects fake PreviousInValue for victim
    var fakeInValue = HashHelper.ComputeFrom("fake_secret");
    var updateValueInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("attacker_in_value"),
        Signature = GenerateSignature(attackerMiner),
        MinersPreviousInValues = 
        {
            { victimMiner.PublicKey, fakeInValue } // FAKE VALUE INJECTED
        }
    };
    
    await AttackerProducesBlockAsync(attackerMiner, updateValueInput);
    
    // Verify: Fake value was set without validation
    var currentRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    var victimInfo = currentRound.RealTimeMinersInformation[victimMiner.PublicKey];
    victimInfo.PreviousInValue.ShouldBe(fakeInValue); // Fake value was accepted!
    
    // Round N+2: Victim attempts to mine but fails validation
    var victimBlock = await VictimAttemptsToProduceBlockAsync(victimMiner, victimInValue);
    
    // Assertion: Victim's block is REJECTED
    victimBlock.ValidationResult.Success.ShouldBe(false);
    victimBlock.ValidationResult.Message.ShouldContain("Incorrect previous in value");
    
    // Impact: Hash(fake) != victimOutValue, validation fails
    HashHelper.ComputeFrom(fakeInValue).ShouldNotBe(victimOutValue);
}
```

## Notes

This vulnerability represents a **fundamental break in the AEDPoS consensus security model**. The commit-reveal scheme's entire purpose is to prevent manipulation of random values by requiring cryptographic commitment before revelation. Without proper validation of revealed values, the commitment phase becomes meaningless.

The attack is particularly dangerous because:
1. It requires no special privileges beyond being a miner
2. It's undetectable until the victim attempts to mine
3. It can be sustained indefinitely by repeatedly injecting fake values
4. Multiple miners can be targeted simultaneously

The fix must be implemented across all three vulnerable code paths to fully address the issue. Partial fixes will leave attack vectors open.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L28-29)
```csharp
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```
