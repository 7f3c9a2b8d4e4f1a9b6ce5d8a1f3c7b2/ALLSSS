### Title
Authorization Bypass via Malicious Contract Address in Controller Change Functions

### Summary
The `ChangeMaximumMinersCountController()` function and similar controller-changing methods across multiple system contracts fail to validate that the provided `AuthorityInfo.ContractAddress` is a legitimate governance contract (Parliament, Association, or Referendum). An attacker can deploy a malicious contract with a `ValidateOrganizationExist` method that always returns true, then use it to bypass organization existence checks and gain unauthorized control over critical system controllers.

### Finding Description

The vulnerable code is located in the `ChangeMaximumMinersCountController()` function: [1](#0-0) 

The function calls `CheckOrganizationExist(input)` to validate the new controller. The implementation of this method is: [2](#0-1) 

**Root Cause:** The `authorityInfo.ContractAddress` field is user-provided and not validated to be one of the legitimate governance contracts. The code performs a cross-contract call to whatever address the user supplies, allowing an attacker to provide their own malicious contract address.

**Why Protections Fail:** The governance contracts implement `ValidateOrganizationExist` to check if an organization exists in their state: [3](#0-2) 

However, there is no check that ensures the contract being called is actually a legitimate governance contract before making this cross-contract call.

**Execution Path:**
1. Attacker deploys a malicious contract with a `ValidateOrganizationExist` method that always returns `BoolValue { Value = true }`
2. Attacker calls `ChangeMaximumMinersCountController` with `AuthorityInfo`:
   - `ContractAddress`: attacker's malicious contract
   - `OwnerAddress`: any address attacker controls
3. The `CheckOrganizationExist` method calls the malicious contract
4. Malicious contract returns true
5. Validation passes and attacker's address becomes the new controller

**User Contract Deployment:** On main chains and public side chains, users can deploy contracts without restrictions: [4](#0-3) 

This confirms the attack is feasible as attackers can deploy arbitrary contracts.

### Impact Explanation

**Direct Authorization Impact:** The attacker gains unauthorized control over the `MaximumMinersCountController`, which has authority to: [5](#0-4) 

**Consensus Integrity Compromise:** With this control, the attacker can:
- Modify `MaximumMinersCount` to manipulate the number of active miners in consensus
- Change `MinerIncreaseInterval` to disrupt the planned miner growth schedule
- Affect the election contract's miner count calculations

**Severity:** Critical - This violates the fundamental authorization invariant that only legitimate governance organizations should control consensus parameters. The compromise allows direct manipulation of consensus mechanisms that secure the blockchain.

**Affected Parties:** The entire network is affected as consensus parameter manipulation can:
- Disrupt block production schedules
- Affect miner election mechanisms
- Undermine network security through improper miner count management

**Systemic Issue:** This vulnerability pattern exists across multiple critical contracts including Genesis contract's deployment controllers and CrossChain contract's lifetime controller: [6](#0-5) [7](#0-6) 

### Likelihood Explanation

**Reachable Entry Point:** The function is publicly callable and only requires the caller to be the current controller's owner address: [8](#0-7) 

**Attacker Capabilities Required:**
1. Ability to deploy a user contract (available on main chains and public side chains)
2. Initial authorization as current controller (default is Parliament default organization)
3. Craft a malicious contract with `ValidateOrganizationExist` method

**Attack Complexity:** Low - The exploit requires:
- Simple contract deployment (standard operation)
- Single transaction to change controller
- No timing constraints or race conditions
- No complex state manipulation

**Economic Feasibility:** The attack cost is minimal:
- Contract deployment gas fees (standard deployment cost)
- One transaction to call `ChangeMaximumMinersCountController`
- No token staking or economic lock required

**Detection:** The attack is difficult to detect in real-time as the transaction appears legitimate - it's calling a standard controller-change function with valid parameters. Only post-analysis of the provided contract address would reveal the bypass.

**Probability Assessment:** High - Given that similar validation patterns are used across system contracts and the proof of concept showing correct validation exists elsewhere in the codebase, this represents a systematic vulnerability that is practical to exploit.

### Recommendation

**Code-Level Mitigation:** Validate that the `ContractAddress` in `AuthorityInfo` matches one of the legitimate governance contract addresses before calling it. The correct implementation pattern is demonstrated in: [9](#0-8) 

**Specific Fix for AEDPoS Contract:**
```
public override Empty ChangeMaximumMinersCountController(AuthorityInfo input)
{
    RequiredMaximumMinersCountControllerSet();
    AssertSenderAddressWith(State.MaximumMinersCountController.Value.OwnerAddress);
    
    // Add validation that ContractAddress is a legitimate governance contract
    EnsureParliamentContractAddressSet();
    EnsureAssociationContractAddressSet();
    EnsureReferendumContractAddressSet();
    
    var isValidGovernanceContract = 
        input.ContractAddress == State.ParliamentContract.Value ||
        input.ContractAddress == State.AssociationContract.Value ||
        input.ContractAddress == State.ReferendumContract.Value;
    
    Assert(isValidGovernanceContract, "Contract address must be a governance contract.");
    
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    State.MaximumMinersCountController.Value = input;
    return new Empty();
}
```

**Invariant to Add:** Before calling any cross-contract validation method on a user-provided contract address, verify the address matches a known system contract from the system contract registry: [10](#0-9) 

**Test Cases:**
1. Attempt to change controller with non-governance contract address - should fail
2. Attempt to change controller with governance contract but non-existent organization - should fail
3. Attempt to change controller with valid governance contract and valid organization - should succeed
4. Verify system contract address validation using `GetSystemContractNameToAddressMapping()`

**Apply Fix Systematically:** This same validation must be added to all controller-change functions across all contracts including:
- Genesis contract: `ChangeContractDeploymentController`, `ChangeCodeCheckController`
- CrossChain contract: `ChangeSideChainLifetimeController`
- All ACS1 implementations: `ChangeMethodFeeController`
- Any other function accepting `AuthorityInfo` parameters

### Proof of Concept

**Required Initial State:**
- Attacker has ability to deploy contracts (on main chain or public side chain)
- Current MaximumMinersCountController is set to default Parliament organization
- Attacker has obtained authorization from Parliament to execute one transaction (or is exploiting another vulnerability to get initial access)

**Attack Sequence:**

1. **Deploy Malicious Contract:**
   - Attacker deploys contract with code:
   ```csharp
   public BoolValue ValidateOrganizationExist(Address input)
   {
       return new BoolValue { Value = true }; // Always returns true
   }
   ```

2. **Call ChangeMaximumMinersCountController:**
   - Attacker calls with AuthorityInfo:
     - ContractAddress: [address of malicious contract from step 1]
     - OwnerAddress: [attacker's controlled address]

3. **Expected vs Actual Result:**
   - **Expected (Secure):** Transaction should fail with "Invalid authority input" because contract address is not a legitimate governance contract
   - **Actual (Vulnerable):** Transaction succeeds, CheckOrganizationExist calls malicious contract which returns true, validation passes, attacker becomes new MaximumMinersCountController

4. **Verification:**
   - Call `GetMaximumMinersCountController()` 
   - Confirm returned AuthorityInfo.OwnerAddress is attacker's address
   - Attacker can now call `SetMaximumMinersCount()` without governance approval

**Success Condition:** Attacker's address is set as the MaximumMinersCountController owner without the address being a valid organization in any legitimate governance contract, bypassing all governance controls.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L45-54)
```csharp
    public override Empty ChangeMaximumMinersCountController(AuthorityInfo input)
    {
        RequiredMaximumMinersCountControllerSet();
        AssertSenderAddressWith(State.MaximumMinersCountController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MaximumMinersCountController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L83-88)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L41-42)
```csharp
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Unauthorized to create organization.");
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L366-373)
```csharp
    public override Empty ChangeContractDeploymentController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.ContractDeploymentController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L61-73)
```csharp
    public override Empty ChangeCrossChainIndexingController(AuthorityInfo input)
    {
        AssertCrossChainIndexingControllerAuthority(Context.Sender);
        SetContractStateRequired(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);
        Assert(
            input.ContractAddress == State.ParliamentContract.Value &&
            ValidateParliamentOrganization(input.OwnerAddress), "Invalid authority input.");
        State.CrossChainIndexingController.Value = input;
        Context.Fire(new CrossChainIndexingControllerChanged
        {
            AuthorityInfo = input
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L76-85)
```csharp
    public override Empty ChangeSideChainLifetimeController(AuthorityInfo input)
    {
        AssertSideChainLifetimeControllerAuthority(Context.Sender);
        Assert(ValidateAuthorityInfoExists(input), "Invalid authority input.");
        State.SideChainLifetimeController.Value = input;
        Context.Fire(new SideChainLifetimeControllerChanged
        {
            AuthorityInfo = input
        });
        return new Empty();
```
