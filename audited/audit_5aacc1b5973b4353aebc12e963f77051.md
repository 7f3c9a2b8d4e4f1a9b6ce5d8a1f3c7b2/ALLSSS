# Audit Report

## Title
Pricing Discrepancy in GetNeededDeposit Due to TotalSupply vs Actual Balance Mismatch

## Summary
The `GetNeededDeposit()` function incorrectly uses `tokenInfo.TotalSupply` as the connector balance for Bancor pricing calculations, while actual `Buy`/`Sell` operations use the converter's real token holdings via `GetSelfBalance()`. When tokens are distributed before enabling the connector, this creates a significant pricing mismatch that results in unexpected trading prices and potential financial losses.

## Finding Description

The TokenConverter contract exhibits an inconsistent balance calculation between deposit initialization and trading operations.

In `GetNeededDeposit()`, the toConnectorBalance parameter uses `tokenInfo.TotalSupply` for Bancor pricing. [1](#0-0) 

The function calculates tokens outside the converter but still uses total supply for pricing. [2](#0-1) 

However, in actual trading operations, `GetSelfBalance()` is used to determine connector balances. For resource tokens (non-deposit accounts), this returns only the actual balance held by the converter contract. [3](#0-2) 

The `Buy` operation uses these actual balances for Bancor pricing. [4](#0-3) 

Similarly, the `Sell` operation uses the actual balances. [5](#0-4) 

**Execution Flow:**
1. Token created with TotalSupply = 1,000,000
2. 900,000 tokens distributed to users (staked/locked/held)
3. `EnableConnector` called with AmountToTokenConvert = 100,000
4. `GetNeededDeposit` calculates deposit using TotalSupply = 1,000,000
5. Connector is enabled with 100,000 tokens actually deposited
6. `Buy`/`Sell` operations price based on actual balance = 100,000
7. Result: 10x discrepancy in the balance parameter used for pricing

## Impact Explanation

**Medium Severity - Financial Loss Through Pricing Inaccuracy**

The Bancor formula used for pricing is highly sensitive to connector balance values. [6](#0-5) 

When the toConnectorBalance used in deposit calculation is significantly different from what's used in actual trading:

1. **Incorrect Prices**: The formula `((tb / (tb - amount))^(wt/wf) - 1) * fb` produces drastically different results when `tb` varies by 10x
2. **User Financial Loss**: Buyers pay more than expected based on initial deposit calculations because smaller `tb` values increase the price ratio
3. **Reserve Miscalculation**: The initial deposit may be insufficient to support the actual price curve that results from the lower balance
4. **Economic Instability**: The converter's economic model breaks down when pricing assumptions don't match reality

For example, with TotalSupply = 1M but only 100K actually in the converter, users expecting prices based on 1M supply face 10x higher costs due to the 100K actual balance being used in trading.

## Likelihood Explanation

**High Likelihood - Standard Operational Pattern**

This vulnerability triggers naturally in common token deployment workflows:

1. **Resource Token Distribution**: Tokens like CPU, RAM, or governance tokens are often issued and distributed before trading begins
2. **Staking/Locking Scenarios**: Users may stake or lock tokens before the converter is enabled, reducing available supply
3. **Phased Rollout**: Projects commonly distribute tokens first for utility purposes, then enable trading later
4. **No Special Privileges Required**: Any token creator following standard practices encounters this issue

The scenario requires no attacker capabilities - it occurs through normal operations when:
- Tokens have pre-existing utility (staking, governance)
- Distribution happens before trading activation
- Not all issued tokens are deposited into the converter

This is the expected workflow documented in tests where tokens are issued before connector enablement. [7](#0-6) 

## Recommendation

Modify `GetNeededDeposit()` to calculate the toConnectorBalance based on the actual balance that will be in the converter after `EnableConnector` completes, not the total supply.

**Suggested fix:**
Replace the toConnectorBalance calculation to use the expected post-EnableConnector balance:
```
var expectedBalance = balance + input.AmountToTokenConvert;
var tb = toConnector.IsVirtualBalanceEnabled
    ? toConnector.VirtualBalance.Add(expectedBalance)
    : expectedBalance;
```

This ensures consistency between deposit calculation and subsequent trading operations, as both would then use the actual converter balance.

## Proof of Concept

The test case demonstrates the discrepancy can be verified by:

1. Creating a token with TotalSupply = 100_0000_0000
2. Issuing only a portion (e.g., 10_0000_0000) to be deposited
3. Distributing the remainder (90_0000_0000) to users
4. Calling `GetNeededDeposit` - it uses TotalSupply for calculation
5. Enabling the connector with the smaller amount
6. Executing `Buy` operation - pricing based on actual deposited amount
7. Comparing expected price (based on TotalSupply) vs actual price (based on deposited amount)

The pricing discrepancy would be immediately observable through the different `amountToPay` values calculated by the Bancor formula with the divergent balance parameters.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-73)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L78-80)
```csharp
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-94)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L386-399)
```csharp
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Amount = 99_9999_0000,
            To = DefaultSender,
            Symbol = tokenSymbol
        });
        var toBeBuildConnectorInfo = new ToBeConnectedTokenInfo
        {
            TokenSymbol = tokenSymbol,
            AmountToTokenConvert = 99_9999_0000
        };
        var deposit = await DefaultStub.GetNeededDeposit.CallAsync(toBeBuildConnectorInfo);
        deposit.NeedAmount.ShouldBe(100);
        await DefaultStub.EnableConnector.SendAsync(toBeBuildConnectorInfo);
```
