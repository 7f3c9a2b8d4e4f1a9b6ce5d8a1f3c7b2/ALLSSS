### Title
Side Chain Miner List Synchronization Delay Allows Replaced Miners to Maintain Control

### Summary
The SideChainConsensusBehaviourProvider unconditionally returns NextRound behavior, requiring side chain miner list updates to go through the governance-gated cross-chain indexing process. This creates a synchronization delay window where miners who have been replaced on the parent chain (potentially for malicious behavior) continue controlling the side chain, violating cross-chain consensus integrity.

### Finding Description

The vulnerability exists in the consensus behavior determination and cross-chain synchronization mechanism: [1](#0-0) 

Unlike the main chain which can immediately transition to a new term with updated miners via NextTerm behavior, side chains always use NextRound. The side chain miner list update mechanism relies on checking `State.MainChainCurrentMinerList.Value` during round generation: [2](#0-1) 

This state variable is only updated when parent chain blocks are indexed via cross-chain indexing: [3](#0-2) 

However, cross-chain indexing requires a multi-step governance process:

1. A miner proposes indexing via `ProposeCrossChainIndexing`: [4](#0-3) 

2. Parliament must approve the proposal (requiring miner votes)

3. A miner releases the proposal via `ReleaseCrossChainIndexingProposal`: [5](#0-4) 

The proposal creation includes a 120-second expiration period: [6](#0-5) 

During the entire governance process (proposal → approval → release), the side chain continues producing blocks with the OLD miner list because `IsMainChainMinerListChanged` returns false until `UpdateInformationFromCrossChain` executes: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Violation**: The side chain operates with miners who are no longer authorized on the parent chain, breaking the fundamental cross-chain consensus assumption that parent and side chains share the same miner set.

**Continued Control by Replaced Miners**: If parent chain miners were replaced during election due to poor performance or malicious behavior (marked as evil miners), those same miners continue producing side chain blocks during the synchronization delay. This allows potentially compromised miners to:
- Continue earning side chain block rewards
- Execute transactions on the side chain
- Potentially collude to delay or block the governance approval process
- Maintain indefinite control if they constitute a governance majority

**Cross-Chain State Divergence**: The parent chain views new miners {D, E, F} as authoritative, while the side chain operates with old miners {A, B, C}, creating inconsistent cross-chain state that could affect cross-chain transactions and verifications.

**Severity Justification**: CRITICAL - This affects core consensus integrity, happens on every parent chain term change, and enables replaced miners to maintain unauthorized control over a side chain.

### Likelihood Explanation

**Reachable Entry Point**: The vulnerability is triggered automatically whenever the parent chain undergoes a term transition via `ProcessNextTerm`: [8](#0-7) 

**Feasible Preconditions**: 
- Parent chain term changes occur regularly based on the configured period (typically every few days)
- No special attacker capabilities required - this is inherent in the design
- The governance approval process introduces unavoidable delay

**Execution Practicality**: The issue manifests in normal operation:
1. Parent chain automatically transitions terms when period elapses
2. Side chain continues with old miners until cross-chain indexing completes
3. Old miners control the proposal/approval process during the delay window
4. Minimum delay: multiple rounds (120+ seconds per proposal attempt)

**Exploitation Potential**: Old miners who retain side chain control can:
- Intentionally delay governance approval by abstaining or rejecting proposals
- Block new proposals within the 120-second expiration window
- Force repeated proposal cycles to extend their control period
- This is particularly dangerous if old miners were removed for malicious behavior

**Detection Constraints**: The delayed synchronization appears as normal operation since the governance process is intentionally designed this way, making malicious delays difficult to distinguish from legitimate governance delays.

### Recommendation

**Immediate Mitigation** - Add an automatic synchronization path for miner list updates that bypasses governance when the parent chain undergoes a term change:

1. Modify `SideChainConsensusBehaviourProvider` to detect parent chain term changes and return `NextTerm` when synchronization is required, checking a flag set by `UpdateInformationFromCrossChain` when a term number change is detected.

2. Alternatively, create a privileged synchronization path in `UpdateInformationFromCrossChain` that allows immediate miner list updates when the parent chain's term number changes, bypassing the standard governance approval for this critical consensus operation.

3. Add a state variable tracking the last synced parent chain term number, and assert in `GenerateNextRoundInformation` that the side chain cannot fall more than 1 term behind the parent chain.

**Invariant Check** - Add validation in consensus command generation:
```
Assert(
    State.MainChainCurrentMinerList.Value.IsEmpty || 
    GetCurrentTermNumber() >= State.LastSyncedParentChainTermNumber.Value,
    "Side chain miner list critically out of sync with parent chain"
);
```

**Test Cases**:
- Test side chain behavior when parent chain transitions terms
- Test that miner list synchronization completes within 1-2 rounds maximum
- Test that old miners cannot block or indefinitely delay synchronization
- Test cross-chain transaction verification during the synchronization window

### Proof of Concept

**Initial State**:
- Parent chain at term N, round R with miners: {PubkeyA, PubkeyB, PubkeyC}
- Side chain at round S with same miners: {PubkeyA, PubkeyB, PubkeyC}
- Both chains operating normally

**Attack Sequence**:

1. **T0**: Parent chain reaches term period threshold, `MainChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` returns `NextTerm`

2. **T0+1**: Parent chain executes `NextTerm`, calling `ProcessNextTerm` which updates miner list to {PubkeyD, PubkeyE, PubkeyF} via `SetMinerList`

3. **T0+2**: Side chain miner A produces block, `SideChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` returns `NextRound`

4. **T0+3**: Side chain calls `GenerateNextRoundInformation`, which invokes `IsMainChainMinerListChanged`. Returns FALSE because `State.MainChainCurrentMinerList.Value` still contains {PubkeyA, PubkeyB, PubkeyC}

5. **T0+4**: Side chain generates next round with OLD miner list {PubkeyA, PubkeyB, PubkeyC}

6. **T0+5**: Node calls `PrepareExtraDataForNextMiningAsync`, which prepares `ProposeCrossChainIndexing` transaction

7. **T0+6**: Miner A proposes cross-chain indexing with 120-second expiration

8. **T0+7 to T0+126**: Governance approval process occurs. During this time:
   - Side chain continues producing blocks with {PubkeyA, PubkeyB, PubkeyC}
   - Parent chain is producing blocks with {PubkeyD, PubkeyE, PubkeyF}
   - Multiple side chain rounds complete with the outdated miner list

9. **T0+127**: If proposal expires without approval, it is cleared and the process repeats from step 6

10. **T0+N**: Eventually, if/when the proposal is approved and released, `IndexParentChainBlockData` executes, `UpdateInformationFromCrossChain` updates `State.MainChainCurrentMinerList.Value` to {PubkeyD, PubkeyE, PubkeyF}

11. **T0+N+1**: Next `GenerateNextRoundInformation` call detects the change and generates a new round with {PubkeyD, PubkeyE, PubkeyF}

**Expected Result**: Side chain should synchronize miner list immediately when parent chain changes terms (within 1-2 rounds maximum).

**Actual Result**: Side chain continues with old miner list for minimum 120 seconds (one proposal cycle) and potentially indefinitely if old miners block governance approval. This allows replaced miners to maintain unauthorized control over the side chain.

**Success Condition**: Observe side chain block production by {PubkeyA, PubkeyB, PubkeyC} continuing for multiple rounds after parent chain has transitioned to {PubkeyD, PubkeyE, PubkeyF}, demonstrating the synchronization delay vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-23)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L285-295)
```csharp
    private void GenerateNextRoundInformation(Round currentRound, Timestamp currentBlockTime, out Round nextRound)
    {
        TryToGetPreviousRoundInformation(out var previousRound);
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L349-354)
```csharp
    private bool IsMainChainMinerListChanged(Round currentRound)
    {
        return State.MainChainCurrentMinerList.Value.Pubkeys.Any() &&
               GetMinerListHash(currentRound.RealTimeMinersInformation.Keys) !=
               GetMinerListHash(State.MainChainCurrentMinerList.Value.Pubkeys.Select(p => p.ToHex()));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-64)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-291)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L407-409)
```csharp
                    ExpiredTime =
                        Context.CurrentBlockTime.AddSeconds(CrossChainIndexingProposalExpirationTimePeriod),
                    OrganizationAddress = crossChainIndexingController.OwnerAddress,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-189)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
```
