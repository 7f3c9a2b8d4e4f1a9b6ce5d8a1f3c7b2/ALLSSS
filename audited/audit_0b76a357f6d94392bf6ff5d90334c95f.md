### Title
Missing Upper Bound Validation in SetMaximumMinersCount Enables Potential Consensus DoS via Expensive Secret Sharing Computation

### Summary
The `SetMaximumMinersCount` method lacks upper bound validation, only checking that the input is greater than zero. If governance sets an excessively large value, the `RevealSharedInValues` function during next-round block production will perform O(minimumCount²) polynomial interpolation operations through `SecretSharingHelper.DecodeSecret`, potentially causing the extra block producer to fail generating the consensus header and disrupting consensus progression.

### Finding Description

**Root Cause:**
The `SetMaximumMinersCount` method only validates that the input is positive but does not enforce any upper bound: [1](#0-0) 

This value is then propagated to the Election contract without additional validation: [2](#0-1) 

**Execution Path:**

1. When a new term begins, `GetVictories` returns up to `State.MinersCount.Value` miners, which can be set arbitrarily high through `SetMaximumMinersCount`: [3](#0-2) 

2. These miners populate the `RealTimeMinersInformation` dictionary for the new round.

3. During next-round transition, the extra block producer calls `GetConsensusExtraDataForNextRound`, which invokes `RevealSharedInValues`: [4](#0-3) 

4. `RevealSharedInValues` calculates `minimumCount` based on the miner count without bounds checking: [5](#0-4) 

5. For each previous miner, it calls `SecretSharingHelper.DecodeSecret` with this `minimumCount`: [6](#0-5) 

6. `DecodeSecret` performs O(threshold²) iterations with nested loops involving expensive BigInteger operations (multiplication, modulo, GCD calculations, and modular inverse): [7](#0-6) 

**Why Existing Protections Fail:**
- No upper bound validation in `SetMaximumMinersCount`
- No constraint on `RealTimeMinersInformation.Count` usage in `RevealSharedInValues`
- No computational complexity guards in the secret sharing flow
- The system initialization sets `MaximumMinersCount` to `int.MaxValue` by default: [8](#0-7) 

### Impact Explanation

**Concrete Harm:**
- If `MinersCount` is set to 10,000, `minimumCount` becomes ~6,666
- `DecodeSecret` performs 6,666 × 6,666 ≈ 44 million iterations
- Each iteration involves BigInteger multiplication, modulo operations, GCD calculation via `MultiplyRational`, and extended GCD via `Inverse`
- This computation occurs during consensus header generation by the extra block producer

**Affected Parties:**
- The extra block producer attempting to transition to the next round
- The entire network if consensus cannot progress due to failed round transitions
- All validators and users depending on block production

**Severity Justification:**
This is a **MEDIUM** severity issue because:
- **High Impact**: Potential consensus halt or severe degradation
- **Medium-Low Likelihood**: Requires governance approval to set unrealistic `MaximumMinersCount` AND requires enough valid candidates to populate that many miners
- **Clear Code Defect**: Missing validation is a concrete flaw regardless of practical constraints

### Likelihood Explanation

**Attacker Capabilities:**
- Requires governance (Parliament by default) to pass a proposal calling `SetMaximumMinersCount` with a large value
- Not a unilateral attack; requires social consensus or governance compromise
- Authority check enforced: [9](#0-8) 

**Feasibility Conditions:**
1. Governance must approve setting `MaximumMinersCount` to a large value (e.g., 1,000+)
2. Sufficient valid candidates must exist to reach that threshold (candidates with votes > 0, not evil nodes)
3. These candidates must participate in secret sharing for the vulnerability to manifest
4. The system reaches a term transition where `GetVictories` returns the large miner set

**Practical Constraints:**
- In production, having thousands of registered candidates with active votes is unlikely
- Even moderate values (500-1000 miners) would cause noticeable performance impact
- The system would likely experience other consensus issues (network latency, bandwidth) before computational limits
- However, on test networks or through coordinated action, reaching problematic thresholds is possible

**Detection:**
- Setting extremely high `MaximumMinersCount` values would be visible in governance proposals
- Performance degradation would become apparent during round transitions

### Recommendation

**Immediate Mitigation:**
Add an upper bound constant and validate it in `SetMaximumMinersCount`:

```csharp
public override Empty SetMaximumMinersCount(Int32Value input)
{
    EnsureElectionContractAddressSet();
    
    Assert(input.Value > 0, "Invalid max miners count.");
    Assert(input.Value <= AEDPoSContractConstants.MaximumAllowedMinersCount, 
        "Max miners count exceeds allowed limit.");
    
    // ... rest of method
}
```

Define a reasonable constant in `AEDPoSContractConstants.cs`:
```csharp
public const int MaximumAllowedMinersCount = 200; // Or other reasonable limit
```

**Additional Safeguards:**
1. Add a validation check in `RevealSharedInValues` before calling `DecodeSecret`:

```csharp
var minimumCount = minersCount.Mul(2).Div(3);
Assert(minimumCount <= AEDPoSContractConstants.MaximumSecretSharingThreshold,
    "Secret sharing threshold exceeds safe computation limit.");
```

2. Document the computational complexity constraints in the election and consensus documentation

3. Add integration tests that verify behavior with maximum allowed miner counts

**Invariant to Enforce:**
`State.MaximumMinersCount.Value <= MaximumAllowedMinersCount` at all times

### Proof of Concept

**Initial State:**
- Blockchain initialized with consensus and election contracts
- Parliament governance contract configured as `MaximumMinersCountController`

**Attack Sequence:**

1. **Governance Proposal Creation:**
   - Parliament member creates proposal to call `SetMaximumMinersCount` with value 5,000
   - Proposal passes through governance voting

2. **Execution:**
   - `SetMaximumMinersCount(5000)` is executed
   - `State.MaximumMinersCount.Value` set to 5,000
   - `UpdateMinersCount(5000)` called on Election contract
   - `State.MinersCount.Value` set to 5,000 in Election contract

3. **Term Transition:**
   - Assume 5,000 valid candidates exist (registered with votes)
   - `NextTerm` is triggered
   - `GetVictories` returns 5,000 miner pubkeys
   - `GenerateFirstRoundOfNewTerm` creates `RealTimeMinersInformation` with 5,000 entries

4. **Next Round Transition:**
   - Extra block producer calls `GetConsensusExtraData` with `NextRound` behavior
   - `GetConsensusExtraDataForNextRound` is invoked
   - `RevealSharedInValues` is called with `currentRound` containing 5,000 miners
   - `minimumCount = 5000 * 2 / 3 = 3,333`
   - For each of potentially 5,000 previous miners with sufficient encrypted/decrypted pieces:
     - `DecodeSecret(sharedParts, orders, 3333)` is called
     - Performs 3,333 × 3,333 ≈ 11 million iterations with BigInteger operations
   
**Expected vs Actual Result:**
    - **Expected**: Extra block producer generates consensus header and transitions to next round
    - **Actual**: Computation exceeds practical execution limits, causing timeout, excessive resource consumption, or failed block generation

**Success Condition:**
The consensus round transition fails or experiences significant delay due to excessive computation in `RevealSharedInValues`, demonstrating the DoS impact.

**Notes**

While the practical likelihood is reduced by the requirement for governance approval and the need for an unrealistic number of valid candidates, this represents a concrete code defect. The lack of upper bound validation violates defensive programming principles and could manifest under specific conditions including:
- Misconfigured test networks
- Malicious or compromised governance
- Future protocol changes that increase candidate participation

The recommended mitigation is straightforward and should be implemented to ensure the system remains robust against both accidental misconfiguration and potential governance-level attacks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L14-14)
```csharp
        Assert(input.Value > 0, "Invalid max miners count.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L17-18)
```csharp
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L157-157)
```csharp
        State.MinersCount.Value = input.MinersCount;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-83)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L52-52)
```csharp
        State.MaximumMinersCount.Value = int.MaxValue;
```
