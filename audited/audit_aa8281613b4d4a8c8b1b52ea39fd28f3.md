### Title
Uninitialized Rental State Enables Free Resource Usage on Side Chains

### Summary
The `State.Rental` mapping is not initialized during side chain setup and lacks validation before rental calculation. If the side chain rental controller fails to call `UpdateRental` after initialization, the rental unit values remain at their default value of zero, resulting in no rental charges being applied when `PayRental()` executes. This allows side chains to consume resources indefinitely without paying the intended rental fees.

### Finding Description

The vulnerability exists in the rental charging mechanism for side chains. The state variable `State.Rental` is defined as a `MappedState<string, long>` [1](#0-0) , which defaults to 0 for uninitialized keys in C#.

During side chain initialization via `InitializeFromParentChain`, only the `State.ResourceAmount` values are set, but `State.Rental` is not initialized [2](#0-1) . The rental unit values must be set separately through the `UpdateRental` method [3](#0-2) , which requires authorization from the side chain rental controller [4](#0-3) .

The rental calculation in `PayRental()` multiplies the duration, resource amount, and rental unit value: `var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);` [5](#0-4) . If `State.Rental[symbol]` is 0 (uninitialized), the entire rental calculation results in 0, and no fees are charged [6](#0-5) .

The `PayRental()` function is automatically invoked on side chains when miners call `DonateResourceToken` [7](#0-6) . Critically, there is no validation in `PayRental()` that checks whether `State.Rental[symbol]` has been properly initialized or is greater than zero before performing the rental calculation [8](#0-7) .

The `GetOwningRentalUnitValue()` view function simply reads and returns the current `State.Rental` values without any checks [9](#0-8) , making it possible to observe that rental values are zero but providing no enforcement mechanism.

### Impact Explanation

**Economic Impact**: A side chain can exploit this vulnerability to consume computational resources (CPU, RAM, DISK, NET) indefinitely without paying rental fees to the parent chain's consensus contract. This directly violates the economic model where side chains must pay ongoing rental costs proportional to their resource consumption.

**Affected Parties**: 
- Parent chain validators who should receive rental fee distributions lose expected revenue
- The economic security model is undermined as side chains can operate without the intended cost barrier
- Other properly-paying side chains are disadvantaged

**Severity Justification**: HIGH - This represents a complete bypass of the rental fee mechanism, allowing unlimited resource consumption at zero cost. The vulnerability breaks a critical economic invariant (rental fees must be charged for resource usage) and can result in substantial economic loss over time as rental fees accumulate every minute the side chain operates.

### Likelihood Explanation

**Attack Requirements**:
1. Side chain must be initialized via `InitializeFromParentChain` (sets `State.ResourceAmount`)
2. Side chain rental controller must NOT call `UpdateRental` to set rental unit values
3. `DonateResourceToken` is called by miners (happens automatically each block)

**Feasibility**: MEDIUM-HIGH
- The side chain rental controller is typically governed by an association or parliament organization
- Either through malicious intent or operational negligence, the controller could delay or refuse to call `UpdateRental`
- No code-level enforcement requires `UpdateRental` to be called before `DonateResourceToken` executes
- The vulnerability is passively exploited - the attacker simply needs to NOT perform the initialization step

**Detection Constraints**: The issue may go unnoticed initially since:
- `GetOwningRentalUnitValue()` would return zero values, but this might be assumed to be a temporary pre-configuration state
- Rental charges appear to execute successfully (events fire), but with zero amounts
- No transaction reverts or obvious errors occur

**Attack Complexity**: LOW - The "attack" is simply omitting a required initialization step rather than executing complex exploits.

### Recommendation

**Immediate Fix**:
Add validation in the `PayRental()` function to ensure rental unit values are initialized before calculating charges:

```csharp
private void PayRental()
{
    var creator = State.SideChainCreator.Value;
    if (creator == null) return;
    if (State.LastPayRentTime.Value == null)
    {
        State.LastPayRentTime.Value = Context.CurrentBlockTime;
        return;
    }

    var duration = (Context.CurrentBlockTime - State.LastPayRentTime.Value).Seconds.Div(60);
    if (duration == 0) return;

    State.LastPayRentTime.Value += new Duration { Seconds = duration.Mul(60) };

    foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
    {
        // ADD THIS CHECK
        Assert(State.Rental[symbol] > 0, 
            $"Rental unit value for {symbol} not initialized. Call UpdateRental first.");
        
        // ... rest of rental calculation
    }
}
```

**Additional Safeguards**:
1. Add a state flag `State.RentalInitialized` that must be set to true by `UpdateRental` and checked by `PayRental()`
2. Require `UpdateRental` to be called as part of the `InitializeFromParentChain` transaction sequence
3. Add validation in `UpdateRental` to ensure all rental symbols are set in a single transaction

**Test Cases**:
1. Verify that `PayRental()` reverts when called before `UpdateRental` has been executed
2. Test that partial initialization (some symbols set, others not) is properly rejected
3. Ensure rental charges are correctly calculated only after proper initialization

### Proof of Concept

**Initial State**:
1. Side chain contract deployed
2. Parliament/Association organization created for side chain governance

**Exploitation Sequence**:
1. Call `InitializeFromParentChain` with resource amounts:
   - Input: `{ ResourceAmount: { "CPU": 4, "RAM": 8, "DISK": 512, "NET": 1000 }, Creator: <address> }`
   - Result: `State.ResourceAmount` is set, but `State.Rental` remains at default 0

2. Call `InitializeAuthorizedController`:
   - Result: Creates rental controller authority, but does NOT initialize rental values

3. **Omit calling `UpdateRental`** (the exploitation step - simply don't initialize rental values)

4. Miners automatically call `DonateResourceToken` once per block:
   - This triggers `PayRental()` on side chains
   - Rental calculation: `rental = duration * ResourceAmount * 0 = 0`
   - Result: Zero rental charged, creator keeps all balance

5. Verify exploitation via `GetOwningRentalUnitValue()`:
   - Expected: Rental unit values should be > 0 (e.g., 100 per the test)
   - Actual: Returns 0 for all symbols
   - Side chain continues operating with zero rental charges

**Success Condition**: Side chain operates for extended period (hours/days) with `State.OwningRental` remaining at 0 and creator balance unchanged despite continuous resource consumption. The vulnerability is confirmed when `rental = 0` in `PayRental()` due to uninitialized `State.Rental[symbol]` values.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L31-31)
```csharp
    public MappedState<string, long> Rental { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L14-26)
```csharp
    public override Empty InitializeFromParentChain(InitializeFromParentChainInput input)
    {
        Assert(!State.InitializedFromParentChain.Value, "MultiToken has been initialized");
        State.InitializedFromParentChain.Value = true;
        Assert(input.Creator != null, "creator should not be null");
        foreach (var pair in input.ResourceAmount) State.ResourceAmount[pair.Key] = pair.Value;

        foreach (var pair in input.RegisteredOtherTokenContractAddresses)
            State.CrossChainTransferWhiteList[pair.Key] = pair.Value;

        SetSideChainCreator(input.Creator);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L947-950)
```csharp
        if (!isMainChain)
        {
            PayRental();
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1019-1097)
```csharp
    private void PayRental()
    {
        var creator = State.SideChainCreator.Value;
        if (creator == null) return;
        if (State.LastPayRentTime.Value == null)
        {
            // Initial LastPayRentTime first calling DonateResourceToken.
            State.LastPayRentTime.Value = Context.CurrentBlockTime;
            return;
        }

        // We need minutes.
        var duration = (Context.CurrentBlockTime - State.LastPayRentTime.Value).Seconds.Div(60);
        if (duration == 0)
        {
            return;
        }

        // Update LastPayRentTime if it is ready to charge rental.
        State.LastPayRentTime.Value += new Duration { Seconds = duration.Mul(60) };

        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
        {
            var donates = 0L;

            var availableBalance = GetBalance(creator, symbol);

            // Try to update owning rental.
            var owningRental = State.OwningRental[symbol];
            if (owningRental > 0)
            {
                // If Creator own this symbol and current balance can cover the debt, pay the debt at first.
                if (availableBalance > owningRental)
                {
                    donates = owningRental;
                    // Need to update available balance,
                    // cause existing balance not necessary equals to available balance.
                    availableBalance = availableBalance.Sub(owningRental);
                    State.OwningRental[symbol] = 0;
                }
            }

            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
            if (availableBalance >= rental) // Success
            {
                donates = donates.Add(rental);
                ModifyBalance(creator, symbol, -donates);
            }
            else // Fail
            {
                // Donate all existing balance. Directly reset the donates.
                donates = GetBalance(creator, symbol);
                State.Balances[creator][symbol] = 0;

                // Update owning rental to record a new debt.
                var own = rental.Sub(availableBalance);
                State.OwningRental[symbol] = State.OwningRental[symbol].Add(own);

                Context.Fire(new RentalAccountBalanceInsufficient
                {
                    Symbol = symbol,
                    Amount = own
                });
            }

            // Side Chain donates.
            var consensusContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
            ModifyBalance(consensusContractAddress, symbol, donates);

            Context.Fire(new RentalCharged()
            {
                Symbol = symbol,
                Amount = donates,
                Payer = creator,
                Receiver = consensusContractAddress
            });
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1099-1112)
```csharp
    public override Empty UpdateRental(UpdateRentalInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.Rental)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.Rental[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L407-413)
```csharp
    private void AssertControllerForSideChainRental()
    {
        Assert(State.SideChainRentalController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");
        // ReSharper disable once PossibleNullReferenceException
        Assert(State.SideChainRentalController.Value.OwnerAddress == Context.Sender, "no permission");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L170-177)
```csharp
    public override OwningRentalUnitValue GetOwningRentalUnitValue(Empty input)
    {
        var rentalResourceUnitValue = new OwningRentalUnitValue();
        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
            rentalResourceUnitValue.ResourceUnitValue[symbol] = State.Rental[symbol];

        return rentalResourceUnitValue;
    }
```
