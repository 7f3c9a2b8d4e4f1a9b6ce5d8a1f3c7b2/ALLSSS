[
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [External Call] State.TokenContract.GetTokenInfo.Call at line 80 is external call - can reentrancy during this call allow double protocol creation before line 79 assertion? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_cb7b29f8-7166-42d7-9fe6-ccbe7b18d363?mode=deep",
    "timestamp": "2026-02-19 02:35:30.819928",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [State Race] Between checking State.NftProtocolMap (line 79) and setting it (line 108), can concurrent CrossChainCreate calls create duplicate protocols? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_e299e252-8290-45f4-9ef2-25ffe85f471c?mode=deep",
    "timestamp": "2026-02-19 02:35:53.270747",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [Initialization Race] InitialNFTTypeNameMap() at line 78 and MakeSureTokenContractAddressSet() at line 77 - can concurrent calls cause race conditions in initialization? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_8c9127e7-8086-4d76-869f-ba210b01f41f?mode=deep",
    "timestamp": "2026-02-19 02:36:15.525010",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Authorization Bypass] AssertSenderIsParliamentDefaultAddress() at line 133 - can the Parliament address be manipulated, uninitialized, or compromised to allow unauthorized NFT type additions? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_302ec38a-7d8e-4a45-b33e-6260b79227d7?mode=deep",
    "timestamp": "2026-02-19 02:36:38.317463",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Parliament Contract Manipulation] If State.ParliamentContract.Value at line 174 is null and GetContractAddressByName returns wrong address, can unauthorized users bypass authorization at line 181? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_13be9989-1518-4c98-ad41-c967a85a9dcc?mode=deep",
    "timestamp": "2026-02-19 02:37:01.961561",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Default Address Override] State.ParliamentDefaultAddress.Value at line 178 relies on Parliament contract - if Parliament is compromised, can attackers change default address to authorize themselves? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_8c4a43d7-1ead-4289-a3bc-0c2ec73d36c6?mode=deep",
    "timestamp": "2026-02-19 02:37:27.109113",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Context.Sender Spoofing] Line 181 checks Context.Sender == State.ParliamentDefaultAddress.Value - can transaction origin spoofing bypass this check? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_9affda74-3ef8-40ed-adcb-800e3a85cc5a?mode=deep",
    "timestamp": "2026-02-19 02:37:52.748853",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Short Name Length] Line 136 asserts input.ShortName.Length == 2, but doesn't validate characters - can special chars, unicode, or control characters corrupt NFT type mappings? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_79c84aa0-5086-497c-97a1-2453a87c460e?mode=deep",
    "timestamp": "2026-02-19 02:38:18.574196",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Short Name Collision] Line 137 checks State.NFTTypeFullNameMap[input.ShortName] == null - can case sensitivity issues (e.g., 'AR' vs 'ar') allow duplicate NFT types? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_857af6bf-13c8-4fd8-b91b-d78ba30f4902?mode=deep",
    "timestamp": "2026-02-19 02:38:44.793322",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Full Name Validation] input.FullName at line 135 has no length/character validation - can empty strings, extremely long names, or SQL injection-like strings corrupt state? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_0b33506f-010e-458c-9452-8f3f93d4bea4?mode=deep",
    "timestamp": "2026-02-19 02:39:11.137858",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Full Name Collision] Line 138 checks State.NFTTypeShortNameMap[fullName] == null - what if fullName exactly matches an existing NFT type's string representation? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_59954b95-7181-4a87-9e33-2e2525521c4a?mode=deep",
    "timestamp": "2026-02-19 02:39:38.057837",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Null Input] No validation that input, input.ShortName, or input.FullName are not null before line 135 - can null inputs cause NullReferenceException? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_e1487335-521a-4b27-80f2-6b4ed6b9b13f?mode=deep",
    "timestamp": "2026-02-19 02:40:05.715364",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [State Atomicity] Lines 139-140 set two-way mappings separately - if transaction fails after line 139, can this leave State.NFTTypeFullNameMap inconsistent with State.NFTTypeShortNameMap? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_bf3a75cb-ed74-4276-87f4-e9fc9e12224a?mode=deep",
    "timestamp": "2026-02-19 02:40:34.732512",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [NFTTypes.Value Sync] Lines 141-143 modify State.NFTTypes.Value separately from individual mappings - can failures leave State.NFTTypes desynchronized from mapping states? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_0f2a18db-0a29-4d40-a9b4-64caded136fd?mode=deep",
    "timestamp": "2026-02-19 02:41:04.988280",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Dictionary Mutation] Line 142 uses nftTypes.Value.Add() on potentially concurrent state - can race conditions corrupt the NFTTypes dictionary? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_4d69dba8-7792-4969-976b-1ba4100288a6?mode=deep",
    "timestamp": "2026-02-19 02:41:34.016951",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Initialization Dependency] InitialNFTTypeNameMap() at line 134 may initialize default types - can this interfere with custom type additions or cause duplicate entries? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_ca5403cf-9d75-474f-ba61-ac710c67f8f7?mode=deep",
    "timestamp": "2026-02-19 02:42:01.302840",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [NFT Type Spam] No limit on how many NFT types can be added - can Parliament governance spam AddNFTType to exhaust state storage or cause gas issues in InitialNFTTypeNameMap()? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_4485068d-6838-4778-86d6-f6e490471c0d?mode=deep",
    "timestamp": "2026-02-19 02:42:29.385050",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Symbol Space Exhaustion] Each NFT type claims 2-character prefix space - can malicious additions exhaust all possible 2-char combinations (26^2 = 676), preventing legitimate NFT types? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_5c7d5798-53a5-4cac-a3ed-9e560cf62153?mode=deep",
    "timestamp": "2026-02-19 02:43:01.398897",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Create() Impact] After AddNFTType, Create() can use new types - can retroactive type additions break existing protocols expecting specific type behavior? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_bc1f2695-1731-4850-ac35-841948cf5d6f?mode=deep",
    "timestamp": "2026-02-19 02:43:29.121400",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: RemoveNFTType()] [Authorization Bypass] AssertSenderIsParliamentDefaultAddress() at line 154 - same Parliament compromise risks as AddNFTType, can unauthorized removal DOS protocol creation? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_254b550f-dcf9-446b-a642-cc97d8cd68ce?mode=deep",
    "timestamp": "2026-02-19 02:43:57.208627",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: RemoveNFTType()] [Remove Default Types] Can RemoveNFTType delete built-in types initialized in InitialNFTTypeNameMap (lines 44-53 of Helpers), breaking existing NFT protocols? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_75837268-0ef7-4c26-9a52-9f298eeb715d?mode=deep",
    "timestamp": "2026-02-19 02:44:27.118966",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: RemoveNFTType()] [Short Name Validation] Line 156 checks input.Value.Length == 2, but doesn't validate that it's a valid short name - can arbitrary 2-char strings be removed even if never added? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_c709d244-e843-4c8b-86f3-b6a6abe39370?mode=deep",
    "timestamp": "2026-02-19 02:44:53.664224",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: RemoveNFTType()] [Existence Check] Line 157 asserts short name exists, but doesn't check if NFT protocols currently use this type - can removal break active protocols? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_c0b2b5c7-3235-4a76-bcf5-811a2853bf79?mode=deep",
    "timestamp": "2026-02-19 02:45:22.905428",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: RemoveNFTType()] [Orphaned Protocols] After RemoveNFTType, existing protocols with removed type remain in State.NftProtocolMap - can this prevent CrossChainCreate from working at line 90? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_5af80b96-24f5-4b86-9d7c-acd930b4456f?mode=deep",
    "timestamp": "2026-02-19 02:45:50.625394",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: RemoveNFTType()] [State Consistency] Lines 159-160 remove mappings but line 162 removes from State.NFTTypes.Value separately - can partial removal leave inconsistent state? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_1b2acdd4-05e8-4f09-974e-e8061bfcc460?mode=deep",
    "timestamp": "2026-02-19 02:46:20.799162",
    "report_generated": false
  }
]