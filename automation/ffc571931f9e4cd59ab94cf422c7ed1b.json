[
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetNextElectCountDown()] [Term 1 Special Case] Lines 419-425 handle term 1 differently. Can attacker manipulate BlockchainStartTimestamp in term 1 to extend or shorten first election period? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_cb23a1de-b948-418f-9853-ec528150f0da?mode=deep",
    "timestamp": "2026-02-19 15:26:47.471916",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousTermInformation()] [LastRoundNumber Calculation] Line 442 calculates lastRoundNumber using Add(1).Sub(1). Can integer overflow in Add cause incorrect round lookup? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_7124bd47-96d0-4ae9-96ae-6a28651d3f5d?mode=deep",
    "timestamp": "2026-02-19 15:27:09.620866",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousTermInformation()] [Round Validation] Line 444 checks if round is null or RoundId==0. Can attacker setting RoundId to 0 bypass validation and return empty Round instead of failing? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_ea16f24b-2d14-480e-a019-778515d97980?mode=deep",
    "timestamp": "2026-02-19 15:27:31.957553",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousTermInformation()] [Selective Field Copy] Lines 449-454 only copy Pubkey and ProducedBlocks. Does omitting other fields like MissedTimeSlots hide punishment information and enable evil miner to rejoin? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_bf506aef-6859-44b9-9940-7ff44f61c002?mode=deep",
    "timestamp": "2026-02-19 15:27:54.947810",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousTermInformation()] [TermNumber Override] Line 447 sets result.TermNumber to input.Value. Can attacker requesting future term number cause confusion in term-dependent logic? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_c91d64c9-ba43-4242-b9e4-99b1729fb1bd?mode=deep",
    "timestamp": "2026-02-19 15:28:18.731941",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetMinedBlocksOfPreviousTerm()] [Term Number Fetch] Line 73 calls TryToGetTermNumber. If this fails, function returns default value. Can missing term number cause incorrect reward calculations? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_0852b72f-1bb0-484f-b021-4390e1887a50?mode=deep",
    "timestamp": "2026-02-19 15:28:44.021025",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetMinedBlocksOfPreviousTerm()] [Sub(1) Underflow] Line 75 uses Sub(1) on FirstRoundNumberOfEachTerm. If termNumber is 1, can underflow cause lookup of round 0 or negative round? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_9a5a04f9-c097-4c53-be9d-31cca52b77be?mode=deep",
    "timestamp": "2026-02-19 15:29:09.598875",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetMinedBlocksOfPreviousTerm()] [Round Lookup Failure] Line 76 tries to get round info for targetRound. If this round doesn't exist, does returning empty Int64Value cause reward distribution to skip previous term? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_9091d14a-e3cc-4323-b8b7-deda9fd15513?mode=deep",
    "timestamp": "2026-02-19 15:29:37.495933",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetMinedBlocksOfPreviousTerm()] [GetMinedBlocks Trust] Line 77 calls GetMinedBlocks() on round. Can corrupted round data with inflated block counts cause excessive reward minting? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_a83dad33-7ac9-477a-9b83-aee327e39ddc?mode=deep",
    "timestamp": "2026-02-19 15:30:06.518131",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousMinerList()] [TermNumber Underflow] Line 85 checks termNumber > 1 before Sub(1). But can termNumber be 0, causing check to pass incorrectly? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_ea93c253-110a-437f-9905-13461488751e?mode=deep",
    "timestamp": "2026-02-19 15:30:35.352943",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousMinerList()] [Null Miner List] Line 86 uses ?? operator returning empty list if MinerListMap entry is null. Can this hide missing historical data that should cause error? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_76a27c6d-2ca5-4d4a-84ca-08dc8ce190b6?mode=deep",
    "timestamp": "2026-02-19 15:31:05.981512",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousMinerList()] [Genesis Term Access] Line 88 returns empty list for term 1 or if fetch fails. Can code depending on this list crash or make incorrect authorization decisions? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_d23f0d5f-6558-4561-a816-53c89e6c6d7f?mode=deep",
    "timestamp": "2026-02-19 15:31:37.491592",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerList()] [Round Fetch Failure] Line 33 uses TryToGetCurrentRoundInformation. If this fails, returns empty MinerList. Can empty list cause consensus to freeze? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_805275d1-4fcd-4b6a-861c-3e584b1a4005?mode=deep",
    "timestamp": "2026-02-19 15:32:05.796223",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerList()] [ByteString Conversion] Line 38 converts hex string keys to ByteString. Can malformed hex in RealTimeMinersInformation.Keys cause conversion exceptions? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_37db7728-cdb2-423a-912d-624c43403c9b?mode=deep",
    "timestamp": "2026-02-19 15:32:36.420526",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerList()] [Select Chain] Line 38 uses Select with FromHexString. If any key conversion fails, does Select chain break or skip entries, reducing miner count? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_8586b997-f809-495a-acff-ac867357873a?mode=deep",
    "timestamp": "2026-02-19 15:33:08.553141",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerPubkeyList()] [ToHex Conversion] Line 48 converts Pubkeys to hex strings. Can non-standard ByteString formats cause ToHex to fail or produce inconsistent results? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_56587ba2-909a-43ad-96b0-434ebf378fe0?mode=deep",
    "timestamp": "2026-02-19 15:33:41.835200",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerPubkeyList()] [Double Conversion] Function converts ByteString->Hex->ByteString->Hex in chain with GetCurrentMinerList. Can double conversion introduce inconsistencies? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_b50807c9-8c4f-4f88-8176-cb045bee6232?mode=deep",
    "timestamp": "2026-02-19 15:34:12.676050",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerListWithRoundNumber()] [Atomicity] Lines 56-57 fetch MinerList and RoundNumber separately. Can state change between these calls cause miner list and round number to be from different rounds? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_14da7a5a-85c2-42be-b9ef-ae61345564b7?mode=deep",
    "timestamp": "2026-02-19 15:34:45.073967",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerListWithRoundNumber()] [Empty Input Redundancy] Line 56 passes new Empty() instead of using input parameter. Is this intentional, or does it indicate misunderstanding of function contract? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_a7e20642-5aa6-4441-98c4-46235f076b72?mode=deep",
    "timestamp": "2026-02-19 15:35:17.243180",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetRoundInformation()] [Arbitrary Round Access] Line 28 allows querying any round number via input.Value. Can querying very high round numbers cause resource exhaustion or return future round data?\n\n### Citations\n\n**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L1-474)\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing AElf.Contracts.Election;\nusing AElf.CSharp.Core;\nusing AElf.CSharp.Core.Extension;\nusing AElf.Sdk.CSharp;\nusing AElf.Types;\nusing Google.Protobuf.WellKnownTypes;\n\nnamespace AElf.Contracts.Consensus.AEDPoS;\n\n// ReSharper disable once InconsistentNaming\npublic partial class AEDPoSContract\n{\n    public override Int64Value GetCurrentRoundNumber(Empty input)\n    {\n        return new() { Value = State.CurrentRoundNumber.Value };\n    }\n\n    public override Round GetCurrentRoundInformation(Empty input)\n    {\n        return TryToGetCurrentRoundInformation(out var currentRound) ? currentRound : new Round();\n    }\n\n    public override Round GetRoundInformation(Int64Value input)\n    {\n        return TryToGetRoundInformation(input.Value, out var round) ? round : new Round();\n    }\n\n    public override MinerList GetCurrentMinerList(Empty input)\n    {\n        return TryToGetCurrentRoundInformation(out var round)\n            ? new MinerList\n            {\n                Pubkeys =\n                {\n                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))\n                }\n            }\n            : new MinerList();\n    }\n\n    public override PubkeyList GetCurrentMinerPubkeyList(Empty input)\n    {\n        return new()\n        {\n            Pubkeys = { GetCurrentMinerList(input).Pubkeys.Select(p => p.ToHex()) }\n        };\n    }\n\n    public override MinerListWithRoundNumber GetCurrentMinerListWithRoundNumber(Empty input)\n    {\n        return new()\n        {\n            MinerList = GetCurrentMinerList(new Empty()),\n            RoundNumber = State.CurrentRoundNumber.Value\n        };\n    }\n\n    public override Round GetPreviousRoundInformation(Empty input)\n    {\n        return TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round();\n    }\n\n    public override MinerList GetMinerList(GetMinerListInput input)\n    {\n        return State.MinerListMap[input.TermNumber] ?? new MinerList();\n    }\n\n    public override Int64Value GetMinedBlocksOfPreviousTerm(Empty input)\n    {\n        if (TryToGetTermNumber(out var termNumber))\n        {\n            var targetRound = State.FirstRoundNumberOfEachTerm[termNumber].Sub(1);\n            if (TryToGetRoundInformation(targetRound, out var round))\n                return new Int64Value { Value = round.GetMinedBlocks() };\n        }\n\n        return new Int64Value();\n    }\n\n    public override MinerList GetPreviousMinerList(Empty input)\n    {\n        if (TryToGetTermNumber(out var termNumber) && termNumber > 1)\n            return State.MinerListMap[termNumber.Sub(1)] ?? new MinerList();\n\n        return new MinerList();\n    }\n\n    public override StringValue GetNextMinerPubkey(Empty input)\n    {\n        if (TryToGetCurrentRoundInformation(out var round))\n            return new StringValue\n            {\n                Value = round.RealTimeMinersInformation.Values\n                            .FirstOrDefault(m => m.ExpectedMiningTime > Context.CurrentBlockTime)?.Pubkey ??\n                        round.RealTimeMinersInformation.Values.First(m => m.IsExtraBlockProducer).Pubkey\n            };\n\n        return new StringValue();\n    }\n\n    /// <summary>\n    ///     Current implementation can be incorrect if all nodes recovering from\n    ///     a strike more than the time of one round, because it's impossible to\n    ///     infer a time slot in this situation.\n    /// </summary>\n    /// <param name=",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_3ca476a0-cf61-4bc7-b599-8b5697fe0c3d?mode=deep",
    "timestamp": "2026-02-19 15:35:48.832147",
    "report_generated": false
  }
]