[
  {
    "question": "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [State] [LockIds Mapping] LockIds state at line 166 maps Manager->User->LockId. If manager address is reused across schemes, can lockIds collide causing unlock failures? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_967165d0-39f7-4e03-aa7f-d1628d5ec0ef?mode=deep",
    "timestamp": "2026-02-19 09:24:14.653010",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [State] [LockTimestamp Mapping] LockTimestamp maps LockId to Timestamp (line 167). If same LockId is reused, can timestamp be overwritten, allowing premature withdrawals? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_ed58b674-6a80-4dec-b18d-b9977e16d419?mode=deep",
    "timestamp": "2026-02-19 09:24:36.725237",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [State] [Scheme Storage] TokenHolderProfitSchemes maps Address to Scheme. Can one address manage multiple schemes, or is there a one-to-one relationship? What prevents scheme key collisions? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_e5372c31-7507-4e31-8b60-15c5e1ef1578?mode=deep",
    "timestamp": "2026-02-19 09:24:59.114879",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [State] [Orphaned Locks] If user registers, scheme is deleted, and user tries to withdraw, can tokens be permanently locked due to scheme not found error at line 281? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_4f536dbd-bab8-4e8a-b845-b4945cb8d51e?mode=deep",
    "timestamp": "2026-02-19 09:25:21.932479",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [State] [Period Persistence] Scheme.Period is stored in state and incremented locally. If contract is upgraded, can Period value be reset causing profit distribution errors? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_7692facd-4bae-4ec5-9416-3aa387a1067f?mode=deep",
    "timestamp": "2026-02-19 09:25:46.152442",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Cross-Contract] [ProfitContract Trust] All functions trust ProfitContract address from line 16-18. If ProfitContract is malicious or upgraded, can it drain all locked tokens via approval at line 115-120? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_0ddaaf49-c426-4f65-a116-774e2d5b87ca?mode=deep",
    "timestamp": "2026-02-19 09:26:10.865496",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Cross-Contract] [TokenContract Trust] TokenContract address is fetched at lines 103-105, 153-155, 214-216. If TokenContract is compromised, can it manipulate Lock/Unlock operations? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_91e30778-188f-46e7-9d3c-fc3d6d9cf643?mode=deep",
    "timestamp": "2026-02-19 09:26:36.546153",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Cross-Contract] [Contract Upgrade] If ProfitContract or TokenContract are upgraded mid-operation, can ongoing transactions fail leaving state inconsistent? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_caf86ec5-4ef8-4c69-8607-3979a7050d9a?mode=deep",
    "timestamp": "2026-02-19 09:27:02.531504",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Cross-Contract] [Return Value Checks] Multiple Send() calls don't check return values (lines 20, 50, 58, 80, 87, 107, 115, 122, 143, 159, 168, 203, 230, 239, 251). Can silently failing external calls cause state corruption? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_1a9aac63-3180-481d-806e-4df22bc706f0?mode=deep",
    "timestamp": "2026-02-19 09:27:31.061404",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Cross-Contract] [Call() vs Send()] Contract uses both Call() and Send() methods. Are failure modes different? Can Call() failures be handled differently than Send() causing inconsistencies? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_dee15c79-ecef-4cd9-8bf6-e61fef7c90dc?mode=deep",
    "timestamp": "2026-02-19 09:28:00.135783",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Cross-Contract] [Circular Dependency] TokenHolderContract depends on ProfitContract which may depend on TokenContract. Can circular calls cause reentrancy or stack overflow? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_63a80b5f-c625-4025-9663-24462a1493f1?mode=deep",
    "timestamp": "2026-02-19 09:28:29.814610",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Input Validation] [Null Address Checks] Multiple functions accept Address inputs but don't validate non-null (CreateScheme input.Symbol, AddBeneficiary input.Beneficiary, etc). Can null inputs cause crashes? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_1e0c6c2e-56b5-48ee-ab11-dbeec74d17cc?mode=deep",
    "timestamp": "2026-02-19 09:28:58.509782",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Input Validation] [Negative Amounts] Functions accept int64 amounts (input.Amount, input.Shares) but may not validate positive values. Can negative amounts bypass checks or cause underflow? (High\n\n### Citations\n\n**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L1-300)\n```csharp\nï»¿using System.Linq;\nusing AElf.Contracts.MultiToken;\nusing AElf.Contracts.Profit;\nusing AElf.CSharp.Core;\nusing AElf.CSharp.Core.Extension;\nusing AElf.Sdk.CSharp;\nusing AElf.Types;\nusing Google.Protobuf.WellKnownTypes;\n\nnamespace AElf.Contracts.TokenHolder;\n\npublic partial class TokenHolderContract : TokenHolderContractImplContainer.TokenHolderContractImplBase\n{\n    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)\n    {\n        if (State.ProfitContract.Value == null)\n            State.ProfitContract.Value =\n                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);\n\n        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput\n        {\n            Manager = Context.Sender,\n            IsReleaseAllBalanceEveryTimeByDefault = true,\n            CanRemoveBeneficiaryDirectly = true\n        });\n\n        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme\n        {\n            Symbol = input.Symbol,\n            MinimumLockMinutes = input.MinimumLockMinutes,\n            AutoDistributeThreshold = { input.AutoDistributeThreshold }\n        };\n\n        return new Empty();\n    }\n\n    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)\n    {\n        var scheme = GetValidScheme(Context.Sender);\n        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput\n        {\n            SchemeId = scheme.SchemeId,\n            Beneficiary = input.Beneficiary\n        });\n        var shares = input.Shares;\n        if (detail.Details.Any())\n        {\n            // Only keep one detail.\n\n            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput\n            {\n                SchemeId = scheme.SchemeId,\n                Beneficiary = input.Beneficiary\n            });\n            shares.Add(detail.Details.Single().Shares);\n        }\n\n        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput\n        {\n            SchemeId = scheme.SchemeId,\n            BeneficiaryShare = new BeneficiaryShare\n            {\n                Beneficiary = input.Beneficiary,\n                Shares = shares\n            }\n        });\n        return new Empty();\n    }\n\n    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)\n    {\n        var scheme = GetValidScheme(Context.Sender);\n\n        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput\n        {\n            Beneficiary = input.Beneficiary,\n            SchemeId = scheme.SchemeId\n        }).Details.Single();\n        var lockedAmount = detail.Shares;\n        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput\n        {\n            SchemeId = scheme.SchemeId,\n            Beneficiary = input.Beneficiary\n        });\n        if (lockedAmount > input.Amount &&\n            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.\n            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput\n            {\n                SchemeId = scheme.SchemeId,\n                BeneficiaryShare = new BeneficiaryShare\n                {\n                    Beneficiary = input.Beneficiary,\n                    Shares = lockedAmount.Sub(input.Amount)\n                }\n            });\n\n        return new Empty();\n    }\n\n    public override Empty ContributeProfits(ContributeProfitsInput input)\n    {\n        var scheme = GetValidScheme(input.SchemeManager);\n        if (State.TokenContract.Value == null)\n            State.TokenContract.Value =\n                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);\n\n        State.TokenContract.TransferFrom.Send(new TransferFromInput\n        {\n            From = Context.Sender,\n            To = Context.Self,\n            Symbol = input.Symbol,\n            Amount = input.Amount\n        });\n\n        State.TokenContract.Approve.Send(new ApproveInput\n        {\n            Spender = State.ProfitContract.Value,\n            Symbol = input.Symbol,\n            Amount = input.Amount\n        });\n\n        State.ProfitContract.ContributeProfits.Send(new Profit.ContributeProfitsInput\n        {\n            SchemeId = scheme.SchemeId,\n            Symbol = input.Symbol,\n            Amount = input.Amount\n        });\n        return new Empty();\n    }\n\n    public override Empty DistributeProfits(DistributeProfitsInput input)\n    {\n        var scheme = GetValidScheme(input.SchemeManager, true);\n        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||\n               Context.Sender == input.SchemeManager,",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_d77613d8-40fe-4430-b5de-c347a01b43ca?mode=deep",
    "timestamp": "2026-02-19 09:29:27.691399",
    "report_generated": false
  }
]