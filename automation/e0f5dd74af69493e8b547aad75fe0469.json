[
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidSymbol()] [Regex Bypass] Can an attacker create tokens with symbols like 'ABC-0' which passes the regex '^[a-zA-Z0-9]+(-[0-9]+)?$' but may conflict with NFT symbol format, leading to symbol collision and token confusion? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_c71a9b30-c8fa-4653-93dd-09a2559daa34?mode=deep",
    "timestamp": "2026-02-19 13:22:19.110451",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidSymbol()] [Input Validation] Does the regex '^[a-zA-Z0-9]+(-[0-9]+)?$' allow symbols with leading zeros like 'TOKEN-0001' which could cause duplicate symbol issues when normalized, enabling double-registration attacks? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_491e2d5e-d139-46bd-82e0-b5f6a4935ae8?mode=deep",
    "timestamp": "2026-02-19 13:22:41.233402",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidSymbol()] [Length Validation Missing] The function only validates format but not length - can an attacker create extremely long symbols (1000+ chars) that pass regex but cause DoS in storage or processing operations? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_07c3a727-9225-4a6f-bfe4-fead04b2b615?mode=deep",
    "timestamp": "2026-02-19 13:23:03.510109",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidItemId()] [Regex Weakness] The regex '^[0-9]+$' allows unlimited leading zeros - can '00000001' and '1' be treated as different NFT IDs causing duplicate NFT creation for same logical item? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_291439c9-c64e-4fb1-bed4-68cb9c5ad13c?mode=deep",
    "timestamp": "2026-02-19 13:23:26.236879",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidItemId()] [Integer Overflow] Does IsValidItemId validate the numeric range? Can an attacker use '99999999999999999999999999999' exceeding long.MaxValue, causing parsing failures or integer overflow in downstream operations? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_06d516aa-13d4-4b96-b748-4353f96e9773?mode=deep",
    "timestamp": "2026-02-19 13:23:50.255531",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidCreateSymbol()] [Symbol Collision] The regex '^[a-zA-Z0-9]+$' allows symbols without hyphens - can this create collision between base token 'ABC0' and NFT collection prefix 'ABC' when combined with '-0' suffix? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_86b54d9c-a07f-4d59-8c99-ee2d4bf4dd6f?mode=deep",
    "timestamp": "2026-02-19 13:24:14.818395",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidCreateSymbol()] [Case Sensitivity] Does the validation allow both 'TOKEN' and 'token' as different symbols? Can attacker create phishing tokens exploiting case-insensitive user interfaces while being case-sensitive in contract? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_f667968a-24c4-4bdb-8420-ddf4297680c6?mode=deep",
    "timestamp": "2026-02-19 13:24:39.888108",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertValidToken()] [TOCTOU Race] Between line 35 AssertValidSymbolAndAmount and line 36 GetTokenInfo, can token info be deleted by parallel transaction, causing assertion to pass but subsequent operations to fail with inconsistent state? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_475dbac2-f0f4-4fba-87eb-8362f6107a30?mode=deep",
    "timestamp": "2026-02-19 13:25:09.509655",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertValidToken()] [Null Symbol Check] Line 37 checks '!string.IsNullOrEmpty(tokenInfo.Symbol)' but tokenInfo itself could be non-null with empty Symbol field - can this bypass cause operations on invalid/deleted tokens? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_8a51a103-3151-42e3-be99-6414c9bb29ac?mode=deep",
    "timestamp": "2026-02-19 13:25:38.511990",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertApproveToken()] [NFT Separator Injection] Line 57 splits by TokenContractConstants.NFTSymbolSeparator - can attacker inject multiple separators like 'ABC--123' to bypass validation or cause array index out of bounds? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_a015bd26-5c02-473c-bfc6-d2b8f6b432e6?mode=deep",
    "timestamp": "2026-02-19 13:26:09.674306",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertApproveToken()] [All Symbol Bypass] Lines 60, 72 check for 'allSymbolIdentifier' - can attacker exploit this wildcard to approve/manipulate all tokens at once if allSymbolIdentifier is predictable or leaked? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_0289f00e-d0b5-4f18-9f3c-d7759fc4aa88?mode=deep",
    "timestamp": "2026-02-19 13:26:42.005940",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertApproveToken()] [Symbol Validation Inconsistency] Line 60 uses IsValidCreateSymbol for prefix validation but line 71 uses IsValidItemId - can mismatched validation allow malformed symbols through one path but not another? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_e7316074-b95c-46d8-9e0f-0649b38fba67?mode=deep",
    "timestamp": "2026-02-19 13:27:14.603019",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertApproveToken()] [Collection Symbol Construction] Line 72 constructs nftSymbol conditionally - if itemId equals allSymbolIdentifier, it uses GetCollectionSymbol, otherwise uses original symbol. Can this logic be exploited to approve non-existent collections? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_ba338529-9a30-44c5-9ad0-c21338363b2d?mode=deep",
    "timestamp": "2026-02-19 13:27:47.257706",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ValidTokenExists()] [State Access Without Lock] Lines 49-51 read State.TokenInfos without synchronization - can concurrent token deletion cause race condition where exists check passes but token is deleted before usage? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_ddb79cf2-62f6-4a62-a56e-e4947a5abac3?mode=deep",
    "timestamp": "2026-02-19 13:28:19.532233",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetCollectionSymbol()] [Hard-coded Suffix] Line 78 appends '-0' suffix - can attacker create token 'ABC-0' directly that collides with collection symbol for 'ABC', causing authorization or balance confusion? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_f2de4094-5964-47ab-b3ec-6476f46b8c70?mode=deep",
    "timestamp": "2026-02-19 13:28:50.170118",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyBalance()] [Integer Overflow] Line 123 uses before.Add(addAmount) - if before + addAmount exceeds long.MaxValue, does Add() method throw or wrap around, potentially allowing balance inflation? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_65d6bb54-6b3b-41de-9401-9e55213244ad?mode=deep",
    "timestamp": "2026-02-19 13:29:20.433433",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyBalance()] [Insufficient Balance Check] Lines 119-121 only check if 'before < -addAmount' when addAmount < 0, but what if before + addAmount causes overflow? Can attacker exploit this to bypass balance checks? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_93949875-f68f-41b1-9412-51c5813bc657?mode=deep",
    "timestamp": "2026-02-19 13:29:51.442972",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyBalance()] [Negative Balance Possibility] If before.Add(addAmount) implementation doesn't prevent negative results in edge cases, can balance become negative breaking supply invariant? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_6c339b9c-055c-493e-8d55-90c1633ba03a?mode=deep",
    "timestamp": "2026-02-19 13:30:23.003262",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyBalance()] [Direct State Assignment] Line 124 directly assigns without emit event or additional validation - can this be exploited in reentrancy scenarios where balance is modified during callbacks? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_4b909dce-d72a-4789-91c6-e724c4187bc6?mode=deep",
    "timestamp": "2026-02-19 13:30:53.553853",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyBalance()] [Error Message Information Leak] Lines 120-121 expose exact balance 'Current balance: {before}' - can attackers use this to probe account balances through transaction failures? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_f83955c0-ac6c-436f-a6fc-d68bf27655f2?mode=deep",
    "timestamp": "2026-02-19 13:31:20.515714",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetBalance()] [Symbol Transformation] Line 169 calls GetActualTokenSymbol which may resolve aliases - can attacker exploit alias resolution to query balances of aliased tokens without authorization? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_c3cb1671-5660-48ff-a2e6-48bd3da0cee6?mode=deep",
    "timestamp": "2026-02-19 13:31:50.841999",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetBalance()] [Address Validation Timing] Line 168 validates address but line 169 gets symbol - can invalid symbol bypass address validation by throwing different exception? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_8a256585-0450-4586-a332-76127f072763?mode=deep",
    "timestamp": "2026-02-19 13:32:19.159167",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: DoTransfer()] [Blacklist Check Before Balance] Line 101 checks blacklist but balance check is in ModifyBalance at line 104 - can attacker add addresses to blacklist mid-transfer to cause fund locking? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_e0a30c42-6e62-413c-9f4a-ec466367fa50?mode=deep",
    "timestamp": "2026-02-19 13:32:45.487583",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: DoTransfer()] [Self-Transfer Check] Line 102 prevents 'from == to' but doesn't prevent sending to contract addresses that immediately forward back - can circular transfers cause reentrancy or state corruption? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_2a7934aa-308b-44b1-bb65-2fd1856e1b59?mode=deep",
    "timestamp": "2026-02-19 13:33:15.303569",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: DoTransfer()] [Balance Modification Order] Lines 104-105 modify sender balance first, then receiver - if line 105 fails after 104 succeeds, can this cause balance inconsistency without rollback? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_7f59c2fb-cf3f-4ea9-9d7b-7b39fbfe92b4?mode=deep",
    "timestamp": "2026-02-19 13:33:45.989760",
    "report_generated": false
  }
]