[
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetNextElectCountDown()] [Term 1 Special Case] Lines 419-425 handle term 1 differently. Can attacker manipulate BlockchainStartTimestamp in term 1 to extend or shorten first election period? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_5cfd30ed-7e2b-4395-aee4-c4eaafe4933c?mode=deep",
    "timestamp": "2026-02-19 06:56:17.291632",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousTermInformation()] [LastRoundNumber Calculation] Line 442 calculates lastRoundNumber using Add(1).Sub(1). Can integer overflow in Add cause incorrect round lookup? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_4c7bf73b-41c1-49fe-901b-f988308e955d?mode=deep",
    "timestamp": "2026-02-19 06:56:39.477450",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousTermInformation()] [Round Validation] Line 444 checks if round is null or RoundId==0. Can attacker setting RoundId to 0 bypass validation and return empty Round instead of failing? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_4c667b0c-8adb-41c5-9089-58970c437a95?mode=deep",
    "timestamp": "2026-02-19 06:57:01.654291",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousTermInformation()] [Selective Field Copy] Lines 449-454 only copy Pubkey and ProducedBlocks. Does omitting other fields like MissedTimeSlots hide punishment information and enable evil miner to rejoin? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_f75590b4-d1c7-4897-a63b-ba6c5894e044?mode=deep",
    "timestamp": "2026-02-19 06:57:24.412090",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousTermInformation()] [TermNumber Override] Line 447 sets result.TermNumber to input.Value. Can attacker requesting future term number cause confusion in term-dependent logic? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_b60da21d-2053-4daa-a3d0-1fea134c56ca?mode=deep",
    "timestamp": "2026-02-19 06:57:48.564417",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetMinedBlocksOfPreviousTerm()] [Term Number Fetch] Line 73 calls TryToGetTermNumber. If this fails, function returns default value. Can missing term number cause incorrect reward calculations? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_190f38dd-0a62-4e05-a1dc-764a355552fb?mode=deep",
    "timestamp": "2026-02-19 06:58:14.283607",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetMinedBlocksOfPreviousTerm()] [Sub(1) Underflow] Line 75 uses Sub(1) on FirstRoundNumberOfEachTerm. If termNumber is 1, can underflow cause lookup of round 0 or negative round? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_f749388d-fa1b-4568-b319-48052ef5ea17?mode=deep",
    "timestamp": "2026-02-19 06:58:39.839680",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetMinedBlocksOfPreviousTerm()] [Round Lookup Failure] Line 76 tries to get round info for targetRound. If this round doesn't exist, does returning empty Int64Value cause reward distribution to skip previous term? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_a27e1a66-31ed-4ca9-a6b4-ebc1e38d1111?mode=deep",
    "timestamp": "2026-02-19 06:59:06.120404",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetMinedBlocksOfPreviousTerm()] [GetMinedBlocks Trust] Line 77 calls GetMinedBlocks() on round. Can corrupted round data with inflated block counts cause excessive reward minting? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_1cb34c93-5e32-42a4-ba34-7659707240a9?mode=deep",
    "timestamp": "2026-02-19 06:59:33.786273",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousMinerList()] [TermNumber Underflow] Line 85 checks termNumber > 1 before Sub(1). But can termNumber be 0, causing check to pass incorrectly? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_75fe23a2-21b7-4e74-aaf9-2829ddc24fac?mode=deep",
    "timestamp": "2026-02-19 07:00:02.548767",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousMinerList()] [Null Miner List] Line 86 uses ?? operator returning empty list if MinerListMap entry is null. Can this hide missing historical data that should cause error? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_c7952e3b-8508-4359-b615-bb51cf81d3ab?mode=deep",
    "timestamp": "2026-02-19 07:00:32.688104",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousMinerList()] [Genesis Term Access] Line 88 returns empty list for term 1 or if fetch fails. Can code depending on this list crash or make incorrect authorization decisions? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_cd8ad654-9880-4a53-9e05-5c46e095892d?mode=deep",
    "timestamp": "2026-02-19 07:01:02.632459",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerList()] [Round Fetch Failure] Line 33 uses TryToGetCurrentRoundInformation. If this fails, returns empty MinerList. Can empty list cause consensus to freeze? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_58787a26-0769-4bea-aa12-6e75ad853138?mode=deep",
    "timestamp": "2026-02-19 07:01:33.688243",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerList()] [ByteString Conversion] Line 38 converts hex string keys to ByteString. Can malformed hex in RealTimeMinersInformation.Keys cause conversion exceptions? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_374ee8ae-487a-44ce-87c2-8225c7c203f9?mode=deep",
    "timestamp": "2026-02-19 07:02:04.257120",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerList()] [Select Chain] Line 38 uses Select with FromHexString. If any key conversion fails, does Select chain break or skip entries, reducing miner count? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_48f3ea1b-bb1f-48e3-927d-779c7d18a865?mode=deep",
    "timestamp": "2026-02-19 07:02:36.466064",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerPubkeyList()] [ToHex Conversion] Line 48 converts Pubkeys to hex strings. Can non-standard ByteString formats cause ToHex to fail or produce inconsistent results? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_28ac51fd-2bf2-44b6-b8dd-b0fa52b21c68?mode=deep",
    "timestamp": "2026-02-19 07:03:07.937773",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerPubkeyList()] [Double Conversion] Function converts ByteString->Hex->ByteString->Hex in chain with GetCurrentMinerList. Can double conversion introduce inconsistencies? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_fed0ef43-0874-48e0-a25a-a7a62d30eef4?mode=deep",
    "timestamp": "2026-02-19 07:03:39.845678",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerListWithRoundNumber()] [Atomicity] Lines 56-57 fetch MinerList and RoundNumber separately. Can state change between these calls cause miner list and round number to be from different rounds? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_dfe46212-3d47-4ee9-99ae-ee6e8f100060?mode=deep",
    "timestamp": "2026-02-19 07:04:08.264416",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerListWithRoundNumber()] [Empty Input Redundancy] Line 56 passes new Empty() instead of using input parameter. Is this intentional, or does it indicate misunderstanding of function contract? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_eae072d9-074e-494b-affa-c8575a61737b?mode=deep",
    "timestamp": "2026-02-19 07:04:38.999090",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetRoundInformation()] [Arbitrary Round Access] Line 28 allows querying any round number via input.Value. Can querying very high round numbers cause resource exhaustion or return future round data?\n\n### Citations\n\n**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L1-474)\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing AElf.Contracts.Election;\nusing AElf.CSharp.Core;\nusing AElf.CSharp.Core.Extension;\nusing AElf.Sdk.CSharp;\nusing AElf.Types;\nusing Google.Protobuf.WellKnownTypes;\n\nnamespace AElf.Contracts.Consensus.AEDPoS;\n\n// ReSharper disable once InconsistentNaming\npublic partial class AEDPoSContract\n{\n    public override Int64Value GetCurrentRoundNumber(Empty input)\n    {\n        return new() { Value = State.CurrentRoundNumber.Value };\n    }\n\n    public override Round GetCurrentRoundInformation(Empty input)\n    {\n        return TryToGetCurrentRoundInformation(out var currentRound) ? currentRound : new Round();\n    }\n\n    public override Round GetRoundInformation(Int64Value input)\n    {\n        return TryToGetRoundInformation(input.Value, out var round) ? round : new Round();\n    }\n\n    public override MinerList GetCurrentMinerList(Empty input)\n    {\n        return TryToGetCurrentRoundInformation(out var round)\n            ? new MinerList\n            {\n                Pubkeys =\n                {\n                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))\n                }\n            }\n            : new MinerList();\n    }\n\n    public override PubkeyList GetCurrentMinerPubkeyList(Empty input)\n    {\n        return new()\n        {\n            Pubkeys = { GetCurrentMinerList(input).Pubkeys.Select(p => p.ToHex()) }\n        };\n    }\n\n    public override MinerListWithRoundNumber GetCurrentMinerListWithRoundNumber(Empty input)\n    {\n        return new()\n        {\n            MinerList = GetCurrentMinerList(new Empty()),\n            RoundNumber = State.CurrentRoundNumber.Value\n        };\n    }\n\n    public override Round GetPreviousRoundInformation(Empty input)\n    {\n        return TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round();\n    }\n\n    public override MinerList GetMinerList(GetMinerListInput input)\n    {\n        return State.MinerListMap[input.TermNumber] ?? new MinerList();\n    }\n\n    public override Int64Value GetMinedBlocksOfPreviousTerm(Empty input)\n    {\n        if (TryToGetTermNumber(out var termNumber))\n        {\n            var targetRound = State.FirstRoundNumberOfEachTerm[termNumber].Sub(1);\n            if (TryToGetRoundInformation(targetRound, out var round))\n                return new Int64Value { Value = round.GetMinedBlocks() };\n        }\n\n        return new Int64Value();\n    }\n\n    public override MinerList GetPreviousMinerList(Empty input)\n    {\n        if (TryToGetTermNumber(out var termNumber) && termNumber > 1)\n            return State.MinerListMap[termNumber.Sub(1)] ?? new MinerList();\n\n        return new MinerList();\n    }\n\n    public override StringValue GetNextMinerPubkey(Empty input)\n    {\n        if (TryToGetCurrentRoundInformation(out var round))\n            return new StringValue\n            {\n                Value = round.RealTimeMinersInformation.Values\n                            .FirstOrDefault(m => m.ExpectedMiningTime > Context.CurrentBlockTime)?.Pubkey ??\n                        round.RealTimeMinersInformation.Values.First(m => m.IsExtraBlockProducer).Pubkey\n            };\n\n        return new StringValue();\n    }\n\n    /// <summary>\n    ///     Current implementation can be incorrect if all nodes recovering from\n    ///     a strike more than the time of one round, because it's impossible to\n    ///     infer a time slot in this situation.\n    /// </summary>\n    /// <param name=",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_313417ce-ebdf-41bf-bf5c-f4a59e6e4b13?mode=deep",
    "timestamp": "2026-02-19 07:05:11.518759",
    "report_generated": false
  }
]