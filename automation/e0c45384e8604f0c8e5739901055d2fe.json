[
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Burn()] [Non-Burnable Protocol Bypass] At lines 87-88, can an attacker bypass the IsBurnable check by manipulating the NFTProtocolInfo state or calling Burn through a different path? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_0ed0a896-a9ad-4a4c-8390-a93322c89832?mode=deep",
    "timestamp": "2026-02-19 13:21:32.390145",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Burn()] [Balance Underflow Risk] At line 94, can burning more than available balance cause an underflow if the assertion at line 91 is bypassed or fails to catch edge cases? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_657d4484-a7b9-43ec-90dd-f65b25ba8a04?mode=deep",
    "timestamp": "2026-02-19 13:21:54.522686",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Burn()] [Protocol Supply Corruption] If nftProtocolInfo.Supply becomes negative due to multiple concurrent burns or arithmetic errors at line 95, can it break protocol-level supply constraints and accounting? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_7b7dd4f7-0c8d-426c-a74a-6130ce1dc8fb?mode=deep",
    "timestamp": "2026-02-19 13:22:16.850260",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Burn()] [Burned Token Resurrection] After IsBurned is set to true at line 99, can the token be reminted or transferred, violating the burned state invariant? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_db9159c4-e5b6-4c5c-96e1-81f2d5922843?mode=deep",
    "timestamp": "2026-02-19 13:22:40.160534",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [NFT Theft via Assemble] At lines 124-131, when assembling NFTs, the function transfers them to Context.Self - can an attacker exploit this to lock victim's NFTs permanently if disassembly fails or is blocked? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_0449ca30-1c7a-4e19-82f6-9f30823eb134?mode=deep",
    "timestamp": "2026-02-19 13:23:04.098890",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [FT Allowance Front-running] Between checking allowance at line 148-154 and executing TransferFrom at line 155-161, can an attacker front-run to reduce allowance, causing the transaction to fail after NFTs are already locked? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_9e21e6db-f2cf-4e44-bffc-e53f81f9ab96?mode=deep",
    "timestamp": "2026-02-19 13:23:28.632488",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [Metadata Injection] At lines 122 and 136, assembled NFT/FT data is stored in metadata with keys AssembledNftsKey and AssembledFtsKey - can an attacker inject malicious data that overwrites these reserved keys via input.Metadata? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_95365ba4-9632-4347-83e7-ddfdb17ca450?mode=deep",
    "timestamp": "2026-02-19 13:23:56.259806",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [Insufficient Balance Check Bypass] At line 128, the balance check only verifies NFT balance - can an attacker exploit timing or state inconsistencies to assemble NFTs they don't actually own? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_95198fa0-0d2d-4686-9689-854f06624947?mode=deep",
    "timestamp": "2026-02-19 13:24:22.497444",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [Hash Collision in Assembled NFTs] At line 126, Hash.LoadFromHex(pair.Key) converts string keys to hashes - can an attacker craft colliding hex strings to manipulate which NFTs get locked during assembly? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_85959b47-0b18-431e-8028-75a930045f07?mode=deep",
    "timestamp": "2026-02-19 13:24:54.167542",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [FT Balance Check Race Condition] At lines 142-147, balance is checked before TransferFrom - can the balance change between check and transfer, causing the transfer to fail after NFTs are already locked in the contract? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_39d30af0-8da8-4f72-b192-4498993baa13?mode=deep",
    "timestamp": "2026-02-19 13:25:27.452569",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [Double Assembly Exploit] Can an attacker call Assemble twice with the same NFTs by exploiting timing windows, locking the same NFTs into multiple assembled tokens? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_62b47471-f2d5-4d78-86d9-74889be1ec39?mode=deep",
    "timestamp": "2026-02-19 13:26:02.357637",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [Assembled Token Mint Permission] At line 175, PerformMint is called with isTokenIdMustBeUnique=true - can an attacker bypass minter checks if the assembled token minting path doesn't properly validate minter permissions? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_d20f1ed0-df36-48d3-8ae6-c977591b8aec?mode=deep",
    "timestamp": "2026-02-19 13:26:33.102815",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [State Corruption on Partial Failure] If TransferFrom at line 155 fails for some FTs after NFTs are already transferred at line 130, are the NFTs returned or permanently locked? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_6f94be35-5ed5-4a95-a6d0-320be4dfac05?mode=deep",
    "timestamp": "2026-02-19 13:27:07.480979",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [Metadata Key Validation Bypass] At line 116, AssertMetadataKeysAreCorrect is called - but can reserved keys for assembled NFTs/FTs be overwritten if validation is incomplete? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_d1ae6039-5682-4870-ae4a-6f18cfbbd4ad?mode=deep",
    "timestamp": "2026-02-19 13:27:39.734953",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Disassemble()] [Authorization Bypass] At lines 193-198, Burn is called without verifying that Context.Sender owns the assembled token - can any minter burn and disassemble someone else's token? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_656f7b1a-6e15-42b7-8e54-371629170edf?mode=deep",
    "timestamp": "2026-02-19 13:28:08.534572",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Disassemble()] [Receiver Manipulation] At line 200, receiver defaults to Context.Sender if input.Owner is null - can an attacker specify a different owner to redirect disassembled assets to arbitrary addresses? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_c7591e25-e416-4550-a007-7eacd9f6d350?mode=deep",
    "timestamp": "2026-02-19 13:28:36.546548",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Disassemble()] [State Cleanup Failure] If AssembledNftsMap or AssembledFtsMap removal at lines 209 and 224 fails, can the same token be disassembled multiple times, duplicating the underlying assets? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_c04cae68-72a9-4b5c-84c1-70924a058c4b?mode=deep",
    "timestamp": "2026-02-19 13:29:05.945594",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Disassemble()] [Null Reference Crash] At line 203, if AssembledNftsMap[tokenHash] returns null and Clone() is called, does this cause a null reference exception that bricks the disassembly process? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_57a124b1-2dff-4a9b-974e-9cb6fdbc229c?mode=deep",
    "timestamp": "2026-02-19 13:29:36.315984",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Disassemble()] [Transfer Failure Handling] At lines 207 and 217-222, if DoTransfer or State.TokenContract.Transfer.Send fails for some assets, is the assembled token still burned, causing permanent asset loss? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_5e0a2d52-6e3a-4061-a933-11b135b4412e?mode=deep",
    "timestamp": "2026-02-19 13:30:03.219726",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Disassemble()] [Burn Amount Hardcoded] At line 197, the burn amount is hardcoded to 1 - can an attacker assemble multiple copies and only burn 1 to disassemble, potentially duplicating underlying assets? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_979b4ae6-5691-432a-a301-842d89e3e898?mode=deep",
    "timestamp": "2026-02-19 13:30:33.626036",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Disassemble()] [Clone Mutation Risk] At lines 203 and 212, Clone() is called on assembled assets - can mutations to the cloned data affect the original state, causing inconsistencies? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_76368d78-46d4-45e3-8208-d1e61f6dc0f3?mode=deep",
    "timestamp": "2026-02-19 13:31:05.840841",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Disassemble()] [DOS via Empty Assembly] If an assembled token has empty AssembledNfts and AssembledFts, can repeated disassemble calls be used to spam events and waste gas? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_99b93b3e-5da1-4fb3-87b4-2de490363a7b?mode=deep",
    "timestamp": "2026-02-19 13:31:33.427880",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: ApproveProtocol()] [Protocol Existence Check Bypass] At line 240, if State.NftProtocolMap[input.Symbol] check can be bypassed or returns a non-null dummy value, can operators be added for non-existent protocols? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_6b8ca896-2d8a-46f9-ab43-27f47fccac9f?mode=deep",
    "timestamp": "2026-02-19 13:32:01.818922",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: ApproveProtocol()] [Operator List Pollution] At lines 244-245, operators are added without limit - can an attacker spam add operations to bloat the operator list, causing DOS or excessive gas costs for future operations? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_4497bd71-da3e-4926-b075-c14543a2a78a?mode=deep",
    "timestamp": "2026-02-19 13:32:36.397482",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: ApproveProtocol()] [Approval Revocation Race] At lines 247-248, operators are removed from the list - can concurrent approve/revoke calls cause race conditions that leave the operator list in an inconsistent state? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_1792088d-0b1f-4b58-8ec0-e0442934de71?mode=deep",
    "timestamp": "2026-02-19 13:33:10.850314",
    "report_generated": false
  }
]