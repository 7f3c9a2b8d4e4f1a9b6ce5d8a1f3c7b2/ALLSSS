[
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialTreasuryContract()] [Reentrancy] Can an attacker exploit the initialization flow by calling CreateScheme 7 times before State.Initialized is set to true, potentially creating duplicate profit schemes if called reentrantly? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_26557e74-b4e0-45cd-aff9-0f536b7f8a45?mode=deep",
    "timestamp": "2026-02-19 10:06:30.726444",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialTreasuryContract()] [State Manipulation] If State.Initialized check fails after partial scheme creation, can the contract end up with fewer than 7 schemes, breaking subsequent operations that assume exactly 7 schemes exist? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_d80ffec3-a019-4b67-9b5e-54b05b02cf78?mode=deep",
    "timestamp": "2026-02-19 10:06:53.542293",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialTreasuryContract()] [Configuration Error] The DelayDistributePeriodCount is set to 1 only for index 3 (Welfare), but can this delay cause synchronization issues where welfare distribution is perpetually one period behind, leading to stale reward calculations? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_795ec384-fef4-435d-85bd-61547f2d5a87?mode=deep",
    "timestamp": "2026-02-19 10:07:18.398673",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialTreasuryContract()] [Authorization] Since there's no explicit sender verification, can any account call InitialTreasuryContract before State.Initialized.Value is set to true, potentially front-running the legitimate initialization? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_0d5b81ac-a304-4fc0-a7de-5de138caec72?mode=deep",
    "timestamp": "2026-02-19 10:07:42.522406",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialTreasuryContract()] [Logic Error] The CanRemoveBeneficiaryDirectly flag is set for indices 2, 5, 6 (Subsidy, Flexible, Welcome), but what prevents an attacker from exploiting this to remove legitimate beneficiaries and redirect rewards? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_379fe660-1db8-41f0-befd-5ddbd203f1c6?mode=deep",
    "timestamp": "2026-02-19 10:08:07.981142",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialMiningRewardProfitItem()] [State Inconsistency] If GetManagingSchemeIds returns exactly 7 schemes but they're not in the expected order, will the wrong scheme IDs be assigned to TreasuryHash, RewardHash, etc., causing complete reward distribution failure? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_99658f99-4709-49a1-b5c3-c8f3459b9731?mode=deep",
    "timestamp": "2026-02-19 10:08:34.121166",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialMiningRewardProfitItem()] [Authorization Bypass] The function checks State.TreasuryHash.Value == null but doesn't verify the caller - can an attacker call this before legitimate initialization to set malicious scheme IDs? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_14c72a48-5beb-40fe-ab53-eb507c7a983a?mode=deep",
    "timestamp": "2026-02-19 10:08:59.997529",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialMiningRewardProfitItem()] [Integration Risk] If electionContractAddress is null, managers for SubsidyHash and WelfareHash aren't reset - can this lead to the Treasury contract retaining unauthorized control over these schemes indefinitely? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_a792bac1-534d-429e-b87a-da5a6589d318?mode=deep",
    "timestamp": "2026-02-19 10:09:31.013177",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialMiningRewardProfitItem()] [State Manipulation] BuildTreasury() is called which sets default weights - if an attacker can influence the timing of this call versus SetDividendPoolWeightSetting, can they lock in unfavorable default weights? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_d3a8ba83-3af0-4a29-a05a-701dc110952e?mode=deep",
    "timestamp": "2026-02-19 10:10:05.271581",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialMiningRewardProfitItem()] [Address Collision] The TreasuryVirtualAddress is computed from ProfitContract address and scheme hash - can an attacker predict this address and pre-fund it or set up malicious state before initialization? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_488ee741-8755-4436-95cc-33ba4ef29fdd?mode=deep",
    "timestamp": "2026-02-19 10:10:39.248802",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Authorization Bypass] Only AEDPoS contract can call Release, but if State.AEDPoSContract.Value is uninitialized or can be manipulated, can an attacker bypass this check and trigger unauthorized profit distributions? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_828bafae-d1f7-4ff4-8e28-2a11828260fe?mode=deep",
    "timestamp": "2026-02-19 10:11:09.263911",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Reentrancy] The function calls DistributeProfits, then retrieves previous term info, updates state, and distributes again - can an attacker exploit reentrancy during DistributeProfits to corrupt the state updates or double-claim rewards? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_6b5f5afb-9aab-4d9e-a831-18fd78c548df?mode=deep",
    "timestamp": "2026-02-19 10:11:44.200139",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Integer Overflow] When combining currentMinerList, previousTermInformation miners, and replaceCandidates into maybeNewElectedMiners, can an extremely large combined list cause memory/gas exhaustion or overflow in subsequent processing? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_8ca30f81-c241-4d5f-bb60-816319c1dfd5?mode=deep",
    "timestamp": "2026-02-19 10:12:18.420112",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [State Corruption] ReplaceCandidateMap is removed after reading - if Release is called twice for the same period (via reentrancy or race condition), will the second call miss the replace candidates, causing incorrect reward distribution? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_9a5f95cf-6f3d-4ae0-ac4a-8548f75182f8?mode=deep",
    "timestamp": "2026-02-19 10:12:47.251457",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Logic Error] maybeNewElectedMiners filters out miners with State.LatestMinedTerm[p] == 0 AND not in initial list - can a miner who mined in term 1, skipped terms, then returned be incorrectly treated as new, getting undeserved welcome rewards? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_6e5cc22f-e32b-42db-af33-30eb81464b8e?mode=deep",
    "timestamp": "2026-02-19 10:13:20.716922",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [DOS Attack] If previousTermInformation contains an enormous number of miners, will the filtering and processing of maybeNewElectedMiners cause gas exhaustion, preventing release and freezing all reward distributions? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_d3ce6833-a7b0-480e-8b8d-8229a4251d63?mode=deep",
    "timestamp": "2026-02-19 10:13:55.963759",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Accounting Error] AmountsMap is initialized with all symbols set to 0L - does DistributeProfits actually distribute the accumulated balances in the virtual address, or does this zero map cause all rewards to be lost? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_443b9d1d-218e-49c7-81c9-d392d53c314f?mode=deep",
    "timestamp": "2026-02-19 10:14:32.689004",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [State Inconsistency] UpdateStateBeforeDistribution is called before ReleaseTreasurySubProfitItems, but if the distribution fails, the state updates persist - can this cause permanent desynchronization between state and actual distributions? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_dd86d020-b123-4f09-93a1-4692526840c0?mode=deep",
    "timestamp": "2026-02-19 10:15:09.501661",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Race Condition] If multiple Release calls are queued for different periods, can out-of-order execution cause LatestMinedTerm updates to be applied incorrectly, breaking future reward calculations? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_87b43729-35f5-42cd-9f4c-655096a6b2f9?mode=deep",
    "timestamp": "2026-02-19 10:15:45.007601",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Authorization Bypass] When Context.Sender == Context.Self, TransferFrom is skipped - can an attacker call Donate through a delegatecall or inline call to donate without actually transferring tokens? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_2e43b47d-744a-482a-8d77-a754102fa1ff?mode=deep",
    "timestamp": "2026-02-19 10:16:17.008975",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Reentrancy] The function calls TransferFrom, then potentially ConvertToNativeToken (which calls Sell and recursively calls DonateAll) - can an attacker exploit reentrancy to manipulate DonatedDividends state or double-contribute? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_7143db39-3f6c-4a29-9fea-805e702f4f86?mode=deep",
    "timestamp": "2026-02-19 10:16:52.400774",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Token Validation Bypass] If IsTokenAvailableForMethodFee returns false, the function returns Empty without reverting - can an attacker donate worthless tokens that get accepted into the treasury without validation? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_29cda32b-0d51-4377-9de6-ad5c609fee1d?mode=deep",
    "timestamp": "2026-02-19 10:17:26.235785",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Accounting Error] When needToConvert is true, ConvertToNativeToken is called but DonatedDividends is NOT updated - does this mean converted donations aren't tracked, breaking dividend accounting? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_1d7176df-bff5-4ce0-85bb-c22ed388f6c2?mode=deep",
    "timestamp": "2026-02-19 10:17:59.590576",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [State Manipulation] DonatedDividends[Context.CurrentHeight] accumulates donations in the same block - if an attacker makes multiple donations in one block, can they manipulate the recorded amount to be higher or lower than actual? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_c6574dfd-f06f-433f-bdb9-fdc872705128?mode=deep",
    "timestamp": "2026-02-19 10:18:34.120078",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Logic Error] The code checks if donatesOfCurrentBlock != null AND symbol matches AND contains key, then adds - but if donatesOfCurrentBlock is null OR symbol doesn't match, it creates NEW Dividends - can this overwrite existing donations of other symbols in same block? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_062ee238-88ea-4d4a-afe9-eae521c9b23f?mode=deep",
    "timestamp": "2026-02-19 10:19:08.190388",
    "report_generated": false
  }
]