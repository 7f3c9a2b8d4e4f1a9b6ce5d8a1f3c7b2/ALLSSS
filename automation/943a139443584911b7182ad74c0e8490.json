[
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: CalculateVirtualHash()] [Null Token Handling] Line 223 checks if creationToken == null and returns organizationHash directly - can this create address collisions between organizations with and without creation tokens? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_212a9536-03a8-4909-994b-51dfe560753e?mode=deep",
    "timestamp": "2026-02-19 08:46:48.674089",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: CalculateVirtualHash()] [Hash Concatenation] Line 225 uses HashHelper.ConcatAndCompute - can specific combinations of organizationHash and creationToken produce identical results as organizationHash alone? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_c181c8f8-7c89-4f29-9511-aea81c9587f5?mode=deep",
    "timestamp": "2026-02-19 08:47:10.937140",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: CalculateVirtualHash()] [Token Reuse] If creationToken is reused across organizations, can this create predictable patterns in virtual hashes? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_5d322f1b-31a1-45ca-bab5-a7870ee9708a?mode=deep",
    "timestamp": "2026-02-19 08:47:33.343780",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: LockToken() + UnlockToken()] [Lock-Unlock Race] Can an attacker call UnlockToken immediately after LockToken in the same block, bypassing intended vote locking period? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_2196f112-de11-463e-a8d8-3251697461d6?mode=deep",
    "timestamp": "2026-02-19 08:47:56.029893",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: LockToken() + IsReleaseThresholdReached()] [Vote Counting Integrity] If tokens are locked but vote counts aren't updated atomically, can voting thresholds be bypassed? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_7f491819-2d40-41e8-8de0-e3fc32b3b1fa?mode=deep",
    "timestamp": "2026-02-19 08:48:19.631986",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: CreateNewProposal() + GetValidProposal()] [Proposal Lifecycle] Can a proposal become invalid between creation and first retrieval, causing execution of invalid proposals? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_183f1e6a-05a8-4187-8974-8dc4dd7c7fb5?mode=deep",
    "timestamp": "2026-02-19 08:48:43.900307",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: Validate(Organization) + CreateNewProposal()] [Organization-Proposal Consistency] Can proposals be created for organizations that fail validation, leading to unvotable proposals? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_726509b7-d8a7-4d69-af27-c0e30c025663?mode=deep",
    "timestamp": "2026-02-19 08:49:08.871874",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GetAllowance() + LockToken()] [Allowance-Lock Mismatch] If GetAllowance checks pass but subsequent LockToken fails, can this create inconsistent voting state? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_6328460c-badd-4d90-8c7b-2b8ac37653ff?mode=deep",
    "timestamp": "2026-02-19 08:49:34.796910",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GenerateProposalId() + CreateNewProposal()] [ID Collision Attack] Can an attacker precompute proposal IDs and create proposals that collide with legitimate future proposals? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_0732338e-e170-42f5-83e6-1bb57c0e4e9e?mode=deep",
    "timestamp": "2026-02-19 08:50:03.676749",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: AssertIsAuthorizedProposer() + CreateNewProposal()] [Authorization Timing] Is AssertIsAuthorizedProposer called before CreateNewProposal in all code paths? Can authorization be bypassed? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_59e0064f-9b1c-4f6b-ac86-8028823500ff?mode=deep",
    "timestamp": "2026-02-19 08:50:32.816713",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: RequireTokenContractStateSet() + GetTokenInfo()] [Token Contract Trust] All token operations trust the token contract - can a malicious or compromised token contract break referendum security? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_cae4dfa1-2658-4f73-a0eb-95a9909a63dd?mode=deep",
    "timestamp": "2026-02-19 08:51:02.974612",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: LockToken() + GetProposalVirtualAddress()] [Virtual Address Consistency] Are virtual addresses used consistently across lock/unlock operations, or can address mismatches cause token loss? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_5fb855f4-4a58-49b4-8dbf-8f7c31a647eb?mode=deep",
    "timestamp": "2026-02-19 08:51:32.396442",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: Validate(Proposal) + CheckCreateProposalInput()] [Validation Completeness] Do these two validation functions cover all security-critical proposal fields, or are some fields unvalidated? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_bb8db06a-12b2-49e8-8efa-30fbbed625b1?mode=deep",
    "timestamp": "2026-02-19 08:52:03.340442",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [State: LockedTokenAmount] [Mapping Structure] State.LockedTokenAmount uses nested mapping [address][proposalId] - can this structure be exploited to lock tokens under multiple proposal IDs? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_5462105c-902e-4c1e-854c-49883abcf8b4?mode=deep",
    "timestamp": "2026-02-19 08:52:31.665493",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [State: LockedTokenAmount] [State Cleanup] UnlockToken removes state on line 87 but LockToken checks a different address on line 42 - can orphaned state entries accumulate? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_d458c473-8b78-4228-848f-091d299e6f29?mode=deep",
    "timestamp": "2026-02-19 08:53:02.106592",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [State: Proposals] [Proposal Storage] Proposals are stored but never explicitly deleted - can expired proposals cause storage bloat or be reused maliciously? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_58244e40-5f8f-457b-bbc3-deb514bba337?mode=deep",
    "timestamp": "2026-02-19 08:53:33.101888",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [State: Organizations] [Organization Immutability] Organizations retrieved from state can be modified - are they immutable once created or can parameters be changed post-creation? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_04661b24-b2ea-4dba-9b86-279f4bb7eabd?mode=deep",
    "timestamp": "2026-02-19 08:54:04.222469",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [State: TokenContract] [Contract Address Caching] TokenContract address is cached in state - can this become stale if the token contract is upgraded or replaced? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_00919336-97fc-4838-ad03-d2d4f7da6713?mode=deep",
    "timestamp": "2026-02-19 08:54:34.654562",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [General: Virtual Addresses] [Virtual Address Security] Multiple functions use virtual addresses derived from proposal IDs - can these be predicted or manipulated for malicious purposes? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_3ffbcf8f-e4ed-4508-b5e4-149edd58733a?mode=deep",
    "timestamp": "2026-02-19 08:55:05.278091",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [General: Context.Sender] [Sender Authentication] Context.Sender is used throughout without additional authentication - can transaction origin be spoofed in the AElf context? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_744cdf90-4fff-47d3-b76c-d9ad230a90e0?mode=deep",
    "timestamp": "2026-02-19 08:55:34.075969",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [General: Context.CurrentBlockTime] [Time Manipulation] Multiple functions rely on Context.CurrentBlockTime - can miners manipulate block time to affect proposal\n\n### Citations\n\n**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L1-227)\n```csharp\nusing System;\nusing AElf.Contracts.MultiToken;\nusing AElf.CSharp.Core;\nusing AElf.Sdk.CSharp;\nusing AElf.Standards.ACS3;\nusing AElf.Types;\n\nnamespace AElf.Contracts.Referendum;\n\npublic partial class ReferendumContract\n{\n    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)\n    {\n        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;\n        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=\n                         proposalReleaseThreshold.MinimalVoteThreshold;\n        if (!enoughVote)\n            return false;\n\n        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;\n        if (isRejected)\n            return false;\n\n        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;\n        if (isAbstained)\n            return false;\n\n        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;\n    }\n\n    private void RequireTokenContractStateSet()\n    {\n        if (State.TokenContract.Value != null)\n            return;\n        State.TokenContract.Value =\n            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);\n    }\n\n    private ReferendumReceiptCreated LockToken(string symbol, long amount, Hash proposalId, Address lockedAddress,\n        Address organizationAddress)\n    {\n        Assert(State.LockedTokenAmount[lockedAddress][proposalId] == null,",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_2e29ac43-9c9f-4dee-afcd-51d008426788?mode=deep",
    "timestamp": "2026-02-19 08:56:01.487396",
    "report_generated": false
  }
]