[
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: ValidateTokenInfoExists()] [Early Throw] Throws at line 455 inside iteration - can this prevent proper validation of remaining keys? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_d693c4d6-e476-4b01-bca3-200de3c09f31?mode=deep",
    "timestamp": "2026-02-19 11:57:41.419581",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: ValidateTokenInfoExists()] [Owner Null Handling] Compares tokenInfo.Owner == input.Owner without null checks - can null vs empty address cause validation bypass? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_5aba8e94-d822-4076-9daa-81ab854db382?mode=deep",
    "timestamp": "2026-02-19 11:58:03.303215",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainCreateToken()] [Merkle Proof Bypass] CrossChainVerify at line 488 validates merkle path, but can attacker use old/replayed merkle proofs from previous blocks? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_e6c6b9fb-facd-42ad-9d06-f54539ac261e?mode=deep",
    "timestamp": "2026-02-19 11:58:25.540125",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainCreateToken()] [Transaction Replay] No check preventing same originalTransactionId from being used multiple times if merkle paths differ? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_5ae39dc8-00da-49a2-ba4a-97ec1e71b8a6?mode=deep",
    "timestamp": "2026-02-19 11:58:48.234370",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainCreateToken()] [Token Overwrite] If State.TokenInfos[tokenInfo.Symbol] already exists at line 506, only ExternalInfo is updated at line 528 - can this cause inconsistent token state? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_42e51bfe-356c-4101-8d00-dc51c50f1a8b?mode=deep",
    "timestamp": "2026-02-19 11:59:11.683101",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainCreateToken()] [Issuer Mismatch] Token is created with Issuer from validateTokenInfoExistsInput, but can this differ from actual issuer on origin chain? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_393dbcfe-cb39-46b3-804a-0ef7bc03dd44?mode=deep",
    "timestamp": "2026-02-19 11:59:38.143893",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainCreateToken()] [NFT Collection Bypass] AssertNftCollectionExist at line 491 checks collection exists, but what if collection was created after transfer transaction? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_39c86504-b75e-4798-a030-9326ed39d47a?mode=deep",
    "timestamp": "2026-02-19 12:00:02.980911",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainCreateToken()] [Alias Race Condition] SyncSymbolAliasFromTokenInfo at line 505 and ExternalInfo update at line 528 - can alias be set twice causing confusion? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_4e768e28-2721-4278-aa02-bcba3757ef38?mode=deep",
    "timestamp": "2026-02-19 12:00:28.205214",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: RegisterCrossChainTokenContractAddress()] [Controller Authorization Bypass] CheckCrossChainTokenContractRegistrationControllerAuthority at line 538 - can attacker gain control of controller to register malicious addresses? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_63babc1d-a299-497f-ad2b-c6f3b21a0c17?mode=deep",
    "timestamp": "2026-02-19 12:00:54.676444",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: RegisterCrossChainTokenContractAddress()] [Address Extraction Manipulation] ExtractTokenContractAddress at line 544 parses from transaction params - can malformed params cause extraction of wrong address? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_ec4b00ad-d977-491b-84d0-ba0ea74428e5?mode=deep",
    "timestamp": "2026-02-19 12:01:21.872265",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: RegisterCrossChainTokenContractAddress()] [Whitelist Overwrite] State.CrossChainTransferWhiteList[input.FromChainId] at line 549 overwrites existing value - can this deregister legitimate contract? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_0ff6205a-9600-449e-b0d9-9e1683648975?mode=deep",
    "timestamp": "2026-02-19 12:01:48.429174",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainTransfer()] [Blacklist Check Position] IsInTransferBlackListInternal check at line 562 happens before burn, but can blacklisted address still burn tokens even if transfer fails? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_123365fb-214e-45bd-86a5-e00c76693dec?mode=deep",
    "timestamp": "2026-02-19 12:02:18.732496",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainTransfer()] [IssueChainId Mismatch] Requires issueChainId == input.IssueChainId at line 566, but can attacker specify wrong chainId to bypass cross-chain controls? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_f577631d-9c60-4c0c-b002-4d095d3320ec?mode=deep",
    "timestamp": "2026-02-19 12:02:48.817186",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainTransfer()] [Burn Without Verification] Tokens are burned at line 572 without verifying recipient exists on target chain - can tokens be permanently lost? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_7375479d-4509-42bb-98e8-0c0bbf50a601?mode=deep",
    "timestamp": "2026-02-19 12:03:19.730412",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainTransfer()] [Event Replay] CrossChainTransferred event at line 573 can be replayed on receiving chain - are there replay protections? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_3b8e9b4d-5ccc-4871-a06b-ad02a1035f6a?mode=deep",
    "timestamp": "2026-02-19 12:03:51.352902",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainReceiveToken()] [Double Claim] State.VerifiedCrossChainTransferTransaction check at line 596, but can attacker claim tokens before this flag is set through reentrancy? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_5cb36e00-1564-4b55-a571-c199017a6335?mode=deep",
    "timestamp": "2026-02-19 12:04:19.624272",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainReceiveToken()] [Supply Overflow] tokenInfo.Supply.Add(amount) at line 620 and check at line 621 - can multiple concurrent claims cause supply to exceed total supply? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_70ba8459-fba2-4b55-a7fc-06113c8b0aa5?mode=deep",
    "timestamp": "2026-02-19 12:04:50.014267",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainReceiveToken()] [Recipient Address Manipulation] receivingAddress from crossChainTransferInput at line 603 - can attacker modify transaction params to redirect tokens? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_00ab896c-782a-4897-88ac-105eee410343?mode=deep",
    "timestamp": "2026-02-19 12:05:16.939448",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainReceiveToken()] [ChainId Validation] targetChainId must equal Context.ChainId at line 610, but can attacker claim tokens on wrong chain by manipulating context? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_8683fa1b-9f9e-4b1c-b71c-ba16a194bc20?mode=deep",
    "timestamp": "2026-02-19 12:05:45.939354",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainReceiveToken()] [Merkle Proof Validation Window] CrossChainVerify at line 617 validates proof, but can old proofs from reorganized blocks still be valid? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_b1fdd502-e9b5-4355-a18c-6ecd3695dd4c?mode=deep",
    "timestamp": "2026-02-19 12:06:14.370361",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainReceiveToken()] [State Update Order] VerifiedCrossChainTransferTransaction set at line 619 after all validations but before supply update - can reentrancy bypass this? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_c48fde93-f068-41ec-8117-ca568b455deb?mode=deep",
    "timestamp": "2026-02-19 12:06:43.110282",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: ModifyTokenIssuerAndOwner()] [Disabled State Race] Check State.TokenIssuerAndOwnerModificationDisabled.Value at line 644, but can value change between check and modification? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_376e9bd8-3ae5-4cd6-bf87-5b504522c91a?mode=deep",
    "timestamp": "2026-02-19 12:07:12.059499",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: ModifyTokenIssuerAndOwner()] [Owner Null Bypass] Requires tokenInfo.Owner == null at line 653, but can attacker set Owner to empty (non-null) address to bypass this? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_8df39178-fa68-4e19-abc0-8accc446886c?mode=deep",
    "timestamp": "2026-02-19 12:07:41.078902",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: ModifyTokenIssuerAndOwner()] [Missing SetTokenInfo] After modifying issuer/owner at lines 655-656, SetTokenInfo is not called - do changes persist? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_28a6cfef-15ba-4077-9ba1-b05f4f9e0e62?mode=deep",
    "timestamp": "2026-02-19 12:08:08.019965",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: ModifyTokenIssuerAndOwner()] [Issuer Authorization Bypass] Only checks tokenInfo.Issuer == Context.Sender at line 652, but can old issuer still issue after modification? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_efc4ac96-294c-4f09-a5d3-68ae2194d6ca?mode=deep",
    "timestamp": "2026-02-19 12:08:38.155193",
    "report_generated": false
  }
]