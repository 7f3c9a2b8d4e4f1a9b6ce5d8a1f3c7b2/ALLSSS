[
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: CheckSymbolIdentifier()] [String Parsing] CheckSymbolIdentifier() splits symbol by NFTSymbolSeparator and checks if words[0] or words[1] equals allSymbolIdentifier - can crafted symbols with multiple separators cause array index out of bounds when accessing words[1]? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_653f48e2-a53c-4f3d-8b6d-ea8e8af682a6?mode=deep",
    "timestamp": "2026-02-19 07:13:36.443495",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: CheckSymbolIdentifier()] [Logic Bypass] The function returns true if words[1].Equals(allSymbolIdentifier) when words.Length > 1, but does not validate what words[0] contains - can an attacker prepend arbitrary prefixes to all-symbol identifiers to bypass intended restrictions? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_db21b2aa-e0e8-4dbb-a223-b381f9a4b415?mode=deep",
    "timestamp": "2026-02-19 07:13:58.616266",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: CheckSymbolIdentifier()] [Identifier Collision] If GetAllSymbolIdentifier() returns a common string that could naturally appear in legitimate token symbols, can CheckSymbolIdentifier() false-positive on regular tokens, causing them to be treated as all-symbol allowances? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_cb767c66-0d21-418d-a833-9551a285087c?mode=deep",
    "timestamp": "2026-02-19 07:14:22.027721",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: CheckSymbolIdentifier()] [Empty String Handling] If symbol is empty or null, does symbol.Split() throw exceptions or return unexpected arrays that cause CheckSymbolIdentifier() to return incorrect boolean values? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_3f8e9eea-47e9-4b68-bfa4-9a1f944c095e?mode=deep",
    "timestamp": "2026-02-19 07:14:46.108099",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: IsInWhiteList()] [Default Value] IsInWhiteList() directly returns State.LockWhiteLists[input.Symbol][input.Address] - if this mapping is uninitialized for a symbol-address pair, does it return false (safe) or can uninitialized state cause undefined behavior? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_23e6b23a-c760-4f1b-91c2-1c0a110c19b9?mode=deep",
    "timestamp": "2026-02-19 07:15:10.408104",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: IsInWhiteList()] [Input Validation] Does IsInWhiteList() validate that input.Symbol exists and input.Address is valid before state lookup, or can querying non-existent symbols return misleading whitelist status? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_9f2c5831-d3bd-45e2-aea3-5196a0a22a2c?mode=deep",
    "timestamp": "2026-02-19 07:15:37.343119",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: IsInWhiteList()] [Whitelist Purpose] The function checks LockWhiteLists but doesn't validate the purpose of whitelisting - can addresses be whitelisted for one lock type but the status misused for different lock operations? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_dd270e3e-de89-4d0d-bd8d-76b9c5c4b16b?mode=deep",
    "timestamp": "2026-02-19 07:16:03.922975",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetLockedAmount()] [Lock ID Null Check] GetLockedAmount() asserts input.LockId != null, but does it validate that LockId is non-empty or contains valid hash data before using it in GetVirtualAddressForLocking()? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_5d04d65a-cf96-4264-859e-e88ef6ef3c56?mode=deep",
    "timestamp": "2026-02-19 07:16:32.200602",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetLockedAmount()] [Virtual Address Collision] GetLockedAmount() derives virtualAddress from Address and LockId, but if hash collisions occur in GetVirtualAddressForLocking(), can an attacker query locked amounts of different users by crafting colliding LockIds? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_5d283851-2da6-4b52-bc3c-01f89525bd8d?mode=deep",
    "timestamp": "2026-02-19 07:17:02.216437",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetLockedAmount()] [Symbol Validation] GetLockedAmount() queries balance using input.Symbol without resolving aliases via GetActualTokenSymbol() - can this cause locked amount queries to fail or return incorrect values for aliased tokens? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_075c7796-883d-4f2e-9f10-7c684aab288d?mode=deep",
    "timestamp": "2026-02-19 07:17:32.838053",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetLockedAmount()] [Balance Query] The function calls GetBalance(virtualAddress, input.Symbol) but doesn't verify the virtualAddress was properly computed - can failures in virtual address generation lead to querying wrong addresses and reporting incorrect locked amounts? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_661d3518-75d4-41f6-bf7c-91b8bf13c3fd?mode=deep",
    "timestamp": "2026-02-19 07:18:04.679606",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetVirtualAddressForLocking()] [Hash Collision] GetVirtualAddressForLocking() uses HashHelper.ComputeFrom() to concatenate Context.Sender, input.Address, and input.LockId - can an attacker find different combinations that produce the same hash, allowing them to access another user's locked funds? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_0dcbadcd-0680-4771-a90c-a151c9a76615?mode=deep",
    "timestamp": "2026-02-19 07:18:36.442717",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetVirtualAddressForLocking()] [Context.Sender Dependency] The virtual address computation includes Context.Sender.Value - can different callers querying the same Address+LockId get different virtual addresses, breaking the invariant that locked amounts should be consistent regardless of querier? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_d06afa62-803d-4a42-bc27-c1a52a6aa9f6?mode=deep",
    "timestamp": "2026-02-19 07:19:06.714854",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetVirtualAddressForLocking()] [Input Validation] Does GetVirtualAddressForLocking() validate that input.Address and input.LockId are non-null before concatenating, or can null values cause hash computation to produce predictable virtual addresses? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_4181b17e-49b2-4ac0-a214-57ee88cc4923?mode=deep",
    "timestamp": "2026-02-19 07:19:37.060302",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetVirtualAddressForLocking()] [Virtual Address Conversion] After computing fromVirtualAddress hash, the function calls Context.ConvertVirtualAddressToContractAddress() - can this conversion fail or return an already-used address causing locked fund confusion? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_949f7034-735e-4b55-9932-a096bd0bb226?mode=deep",
    "timestamp": "2026-02-19 07:20:07.502904",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetCrossChainTransferTokenContractAddress()] [Uninitialized State] GetCrossChainTransferTokenContractAddress() returns State.CrossChainTransferWhiteList[input.ChainId] directly - if a ChainId is not whitelisted, does it return null or zero address, and can this cause cross-chain transfers to be incorrectly validated? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_96dfc6c2-1e01-4323-b578-1d1ecb728108?mode=deep",
    "timestamp": "2026-02-19 07:20:39.111017",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetCrossChainTransferTokenContractAddress()] [ChainId Validation] Does the function validate that input.ChainId is a valid chain ID before lookup, or can attackers query arbitrary ChainId values to enumerate whitelisted chains? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_71a4f918-966c-4463-9c75-c6e31ac91846?mode=deep",
    "timestamp": "2026-02-19 07:21:12.478975",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetCrossChainTransferTokenContractAddress()] [Whitelist Bypass] If State.CrossChainTransferWhiteList mappings can be manipulated through governance, can an attacker register malicious contract addresses for valid ChainIds, causing GetCrossChainTransferTokenContractAddress() to return attacker-controlled addresses? (Critical)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_9aa998a1-7d11-474b-b186-fb954afa527c?mode=deep",
    "timestamp": "2026-02-19 07:21:44.656760",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetPrimaryTokenSymbol()] [State Caching] GetPrimaryTokenSymbol() caches _primaryTokenSymbol and checks State.ChainPrimaryTokenSymbol.Value - if the primary token changes after caching, can stale cached values cause fee calculations or consensus operations to use the wrong token? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_0dcb4e04-c121-4a6a-8ff2-d44496671f2d?mode=deep",
    "timestamp": "2026-02-19 07:22:17.461082",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetPrimaryTokenSymbol()] [Fallback Logic] The function falls back to Context.Variables.NativeSymbol if both _primaryTokenSymbol and State.ChainPrimaryTokenSymbol.Value are null/empty - can this fallback be exploited if NativeSymbol is uninitialized or manipulated? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_f1debb98-239a-4311-a279-fc1ecdec0c7a?mode=deep",
    "timestamp": "2026-02-19 07:22:51.446836",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetPrimaryTokenSymbol()] [String.IsNullOrWhiteSpace Check] The check string.IsNullOrWhiteSpace(_primaryTokenSymbol) only updates the cache if true - can partial initialization where _primaryTokenSymbol is set to empty string cause the cache to never update? (Low)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_93287681-1941-4362-bb7a-4a1d48314f23?mode=deep",
    "timestamp": "2026-02-19 07:23:24.948819",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetCalculateFeeCoefficientsForContract()] [Fee Type Bypass] If input.Value equals FeeTypeEnum.Tx, GetCalculateFeeCoefficientsForContract() returns empty CalculateFeeCoefficients - can this bypass fee calculations by setting contracts to use Tx fee type incorrectly? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_f22d9642-5d7d-4c2d-90a1-3f1875300464?mode=deep",
    "timestamp": "2026-02-19 07:23:58.387970",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetCalculateFeeCoefficientsForContract()] [Null Coefficients] The function uses FirstOrDefault() which can return null if no matching FeeTokenType exists - can null coefficients cause divide-by-zero or null reference exceptions in fee calculation logic? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_0409f6f1-2230-44b3-97bc-0641e60901c0?mode=deep",
    "timestamp": "2026-02-19 07:24:30.326356",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetCalculateFeeCoefficientsForContract()] [State.AllCalculateFeeCoefficients] Does the function validate that State.AllCalculateFeeCoefficients.Value is initialized before accessing .Value.FirstOrDefault(), or can uninitialized state cause exceptions? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_d2ba82ce-06f9-4001-94dd-3a0971b515c4?mode=deep",
    "timestamp": "2026-02-19 07:25:03.254068",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetCalculateFeeCoefficientsForContract()] [Fee Type Manipulation] Can an attacker manipulate input.Value to query coefficients for fee types that shouldn't be accessible, potentially discovering or exploiting unintended fee calculation paths? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_df3d688b-5740-4bdb-b00c-65f27dcc99d2?mode=deep",
    "timestamp": "2026-02-19 07:25:34.460560",
    "report_generated": false
  }
]