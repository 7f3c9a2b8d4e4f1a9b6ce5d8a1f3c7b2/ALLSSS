[
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GenerateNextRoundInformation()] [IsExtraBlockProducer Transfer] Can transferring IsExtraBlockProducer flag at line 334 allow evil miner's extra block privilege to be inherited without validation? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_1fbe9f3f-f975-4403-99bb-51baa6e48996?mode=deep",
    "timestamp": "2026-02-19 14:12:21.564782",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GenerateNextRoundInformation()] [Dictionary Modification] Does Remove+Add pattern at lines 337-338 create race condition if another thread reads RealTimeMinersInformation simultaneously? (Medium)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_127f024b-2832-4507-b513-0437e3e90a9c?mode=deep",
    "timestamp": "2026-02-19 14:12:43.859706",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GenerateNextRoundInformation()] [IsMinerListJustChanged Flag] Does setting isMinerListChanged=true at line 341 propagate correctly to prevent stale miner checks? (High)",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_5b33298a-bd1b-4baf-ba18-4af4bc70e48f?mode=deep",
    "timestamp": "2026-02-19 14:13:06.280149",
    "report_generated": false
  },
  {
    "question": "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GenerateNextRoundInformation()] [Round Generation Delegation] Can currentR\n\n### Citations\n\n**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L1-474)\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing AElf.Contracts.Election;\nusing AElf.CSharp.Core;\nusing AElf.CSharp.Core.Extension;\nusing AElf.Sdk.CSharp;\nusing AElf.Types;\nusing Google.Protobuf.WellKnownTypes;\n\nnamespace AElf.Contracts.Consensus.AEDPoS;\n\n// ReSharper disable once InconsistentNaming\npublic partial class AEDPoSContract\n{\n    public override Int64Value GetCurrentRoundNumber(Empty input)\n    {\n        return new() { Value = State.CurrentRoundNumber.Value };\n    }\n\n    public override Round GetCurrentRoundInformation(Empty input)\n    {\n        return TryToGetCurrentRoundInformation(out var currentRound) ? currentRound : new Round();\n    }\n\n    public override Round GetRoundInformation(Int64Value input)\n    {\n        return TryToGetRoundInformation(input.Value, out var round) ? round : new Round();\n    }\n\n    public override MinerList GetCurrentMinerList(Empty input)\n    {\n        return TryToGetCurrentRoundInformation(out var round)\n            ? new MinerList\n            {\n                Pubkeys =\n                {\n                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))\n                }\n            }\n            : new MinerList();\n    }\n\n    public override PubkeyList GetCurrentMinerPubkeyList(Empty input)\n    {\n        return new()\n        {\n            Pubkeys = { GetCurrentMinerList(input).Pubkeys.Select(p => p.ToHex()) }\n        };\n    }\n\n    public override MinerListWithRoundNumber GetCurrentMinerListWithRoundNumber(Empty input)\n    {\n        return new()\n        {\n            MinerList = GetCurrentMinerList(new Empty()),\n            RoundNumber = State.CurrentRoundNumber.Value\n        };\n    }\n\n    public override Round GetPreviousRoundInformation(Empty input)\n    {\n        return TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round();\n    }\n\n    public override MinerList GetMinerList(GetMinerListInput input)\n    {\n        return State.MinerListMap[input.TermNumber] ?? new MinerList();\n    }\n\n    public override Int64Value GetMinedBlocksOfPreviousTerm(Empty input)\n    {\n        if (TryToGetTermNumber(out var termNumber))\n        {\n            var targetRound = State.FirstRoundNumberOfEachTerm[termNumber].Sub(1);\n            if (TryToGetRoundInformation(targetRound, out var round))\n                return new Int64Value { Value = round.GetMinedBlocks() };\n        }\n\n        return new Int64Value();\n    }\n\n    public override MinerList GetPreviousMinerList(Empty input)\n    {\n        if (TryToGetTermNumber(out var termNumber) && termNumber > 1)\n            return State.MinerListMap[termNumber.Sub(1)] ?? new MinerList();\n\n        return new MinerList();\n    }\n\n    public override StringValue GetNextMinerPubkey(Empty input)\n    {\n        if (TryToGetCurrentRoundInformation(out var round))\n            return new StringValue\n            {\n                Value = round.RealTimeMinersInformation.Values\n                            .FirstOrDefault(m => m.ExpectedMiningTime > Context.CurrentBlockTime)?.Pubkey ??\n                        round.RealTimeMinersInformation.Values.First(m => m.IsExtraBlockProducer).Pubkey\n            };\n\n        return new StringValue();\n    }\n\n    /// <summary>\n    ///     Current implementation can be incorrect if all nodes recovering from\n    ///     a strike more than the time of one round, because it's impossible to\n    ///     infer a time slot in this situation.\n    /// </summary>\n    /// <param name=",
    "url": "https://deepwiki.com/search/-aelf-smart-contract-security_7879803a-ec29-4e0f-85fe-c2aaaa861421?mode=deep",
    "timestamp": "2026-02-19 14:13:29.421300",
    "report_generated": false
  }
]