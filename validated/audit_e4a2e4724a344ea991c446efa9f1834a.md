# Audit Report

## Title
Hash Collision in NFT Token Identification Causes Cross-Protocol Balance and State Corruption

## Summary
The NFT contract's `CalculateTokenHash` function concatenates symbol and tokenId without a delimiter before hashing, creating collision vulnerabilities when protocol symbol lengths transition from N digits to N+1 digits. This allows different protocols' NFTs to share the same tokenHash, causing cross-protocol state corruption in balances, metadata, allowances, and assembly data.

## Finding Description

The vulnerability originates in the hash calculation that serves as the unique identifier for all NFT operations: [1](#0-0) 

NFT protocol symbols combine a 2-character type code with an N-digit random number. The initial number length is 9 digits: [2](#0-1) 

The symbol generation mechanism creates numbers in ranges that increase as capacity is exhausted: [3](#0-2) 

When the length transitions from 9 to 10 digits, collisions become possible:
- Protocol A: "AR123456789" + tokenId "123" = "AR123456789123"  
- Protocol B: "AR1234567891" + tokenId "23" = "AR123456789123"

Both produce identical strings before hashing, resulting in the same tokenHash that keys all critical state mappings: [4](#0-3) 

The minting logic allows users to specify custom tokenIds: [5](#0-4) 

The uniqueness check is bypassed when a protocol has `IsTokenIdReuse=true`: [6](#0-5) 

When a collision occurs with `IsTokenIdReuse=true`, the code modifies the existing NFT from a different protocol: [7](#0-6) 

This corrupted state is then persisted to all affected maps: [8](#0-7) 

## Impact Explanation

The collision causes critical cross-protocol state corruption:

1. **Balance Mixing**: `BalanceMap[tokenHash][owner]` accumulates balances from different protocols' NFTs, causing balance queries to return incorrect totals combining unrelated assets.

2. **Metadata Corruption**: When minting the colliding NFT with `IsTokenIdReuse=true`, the existing `NftInfoMap[tokenHash]` entry (from the victim protocol) gets its quantity increased and minters list modified, corrupting the original NFT's metadata while retaining the wrong symbol.

3. **Allowance Confusion**: `AllowanceMap[tokenHash][owner][spender]` becomes shared between protocols. An approval for Protocol A's NFT inadvertently grants allowance for Protocol B's colliding NFT, enabling unauthorized cross-protocol transfers.

4. **Assembly Data Corruption**: `AssembledNftsMap` and `AssembledFtsMap` using the colliding hash cause disassembly operations to retrieve wrong component data, breaking composite NFT mechanics.

The impact extends beyond individual users to systemic protocol integrity: supply counters become inaccurate, NFT uniqueness guarantees are violated, and the fundamental security assumption that each NFT has a unique identifier is broken.

## Likelihood Explanation

**Attacker Capabilities:**

Protocol creation is permissionless (only requires mainchain execution): [9](#0-8) 

Attackers control the `IsTokenIdReuse` setting for their own protocols: [10](#0-9) 

**Attack Complexity: LOW**

The attack sequence:
1. Monitor blockchain for symbol length transition from 9 to 10 digits
2. Enumerate existing protocols to identify collision targets (9-digit symbols with suitable tokenIds)
3. Create new protocol with `IsTokenIdReuse=true`, repeat until receiving a 10-digit symbol matching the collision pattern
4. Mint NFT with calculated tokenId to trigger collision

**Feasibility: HIGH**

- Symbol ranges are disjoint: 9-digit [100,000,000 - 999,999,999], 10-digit [1,000,000,000 - 9,999,999,999]
- Both number spaces will naturally exist as the protocol scales
- No special permissions required beyond normal user capabilities
- Multiple collision opportunities exist at each length transition (9→10, 10→11, etc.)
- The uniqueness check in `IsCreatedMap` only prevents duplicate numbers, not cross-protocol collisions

**Detection: Difficult**

Collision attacks appear as legitimate protocol creation and minting. Balance queries still return values (just incorrect ones). Only detailed state inspection reveals the corruption.

## Recommendation

Add a delimiter to the hash calculation to prevent concatenation ambiguity:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}#{tokenId}");
}
```

Alternatively, use structured hashing:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol), 
        HashHelper.ComputeFrom(tokenId)
    );
}
```

Additionally, strengthen the uniqueness check to detect cross-protocol collisions regardless of `IsTokenIdReuse` setting:

```csharp
var nftInfo = State.NftInfoMap[tokenHash];
if (nftInfo != null && nftInfo.Symbol != input.Symbol)
    throw new AssertionException($"Token hash collision detected across protocols.");
```

## Proof of Concept

```csharp
[Fact]
public async Task HashCollision_CrossProtocol_StateCorruption()
{
    // Setup: Create first protocol with 9-digit symbol during initial phase
    var protocol1 = await CreateProtocolAsync("Art", isTokenIdReuse: false);
    // Assume protocol1.Symbol = "AR123456789"
    
    // Mint NFT with tokenId 123 on protocol1
    await MintNFTAsync(protocol1.Symbol, tokenId: 123, owner: User1Address);
    
    // Verify initial state
    var hash1 = CalculateHash("AR123456789", 123); // "AR123456789123"
    var balance1 = await GetBalanceAsync(hash1, User1Address);
    Assert.Equal(1, balance1);
    
    // Trigger transition to 10-digit symbols (simulate protocol scaling)
    await TriggerSymbolLengthTransition();
    
    // Attack: Create second protocol with isTokenIdReuse=true
    var protocol2 = await CreateProtocolAsync("Art", isTokenIdReuse: true);
    // Assume protocol2.Symbol = "AR1234567891" (10 digits)
    
    // Mint with tokenId 23 to create collision
    await MintNFTAsync(protocol2.Symbol, tokenId: 23, owner: User2Address);
    
    // Verify collision: same hash
    var hash2 = CalculateHash("AR1234567891", 23); // "AR123456789123"
    Assert.Equal(hash1, hash2);
    
    // Impact: Balance mixing across protocols
    var corruptedBalance1 = await GetBalanceAsync(hash1, User1Address);
    var corruptedBalance2 = await GetBalanceAsync(hash2, User2Address);
    Assert.NotEqual(1, corruptedBalance1); // Corrupted
    Assert.NotEqual(1, corruptedBalance2); // Corrupted
    
    // Impact: Metadata corruption - protocol1's NFT metadata modified
    var nftInfo = await GetNFTInfoAsync(hash1);
    Assert.Equal(2, nftInfo.Quantity); // Original 1 + new 1
    Assert.Contains(User1Address, nftInfo.Minters);
    Assert.Contains(User2Address, nftInfo.Minters); // Cross-protocol contamination
    Assert.Equal("AR123456789", nftInfo.Symbol); // Wrong - should reflect protocol2
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L392-393)
```csharp
        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L394-396)
```csharp
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-437)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L439-441)
```csharp
        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-33)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L48-48)
```csharp
            IsTokenIdReuse = input.IsTokenIdReuse,
```
