# Audit Report

## Title
Vote Contract Timestamp Enforcement Missing - Sponsor Can Manipulate Snapshot Timing

## Summary
The Vote contract accepts `StartTimestamp` and `EndTimestamp` parameters during voting item registration but never enforces these time constraints in critical functions. The sponsor has unrestricted control over when to call `TakeSnapshot()`, allowing strategic timing to capture favorable voting states, even indefinitely past the declared end time. This enables timing-based manipulation of voting outcomes and violates voter expectations about voting deadlines.

## Finding Description

The Vote contract stores timestamp fields but lacks enforcement logic in critical functions. During registration, the contract accepts and stores `StartTimestamp` and `EndTimestamp` fields [1](#0-0) , with protocol documentation describing these as "The start time of the voting" and "The end time of the voting" [2](#0-1) .

The only timestamp validation occurs during registration, checking that `EndTimestamp > StartTimestamp` [3](#0-2) . However, these timestamps are never validated afterward in any execution path.

The `Vote()` function validates voting eligibility through `AssertValidVoteInput()` [4](#0-3) , which only checks snapshot numbers with no comparison of `Context.CurrentBlockTime` against the voting item's timestamps [5](#0-4) .

The `TakeSnapshot()` function similarly lacks any timestamp validation [6](#0-5) . It only verifies sponsor permission, snapshot number limits, and sequential snapshot numbers. No code prevents the sponsor from delaying `TakeSnapshot()` indefinitely, even past `EndTimestamp`.

Test evidence confirms this behavior: a voting item registered with 100 days duration can be immediately "ended" by taking a snapshot, demonstrating that the voting period is controlled entirely by snapshot mechanics rather than timestamp constraints [7](#0-6) .

## Impact Explanation

**Governance Manipulation:**
Sponsors can strategically time snapshot captures to include or exclude specific votes. If early votes are unfavorable, the sponsor waits for more votes before taking a snapshot. If votes become unfavorable later, the sponsor can take a snapshot immediately. Voting can continue indefinitely past the declared `EndTimestamp`, allowing the sponsor to optimize outcomes.

**Voter Expectation Violation:**
Voters see `StartTimestamp` and `EndTimestamp` in the voting item structure and reasonably believe voting ends at that time. This can cause voters to either not cast votes thinking the period has ended, or rush to vote before `EndTimestamp` when timing is actually irrelevant to the snapshot process.

**Protocol-Level Impact:**
While the Election contract registers voting items with effectively infinite timestamps [8](#0-7) , the Vote contract is a generic infrastructure component. Any external contracts or systems using it to create voting items with meaningful time constraints would find those constraints completely unenforced, creating a timing attack surface for governance decisions.

## Likelihood Explanation

**Attacker Capabilities:**
The attacker is the voting item sponsor who registered the voting system. No special privileges beyond being the sponsor are needed, and no collusion is required.

**Attack Complexity:**
Trivial - the sponsor simply delays calling `TakeSnapshot()`. No complex transactions, state manipulation, or timing precision is required.

**Economic Rationality:**
Zero cost to execute (just delay action), with high benefit from controlling voting outcome timing. This is particularly valuable in close votes or important governance decisions, making it economically rational for sponsors to optimize snapshot timing.

## Recommendation

Add timestamp validation to the `Vote()` and `TakeSnapshot()` functions:

1. In `AssertValidVoteInput()`, add validation that `Context.CurrentBlockTime` is between `StartTimestamp` and `EndTimestamp`
2. In `TakeSnapshot()`, add validation that prevents taking snapshots before `StartTimestamp` or after `EndTimestamp`
3. Alternatively, if timestamps are intended to be informational only, update the protobuf documentation to clarify this and remove the misleading field names

## Proof of Concept

The existing test case demonstrates the vulnerability: [9](#0-8) 

This test shows that a voting item registered with 100 days duration can be immediately ended by taking a snapshot, with no timestamp validation preventing this manipulation.

## Notes

The vulnerability stems from a design inconsistency where timestamps are documented and validated during registration as if they control voting periods, but the actual enforcement mechanism is based solely on snapshot numbers. This creates a mismatch between voter expectations (based on visible timestamps) and actual behavior (controlled by sponsor's snapshot timing decisions). The sponsor role is not privileged in the traditional sense—anyone can become a sponsor by registering a voting item—making this attack vector accessible to any actor creating governance votes through the Vote contract.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L46-47)
```csharp
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L92-92)
```csharp
        var votingItem = AssertValidVoteInput(input);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L241-273)
```csharp
    public override Empty TakeSnapshot(TakeSnapshotInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);

        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");

        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");

        // Update previous voting going information.
        var previousVotingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
        var previousVotingResult = State.VotingResults[previousVotingResultHash];
        previousVotingResult.SnapshotEndTimestamp = Context.CurrentBlockTime;
        State.VotingResults[previousVotingResultHash] = previousVotingResult;

        Assert(votingItem.CurrentSnapshotNumber == input.SnapshotNumber,
            $"Can only take snapshot of current snapshot number: {votingItem.CurrentSnapshotNumber}, but {input.SnapshotNumber}");
        var nextSnapshotNumber = input.SnapshotNumber.Add(1);
        votingItem.CurrentSnapshotNumber = nextSnapshotNumber;
        State.VotingItems[votingItem.VotingItemId] = votingItem;

        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L361-361)
```csharp
        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** protobuf/vote_contract.proto (L88-91)
```text
    // The start time of the voting.
    google.protobuf.Timestamp start_timestamp = 1;
    // The end time of the voting.
    google.protobuf.Timestamp end_timestamp = 2;
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L92-102)
```csharp
        //voting item have been out of date
        {
            var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
            await TakeSnapshot(registerItem.VotingItemId, 1);

            var voter = Accounts[11].KeyPair;
            var voteResult =
                await VoteWithException(voter, registerItem.VotingItemId, registerItem.Options[0], 100);
            voteResult.Status.ShouldBe(TransactionResultStatus.Failed);
            voteResult.Error.Contains("Current voting item already ended").ShouldBeTrue();
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L60-67)
```csharp
        var votingRegisterInput = new VotingRegisterInput
        {
            IsLockToken = false,
            AcceptedCurrency = Context.Variables.NativeSymbol,
            TotalSnapshotNumber = long.MaxValue,
            StartTimestamp = TimestampHelper.MinValue,
            EndTimestamp = TimestampHelper.MaxValue
        };
```
