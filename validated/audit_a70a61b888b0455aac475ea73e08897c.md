# Audit Report

## Title
Assembled NFTs Can Be Burned Directly, Causing Permanent Loss of Locked Fungible Tokens

## Summary
The `Burn` method in the NFT contract does not verify whether an NFT contains assembled assets before destroying it. When a minter burns an assembled NFT directly instead of using `Disassemble`, the fungible tokens locked during assembly remain permanently trapped in the contract with no recovery mechanism.

## Finding Description

The NFT contract implements an assembly mechanism where users can lock fungible tokens (FTs) and other NFTs inside a newly minted assembled NFT. [1](#0-0) 

During assembly, FTs are transferred from the user to the NFT contract itself via `State.TokenContract.TransferFrom`, and the locked asset information is stored in `State.AssembledFtsMap`. [2](#0-1) [3](#0-2) 

The intended recovery path is through the `Disassemble` method, which burns the assembled NFT, retrieves the locked assets from state mappings, transfers them back to the receiver, and removes the state entries. [4](#0-3) 

However, the `Burn` method can be called directly by any minter who owns the assembled NFT. [5](#0-4) 

**Root Cause:** The `Burn` method only verifies that the protocol is burnable, the caller is a minter, and the caller has sufficient balance. [6](#0-5)  It lacks any check to determine if the NFT being burned has entries in `AssembledFtsMap` or `AssembledNftsMap`. The state mappings for assembled assets are defined in the contract state. [7](#0-6) 

When an assembled NFT is burned directly:
1. The NFT balance is reduced to zero [8](#0-7) 
2. The supply and quantity are decremented [9](#0-8) 
3. The NFT is marked as burned [10](#0-9) 
4. **The `AssembledFtsMap` entry remains in state but becomes orphaned**
5. **The locked FTs remain in the contract address**

After this occurs, `Disassemble` cannot recover the locked assets because it first calls `Burn` with amount=1, which requires the caller to have balance ≥ 1. [11](#0-10)  Since the balance is already 0 from the direct burn, the assertion at line 91-92 will fail.

Code analysis confirms that `AssembledFtsMap` is only accessed during `Assemble` (to store) and `Disassemble` (to retrieve and remove), with no alternative recovery mechanism. No admin or privileged method exists to rescue orphaned assembled assets.

## Impact Explanation

**Direct Asset Loss:** All fungible tokens locked in the assembled NFT become permanently trapped in the NFT contract address with no possibility of recovery. For example, if 1,000 ELF tokens were locked during assembly, they become permanently inaccessible.

**Affected Parties:**
- NFT owners who assembled valuable FTs into NFTs lose their locked assets
- Any subsequent owner of an assembled NFT who receives it via transfer
- The protocol's economic integrity, as locked assets are removed from circulating supply permanently without any burn mechanism

**Severity Justification:** HIGH severity because:
1. Results in permanent, unrecoverable loss of user funds
2. Can affect any assembled NFT with arbitrary value of locked FTs
3. Requires only normal operational permissions (minter role)
4. No admin recovery mechanism exists in the contract
5. Violates the fundamental security guarantee that assembled assets can always be recovered through disassembly

## Likelihood Explanation

**Attacker Capabilities:** The vulnerability can be triggered by any minter who owns an assembled NFT. Minters are common operational roles in the NFT ecosystem—they are explicitly added via the `AddMinters` method and often include the creator/assembler themselves. [12](#0-11) 

**Attack Complexity:** Extremely simple—requires a single transaction calling the public `Burn` method with the symbol and token ID of the assembled NFT.

**Feasibility Conditions:**
1. Protocol must be burnable (set during protocol creation via `IsBurnable` flag)
2. Caller must be in the minter list for that protocol
3. Caller must own the assembled NFT (balance ≥ 1)

These conditions are commonly met in normal operations. Many NFT protocols are designed as burnable, and assemblers are often minters themselves or can be added to the minter list.

**Detection:** The vulnerability could occur accidentally (user mistakenly calls `Burn` instead of `Disassemble`) or intentionally. Once executed, the locked FTs cannot be recovered through any contract mechanism.

**Probability:** MEDIUM to HIGH—while this may not be a deliberate attack vector, the ease of accidentally calling the wrong method, combined with no warning or protection mechanism in the contract, makes this a realistic scenario in production use.

## Recommendation

Add a check in the `Burn` method to prevent burning assembled NFTs:

```csharp
public override Empty Burn(BurnInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    
    // Add this check to prevent burning assembled NFTs
    Assert(State.AssembledFtsMap[tokenHash] == null && 
           State.AssembledNftsMap[tokenHash] == null,
           "Cannot burn assembled NFT directly. Use Disassemble method instead.");
    
    var nftInfo = GetNFTInfoByTokenHash(tokenHash);
    var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
    // ... rest of existing Burn logic
}
```

Alternatively, automatically trigger disassembly within the `Burn` method when assembled assets are detected, returning them to the burner.

## Proof of Concept

```csharp
[Fact]
public async Task BurnAssembledNFT_LocksTokensPermanently()
{
    // Setup: Create NFT protocol and approve FTs
    var symbol = await CreateTest(); // Creates burnable NFT protocol
    await AddMinterAsync(symbol);
    await TokenContractStub.Approve.SendAsync(new MultiToken.ApproveInput
    {
        Spender = NFTContractAddress,
        Symbol = "ELF",
        Amount = long.MaxValue
    });

    // Assemble NFT with 1000 ELF locked
    var assembledTokenHash = (await NFTContractStub.Assemble.SendAsync(new AssembleInput
    {
        Symbol = symbol,
        AssembledFts = new AssembledFts { Value = { ["ELF"] = 1000 } }
    })).Output;

    // Get initial balances
    var initialUserBalance = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = DefaultAddress, Symbol = "ELF" })).Balance;
    var initialContractBalance = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = NFTContractAddress, Symbol = "ELF" })).Balance;

    // Vulnerability: Burn assembled NFT directly (instead of using Disassemble)
    await NFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        TokenId = 2, // The assembled NFT token ID
        Amount = 1
    });

    // Verify locked FTs remain in contract
    var finalContractBalance = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = NFTContractAddress, Symbol = "ELF" })).Balance;
    
    finalContractBalance.ShouldBe(initialContractBalance); // 1000 ELF still locked
    
    // Verify Disassemble cannot recover the tokens (will fail with "No permission")
    var disassembleException = await Assert.ThrowsAsync<Exception>(async () =>
        await NFTContractStub.Disassemble.SendAsync(new DisassembleInput
        {
            Symbol = symbol,
            TokenId = 2
        }));
    
    disassembleException.Message.ShouldContain("No permission"); // Balance is 0
    
    // Result: 1000 ELF permanently locked in NFT contract with no recovery mechanism
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L113-189)
```csharp
    public override Hash Assemble(AssembleInput input)
    {
        if (input.Metadata != null && input.Metadata.Value.Any())
            AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var metadata = input.Metadata ?? new Metadata();

        if (input.AssembledNfts.Value.Any())
        {
            metadata.Value[AssembledNftsKey] = input.AssembledNfts.ToString();
            // Check owner.
            foreach (var pair in input.AssembledNfts.Value)
            {
                var nftHash = Hash.LoadFromHex(pair.Key);
                var nftInfo = GetNFTInfoByTokenHash(nftHash);
                Assert(State.BalanceMap[nftHash][Context.Sender] >= pair.Value,
                    $"Insufficient balance of {nftInfo.Symbol}{nftInfo.TokenId}.");
                DoTransfer(nftHash, Context.Sender, Context.Self, pair.Value);
            }
        }

        if (input.AssembledFts.Value.Any())
        {
            metadata.Value[AssembledFtsKey] = input.AssembledFts.ToString();
            // Check balance and allowance.
            foreach (var pair in input.AssembledFts.Value)
            {
                var symbol = pair.Key;
                var amount = pair.Value;
                var balance = State.TokenContract.GetBalance.Call(new MultiToken.GetBalanceInput
                {
                    Owner = Context.Sender,
                    Symbol = symbol
                }).Balance;
                Assert(balance >= amount, $"Insufficient balance of {symbol}");
                var allowance = State.TokenContract.GetAllowance.Call(new MultiToken.GetAllowanceInput
                {
                    Owner = Context.Sender,
                    Spender = Context.Self,
                    Symbol = symbol
                }).Allowance;
                Assert(allowance >= amount, $"Insufficient allowance of {symbol}");
                State.TokenContract.TransferFrom.Send(new MultiToken.TransferFromInput
                {
                    From = Context.Sender,
                    To = Context.Self,
                    Symbol = symbol,
                    Amount = amount
                });
            }
        }

        var mingInput = new MintInput
        {
            Symbol = input.Symbol,
            Alias = input.Alias,
            Owner = input.Owner,
            Uri = input.Uri,
            Metadata = metadata,
            TokenId = input.TokenId
        };

        var nftMinted = PerformMint(mingInput, true);
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;

        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;

        Context.Fire(new Assembled
        {
            Symbol = input.Symbol,
            TokenId = nftMinted.TokenId,
            AssembledNfts = input.AssembledNfts,
            AssembledFts = input.AssembledFts
        });

        return nftMinted.TokenHash;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-236)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }

        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
        }

        Context.Fire(new Disassembled
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            DisassembledNfts = assembledNfts ?? new AssembledNfts(),
            DisassembledFts = assembledFts ?? new AssembledFts()
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-353)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-33)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```
