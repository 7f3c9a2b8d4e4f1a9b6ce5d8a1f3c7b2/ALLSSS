# Audit Report

## Title
Continuous Blocks Validation Bypass via Negative RoundNumber in UpdateValue/TinyBlock Behaviors

## Summary
The `ContinuousBlocksValidationProvider` can be bypassed by providing a negative `RoundNumber` in consensus extra data. The validation check `ProvidedRound.RoundNumber > 2` evaluates to false for negative values, allowing miners to produce more consecutive blocks than the configured maximum threshold of 8 blocks, violating consensus fairness guarantees.

## Finding Description
The AEDPoS consensus mechanism enforces a fairness rule preventing any single miner from producing more than `MaximumTinyBlocksCount` (8) consecutive blocks. [1](#0-0)  This is tracked via `LatestPubkeyToTinyBlocksCount.BlocksCount`, which decrements each time the same miner produces consecutive blocks. [2](#0-1) 

The `ContinuousBlocksValidationProvider` enforces this limit by checking if `BlocksCount < 0`, which indicates excessive consecutive blocks. [3](#0-2)  However, this validation only executes when `ProvidedRound.RoundNumber > 2`. 

The `RoundNumber` field is defined as `int64` in the protobuf schema, [4](#0-3)  allowing negative values. The `ProvidedRound` is populated from block header extra data without validating that `RoundNumber` is positive. [5](#0-4) 

**Attack Scenario:**
1. Miner produces 8 consecutive blocks, causing `BlocksCount` to become negative
2. The consensus command logic would normally force the miner to produce a `NextRound` block [6](#0-5) 
3. Instead, the miner crafts a block with `UpdateValue` or `TinyBlock` behavior and sets `RoundNumber = -1` in the consensus extra data
4. During validation, the check `-1 > 2` evaluates to false, causing the entire continuous blocks validation to be skipped
5. The block passes validation despite exceeding the consecutive blocks limit

The vulnerability exists because no validation provider checks whether `ProvidedRound.RoundNumber` is positive or matches the actual current round number stored in state. The `RecoverFromUpdateValue` and `RecoverFromTinyBlock` methods do not validate or use the `RoundNumber` field. [7](#0-6) 

## Impact Explanation
This vulnerability violates the consensus fairness guarantee designed to prevent block production centralization. A malicious miner can:

1. Continue producing blocks beyond the 8-block limit without triggering validation failures
2. Dominate block production and centralize consensus power
3. Deny other miners their fair share of block production slots and associated rewards

However, the impact is LIMITED because:
- The attacker must be a validly elected miner with legitimate mining permissions
- Other critical validations remain enforced (mining permission, time slot validation)
- State integrity is maintained since actual round updates use `BaseRound` from state, not the malicious `ProvidedRound`
- No direct fund theft or total consensus break occurs

This is appropriately classified as **LOW severity** - it affects consensus fairness and decentralization rather than causing direct financial loss or complete consensus failure.

## Likelihood Explanation
The attack is practically exploitable with **moderate likelihood**:

**Required Capabilities:**
- Must be an authorized miner in the current miner list (validated by `MiningPermissionValidationProvider`) [8](#0-7) 
- Must be within assigned time slot (validated by `TimeSlotValidationProvider`) [9](#0-8) 
- Technical capability to craft custom block headers with modified protobuf consensus extra data

**Attack Complexity:**
- Low to moderate - requires modifying the `RoundNumber` field in the `AElfConsensusHeaderInformation` protobuf message
- No cryptographic challenges or complex preconditions beyond being a valid miner
- Protobuf serialization accepts arbitrary int64 values without type-level constraints

**Economic Rationality:**
- Elected miners have economic incentive to maximize block production and associated mining rewards
- The cost is minimal (just crafting modified headers)
- The benefit is increased block production share and rewards

## Recommendation
Add validation to ensure `ProvidedRound.RoundNumber` is positive and reasonable:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    // Validate RoundNumber is positive and not excessively different from current round
    if (validationContext.ProvidedRound.RoundNumber < 0 ||
        validationContext.ProvidedRound.RoundNumber > validationContext.BaseRound.RoundNumber + 1)
    {
        validationResult.Message = "Invalid round number in consensus extra data.";
        return validationResult;
    }

    if (validationContext.ProvidedRound.RoundNumber > 2 &&
        validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
    {
        var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
        if (latestPubkeyToTinyBlocksCount != null &&
            latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
            latestPubkeyToTinyBlocksCount.BlocksCount < 0)
        {
            validationResult.Message = "Sender produced too many continuous blocks.";
            return validationResult;
        }
    }

    validationResult.Success = true;
    return validationResult;
}
```

Alternatively, add a dedicated `RoundNumberValidationProvider` to validate that the provided round number matches expected values across all consensus behaviors.

## Proof of Concept
A test would demonstrate:
1. Set up a miner who has produced 8 consecutive blocks (`BlocksCount = -1`)
2. Craft a block with `UpdateValue` behavior and `RoundNumber = -1` in consensus extra data
3. Call `ValidateConsensusBeforeExecution` with this malicious extra data
4. Observe that validation passes despite the miner having exceeded the consecutive blocks limit
5. Verify that with a normal positive `RoundNumber`, the validation would fail as expected

The test would prove that the negative `RoundNumber` bypasses the continuous blocks validation check that should enforce the 8-block limit.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-357)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** protobuf/aedpos_contract.proto (L245-245)
```text
    int64 round_number = 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-47)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }

    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L24-30)
```csharp
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
```
