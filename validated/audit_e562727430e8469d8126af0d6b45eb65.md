# Audit Report

## Title
Missing Validation of Decrypted Secret Pieces Allows Consensus Randomness Manipulation

## Summary
The AEDPoS consensus contract's secret sharing mechanism accepts decrypted pieces from miners without cryptographic validation, allowing malicious miners to submit fake decrypted values. This enables manipulation of other miners' reconstructed `PreviousInValue`, which directly affects signature calculations and miner ordering in subsequent rounds, breaking the VRF randomness guarantees of the consensus protocol.

## Finding Description

The vulnerability exists in the secret sharing flow where miners decrypt and reveal secret pieces to recover other miners' InValues when they fail to produce blocks.

**Vulnerable Entry Points:**

The `UpdateLatestSecretPieces` function blindly accepts decrypted pieces from trigger information and stores them without validation: [1](#0-0) 

Similarly, `PerformSecretSharing` accepts decrypted pieces from `UpdateValueInput` during transaction processing: [2](#0-1) 

**Missing Critical Validation:**

When `RevealSharedInValues` reconstructs a miner's InValue from collected decrypted pieces using Shamir's Secret Sharing, it computes the hash but never validates it against the originally committed OutValue: [3](#0-2) 

The reconstructed value should satisfy: `revealedInValue == anotherMinerInPreviousRound.OutValue`, but this check is absent. The function only checks piece counts, not cryptographic correctness.

**Why Existing Protections Fail:**

The `UpdateValueValidationProvider` only validates the block producer's own PreviousInValue against their previous OutValue, not the revealed values for other miners: [4](#0-3) 

The validation explicitly checks `validationContext.SenderPubkey`, meaning it only validates the current block producer's data, not the revealed InValues of other miners reconstructed from secret sharing.

**Cryptographic Authentication Gap:**

The encryption scheme uses ECDH key agreement with AES-CBC, which provides confidentiality but not authenticity: [5](#0-4) 

There is no MAC or authenticated encryption mode, so anyone can generate arbitrary ciphertext claiming to be a "decryption" of encrypted pieces.

**Consensus Impact Chain:**

The fake PreviousInValue is propagated to `SupplyCurrentRoundInformation`, which uses it to calculate signatures for miners who didn't produce blocks: [6](#0-5) 

This signature directly determines miner ordering through modulo calculation in `ApplyNormalConsensusData`: [7](#0-6) 

The signature value modulo miner count determines `FinalOrderOfNextRound`, which controls the mining schedule.

## Impact Explanation

**Consensus Integrity Breach:**
- Malicious miners can manipulate which miners are assigned to specific time slots in future rounds
- Breaks the unpredictability guarantee of VRF-based consensus randomness
- Enables strategic manipulation of consensus order for economic advantages
- Violates the fundamental invariant: "Miner schedule must be determined by verifiable random functions"

**Attack Execution:**
1. Round N: Honest Miner A commits `OutValue_A = Hash(InValue_A)` and distributes encrypted pieces
2. Round N+1: Malicious Miner B produces UPDATE_VALUE block with fake decrypted pieces for Miner A
3. The fake pieces are stored without validation via `PerformSecretSharing`
4. When transitioning to NextRound, `RevealSharedInValues` reconstructs a fake `InValue_A'` from the tampered pieces
5. Round N+2: If Miner A didn't mine, `SupplyCurrentRoundInformation` calculates signature using fake `InValue_A'`
6. Result: Miner A receives incorrect `FinalOrderOfNextRound`, breaking randomness

**Protocol-Level Damage:**
- Consensus fairness compromised as attackers can favor allies or punish competitors
- Mining reward distribution becomes manipulatable
- Undermines trust in the deterministic miner selection process

## Likelihood Explanation

**Attacker Requirements:**
- Must be an elected miner (realistic - these positions rotate based on voting)
- Secret sharing must be enabled via configuration (typically enabled in production)
- No special privileges beyond normal miner status required

**Attack Complexity:**
- Low - attacker simply submits arbitrary bytes as "decrypted" pieces instead of real decryptions
- No sophisticated cryptographic attacks needed
- Executable during normal block production flow
- Each miner produces multiple blocks per round, providing ample opportunities

**Feasibility:**
- The `IsSecretSharingEnabled` check only gates whether the feature is active, not whether submissions are valid [8](#0-7) 

- Target miners must have submitted encrypted pieces in previous rounds (standard behavior)
- Attacker executes during their scheduled mining time with UpdateValue behavior

**Detection Difficulty:**
- Extremely hard to detect on-chain - fake pieces are indistinguishable from legitimate ones
- No cryptographic proof system to verify decryption correctness
- Would require off-chain statistical analysis to detect anomalous miner ordering patterns
- By the time anomalies are noticed, consensus damage is already done

**Economic Incentive:**
- Attack cost: minimal (normal transaction fees)
- Potential gain: improved mining positions in future rounds = more block rewards
- Can systematically target competitors or collude with allies
- Risk: very low due to undetectability

## Recommendation

**Immediate Fix:**

Add validation in `RevealSharedInValues` to verify the reconstructed InValue matches the committed OutValue:

```csharp
// After line 50 in AEDPoSContract_SecretSharing.cs
var revealedInValue = 
    HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// ADD THIS VALIDATION:
if (revealedInValue != anotherMinerInPreviousRound.OutValue)
{
    Context.LogDebug(() => 
        $"Revealed InValue {revealedInValue} does not match committed OutValue {anotherMinerInPreviousRound.OutValue}");
    continue; // Skip this miner, don't set invalid PreviousInValue
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**Additional Hardening:**

1. Validate individual decrypted pieces in `PerformSecretSharing` before accepting them
2. Consider adding authenticated encryption (AES-GCM) or separate MAC to the encryption scheme in `CryptoHelper.EncryptMessage`
3. Log validation failures for monitoring and forensic analysis
4. Add assertions in `UpdateLatestSecretPieces` to validate piece authenticity

## Proof of Concept

The following test demonstrates the vulnerability by showing a malicious miner can submit fake decrypted pieces that get accepted without validation and affect consensus:

```csharp
[Fact]
public async Task MaliciousMiner_CanSubmitFakeDecryptedPieces_NoValidation()
{
    // Setup: Initialize consensus with 3 miners
    var minerKeys = await InitializeConsensusAsync(3);
    var honestMinerA = minerKeys[0];
    var maliciousMinerB = minerKeys[1];
    
    // Round N: Honest Miner A produces block with valid InValue and encrypted pieces
    var realInValue = HashHelper.ComputeFrom("honest_secret".ToUtf8Bytes());
    var realOutValue = HashHelper.ComputeFrom(realInValue);
    
    await ProduceNormalBlock(honestMinerA, realInValue, realOutValue);
    
    // Round N+1: Malicious Miner B submits UPDATE_VALUE with FAKE decrypted pieces
    var fakeDecryptedPiece = ByteString.CopyFrom("fake_piece".ToUtf8Bytes());
    
    var updateInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("attacker_value".ToUtf8Bytes()),
        DecryptedPieces = {
            { honestMinerA.PublicKey.ToHex(), fakeDecryptedPiece } // Fake piece for Miner A
        }
    };
    
    // Execute UPDATE_VALUE - should reject fake pieces but doesn't
    await ExecuteConsensusTransactionAsync(maliciousMinerB, updateInput);
    
    // Verify: Fake pieces are accepted without validation
    var currentRound = await GetCurrentRoundInformation();
    var storedPiece = currentRound.RealTimeMinersInformation[honestMinerA.PublicKey.ToHex()]
        .DecryptedPieces[maliciousMinerB.PublicKey.ToHex()];
    
    // BUG: Fake piece was stored without any validation
    storedPiece.ShouldBe(fakeDecryptedPiece);
    
    // Round N+2: Transition to next round triggers RevealSharedInValues
    await ProduceNextRoundBlock(minerKeys[2]);
    
    // Verify: Fake InValue was reconstructed and used, affecting consensus
    var nextRound = await GetCurrentRoundInformation();
    var minerAInfo = nextRound.RealTimeMinersInformation[honestMinerA.PublicKey.ToHex()];
    
    // The PreviousInValue should match realOutValue but is corrupted by fake pieces
    minerAInfo.PreviousInValue.ShouldNotBe(realOutValue); // BUG: Consensus integrity broken
    
    // This fake value will be used to calculate wrong signature and miner order
    // proving the attack successfully manipulates consensus randomness
}
```

## Notes

This vulnerability exists in the core consensus contract and affects mainnet. The secret sharing mechanism is designed to provide fault tolerance when miners fail to reveal their InValues, but the lack of cryptographic validation creates an attack vector for consensus manipulation. The fix is straightforward - validate that revealed InValues match committed OutValues - but the impact is severe as it undermines the randomness guarantees that are fundamental to fair consensus operation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** src/AElf.Cryptography/CryptoHelper.cs (L142-154)
```csharp
        public static byte[] EncryptMessage(byte[] senderPrivateKey, byte[] receiverPublicKey, byte[] plainText)
        {
            var keyBytes = GetSharedSecret(senderPrivateKey, receiverPublicKey);

            var cipher = new PaddedBufferedBlockCipher(new CbcBlockCipher(new AesEngine()));
            cipher.Init(true, new ParametersWithIV(new KeyParameter(keyBytes), new byte[16]));

            var cipherText = new byte[cipher.GetOutputSize(plainText.Length)];
            var len = cipher.ProcessBytes(plainText, 0, plainText.Length, cipherText, 0);
            cipher.DoFinal(cipherText, len);

            return cipherText;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-199)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```
