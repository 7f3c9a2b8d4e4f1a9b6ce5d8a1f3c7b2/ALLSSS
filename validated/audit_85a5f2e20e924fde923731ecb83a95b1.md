# Audit Report

## Title
Duplicate Welcome Rewards via Pubkey Replacement During Non-Mining Periods

## Summary
A candidate can receive welcome rewards multiple times by replacing their public key while not actively mining. The AEDPoS contract's conditional notification to Treasury creates a state inconsistency where replacement pubkeys retain a `LatestMinedTerm` value of zero, causing them to be incorrectly identified as new miners eligible for welcome rewards.

## Finding Description

The vulnerability stems from a coordination failure between the Election, AEDPoS, and Treasury contracts during pubkey replacement operations.

When a candidate calls `ReplaceCandidatePubkey`, the Election contract only validates that the old pubkey is a current candidate or initial miner, without checking active mining status. [1](#0-0)  The validation function `IsCurrentCandidateOrInitialMiner` only checks candidate registration status, not mining activity. [2](#0-1) 

The Election contract then notifies the AEDPoS contract via `RecordCandidateReplacement`. [3](#0-2) 

However, the AEDPoS contract only forwards this notification to Treasury if the old pubkey is present in the current round's active miner list. If not found, it returns early without updating Treasury. [4](#0-3) 

The Treasury notification, when it occurs, transfers the `LatestMinedTerm` tracking from old to new pubkey. [5](#0-4) 

During reward distribution, Treasury's `Release` method identifies miners with `LatestMinedTerm == 0` (excluding initial miners) as new miners eligible for welcome rewards. [6](#0-5) 

These identified new miners receive welcome reward shares through `UpdateWelcomeRewardWeights`. [7](#0-6) 

The state variable `LatestMinedTerm` tracks mining history per pubkey. [8](#0-7) 

When a replacement occurs during a non-mining period, the new pubkey retains the default `LatestMinedTerm` value of zero. Upon future election, this pubkey is incorrectly treated as a first-time miner and receives duplicate welcome rewards.

## Impact Explanation

**Financial Impact**: The vulnerability enables unauthorized drainage of the welcome reward pool (`VotesWeightRewardHash` profit scheme). Each exploitation grants full welcome reward shares for an entire term, proportional to the `MinerRewardWeightSetting.WelcomeRewardWeight` allocation (default 25% of miner rewards, or 5% of total treasury distribution).

**Affected Parties**: 
- Legitimate first-time miners receive diluted welcome rewards as the fixed pool is divided among more beneficiaries
- The Treasury's economic model is violated, as welcome rewards are designed as one-time onboarding incentives
- Overall protocol fairness is compromised

**Severity Justification**: HIGH severity due to:
1. Direct misallocation of economic rewards from a fixed pool
2. Repeatability - single entity can exploit multiple times through successive replacements
3. Minimal cost - only transaction fees for pubkey replacement
4. No special privileges required beyond standard candidate admin rights

## Likelihood Explanation

**Attacker Requirements**:
- Registered candidate with candidate admin address
- Previous mining history (to establish legitimacy)
- Non-mining status during replacement (naturally occurs due to voting dynamics)
- Ability to be elected in future terms

**Attack Feasibility**: HIGH
- Elections cycle regularly (approximately 7-day terms)
- Candidates naturally rotate in/out of active miner sets based on voting
- Pubkey replacement is a legitimate security operation
- The attack is indistinguishable from normal key rotation
- No on-chain validation prevents this pattern

**Detection Difficulty**: The exploitation leaves minimal audit trail since replacement operations are normal and expected for security purposes. Multiple candidates could independently discover and exploit this vulnerability.

## Recommendation

Add unconditional `LatestMinedTerm` transfer in the Election contract when calling Treasury. Modify `ReplaceCandidatePubkey` to always notify Treasury of the replacement, regardless of current mining status:

```csharp
private void PerformReplacement(string oldPubkey, string newPubkey)
{
    // ... existing code ...
    
    // Always notify Treasury to transfer LatestMinedTerm tracking
    if (State.TreasuryContract.Value == null)
        State.TreasuryContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
    
    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = oldPubkey,
        NewPubkey = newPubkey,
        CurrentTermNumber = State.AEDPoSContract.GetCurrentTermNumber.Call(new Empty()).Value,
        IsOldPubkeyEvil = false
    });
    
    // ... rest of existing code ...
}
```

Alternatively, modify the AEDPoS contract to always forward replacement notifications to Treasury, removing the conditional check.

## Proof of Concept

```csharp
[Fact]
public async Task DuplicateWelcomeReward_ViaReplacementDuringNonMining_Test()
{
    // Setup: Candidate announces election and gets elected in Term 1
    var candidateKeyPair = ValidationDataCenterKeyPairs.First();
    var adminKeyPair = ValidationDataCenterKeyPairs.Last();
    await AnnounceElectionAsync(candidateKeyPair, Address.FromPublicKey(adminKeyPair.PublicKey));
    
    // Vote and proceed to term 2 where candidate is elected and mines
    await VoteToCandidate(candidateKeyPair.PublicKey.ToHex(), 100_000, 100);
    await MineBlocksToNextTermAsync(1);
    
    // Verify candidate mined in term 2 (LatestMinedTerm should be 2)
    var latestMinedTerm = await TreasuryStub.GetLatestMinedTerm.CallAsync(
        new StringValue { Value = candidateKeyPair.PublicKey.ToHex() });
    latestMinedTerm.Value.ShouldBe(2);
    
    // Proceed to term 3 where candidate is NOT elected (not in active miner set)
    await MineBlocksToNextTermAsync(2);
    var currentMiners = await ConsensusStub.GetCurrentMinerList.CallAsync(new Empty());
    currentMiners.Pubkeys.Select(p => p.ToHex()).ShouldNotContain(candidateKeyPair.PublicKey.ToHex());
    
    // Replace pubkey while NOT mining
    var newKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
    var adminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, adminKeyPair);
    await adminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = candidateKeyPair.PublicKey.ToHex(),
        NewPubkey = newKeyPair.PublicKey.ToHex()
    });
    
    // Verify new pubkey has LatestMinedTerm = 0 (vulnerability)
    var newLatestMinedTerm = await TreasuryStub.GetLatestMinedTerm.CallAsync(
        new StringValue { Value = newKeyPair.PublicKey.ToHex() });
    newLatestMinedTerm.Value.ShouldBe(0); // Should be 2, but is 0 - VULNERABILITY
    
    // Get new pubkey elected in term 4
    await VoteToCandidate(newKeyPair.PublicKey.ToHex(), 200_000, 100);
    await MineBlocksToNextTermAsync(3);
    
    // Verify new pubkey is treated as "new miner" and receives welcome rewards
    var welcomeScheme = await ProfitStub.GetScheme.CallAsync(
        await TreasuryStub.GetWelcomeRewardSchemeId.CallAsync(new Empty()));
    var beneficiaries = await ProfitStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = welcomeScheme.SchemeId,
        Beneficiary = Address.FromPublicKey(newKeyPair.PublicKey)
    });
    
    // New pubkey receives welcome rewards despite entity having already mined
    beneficiaries.Details.Count.ShouldBeGreaterThan(0); // EXPLOIT CONFIRMED
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-176)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L75-82)
```csharp
    private bool IsCurrentCandidateOrInitialMiner(string pubkey)
    {
        var isCurrentCandidate = State.CandidateInformationMap[pubkey] != null &&
                                 State.CandidateInformationMap[pubkey].IsCurrentCandidate;
        var isInitialMiner = State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey)));
        return isCurrentCandidate || isInitialMiner;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L123-166)
```csharp
    public override Empty Release(ReleaseInput input)
    {
        RequireAEDPoSContractStateSet();
        Assert(
            Context.Sender == State.AEDPoSContract.Value,
            "Only AElf Consensus Contract can release profits from Treasury.");
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.TreasuryHash.Value,
            Period = input.PeriodNumber,
            AmountsMap = { State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L) }
        });
        RequireElectionContractStateSet();
        var previousTermInformation = State.AEDPoSContract.GetPreviousTermInformation.Call(new Int64Value
        {
            Value = input.PeriodNumber
        });

        var currentMinerList = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(p => p.ToHex()).ToList();
        var maybeNewElectedMiners = new List<string>();
        maybeNewElectedMiners.AddRange(currentMinerList);
        maybeNewElectedMiners.AddRange(previousTermInformation.RealTimeMinersInformation.Keys);
        var replaceCandidates = State.ReplaceCandidateMap[input.PeriodNumber];
        if (replaceCandidates != null)
        {
            Context.LogDebug(() =>
                $"New miners from replace candidate map: {replaceCandidates.Value.Aggregate((l, r) => $"{l}\n{r}")}");
            maybeNewElectedMiners.AddRange(replaceCandidates.Value);
            State.ReplaceCandidateMap.Remove(input.PeriodNumber);
        }

        maybeNewElectedMiners = maybeNewElectedMiners
            .Where(p => State.LatestMinedTerm[p] == 0 && !GetInitialMinerList().Contains(p)).ToList();
        if (maybeNewElectedMiners.Any())
            Context.LogDebug(() => $"New elected miners: {maybeNewElectedMiners.Aggregate((l, r) => $"{l}\n{r}")}");
        else
            Context.LogDebug(() => "No new elected miner.");

        UpdateStateBeforeDistribution(previousTermInformation, maybeNewElectedMiners);
        ReleaseTreasurySubProfitItems(input.PeriodNumber);
        UpdateStateAfterDistribution(previousTermInformation, currentMinerList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L573-599)
```csharp
    public override Empty RecordMinerReplacement(RecordMinerReplacementInput input)
    {
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only AEDPoS Contract can record miner replacement.");

        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        if (!input.IsOldPubkeyEvil)
        {
            var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
            State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
            State.LatestMinedTerm.Remove(input.OldPubkey);
        }
        else
        {
            var replaceCandidates = State.ReplaceCandidateMap[input.CurrentTermNumber] ?? new StringList();
            replaceCandidates.Value.Add(input.NewPubkey);
            State.ReplaceCandidateMap[input.CurrentTermNumber] = replaceCandidates;
        }

        State.IsReplacedEvilMiner[input.NewPubkey] = true;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L848-891)
```csharp
    private void UpdateWelcomeRewardWeights(Round previousTermInformation, List<string> newElectedMiners)
    {
        var previousMinerAddresses =
            GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
        var possibleWelcomeBeneficiaries = new RemoveBeneficiariesInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            Beneficiaries = { previousMinerAddresses }
        };
        State.ProfitContract.RemoveBeneficiaries.Send(possibleWelcomeBeneficiaries);
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            SubSchemeId = State.BasicRewardHash.Value
        });

        if (newElectedMiners.Any())
        {
            Context.LogDebug(() => "Welcome reward will go to new miners.");
            var newBeneficiaries = new AddBeneficiariesInput
            {
                SchemeId = State.VotesWeightRewardHash.Value,
                EndPeriod = previousTermInformation.TermNumber.Add(1)
            };
            foreach (var minerAddress in newElectedMiners.Select(GetProfitsReceiver))
                newBeneficiaries.BeneficiaryShares.Add(new BeneficiaryShare
                {
                    Beneficiary = minerAddress,
                    Shares = 1
                });

            if (newBeneficiaries.BeneficiaryShares.Any()) State.ProfitContract.AddBeneficiaries.Send(newBeneficiaries);
        }
        else
        {
            Context.LogDebug(() => "Welcome reward will go to Basic Reward.");
            State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
            {
                SchemeId = State.VotesWeightRewardHash.Value,
                SubSchemeId = State.BasicRewardHash.Value,
                SubSchemeShares = 1
            });
        }
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContractState.cs (L45-48)
```csharp
    /// <summary>
    ///     Pubkey -> Latest Mined Term Number.
    /// </summary>
    public MappedState<string, long> LatestMinedTerm { get; set; }
```
