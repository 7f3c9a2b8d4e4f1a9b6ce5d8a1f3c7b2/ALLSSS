# Audit Report

## Title
NextRound Validation Fails to Verify Miner Participation Against Trusted State

## Summary
The `NextRoundMiningOrderValidationProvider` performs only internal consistency checks on the untrusted `ProvidedRound` without comparing it against the trusted `BaseRound` from StateDb. This allows a malicious miner producing a NextRound block to manipulate the next round's miner schedule by arbitrarily including or excluding miners, violating the consensus rule that participation determines next-round eligibility.

## Finding Description

The validation logic contains a critical flaw in how it verifies NextRound block data. The validator only examines the `ProvidedRound` (untrusted data from the block header) and never compares it against `BaseRound` (trusted state). [1](#0-0) 

The validation checks whether the count of miners with `FinalOrderOfNextRound > 0` equals the count with `OutValue != null` **within the ProvidedRound itself**. However, when NextRound is legitimately generated, these fields are NOT populated in the new round: [2](#0-1) 

The new round only sets `Order`, `Pubkey`, `ExpectedMiningTime`, etc., leaving `FinalOrderOfNextRound` and `OutValue` at their default values (0 and null). This means the validation effectively checks `0 == 0`, which always passes regardless of the actual miner list.

**Critical difference from other behaviors**: UpdateValue and TinyBlock behaviors call recovery methods to populate BaseRound with provided data BEFORE validation: [3](#0-2) 

But NextRound has no such recovery step: [4](#0-3) 

The validation context provides both `BaseRound` and `ProvidedRound`: [5](#0-4) 

But the validator uses only `ProvidedRound`, ignoring `BaseRound` entirely.

**What should be validated**: The code comment explicitly states the intended invariant: [6](#0-5) 

The validation should verify that:
1. Miners in `ProvidedRound` match those who actually participated in `BaseRound` (identified by `GetMinedMiners()` which checks `SupposedOrderOfNextRound != 0`)
2. Their `Order` values in `ProvidedRound` correspond to their `FinalOrderOfNextRound` from `BaseRound` [7](#0-6) 

After the ineffective validation passes, the malicious round is directly stored: [8](#0-7) 

## Impact Explanation

**HIGH Severity** - This vulnerability breaks a critical consensus invariant:

1. **Consensus Integrity Violation**: A malicious extra block producer can manipulate who mines in the next round, directly violating the documented rule that "miners that mined blocks during current round" should determine next round participation.

2. **Reward Manipulation**: 
   - Legitimate miners who participated in the current round can be excluded from the next round, losing one round of block rewards
   - Non-participating miners or miners who missed their slots can be improperly included, receiving undeserved rewards
   - The mining order can be manipulated to favor specific miners for extra block producer assignment

3. **Decentralization Impact**: Excluding legitimate miners reduces network decentralization and undermines the fairness of the consensus mechanism.

4. **All Miners Affected**: Any miner can be victimized when a malicious miner gains the extra block producer role, affecting the entire validator set.

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability is easily exploitable:

1. **Attacker Profile**: Any miner in the network can exploit this when they gain the extra block producer role, which rotates deterministically based on the first miner's signature in each round. [9](#0-8) 

2. **Attack Complexity**: LOW
   - Wait for turn as extra block producer
   - Craft `NextRoundInput` with arbitrary miner list and orders
   - The validation (0 == 0 check) automatically passes
   - Malicious round is stored and becomes authoritative

3. **No Special Preconditions**: Only requires being a miner in the current validator set - no additional privileges or timing requirements beyond the normal consensus rotation.

4. **Detection Difficulty**: The manipulated round structure appears valid with all fields properly populated, making it indistinguishable from legitimate rounds without explicit comparison against expected state.

5. **Frequent Opportunity**: Every NextRound transition (end of each round) provides an opportunity, and all miners eventually rotate into the extra block producer role.

## Recommendation

Implement proper validation that compares `ProvidedRound` against `BaseRound`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound;
    var providedRound = validationContext.ProvidedRound;
    
    // Get miners who actually participated in current round
    var minedMiners = baseRound.GetMinedMiners();
    
    // Verify provided round contains exactly these miners
    if (providedRound.RealTimeMinersInformation.Count != minedMiners.Count)
    {
        validationResult.Message = "Next round miner count doesn't match participating miners.";
        return validationResult;
    }
    
    // Verify each miner's order corresponds to their FinalOrderOfNextRound from base round
    foreach (var minedMiner in minedMiners)
    {
        if (!providedRound.RealTimeMinersInformation.ContainsKey(minedMiner.Pubkey))
        {
            validationResult.Message = $"Participating miner {minedMiner.Pubkey} missing from next round.";
            return validationResult;
        }
        
        var expectedOrder = minedMiner.FinalOrderOfNextRound;
        var actualOrder = providedRound.RealTimeMinersInformation[minedMiner.Pubkey].Order;
        
        if (expectedOrder != actualOrder)
        {
            validationResult.Message = $"Invalid order for miner {minedMiner.Pubkey}.";
            return validationResult;
        }
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task MaliciousNextRound_CanManipulateMinerSchedule()
{
    // Setup: 5 miners in current round, 3 participated, 2 didn't
    var currentRound = CreateRound(5);
    currentRound.RealTimeMinersInformation["miner1"].OutValue = Hash.FromString("out1");
    currentRound.RealTimeMinersInformation["miner1"].FinalOrderOfNextRound = 1;
    currentRound.RealTimeMinersInformation["miner2"].OutValue = Hash.FromString("out2");
    currentRound.RealTimeMinersInformation["miner2"].FinalOrderOfNextRound = 2;
    currentRound.RealTimeMinersInformation["miner3"].OutValue = Hash.FromString("out3");
    currentRound.RealTimeMinersInformation["miner3"].FinalOrderOfNextRound = 3;
    // miner4 and miner5 didn't participate (no OutValue, FinalOrderOfNextRound = 0)
    
    // Malicious NextRound: Include non-participant miner4, exclude participant miner2
    var maliciousNextRound = new Round
    {
        RoundNumber = currentRound.RoundNumber + 1,
        RealTimeMinersInformation =
        {
            ["miner1"] = new MinerInRound { Pubkey = "miner1", Order = 1 },
            ["miner3"] = new MinerInRound { Pubkey = "miner3", Order = 2 },
            ["miner4"] = new MinerInRound { Pubkey = "miner4", Order = 3 } // Non-participant!
            // miner2 excluded despite participating!
        }
    };
    
    // Create validation context
    var context = new ConsensusValidationContext
    {
        BaseRound = currentRound,
        ProvidedRound = maliciousNextRound,
        ExtraData = new AElfConsensusHeaderInformation 
        { 
            Behaviour = AElfConsensusBehaviour.NextRound,
            Round = maliciousNextRound
        }
    };
    
    // Execute validation
    var validator = new NextRoundMiningOrderValidationProvider();
    var result = validator.ValidateHeaderInformation(context);
    
    // Vulnerability: Validation passes even though:
    // - miner4 didn't participate but is included
    // - miner2 participated but is excluded
    Assert.True(result.Success); // This should FAIL but passes due to the bug
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L13-27)
```csharp
    /// <summary>
    ///     We can trust this because we already validated the pubkey
    ///     during `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`
    /// </summary>
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();

    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```
