# Audit Report

## Title
Consensus Failure via Malformed Signature in NextRound Transition

## Summary
A malicious authorized miner can permanently halt the AEDPoS consensus mechanism by submitting a `NextRoundInput` containing signatures with insufficient byte length (< 8 bytes). This bypasses validation during the NextRound transaction but causes an unhandled exception when subsequent miners attempt to generate the next round, preventing all future block production.

## Finding Description

The vulnerability exists in the consensus round generation logic where signature byte length validation is missing from the NextRound validation pipeline.

**Root Cause:** The `CalculateNextExtraBlockProducerOrder()` method validates signature existence but not byte length before converting to Int64: [1](#0-0) 

The null check at line 113 passes when a Hash object exists, even if its underlying ByteString has fewer than 8 bytes. The subsequent `signature.ToInt64()` call chains through the Hash type implementation: [2](#0-1) 

Which invokes `ByteExtensions.ToInt64()` that directly calls `BitConverter.ToInt64()` without length validation: [3](#0-2) 

The .NET `BitConverter.ToInt64()` method requires exactly 8 bytes and throws `ArgumentException` when provided with a shorter array, crashing the consensus data generation process.

**Validation Gap:** For NextRound behavior, only `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` are applied: [4](#0-3) 

The `NextRoundMiningOrderValidationProvider` only validates mining order counts, not signature integrity: [5](#0-4) 

The `RoundTerminateValidationProvider` only validates round number increments and InValue nullness: [6](#0-5) 

Neither validator checks signature byte length, creating a validation bypass.

**Attack Execution:**

1. An authorized miner calls `NextRound()` with a malformed `NextRoundInput`: [7](#0-6) 

2. The input passes validation, gets converted to a Round object via `ToRound()`, and is persisted to state via `AddRoundInformation()` at line 156: [8](#0-7) 

3. When the next miner attempts to generate consensus data for transitioning to the subsequent round, `GetConsensusExtraDataForNextRound` is invoked: [9](#0-8) 

4. This calls the contract wrapper `GenerateNextRoundInformation`: [10](#0-9) 

5. At line 345, it invokes the Round extension method `GenerateNextRoundInformation`, which at line 59 calls `CalculateNextExtraBlockProducerOrder()` on the poisoned round, triggering the exception and preventing block generation.

## Impact Explanation

**Critical Consensus Halt:** Once a round with malformed signatures is persisted to state, all subsequent attempts to generate NextRound consensus data fail with an unhandled exception. The consensus mechanism becomes permanently inoperable because:

- Miners cannot generate valid consensus transactions for round transitions
- Block production halts completely at the poisoned round
- No recovery mechanism exists to purge or correct the malformed state
- The entire blockchain network loses liveness

**Affected Stakeholders:**
- All block producers unable to fulfill their mining duties
- All network participants whose transactions cannot be processed
- The entire blockchain ecosystem which becomes frozen

This represents a complete denial-of-service against the blockchain's consensus layer with permanent impact.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an authorized miner in the current or previous round's miner list
- Miner status is obtained through the election process, making this a permissioned but achievable role

**Attack Complexity:** LOW
- Simply construct a `NextRoundInput` with `MinerInRound.Signature` fields set to Hash objects with `Value.Length < 8`
- Submit via a single NextRound transaction
- No timing windows, cryptographic operations, or complex state manipulation required

**Detection:** The attack manifests immediately when the next miner attempts NextRound generation, but by that point the malformed data is irreversibly committed to state.

**Overall Likelihood:** MEDIUM - While requiring miner privileges, the attack is trivial to execute and has no preconditions beyond authorization. A single compromised or malicious miner can unilaterally halt the entire network.

## Recommendation

Add signature byte length validation to the NextRound validation pipeline:

1. Create a new validation provider or extend `NextRoundMiningOrderValidationProvider` to validate that all non-null signatures in `MinerInRound` objects have exactly 32 bytes (standard Hash length) or at minimum 8 bytes for Int64 conversion
2. Add this validator to the NextRound validation chain in `ValidateBeforeExecution`
3. Alternatively, add defensive byte length checks in `CalculateNextExtraBlockProducerOrder()` before calling `ToInt64()`, returning a default value for malformed signatures

The fix should validate that `signature.Value.Length >= 8` for any signature that will be converted to Int64, rejecting the transaction if this condition is not met.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Create a NextRoundInput with valid structure but MinerInRound signatures set to `new Hash { Value = ByteString.CopyFrom(new byte[4]) }` (4 bytes instead of 8)
2. Call NextRound with an authorized miner context
3. Observe successful transaction execution and state persistence
4. Attempt to call GenerateConsensusTransactions for NextRound behavior
5. Observe ArgumentException from BitConverter.ToInt64 with message "Destination array is not long enough"
6. Confirm consensus is halted as no miner can generate valid NextRound transactions

## Notes

This vulnerability exploits the gap between the validation providers used for different consensus behaviors. While `UpdateValueValidationProvider` checks that signatures are non-empty, it only verifies at least one byte exists (`Value.Any()`), not that 8 bytes are present for Int64 conversion. The NextRound behavior's validators completely omit signature validation, creating an exploitable inconsistency in the validation framework.

The permanent nature of this DoS stems from the fact that the poisoned round becomes part of the immutable consensus state, and all future round generation attempts read from and process this corrupted data, triggering the same exception repeatedly with no recovery path.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** src/AElf.Types/Types/Hash.cs (L105-108)
```csharp
        public long ToInt64()
        {
            return ToByteArray().ToInt64(true);
        }
```

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L53-57)
```csharp
        public static long ToInt64(this byte[] bytes, bool bigEndian)
        {
            var needReverse = !bigEndian ^ BitConverter.IsLittleEndian;
            return BitConverter.ToInt64(needReverse ? bytes.Reverse().ToArray() : bytes, 0);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L285-347)
```csharp
    private void GenerateNextRoundInformation(Round currentRound, Timestamp currentBlockTime, out Round nextRound)
    {
        TryToGetPreviousRoundInformation(out var previousRound);
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();
        var isMinerListChanged = false;
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }

        currentRound.GenerateNextRoundInformation(currentBlockTime, blockchainStartTimestamp, out nextRound,
            isMinerListChanged);
    }
```
