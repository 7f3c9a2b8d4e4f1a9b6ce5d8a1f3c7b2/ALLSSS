# Audit Report

## Title
Insufficient Validation of PreviousInValue for Non-Sender Miners Allows Consensus State Corruption

## Summary
The AEDPoS consensus contract validates `PreviousInValue` only for the block producer (sender), but not for other miners whose values are included in the block header. A malicious miner can inject arbitrary `PreviousInValue` values for other miners through the `revealed_in_values` field in trigger information, corrupting consensus state and violating the VRF commit-reveal invariant that `Hash(PreviousInValue) == OutValue_previous_round`.

## Finding Description

The vulnerability exists across the consensus data flow where `PreviousInValue` for all miners is propagated without comprehensive validation.

**Injection Point:** In `UpdateLatestSecretPieces()`, a miner can set arbitrary `PreviousInValue` for other miners via the `revealed_in_values` field from trigger information. [1](#0-0)  The condition only checks if the target miner's `PreviousInValue` is currently empty, which is common for miners who haven't produced blocks yet in the current round.

**Propagation to Block Header:** The injected values are copied into the simplified round that goes into the block header. [2](#0-1) 

**Recovery Without Validation:** During validation, ALL miners' `PreviousInValue` are copied from the block header to the base round. [3](#0-2) 

**Validation Gap:** The validation provider only validates the sender's `PreviousInValue`. [4](#0-3)  Line 38 explicitly limits validation to `publicKey = validationContext.SenderPubkey`, leaving other miners' values unverified.

**Additional Injection via Transaction Input:** During execution, `PerformSecretSharing()` directly sets `PreviousInValue` from the transaction input without validation. [5](#0-4) 

**Usage of Corrupted Values:** The corrupted `PreviousInValue` is later used to calculate signatures for miners who didn't produce blocks. [6](#0-5)  If the `PreviousInValue` is corrupted, the calculated signature will be wrong, violating the VRF invariant.

## Impact Explanation

**Consensus Integrity Violation:** The vulnerability breaks the fundamental VRF (Verifiable Random Function) invariant that `Hash(PreviousInValue) == OutValue_previous_round`. A malicious miner can inject `PreviousInValue` values that do NOT hash to the corresponding miner's `OutValue` from the previous round.

**Concrete Harm:**

1. **Signature Corruption**: For miners who miss their time slots, the incorrect `PreviousInValue` is used to calculate their signature through `previousRound.CalculateSignature(previousInValue)`. [7](#0-6)  The signature calculation aggregates all miners' signatures, so corruption propagates.

2. **Secret Sharing Compromise**: The incorrect values propagate through the secret sharing mechanism via `MinersPreviousInValues` which collects all miners' `PreviousInValue`. [8](#0-7) 

3. **State Persistence**: The corrupted values become part of persistent consensus state, affecting subsequent round calculations and miner ordering.

**Affected Parties:** All network participants relying on consensus integrity, miners whose `PreviousInValue` is corrupted, and the random number generation mechanism used for block production schedules.

## Likelihood Explanation

**Attacker Capabilities:**
- Any active miner in the current round can exploit this vulnerability
- No special privileges required beyond normal block production rights
- Attack is launched by providing malicious trigger information to their own consensus node

**Attack Complexity:**
LOW - The attacker simply provides malicious `revealed_in_values` in their `AElfConsensusTriggerInformation`. [9](#0-8)  The trigger information is generated by the miner's own node and can be modified before being passed to the contract.

**Feasibility Conditions:**
- Target miner must have `PreviousInValue == Hash.Empty || PreviousInValue == null` (miners who haven't produced blocks yet in current round)
- Secret sharing must be enabled, which is checked via `IsSecretSharingEnabled()`. [10](#0-9) 

**Detection Constraints:**
- No validation prevents this attack
- Corrupted values appear legitimate in block headers
- Only detectable through forensic analysis comparing `PreviousInValue` hashes with previous round's `OutValue`

**Probability: HIGH** - The attack is straightforward, requires no sophisticated techniques, and bypasses all existing validations.

## Recommendation

Add comprehensive validation for ALL miners' `PreviousInValue` values in the `UpdateValueValidationProvider`, not just the sender's. Specifically:

1. In `UpdateValueValidationProvider.ValidateHeaderInformation()`, iterate through ALL miners in the provided round and validate each miner's `PreviousInValue` against their previous round's `OutValue`.

2. Add validation in `PerformSecretSharing()` before setting `PreviousInValue` to ensure the provided values match the hash of the previous round's `OutValue`.

3. Consider removing the ability to set other miners' `PreviousInValue` via trigger information, and only allow the legitimate secret sharing recovery mechanism.

## Proof of Concept

A malicious miner can execute the following attack:

1. Monitor the current round to identify miners with empty `PreviousInValue` (new miners or those who missed recent slots)
2. Modify their node's `SecretSharingService.GetRevealedInValues()` to return arbitrary hash values for target miners
3. Produce a block with this malicious trigger information
4. The contract accepts these values without validation via `UpdateLatestSecretPieces()`
5. Values propagate to block header and persist in consensus state
6. When target miners miss their slots, `SupplyCurrentRoundInformation()` uses the corrupted values to calculate incorrect signatures
7. The corrupted signatures affect random number generation and subsequent mining order

The attack succeeds because `UpdateValueValidationProvider` only validates the sender's `PreviousInValue`, allowing arbitrary values for other miners to bypass all security checks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L51-51)
```csharp
                    PreviousInValue = information.Value.PreviousInValue
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L28-29)
```csharp
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L38-38)
```csharp
        var publicKey = validationContext.SenderPubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L296-296)
```csharp
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L112-114)
```csharp
            var revealedInValues = _secretSharingService.GetRevealedInValues(hint.RoundId);
            foreach (var revealedInValue in revealedInValues)
                trigger.RevealedInValues.Add(revealedInValue.Key, revealedInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```
