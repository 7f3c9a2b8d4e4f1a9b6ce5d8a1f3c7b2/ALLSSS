# Audit Report

## Title 
Token Issuer Modification Never Persisted to Storage - Old Issuer Retains All Privileges

## Summary
The `ModifyTokenIssuerAndOwner()` function in the MultiToken contract modifies the token issuer and owner fields in a local memory copy but fails to persist these changes to contract storage. This renders the entire token ownership transfer mechanism completely non-functional - the old issuer retains 100% of issuing privileges while the new issuer gains none.

## Finding Description

The vulnerability exists in the `ModifyTokenIssuerAndOwner()` function which retrieves `tokenInfo` from storage, modifies the `Issuer` and `Owner` fields, but critically fails to persist the changes back to storage. [1](#0-0) 

The function modifies `tokenInfo.Issuer` and `tokenInfo.Owner` in memory but never calls `SetTokenInfo()` to persist these changes. The contract uses a `MappedState<string, TokenInfo>` storage pattern where all modifications must be explicitly persisted via the `SetTokenInfo()` helper method. [2](#0-1) 

**Evidence from Correct Implementations:**

All other functions that modify `tokenInfo` correctly call `SetTokenInfo()`:

1. The `Issue()` function modifies supply fields and correctly persists changes: [3](#0-2) 

2. The `CrossChainReceiveToken()` function modifies supply and correctly persists: [4](#0-3) 

3. The `SetSymbolAlias()` function modifies external info and correctly persists: [5](#0-4) 

**Why Authorization Checks Fail:**

When `Issue()` is called, it validates the caller against the issuer stored in persistent storage: [3](#0-2) 

Since `ModifyTokenIssuerAndOwner()` never updates storage, the authorization check at line 160 continues to pass for the old issuer and fails for the new issuer, completely breaking the intended ownership transfer.

The `GetTokenInfo()` helper retrieves from persistent storage: [6](#0-5) 

## Impact Explanation

**Direct Authorization Impact:**
- The token issuer modification function is completely non-functional despite appearing to succeed
- Old issuer retains 100% of token issuance privileges indefinitely 
- New issuer receives 0% privileges despite successful transaction execution
- Token creators cannot transfer control to new addresses, DAOs, or governance structures as intended

**Operational Impact:**
- Breaks the entire token ownership transfer mechanism
- Creates dangerous false sense of security - function executes without error but has no effect
- Users believe they have transferred issuer rights when they have not
- Violates critical protocol invariant for token authorization and governance control

**Who Is Affected:**
- All token creators attempting to use `ModifyTokenIssuerAndOwner()`
- Projects relying on transferring token control to DAOs or new addresses
- Any governance structure expecting issuer changes to be effective
- Token migration scenarios requiring issuer updates

## Likelihood Explanation

**Trigger Conditions:**
- Function is publicly callable by any current token issuer
- No special permissions or state required beyond being the current issuer
- No external dependencies or timing constraints

**Reproducibility:**
- 100% certain - every single execution fails to persist changes
- No attacker action required - this is a functional bug affecting all legitimate users
- Zero complexity - bug triggers automatically on every call

**Feasibility:**
The existing test suite validates only error cases and never verifies functional correctness: [7](#0-6) 

The tests check validation logic but never verify that issuer modifications actually persist and work, which is why this critical bug went undetected.

## Recommendation

Add the missing `SetTokenInfo()` call to persist the changes:

```csharp
public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
{
    Assert(!State.TokenIssuerAndOwnerModificationDisabled.Value, "Set token issuer and owner disabled.");
    Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
    Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
    Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");

    var tokenInfo = GetTokenInfo(input.Symbol);

    Assert(tokenInfo != null, "Token is not found.");
    Assert(tokenInfo.Issuer == Context.Sender, "Only token issuer can set token issuer and owner.");
    Assert(tokenInfo.Owner == null, "Can only set token which does not have owner.");
    
    tokenInfo.Issuer = input.Issuer;
    tokenInfo.Owner = input.Owner;
    
    // ADD THIS LINE:
    SetTokenInfo(tokenInfo);

    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ModifyTokenIssuerAndOwner_DoesNotPersist_Vulnerability()
{
    // Create a token with DefaultAddress as issuer
    await CreateAndIssueMultiTokensAsync();
    var symbol = AliceCoinTokenInfo.Symbol;
    
    // Verify DefaultAddress can issue initially
    var issueResult = await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = symbol,
        Amount = 1000,
        To = DefaultAddress
    });
    issueResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Enable the modification feature via Parliament
    var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    var proposalId = await CreateProposalAsync(TokenContractAddress, defaultParliament, 
        nameof(TokenContractStub.SetTokenIssuerAndOwnerModificationEnabled),
        new SetTokenIssuerAndOwnerModificationEnabledInput { Enabled = true });
    await ApproveWithMinersAsync(proposalId);
    await ParliamentContractStub.Release.SendAsync(proposalId);
    
    // Modify issuer to User1Address
    var modifyResult = await TokenContractStub.ModifyTokenIssuerAndOwner.SendAsync(new ModifyTokenIssuerAndOwnerInput
    {
        Symbol = symbol,
        Issuer = User1Address,
        Owner = User1Address
    });
    modifyResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // BUG: Old issuer (DefaultAddress) can still issue tokens
    var oldIssuerCanStillIssue = await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = symbol,
        Amount = 1000,
        To = DefaultAddress
    });
    oldIssuerCanStillIssue.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // SHOULD FAIL BUT PASSES
    
    // BUG: New issuer (User1Address) CANNOT issue tokens
    var newIssuerCannotIssue = await TokenContractStubUser1.Issue.SendWithExceptionAsync(new IssueInput
    {
        Symbol = symbol,
        Amount = 1000,
        To = User1Address
    });
    newIssuerCannotIssue.TransactionResult.Error.ShouldContain("Sender is not allowed to issue"); // SHOULD PASS BUT FAILS
    
    // Verify storage was never updated
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = symbol });
    tokenInfo.Issuer.ShouldBe(DefaultAddress); // Still old issuer!
    tokenInfo.Owner.ShouldBe(DefaultAddress); // Still old owner!
}
```

This test demonstrates that after calling `ModifyTokenIssuerAndOwner()`, the old issuer retains all privileges while the new issuer gains none, proving the vulnerability.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-178)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(input.To, input.Symbol, input.Amount);

        Context.Fire(new Issued
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = input.To,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L591-638)
```csharp
    public override Empty CrossChainReceiveToken(CrossChainReceiveTokenInput input)
    {
        var transferTransaction = Transaction.Parser.ParseFrom(input.TransferTransactionBytes);
        var transferTransactionId = transferTransaction.GetHash();

        Assert(!State.VerifiedCrossChainTransferTransaction[transferTransactionId],
            "Token already claimed.");

        var crossChainTransferInput =
            CrossChainTransferInput.Parser.ParseFrom(transferTransaction.Params.ToByteArray());
        var symbol = crossChainTransferInput.Symbol;
        var amount = crossChainTransferInput.Amount;
        var receivingAddress = crossChainTransferInput.To;
        var targetChainId = crossChainTransferInput.ToChainId;
        var transferSender = transferTransaction.From;

        var tokenInfo = AssertValidToken(symbol, amount);
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
        Assert(targetChainId == Context.ChainId, "Unable to claim cross chain token.");
        var registeredTokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        AssertCrossChainTransaction(transferTransaction, registeredTokenContractAddress,
            nameof(CrossChainTransfer));
        Context.LogDebug(() =>
            $"symbol == {tokenInfo.Symbol}, amount == {amount}, receivingAddress == {receivingAddress}, targetChainId == {targetChainId}");

        CrossChainVerify(transferTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);

        State.VerifiedCrossChainTransferTransaction[transferTransactionId] = true;
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(receivingAddress, tokenInfo.Symbol, amount);

        Context.Fire(new CrossChainReceived
        {
            From = transferSender,
            To = receivingAddress,
            Symbol = tokenInfo.Symbol,
            Amount = amount,
            Memo = crossChainTransferInput.Memo,
            FromChainId = input.FromChainId,
            ParentChainHeight = input.ParentChainHeight,
            IssueChainId = issueChainId,
            TransferTransactionId = transferTransactionId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L642-659)
```csharp
    public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
    {
        Assert(!State.TokenIssuerAndOwnerModificationDisabled.Value, "Set token issuer and owner disabled.");
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
        Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");

        var tokenInfo = GetTokenInfo(input.Symbol);

        Assert(tokenInfo != null, "Token is not found.");
        Assert(tokenInfo.Issuer == Context.Sender, "Only token issuer can set token issuer and owner.");
        Assert(tokenInfo.Owner == null, "Can only set token which does not have owner.");
        
        tokenInfo.Issuer = input.Issuer;
        tokenInfo.Owner = input.Owner;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L738-779)
```csharp
    public override Empty SetSymbolAlias(SetSymbolAliasInput input)
    {
        // Alias setting can only work for NFT Item for now.
        // And the setting exists on the TokenInfo of the NFT Collection.

        // Can only happen on Main Chain.
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "Symbol alias setting only works on MainChain.");

        var collectionSymbol = GetNftCollectionSymbol(input.Symbol, true);

        // For now, token alias can only be set once.
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");

        CheckTokenAlias(input.Alias, collectionSymbol);

        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");

        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);

        State.SymbolAliasMap[input.Alias] = input.Symbol;

        Context.LogDebug(() => $"Token alias added: {input.Symbol} -> {input.Alias}");

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = input.Symbol,
            Alias = input.Alias
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L418-422)
```csharp
    private void SetTokenInfo(TokenInfo tokenInfo)
    {
        var symbol = tokenInfo.Symbol;
        State.TokenInfos[symbol] = tokenInfo;
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L1826-1900)
```csharp
    [Fact]
    public async Task TokenIssuerAndOwnerModification_Test()
    {
        var result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput());
        result.TransactionResult.Error.ShouldContain("Invalid input symbol.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = "TEST"
        });
        result.TransactionResult.Error.ShouldContain("Invalid input issuer.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = "TEST",
            Issuer = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Invalid input owner.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = "TEST",
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Token is not found.");
        
        result = await TokenContractStubUser.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = DefaultSymbol,
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Only token issuer can set token issuer and owner.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = DefaultSymbol,
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Can only set token which does not have owner.");
        
        var output = await TokenContractStub.GetTokenIssuerAndOwnerModificationEnabled.CallAsync(new Empty());
        output.Value.ShouldBeTrue();
        
        result = await TokenContractStub.SetTokenIssuerAndOwnerModificationEnabled.SendWithExceptionAsync(
            new SetTokenIssuerAndOwnerModificationEnabledInput
            {
                Enabled = false
            });
        result.TransactionResult.Error.ShouldContain("Unauthorized behavior.");
        
        var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
        var proposalId = await CreateProposalAsync(TokenContractAddress,
            defaultParliament, nameof(TokenContractStub.SetTokenIssuerAndOwnerModificationEnabled),
            new SetTokenIssuerAndOwnerModificationEnabledInput
            {
                Enabled = false
            });
        await ApproveWithMinersAsync(proposalId);
        await ParliamentContractStub.Release.SendAsync(proposalId);
        
        output = await TokenContractStub.GetTokenIssuerAndOwnerModificationEnabled.CallAsync(new Empty());
        output.Value.ShouldBeFalse();
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = DefaultSymbol,
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Set token issuer and owner disabled.");

    }
```
