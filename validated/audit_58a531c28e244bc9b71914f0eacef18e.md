# Audit Report

## Title
Duplicate Initial Miners Can Cause Consensus DoS During Term Transition

## Summary
The AEDPoS consensus contract's `GenerateFirstRoundOfNewTerm` method lacks duplicate public key filtering before calling `ToDictionary`, causing an `ArgumentException` when duplicate initial miners exist. This results in complete consensus failure during term transitions when the Election contract falls back to using unvalidated initial miners.

## Finding Description

The vulnerability exists across three critical locations in the production contract code:

**1. Missing Deduplication in Round Generation:**

The contract version of `GenerateFirstRoundOfNewTerm` directly converts miner public keys to a dictionary without duplicate removal [1](#0-0) , whereas the kernel extension version includes `.Distinct()` for safety [2](#0-1) .

**2. No Validation During Initialization:**

The Election contract's `InitialElectionContract` method accepts the initial miner list without any duplicate validation [3](#0-2) , allowing duplicates to persist in `State.InitialMiners.Value`.

**3. Duplicate Preservation in Fallback Path:**

When valid candidates are insufficient, the `GetVictories` method's fallback logic adds initial miners to the backups list [4](#0-3) . The filter `Where(k => !backups.Contains(k))` only prevents duplicates **between** the backups list and initial miners, but does NOT deduplicate **within** the initial miners list itself. If `State.InitialMiners.Value` contains `[A, A, B]`, both A entries pass the filter when backups doesn't already contain A, because the Where clause is evaluated once before AddRange executes, not incrementally.

**Execution Flow:**

During term transitions, `GetConsensusExtraDataForNextTerm` [5](#0-4)  calls `GenerateFirstRoundOfNextTerm` [6](#0-5) , which retrieves victories via `TryToGetVictories` [7](#0-6) . The Election contract returns the potentially duplicated miner list [8](#0-7) , which is then passed to `victories.GenerateFirstRoundOfNewTerm()`, triggering the `ArgumentException` on the unprotected `ToDictionary` call.

## Impact Explanation

**Critical Consensus DoS:**
- When duplicate public keys exist in the miner list, the `ToDictionary` operation throws `ArgumentException` with message "An item with the same key has already been added"
- Term generation fails completely, preventing consensus from advancing to the next term
- The blockchain enters a halted state as no new blocks can be produced after the current term expires
- All network participants are affected simultaneously - validators cannot mine, transactions cannot be processed
- No automatic recovery mechanism exists in the protocol
- Requires emergency governance intervention or chain fork to resolve

**Severity: High** - This is a complete availability attack on the entire blockchain network, breaking the fundamental consensus liveness guarantee.

## Likelihood Explanation

**Feasible Attack Scenario:**

**Precondition Setup:**
1. During chain initialization (genesis), a malicious or incompetent operator provides a miner list containing duplicates to `InitialElectionContract`
2. No validation prevents this, so `State.InitialMiners.Value` permanently stores duplicates
3. This persists silently in contract state

**Natural Trigger:**
1. Term transition time arrives (every ~7 days by default)
2. Valid election candidates are fewer than required miners count (common in early chain stages or low participation)
3. `GetVictories` executes fallback path that adds initial miners
4. Duplicates from initial miners propagate to victories list
5. `GenerateFirstRoundOfNewTerm` calls `ToDictionary` with duplicates
6. **Consensus halts**

**Likelihood: Medium to High**
- **Low attack complexity**: Only requires incorrect initialization data (no special runtime privileges needed)
- **Realistic precondition**: Configuration errors are common during genesis setup; accidental duplicates possible
- **Natural trigger**: Low candidate participation is plausible, especially on new chains or during low activity periods
- **Difficult detection**: Issue remains dormant until the specific trigger conditions align
- **No economic cost**: If duplicates injected at genesis, attacker needs no ongoing access

## Recommendation

Apply `.Distinct()` to deduplicate miner lists before `ToDictionary` operations, matching the kernel extension implementation:

In `contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs`, modify line 16-17 to:
```csharp
var sortedMiners =
    (from obj in Pubkeys.Distinct()
            .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
```

Additionally, add validation in `InitialElectionContract` to reject duplicate initial miners:
```csharp
var distinctMiners = input.MinerList.Distinct().ToList();
Assert(distinctMiners.Count == input.MinerList.Count, "Duplicate initial miners not allowed.");
```

## Proof of Concept

```csharp
[Fact]
public async Task DuplicateInitialMiners_Should_Cause_Consensus_DoS()
{
    // Setup: Initialize election contract with duplicate initial miners
    var duplicateMinerList = new List<string> 
    { 
        InitialCoreDataCenterKeyPairs[0].PublicKey.ToHex(),
        InitialCoreDataCenterKeyPairs[0].PublicKey.ToHex(), // Duplicate
        InitialCoreDataCenterKeyPairs[1].PublicKey.ToHex()
    };
    
    var input = new InitialElectionContractInput
    {
        MinerList = { duplicateMinerList },
        MinersCount = 3,
        MinimumLockTime = 7 * 86400,
        MaximumLockTime = 1095 * 86400,
        TimeEachTerm = 604800
    };
    
    // This should succeed (no validation)
    await ElectionContractStub.InitialElectionContract.SendAsync(input);
    
    // Trigger: Simulate low candidate scenario during term transition
    // Set MinersCount higher than valid candidates to trigger fallback
    await ElectionContractStub.UpdateMinersCount.SendAsync(
        new UpdateMinersCountInput { MinersCount = 10 });
    
    // Attempt term transition - this will throw ArgumentException
    var exception = await Assert.ThrowsAsync<Exception>(() => 
        AEDPoSContractStub.GetConsensusExtraDataForNextTerm.CallAsync(
            new BytesValue()));
    
    Assert.Contains("An item with the same key has already been added", 
        exception.Message);
}
```

## Notes

The discrepancy between the contract implementation (no `.Distinct()`) and the kernel extension implementation (has `.Distinct()`) suggests this was an oversight during development. The kernel extension likely encountered this issue in testing and added the fix, but the contract code was never updated to match. This creates a critical vulnerability in production chains where genesis misconfiguration can lead to permanent consensus failure.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Extensions/MinerListExtensions.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in miners.Pubkeys.Distinct()
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L34-38)
```csharp
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-76)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-209)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-232)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L274-280)
```csharp
        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
```
