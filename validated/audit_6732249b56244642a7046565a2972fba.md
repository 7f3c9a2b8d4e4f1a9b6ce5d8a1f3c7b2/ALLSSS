# Audit Report

## Title
Missing Consensus Behaviour Validation Allows Miners to Force Incorrect Round Transitions

## Summary
The AEDPoS consensus contract accepts miner-provided consensus behaviour values without validating they match the correct behaviour for the current consensus state. This allows malicious miners to force premature round transitions (NextRound instead of UpdateValue) or incorrect term changes (NextTerm instead of NextRound), disrupting consensus integrity and triggering unintended economic events.

## Finding Description

The vulnerability exists in the consensus behaviour validation flow where the contract accepts and processes behaviour values without verifying their correctness.

The `GetConsensusBlockExtraData()` function receives a behaviour value from caller-provided trigger information and directly switches on it to determine which consensus logic to execute [1](#0-0) . The input is passed through `GetConsensusExtraData()` without any validation [2](#0-1) .

The correct behaviour should be determined by `ConsensusBehaviourProviderBase.GetConsensusBehaviour()` which calculates the expected behaviour based on round state, miner status, time slots, and consensus parameters [3](#0-2) . However, the validation in `ValidateBeforeExecution()` never recalculates the expected behaviour to compare against the provided one [4](#0-3) .

The `RoundTerminateValidationProvider` only validates structural correctness for NextRound/NextTerm behaviours (round number increments by 1, InValues are null) but never validates WHETHER a round termination should occur at this point [5](#0-4) .

**Attack Scenario:**
1. Malicious miner queries `GetConsensusCommand()` which correctly returns UpdateValue behaviour
2. Miner constructs custom `AElfConsensusTriggerInformation` with NextRound behaviour instead
3. Miner calls `GetConsensusExtraData()` with this manipulated trigger information
4. Contract generates NextRound consensus data (round number +1, null InValues)
5. Miner produces block with this NextRound consensus information
6. Block validation passes all structural checks (mining permission, time slot, round number increment)
7. NextRound transaction executes, prematurely terminating the round [6](#0-5) 
8. Other miners who should have produced blocks in the current round are skipped

## Impact Explanation

**HIGH Impact** - This vulnerability breaks fundamental consensus guarantees:

1. **Consensus Integrity**: Allows arbitrary manipulation of round transitions, violating the consensus state machine that determines when rounds should end based on miner participation and timing.

2. **Miner Participation Bypass**: Premature round transitions skip legitimate miners who haven't produced their blocks, disrupting fair block production rotation.

3. **Economic Impact**: Incorrect term transitions trigger premature treasury releases and election snapshots [7](#0-6) , affecting reward distribution timing and the economic model.

4. **LIB Calculation Disruption**: Incorrect round data affects Last Irreversible Block height calculations, potentially compromising finality guarantees required for cross-chain operations.

5. **Protocol-Wide Impact**: Since consensus integrity is fundamental to blockchain operations, this affects all protocol functions including token transfers, contract execution, and governance.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood**:

**Attacker Capabilities**: Any miner in the current miner list can execute this attack. Miners are expected participants obtainable through the election mechanism.

**Attack Complexity**: LOW - The attacker only needs to:
- Observe the correct behaviour via `GetConsensusCommand()`
- Construct trigger information with a different behaviour value
- Generate structurally valid data (e.g., round number +1, null InValues for NextRound)
- Produce the block during their time slot

**Feasibility**: The attack requires no special permissions beyond normal mining rights. It passes all existing validations because they only check structural correctness, not semantic correctness of the behaviour choice.

**Detection**: The attack is not immediately obvious as all validation checks pass. Detection requires off-chain comparison of expected versus actual behaviour.

## Recommendation

Add behaviour validation in `ValidateBeforeExecution()` that recalculates the expected behaviour and compares it to the provided behaviour:

```csharp
// In ValidateBeforeExecution, before processing validation providers
var expectedBehaviour = IsMainChain
    ? new MainChainConsensusBehaviourProvider(baseRound, extraData.SenderPubkey.ToHex(),
            GetMaximumBlocksCount(), Context.CurrentBlockTime, 
            GetBlockchainStartTimestamp(), State.PeriodSeconds.Value)
        .GetConsensusBehaviour()
    : new SideChainConsensusBehaviourProvider(baseRound, extraData.SenderPubkey.ToHex(),
            GetMaximumBlocksCount(), Context.CurrentBlockTime)
        .GetConsensusBehaviour();

if (expectedBehaviour != extraData.Behaviour)
{
    return new ValidationResult 
    { 
        Success = false, 
        Message = $"Incorrect consensus behaviour. Expected {expectedBehaviour}, got {extraData.Behaviour}." 
    };
}
```

This ensures the provided behaviour matches what the consensus logic would determine for the current state.

## Proof of Concept

A complete proof of concept would require:
1. Test chain with multiple miners
2. Miner node modified to construct custom trigger information
3. Block production with manipulated NextRound behaviour during UpdateValue time
4. Verification that block passes validation and prematurely ends the round

The vulnerability is confirmed through code analysis showing the missing validation check. The validation providers check mining permission, time slots, and structural correctness but never validate whether the chosen behaviour is semantically correct for the current consensus state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L26-48)
```csharp
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-104)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }

        var service = new HeaderInformationValidationService(validationProviders);

        Context.LogDebug(() => $"Validating behaviour: {extraData.Behaviour.ToString()}");

        var validationResult = service.ValidateInformation(validationContext);

        if (validationResult.Success == false)
            Context.LogDebug(() => $"Consensus Validation before execution failed : {validationResult.Message}");

        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-218)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```
