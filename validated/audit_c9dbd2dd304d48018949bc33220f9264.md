# Audit Report

## Title
Missing LIB Height Validation in NextTerm Allows Malicious Miner to Corrupt Blockchain Finality

## Summary
The `NextTerm` consensus operation lacks validation of the `ConfirmedIrreversibleBlockHeight` (LIB) field, allowing a malicious miner to inject arbitrary LIB values during term transitions. This corrupts the blockchain's finality tracking mechanism and propagates to all subsequent rounds.

## Finding Description

The AEDPoS consensus contract exhibits an asymmetric validation pattern between `NextTerm` and `UpdateValue` operations that creates a critical security gap.

**Missing Validation in NextTerm:**
When `NextTerm` is invoked, it delegates to `ProcessConsensusInformation` which performs only basic permission checks. [1](#0-0)  The permission check (`PreCheck`) merely verifies the sender is a current or previous miner, without validating any data fields. [2](#0-1) 

For `NextTerm` behavior, the validation system registers only `RoundTerminateValidationProvider`. [3](#0-2)  This provider validates only term and round number progression, completely ignoring LIB fields. [4](#0-3) 

**Contrasting Protection in UpdateValue:**
`UpdateValue` operations properly register `LibInformationValidationProvider` alongside other validators. [5](#0-4)  This provider enforces that LIB values cannot decrease. [6](#0-5) 

**Unvalidated Data Propagation:**
The `NextTermInput.ToRound()` method performs direct field copying without any validation logic. [7](#0-6)  The resulting Round object is immediately persisted to state via `AddRoundInformation`. [8](#0-7) [9](#0-8) 

**Attack Execution:**
A malicious miner generating a term transition block can query the legitimate consensus data generation method [10](#0-9)  then modify the `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields before including the transaction in their block. The modified values bypass validation and corrupt state.

**Propagation Mechanism:**
The malicious LIB value persists across round transitions since `GenerateNextRoundInformation` directly copies LIB fields from the current round. [11](#0-10)  Furthermore, the `UpdateValue` operation only increases LIB when calculated values exceed stored values, [12](#0-11)  meaning an artificially high LIB persists indefinitely.

## Impact Explanation

The Last Irreversible Block height is the cornerstone of blockchain finality guarantees. Its corruption has cascading security consequences:

**Premature Finality:** Setting LIB higher than legitimate values marks insufficiently confirmed blocks as irreversible, violating the 2/3+ miner consensus requirement. This could finalize fraudulent transactions, enable irreversible cross-chain message commitments before proper validation, and create permanent chain state corruption.

**Finality Regression:** Setting LIB lower than legitimate values exposes previously finalized blocks to reorganization attacks, enabling double-spend attacks on confirmed transactions and reverting cross-chain commitments that external systems considered permanent.

**Persistent Corruption:** The malicious LIB propagates through the round generation mechanism, corrupting all subsequent consensus rounds in that term and potentially affecting future terms until manually detected and corrected through extraordinary measures.

## Likelihood Explanation

**Attacker Prerequisites:** The attacker must be an active miner in the current or previous round to pass the `PreCheck()` authorization. [2](#0-1)  This is a standard operational privilege in AEDPoS consensus.

**Attack Simplicity:** The exploitation path requires minimal sophistication: obtain legitimate consensus data, modify two integer fields, submit during term transition. No timing windows, race conditions, or complex state manipulation needed.

**Execution Feasibility:** Any single malicious miner can execute this unilaterally during their assigned term transition block without requiring collusion or coordination with other miners.

**Detection Difficulty:** The malicious transaction appears structurally valid to all validation logic, passing all registered validators. Detection requires manual monitoring of LIB progression patterns or investigation of unexpected finality-dependent behavior.

## Recommendation

Add `LibInformationValidationProvider` to the validation providers for `NextTerm` behavior in the `ValidateBeforeExecution` method:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

This ensures LIB validation symmetry across all consensus operations and prevents arbitrary LIB manipulation during term transitions.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Deploying the AEDPoS consensus contract
2. Establishing a running consensus with multiple miners
3. During a term transition, having a malicious miner call `GetConsensusExtraDataForNextTerm` to obtain legitimate data
4. Modifying the `ConfirmedIrreversibleBlockHeight` field to an arbitrary value (e.g., current height + 1000)
5. Submitting the `NextTerm` transaction with the modified input
6. Observing that the transaction succeeds and the corrupted LIB is persisted to state
7. Verifying that subsequent `GenerateNextRoundInformation` calls propagate the corrupted value

The test would validate that `State.Rounds[termNumber].ConfirmedIrreversibleBlockHeight` contains the attacker-controlled value rather than the legitimate calculated value.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-43)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();

        Context.LogDebug(() => $"Processing {callerMethodName}");

        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");

        State.RoundBeforeLatestExecution.Value = GetCurrentRoundInformation(new Empty());

        ByteString randomNumber = null;

        // The only difference.
        switch (input)
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```
