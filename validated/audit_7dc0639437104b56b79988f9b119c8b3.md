# Audit Report

## Title
Secret Sharing Revealed In Values Lost Due to Missing State Persistence in NextRound Flow

## Summary
The `RevealSharedInValues` function computes revealed in values from secret shares to recover previous in values of miners who failed to mine. However, these revealed values are computed on a local copy of `currentRound` that is never persisted to contract state. When `SupplyCurrentRoundInformation` later attempts to read these revealed values from state during NextRound execution, they are absent, causing the secret sharing recovery mechanism to fail completely.

## Finding Description

The vulnerability exists in the NextRound consensus flow where secret sharing recovery is supposed to reveal in values for miners who didn't mine. The issue occurs across two phases:

**Off-Chain Phase (Block Generation):**
When `GetConsensusExtraDataForNextRound` is called to generate consensus header data, it first creates `nextRound` from `currentRound` via `GenerateNextRoundInformation`. [1](#0-0)  This function only copies basic fields (Pubkey, Order, ExpectedMiningTime, ProducedBlocks, MissedTimeSlots) and does not copy PreviousInValue. [2](#0-1) 

After creating `nextRound`, the code calls `RevealSharedInValues(currentRound, pubkey)` which uses secret sharing to decode in values and sets them in `currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue`. [3](#0-2) [4](#0-3) 

The function then returns `nextRound` (which doesn't contain the revealed values), and the modified `currentRound` is discarded without any call to persist it. [5](#0-4) 

**On-Chain Phase (Block Execution):**
When the NextRound transaction executes, it first calls `SupplyCurrentRoundInformation()` to fill in missing data for miners who didn't mine. [6](#0-5) 

This function attempts to read `currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue`, with a comment explicitly stating this should contain "previous in value recovered by other miners". [7](#0-6) 

Since the revealed values were never persisted, this field is null, forcing the system to fall back to the previous round's InValue or generate a deterministic fake value based on the miner's pubkey. [8](#0-7) 

## Impact Explanation

This vulnerability completely breaks the secret sharing mechanism, which is a critical security feature of AEDPoS consensus. Secret sharing is designed to prevent miners from withholding their in values, which would break the random beacon and allow manipulation of consensus outcomes.

When secret sharing fails, the system falls back to using deterministic values computed from the miner's public key (`HashHelper.ComputeFrom(miner)`), which are predictable and undermine the random beacon's security properties. This allows malicious miners to successfully withhold in values without consequence, as the recovery mechanism silently fails.

The impact is high severity because it:
- Completely negates a critical security mechanism
- Allows consensus manipulation by enabling in value withholding
- Degrades the random beacon to predictable outputs
- Occurs silently without any error indication

## Likelihood Explanation

This is not an attack - it's a logic bug that occurs automatically during normal operation. No attacker action is required.

The issue is guaranteed to occur every time NextRound is triggered when secret sharing is enabled, which is a regular consensus operation that happens at every round transition. The issue is silent - no errors are thrown, so the system appears to function normally while the secret sharing recovery mechanism silently fails.

The likelihood is HIGH because:
- Triggers automatically during normal consensus operations
- No special conditions or attacker actions needed
- Happens at every NextRound when secret sharing is enabled
- Silent failure makes it difficult to detect

## Recommendation

The fix requires ensuring that revealed in values are either:

1. **Option 1**: Apply revealed values to `nextRound` instead of `currentRound`, or call `RevealSharedInValues` after `GenerateNextRoundInformation` and pass it `nextRound` to modify.

2. **Option 2**: Persist the modified `currentRound` by calling `TryToUpdateRoundInformation(currentRound)` after `RevealSharedInValues` returns, before returning from `GetConsensusExtraDataForNextRound`.

3. **Option 3**: Ensure `GenerateNextRoundInformation` copies the `PreviousInValue` field from currentRound miners, though this would require calling `RevealSharedInValues` before `GenerateNextRoundInformation`.

4. **Option 4**: Use the `RevealedInValues` from the trigger information (which are computed off-chain by SecretSharingService) instead of computing them on-chain, similar to how UpdateValue behavior handles them via `UpdateLatestSecretPieces`. [9](#0-8) 

## Proof of Concept

This vulnerability manifests in the production code flow. To observe it:

1. Enable secret sharing in the consensus configuration
2. Have some miners fail to mine during a round (OutValue remains null)
3. When the extra block producer triggers NextRound, the off-chain `GetConsensusExtraDataForNextRound` will compute revealed values in `RevealSharedInValues` but discard them
4. When the on-chain NextRound transaction executes, `SupplyCurrentRoundInformation` will find null PreviousInValue fields and fall back to fake deterministic values
5. Verify that line 189's comment expectation is violated - the PreviousInValue that should contain "previous in value recovered by other miners" is always null

The bug is in the production contract code and affects the live consensus mechanism whenever secret sharing is enabled and miners fail to mine.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-176)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L198-203)
```csharp
        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L52-52)
```csharp
            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L189-191)
```csharp
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L192-210)
```csharp
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }
```
