# Audit Report

## Title
Stale Beneficiaries in Treasury Reward Schemes Due to Profits Receiver Address Desynchronization

## Summary
When a miner changes their custom profits receiver address via `SetProfitsReceiver`, the Treasury contract fails to remove the old receiver from BasicReward, WelcomeReward, and FlexibleReward schemes due to an address resolution mismatch between beneficiary addition and removal operations. This creates permanent stale beneficiaries who continue receiving mining rewards indefinitely, resulting in ongoing fund misallocation.

## Finding Description

The vulnerability exists in the Treasury contract's beneficiary management system across three critical reward update functions. The root cause is an address resolution mismatch between adding and removing beneficiaries.

**Root Cause - Address Resolution Mismatch:**

When adding beneficiaries, the code uses `GetProfitsReceiver` which returns the custom receiver if set in the map, otherwise defaults to the pubkey's address: [1](#0-0) 

However, when removing beneficiaries, the code uses `GetAddressesFromCandidatePubkeys` which returns BOTH the default address derived from the pubkey AND the CURRENT profits receiver from the map: [2](#0-1) 

**Affected Functions:**

1. `UpdateBasicMinerRewardWeights` removes beneficiaries using `GetAddressesFromCandidatePubkeys`: [3](#0-2) 

But adds beneficiaries using `GetProfitsReceiver`: [4](#0-3) 

2. `UpdateWelcomeRewardWeights` follows the same flawed pattern for removal: [5](#0-4) 

And addition: [6](#0-5) 

3. `UpdateFlexibleRewardWeights` uses the same removal logic: [7](#0-6) 

**Why Protections Fail:**

The Profit contract's `RemoveBeneficiary` function returns `Empty` silently when the beneficiary's profit details don't exist in the scheme: [8](#0-7) 

Additionally, `SetProfitsReceiver` in the Treasury contract only updates the Election contract's BackupSubsidy scheme: [9](#0-8) 

The Election contract's handler only manages its own BackupSubsidy beneficiaries (via `State.SubsidyHash.Value`), not the Treasury's BasicReward/WelcomeReward/FlexibleReward schemes: [10](#0-9) [11](#0-10) 

**Execution Path:**

1. **Term N**: Miner with pubkey PK sets custom receiver to CustomAddr1 via `SetProfitsReceiver` (permission checked at line 608-609) [12](#0-11) 

2. During term distribution, `UpdateBasicMinerRewardWeights` adds CustomAddr1 as beneficiary

3. **Between Terms**: Miner calls `SetProfitsReceiver` again, changing receiver to CustomAddr2, which updates the map at line 620

4. **Term N+2**: During distribution via `Release` (called by consensus contract), `UpdateStateBeforeDistribution` is invoked: [13](#0-12) 

5. `GetAddressesFromCandidatePubkeys` now returns `[DefaultAddr, CustomAddr2]` (current receiver)

6. Removal attempts for both addresses fail silently because CustomAddr1 (the actual beneficiary) is not in the removal list

7. CustomAddr2 is then added as new beneficiary

8. **Result**: Both CustomAddr1 and CustomAddr2 are now beneficiaries, with CustomAddr1 persisting indefinitely

## Impact Explanation

**Direct Fund Loss:**
- Stale beneficiaries continue accumulating profit shares in BasicReward, WelcomeReward, and FlexibleReward schemes without limit
- Mining rewards are substantial (approximately 1,250,000,000 ELF per term based on block production as documented in the contract) [14](#0-13) 
- BasicReward receives approximately 40% of miner rewards based on default weight settings (weight 2 out of total 4) [15](#0-14) 

**Affected Parties:**
1. Old receiver addresses receive rewards they shouldn't (potentially compromised or malicious addresses)
2. New legitimate receivers never get full rewards as shares are diluted
3. Protocol economic model integrity is violated

**Severity - HIGH:**
- Permanent fund misallocation with no cleanup mechanism
- Affects multiple critical reward schemes simultaneously (BasicReward, WelcomeReward, FlexibleReward)
- Accumulates over time with each receiver change
- Cannot be easily detected without manual scheme audits

## Likelihood Explanation

**Attacker Requirements:**
- Must be a candidate admin (standard role for any candidate, not a privileged system role)
- Can call `SetProfitsReceiver` as verified by permission check at lines 608-609

**Exploitation Complexity - LOW:**
1. Become a candidate and get elected as miner (normal operation)
2. Set custom receiver CustomAddr1 to receive rewards
3. Mine for at least one term to become beneficiary in Treasury schemes
4. Change receiver to CustomAddr2 via `SetProfitsReceiver`
5. CustomAddr1 automatically becomes stale beneficiary
6. Both addresses receive rewards in subsequent distributions

**Feasibility - HIGH:**
- Requires only standard candidate admin permissions
- No suspicious transactions needed - all operations are legitimate
- Trigger is automatic during term transitions called by consensus contract: [16](#0-15) 
- Even non-malicious receiver changes trigger the vulnerability (e.g., security key rotation, address migration)

**Detection Difficulty:**
- Historical profit receiver mappings are not stored in contract state
- No alerts or events for beneficiary count mismatches
- Legitimate use case (changing profit receiver) makes exploitation indistinguishable from normal operation

## Recommendation

The Treasury contract should synchronize beneficiary management across all reward schemes when profits receivers are updated. Implement one of the following fixes:

**Option 1: Unified Beneficiary Update (Recommended)**
Modify `SetProfitsReceiver` to directly update Treasury scheme beneficiaries instead of only calling the Election contract. Store the previous receiver for each pubkey and use it for removal:

```csharp
public override Empty SetProfitsReceiver(SetProfitsReceiverInput input)
{
    // ... existing validation ...
    
    var previousProfitsReceiver = State.ProfitsReceiverMap[input.Pubkey];
    var oldReceiver = previousProfitsReceiver ?? 
        Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey));
    
    if (input.ProfitsReceiverAddress == oldReceiver)
    {
        return new Empty();
    }
    
    State.ProfitsReceiverMap[input.Pubkey] = input.ProfitsReceiverAddress;
    
    // Update Treasury schemes if miner is currently a beneficiary
    UpdateTreasurySchemeBeneficiaries(input.Pubkey, oldReceiver, input.ProfitsReceiverAddress);
    
    // Update Election's BackupSubsidy
    State.ElectionContract.SetProfitsReceiver.Send(new AElf.Contracts.Election.SetProfitsReceiverInput
    {
        CandidatePubkey = input.Pubkey,
        ReceiverAddress = input.ProfitsReceiverAddress,
        PreviousReceiverAddress = oldReceiver
    });

    return new Empty();
}

private void UpdateTreasurySchemeBeneficiaries(string pubkey, Address oldReceiver, Address newReceiver)
{
    // Check if currently in any scheme and update
    var schemes = new[] { State.BasicRewardHash.Value, State.VotesWeightRewardHash.Value, State.ReElectionRewardHash.Value };
    foreach (var schemeId in schemes)
    {
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = schemeId,
            Beneficiary = oldReceiver
        });
        
        if (profitDetails != null && profitDetails.Details.Any())
        {
            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = schemeId,
                Beneficiary = oldReceiver
            });
            
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = schemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = newReceiver,
                    Shares = profitDetails.Details.First().Shares
                }
            });
        }
    }
}
```

**Option 2: Fix Address Resolution**
Modify `GetAddressesFromCandidatePubkeys` to only return the actual beneficiary addresses that were added (consistent with `GetProfitsReceiver`), not both default and current receiver.

**Option 3: Track Historical Receivers**
Store historical receiver mappings and use them during removal operations to ensure all previously added receivers are properly removed.

## Proof of Concept

Due to the read-only nature of my access to the codebase, I cannot create a runnable test. However, the vulnerability can be proven with the following test scenario:

```csharp
[Fact]
public async Task StaleBeneficiary_WhenProfitsReceiverChanged_Test()
{
    // 1. Setup: Miner becomes candidate with CustomAddr1 as receiver
    var minerKeyPair = MinerKeyPairs.First();
    var customAddr1 = ValidationDataCenterKeyPairs[0];
    var customAddr2 = ValidationDataCenterKeyPairs[1];
    
    await SetProfitsReceiver(minerKeyPair, Address.FromPublicKey(customAddr1.PublicKey));
    
    // 2. Mine one term - CustomAddr1 becomes beneficiary in BasicReward
    await ProduceBlocksAndEndTerm();
    
    var customAddr1Details = await GetBasicRewardProfitDetails(Address.FromPublicKey(customAddr1.PublicKey));
    customAddr1Details.Details.Count.ShouldBe(1); // CustomAddr1 is beneficiary
    
    // 3. Change receiver to CustomAddr2
    await SetProfitsReceiver(minerKeyPair, Address.FromPublicKey(customAddr2.PublicKey));
    
    // 4. Mine another term - triggers UpdateBasicMinerRewardWeights
    await ProduceBlocksAndEndTerm();
    
    // 5. Verify vulnerability: BOTH CustomAddr1 and CustomAddr2 are beneficiaries
    var customAddr1DetailsAfter = await GetBasicRewardProfitDetails(Address.FromPublicKey(customAddr1.PublicKey));
    var customAddr2Details = await GetBasicRewardProfitDetails(Address.FromPublicKey(customAddr2.PublicKey));
    
    customAddr1DetailsAfter.Details.Count.ShouldBe(1); // BUG: CustomAddr1 still exists!
    customAddr2Details.Details.Count.ShouldBe(1); // CustomAddr2 also exists
    
    // Both receive rewards - fund misallocation proven
    await ClaimProfits(customAddr1);
    await ClaimProfits(customAddr2);
    
    var balance1 = await GetBalance(Address.FromPublicKey(customAddr1.PublicKey));
    var balance2 = await GetBalance(Address.FromPublicKey(customAddr2.PublicKey));
    
    balance1.ShouldBeGreaterThan(0); // CustomAddr1 should not receive rewards!
    balance2.ShouldBeGreaterThan(0);
}
```

The test would demonstrate that after changing the profits receiver, both the old and new receiver addresses exist as beneficiaries and both receive rewards, proving the fund misallocation vulnerability.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L22-26)
```csharp
///     (AEDPoS Contract will:
///     1. transfer ELF tokens to general ledger of Treasury every time we change term (7 days),
///     the amount of ELF should be based on blocks produced during last term. 1,000,000 * 1250000 ELF,
///     then release the Treasury;
///     2. Release Treasury)
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L123-128)
```csharp
    public override Empty Release(ReleaseInput input)
    {
        RequireAEDPoSContractStateSet();
        Assert(
            Context.Sender == State.AEDPoSContract.Value,
            "Only AElf Consensus Contract can release profits from Treasury.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L480-488)
```csharp
    private MinerRewardWeightSetting GetDefaultMinerRewardWeightSetting()
    {
        return new MinerRewardWeightSetting
        {
            BasicMinerRewardWeight = 2,
            WelcomeRewardWeight = 1,
            FlexibleRewardWeight = 1
        };
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-612)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
        
        var candidateList = State.ElectionContract.GetCandidates.Call(new Empty());
        Assert(candidateList.Value.Contains(pubkey),"Pubkey is not a candidate.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L620-627)
```csharp
        State.ProfitsReceiverMap[input.Pubkey] = input.ProfitsReceiverAddress;
        State.ElectionContract.SetProfitsReceiver.Send(new AElf.Contracts.Election.SetProfitsReceiverInput
        {
            CandidatePubkey = input.Pubkey,
            ReceiverAddress = input.ProfitsReceiverAddress,
            PreviousReceiverAddress = previousProfitsReceiver ?? new Address()
        });

```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L651-655)
```csharp
    private Address GetProfitsReceiver(string pubkey)
    {
        return State.ProfitsReceiverMap[pubkey] ??
               Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L657-663)
```csharp
    private List<Address> GetAddressesFromCandidatePubkeys(ICollection<string> pubkeys)
    {
        var addresses = pubkeys.Select(k => Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)))
            .ToList();
        addresses.AddRange(pubkeys.Select(GetProfitsReceiver));
        return addresses;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L751-764)
```csharp
    private void UpdateStateBeforeDistribution(Round previousTermInformation, List<string> newElectedMiners)
    {
        var previousPreviousTermInformation = State.AEDPoSContract.GetPreviousTermInformation.Call(new Int64Value
        {
            Value = previousTermInformation.TermNumber.Sub(1)
        });

        if (newElectedMiners.Any()) State.HasNewMiner[previousTermInformation.TermNumber.Add(1)] = true;

        Context.LogDebug(() => $"Will update weights after term {previousTermInformation.TermNumber}");
        UpdateBasicMinerRewardWeights(new List<Round> { previousPreviousTermInformation, previousTermInformation });
        UpdateWelcomeRewardWeights(previousTermInformation, newElectedMiners);
        UpdateFlexibleRewardWeights(previousTermInformation);
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L780-787)
```csharp
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L814-821)
```csharp
                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L850-857)
```csharp
        var previousMinerAddresses =
            GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
        var possibleWelcomeBeneficiaries = new RemoveBeneficiariesInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            Beneficiaries = { previousMinerAddresses }
        };
        State.ProfitContract.RemoveBeneficiaries.Send(possibleWelcomeBeneficiaries);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L867-879)
```csharp
            var newBeneficiaries = new AddBeneficiariesInput
            {
                SchemeId = State.VotesWeightRewardHash.Value,
                EndPeriod = previousTermInformation.TermNumber.Add(1)
            };
            foreach (var minerAddress in newElectedMiners.Select(GetProfitsReceiver))
                newBeneficiaries.BeneficiaryShares.Add(new BeneficiaryShare
                {
                    Beneficiary = minerAddress,
                    Shares = 1
                });

            if (newBeneficiaries.BeneficiaryShares.Any()) State.ProfitContract.AddBeneficiaries.Send(newBeneficiaries);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L907-913)
```csharp
            var previousMinerAddresses =
                GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                Beneficiaries = { previousMinerAddresses }
            });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-235)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L785-794)
```csharp
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = beneficiaryAddress,
                Shares = 1,
            },
            ProfitDetailId = subsidyId
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L801-806)
```csharp
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            Beneficiary = beneficiaryAddress,
            ProfitDetailId = previousSubsidyId
        });
```
