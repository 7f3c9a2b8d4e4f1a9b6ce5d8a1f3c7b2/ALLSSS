# Audit Report

## Title
ExpectedMiningTime Manipulation in Next Round Allows Network DoS

## Summary
The AEDPoS consensus validation fails to verify that `ExpectedMiningTime` values in next round data are anchored to the current block timestamp. A malicious extra block producer can set arbitrary future timestamps while maintaining equal intervals between miners, passing all validation checks but rendering the network unable to produce blocks when the manipulated round activates.

## Finding Description

When a miner produces an extra block to terminate the current round, they include next round information in the consensus extra data. This data is validated by `ValidateBeforeExecution` which orchestrates multiple validation providers. [1](#0-0) 

For NextRound behavior, the validation chain includes `TimeSlotValidationProvider` which delegates to `CheckRoundTimeSlots()` when a new round is provided: [2](#0-1) 

The `CheckRoundTimeSlots()` method only validates relative properties: (1) `ExpectedMiningTime` is not null, (2) mining interval > 0, and (3) intervals between consecutive miners are roughly equal with 100% tolerance. Critically, it does NOT validate that the absolute `ExpectedMiningTime` values are anchored to the current block time: [3](#0-2) 

The intended generation logic properly calculates `ExpectedMiningTime` as `currentBlockTimestamp.AddMilliseconds(miningInterval * order)`: [4](#0-3) 

However, since miners control the consensus data they include in blocks (it's just serialized bytes that get validated), an attacker can construct manipulated round data. For example, setting all `ExpectedMiningTime` values to `currentBlockTime + 1000 years` with proper intervals between them would pass all validation checks.

When this manipulated round becomes active, `IsCurrentMiner()` checks fail for all miners. This method verifies that `Context.CurrentBlockTime` falls within the time slot `[ExpectedMiningTime, ExpectedMiningTime + miningInterval]`: [5](#0-4) 

With `ExpectedMiningTime` set far in the future, no miner's time slot will ever arrive, preventing all block production.

## Impact Explanation

This vulnerability enables a complete consensus-level denial of service attack:

**Network Halt**: Once the manipulated round activates, all `IsCurrentMiner()` checks return false because the current block time never reaches the artificially advanced `ExpectedMiningTime` values. Block production stops entirely.

**Transaction Freeze**: No transactions can be processed, no state updates occur, and the blockchain becomes completely non-functional.

**Recovery Difficulty**: The network remains halted until manual intervention (governance action or hard fork) since the consensus mechanism itself is compromised.

**Broad Impact**: All network participants are affected - users cannot transact, applications cannot function, and validators cannot earn rewards.

The severity is HIGH because this causes complete, deterministic network unavailability with no automatic recovery mechanism.

## Likelihood Explanation

**Attacker Profile**: Any miner in the active validator set can execute this attack when selected as the extra block producer. Extra block producer selection rotates deterministically based on consensus signatures, meaning every miner periodically has this opportunity.

**Attack Prerequisites**: 
- Attacker must be a miner (normal participant role, not privileged)
- Attacker must wait until selected as extra block producer (happens regularly through rotation)
- Attacker runs modified node software that manipulates round data before block production

**Technical Simplicity**: The attack requires only modifying the `Round` protobuf structure before serialization - no cryptographic breaks, no race conditions, no complex state manipulation. The validation gap makes exploitation straightforward.

**Detection Window**: The attack is invisible during validation (all checks pass) and only becomes apparent when the manipulated round activates and blocks stop being produced. By then, the malicious round data is already committed to the chain.

The likelihood is HIGH because every miner regularly becomes extra block producer, and the validation logic has no defense against this manipulation.

## Recommendation

Add validation in `CheckRoundTimeSlots()` or a dedicated provider to verify that the first miner's `ExpectedMiningTime` is anchored to a reasonable window around the current block timestamp:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    var baseMiningInterval = (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();
    if (baseMiningInterval <= 0)
        return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

    // NEW: Validate first miner's ExpectedMiningTime is anchored to current time
    var firstMinerTime = miners[0].ExpectedMiningTime;
    var expectedFirstMinerTime = Context.CurrentBlockTime.AddMilliseconds(baseMiningInterval);
    var timeDeviation = Math.Abs((firstMinerTime - expectedFirstMinerTime).Milliseconds());
    
    // Allow small tolerance for clock skew (e.g., 2x mining interval)
    if (timeDeviation > baseMiningInterval * 2)
        return new ValidationResult { Message = "First miner ExpectedMiningTime not anchored to current block time." };

    // Continue with existing interval checks...
    for (var i = 1; i < miners.Count - 1; i++)
    {
        var miningInterval = (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
        if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
            return new ValidationResult { Message = "Time slots are so different." };
    }

    return new ValidationResult { Success = true };
}
```

This ensures that even if all intervals are equal, the absolute timestamps must be reasonable relative to when the round is being proposed.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Set up a consensus contract with active miners
2. Have one miner selected as extra block producer
3. Call `GetConsensusExtraData` to generate legitimate next round data
4. Modify the returned round data to set all `ExpectedMiningTime` values far in the future (e.g., +1000 years) while maintaining equal intervals
5. Call `ValidateConsensusBeforeExecution` with the manipulated data
6. Verify validation passes (returns Success = true)
7. Execute the `NextRound` transaction to commit the manipulated round
8. Verify that subsequent `IsCurrentMiner()` calls for all miners return false
9. Demonstrate that no miner can produce the next block

The test proves that manipulated timestamps pass validation but break consensus, causing network halt.

---

**Notes**: This vulnerability exploits a validation gap where relative properties (equal intervals) are checked but absolute properties (timestamp anchoring) are not. The attack is particularly severe because it's deterministic, regularly available to any miner, and causes complete network failure with no automatic recovery.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-104)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }

        var service = new HeaderInformationValidationService(validationProviders);

        Context.LogDebug(() => $"Validating behaviour: {extraData.Behaviour.ToString()}");

        var validationResult = service.ValidateInformation(validationContext);

        if (validationResult.Success == false)
            Context.LogDebug(() => $"Consensus Validation before execution failed : {validationResult.Message}");

        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L158-167)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;

        // Check normal time slot.
        if (timeSlotStartTime <= Context.CurrentBlockTime && Context.CurrentBlockTime <=
            timeSlotStartTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]NORMAL");
            return true;
        }
```
