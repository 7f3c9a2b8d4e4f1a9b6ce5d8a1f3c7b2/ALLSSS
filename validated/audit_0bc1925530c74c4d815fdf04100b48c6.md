# Audit Report

## Title
Period Desynchronization Between TokenHolder and Profit Contracts Causes DoS in RegisterForProfits

## Summary
The TokenHolder contract maintains a local Period counter that must stay synchronized with the Profit contract's CurrentPeriod. When a scheme manager calls Profit.DistributeProfits directly (bypassing TokenHolder), the periods desynchronize. This causes RegisterForProfits with auto-distribute enabled to permanently revert, creating a DoS condition that prevents users from registering for profit schemes.

## Finding Description

The TokenHolder contract tracks profit distribution periods locally, which should remain synchronized with the underlying Profit contract's CurrentPeriod. The synchronization mechanism is implemented in UpdateTokenHolderProfitScheme, which has an early-exit condition that prevents synchronization when SchemeId is already set and updateSchemePeriod is false. [1](#0-0) 

The vulnerability occurs in RegisterForProfits when auto-distribute is triggered. The function calls GetValidScheme with the default updateSchemePeriod=false parameter, preventing period synchronization. [2](#0-1) 

Although the function fetches the current scheme from the Profit contract, it uses the stale local scheme.Period value when constructing the DistributeProfitsInput for auto-distribute: [3](#0-2) 

The Profit contract explicitly allows both the scheme manager AND the TokenHolder contract to call DistributeProfits: [4](#0-3) 

When the manager calls it directly, the Profit contract increments its CurrentPeriod but TokenHolder's local Period remains unchanged: [5](#0-4) 

Subsequently, when RegisterForProfits triggers auto-distribute with the stale Period, the Profit contract enforces strict period validation: [6](#0-5) 

This assertion fails, causing all subsequent RegisterForProfits calls to revert with "Invalid period" error until the periods are re-synchronized.

## Impact Explanation

**Operational Impact - Complete DoS of RegisterForProfits:**
- When periods desynchronize, RegisterForProfits with auto-distribute enabled permanently fails for ALL users attempting to register
- Users cannot lock tokens or register as beneficiaries in the profit scheme
- The staking/dividend system becomes non-functional for new participants
- Existing beneficiaries remain unaffected but no new users can join

**Scope of Damage:**
- Affects ALL TokenHolder schemes where auto-distribute thresholds are configured
- The DoS persists until someone successfully calls TokenHolder.DistributeProfits (which may also fail due to the same desynchronization)
- No fund loss occurs, but critical protocol functionality is severely degraded
- Reduces protocol adoption and utility as new users cannot participate

This breaks the core invariant that TokenHolder.Period must equal Profit.CurrentPeriod for proper operation, violating the synchronization guarantee expected by the auto-distribute mechanism.

## Likelihood Explanation

**High Likelihood due to:**

1. **Low Attack Complexity**: Single transaction calling Profit.DistributeProfits directly by the scheme manager. No coordination, timing requirements, or complex setup needed.

2. **Legitimate Use Case**: Scheme managers have valid reasons to call Profit.DistributeProfits directly, such as distributing profits without going through TokenHolder's wrapper function. This is an explicitly authorized operation, not an exploit.

3. **Common Precondition**: Auto-distribute thresholds are a standard feature for TokenHolder schemes, making affected schemes common rather than exceptional.

4. **Permanent Effect**: Once triggered, the desynchronization persists indefinitely, affecting all subsequent RegisterForProfits attempts.

5. **No Detection Mechanism**: The system provides no warning or detection when periods desynchronize, making this issue likely to occur through normal operations rather than only through malicious intent.

The test suite confirms the expected synchronization behavior but does not cover the scenario where managers bypass TokenHolder: [7](#0-6) 

## Recommendation

**Fix Option 1 - Always Synchronize in RegisterForProfits:**
Modify RegisterForProfits to always sync the period before checking auto-distribute thresholds by passing updateSchemePeriod=true to GetValidScheme, or by explicitly fetching and using originScheme.CurrentPeriod instead of scheme.Period when creating the DistributeProfitsInput.

**Fix Option 2 - Restrict DistributeProfits Authorization:**
Modify the Profit contract to only allow the TokenHolder contract (not the manager) to call DistributeProfits for TokenHolder-managed schemes. However, this may break legitimate use cases where managers need direct control.

**Fix Option 3 - Use Profit's CurrentPeriod Directly:**
When auto-distribute is triggered, fetch the Profit contract's CurrentPeriod at line 181 and use originScheme.CurrentPeriod in the DistributeProfitsInput instead of the cached scheme.Period value.

**Recommended Approach**: Implement Fix Option 3 as it maintains backward compatibility while ensuring the correct period is always used for auto-distribution.

## Proof of Concept

```csharp
[Fact]
public async Task Period_Desynchronization_Causes_RegisterForProfits_DoS()
{
    // Setup: Create scheme with auto-distribute threshold
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        AutoDistributeThreshold = { { "ELF", 1000 } }
    });
    
    // Contribute profits to trigger scheme creation in Profit contract
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 1000
    });
    
    // Get scheme ID for direct Profit contract interaction
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = Starter });
    var schemeId = schemeIds.SchemeIds.First();
    
    // Verify periods are initially synchronized
    var profitScheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    var tokenHolderScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    profitScheme.CurrentPeriod.ShouldBe(1);
    tokenHolderScheme.Period.ShouldBe(1);
    
    // ATTACK: Manager calls Profit.DistributeProfits directly (bypassing TokenHolder)
    await ProfitContractStub.DistributeProfits.SendAsync(new Profit.DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { { "ELF", 0 } }
    });
    
    // Verify desynchronization occurred
    profitScheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    tokenHolderScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    profitScheme.CurrentPeriod.ShouldBe(2); // Profit contract incremented
    tokenHolderScheme.Period.ShouldBe(1);  // TokenHolder did NOT increment
    
    // IMPACT: User attempts RegisterForProfits with auto-distribute - it FAILS
    var result = await TokenHolderContractStub.RegisterForProfits.SendWithExceptionAsync(
        new RegisterForProfitsInput
        {
            Amount = 1000,
            SchemeManager = Starter
        });
    
    // Verify the DoS: transaction reverts with period validation error
    result.TransactionResult.Error.ShouldContain("Invalid period");
}
```

**Notes**

The vulnerability stems from a design assumption that all profit distribution operations would flow through TokenHolder's DistributeProfits method, which properly synchronizes periods. However, the Profit contract's authorization check explicitly allows scheme managers to call DistributeProfits directly, creating a valid but unhandled execution path that breaks the synchronization invariant. This is particularly problematic because the desynchronization is silent and persistent, affecting all users attempting to register for profits until manual intervention re-synchronizes the periods.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-152)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L193-203)
```csharp
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L426-428)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L478-480)
```csharp
        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L415-418)
```csharp
        var schemeInfoInProfit = await ProfitContractStub.GetScheme.CallAsync(schemeId);
        var schemeInfoInTokenHolder = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
        schemeInfoInProfit.CurrentPeriod.ShouldBe(2);
        schemeInfoInTokenHolder.Period.ShouldBe(2);
```
