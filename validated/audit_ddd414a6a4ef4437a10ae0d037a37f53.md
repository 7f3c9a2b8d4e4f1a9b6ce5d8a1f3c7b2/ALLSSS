# Audit Report

## Title
Stale Continuous Block Counter Bypasses Severe Status Emergency Limit

## Summary
During Severe emergency status, the AEDPoS consensus system intends to limit block production to 1 block per miner. However, the validation system uses a stale `LatestPubkeyToTinyBlocksCount` counter from the previous block's state, and the counter update logic only decrements when the same miner continues. This allows a miner to produce up to 8 blocks during emergency status instead of the intended 1 block, completely undermining the emergency safety mechanism.

## Finding Description

The AEDPoS consensus contract implements an emergency brake mechanism that triggers when the current round number is dangerously ahead of the Last Irreversible Block (LIB) round number. The vulnerability arises from a timing mismatch between validation and state updates.

**Root Cause - Severe Status Returns 1:**

When the blockchain enters Severe status (current round ≥ LIB round + 8), the emergency limit is set to 1 block: [1](#0-0) 

The Severe status threshold is defined at 8 rounds: [2](#0-1) 

And triggers when the condition is met: [3](#0-2) 

**Validation Uses Stale Counter:**

The validation occurs BEFORE block execution and uses the counter value from the previous block's state: [4](#0-3) 

The validation is invoked via the ACS4 interface before execution: [5](#0-4) 

The validation provider only rejects blocks when the counter is negative: [6](#0-5) 

**Counter Update Only Decrements:**

After block execution, the counter is updated. When the same miner continues, the counter is merely decremented rather than reset to the new emergency limit: [7](#0-6) 

The new emergency limit (minersCountInTheory = 1) is only applied when a DIFFERENT miner takes over: [8](#0-7) 

**Execution Flow:**

Block execution calls `ProcessConsensusInformation` which updates the counter AFTER execution: [9](#0-8) 

**Concrete Example:**

- Before Severe status: Miner A has BlocksCount = 7 (from normal limit of 8)
- System enters Severe: `GetMaximumBlocksCount()` now returns 1
- Block N+1: Validation sees 7 (≥ 0, passes) → Execution sets to 6
- Block N+2: Validation sees 6 (≥ 0, passes) → Execution sets to 5
- ... continues through 4, 3, 2, 1, 0
- Block N+8: Validation sees 0 (≥ 0, passes) → Execution sets to -1
- Block N+9: Validation sees -1 (< 0, FAILS)

Result: 8 blocks produced during Severe status instead of 1.

## Impact Explanation

The Severe status emergency mechanism is a critical safety feature designed to prevent chain instability when the Last Irreversible Block falls dangerously behind. This security guarantee is explicitly enforced through the emergency brake logic [10](#0-9)  which fires an `IrreversibleBlockHeightUnacceptable` event to notify miners of the dangerous state.

When bypassed, the chain continues advancing rapidly despite being 8+ rounds ahead of LIB, which:
- **Increases fork risk:** More blocks ahead of LIB means higher probability of chain reorganization
- **Undermines finality guarantees:** Transaction irreversibility becomes less reliable
- **Defeats emergency response:** The emergency brake becomes 87.5% ineffective (1 block intended vs 8 blocks actual)

The constant defining the normal limit shows this affects up to 7 extra blocks: [11](#0-10) 

## Likelihood Explanation

This vulnerability triggers automatically during normal consensus operations:

**Preconditions (All Realistic):**
1. A miner produces consecutive blocks - common during normal mining operations as shown in the consensus command generation [12](#0-11) 
2. Network conditions cause LIB to lag 8+ rounds behind - occurs during network partitions, consensus delays, or validator downtime
3. The same miner continues producing blocks - natural consensus behavior

**No Special Capabilities Required:**
- No privileged access needed
- No transaction manipulation required
- Happens through legitimate mining operations

**Probability: HIGH** - This occurs whenever network issues cause Severe status while a miner is naturally producing consecutive blocks. The vulnerability is architectural and cannot be prevented without code changes.

## Recommendation

Fix the time-of-check-time-of-use vulnerability by enforcing the emergency limit immediately upon entering Severe status. Two approaches:

**Approach 1: Reset counter to emergency limit during validation**
Modify `ContinuousBlocksValidationProvider` to check if the current emergency limit is lower than the stored counter and enforce the stricter limit immediately.

**Approach 2: Reset counter when Severe status detected**
Modify `ResetLatestProviderToTinyBlocksCount` to detect when entering Severe status and reset the counter to the new limit rather than decrementing:

```csharp
private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
{
    LatestPubkeyToTinyBlocksCount currentValue;
    if (State.LatestPubkeyToTinyBlocksCount.Value == null)
    {
        currentValue = new LatestPubkeyToTinyBlocksCount
        {
            Pubkey = _processingBlockMinerPubkey,
            BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
        };
        State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
    }
    else
    {
        currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
        if (currentValue.Pubkey == _processingBlockMinerPubkey)
        {
            // NEW: If emergency limit is stricter than current counter, enforce it immediately
            var newCount = Math.Min(currentValue.BlocksCount.Sub(1), minersCountInTheory.Sub(1));
            State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = newCount
            };
        }
        else
            State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = minersCountInTheory.Sub(1)
            };
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task SevereStatus_ShouldLimit_ToOneBlock_NotEight()
{
    // Setup: Miner produces consecutive blocks normally
    var miner = InitialCoreDataCenterKeyPairs[0];
    
    // Produce blocks until counter is at 7 (one block already produced from limit of 8)
    for (int i = 0; i < 1; i++)
    {
        await ProduceTinyBlock(miner);
    }
    
    // Verify counter is at 7
    var counter = await ConsensusStub.GetLatestPubkeyToTinyBlocksCount.CallAsync(new Empty());
    counter.BlocksCount.ShouldBe(7);
    
    // Simulate Severe status: Force LIB to lag 8+ rounds behind
    // (In practice: network partition, consensus delays, validator downtime)
    await ForceSevereStatus();
    
    // Verify GetMaximumBlocksCount returns 1 during Severe status
    var maxBlocks = await ConsensusStub.GetMaximumBlocksCount.CallAsync(new Empty());
    maxBlocks.Value.ShouldBe(1);
    
    // BUG: Miner can still produce 8 blocks instead of 1
    int blocksProduced = 0;
    for (int i = 0; i < 10; i++)
    {
        try
        {
            await ProduceTinyBlock(miner);
            blocksProduced++;
        }
        catch
        {
            break; // Validation finally fails
        }
    }
    
    // EXPECTED: 1 block during Severe status
    // ACTUAL: 8 blocks produced (counter drains from 7 to -1)
    blocksProduced.ShouldBe(1); // This assertion FAILS
    Assert.True(blocksProduced == 8, "Vulnerability confirmed: 8 blocks produced instead of 1");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L117-117)
```csharp
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L127-128)
```csharp
            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-80)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L67-69)
```csharp
        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-357)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L358-363)
```csharp
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
