# Audit Report

## Title
Missing OutValue Uniqueness Check Allows Miners to Manipulate Mining Order Through Duplicate UpdateValue Submissions

## Summary
The AEDPoS consensus contract fails to enforce the invariant that each miner submits their OutValue commitment exactly once per round. The validation flow calls `RecoverFromUpdateValue` before checking for duplicate submissions, which overwrites the original OutValue in the BaseRound state. This allows malicious miners to adaptively change their committed OutValue mid-round after observing other miners' submissions, enabling manipulation of the next round's mining order calculation.

## Finding Description

The vulnerability exists because the consensus validation pipeline does not verify whether a miner has already submitted an OutValue in the current round before accepting a new UpdateValue transaction.

**Root Cause Analysis:**

In `ValidateBeforeExecution`, the contract calls `RecoverFromUpdateValue` on the baseRound **before** any validation occurs: [1](#0-0) 

This method unconditionally overwrites the miner's OutValue in the baseRound: [2](#0-1) 

After this recovery, the validation provider `NewConsensusInformationFilled` only checks that the ProvidedRound contains a non-null OutValue with bytes, but cannot detect if the baseRound originally had an OutValue set: [3](#0-2) 

The only duplicate protection is `EnsureTransactionOnlyExecutedOnceInOneBlock`, which prevents multiple executions in the same block but NOT in the same round: [4](#0-3) 

During execution, `ProcessUpdateValue` unconditionally overwrites the OutValue: [5](#0-4) 

**Expected vs Actual Behavior:**

The client-side consensus behavior provider expects miners to use TinyBlock after their first UpdateValue (when OutValue is already set): [6](#0-5) 

However, this is only client-side guidance and is not enforced by contract-side validation. A malicious miner can modify their node to ignore this and submit multiple UpdateValue transactions in different blocks within the same round.

**Attack Scenario:**

1. Miner A is elected and has their time slot in Round N
2. At block height H, Miner A calls UpdateValue with OutValue_1 (derived from InValue_1)
3. Miner A observes other miners' OutValue submissions in the round
4. At block height H+1 (still in Round N, within the same time slot), Miner A calls UpdateValue again with OutValue_2 (derived from InValue_2)
5. The second UpdateValue passes all validations because:
   - Different block heights (H vs H+1) so `EnsureTransactionOnlyExecutedOnceInOneBlock` passes
   - `RecoverFromUpdateValue` overwrites BaseRound.OutValue_1 with OutValue_2 before validation
   - `NewConsensusInformationFilled` only checks that OutValue_2 is non-null, not that OutValue_1 already existed
6. Miner A's state now has OutValue_2, and they can choose the value that gives them optimal mining order for the next round

## Impact Explanation

**Consensus Integrity Violation - HIGH**

The vulnerability directly undermines the core security property of the AEDPoS consensus mechanism: that miners must commit to their randomness contribution (OutValue) before observing others' commitments.

The mining order for the next round is calculated based on the signature value (derived from OutValue) modulo the miner count: [7](#0-6) 

By allowing miners to change their OutValue mid-round, the attacker can:

1. **Manipulate Mining Order**: The attacker can generate multiple InValue/OutValue pairs and selectively choose the one that positions them favorably in the next round's mining schedule
2. **Break Randomness Guarantees**: The commitment scheme is designed to ensure unpredictable ordering. Adaptive commitment breaks this property
3. **Gain Unfair Advantage**: Honest miners commit once and are bound to their choice, while the attacker can optimize their position based on observed values

This compromises the fairness and security of the consensus mechanism, as mining order determines block production privileges and associated rewards.

## Likelihood Explanation

**HIGH Likelihood**

**Attack Complexity**: Low
- The attacker only needs to be an elected miner (requires staking tokens and receiving votes)
- Once elected, the attack requires minimal technical complexity: modify the node software to submit multiple UpdateValue transactions instead of using TinyBlock after the first block
- No complex state manipulation or timing constraints beyond being within the miner's time slot

**Preconditions**: Minimal
- Attacker must be an elected miner (achievable through normal election process)
- No additional privileges required
- Attack can be executed within normal consensus operation

**Detection**: Difficult
- The duplicate UpdateValue transactions appear valid to on-chain validators
- No event logs or state markers distinguish this attack from normal operation
- The overwritten OutValue is lost, making forensic analysis difficult

**Economic Rationality**: High
- Attack cost: Minimal (only transaction fees for additional blocks)
- Attack benefit: Favorable mining position in next round, potentially leading to more block rewards
- Risk: Low (appears as normal consensus operation)

Any malicious miner can execute this attack whenever they desire optimal positioning in the subsequent round.

## Recommendation

Add a validation check before processing UpdateValue to ensure the miner has not already submitted an OutValue in the current round:

**In `ValidateBeforeExecution` method**, before calling `RecoverFromUpdateValue`, check the original BaseRound state:

```csharp
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
{
    // Check if OutValue is already set BEFORE recovery
    if (baseRound.RealTimeMinersInformation.ContainsKey(extraData.SenderPubkey.ToHex()) &&
        baseRound.RealTimeMinersInformation[extraData.SenderPubkey.ToHex()].OutValue != null)
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = "Miner has already submitted OutValue in this round." 
        };
    }
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
}
```

Alternatively, add this check to `UpdateValueValidationProvider`:

```csharp
private bool NoOutValueAlreadySet(ConsensusValidationContext validationContext)
{
    // Note: Must check against un-recovered BaseRound, so this check must happen
    // in ValidateBeforeExecution before RecoverFromUpdateValue is called
    var minerInBaseRound = validationContext.BaseRound
        .RealTimeMinersInformation[validationContext.SenderPubkey];
    return minerInBaseRound.OutValue == null;
}
```

This ensures the consensus invariant is enforced: each miner commits their OutValue exactly once per round.

## Proof of Concept

```csharp
[Fact]
public async Task DuplicateUpdateValue_SameRound_DifferentBlocks_ShouldFail()
{
    // Initialize first round with boot miner
    await InitializeFirstRound();
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var miner = firstRound.RealTimeMinersInformation.Values.First();
    var minerKeyPair = InitialCoreDataCenterKeyPairs.First(k => k.PublicKey.ToHex() == miner.Pubkey);
    
    // First UpdateValue at block height H
    BlockTimeProvider.SetBlockTime(miner.ExpectedMiningTime);
    var inValue1 = HashHelper.ComputeFrom("invalue1");
    var triggerInfo1 = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(minerKeyPair.PublicKey),
        InValue = inValue1,
        Behaviour = AElfConsensusBehaviour.UpdateValue
    };
    var extraData1 = (await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
        triggerInfo1.ToBytesValue())).ToConsensusHeaderInformation();
    var randomNumber1 = await GenerateRandomProofAsync(minerKeyPair);
    var updateInput1 = extraData1.Round.ExtractInformationToUpdateConsensus(
        miner.Pubkey, ByteString.CopyFrom(randomNumber1));
    await GetAEDPoSContractStub(minerKeyPair).UpdateValue.SendAsync(updateInput1);
    
    var roundAfterFirst = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var outValue1 = roundAfterFirst.RealTimeMinersInformation[miner.Pubkey].OutValue;
    outValue1.ShouldNotBeNull(); // First OutValue set
    
    // Second UpdateValue at block height H+1 (still in same round, same time slot)
    BlockTimeProvider.SetBlockTime(miner.ExpectedMiningTime.AddSeconds(1));
    var inValue2 = HashHelper.ComputeFrom("invalue2_different"); // Different InValue
    var triggerInfo2 = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(minerKeyPair.PublicKey),
        InValue = inValue2,
        Behaviour = AElfConsensusBehaviour.UpdateValue
    };
    var extraData2 = (await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
        triggerInfo2.ToBytesValue())).ToConsensusHeaderInformation();
    var randomNumber2 = await GenerateRandomProofAsync(minerKeyPair);
    var updateInput2 = extraData2.Round.ExtractInformationToUpdateConsensus(
        miner.Pubkey, ByteString.CopyFrom(randomNumber2));
    
    // This should FAIL but currently SUCCEEDS
    var result = await GetAEDPoSContractStub(minerKeyPair).UpdateValue.SendAsync(updateInput2);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // BUG: Passes when it should fail
    
    var roundAfterSecond = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var outValue2 = roundAfterSecond.RealTimeMinersInformation[miner.Pubkey].OutValue;
    
    // Vulnerability: OutValue was overwritten
    outValue2.ShouldNotBe(outValue1); // OutValue changed - consensus invariant violated
    roundAfterSecond.RoundNumber.ShouldBe(firstRound.RoundNumber); // Still in same round
}
```

This test demonstrates that a miner can call UpdateValue multiple times in the same round (different block heights), overwriting their OutValue commitment and violating the consensus invariant.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L14-20)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L242-248)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-62)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
