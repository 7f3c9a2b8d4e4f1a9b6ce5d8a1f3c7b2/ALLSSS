# Audit Report

## Title
LIB Height Can Decrease During NextRound and NextTerm Transitions Due to Missing Validation

## Summary
The AEDPoS consensus contract fails to validate Last Irreversible Block (LIB) height during `NextRound` and `NextTerm` transitions. The `LibInformationValidationProvider` is only applied for `UpdateValue` behavior, and the consensus hash validation explicitly excludes `ConfirmedIrreversibleBlockHeight`. This allows any elected miner to provide a `NextRound` or `NextTerm` block with a decreased LIB height, violating the critical consensus invariant that finality can only move forward.

## Finding Description

The vulnerability consists of three interconnected defects in the consensus validation flow:

**1. Missing LIB Validation for NextRound/NextTerm**

The validation logic only applies `LibInformationValidationProvider` for `UpdateValue` behavior but not for `NextRound` or `NextTerm`. [1](#0-0) 

For `UpdateValue`, the validation explicitly adds `LibInformationValidationProvider` with a comment stating "Is confirmed lib height and lib round number went down? (Which should not happens.)". However, for `NextRound` and `NextTerm` behaviors, only `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` are added, without the critical LIB validation.

The `LibInformationValidationProvider` contains the check that prevents LIB from decreasing by verifying that the base round's `ConfirmedIrreversibleBlockHeight` does not exceed the provided round's value. [2](#0-1) 

**2. Hash Validation Excludes ConfirmedIrreversibleBlockHeight**

The `GetCheckableRound` method used for consensus hash validation only includes specific fields (RoundNumber, TermNumber, RealTimeMinersInformation, and BlockchainAge), explicitly excluding `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` from the hash calculation. [3](#0-2) 

This exclusion allows these fields to be modified without detection during the consensus hash validation performed in `ValidateConsensusAfterExecution`. [4](#0-3) 

**3. Direct State Save Without LIB Validation**

The `ProcessNextRound` method converts the input to a Round object and saves it directly to state without any LIB validation. [5](#0-4) 

The conversion from `NextRoundInput` to `Round` includes the `ConfirmedIrreversibleBlockHeight` field. [6](#0-5) 

Similarly, `NextTermInput` conversion also includes these LIB fields. [7](#0-6) 

**Attack Execution Path:**

1. When generating next round information, the current LIB is copied to the new round. [8](#0-7) 

2. For next term, the same copying occurs. [9](#0-8) 

3. A malicious miner scheduled to produce a `NextRound` or `NextTerm` block receives the legitimate round data through `GetConsensusExtraDataForNextRound` or `GetConsensusExtraDataForNextTerm`, which includes the current LIB value. [10](#0-9) 

4. The malicious miner modifies `ConfirmedIrreversibleBlockHeight` to a lower value before including it in the block.

5. The modified block passes validation because:
   - `LibInformationValidationProvider` is not applied for NextRound/NextTerm
   - Hash validation doesn't include the modified field
   
6. The manipulated Round is saved to state with the decreased LIB height.

## Impact Explanation

**Critical Consensus Invariant Violation:**

LIB (Last Irreversible Block) represents the blockchain finality boundary - blocks below this height are considered permanently finalized and irreversible. Decreasing LIB violates the fundamental consensus guarantee that finality only moves forward. This breaks the core security model where confirmed blocks cannot be reorganized.

**Cross-Chain Security Impact:**

Cross-chain indexing and verification rely on LIB for security guarantees. The cross-chain system uses irreversible block information for validation. Decreasing LIB could invalidate previously accepted cross-chain transactions and may enable double-spending attacks across chains if transactions were confirmed based on the original LIB.

**Systemic Impact:**

Applications and users relying on block finality guarantees lose security assurances. Smart contracts depending on finality (e.g., time-locked operations, irreversible settlements) become vulnerable. Treasury distributions, profit calculations, and other consensus-dependent operations may be compromised.

The severity is **CRITICAL** because it breaks a fundamental blockchain invariant that underpins the entire security model.

## Likelihood Explanation

**Attacker Requirements:**
- Attacker must be an elected miner in the consensus miner list
- Must be scheduled to produce a NextRound or NextTerm block during their assigned time slot
- No additional privileges beyond normal miner status required

**Attack Complexity:**
- **Very Low**: Simply modify the `ConfirmedIrreversibleBlockHeight` field in the Round object before including it in the block header
- No cryptographic manipulation required
- No complex state race conditions to exploit
- The attack is deterministic and reproducible

**Feasibility:**
- NextRound transitions occur regularly (every round, typically every few minutes)
- NextTerm transitions occur periodically (every term, typically daily/weekly depending on configuration)
- Any miner will eventually be scheduled for these transitions
- No unusual blockchain state or timing requirements needed

**Detection:**
- No validation checks will catch the manipulation
- No events or logs specifically track LIB progression validation
- Attack succeeds silently unless external monitoring specifically tracks LIB monotonicity
- Standard consensus validation passes the malicious block

The likelihood is **HIGH** because any malicious miner can execute this attack with 100% success rate during their regularly scheduled NextRound/NextTerm block production.

## Recommendation

Add `LibInformationValidationProvider` to the validation providers for both `NextRound` and `NextTerm` behaviors in the `ValidateBeforeExecution` method:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
}
```

This ensures that any attempt to decrease the LIB height during round or term transitions will be rejected during validation.

## Proof of Concept

A test can be constructed demonstrating that a NextRound transaction with a decreased `ConfirmedIrreversibleBlockHeight` value passes validation and corrupts the blockchain state. The test would:

1. Initialize a blockchain with current round having `ConfirmedIrreversibleBlockHeight = 1000`
2. Create a `NextRoundInput` with `ConfirmedIrreversibleBlockHeight = 500`
3. Execute `NextRound` transaction as an elected miner
4. Verify that the transaction succeeds (no validation error)
5. Verify that the new round in state has `ConfirmedIrreversibleBlockHeight = 500`
6. Confirm that LIB has decreased from 1000 to 500, violating the invariant

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L47-54)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval, Timestamp currentBlockTime, Round currentRound)
    {
        var round = GenerateFirstRoundOfNewTerm(miningInterval, currentBlockTime, currentRound.RoundNumber,
            currentRound.TermNumber);
        round.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        round.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```
