# Audit Report

## Title
Missing LIB Round Number Validation Allows Consensus State Corruption in NextTerm/NextRound Operations

## Summary
The AEDPoS consensus contract fails to validate that `ConfirmedIrreversibleBlockRoundNumber` is less than the current `RoundNumber` when processing `NextTerm` and `NextRound` operations. A malicious miner can inject consensus state where the Last Irreversible Block (LIB) round number equals or exceeds the current round number, violating the fundamental invariant that LIB must lag behind the current round, causing permanent consensus state corruption and mining status miscalculations.

## Finding Description

The vulnerability exists in the validation logic for consensus round transitions. The validation framework selectively applies different validation providers based on the consensus behavior type. [1](#0-0) 

For `NextTerm` behavior, only `RoundTerminateValidationProvider` is applied, which validates round number increment, term number increment, and InValue nullity, but does not validate LIB constraints. [2](#0-1) 

The `RoundTerminateValidationProvider` implementation confirms it only checks round/term number progression and InValue state without any LIB validation. [3](#0-2) 

The `LibInformationValidationProvider`, which is only applied to `UpdateValue` behavior, checks that LIB values don't regress but never validates that `ConfirmedIrreversibleBlockRoundNumber < RoundNumber`. [4](#0-3) 

**Attack Execution:**

1. A malicious miner with block production rights creates consensus input with valid `RoundNumber = currentRound.RoundNumber + 1` but invalid `ConfirmedIrreversibleBlockRoundNumber >= RoundNumber`

2. Validation passes because LibInformationValidationProvider is not applied to NextTerm/NextRound behaviors

3. The malicious round is stored via `ProcessNextTerm` which calls `input.ToRound()` to convert the input directly without LIB validation. [5](#0-4) [6](#0-5) 

4. The corrupted LIB values persist and propagate to all subsequent rounds because `GenerateNextRoundInformation` copies these fields without validation. [7](#0-6) 

5. No additional validation exists in `AddRoundInformation` or `TryToUpdateRoundNumber` to catch this invariant violation. [8](#0-7) 

## Impact Explanation

**Severity: HIGH - Critical Consensus Invariant Violation**

**Consensus State Corruption:**
The blockchain consensus state will permanently contain the logically impossible condition where `ConfirmedIrreversibleBlockRoundNumber >= RoundNumber`. This fundamentally violates the consensus protocol's invariant that the Last Irreversible Block must always lag behind the current round. The code itself expects this invariant, as shown in `ProcessUpdateValue` which sets `ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1)`. [9](#0-8) 

**Mining Status Miscalculation:**
The `BlockchainMiningStatusEvaluator` determines blockchain health by comparing `_libRoundNumber` against `_currentRoundNumber` using arithmetic assumptions that `_libRoundNumber < _currentRoundNumber`. [10](#0-9) 

When the invariant is violated (libRoundNumber >= currentRoundNumber), the status evaluation logic produces incorrect results:
- Line 123 condition `_libRoundNumber.Add(2) < _currentRoundNumber` becomes impossible, so Abnormal status never triggers
- Line 127 condition `_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold)` becomes impossible, so Severe status never triggers  
- The blockchain will always report Normal status even during actual health issues
- Block production limits and `IrreversibleBlockHeightUnacceptable` events will malfunction

**Cross-Chain Impact:**
LIB information is fundamental to cross-chain operations, as it determines which blocks are considered finalized for cross-chain indexing and transaction verification. Corrupted LIB round numbers could compromise cross-chain security guarantees.

## Likelihood Explanation

**Probability: MEDIUM - Requires Miner Privileges**

**Attacker Requirements:**
- Must be an active miner in the current miner list (controlled via election/governance)
- Must wait for scheduled time slot to produce a NextTerm or NextRound block
- Must be capable of crafting custom consensus transaction input (requires modified node software)

**Attack Complexity:**
The attack is technically simple - merely requires modifying the `ConfirmedIrreversibleBlockRoundNumber` field in the NextTermInput/NextRoundInput to an invalid value. No sophisticated cryptographic attacks, timing exploits, or multi-transaction coordination required.

**Execution Feasibility:**
While normal miners use `GenerateConsensusTransactions` to create consensus data, there is no cryptographic binding preventing a malicious miner from crafting arbitrary input. [11](#0-10)  A compromised miner running modified node software can execute this attack with certainty during their mining turn.

**Detection Difficulty:**
The corruption does not cause immediate failures or reverts - it silently corrupts state. The mining status miscalculations may not be obvious until specific threshold conditions are met.

## Recommendation

Add `LibInformationValidationProvider` to the validation pipeline for `NextTerm` and `NextRound` behaviors in `AEDPoSContract_Validation.cs`:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add this
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add this
    break;
```

Additionally, enhance `LibInformationValidationProvider` to validate the critical invariant:

```csharp
// Add after line 21 in LibInformationValidationProvider.cs
if (providedRound.ConfirmedIrreversibleBlockRoundNumber >= providedRound.RoundNumber)
{
    validationResult.Message = "LIB round number must be less than current round number.";
    return validationResult;
}
```

## Proof of Concept

A malicious miner can craft a `NextTermInput` with:
- `RoundNumber = currentRound.RoundNumber + 1` (passes RoundTerminateValidationProvider)
- `ConfirmedIrreversibleBlockRoundNumber = RoundNumber` (violates invariant but no validator checks this)

The input will pass validation and be stored via `ProcessNextTerm` → `input.ToRound()` → `AddRoundInformation(nextRound)`, permanently corrupting consensus state. The corrupted value will propagate to all future rounds via `GenerateNextRoundInformation` copying without validation, causing `BlockchainMiningStatusEvaluator` to always report Normal status even during blockchain health issues.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-46)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-281)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L91-124)
```csharp
    private bool TryToUpdateRoundNumber(long roundNumber)
    {
        var oldRoundNumber = State.CurrentRoundNumber.Value;
        if (roundNumber != 1 && oldRoundNumber + 1 != roundNumber) return false;
        State.CurrentRoundNumber.Value = roundNumber;
        return true;
    }

    /// <summary>
    ///     Will force to generate a `Change` to tx executing result.
    /// </summary>
    /// <param name="round"></param>
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L87-130)
```csharp
    private class BlockchainMiningStatusEvaluator
    {
        private const int AbnormalThresholdRoundsCount = 2;

        /// <summary>
        ///     Stands for R
        /// </summary>
        private readonly long _currentRoundNumber;

        /// <summary>
        ///     Stands for R_LIB
        /// </summary>
        private readonly long _libRoundNumber;

        /// <summary>
        ///     Stands for CB0
        /// </summary>
        private readonly int _maximumTinyBlocksCount;

        public BlockchainMiningStatusEvaluator(long currentConfirmedIrreversibleBlockRoundNumber,
            long currentRoundNumber, int maximumTinyBlocksCount)
        {
            _libRoundNumber = currentConfirmedIrreversibleBlockRoundNumber;
            _currentRoundNumber = currentRoundNumber;
            _maximumTinyBlocksCount = maximumTinyBlocksCount;
        }

        /// <summary>
        ///     Stands for CB1
        /// </summary>
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L172-179)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextTerm), NextTermInput.Create(round,randomNumber))
                    }
                };
```
