# Audit Report

## Title
Vote Persistence After Member Removal Enables Governance Manipulation

## Summary
The Association contract's `RemoveMember()` function fails to clean up existing votes on pending proposals, creating a critical inconsistency in threshold calculations. This allows organizations to bypass `MaximalRejectionThreshold` and `MaximalAbstentionThreshold` protections by strategically removing dissenting members after they vote.

## Finding Description

The vulnerability stems from an inconsistency between how individual vote types are counted versus how total votes are counted when determining if a proposal can be released.

The `RemoveMember()` function only modifies the organization's member list without touching existing votes on pending proposals. [1](#0-0) 

When a proposal's release threshold is evaluated, the `IsProposalRejected()` method filters rejection votes by checking if voters are still in the current member list. [2](#0-1) 

Similarly, `IsProposalAbstained()` filters abstention votes by current membership. [3](#0-2) 

However, the `CheckEnoughVoteAndApprovals()` method contains a critical flaw. While it correctly filters approval votes by current membership, the total vote count concatenates all vote lists without any membership filtering. [4](#0-3) 

This inconsistency enables the following attack:
1. A proposal receives votes including rejections or abstentions
2. The organization (via another proposal) calls `RemoveMember()` to remove members who voted unfavorably
3. When the original proposal's `Release()` method evaluates `IsReleaseThresholdReached()`, removed members' rejection/abstention votes no longer count against the respective maximum thresholds
4. However, their votes still count toward the `MinimalVoteThreshold` requirement
5. The proposal can now pass despite having exceeded rejection/abstention limits

## Impact Explanation

This vulnerability completely undermines the Association contract's governance safeguards:

**Direct Governance Bypass**: Organizations can circumvent `MaximalRejectionThreshold` and `MaximalAbstentionThreshold` - two critical protections designed to prevent proposals from passing when too many members oppose or abstain. For example, with 10 members, `MinimalVoteThreshold=7`, `MaximalRejectionThreshold=2`, and `MinimalApprovalThreshold=5`, a proposal with 5 approvals and 3 rejections (8 total votes) would normally fail. By removing the 3 rejecting members, the rejection count becomes 0 while maintaining 8 total votes, allowing the proposal to pass.

**Affected Parties**: All Association organization members and stakeholders relying on Association-based governance for protocol decisions, fund management, or multi-sig operations.

**Severity**: This is a critical governance integrity violation. The Association contract's threshold system is designed as a check-and-balance mechanism. By allowing threshold manipulation through membership changes rather than genuine consensus, the vulnerability enables minority factions to force through proposals, fundamentally breaking the governance model.

## Likelihood Explanation

**Attacker Capabilities**: The organization itself (acting through a passed proposal) has the authority to remove members. While this requires initial consensus, once a faction gains sufficient control to pass a single member removal proposal, they can leverage this vulnerability to manipulate subsequent proposals.

**Attack Complexity**: Low to medium complexity. The attack requires:
1. Achieving enough votes to pass an initial member removal proposal
2. Timing the removal to occur after unfavorable votes are cast on target proposals
3. Subsequently releasing the manipulated proposal

**Practical Feasibility**: The attack is realistic in organizations where a faction controls slightly above `MinimalApprovalThreshold` but faces opposition. The faction can pass one removal proposal, eliminate the opposition's voting power, then pass subsequent proposals that would have failed under normal circumstances.

## Recommendation

Modify the vote counting logic to ensure consistency. The total vote threshold should also filter by current membership, matching the behavior of rejection, abstention, and approval counts:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // Filter total votes by current membership
    var validAbstentions = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
    var validApprovals = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var validRejections = proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached =
        validAbstentions + validApprovals + validRejections >=
        organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

Alternatively, implement vote cleanup when removing members to maintain historical integrity.

## Proof of Concept

```csharp
[Fact]
public async Task VotePersistenceAfterMemberRemoval_EnablesGovernanceManipulation_Test()
{
    // Setup: Create organization with 10 members
    var members = new[] { Reviewer1, Reviewer2, Reviewer3, Accounts[4].Address, 
                         Accounts[5].Address, Accounts[6].Address, Accounts[7].Address,
                         Accounts[8].Address, Accounts[9].Address, Accounts[10].Address };
    
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList { OrganizationMembers = { members } },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 5,
            MinimalVoteThreshold = 7,
            MaximalAbstentionThreshold = 1,
            MaximalRejectionThreshold = 2
        },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { Reviewer1 } }
    };
    
    var organizationAddress = (await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput)).Output;
    
    // Step 1: Create Proposal A
    var proposalAInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress,
        ToAddress = TokenContractAddress,
        ContractMethodName = nameof(TokenContractStub.Transfer),
        Params = new TransferInput { To = Reviewer1, Amount = 100, Symbol = "ELF" }.ToByteString(),
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(1)
    };
    var proposalAId = (await GetAssociationContractTester(Reviewer1KeyPair).CreateProposal.SendAsync(proposalAInput)).Output;
    
    // Step 2: Cast votes - 5 approvals, 3 rejections (8 total, exceeds MaximalRejectionThreshold of 2)
    await GetAssociationContractTester(Accounts[1].KeyPair).Approve.SendAsync(proposalAId);
    await GetAssociationContractTester(Accounts[2].KeyPair).Approve.SendAsync(proposalAId);
    await GetAssociationContractTester(Accounts[3].KeyPair).Approve.SendAsync(proposalAId);
    await GetAssociationContractTester(Accounts[4].KeyPair).Approve.SendAsync(proposalAId);
    await GetAssociationContractTester(Accounts[5].KeyPair).Approve.SendAsync(proposalAId);
    await GetAssociationContractTester(Accounts[6].KeyPair).Reject.SendAsync(proposalAId);
    await GetAssociationContractTester(Accounts[7].KeyPair).Reject.SendAsync(proposalAId);
    await GetAssociationContractTester(Accounts[8].KeyPair).Reject.SendAsync(proposalAId);
    
    // Step 3: Verify Proposal A cannot be released (rejected due to exceeding MaximalRejectionThreshold)
    var proposalBeforeRemoval = await AssociationContractStub.GetProposal.CallAsync(proposalAId);
    proposalBeforeRemoval.ToBeReleased.ShouldBeFalse(); // Should fail due to 3 rejections > 2 threshold
    
    // Step 4: Create and pass Proposal B to remove the 3 rejecting members
    var removeMemberInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress,
        ToAddress = organizationAddress,
        ContractMethodName = nameof(AssociationContractStub.RemoveMember),
        Params = Accounts[6].Address.ToByteString(),
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(1)
    };
    var proposalBId = (await GetAssociationContractTester(Reviewer1KeyPair).CreateProposal.SendAsync(removeMemberInput)).Output;
    
    // Pass Proposal B with 5 approvals
    await GetAssociationContractTester(Accounts[1].KeyPair).Approve.SendAsync(proposalBId);
    await GetAssociationContractTester(Accounts[2].KeyPair).Approve.SendAsync(proposalBId);
    await GetAssociationContractTester(Accounts[3].KeyPair).Approve.SendAsync(proposalBId);
    await GetAssociationContractTester(Accounts[4].KeyPair).Approve.SendAsync(proposalBId);
    await GetAssociationContractTester(Accounts[5].KeyPair).Approve.SendAsync(proposalBId);
    
    // Release Proposal B to remove member
    await GetAssociationContractTester(Reviewer1KeyPair).Release.SendAsync(proposalBId);
    
    // Repeat for other 2 rejecting members...
    // (Similar proposal creation and execution for Accounts[7] and Accounts[8])
    
    // Step 5: VULNERABILITY - Proposal A can now be released despite exceeding rejection threshold
    var proposalAfterRemoval = await AssociationContractStub.GetProposal.CallAsync(proposalAId);
    proposalAfterRemoval.ToBeReleased.ShouldBeTrue(); // BYPASSED - now passes!
    
    // The proposal passes because:
    // - rejectionMemberCount = 0 (filtered by current membership)
    // - approvedMemberCount = 5 (>= MinimalApprovalThreshold)
    // - totalVotes = 8 (NOT filtered, still >= MinimalVoteThreshold)
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```
