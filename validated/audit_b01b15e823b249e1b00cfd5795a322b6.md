# Audit Report

## Title
Vote Manipulation Through Member Removal After Rejection

## Summary
The Association contract allows organizations to manipulate proposal outcomes by removing members after they have cast rejection votes. Vote validity is dynamically re-evaluated at release time based on current membership rather than being immutably recorded at vote time, enabling proposals that legitimately reached rejection thresholds to be released by strategically removing dissenting voters.

## Finding Description

The vulnerability exists in the critical interaction between vote recording and threshold validation in the Association contract.

**Vote Recording:** When a member casts a rejection vote, the `Reject` method verifies they are a current member and adds their address to the proposal's rejection list. [1](#0-0) 

**Dynamic Threshold Calculation:** When checking if a proposal is rejected during release, the `IsProposalRejected` method counts only rejections from addresses that are currently in the organization member list. The filtering logic uses `proposal.Rejections.Count(organization.OrganizationMemberList.Contains)` which dynamically re-evaluates vote validity based on current membership rather than membership at vote time. [2](#0-1) 

**Unrestricted Member Removal:** Organizations can remove members at any time through the `RemoveMember` method without any checks for active proposals or existing votes cast by that member. [3](#0-2) 

**Root Cause:** The fundamental issue is that vote validity is re-evaluated at proposal release time based on current membership rather than being immutably recorded at vote time. This allows past votes from removed members to be retroactively invalidated.

**Why Protections Fail:** The organization validation logic only checks structural constraints (member count meets thresholds, no duplicates) but contains no logic to prevent member manipulation during active voting periods. [4](#0-3) 

The `Release` function relies on `IsReleaseThresholdReached`, which calls `IsProposalRejected` to check rejection thresholds. [5](#0-4) [6](#0-5) 

The same dynamic filtering applies to approvals and abstentions. [7](#0-6) 

## Impact Explanation

**Concrete Harm:**
- Organizations can force through proposals that legitimately reached rejection thresholds by removing dissenting members after they vote
- Breaks the fundamental integrity of the governance system where votes should be final once cast
- Enables unauthorized proposal execution by manipulating the apparent vote count
- The rejection threshold mechanism, designed as a veto power, can be completely bypassed

**Severity Justification (HIGH):**
- Directly violates the "Authorization & Governance" critical invariant requiring correct organization threshold enforcement
- Allows bypassing rejection thresholds entirely through membership manipulation
- No limit on the number of proposals that can be manipulated
- Affects all Association-governed organizations in the AElf ecosystem
- While no direct fund loss occurs, this enables unauthorized governance actions that could lead to treasury withdrawals, contract upgrades, or parameter changes

**Affected Parties:**
- Organization members whose rejection votes can be retroactively invalidated
- External parties relying on Association governance decisions
- Smart contracts controlled by manipulated Association organizations

## Likelihood Explanation

**Attacker Capabilities:**
The exploit requires organization-level control, meaning the organization itself (through a separate approved proposal) must execute the member removal. This is realistic because:
- Organizations can create proposals to modify their own membership
- A coalition controlling approval thresholds can remove dissenting members
- This is within the intended attack surface for governance manipulation

**Attack Complexity:**
Low - requires only standard contract operations in sequence:
1. Wait for rejection votes on target proposal
2. Create and approve a proposal to remove those members
3. Release the member removal proposal
4. Release the original proposal (now no longer rejected)

**Feasibility Conditions:**
- Target proposal must have accumulated sufficient rejections to be blocked
- Attacker coalition must control enough approval votes to remove dissenting members
- All steps use public contract methods with no special permissions required beyond organization control

**Economic Rationality:**
If the proposal being forced through provides value (e.g., treasury withdrawal, contract upgrade, parameter change), the cost of creating and approving the member removal proposal is justified by the gain. The transaction fees are minimal compared to potential benefits.

## Recommendation

Implement vote immutability by taking a membership snapshot at vote time or blocking member removal when they have active votes:

**Option 1: Snapshot-based voting**
- Store the organization member list hash with each proposal when created
- Count votes against the original member list, not current membership

**Option 2: Restrict member removal**
- Add checks in `RemoveMember` to prevent removing members with votes on active proposals
- Iterate through active proposals and verify the member hasn't voted

**Option 3: Permanent vote recording**
- Instead of filtering by current membership, validate votes were cast by valid members at vote time and count all historical votes regardless of current membership
- Remove the `.Contains()` predicate filtering and count all votes in the lists

Recommended approach is Option 3 as it preserves vote integrity without complex snapshot management or iteration overhead.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
public async Task MemberRemoval_BypassesRejectionThreshold_Test()
{
    // Setup: Create organization with 5 members, rejection threshold = 2
    var organization = await CreateOrganizationAsync(
        memberCount: 5,
        minimalApprovalThreshold: 3,
        maximalRejectionThreshold: 2
    );
    
    // Create proposal
    var proposalId = await CreateProposalAsync(organization);
    
    // Three members reject the proposal (exceeds rejection threshold of 2)
    await RejectProposalAsync(proposalId, member1);
    await RejectProposalAsync(proposalId, member2);
    await RejectProposalAsync(proposalId, member3);
    
    // Verify proposal is blocked due to rejections
    var canRelease = await IsReleaseThresholdReachedAsync(proposalId);
    Assert.False(canRelease); // Proposal should be blocked
    
    // Attack: Remove the rejecting members
    await RemoveMemberAsync(organization, member1);
    await RemoveMemberAsync(organization, member2);
    await RemoveMemberAsync(organization, member3);
    
    // Vulnerability: Proposal can now be released despite having been legitimately rejected
    canRelease = await IsReleaseThresholdReachedAsync(proposalId);
    Assert.True(canRelease); // VULNERABILITY: Proposal is no longer blocked
    
    // The proposal can now be released even though it had sufficient rejections
    await ReleaseProposalAsync(proposalId);
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L143-161)
```csharp
    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Rejections.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Reject),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```
