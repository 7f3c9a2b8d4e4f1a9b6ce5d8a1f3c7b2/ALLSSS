# Audit Report

## Title
Missing Upper and Lower Bound Validation for ImpliedIrreversibleBlockHeight in LIB Validation

## Summary
The `LibInformationValidationProvider` lacks critical bound checks on `ImpliedIrreversibleBlockHeight` values submitted by miners during block production. This allows malicious miners to submit values exceeding the current block height or below the confirmed LIB, potentially corrupting the consensus state and firing invalid events, though actual chain LIB setting is partially mitigated.

## Finding Description

The validation logic in `LibInformationValidationProvider` performs incomplete validation of `ImpliedIrreversibleBlockHeight` values. [1](#0-0) 

The validator only checks that the value doesn't decrease relative to the miner's previous value, but fails to enforce two critical bounds:

1. **Upper bound violation**: No check exists to ensure `ImpliedIrreversibleBlockHeight <= Context.CurrentHeight`
2. **Lower bound violation**: No check exists to ensure `ImpliedIrreversibleBlockHeight >= ConfirmedIrreversibleBlockHeight`

The first validation check (lines 14-21) is ineffective for `UpdateValue` behavior because the simplified round created by `GetUpdateValueRound` does not copy the `ConfirmedIrreversibleBlockHeight` or `ConfirmedIrreversibleBlockRoundNumber` fields, causing these fields to default to 0. [2](#0-1) 

During honest block production, miners set `ImpliedIrreversibleBlockHeight` to the current height: [3](#0-2) 

However, malicious miners can modify their node software to submit arbitrary values. When `UpdateValue` transactions are processed, the value is stored directly without bounds checking: [4](#0-3) 

The LIB calculation then uses these potentially invalid values from miners in the previous round to compute the new confirmed LIB height: [5](#0-4) 

If the calculated `libHeight` exceeds the current chain height or contains corrupted values, it is still stored in the consensus state and invalid `IrreversibleBlockFound` events are fired: [6](#0-5) 

## Impact Explanation

**Consensus State Corruption:**
- If 1/3+ malicious miners collude and submit `ImpliedIrreversibleBlockHeight` values exceeding actual block heights, the LIB calculation (which takes the value at position `(count-1)/3` in the sorted list) could produce corrupted results
- The `ConfirmedIrreversibleBlockHeight` field in the consensus contract's state becomes corrupted with invalid heights
- `IrreversibleBlockFound` events fire with invalid heights, potentially misleading downstream systems that consume these events

**Cross-Chain and Finality Issues:**
- Cross-chain verification mechanisms may rely on accurate LIB heights for parent/side-chain indexing
- External systems consuming LIB data without independent validation could be affected by the invalid event data
- Artificially low values (but above the miner's previous value) could stall LIB advancement, delaying finality

**Partial Mitigation:**
The `IrreversibleBlockFoundLogEventProcessor` includes a safety check that prevents the actual chain's LIB from being set to non-existent blocks: [7](#0-6) 

However, this is defense-in-depth only. The primary validation layer should enforce bounds, and the corrupted state values remain stored in the consensus contract even with this mitigation.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an authorized miner in the consensus miner set (semi-trusted role)
- Requires modifying node software to submit invalid `ImpliedIrreversibleBlockHeight` values
- Needs 1/3+ of miners to collude for meaningful impact on the LIB calculation due to the median-based consensus mechanism

**Attack Feasibility:**
- Low technical complexity once miner access is obtained - simply modify the value before submission
- The validation gap is directly reachable through normal `UpdateValue` consensus transactions
- No additional authentication bypass or privilege escalation needed beyond being an authorized miner
- Miners are semi-trusted parties, and compromise or collusion is within the threat model for consensus security analysis

**Detection Challenges:**
- Invalid LIB values stored in consensus state might not be immediately apparent
- The corrupted state persists even though the actual chain LIB is protected by the event processor
- Invalid events could mislead monitoring systems

## Recommendation

Add comprehensive bound validation to `LibInformationValidationProvider.ValidateHeaderInformation()`:

```csharp
// After line 21, add upper bound validation:
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0)
{
    var providedHeight = providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    
    // Upper bound: should not exceed current block height
    if (providedHeight > validationContext.ExtraData.BlockHeight)
    {
        validationResult.Message = $"ImpliedIrreversibleBlockHeight {providedHeight} exceeds current height.";
        return validationResult;
    }
    
    // Lower bound: should be at least as high as confirmed LIB
    if (baseRound.ConfirmedIrreversibleBlockHeight > 0 && 
        providedHeight < baseRound.ConfirmedIrreversibleBlockHeight)
    {
        validationResult.Message = $"ImpliedIrreversibleBlockHeight {providedHeight} below confirmed LIB.";
        return validationResult;
    }
    
    // Existing non-decreasing check
    if (baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight > providedHeight)
    {
        validationResult.Message = "Incorrect implied lib height.";
        return validationResult;
    }
}
```

Additionally, ensure that `GetUpdateValueRound` includes the `ConfirmedIrreversibleBlockHeight` field in the simplified round, or validate against the base round's confirmed LIB before simplification.

## Proof of Concept

```csharp
// Test demonstrating missing validation
[Fact]
public async Task MaliciousMiner_CanSubmit_InvalidImpliedIrreversibleBlockHeight()
{
    // Setup: Initialize consensus with miners
    await InitializeConsensusAsync();
    
    // Current height is 100
    var currentHeight = 100L;
    
    // Malicious miner submits ImpliedIrreversibleBlockHeight = 999999 (far exceeds current height)
    var maliciousUpdateInput = new UpdateValueInput
    {
        ImpliedIrreversibleBlockHeight = 999999L,
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        // ... other required fields
    };
    
    // Execute UpdateValue transaction
    var result = await ConsensusStub.UpdateValue.SendAsync(maliciousUpdateInput);
    
    // Assertion: Transaction succeeds despite invalid height
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify corrupted state is stored
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var minerInfo = currentRound.RealTimeMinersInformation[MinerPublicKey];
    
    // The invalid value is stored in state
    minerInfo.ImpliedIrreversibleBlockHeight.ShouldBe(999999L);
    Assert.True(minerInfo.ImpliedIrreversibleBlockHeight > currentHeight);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-32)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-56)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = pubkey,
                    OutValue = minerInRound.OutValue,
                    Signature = minerInRound.Signature,
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    PreviousInValue = minerInRound.PreviousInValue,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
                    Order = minerInRound.Order,
                    IsExtraBlockProducer = minerInRound.IsExtraBlockProducer
                }
            }
        };
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-281)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockFoundLogEventProcessor.cs (L63-65)
```csharp
            var libBlockHash = await _blockchainService.GetBlockHashByHeightAsync(chain,
                irreversibleBlockFound.IrreversibleBlockHeight, block.GetHash());
            if (libBlockHash == null) return;
```
