# Audit Report

## Title
Cross-Chain Token Property Inconsistency Allows Denial of Service on Cross-Chain Transfers

## Summary
The `CrossChainCreateToken` function fails to update critical token properties when a token already exists on the destination chain, only modifying the ExternalInfo field. This enables an attacker to front-run legitimate cross-chain token deployments by creating tokens with mismatched properties (particularly `IssueChainId`), permanently breaking cross-chain transfer functionality for that token symbol.

## Finding Description

The vulnerability exists in the `CrossChainCreateToken` function's handling of existing tokens. When a token with the target symbol already exists on the destination chain, the function only updates the ExternalInfo field for NFT alias information: [1](#0-0) 

All critical security properties are left unchanged:
- **IssueChainId**: Required for cross-chain transfer validation
- **TotalSupply**: Controls maximum token issuance  
- **Decimals**: Defines token precision
- **Issuer**: Controls who can issue tokens
- **Owner**: Controls token management rights

The `ValidateTokenInfoExists` function explicitly validates all these properties as security-critical, confirming they must match between chains for proper cross-chain operation: [2](#0-1) 

**Attack Vector: Front-Running Cross-Chain Token Creation**

On the main chain (where `State.SideChainCreator.Value == null`), anyone can create tokens by burning seed NFTs: [3](#0-2) 

An attacker can exploit this by:
1. Monitoring for planned cross-chain token deployments
2. Burning a seed NFT to create the token on the main chain with incorrect `IssueChainId`
3. When legitimate `CrossChainCreateToken` is called, it finds the token exists and fails to update properties
4. The `IssueChainId` mismatch permanently breaks cross-chain transfers

The `CrossChainReceiveToken` function enforces strict `IssueChainId` validation, causing all subsequent transfers to fail: [4](#0-3) 

Unlike `CrossChainReceiveToken` which implements replay protection, `CrossChainCreateToken` has no mechanism to track synchronized tokens or prevent multiple calls: [5](#0-4) 

## Impact Explanation

**Critical Cross-Chain Transfer Failure**

When properties diverge between chains (especially `IssueChainId`), the protocol's cross-chain transfer mechanism becomes permanently inoperable for that token:
- Users on the source chain cannot transfer tokens to the destination chain
- Users on the destination chain cannot transfer tokens to the source chain
- The token loses all cross-chain utility, severely limiting its value

**Economic Impact**
- Token holders lose cross-chain functionality and liquidity
- DApps expecting cross-chain operations fail
- DEXs and TokenConverter contracts may operate with incorrect decimal precision
- The cost to the attacker is one seed NFT, making this economically viable for disrupting valuable tokens

**No Recovery Mechanism**

Once a token is created with wrong properties, there is no protocol mechanism to:
- Update the properties to match the legitimate source chain
- Remove the malicious token registration
- Override the existing token data

The `Issue` function also enforces supply constraints based on the local `TotalSupply` value, which may differ from the legitimate chain: [6](#0-5) 

## Likelihood Explanation

**Public Entry Point with Minimal Guards**

`CrossChainCreateToken` is a public function with no authorization checks beyond whitelist registration: [7](#0-6) 

Once the source chain's token contract is registered (a one-time administrative action), anyone can call this function with valid merkle proofs.

**Economically Feasible Attack**

The main chain allows token creation for anyone who burns a seed NFT. The attacker needs to:
1. Obtain a seed NFT for the target symbol (available through the SEED NFT system)
2. Call `Create()` before `CrossChainCreateToken` is called
3. Set malicious properties (wrong `IssueChainId`)

For high-value tokens, the cost of one seed NFT is negligible compared to the disruption caused.

**Test Evidence of Intentional Behavior**

A test explicitly shows this behavior was intentionally changed to "allow" calling `CrossChainCreateToken` when the token exists, but without considering the security implications: [8](#0-7) 

## Recommendation

1. **Add Property Validation**: When a token already exists, validate that all critical properties match the cross-chain data:

```csharp
if (State.TokenInfos[tokenInfo.Symbol] != null)
{
    var existingToken = State.TokenInfos[tokenInfo.Symbol];
    Assert(existingToken.IssueChainId == tokenInfo.IssueChainId, "IssueChainId mismatch");
    Assert(existingToken.TotalSupply == tokenInfo.TotalSupply, "TotalSupply mismatch");
    Assert(existingToken.Decimals == tokenInfo.Decimals, "Decimals mismatch");
    Assert(existingToken.Issuer == tokenInfo.Issuer, "Issuer mismatch");
    Assert(existingToken.Owner == tokenInfo.Owner, "Owner mismatch");
    // Only update ExternalInfo for alias as intended
}
```

2. **Add Replay Protection**: Implement transaction tracking similar to `CrossChainReceiveToken`:

```csharp
Assert(!State.VerifiedCrossChainCreateTransaction[originalTransactionId], "Token already synchronized.");
State.VerifiedCrossChainCreateTransaction[originalTransactionId] = true;
```

3. **Restrict Main Chain Creation**: For tokens intended for cross-chain use, consider restricting `Create()` to require special authorization or coordination with cross-chain registration.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreateToken_PropertyMismatch_Breaks_Transfers()
{
    // Setup: Generate side chain and register contracts
    var sideChainId = await GenerateSideChainAsync();
    await RegisterMainChainTokenContractAddressOnSideChainAsync(sideChainId);
    
    // Step 1: Create legitimate token on side chain
    var symbol = "ATTACK";
    await CreateTokenOnSideChainAsync(symbol, issueChainId: sideChainId);
    
    // Step 2: Attacker front-runs and creates token on main chain with wrong IssueChainId
    await CreateTokenOnMainChainAsync(symbol, issueChainId: MainChainId); // Wrong IssueChainId!
    
    // Step 3: Legitimate CrossChainCreateToken called from side chain to main chain
    await CrossChainCreateTokenFromSideToMain(symbol);
    
    // Step 4: Verify properties are NOT synchronized
    var mainChainToken = await MainChainTokenStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = symbol });
    var sideChainToken = await SideChainTokenStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = symbol });
    Assert.True(mainChainToken.IssueChainId != sideChainToken.IssueChainId); // Properties diverged!
    
    // Step 5: Attempt cross-chain transfer - FAILS due to IssueChainId mismatch
    var transferResult = await AttemptCrossChainTransferAsync(symbol, sideChainId, MainChainId);
    Assert.Contains("Incorrect issue chain id", transferResult.Error);
}
```

**Notes**

This vulnerability demonstrates a critical design flaw in the cross-chain token synchronization mechanism. While the behavior of allowing `CrossChainCreateToken` when a token exists was intentionally implemented (as evidenced by the skipped test), the security implications of property inconsistency were not adequately considered. The attack is particularly concerning because:

1. It permanently disables cross-chain functionality for affected tokens
2. The cost (one seed NFT) is low compared to potential disruption of valuable tokens
3. There is no recovery mechanism once properties diverge
4. The attack can be executed by any user without special privileges

The recommended fixes would restore the cross-chain property consistency guarantee while maintaining the intended NFT alias synchronization functionality.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-88)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
        }

        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };

        if (IsAliasSettingExists(tokenInfo))
        {
            Assert(symbolType == SymbolType.NftCollection, "Token alias can only be set for NFT Item.");
            SetTokenAlias(tokenInfo);
        }

        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L163-166)
```csharp
        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L438-460)
```csharp
    public override Empty ValidateTokenInfoExists(ValidateTokenInfoExistsInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo == null) throw new AssertionException("Token validation failed.");

        var validationResult = tokenInfo.TokenName == input.TokenName &&
                               tokenInfo.IsBurnable == input.IsBurnable && tokenInfo.Decimals == input.Decimals &&
                               tokenInfo.Issuer == input.Issuer && tokenInfo.TotalSupply == input.TotalSupply &&
                               tokenInfo.IssueChainId == input.IssueChainId && tokenInfo.Owner == input.Owner;

        if (tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.Count > 0 ||
            input.ExternalInfo != null && input.ExternalInfo.Count > 0)
        {
            validationResult = validationResult && tokenInfo.ExternalInfo.Value.Count == input.ExternalInfo.Count;
            if (tokenInfo.ExternalInfo.Value.Any(keyPair =>
                    !input.ExternalInfo.ContainsKey(keyPair.Key) || input.ExternalInfo[keyPair.Key] != keyPair.Value))
                throw new AssertionException("Token validation failed.");
        }

        Assert(validationResult, "Token validation failed.");
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-482)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-531)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L596-597)
```csharp
        Assert(!State.VerifiedCrossChainTransferTransaction[transferTransactionId],
            "Token already claimed.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L607-609)
```csharp
        var tokenInfo = AssertValidToken(symbol, amount);
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/MultiTokenContractCrossChainTest.cs (L328-329)
```csharp
    [Fact(Skip = "Now we allow this.")]
    public async Task SideChain_CrossChainCreateToken_WithAlreadyCreated_Test()
```
