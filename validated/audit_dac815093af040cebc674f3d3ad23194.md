# Audit Report

## Title
Missing LIB Upper Bound Validation in NextRound/NextTerm Enables Consensus DOS via Integer Overflow

## Summary
The AEDPoS consensus contract fails to validate Last Irreversible Block (LIB) values in `NextRound` and `NextTerm` behaviors, allowing a malicious miner to inject extreme `ConfirmedIrreversibleBlockHeight` values that bypass all validation mechanisms but eventually trigger checked arithmetic overflow in `GetMaximumBlocksCount()`, permanently halting blockchain consensus.

## Finding Description

The AEDPoS consensus validation architecture employs behavior-specific validation providers. A critical validation gap exists where `LibInformationValidationProvider` is registered only for `UpdateValue` behavior: [1](#0-0) 

The `LibInformationValidationProvider` validates that LIB values cannot move backward: [2](#0-1) 

However, `NextRound` and `NextTerm` behaviors only use validators that check mining order and round termination, neither of which validate LIB bounds: [3](#0-2) [4](#0-3) 

Malicious miners can inject arbitrary LIB values through `NextRoundInput` or `NextTermInput` which contain `ConfirmedIrreversibleBlockHeight` fields: [5](#0-4) 

The malicious round is stored directly to state without upper bound validation: [6](#0-5) 

Post-execution hash validation fails to detect this because `GetCheckableRound()` explicitly excludes LIB fields from hash computation: [7](#0-6) 

Once stored, when the blockchain enters Severe mining status, `GetMaximumBlocksCount()` attempts to compute the distance from current height to the malicious LIB height: [8](#0-7) 

The `Sub()` method uses C#'s `checked` keyword, throwing `OverflowException` on underflow: [9](#0-8) 

**Attack Execution:**
1. Malicious miner waits for NextRound/NextTerm time slot
2. Receives legitimate consensus data from `GetConsensusExtraData`
3. Modifies `ConfirmedIrreversibleBlockHeight = long.MaxValue` before block production
4. Produces signed block with malicious consensus data
5. Block passes validation (no LibInformationValidationProvider check)
6. Malicious round stored to state via `AddRoundInformation`
7. After sufficient rounds, blockchain enters Severe status
8. `GetMaximumBlocksCount()` computes `currentHeight.Sub(long.MaxValue)`, causing `OverflowException`
9. All subsequent consensus transactions fail permanently

## Impact Explanation

**Severity: Critical** - Complete consensus halt with no automatic recovery mechanism.

`GetMaximumBlocksCount()` is invoked during every consensus transaction: [10](#0-9) 

Once the overflow triggers:
- No blocks can be produced by any miner (all consensus transactions throw exceptions)
- Blockchain state is frozen at the point of attack
- Recovery requires hard fork or state rollback to before the malicious round
- Affects entire network, not individual users
- Violates blockchain liveness guarantee

This is a protocol-level availability failure affecting consensus integrity.

## Likelihood Explanation

**Likelihood: Medium-High** given miner access.

**Prerequisites:**
- Attacker must be an active miner in current miner list
- Mainchain: requires election (high barrier but achievable)
- Sidechains: requires configured miner status (potentially lower barrier)

**Attack Feasibility:**
- Once miner status achieved, attack complexity is LOW
- Miners control block content between receiving consensus data and block production
- Single malicious block sufficient to poison consensus state
- No cryptographic commitment over LIB fields prevents modification
- No runtime detection until overflow triggers (potentially rounds/hours later)

**Economic Factors:**
- Compromised miners, exiting miners, or Byzantine actors can execute attack
- Single malicious miner suffices - no coordination required
- No economic penalty prevents this attack

**Exploitability: High** - Architectural validation gap cannot be mitigated by node operators.

## Recommendation

Apply `LibInformationValidationProvider` to `NextRound` and `NextTerm` behaviors:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
}
```

Additionally, consider adding upper bound validation to ensure `ConfirmedIrreversibleBlockHeight` cannot exceed `Context.CurrentHeight + reasonable_threshold`.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousLIB_CausesConsensusHalt()
{
    // Setup: Initialize consensus with normal miners
    await InitializeConsensus();
    
    // Malicious miner produces NextRound with extreme LIB
    var maliciousNextRoundInput = new NextRoundInput
    {
        RoundNumber = 2,
        ConfirmedIrreversibleBlockHeight = long.MaxValue, // MALICIOUS VALUE
        ConfirmedIrreversibleBlockRoundNumber = 1,
        // ... other valid fields
    };
    
    // Block passes validation (no LibInformationValidationProvider)
    await ConsensusStub.NextRound.SendAsync(maliciousNextRoundInput);
    
    // Advance rounds to trigger Severe status
    for (int i = 0; i < 10; i++)
    {
        await ProduceNormalBlock();
    }
    
    // Attempting any consensus transaction now throws OverflowException
    var exception = await Assert.ThrowsAsync<OverflowException>(
        async () => await ProduceNextBlock()
    );
    
    // Verify: GetMaximumBlocksCount causes overflow
    Assert.Contains("Arithmetic operation resulted in an overflow", exception.Message);
    
    // Blockchain is permanently halted - no recovery without hard fork
}
```

The test demonstrates that once a malicious LIB value enters state, the blockchain cannot produce any new blocks due to checked arithmetic overflow in the critical `GetMaximumBlocksCount()` path.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L7-26)
```csharp
public class NextRoundMiningOrderValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L8-48)
```csharp
public class RoundTerminateValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);

        validationResult.Success = true;
        return validationResult;
    }

    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L5-41)
```csharp
public partial class NextRoundInput
{
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }

    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L66-70)
```csharp

        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);

```
