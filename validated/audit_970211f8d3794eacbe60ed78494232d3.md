# Audit Report

## Title
Banned Candidates Can Rejoin Consensus Through Snapshot Replacement Mechanism

## Summary
The Election contract's `GetMinerReplacementInformation()` function fails to filter banned candidates when selecting alternative miners from election snapshots. This allows previously banned evil nodes to rejoin consensus and produce blocks, directly violating the fundamental security guarantee that banned nodes must never participate in block production.

## Finding Description

The vulnerability exists across three interconnected functions in the Election contract that collectively enable banned candidates to bypass the evil node punishment system:

**Root Cause 1: GetNewestPubkey lacks banned validation**

The `GetNewestPubkey()` helper function simply returns the newest pubkey from replacement mappings without checking if that pubkey is banned. [1](#0-0) 

**Root Cause 2: Snapshot processing fails to remove banned candidates**

In `GetPreviousTermSnapshotWithNewestPubkey()`, when processing banned candidates in election snapshots, the function identifies banned candidates and attempts to replace them with their newest pubkeys. [2](#0-1) 

The critical flaw is when `GetNewestPubkey(bannedCandidate)` returns the same banned candidate (because no replacement via `ReplaceCandidatePubkey` occurred after the ban - only `UpdateCandidateInformation` with `IsEvilNode=true` was called), the code executes `continue` at line 154, which **skips removal of the banned candidate from the snapshot**. The banned candidate remains in `snapshot.ElectionResult` with their full vote count intact.

**Root Cause 3: Alternative miner selection doesn't validate banned status**

The `GetMinerReplacementInformation()` function selects alternative candidates from the snapshot without checking `State.BannedPubkeyMap`. [3](#0-2) 

The filtering logic only excludes initial miners and current miners, but has **no check** that `cs.Key` is not banned. This is inconsistent with the fallback logic for initial miners which explicitly filters by banned status. [4](#0-3) 

**Exploitation Path:**

The consensus contract trusts the Election contract's response and directly adds the alternative candidate without verification. [5](#0-4) 

The consensus contract adds `alternativeCandidatePubkey` to the current round and transfers mining rights (expected mining time, order, extra block producer status) without checking if it's banned.

**Attack Scenario:**
1. Term N-1: Candidate P gains votes and appears in election snapshot
2. End of Term N-1: Snapshot taken and stored with P's vote count
3. Term N begins: P elected as miner
4. During Term N: P is detected as evil and banned via `UpdateCandidateInformation(P, IsEvilNode=true)` [6](#0-5) 
5. P is removed from active candidates list but remains in historical Term N-1 snapshot
6. Still in Term N: Another miner M becomes evil, triggering miner replacement
7. Consensus calls `GetMinerReplacementInformation()` during round generation [7](#0-6) 
8. `GetPreviousTermSnapshotWithNewestPubkey()` returns Term N-1 snapshot still containing banned P
9. P is selected as alternative with highest votes after filtering current/initial miners
10. Consensus adds P to the current round, allowing it to produce blocks despite being banned

## Impact Explanation

**HIGH Severity - Consensus Integrity Violation**

This vulnerability directly breaks the critical security invariant that "banned nodes must never participate in consensus." The impact includes:

1. **Evil Node Re-entry**: Malicious actors previously identified and banned can regain consensus participation and block production authority
2. **Punishment Mechanism Bypass**: Completely undermines the evil node detection and punishment system that is fundamental to consensus security
3. **Continued Attacks**: Banned nodes could continue attacking the network (double-signing, censorship, liveness attacks) after detection
4. **Economic Impact**: Block production rewards flow to banned entities that should have been permanently excluded from the Treasury reward distribution
5. **Trust Violation**: Users and honest validators rely on the ban system to protect the network; this vulnerability violates that trust

The banned node gains full mining capabilities including producing blocks, participating in consensus rounds, and earning rewards - identical to a legitimate miner.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood**

The vulnerability has high feasibility because:

1. **Automatic Trigger**: Called automatically by consensus during `GenerateNextRoundInformation()` when evil miners are detected - no special attacker action needed beyond initially being a candidate
2. **Realistic Preconditions**: 
   - Evil miners are regularly detected in production blockchain systems
   - Only requires attacker was a candidate with votes in a previous term snapshot
   - Attacker getting banned is actually part of the trigger path
3. **No Special Permissions**: Attacker needs no privileges beyond having been a candidate with votes
4. **Zero Economic Cost**: No additional transactions or fees required from the attacker after the initial candidacy
5. **Deterministic**: Will occur with certainty when: (a) banned candidate exists in previous term snapshot, (b) another miner is detected as evil and needs replacement, (c) banned candidate was not properly replaced via `ReplaceCandidatePubkey`
6. **Detection Difficulty**: The banned miner appears legitimate in round information; only cross-checking against `BannedPubkeyMap` would reveal the issue

The timing window requires the banned candidate to exist in a retrievable snapshot (previous term) when another miner needs replacement during the current term. Given the natural occurrence of evil node detection in consensus systems, this window is sufficiently large in practice.

## Recommendation

Add banned status validation in `GetMinerReplacementInformation()` when filtering alternative candidates:

```csharp
var maybeNextCandidates = latestSnapshot.ElectionResult
    // Except initial miners.
    .Where(cs =>
        !State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
    // Except current miners.
    .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
    // ADD THIS: Except banned pubkeys.
    .Where(cs => !State.BannedPubkeyMap[cs.Key])
    .OrderByDescending(s => s.Value).ToList();
```

Additionally, fix the removal logic in `GetPreviousTermSnapshotWithNewestPubkey()` to ensure banned candidates are always removed when they have no valid replacement:

```csharp
foreach (var bannedCandidate in bannedCandidates)
{
    var newestPubkey = GetNewestPubkey(bannedCandidate);
    // If newest pubkey exists and is different (not banned), transfer votes.
    if (newestPubkey != null && newestPubkey != bannedCandidate &&
        !snapshot.ElectionResult.ContainsKey(newestPubkey))
    {
        var electionResult = snapshot.ElectionResult[bannedCandidate];
        snapshot.ElectionResult.Add(newestPubkey, electionResult);
    }
    // ALWAYS remove banned candidate from snapshot
    if (snapshot.ElectionResult.ContainsKey(bannedCandidate))
        snapshot.ElectionResult.Remove(bannedCandidate);
}
```

## Proof of Concept

```csharp
[Fact]
public async Task BannedCandidateCanRejoinConsensus_Test()
{
    // Setup: Create candidate P with votes in Term 1
    const string bannedPubkey = "banned_candidate_pubkey";
    await ElectionContractStub.AnnounceElection.SendAsync(new Empty());
    
    // Term 1 ends, snapshot taken with P
    await ElectionContractStub.TakeSnapshot.SendAsync(new TakeElectionSnapshotInput 
    { 
        TermNumber = 1,
        MinedBlocks = 100,
        RoundNumber = 10
    });
    
    // Term 2: P becomes miner then gets banned (no replacement, just marked evil)
    await ElectionContractStub.UpdateCandidateInformation.SendAsync(
        new UpdateCandidateInformationInput
        {
            Pubkey = bannedPubkey,
            IsEvilNode = true  // This sets BannedPubkeyMap[P] = true
        });
    
    // Verify P is banned
    var isBanned = await ElectionContractStub.IsPubkeyBanned.CallAsync(
        new StringValue { Value = bannedPubkey });
    isBanned.Value.ShouldBeTrue();
    
    // Another miner M becomes evil, trigger replacement
    var currentMiners = new List<string> { "miner1", "miner2", "evil_miner_M" };
    var replacementInfo = await ElectionContractStub.GetMinerReplacementInformation
        .CallAsync(new GetMinerReplacementInformationInput 
        { 
            CurrentMinerList = { currentMiners }
        });
    
    // BUG: Banned candidate P appears in alternative candidates
    replacementInfo.AlternativeCandidatePubkeys.ShouldContain(bannedPubkey);
    
    // This banned candidate would be added to consensus round
    // violating the security guarantee that banned nodes cannot participate
}
```

## Notes

The vulnerability requires that:
1. The banned candidate was not replaced via `ReplaceCandidatePubkey` (which would update replacement mappings)
2. The candidate was only banned via `UpdateCandidateInformation` with `IsEvilNode=true` 
3. The banned candidate exists in the previous term's election snapshot (historical data)
4. Another miner needs replacement during the current term

The inconsistency between filtering logic for alternative candidates (no banned check) versus initial miner fallback (explicit banned check) indicates this is an oversight rather than intentional design.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L145-158)
```csharp
        var bannedCandidates = snapshot.ElectionResult.Keys.Where(IsPubkeyBanned).ToList();
        Context.LogDebug(() => $"Banned candidates count: {bannedCandidates.Count}");
        if (!bannedCandidates.Any()) return snapshot;
        Context.LogDebug(() => "Getting snapshot and there's miner replaced during current term.");
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L368-377)
```csharp
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-391)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-305)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-338)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
```
