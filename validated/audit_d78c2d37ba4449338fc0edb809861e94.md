# Audit Report

## Title
Insufficient Validation of ImpliedIrreversibleBlockHeight Allows Miners to Manipulate LIB Calculation

## Summary
The AEDPoS consensus contract fails to validate that `ImpliedIrreversibleBlockHeight` values in `UpdateValue` transactions match `Context.CurrentHeight`, allowing authorized miners to submit arbitrary values that corrupt state and affect Last Irreversible Block (LIB) finality calculations in subsequent rounds.

## Finding Description

The AEDPoS protocol enforces that `ImpliedIrreversibleBlockHeight` equals the current block height during honest consensus data generation. [1](#0-0) 

However, when `UpdateValue` processes miner-provided input, it directly assigns the provided value without validation: [2](#0-1) 

The `UpdateValue` method is publicly accessible to any authorized miner: [3](#0-2) 

The only validation is a monotonicity check that prevents values from decreasing: [4](#0-3) 

**Attack Mechanism:**

A malicious miner can:
1. Generate correct header extra data (containing `ImpliedIrreversibleBlockHeight = Context.CurrentHeight`)
2. Craft a different `UpdateValue` transaction with arbitrary `ImpliedIrreversibleBlockHeight` (e.g., `Context.CurrentHeight + 1000`)
3. Include both in their block

The validation logic fails to detect this because it validates header data, not transaction data:

- **Before execution:** The validation recovers the base round from header data, overwriting it with correct values before checking: [5](#0-4) 

- **After execution:** The validation recovers the current round (which now contains the arbitrary value from the transaction) using header data, then compares the recovered round's hash with itself: [6](#0-5) 

The recovery mechanism masks the state corruption by overwriting local variables with header values, while the arbitrary value persists in stored state.

These manipulated values are then used in subsequent LIB calculations: [7](#0-6) 

## Impact Explanation

**Consensus Integrity Violation:** This breaks the fundamental invariant that `ImpliedIrreversibleBlockHeight` must equal `Context.CurrentHeight`. The corrupted values persist in state and directly affect LIB calculations in the next round.

While the Byzantine-tolerant selection (position `(count-1)/3`) limits single-miner impact, multiple colluding miners below the 1/3 threshold can manipulate LIB values to incorrectly represent block irreversibility. This undermines the finality guarantees that the entire blockchain depends upon.

The validation gap is particularly severe: the recovery mechanism in `ValidateConsensusAfterExecution` creates a false sense of security by masking state corruption during validation while allowing it to persist in storage.

## Likelihood Explanation

**High Likelihood:**
- **Direct Access:** `UpdateValue` is a public method callable by any authorized miner
- **Low Barrier:** Requires only crafting a custom transaction instead of using the generated one
- **No Economic Cost:** No additional fees or penalties beyond normal mining requirements
- **Persistent Effect:** The malicious value is permanently stored and affects subsequent round calculations
- **Validation Bypass:** The monotonicity check is easily satisfied by using any value â‰¥ previous value

## Recommendation

Add explicit validation in `ProcessUpdateValue` to ensure the provided `ImpliedIrreversibleBlockHeight` equals `Context.CurrentHeight`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // Add validation: ImpliedIrreversibleBlockHeight must equal Context.CurrentHeight
    Assert(updateValueInput.ImpliedIrreversibleBlockHeight == Context.CurrentHeight,
        "Implied irreversible block height must equal current height.");

    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    // ... rest of method
}
```

Alternatively, instead of accepting the value from input, always set it to `Context.CurrentHeight` directly in `ProcessUpdateValue`.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_SubmitsArbitraryImpliedIrreversibleBlockHeight_StoresCorruptedValue()
{
    // Setup: Initialize consensus with miners
    await InitializeConsensus();
    var maliciousMiner = SampleAccount.Accounts.First();
    
    // Malicious miner crafts UpdateValueInput with arbitrary ImpliedIrreversibleBlockHeight
    var currentHeight = await GetCurrentHeightAsync();
    var arbitraryHeight = currentHeight + 1000; // Way above Context.CurrentHeight
    
    var maliciousInput = new UpdateValueInput
    {
        OutValue = GenerateOutValue(),
        Signature = GenerateSignature(),
        ImpliedIrreversibleBlockHeight = arbitraryHeight, // Arbitrary value
        // ... other required fields
    };
    
    // Execute malicious UpdateValue transaction
    await MaliciousMinerStub.UpdateValue.SendAsync(maliciousInput);
    
    // Verify: The arbitrary value is stored in state
    var round = await GetCurrentRoundAsync();
    var storedValue = round.RealTimeMinersInformation[maliciousMiner.PublicKey.ToHex()]
        .ImpliedIrreversibleBlockHeight;
    
    // This should fail but currently passes - arbitrary value is stored!
    Assert.Equal(arbitraryHeight, storedValue);
    Assert.NotEqual(currentHeight, storedValue); // Protocol invariant violated
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-33)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```
