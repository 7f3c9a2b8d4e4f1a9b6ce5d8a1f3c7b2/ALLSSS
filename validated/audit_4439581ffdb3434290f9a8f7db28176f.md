# Audit Report

## Title
Non-Member Proposers Can Create Unreleased Proposals, Causing Governance Release Deadlock

## Summary
The Association contract fails to validate that proposers must be organization members during organization creation. This allows non-member proposers to create proposals that members can approve but cannot release, causing permanent governance deadlock when the non-member proposer is unavailable or uncooperative.

## Finding Description

The vulnerability exists in the organization validation logic, which fails to enforce a critical governance invariant: **proposers must be organization members**.

**Validation Gap**: The `Validate` method checks that both `ProposerWhiteList` and `OrganizationMemberList` are non-empty and contain no duplicates, but does NOT verify that proposer addresses must also be organization members. [1](#0-0) 

**Organization Creation**: This insufficient validation is enforced when creating organizations. [2](#0-1) 

**Proposal Creation**: When creating proposals, the contract only verifies the sender is in the `ProposerWhiteList`, not that they are a member. [3](#0-2) [4](#0-3) 

**Voting Mechanism**: Members can vote on any proposal by verifying membership, regardless of who created it. [5](#0-4) [6](#0-5) 

**Release Restriction**: The critical flaw is in the `Release` function, which enforces that ONLY the original proposer can release a proposal, even if members have approved it. [7](#0-6) 

**No Recovery Mechanism**: There is no alternative method to execute proposals. The `ClearProposal` method only removes expired proposals without executing them. [8](#0-7) 

**Attack Path:**
1. Organization is created with `ProposerWhiteList = {NonMemberX}` and `OrganizationMemberList = {MemberA, MemberB, MemberC}`
2. NonMemberX creates a critical governance proposal
3. Members vote and approve the proposal, meeting the release threshold
4. NonMemberX becomes unavailable or refuses to call `Release()`
5. The approved proposal can never be executed, causing permanent governance deadlock

## Impact Explanation

**HIGH Severity - Governance DoS:**
- Critical approved governance actions cannot be executed if the non-member proposer is unavailable
- Members lose effective control over their organization despite having voting power
- Can permanently block critical operations like threshold changes, member management, or fund transfers via methods like `ChangeOrganizationThreshold`, `AddMember`, `RemoveMember` [9](#0-8) 
- Time-sensitive proposals may expire before resolution
- Malicious proposers can hold organizations hostage for extortion

This breaks the fundamental governance invariant that organizations should be able to execute their approved proposals. The ACS3 standard defines Release as a core governance operation, but the implementation allows configurations where approved proposals become permanently stuck. [10](#0-9) 

## Likelihood Explanation

**HIGH Likelihood:**
- The `CreateOrganization` method is publicly accessible [11](#0-10) 
- The validation explicitly allows non-member proposers [12](#0-11) 
- Can occur through accidental misconfiguration or intentional malicious setup
- No special privileges required beyond being included in the proposer whitelist
- Zero-cost to exploit once the vulnerable configuration exists
- Economically rational for extortion scenarios

## Recommendation

Add validation to ensure all proposers are also organization members. Modify the `Validate` method in `Association_Helper.cs`:

```csharp
private bool Validate(Organization organization)
{
    if (organization.ProposerWhiteList.Empty() ||
        organization.ProposerWhiteList.AnyDuplicate() ||
        organization.OrganizationMemberList.Empty() ||
        organization.OrganizationMemberList.AnyDuplicate())
        return false;
    
    // NEW: Ensure all proposers are also members
    if (organization.ProposerWhiteList.Proposers.Any(proposer => 
        !organization.OrganizationMemberList.Contains(proposer)))
        return false;
        
    if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
        return false;
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    var organizationMemberCount = organization.OrganizationMemberList.Count();
    return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
}
```

Alternatively, allow any member to release approved proposals instead of restricting it to the proposer only.

## Proof of Concept

```csharp
[Fact]
public async Task NonMemberProposer_CausesGovernanceDeadlock_Test()
{
    // Setup: Create organization with non-member proposer
    var nonMemberProposer = Accounts[10].Address; // Not in member list
    var member1 = Reviewer1;
    var member2 = Reviewer2;
    var member3 = Reviewer3;
    
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { member1, member2, member3 }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 2,
            MinimalVoteThreshold = 2,
            MaximalAbstentionThreshold = 1,
            MaximalRejectionThreshold = 1
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { nonMemberProposer } // Non-member proposer
        }
    };
    
    // Step 1: Organization creation succeeds (vulnerability)
    var organizationAddress = await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    organizationAddress.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 2: Non-member creates proposal
    var proposalId = await CreateProposalAsync(AssociationContractStub, organizationAddress.Output, nonMemberProposer);
    
    // Step 3: Members approve the proposal
    await ApproveAsync(AssociationContractStubReviewer1, proposalId);
    await ApproveAsync(AssociationContractStubReviewer2, proposalId);
    
    // Verify proposal is ready to release
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeTrue();
    
    // Step 4: Members cannot release (only proposer can)
    var memberReleaseResult = await AssociationContractStubReviewer1.Release.SendWithExceptionAsync(proposalId);
    memberReleaseResult.TransactionResult.Error.ShouldContain("No permission");
    
    // Step 5: If non-member proposer is unavailable, proposal is stuck forever
    // This demonstrates the governance deadlock - approved proposal cannot be executed
}
```

## Notes

This vulnerability is specific to the Association contract's design choice to separate `ProposerWhiteList` from `OrganizationMemberList`. The Parliament contract handles this differently by allowing members to be proposers when `ParliamentMemberProposingAllowed` is true. [13](#0-12) 

The vulnerability can be triggered through normal contract usage without any special permissions, making it a realistic threat to any Association-based governance system that misconfigures proposer and member lists.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-128)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-280)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }

    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }

    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }

    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }

    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** protobuf/acs3.proto (L38-40)
```text
    // Release a proposal according to the proposal ID and send a transaction to the specified contract.
    rpc Release(aelf.Hash) returns (google.protobuf.Empty){
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```
