# Audit Report

## Title
Cross-Chain Indexing Controller Change Prevents Legitimate Proposal Release

## Summary
The `GetIndexingProposalStatus()` view function incorrectly marks approved cross-chain indexing proposals as not releasable when the CrossChainIndexingController is changed after proposal creation. This causes a denial-of-service condition where legitimately approved proposals cannot be automatically released, blocking critical cross-chain data indexing functionality until proposals expire.

## Finding Description

The vulnerability exists in the `GetIndexingProposalStatus()` function which determines whether pending cross-chain indexing proposals should be released automatically. [1](#0-0) 

The root cause is that this function requires BOTH conditions to be true for a proposal to be marked as releasable: (1) the proposal must be approved by the authorization contract, AND (2) the proposal's organization address must match the CURRENT controller's owner address.

When a cross-chain indexing proposal is created via `ProposeCrossChainBlockData`, it uses the current controller's OwnerAddress as the proposal's OrganizationAddress. [2](#0-1) 

However, the CrossChainIndexingController can be changed at any time via `ChangeCrossChainIndexingController`, which has no checks for pending proposals and no mechanism to handle or migrate them. [3](#0-2) 

When the controller changes after proposal creation but before release, the organization address mismatch causes `GetIndexingProposalStatus` to return `ToBeReleased = false` even for proposals that were legitimately approved by their original organization.

The automatic release mechanism relies on this view function. The service layer calls `GetIndexingProposalStatus` and then filters proposals where `ToBeReleased = true` to determine which proposals should be released. [4](#0-3) 

When `ToBeReleased` is incorrectly set to false, the proposal is filtered out and never gets released automatically. [5](#0-4) 

## Impact Explanation

This vulnerability causes a denial-of-service condition affecting critical cross-chain protocol functionality:

1. **Blocked Cross-Chain Communication**: Approved cross-chain indexing proposals become permanently stuck and cannot be released through the normal automatic mechanism. The affected chain's cross-chain data cannot be indexed, preventing verification of cross-chain transactions and merkle proofs.

2. **Operational Disruption**: Parent-chain or side-chain block data remains unindexed, breaking the cross-chain communication flow until the proposal expires and a new one must be created with the new controller.

3. **Resource Waste**: Originally approved proposals that consumed governance resources (voting time, miner participation, approval quorum) become unusable and must be abandoned.

4. **Widespread Impact**: All chains with pending approved proposals at the time of controller change are affected simultaneously, potentially causing system-wide cross-chain indexing failure.

The severity is HIGH because cross-chain indexing is essential for maintaining the integrity of parent-chain and side-chain communication, which is a core protocol invariant.

## Likelihood Explanation

This vulnerability has HIGH likelihood of occurrence:

1. **Reachable Entry Point**: `ChangeCrossChainIndexingController` is a legitimate public governance function accessible through normal Parliament operations.

2. **Feasible Preconditions**: 
   - Requires pending cross-chain indexing proposals (normal operational state during active cross-chain communication)
   - Requires controller change through governance (legitimate action for updating governance structure)
   - No special attacker capabilities needed

3. **No Protection**: The controller change function has no checks for pending proposals and no mechanism to migrate or handle them. [3](#0-2) 

4. **Accidental Trigger**: This can occur accidentally during normal governance operations without malicious intent. The conflict between controller changes and pending proposals has no coordination mechanism.

## Recommendation

Add a check in `ChangeCrossChainIndexingController` to prevent controller changes when there are pending cross-chain indexing proposals, or implement a migration mechanism that transfers pending proposals to the new controller's organization. The check should verify that `State.IndexingPendingProposal.Value` is either null or has no pending proposals before allowing the controller change.

Alternatively, modify `GetIndexingProposalStatus()` to check if the proposal belongs to ANY valid historical controller, not just the current one, and maintain a list of valid controller addresses over time.

## Proof of Concept

```csharp
[Fact]
public async Task ControllerChange_BlocksApprovedProposal()
{
    // 1. Initialize and create side chain
    var parentChainId = 123;
    var sideChainId = await InitAndCreateSideChainAsync(parentChainId);
    
    // 2. Propose cross-chain data
    var crossChainBlockData = new CrossChainBlockData
    {
        SideChainBlockDataList = { CreateSideChainBlockData(HashHelper.ComputeFrom("hash"), 1, sideChainId, HashHelper.ComputeFrom("root")) }
    };
    await CrossChainContractStub.ProposeCrossChainIndexing.SendAsync(crossChainBlockData);
    
    // 3. Approve the proposal
    var status = await CrossChainContractStub.GetIndexingProposalStatus.CallAsync(new Empty());
    var proposalId = status.ChainIndexingProposalStatus[sideChainId].ProposalId;
    await ApproveWithMinersAsync(proposalId);
    
    // 4. Verify proposal is releasable BEFORE controller change
    var statusBefore = await CrossChainContractStub.GetIndexingProposalStatus.CallAsync(new Empty());
    Assert.True(statusBefore.ChainIndexingProposalStatus[sideChainId].ToBeReleased);
    
    // 5. Change controller
    var oldController = await CrossChainContractStub.GetCrossChainIndexingController.CallAsync(new Empty());
    var newOrgAddress = (await ParliamentContractStub.CreateOrganization.SendAsync(new CreateOrganizationInput { ... })).Output;
    var changeProposal = await ParliamentContractStub.CreateProposal.SendAsync(new CreateProposalInput
    {
        ContractMethodName = nameof(CrossChainContractStub.ChangeCrossChainIndexingController),
        Params = new AuthorityInfo { ContractAddress = ParliamentContractAddress, OwnerAddress = newOrgAddress }.ToByteString(),
        ToAddress = CrossChainContractAddress,
        OrganizationAddress = oldController.OwnerAddress
    });
    await ApproveWithMinersAsync(Hash.Parser.ParseFrom(changeProposal.TransactionResult.ReturnValue));
    await ParliamentContractStub.Release.SendAsync(Hash.Parser.ParseFrom(changeProposal.TransactionResult.ReturnValue));
    
    // 6. Verify proposal is NO LONGER releasable AFTER controller change (BUG)
    var statusAfter = await CrossChainContractStub.GetIndexingProposalStatus.CallAsync(new Empty());
    Assert.False(statusAfter.ChainIndexingProposalStatus[sideChainId].ToBeReleased); // Approved proposal now blocked!
}
```

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L177-179)
```csharp
            pendingChainIndexingProposalStatus.ToBeReleased =
                proposalInfo.ToBeReleased &&
                proposalInfo.OrganizationAddress == crossChainIndexingController.OwnerAddress;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L409-409)
```csharp
                    OrganizationAddress = crossChainIndexingController.OwnerAddress,
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L61-74)
```csharp
    public override Empty ChangeCrossChainIndexingController(AuthorityInfo input)
    {
        AssertCrossChainIndexingControllerAuthority(Context.Sender);
        SetContractStateRequired(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);
        Assert(
            input.ContractAddress == State.ParliamentContract.Value &&
            ValidateParliamentOrganization(input.OwnerAddress), "Invalid authority input.");
        State.CrossChainIndexingController.Value = input;
        Context.Fire(new CrossChainIndexingControllerChanged
        {
            AuthorityInfo = input
        });
        return new Empty();
    }
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataService.cs (L89-103)
```csharp
        var toBeReleasedChainIdList = FindToBeReleasedChainIdList(indexingProposalStatusList, utcNow);

        if (toBeReleasedChainIdList.Count > 0)
        {
            // release pending proposal and unable to propose anything if it is ready
            _transactionInputForBlockMiningDataProvider.AddTransactionInputForBlockMining(blockHash,
                new CrossChainTransactionInput
                {
                    PreviousBlockHeight = blockHeight,
                    MethodName =
                        nameof(CrossChainContractImplContainer.CrossChainContractImplStub
                            .ReleaseCrossChainIndexingProposal),
                    Value = new ReleaseCrossChainIndexingProposalInput { ChainIdList = { toBeReleasedChainIdList } }
                        .ToByteString()
                });
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataService.cs (L373-378)
```csharp
    private List<int> FindToBeReleasedChainIdList(
        GetIndexingProposalStatusOutput pendingChainIndexingProposalStatusList, Timestamp timestamp)
    {
        return pendingChainIndexingProposalStatusList.ChainIndexingProposalStatus
            .Where(pair => pair.Value.ToBeReleased && pair.Value.ExpiredTime > timestamp).Select(pair => pair.Key)
            .ToList();
```
