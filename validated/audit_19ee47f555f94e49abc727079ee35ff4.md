# Audit Report

## Title
Inconsistent Vote Counting Allows Governance Bypass Through Member Removal

## Summary
The Association contract's vote threshold checking logic contains a critical inconsistency where individual vote type counts (approvals, rejections, abstentions) are filtered by current organization membership, but the total vote count for `MinimalVoteThreshold` validation includes all votes regardless of membership status. This allows organizations to bypass rejection and abstention thresholds by removing dissenting members after they have voted.

## Finding Description

The vulnerability exists in the vote counting implementation within the `CheckEnoughVoteAndApprovals` helper function and related validation methods.

**Rejection Count - Filtered by Current Membership:** [1](#0-0) 

**Abstention Count - Filtered by Current Membership:** [2](#0-1) 

**Approval Count - Filtered by Current Membership:** [3](#0-2) 

**Total Vote Count - NOT Filtered:** [4](#0-3) 

The total vote count simply concatenates and counts all addresses from the three vote lists without filtering by current membership. This creates an exploitable inconsistency.

**Attack Vector Enabled by RemoveMember:** [5](#0-4) 

The `RemoveMember` function can only be called by the organization itself (requires `Context.Sender` to be the organization address), meaning it must be executed through an approved proposal. Once members are removed, their votes on existing proposals are handled inconsistently:
- Their rejections/abstentions are excluded from threshold checks (filtered out)
- Their votes still count toward the `MinimalVoteThreshold` (not filtered)

**Attack Sequence:**
1. Organization with 10 members, thresholds: MinimalApprovalThreshold=5, MinimalVoteThreshold=8, MaximalRejectionThreshold=2
2. Malicious proposal P1 receives: 5 approvals, 4 rejections (total: 9 votes)
3. P1 cannot be released because rejectionCount (4) > MaximalRejectionThreshold (2)
4. Majority creates and passes proposal P2 to remove the 4 rejecting members
5. After removal, P1's status changes:
   - Approvals (filtered): 5 (still members) ≥ 5 ✓
   - Rejections (filtered): 0 (removed members don't count) ≤ 2 ✓
   - Total votes (unfiltered): 9 (all votes still count) ≥ 8 ✓
6. P1 can now be released despite originally being rejected

The release method checks these thresholds: [6](#0-5) 

## Impact Explanation

This vulnerability enables **governance capture** through threshold manipulation. The Association contract's safety mechanism relies on rejection and abstention thresholds to protect minority interests and prevent malicious proposals. By exploiting this inconsistency, a controlling majority can:

1. **Bypass Rejection Thresholds**: Execute proposals that should be blocked by dissenting votes
2. **Undermine Minority Protection**: Remove the votes of members who oppose dangerous actions
3. **Circumvent Governance Intent**: Release proposals that failed legitimate voting requirements

The impact is HIGH because:
- It allows execution of unauthorized proposals (fund transfers, parameter changes, etc.)
- It breaks the fundamental governance invariant that threshold checks represent actual member votes
- All Association-based organizations are affected
- The attack leaves proposals appearing to meet thresholds despite being legitimately rejected

## Likelihood Explanation

**Attacker Requirements:**
- Control sufficient members to pass a member removal proposal (≥ MinimalApprovalThreshold)
- Ability to coordinate two proposals: the malicious proposal and the removal proposal

**Feasibility: HIGH**
- All operations use public, standard contract methods
- No special privileges required beyond normal member voting rights
- Member removal is a legitimate governance operation that may not raise suspicion
- Attack complexity is MEDIUM (requires coordination but no technical sophistication)

**Realistic Scenarios:**
1. Organizations with narrow majorities (e.g., 6/10 members) wanting to bypass minority protections
2. Contentious proposals that receive legitimate rejections
3. Gradual member removals that accumulate exploitable discrepancies

**Detection Difficulty:**
The exploit manifests as normal governance operations (member changes, proposal releases), making it difficult to detect without specific monitoring of the relationship between member changes and proposal vote counts.

## Recommendation

The fix should ensure consistent filtering across all vote count checks. Modify the `CheckEnoughVoteAndApprovals` function to filter the total vote count by current membership:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter total vote count by current membership
    var totalVoteCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
                        proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
                        proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached =
        totalVoteCount >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

This ensures that only votes from current members count toward all thresholds, maintaining consistency and preventing governance bypass through member removal.

## Proof of Concept

```csharp
[Fact]
public async Task VoteCountingInconsistency_AllowsGovernanceBypass_Test()
{
    // Setup: Create organization with 10 members
    // Thresholds: MinimalApproval=5, MinimalVote=8, MaximalRejection=2
    var members = new[] { Reviewer1, Reviewer2, Reviewer3, 
                         Accounts[4].Address, Accounts[5].Address, Accounts[6].Address,
                         Accounts[7].Address, Accounts[8].Address, Accounts[9].Address, 
                         Accounts[10].Address };
    
    var organizationAddress = await CreateOrganizationAsync(5, 8, 0, 2, Reviewer1);
    
    // Step 1: Create malicious proposal P1
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // Step 2: P1 receives 5 approvals
    await ApproveAsync(Reviewer1KeyPair, proposalId);
    await ApproveAsync(Reviewer2KeyPair, proposalId);
    await ApproveAsync(Reviewer3KeyPair, proposalId);
    await ApproveAsync(Accounts[4].KeyPair, proposalId);
    await ApproveAsync(Accounts[5].KeyPair, proposalId);
    
    // Step 3: P1 receives 4 rejections
    await RejectAsync(Accounts[6].KeyPair, proposalId);
    await RejectAsync(Accounts[7].KeyPair, proposalId);
    await RejectAsync(Accounts[8].KeyPair, proposalId);
    await RejectAsync(Accounts[9].KeyPair, proposalId);
    
    // Verify P1 cannot be released (4 rejections > MaximalRejectionThreshold of 2)
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeFalse();
    
    // Step 4: Create and pass proposal P2 to remove 4 rejecting members
    var removeProposals = new List<Hash>();
    foreach (var rejectingMember in new[] { Accounts[6].Address, Accounts[7].Address, 
                                           Accounts[8].Address, Accounts[9].Address })
    {
        var removeProposalId = await CreateAssociationProposalAsync(
            Reviewer1KeyPair, rejectingMember, 
            nameof(AssociationContractStub.RemoveMember), organizationAddress);
        
        // Get 5 approvals to pass removal
        await ApproveAsync(Reviewer1KeyPair, removeProposalId);
        await ApproveAsync(Reviewer2KeyPair, removeProposalId);
        await ApproveAsync(Reviewer3KeyPair, removeProposalId);
        await ApproveAsync(Accounts[4].KeyPair, removeProposalId);
        await ApproveAsync(Accounts[5].KeyPair, removeProposalId);
        
        // Release removal proposal
        var releaseResult = await GetAssociationContractTester(Reviewer1KeyPair)
            .Release.SendAsync(removeProposalId);
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    }
    
    // Step 5: VULNERABILITY - P1 can now be released despite being rejected
    // Rejections (filtered): 0 (removed members) ≤ 2 ✓
    // Total votes (unfiltered): 9 (still counts all votes) ≥ 8 ✓
    proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeTrue(); // This should be FALSE but is TRUE due to the bug
    
    // P1 can be released
    var releaseP1 = await GetAssociationContractTester(Reviewer1KeyPair)
        .Release.SendAsync(proposalId);
    releaseP1.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-38)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-44)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-50)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
