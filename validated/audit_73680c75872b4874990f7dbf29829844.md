# Audit Report

## Title
DOS Attack via Empty Period Creation Permanently Blocks Profit Claiming for Early Beneficiaries

## Summary
A malicious TokenHolder scheme manager can create empty distribution periods by repeatedly calling `DistributeProfits` with null or empty `AmountsMap`. This causes beneficiaries to become permanently unable to claim profits because the claiming logic skips empty periods without advancing their `LastProfitPeriod` marker, creating an insurmountable barrier that prevents access to both past and future profit distributions.

## Finding Description

The vulnerability stems from a critical flaw in how the profit claiming mechanism handles empty distribution periods created through the TokenHolder contract.

**Attack Vector:**

The scheme manager is authorized to call `DistributeProfits` without validation preventing empty distributions. [1](#0-0)  When `AmountsMap` is null or empty, the function conditionally adds amounts but always proceeds to call the Profit contract and increment the period counter. [2](#0-1) 

**Empty Period Creation:**

In `ProfitContract.DistributeProfits`, when the input has an empty `AmountsMap` and the scheme has no `ReceivedTokenSymbols` yet, the `profitsMap` dictionary remains empty. [3](#0-2)  Despite this, `UpdateDistributedProfits` is called and creates a `DistributedProfitsInfo` record with `IsReleased = true`, empty `AmountsMap`, but non-zero `TotalShares`. [4](#0-3)  The scheme's period counter is then incremented. [5](#0-4) 

**DOS Mechanism:**

When beneficiaries attempt to claim profits via `ProfitAllPeriods`, the function initializes `lastProfitPeriod` to the beneficiary's current `LastProfitPeriod`. [6](#0-5)  It then loops through periods, but critically, when it encounters an empty period (where `AmountsMap` is empty), it executes a `continue` statement. [7](#0-6) 

The problem is that the line updating `lastProfitPeriod = period + 1` appears AFTER the `continue` statement. [8](#0-7)  This means for empty periods, the update never executes. After the loop completes processing up to `maxProfitReceivingPeriodCount` periods (default 100), [9](#0-8)  the beneficiary's `LastProfitPeriod` is set to the unchanged `lastProfitPeriod` value. [10](#0-9) 

**Attack Execution:**
1. Attacker creates a TokenHolder scheme via `CreateScheme` [11](#0-10) 
2. Adds beneficiaries to establish non-zero `TotalShares`
3. Before any contributions, calls `DistributeProfits` 1000 times with null `AmountsMap`
4. Each call creates one empty period (periods 1-1000 are now empty)
5. Later legitimate distributions at period 1001+ become unreachable
6. Beneficiaries attempting to claim process 100 empty periods per transaction without progress
7. Their `LastProfitPeriod` remains stuck at period 1 permanently

## Impact Explanation

This vulnerability creates a **permanent denial of service** for profit claiming with the following consequences:

**Permanent Loss of Rewards:**
- Beneficiaries with `StartPeriod` values within or before the empty period range cannot advance their claiming position
- Each claim transaction processes up to 100 periods but makes zero progress through empty periods
- Even if legitimate distributions occur in future periods, beneficiaries can never reach them

**No Recovery Mechanism:**
- No function exists to skip empty periods or reset `LastProfitPeriod`
- Beneficiaries are permanently locked out of the reward system
- Tokens locked by users for profit-sharing become worthless as rewards are inaccessible

**Complete Scheme Dysfunction:**
- The TokenHolder scheme becomes completely non-functional for early participants
- New beneficiaries added after the empty periods may not be affected, but early ones are permanently DOS'd
- The attack affects the core functionality of the staking/reward mechanism

The severity is **HIGH** because it results in permanent, irreversible denial of earned rewards for all early beneficiaries, with no recovery path.

## Likelihood Explanation

The likelihood of this attack is **HIGH** due to:

**Low Barrier to Entry:**
- Any user can create a TokenHolder scheme and become the scheme manager [11](#0-10) 
- The manager role is not a privileged position requiring special permissions
- Creation and management of schemes is a standard protocol feature

**Trivial Attack Execution:**
- The attack requires only repeated calls to `DistributeProfits` with empty input
- No complex transaction sequences or timing requirements
- Each call costs minimal gas (just the transaction fee)
- Can create thousands of empty periods for negligible cost

**Lack of Protective Measures:**
- No validation prevents `DistributeProfits` calls with empty `AmountsMap`
- No rate limiting on distribution frequency
- No maximum empty period detection or prevention
- The authorization check permits the manager to make these calls [1](#0-0) 

## Recommendation

Add validation in `TokenHolderContract.DistributeProfits` to prevent empty distributions:

```csharp
public override Empty DistributeProfits(DistributeProfitsInput input)
{
    var scheme = GetValidScheme(input.SchemeManager, true);
    Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
           Context.Sender == input.SchemeManager, "No permission to distribute profits.");
    
    // Add validation to prevent empty distributions
    Assert(input.AmountsMap != null && input.AmountsMap.Any(), "Cannot distribute empty profits.");
    
    var distributeProfitsInput = new Profit.DistributeProfitsInput
    {
        SchemeId = scheme.SchemeId,
        Period = scheme.Period
    };
    distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

    State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
    scheme.Period = scheme.Period.Add(1);
    State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
    return new Empty();
}
```

Additionally, fix the `ProfitAllPeriods` method to always update `lastProfitPeriod` even for empty periods:

```csharp
for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
{
    // ... existing code ...
    
    if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
        !distributedProfitsInformation.AmountsMap.Any() ||
        !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
    {
        lastProfitPeriod = period + 1; // Update before continue
        continue;
    }
    
    // ... rest of processing ...
    lastProfitPeriod = period + 1;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task EmptyPeriod_DOS_Attack_Test()
{
    // 1. Attacker creates TokenHolder scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });
    
    // 2. Add a beneficiary with non-zero shares
    var beneficiary = Accounts[1].Address;
    await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = beneficiary,
        Shares = 100
    });
    
    // 3. Attacker creates 1000 empty periods
    for (int i = 0; i < 1000; i++)
    {
        await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeManager = DefaultSender,
            AmountsMap = { } // Empty map
        });
    }
    
    // 4. Add legitimate distribution at period 1001
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = DefaultSender,
        Symbol = "ELF",
        Amount = 1000000
    });
    await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeManager = DefaultSender,
        AmountsMap = { {"ELF", 1000000} }
    });
    
    // 5. Beneficiary attempts to claim - will process 100 empty periods with no progress
    var profitsBefore = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = beneficiary
    });
    
    await TokenHolderContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeManager = DefaultSender,
        Beneficiary = beneficiary
    });
    
    var profitsAfter = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = beneficiary
    });
    
    // Verify LastProfitPeriod did NOT advance (still at period 1)
    profitsAfter.Details[0].LastProfitPeriod.ShouldBe(profitsBefore.Details[0].LastProfitPeriod);
    // Beneficiary is permanently stuck and cannot reach period 1001
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L134-135)
```csharp
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L141-145)
```csharp
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L432-460)
```csharp
        var profitsMap = new Dictionary<string, long>();
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L849-849)
```csharp
        var lastProfitPeriod = profitDetail.LastProfitPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L868-871)
```csharp
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L908-908)
```csharp
                    lastProfitPeriod = period + 1;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L917-917)
```csharp
        profitDetail.LastProfitPeriod = lastProfitPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L9-9)
```csharp
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
```
