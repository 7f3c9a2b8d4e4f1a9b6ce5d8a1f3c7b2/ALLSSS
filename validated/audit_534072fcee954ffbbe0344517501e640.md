# Audit Report

## Title
Evil Miner Detection Bypass via Unvalidated MissedTimeSlots Manipulation in NextRound Transaction

## Summary
The AEDPoS consensus contract accepts user-provided `NextRoundInput` containing `MissedTimeSlots` values without validation, storing manipulated data directly to state. This allows malicious miners acting as extra block producers to reduce their missed time slot counter, bypassing the evil miner detection threshold and avoiding removal from consensus.

## Finding Description

The vulnerability exists in the round transition flow where `ProcessNextRound()` stores user-provided round data before evil miner detection takes effect on that data.

**Root Cause:**

The `ProcessNextRound()` function converts user-provided `NextRoundInput` to a `Round` object, retrieves the current round from state, performs evil miner detection on the **current** round (not the next round being submitted), then stores the next round containing potentially manipulated data to state. [1](#0-0) 

Evil miner detection checks whether `MissedTimeSlots >= TolerableMissedTimeSlotsCount`: [2](#0-1) [3](#0-2) 

**Why Validation Fails:**

The before-execution validation adds providers for NextRound behavior: [4](#0-3) 

However, `NextRoundMiningOrderValidationProvider` only validates `FinalOrderOfNextRound`: [5](#0-4) 

And `RoundTerminateValidationProvider` only validates round number and InValue fields: [6](#0-5) 

**Neither validator checks MissedTimeSlots correctness.**

The after-execution validation compares round hashes: [7](#0-6) 

However, since `ProcessNextRound` already stored the manipulated round to state at line 156, both the header round and state round contain the same manipulated data at validation time (line 87 retrieves the newly stored round), causing the hashes to match.

**Data Flow:**

The `NextRoundInput` includes full `RealTimeMinersInformation` containing all `MissedTimeSlots`: [8](#0-7) [9](#0-8) 

When generating next round information correctly (off-chain), `MissedTimeSlots` is incremented for miners who didn't mine: [10](#0-9) 

**Attack Sequence:**

1. Malicious miner with high `MissedTimeSlots` (e.g., 4300, approaching threshold of 4320) is selected as extra block producer
2. Miner calls `GenerateConsensusTransactions` off-chain to obtain correct `NextRoundInput`
3. Miner manually modifies `NextRoundInput.RealTimeMinersInformation[their_pubkey].MissedTimeSlots` to a lower value (e.g., 100)
4. Miner submits modified transaction
5. Transaction passes validation (no `MissedTimeSlots` validation exists)
6. `ProcessNextRound` executes, detecting evil miners in **current** round (old data), then storing manipulated **next** round
7. In subsequent round transition, evil detection checks the manipulated round, failing to detect the attacker

## Impact Explanation

**Severity: HIGH**

This vulnerability breaks a critical consensus integrity invariant. The evil miner detection mechanism is designed to remove underperforming miners who miss their assigned time slots. The 3-day tolerance window (4320 time slots at 1 minute per slot) is completely bypassed.

**Concrete Impact:**
- Evil miners can avoid being flagged as evil nodes by resetting their `MissedTimeSlots` counter
- The Election Contract update is bypassed: [11](#0-10) 

- Malicious miners continue participating in consensus despite poor performance
- Network reliability degrades as unreliable miners remain active
- Honest miners bear increased burden when evil miners fail to produce blocks
- The consensus mechanism's self-healing property is undermined

## Likelihood Explanation

**Probability: MEDIUM-HIGH**

**Attacker Prerequisites:**
- Must be a current miner in the consensus set
- Must accumulate high `MissedTimeSlots` (indicating poor performance)
- Must be selected as extra block producer to trigger NextRound behavior

The extra block producer selection is determined by signature-based randomness, not by `MissedTimeSlots` values. Over time, any miner will eventually be selected as extra block producer with sufficient probability.

**Attack Complexity: LOW**
- Attacker simply modifies a single field in transaction data before submission
- No complex timing requirements or race conditions
- No need to compromise other system components

**Detection Difficulty: HIGH**
- Manipulation occurs in transaction data without on-chain validation
- No audit trail to reveal discrepancy between expected and actual values
- Once stored to state, manipulated data becomes canonical truth

**Repeatability:**
- Attack can be executed each time attacker is selected as extra block producer
- No economic disincentive (only normal transaction fees)

## Recommendation

Implement validation of `MissedTimeSlots` values in `NextRoundInput` by comparing them against the expected values based on the current round state. Add a new validation provider that:

1. Retrieves the current round's `MissedTimeSlots` for each miner
2. Verifies that next round's `MissedTimeSlots` values are correctly incremented (by 1 for miners who didn't mine, or unchanged for miners who did mine)
3. Rejects transactions with manipulated `MissedTimeSlots` values

Alternatively, remove `MissedTimeSlots` from user-provided input entirely and calculate it on-chain based on the current round state during `ProcessNextRound`.

## Proof of Concept

A proof of concept would demonstrate:
1. Setting up a miner with `MissedTimeSlots = 4300` (near threshold of 4320)
2. Having that miner selected as extra block producer
3. Generating a valid `NextRoundInput` transaction off-chain
4. Modifying `RealTimeMinersInformation[miner_pubkey].MissedTimeSlots` to `100`
5. Submitting the transaction and verifying it executes successfully
6. Verifying the state now contains `MissedTimeSlots = 100` for that miner
7. In the next round transition, verifying the miner is not detected as evil despite having previously exceeded the threshold

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L39-56)
```csharp
        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```
