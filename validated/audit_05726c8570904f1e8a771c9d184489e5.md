# Audit Report

## Title
Time-of-Check-Time-of-Use Vulnerability in Proposal Rejection Count Allows Governance Bypass Through Member Manipulation

## Summary
The Association contract's `IsProposalRejected()` function recalculates rejection counts using the current organization membership at release time rather than a snapshot from voting time. This allows attackers to retroactively invalidate legitimate proposal rejections by removing rejecting members between voting and release, enabling execution of proposals that were explicitly rejected by the organization.

## Finding Description

The vulnerability exists in the rejection validation mechanism during proposal release. When a member casts a rejection vote, their address is added to the proposal's rejection list [1](#0-0) . However, when the proposal is later released, the rejection count is recalculated by filtering this rejection list against the **current** organization membership [2](#0-1) .

The critical flaw is in the rejection count calculation: `proposal.Rejections.Count(organization.OrganizationMemberList.Contains)`. This uses the current state of `organization.OrganizationMemberList` rather than the membership state at the time votes were cast. The `Contains` method checks membership against the live organization member list [3](#0-2) .

Organization membership can be modified through the `RemoveMember` function, which can only be called by the organization itself via proposal execution [4](#0-3) . This creates a TOCTOU (Time-Of-Check-Time-Of-Use) race condition where:

1. Proposal P1 is created and receives sufficient rejections to be rejected
2. The rejection check at voting time correctly identifies P1 as rejected
3. A separate proposal P2 is created and approved to remove one or more rejecting members
4. When P1 is later released, the rejection check recalculates using the modified membership
5. With fewer valid rejecting members, P1 may no longer meet the rejection threshold and can be executed

The vulnerability is enforced during release [5](#0-4) , where `IsReleaseThresholdReached` calls `IsProposalRejected` [6](#0-5) .

There are no protections against:
- Membership changes after voting has occurred
- Membership snapshots captured at proposal creation or voting time  
- Locks preventing member removal for proposals with active votes

## Impact Explanation

This vulnerability has **CRITICAL** severity as it violates the fundamental governance invariant that rejection decisions must be final and immutable. 

**Concrete Attack Scenario:**
- Organization with 7 members [A,B,C,D,E,F,G]
- Thresholds: MinimalApproval=3, MaximalRejection=3
- Attacker controls members A, B, C (enough to approve proposals)
- Malicious Proposal P1 is created
- P1 receives 3 approvals (A,B,C) and 4 rejections (D,E,F,G)
- P1 is correctly rejected since 4 > 3
- Attacker creates Proposal P2 to remove member D
- P2 receives 3 approvals (A,B,C) and is executed, removing D
- Attacker releases P1: rejection count now recalculates to 3 (only E,F,G remain as members)
- Since 3 is NOT > 3, P1 is no longer rejected and executes successfully

**Impact Consequences:**
- **Governance Bypass**: Proposals explicitly rejected by the organization can be executed
- **Fund Theft**: Rejected proposals draining treasury funds can be retroactively approved
- **Unauthorized Actions**: Malicious contract calls, parameter changes, or system modifications that were rejected can be executed
- **Multi-signature Violation**: Defeats the purpose of multi-signature governance requiring consensus

The organization validation function still passes after member removal [7](#0-6) , so multiple members can be removed sequentially to flip rejection status.

## Likelihood Explanation

The attack has **HIGH** likelihood due to:

**Attacker Requirements:**
- Control of `MinimalApprovalThreshold` members to pass removal proposals
- No special privileges beyond normal voting rights
- No exploitation of bugs or protocol violations

**Attack Feasibility:**
- Uses only standard governance operations (propose, vote, release)
- Member removals appear legitimate and have valid governance reasons
- Organizations with dynamic membership naturally exhibit this vulnerability
- Long proposal expiration windows provide extended attack opportunities
- Lower `MaximalRejectionThreshold` values make attacks easier (fewer members need removal)

**Detection Difficulty:**
- All operations use legitimate governance mechanisms
- Member removals may occur for valid organizational reasons unrelated to vote manipulation
- No anomalous transaction patterns to detect
- Attack can be executed over extended time periods to avoid suspicion

**Realistic Scenarios:**
- Organizations routinely modify membership for valid governance purposes
- Natural member turnover creates exploitation opportunities even without malicious intent
- Attacker needs only voting majority, not special privileges

## Recommendation

Implement membership snapshots at proposal creation or first vote casting to ensure rejection calculations use the membership state from when votes were originally cast:

**Solution 1: Store Membership Snapshot**
```csharp
// In ProposalInfo, add:
public OrganizationMemberList MembershipSnapshot { get; set; }

// In CreateNewProposal:
proposal.MembershipSnapshot = organization.OrganizationMemberList.Clone();

// In IsProposalRejected:
private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
{
    var memberList = proposal.MembershipSnapshot ?? organization.OrganizationMemberList;
    var rejectionMemberCount = proposal.Rejections.Count(memberList.Contains);
    return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
}
```

**Solution 2: Lock Membership During Active Proposals**
Add validation in `RemoveMember`, `AddMember`, and `ChangeMember` to prevent membership changes when active proposals exist with votes from the affected members.

**Solution 3: Invalidate Proposals on Membership Changes**
Automatically mark proposals as expired or invalid when organization membership changes, requiring re-voting under the new membership.

Solution 1 is recommended as it preserves governance flexibility while ensuring vote integrity.

## Proof of Concept

```csharp
[Fact]
public async Task TOCTOU_Vulnerability_Rejection_Bypass_Through_Member_Removal()
{
    // Setup: Create organization with 7 members, MinimalApproval=3, MaximalRejection=3
    var members = new[] { Reviewer1, Reviewer2, Reviewer3, Accounts[3].Address, 
                          Accounts[4].Address, Accounts[5].Address, Accounts[6].Address };
    
    var organizationAddress = await AssociationContractStub.CreateOrganization.SendAsync(
        new CreateOrganizationInput
        {
            OrganizationMemberList = new OrganizationMemberList { OrganizationMembers = { members } },
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 3,
                MinimalVoteThreshold = 3,
                MaximalRejectionThreshold = 3,
                MaximalAbstentionThreshold = 7
            },
            ProposerWhiteList = new ProposerWhiteList { Proposers = { Reviewer1 } }
        }).Output;

    // Step 1: Create malicious proposal P1
    var proposalId1 = await AssociationContractStub.CreateProposal.SendAsync(
        new CreateProposalInput
        {
            OrganizationAddress = organizationAddress,
            ToAddress = TokenContractAddress,
            ContractMethodName = nameof(TokenContractStub.Transfer),
            Params = new TransferInput { To = Accounts[0].Address, Amount = 1000 }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
        }).Output;

    // Step 2: P1 gets 3 approvals and 4 rejections
    await ApproveAsync(AssociationContractStub, proposalId1); // Reviewer1 approves
    await ApproveAsync(GetAssociationContractTester(Reviewer2KeyPair), proposalId1); // Reviewer2 approves
    await ApproveAsync(GetAssociationContractTester(Reviewer3KeyPair), proposalId1); // Reviewer3 approves
    await RejectAsync(GetAssociationContractTester(Accounts[3].KeyPair), proposalId1); // Account3 rejects
    await RejectAsync(GetAssociationContractTester(Accounts[4].KeyPair), proposalId1); // Account4 rejects
    await RejectAsync(GetAssociationContractTester(Accounts[5].KeyPair), proposalId1); // Account5 rejects
    await RejectAsync(GetAssociationContractTester(Accounts[6].KeyPair), proposalId1); // Account6 rejects

    // Step 3: Verify P1 is rejected (4 rejections > 3 threshold)
    var proposal1 = await AssociationContractStub.GetProposal.CallAsync(proposalId1);
    proposal1.ToBeReleased.ShouldBeFalse(); // Cannot be released due to rejections

    // Step 4: Create proposal P2 to remove rejecting member (Account3)
    var proposalId2 = await AssociationContractStub.CreateProposal.SendAsync(
        new CreateProposalInput
        {
            OrganizationAddress = organizationAddress,
            ToAddress = AssociationContractAddress,
            ContractMethodName = nameof(AssociationContractStub.RemoveMember),
            Params = Accounts[3].Address.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
        }).Output;

    // Step 5: P2 gets approved by attacker-controlled members
    await ApproveAsync(AssociationContractStub, proposalId2);
    await ApproveAsync(GetAssociationContractTester(Reviewer2KeyPair), proposalId2);
    await ApproveAsync(GetAssociationContractTester(Reviewer3KeyPair), proposalId2);

    // Step 6: Release P2 to remove Account3 from membership
    await ReleaseAsync(AssociationContractStub, proposalId2);

    // Step 7: VULNERABILITY - P1 now has only 3 valid rejections, can be released!
    proposal1 = await AssociationContractStub.GetProposal.CallAsync(proposalId1);
    proposal1.ToBeReleased.ShouldBeTrue(); // NOW TRUE - Governance bypass!
    
    // P1 can now be released despite being legitimately rejected
    var releaseResult = await AssociationContractStub.Release.SendAsync(proposalId1);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

This test demonstrates the complete attack: a proposal that was legitimately rejected becomes executable after removing a rejecting member from the organization, proving the TOCTOU vulnerability enables governance bypass.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L150-150)
```csharp
        proposal.Rejections.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```
