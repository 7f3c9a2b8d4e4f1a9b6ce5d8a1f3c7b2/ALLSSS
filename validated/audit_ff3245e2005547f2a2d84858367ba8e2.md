# Audit Report

## Title
Unvalidated Cross-Miner Secret Sharing Pollution in AEDPoS Consensus

## Summary
A malicious miner can inject arbitrary `DecryptedPieces` and `MinersPreviousInValues` through the `UpdateValue` transaction without cryptographic or authorization validation, corrupting the secret sharing reconstruction process and enabling consensus manipulation across the entire round.

## Finding Description

The AEDPoS consensus contract accepts `UpdateValueInput` containing `DecryptedPieces` and `MinersPreviousInValues` fields intended for cross-miner secret sharing. However, the contract blindly trusts this attacker-controlled input without validation.

**Vulnerable Code Path:**

The `UpdateValue` method is publicly accessible to any miner [1](#0-0) . After basic permission checks that only verify the sender is in the miner list [2](#0-1) , the input is processed by `PerformSecretSharing` which directly writes attacker-controlled data to all other miners' state [3](#0-2) .

**Validation Gap:**

The `UpdateValueValidationProvider` only validates the sender's own `OutValue`, `Signature`, and `PreviousInValue` fields [4](#0-3) . It performs no validation of the `DecryptedPieces` or `MinersPreviousInValues` dictionaries that affect other miners' state. The validation configuration confirms only `UpdateValueValidationProvider` is used for UpdateValue behavior [5](#0-4) .

**Consensus Impact:**

The corrupted `DecryptedPieces` are later used by `RevealSharedInValues` to reconstruct other miners' secret `InValues` using Shamir's Secret Sharing [6](#0-5) . These reconstructed values become `PreviousInValue` fields, which are then used to calculate signatures [7](#0-6) . The signatures directly determine mining order for subsequent rounds through signature-based order calculation [8](#0-7) .

## Impact Explanation

**CRITICAL** - This vulnerability breaks core consensus security guarantees:

1. **Mining Order Manipulation**: By injecting fake decrypted pieces, the attacker influences signature calculations that determine which miners produce blocks in what order during the next round, potentially creating favorable schedules for themselves or allied miners.

2. **Randomness Corruption**: The secret sharing mechanism is designed to generate unpredictable consensus randomness. Poisoned pieces allow the attacker to bias or predict these random values, breaking the unpredictability guarantee essential for fair consensus.

3. **Consensus DoS**: Invalid decrypted pieces cause secret sharing reconstruction to produce incorrect results, potentially breaking consensus flow when honest miners cannot properly validate or reconstruct the shared secrets.

4. **Complete Round Pollution**: A single transaction from one malicious miner corrupts the consensus state for ALL miners in the round through direct state writes to other miners' data structures, persisting until the next term change.

The attack violates fundamental "miner schedule integrity" and "correct round transitions" invariants required for secure consensus operation.

## Likelihood Explanation

**HIGH** - The attack is highly feasible:

**Attacker Requirements:**
- Must be an authorized miner (realistic in a DPoS system where miners can become malicious or be compromised)
- Must control a mining node to submit `UpdateValue` transactions
- Secret sharing must be enabled [9](#0-8) 

**Attack Simplicity:**
- LOW complexity - only requires crafting arbitrary byte arrays in `UpdateValueInput` fields as defined in the protocol buffer [10](#0-9) 
- No timing requirements or race conditions
- Deterministic execution guaranteed through direct state writes
- No additional economic cost beyond normal block production

**Detection Difficulty:**
- The poisoned data appears syntactically valid at transaction time
- Corruption only manifests during secret sharing reconstruction in subsequent rounds
- No immediate validation failure alerts honest miners to the attack

## Recommendation

Add cryptographic validation to `PerformSecretSharing` or `UpdateValueValidationProvider`:

1. **Validate DecryptedPieces**: Verify that decrypted pieces are cryptographically valid shares by checking they can reconstruct to the claimed InValue when combined with EncryptedPieces from previous rounds.

2. **Validate MinersPreviousInValues**: Ensure that `PreviousInValue` entries match the hash of actual InValues from the previous round, similar to the existing validation for the sender's own `PreviousInValue`.

3. **Authorization Check**: Verify that the sender has authority to provide decrypted pieces for specific miners (e.g., only provide pieces for miners who provided encrypted pieces to them).

4. **Threshold Validation**: Confirm that the minimum number of valid decrypted pieces exists before accepting them into state.

Add a new validation provider to check cross-miner fields before accepting them into consensus state.

## Proof of Concept

The vulnerability can be demonstrated by:

1. A malicious miner crafting an `UpdateValueInput` with valid `OutValue` and `Signature` (passing existing validation)
2. Including arbitrary `DecryptedPieces` dictionary entries for other miners with random byte values
3. Including arbitrary `MinersPreviousInValues` entries that do not correspond to actual InValues from previous rounds
4. Submitting this via `UpdateValue` transaction
5. Observing that `PerformSecretSharing` writes these arbitrary values directly to other miners' state without validation
6. When `RevealSharedInValues` is later called during NextRound preparation, the corrupted decrypted pieces produce incorrect secret reconstruction
7. The incorrect PreviousInValues lead to incorrect signature calculations
8. Mining order for subsequent rounds is manipulated based on these corrupted signatures

A complete test would require setting up a multi-miner consensus environment, having one miner submit corrupted UpdateValue data, and verifying that other miners' consensus state is polluted, leading to incorrect mining order calculations in subsequent rounds.

## Notes

This vulnerability only affects deployments where secret sharing is enabled via the Configuration contract. However, when enabled, it represents a critical consensus integrity vulnerability that allows a single malicious miner to manipulate the entire round's consensus state without detection at transaction validation time.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** protobuf/aedpos_contract.proto (L194-221)
```text
message UpdateValueInput {
    // Calculated from current in value.
    aelf.Hash out_value = 1;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 2;
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
    // Publish previous in value for validation previous signature and previous out value.
    aelf.Hash previous_in_value = 4;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    google.protobuf.Timestamp actual_mining_time = 5;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 8;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
    // The amount of produced blocks.
    int64 produced_blocks = 10;
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
    // The random number.
    bytes random_number = 13;
}
```
