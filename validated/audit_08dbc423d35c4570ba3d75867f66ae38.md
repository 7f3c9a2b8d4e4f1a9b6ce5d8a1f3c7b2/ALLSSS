# Audit Report

## Title
Missing Contract Address Validation in Governance Proposal Creation Allows Governance DoS

## Summary
The Referendum, Parliament, and Association governance contracts fail to validate that proposal target addresses correspond to deployed smart contracts. This allows proposals targeting non-existent addresses to pass validation, get approved by voters, but permanently fail during release execution, causing governance denial-of-service and locking voter tokens until proposal expiration.

## Finding Description

All three governance contracts contain insufficient validation in their proposal creation logic. The `Validate(ProposalInfo)` method only checks if the target address is non-null, without verifying that it corresponds to a deployed contract: [1](#0-0) [2](#0-1) [3](#0-2) 

The Genesis contract provides a `GetContractInfo` method that could be used to verify contract existence, but governance contracts never call it: [4](#0-3) 

When an approved proposal with an invalid target address is released, the system attempts to execute an inline transaction to the non-existent contract: [5](#0-4) [6](#0-5) [7](#0-6) 

During execution, when attempting to get an executive for the target address, if the contract doesn't exist, a `SmartContractFindRegistrationException` is caught and the inline transaction fails: [8](#0-7) 

The critical issue is that when any inline transaction fails, execution breaks and the parent transaction is marked as failed: [9](#0-8) 

When a transaction fails due to inline transaction failure, only pre/post plugin state changes are committed, not the main transaction's state changes including the proposal removal: [10](#0-9) 

This behavior is confirmed by test cases showing that when inline transactions fail, the parent transaction's state changes are not committed (blockStateSet.Changes.Count is 0): [11](#0-10) 

For Referendum, voters must lock tokens when voting via `LockToken`, which transfers tokens to a proposal virtual address: [12](#0-11) 

These tokens remain locked until the proposal expires, as enforced by `ReclaimVoteToken`: [13](#0-12) 

## Impact Explanation

**Governance Disruption**: Approved proposals cannot execute their intended governance actions, completely breaking the governance process for critical protocol updates or parameter changes. The proposal remains in an approved state but cannot be released, as the `State.Proposals.Remove(input)` statement never commits due to the parent transaction failure.

**Resource Waste**: For Referendum contracts, voter tokens are locked in the proposal virtual address and cannot be reclaimed until the proposal expires. This represents a significant loss of capital efficiency for governance participants, as tokens that could be used for other governance actions or economic activities are unnecessarily locked.

**Denial of Service**: The proposer can repeatedly attempt to release the proposal, each time consuming gas and failing. The proposal cannot be successfully executed until it naturally expires, during which time the governance system's capacity is effectively reduced.

**System-Wide Impact**: This affects all three governance contract types (Referendum, Parliament, Association), potentially impacting the entire governance layer of the AElf ecosystem. A single malicious or erroneous proposal can waste substantial governance resources and time.

## Likelihood Explanation

**Reachable Entry Point**: The `CreateProposal` method is publicly accessible to whitelisted proposers across all three governance contracts: [14](#0-13) [15](#0-14) [16](#0-15) 

**Realistic Preconditions**: 
- Proposer must be in the organization's proposer whitelist, which is a normal governance setup requirement, not a privileged position
- Proposers are expected to create proposals as part of standard governance operations
- No validation prevents submitting invalid addresses at creation time

**Execution Practicality**:
- **Accidental**: Simple human error such as copying the wrong address, typographical errors, or using an address that appears valid but points to an undeployed contract
- **Intentional**: Malicious whitelisted proposer can deliberately create proposals with invalid addresses to disrupt governance and lock voter funds
- The AElf address format validation ensures syntactically valid addresses, but contract existence is never checked

**Attack Complexity**: Low - requires only creating a proposal with a non-existent but validly-formatted address, which can happen accidentally or through minimal malicious effort.

## Recommendation

Add contract existence validation in the `Validate(ProposalInfo proposal)` method for all three governance contracts. The contracts should call the Genesis contract's `GetContractInfo` method to verify that the target address has a deployed contract before accepting the proposal.

Example fix for Referendum (similar changes needed for Parliament and Association):

```csharp
private bool Validate(ProposalInfo proposal)
{
    var validDestinationAddress = proposal.ToAddress != null;
    var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
    var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    var hasOrganizationAddress = proposal.OrganizationAddress != null;
    var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
    
    // Add contract existence check
    if (validDestinationAddress)
    {
        var genesisContract = State.GenesisContract.Value;
        if (genesisContract == null)
        {
            genesisContract = Context.GetContractAddressByName(SmartContractConstants.GenesisContractSystemName);
            State.GenesisContract.Value = genesisContract;
        }
        
        var contractInfo = State.GenesisContract.GetContractInfo.Call(proposal.ToAddress);
        Assert(contractInfo != null && contractInfo.CodeHash != null, "Target address is not a deployed contract.");
    }
    
    return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
           hasOrganizationAddress && validDescriptionUrl;
}
```

## Proof of Concept

The following test demonstrates the vulnerability by creating a proposal with a non-existent contract address, getting it approved, and showing that release fails while leaving the proposal in state and tokens locked:

```csharp
[Fact]
public async Task ProposalWithInvalidContractAddress_FailsOnRelease_TokensStayLocked()
{
    // Setup: Create referendum organization
    var organizationAddress = await CreateReferendumOrganization();
    
    // Create proposal targeting non-existent contract address
    var nonExistentAddress = Address.FromBase58("InvalidContractAddressThatDoesNotExist");
    var proposalId = await CreateProposal(organizationAddress, nonExistentAddress);
    
    // Approve proposal with locked tokens
    await ApproveProposal(proposalId, lockAmount: 1000);
    
    // Verify proposal is approved
    var proposal = await GetProposal(proposalId);
    Assert.True(proposal.ToBeReleased);
    
    // Attempt to release - should fail
    var releaseResult = await ReleaseProposal(proposalId);
    Assert.Equal(TransactionResultStatus.Failed, releaseResult.Status);
    Assert.Contains("Invalid contract address", releaseResult.Error);
    
    // Verify proposal still exists (not removed from state)
    proposal = await GetProposal(proposalId);
    Assert.NotNull(proposal);
    
    // Verify tokens still locked (cannot reclaim before expiration)
    var reclaimResult = await ReclaimVoteToken(proposalId);
    Assert.Equal(TransactionResultStatus.Failed, reclaimResult.Status);
    Assert.Contains("Unable to reclaim at this time", reclaimResult.Error);
    
    // Tokens remain locked until proposal expiration - governance DoS confirmed
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L39-72)
```csharp
    private ReferendumReceiptCreated LockToken(string symbol, long amount, Hash proposalId, Address lockedAddress,
        Address organizationAddress)
    {
        Assert(State.LockedTokenAmount[lockedAddress][proposalId] == null, "Already locked.");

        var lockId = Context.GenerateId(Context.Self,
            HashHelper.ConcatAndCompute(proposalId, HashHelper.ComputeFrom(lockedAddress)));
        RequireTokenContractStateSet();
        Context.SendVirtualInline(proposalId, State.TokenContract.Value,
            nameof(TokenContractContainer.TokenContractReferenceState.TransferFrom), new TransferFromInput
            {
                From = Context.Sender,
                To = GetProposalVirtualAddress(proposalId),
                Symbol = symbol,
                Amount = amount,
                Memo = "Referendum."
            });
        State.LockedTokenAmount[Context.Sender][proposalId] = new Receipt
        {
            Amount = amount,
            LockId = lockId,
            TokenSymbol = symbol
        };

        return new ReferendumReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = proposalId,
            Amount = amount,
            Symbol = symbol,
            Time = Context.CurrentBlockTime,
            OrganizationAddress = organizationAddress
        };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L157-166)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = CheckProposalNotExpired(proposal);
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L20-26)
```csharp
    public override ContractInfo GetContractInfo(Address input)
    {
        var info = State.ContractInfos[input];
        if (info == null) return new ContractInfo();

        return info;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L115-122)
```csharp
    public override Empty ReclaimVoteToken(Hash input)
    {
        var proposal = State.Proposals[input];
        Assert(proposal == null ||
               Context.CurrentBlockTime >= proposal.ExpiredTime, "Unable to reclaim at this time.");
        UnlockToken(input, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L105-126)
```csharp
    private static bool TryUpdateStateCache(TransactionTrace trace, TieredStateCache groupStateCache)
    {
        if (trace == null)
            return false;

        if (!trace.IsSuccessful())
        {
            var transactionExecutingStateSets = new List<TransactionExecutingStateSet>();

            AddToTransactionStateSets(transactionExecutingStateSets, trace.PreTraces);
            AddToTransactionStateSets(transactionExecutingStateSets, trace.PostTraces);

            groupStateCache.Update(transactionExecutingStateSets);
            trace.SurfaceUpError();
        }
        else
        {
            groupStateCache.Update(trace.GetStateSets());
        }

        return true;
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L149-161)
```csharp
        IExecutive executive;
        try
        {
            executive = await _smartContractExecutiveService.GetExecutiveAsync(
                internalChainContext,
                singleTxExecutingDto.Transaction.To);
        }
        catch (SmartContractFindRegistrationException)
        {
            txContext.Trace.ExecutionStatus = ExecutionStatus.ContractError;
            txContext.Trace.Error += "Invalid contract address.\n";
            return trace;
        }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L236-243)
```csharp
            var inlineTrace = await ExecuteOneAsync(singleTxExecutingDto, cancellationToken);

            if (inlineTrace == null)
                break;
            trace.InlineTraces.Add(inlineTrace);
            if (!inlineTrace.IsSuccessful())
                // Already failed, no need to execute remaining inline transactions
                break;
```

**File:** test/AElf.Parallel.Tests/DeleteDataFromStateDbTest.cs (L2101-2140)
```csharp
    public async Task Increase_Value_With_Failed_Inline()
    {
        var accountAddress = await _accountService.GetAccountAsync();
        var chain = await _blockchainService.GetChainAsync();
        await SetIrreversibleBlockAsync(chain);

        const string key = "TestKey";

        var value = await GetValueAsync(accountAddress, key, chain.BestChainHash, chain.BestChainHeight);
        CheckValueNotExisted(value);

        var transaction = await GenerateTransactionAsync(accountAddress,
            ParallelTestHelper.BasicFunctionWithParallelContractAddress,
            nameof(BasicFunctionWithParallelContractContainer.BasicFunctionWithParallelContractStub
                .IncreaseValueWithFailedInline), new IncreaseValueInput
            {
                Key = key,
                Memo = Guid.NewGuid().ToString()
            });
        var transactions = new List<Transaction> { transaction };
        var block = _parallelTestHelper.GenerateBlock(chain.BestChainHash, chain.BestChainHeight, transactions);
        block = (await _blockExecutingService.ExecuteBlockAsync(block.Header, transactions)).Block;
        await _blockchainService.AddTransactionsAsync(transactions);
        await _blockchainService.AddBlockAsync(block);
        await _blockAttachService.AttachBlockAsync(block);

        var transactionResult = await GetTransactionResultAsync(transaction.GetHash(), block.Header);
        transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);

        value = await GetValueAsync(accountAddress, key, block.GetHash(), block.Height);
        CheckValueNotExisted(value);

        var blockStateSet = await _blockStateSetManger.GetBlockStateSetAsync(block.GetHash());
        blockStateSet.Changes.Count.ShouldBe(0);
        blockStateSet.Deletes.Count.ShouldBe(0);

        chain = await _blockchainService.GetChainAsync();
        await SetIrreversibleBlockAsync(chain);
        await CheckValueNotExistedInVersionStateAsync(key);
    }
```
