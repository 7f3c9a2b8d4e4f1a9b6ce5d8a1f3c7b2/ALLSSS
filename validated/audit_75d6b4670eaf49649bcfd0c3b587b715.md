# Audit Report

## Title
Empty Miner List Acceptance Causes Permanent Side Chain Consensus DoS via Division by Zero

## Summary
The `UpdateInformationFromCrossChain()` function in the AEDPoS consensus contract fails to validate that the parent chain's miner list is non-empty before storing it in state. When an empty miner list is stored, all subsequent consensus updates fail with a `DivideByZeroException` during resource token distribution, permanently breaking the side chain's ability to synchronize with the parent chain.

## Finding Description

The vulnerability exists in the cross-chain consensus update mechanism where side chains receive miner list information from their parent chain.

**Root Cause:**

The function extracts miner keys from parent chain consensus data and commits them directly to state without validating that at least one miner exists. [1](#0-0)  The only validation checks are for null/empty input and round number comparison, [2](#0-1)  but there is no check ensuring `RealTimeMinersInformation` contains at least one miner.

**Attack Execution:**

1. **Setup**: A valid miner list is initially stored through normal consensus updates.

2. **First malicious call**: Parent chain data containing empty `RealTimeMinersInformation` is indexed. The `DistributeResourceTokensToPreviousMiners()` function uses the previous (valid) miner list and succeeds. [3](#0-2)  Then the empty miner list bypasses all validation checks and gets stored in `State.MainChainCurrentMinerList.Value`.

3. **Subsequent calls**: When the next consensus update occurs, `DistributeResourceTokensToPreviousMiners()` is invoked before the new miner list update.

4. **Division by zero**: The function retrieves the empty miner list from state [4](#0-3)  and attempts to calculate token distribution per miner. [5](#0-4) 

5. **Exception thrown**: The `Div` method performs standard division [6](#0-5)  which throws `DivideByZeroException` when the miner count is zero, as confirmed by test cases. [7](#0-6) 

6. **Permanent failure**: The guard checking `amount <= 0` comes AFTER the division, so it cannot prevent the exception. [8](#0-7)  All subsequent calls to `UpdateInformationFromCrossChain` fail at the same point.

**Why Protections Fail:**

- The cross-chain contract passes consensus data without content validation, only checking structural properties like chain ID, height continuity, and merkle root existence. [9](#0-8) 
- The cross-chain contract forwards consensus information inline to the consensus contract. [10](#0-9) 
- The `IsMainChainMinerListChanged` check returns false for empty lists, preventing usage in round generation but not storage. [11](#0-10) 

## Impact Explanation

**Critical Consensus Integrity Violation:**

- The side chain permanently loses its ability to receive miner list updates from the parent chain
- All subsequent `UpdateInformationFromCrossChain` transactions revert with an unrecoverable exception
- The consensus system's cross-chain synchronization becomes non-functional, requiring a hard fork or chain restart to recover

**Operational Impact:**

- Complete loss of parent chain consensus synchronization capability
- Economic damage from extended inability to update consensus information
- Manual intervention required (hard fork) with significant coordination costs
- Affects the entire side chain's cross-chain consensus mechanism

The severity is **Critical** because it causes permanent DoS of core consensus synchronization functionality with no automated recovery mechanism. Once triggered, the side chain cannot receive any further consensus updates from the parent chain.

## Likelihood Explanation

**Reachable Entry Point:**

The function can be triggered through the normal cross-chain indexing flow. When miners propose and release parent chain block data containing consensus information, that data is processed and forwarded to the consensus contract through the `UpdateConsensusInformation` helper method. [12](#0-11) 

**Attack Vectors:**

1. **Parent chain bug**: A bug in the parent chain's consensus contract generates an invalid Round with empty `RealTimeMinersInformation`
2. **Malicious parent chain**: If operating a private parent-side chain pair, the parent chain could intentionally send malicious data
3. **Edge case scenario**: During parent chain maintenance or migration, empty miner data could be inadvertently propagated

**Execution Practicality:**

- Single malicious cross-chain consensus update triggers the vulnerability
- No complex preconditions required beyond the malformed data being indexed
- Attack persists permanently after a single successful execution
- No economic cost barrier if parent chain data is compromised

The likelihood is **Medium to High** - while it requires malformed parent chain data (uncommon in normal operation), the impact is so severe and permanent that even a low probability event represents critical risk. From a defense-in-depth perspective, the side chain should validate all external data, including parent chain consensus information.

## Recommendation

Add validation to ensure the miner list is non-empty before storing it:

```csharp
public override Empty UpdateInformationFromCrossChain(BytesValue input)
{
    Assert(
        Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
        "Only Cross Chain Contract can call this method.");

    Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

    if (input == null || input.Value.IsEmpty) return new Empty();

    var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

    if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
        return new Empty();

    // ADD THIS VALIDATION
    Assert(consensusInformation.Round.RealTimeMinersInformation.Count > 0, 
        "Miner list cannot be empty.");

    Context.LogDebug(() =>
        $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
        $"{consensusInformation.Round.ToString("M")}");

    DistributeResourceTokensToPreviousMiners();

    State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

    var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
    State.MainChainCurrentMinerList.Value = new MinerList
    {
        Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
    };

    return new Empty();
}
```

Additionally, add a defensive check in `DistributeResourceTokensToPreviousMiners()`:

```csharp
private void DistributeResourceTokensToPreviousMiners()
{
    if (State.TokenContract.Value == null)
        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

    var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
    
    // ADD THIS CHECK
    if (minerList.Count == 0)
        return;
    
    foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                 .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
    {
        // ... rest of the function
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task UpdateInformationFromCrossChain_EmptyMinerList_CausesDivisionByZero()
{
    SetToSideChain();
    InitialContracts();
    InitialAcs3Stubs();
    
    var mockedCrossChain = SampleAccount.Accounts.Last();
    var mockedCrossChainStub = GetTester<AEDPoSContractImplContainer.AEDPoSContractImplStub>(
        ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        mockedCrossChain.KeyPair);

    await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput
    {
        ProposerAuthorityRequired = false,
        PrivilegedProposer = Address.FromPublicKey(MissionedECKeyPairs.InitialKeyPairs.First().PublicKey)
    });
    
    await CreateAndIssueToken("READ");
    await TokenStub.Transfer.SendAsync(new TransferInput
    {
        Symbol = "READ",
        Amount = 10_00000000,
        To = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name]
    });

    // Step 1: Store valid miner list first
    var validHeaderInformation = new AElfConsensusHeaderInformation
    {
        Round = new Round
        {
            RoundNumber = 2,
            RealTimeMinersInformation =
            {
                { Accounts[0].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                { Accounts[1].KeyPair.PublicKey.ToHex(), new MinerInRound() }
            }
        }
    };
    
    await mockedCrossChainStub.UpdateInformationFromCrossChain.SendAsync(new BytesValue
    {
        Value = validHeaderInformation.ToByteString()
    });

    // Step 2: Send empty miner list - this stores the empty list
    var emptyMinerListHeader = new AElfConsensusHeaderInformation
    {
        Round = new Round
        {
            RoundNumber = 3,
            RealTimeMinersInformation = { } // EMPTY!
        }
    };
    
    await mockedCrossChainStub.UpdateInformationFromCrossChain.SendAsync(new BytesValue
    {
        Value = emptyMinerListHeader.ToByteString()
    });

    // Step 3: Next consensus update triggers division by zero
    var nextHeader = new AElfConsensusHeaderInformation
    {
        Round = new Round
        {
            RoundNumber = 4,
            RealTimeMinersInformation =
            {
                { Accounts[0].KeyPair.PublicKey.ToHex(), new MinerInRound() }
            }
        }
    };
    
    // This should throw DivideByZeroException
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await mockedCrossChainStub.UpdateInformationFromCrossChain.SendAsync(new BytesValue
        {
            Value = nextHeader.ToByteString()
        });
    });
    
    exception.Message.ShouldContain("DivideByZeroException");
}
```

## Notes

This vulnerability demonstrates a critical failure in input validation for cross-chain consensus data. The side chain implicitly trusts parent chain consensus information without validating its semantic correctness. While the `IsMainChainMinerListChanged` function prevents an empty miner list from being used for round generation, it does not prevent the empty list from being stored or causing failures in the token distribution logic.

The attack requires either a bug in the parent chain consensus contract or malicious parent chain behavior, making it an edge case. However, the permanent and catastrophic nature of the impact (permanent DoS of consensus synchronization requiring a hard fork) elevates this to a critical severity issue that should be addressed with proper validation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L41-47)
```csharp
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L53-53)
```csharp
        DistributeResourceTokensToPreviousMiners();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-61)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L72-72)
```csharp
        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L81-81)
```csharp
            var amount = balance.Div(minerList.Count);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L83-83)
```csharp
            if (amount <= 0) continue;
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L50-51)
```csharp
        Should.Throw<DivideByZeroException>(() => { number1.Div(0); });
        Should.Throw<DivideByZeroException>(() => { number2.Div(0); });
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L227-234)
```csharp
    private void UpdateConsensusInformation(ByteString bytes)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        Context.SendInline(State.CrossChainInteractionContract.Value,
            nameof(State.CrossChainInteractionContract.UpdateInformationFromCrossChain),
            new BytesValue { Value = bytes });
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L720-743)
```csharp
    private bool ValidateParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData,
        out Dictionary<int, List<ParentChainBlockData>> validatedParentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
        foreach (var blockData in parentChainBlockData)
        {
            if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
                blockData.TransactionStatusMerkleTreeRoot == null)
                return false;
            if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
                    State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
                    State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
                return false;

            currentHeight += 1;
        }

        if (parentChainBlockData.Count > 0)
            validatedParentChainBlockData[parentChainId] = parentChainBlockData.ToList();

        return true;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L783-788)
```csharp
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L349-354)
```csharp
    private bool IsMainChainMinerListChanged(Round currentRound)
    {
        return State.MainChainCurrentMinerList.Value.Pubkeys.Any() &&
               GetMinerListHash(currentRound.RealTimeMinersInformation.Keys) !=
               GetMinerListHash(State.MainChainCurrentMinerList.Value.Pubkeys.Select(p => p.ToHex()));
    }
```
