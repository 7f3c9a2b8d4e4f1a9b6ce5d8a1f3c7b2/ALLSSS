# Audit Report

## Title
NextTerm Miner List Manipulation Enables Arbitrary MinersCountOfConsent Threshold Control

## Summary
The AEDPoS consensus contract processes `NextTermInput` without validating that the miner list matches election results from `GetVictories()`. A malicious extra block producer at term boundaries can inject an arbitrary miner list, completely bypassing the election system and gaining control over the consensus threshold for all future term changes.

## Finding Description

The vulnerability exists in the term transition mechanism where election-based miner selection is completely bypassed during processing.

**Honest Generation Path:**
When honest block producers generate consensus data for the next term, the system properly queries election results through `GenerateFirstRoundOfNextTerm`, which calls `TryToGetVictories` to fetch actual vote winners from the Election contract. [1](#0-0) 

**Missing Validation:**
However, when `NextTermInput` is submitted for processing, the `ProcessNextTerm` method directly extracts the round from the input and uses the miners from `RealTimeMinersInformation.Keys` to create the new miner list without any election validation. [2](#0-1) 

The before-execution validation only verifies that term and round numbers are incremented correctly, performing no miner list validation against election results. [3](#0-2) 

The after-execution validation compares the header miner list against the current state miner list and calls `GetNewestPubkey` for any differences. [4](#0-3) 

However, `GetNewestPubkey` only resolves pubkey replacement chains through `InitialToNewestPubkeyMap` for legitimate candidate pubkey changes, not election result validation. [5](#0-4) 

**Attack Execution:**
The `PreCheck` permission validation allows the transaction sender if they are in the current or previous round's miner list, explicitly supporting "failed miner performing NextTerm" scenarios. [6](#0-5) 

A malicious miner who is the extra block producer at a term boundary can:
1. Call the honest generation method to obtain valid consensus data with correct term/round numbers
2. Modify the `RealTimeMinersInformation` field in `NextTermInput` to contain only attacker-controlled miners
3. Submit the modified transaction, which passes `PreCheck` because they are a current miner
4. Pass all validations since term/round numbers are correct and no election validation exists
5. The malicious miner list becomes the authoritative state via `SetMinerList`

## Impact Explanation

**Consensus Takeover:**
The attacker gains complete control over the block producer set, fundamentally violating the election-based governance mechanism. Legitimately elected miners are excluded and replaced with colluding addresses.

**Threshold Manipulation:**
By controlling `RealTimeMinersInformation.Count`, the attacker directly manipulates `MinersCountOfConsent = (Count * 2 / 3) + 1`. Reducing the miner set from 17 to 3 miners drops the consensus threshold from 12 to 3, enabling perpetual control over all future term changes and consensus decisions.

**Governance Bypass:**
The election system becomes meaningless. Token holder votes are ignored, legitimate candidates with majority support are excluded, and the entire decentralized governance model is compromised.

**Chain Authority:**
With control over miners and consensus thresholds, attackers can censor transactions, manipulate Last Irreversible Block heights, control governance proposals requiring miner consensus, and permanently prevent legitimate miners from regaining control.

This represents a **CRITICAL** consensus integrity failure with complete protocol capture.

## Likelihood Explanation

**Attacker Requirements:**
The attacker must be a current miner and specifically the extra block producer when a term change occurs. In a 17-miner system, each miner has approximately 1/17 (~6%) probability of being the extra block producer at any given term boundary.

**Attack Opportunities:**
Term changes occur periodically (e.g., every 7 days based on `PeriodSeconds` configuration), providing regular opportunities for any malicious miner to eventually be in the required position.

**Execution Simplicity:**
The attack requires no complex cryptographic manipulation, system compromise, or coordination. Simple modification of the miner list in consensus data is sufficient, and the validation logic accepts the malicious input.

**Detection Difficulty:**
The attack appears as a legitimate `NextTerm` transaction that passes all validation checks. Without independent verification of election results, honest nodes cannot distinguish malicious from legitimate term changes.

**Likelihood Assessment:** MEDIUM-HIGH
While the attacker needs specific timing (being extra block producer at term boundary), the regular occurrence of term changes combined with execution simplicity makes this attack highly feasible for any malicious miner given sufficient time.

## Recommendation

Add election result validation to `ProcessNextTerm`. Before accepting the new miner list, query the Election contract's `GetVictories()` and verify that the miners in `NextTermInput.RealTimeMinersInformation` match the elected candidates:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // Validate miner list matches election results
    if (State.IsMainChain.Value && TryToGetVictories(out var victories))
    {
        var expectedMiners = victories.Pubkeys.Select(p => p.ToHex()).OrderBy(k => k).ToList();
        var actualMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        
        Assert(expectedMiners.SequenceEqual(actualMiners), 
            "Miner list does not match election results.");
    }
    
    // ... rest of existing logic
}
```

Additionally, modify `ValidateConsensusAfterExecution` to validate against election results when the miner list changes, not just pubkey replacement chains.

## Proof of Concept

```csharp
[Fact]
public async Task NextTerm_AcceptsArbitraryMinerList_WithoutElectionValidation()
{
    // Setup: Initialize consensus with 17 legitimate miners
    var legitimateMiners = GenerateMinerList(17);
    await InitializeConsensusWithMiners(legitimateMiners);
    
    // Setup: Set one miner as malicious extra block producer
    var maliciousMiner = legitimateMiners[0];
    await AdvanceToTermBoundary(maliciousMiner);
    
    // Attack: Generate valid NextTermInput with honest term/round numbers
    var honestNextTermData = await GenerateNextTermData(maliciousMiner);
    
    // Attack: Replace miner list with attacker-controlled miners
    var attackerMiners = GenerateMinerList(3); // Reduce to 3 for threshold control
    var maliciousInput = new NextTermInput
    {
        TermNumber = honestNextTermData.TermNumber,
        RoundNumber = honestNextTermData.RoundNumber,
        RealTimeMinersInformation = { attackerMiners.ToDictionary(m => m, m => new MinerInRound { Pubkey = m }) },
        RandomNumber = honestNextTermData.RandomNumber
        // ... other fields copied from honest data
    };
    
    // Attack: Submit malicious NextTerm transaction
    var result = await ConsensusContract.NextTerm(maliciousInput);
    
    // Verify: Transaction succeeds
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Malicious miner list is now authoritative state
    var currentMiners = await ConsensusContract.GetCurrentMinerList(new Empty());
    currentMiners.Pubkeys.Count.ShouldBe(3); // Attackers control miner count
    currentMiners.Pubkeys.ShouldAllBe(p => attackerMiners.Contains(p.ToHex()));
    
    // Verify: Election results were bypassed (legitimate miners not in list)
    var electionVictories = await ElectionContract.GetVictories(new Empty());
    electionVictories.Value.ShouldNotBe(currentMiners.Pubkeys); // Mismatch proves bypass
    
    // Verify: Consensus threshold is now controlled by attacker
    var minersCountOfConsent = (3 * 2 / 3) + 1; // = 3
    minersCountOfConsent.ShouldBe(3); // Attacker needs only 3 signatures for future terms
}
```

## Notes

This vulnerability fundamentally breaks the election-based consensus guarantee. The lack of election validation in `ProcessNextTerm` allows complete bypass of the democratic governance mechanism. The attack is particularly severe because it provides permanent control - once an attacker injects their miner list and reduces the threshold, they can perpetually maintain control over future term changes.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-283)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }

    private long GetBlockchainAge()
    {
        return State.BlockchainStartTimestamp.Value == null
            ? 0
            : (Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds;
    }

    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-190)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-123)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```
