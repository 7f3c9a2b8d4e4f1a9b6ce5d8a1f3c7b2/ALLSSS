# Audit Report

## Title
Scheme Manager Can Bypass Minimum Lock Period by Calling CreateScheme Multiple Times

## Summary
The `CreateScheme` method in TokenHolderContract lacks duplicate scheme validation, allowing a manager to overwrite scheme parameters (including `MinimumLockMinutes`) while users remain registered in the original Profit scheme. This enables arbitrary manipulation of withdrawal timelocks for all existing participants.

## Finding Description

The vulnerability stems from `CreateScheme` unconditionally overwriting stored scheme parameters without checking for existing schemes. [1](#0-0) 

Each `CreateScheme` invocation creates a new Profit contract scheme with a unique ID based on the manager's scheme count. [2](#0-1) 

The Profit contract adds new schemes to the manager's list rather than replacing them. [3](#0-2) 

When users register via `RegisterForProfits`, they are added as beneficiaries to the FIRST Profit scheme (obtained via `FirstOrDefault()`). [4](#0-3) 

During withdrawal, the `Withdraw` method validates timing using `MinimumLockMinutes` from the current (potentially overwritten) TokenHolder scheme, while users remain registered in the first Profit scheme. [5](#0-4) 

**Attack Scenario:**
1. Manager creates scheme with `MinimumLockMinutes = 100000`
2. User locks tokens at time T=0
3. Manager calls `CreateScheme` again with `MinimumLockMinutes = 1`  
4. User can withdraw at T=2 minutes instead of T=100000 minutes

The disconnect occurs because:
- TokenHolder stores scheme **parameters** keyed by manager address (overwritten on each call)
- Users are registered in **Profit schemes** identified by SchemeId (never overwritten)
- Withdrawal validation uses current TokenHolder parameters but operates on the first Profit scheme

## Impact Explanation

**HIGH Severity** - This vulnerability enables unilateral manipulation of the fundamental timelock parameter affecting all scheme participants:

**Direct Fund Impact:**
- Users who locked tokens expecting a 100,000 minute commitment can withdraw after 1 minute if the manager reduces `MinimumLockMinutes`
- Conversely, users expecting a 1-minute lock can be indefinitely trapped if the manager increases the value
- Completely breaks the core security guarantee that locked tokens remain inaccessible for the agreed duration

**Economic Model Breach:**
- Profit distribution schemes depend on predictable lock durations to ensure fair dividend allocation
- Early withdrawal enables users to claim profits without maintaining expected commitment periods
- Undermines the incentive alignment that TokenHolder contracts are designed to enforce

**Trust Violation:**
- Users commit funds based on explicit lock period terms visible at registration time
- Retroactive parameter modification by the manager violates this agreement without user consent or notification
- Affects all existing lockers simultaneously

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability is trivially exploitable with no barriers:

**Reachable Entry Point:**
`CreateScheme` is a public method with no authorization checks beyond standard transaction requirements. Any address can create a scheme and become its manager. [1](#0-0) 

**Attack Complexity:**
Minimal - requires only two standard transactions:
1. Initial `CreateScheme` with original `MinimumLockMinutes`
2. Second `CreateScheme` with modified `MinimumLockMinutes`

**Attacker Prerequisites:**
- Must be the scheme manager (the address that initially called `CreateScheme`)
- No governance approvals required
- No special privileges beyond being the manager
- Standard transaction costs

**Feasibility:**
- No race conditions or precise timing requirements
- No external dependencies
- Could occur accidentally (e.g., manager attempting to "update" scheme parameters through misconfiguration)

**Detection:**
- State overwrite occurs through normal contract execution
- No events specifically indicate parameter changes to existing schemes
- Users may only discover the manipulation when attempting withdrawal

## Recommendation

Add duplicate scheme validation in `CreateScheme` to prevent overwriting existing schemes:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add validation to prevent duplicate scheme creation
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this manager. Cannot create duplicate.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, if parameter updates are intended functionality, implement a separate `UpdateScheme` method with appropriate validations to ensure users are not adversely affected by parameter changes.

## Proof of Concept

```csharp
[Fact]
public async Task SchemeManager_Can_Bypass_MinimumLockPeriod_By_Calling_CreateScheme_Twice()
{
    // Step 1: Manager creates scheme with 100000 minute lock
    var manager = Accounts[0].Address;
    var user = Accounts[1].Address;
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100000 // ~69 days
    });
    
    // Step 2: User registers and locks tokens
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenHolderContractAddress,
        Symbol = "ELF",
        Amount = 1000
    });
    
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = manager,
        Amount = 1000
    });
    
    var lockTime = BlockTimeProvider.GetBlockTime();
    
    // Step 3: Manager calls CreateScheme again with 1 minute lock
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    // Step 4: Advance time by only 2 minutes
    BlockTimeProvider.SetBlockTime(lockTime.AddMinutes(2));
    
    // Step 5: User can now withdraw (should fail but succeeds due to vulnerability)
    var result = await TokenHolderContractStub.Withdraw.SendAsync(manager);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Succeeds!
    
    // User withdrew after 2 minutes instead of required 100000 minutes
}
```

## Notes

This vulnerability exists at the intersection of two contract systems:
- **TokenHolderContract** stores scheme parameters (including `MinimumLockMinutes`) keyed by manager address
- **ProfitContract** stores scheme beneficiaries keyed by SchemeId

The mismatch occurs because TokenHolderContract overwrites parameters on each `CreateScheme` call, while ProfitContract accumulates schemes in a list. The `UpdateTokenHolderProfitScheme` helper always retrieves the first Profit scheme ID but uses the current (potentially overwritten) TokenHolder parameters for validation.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-245)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```
