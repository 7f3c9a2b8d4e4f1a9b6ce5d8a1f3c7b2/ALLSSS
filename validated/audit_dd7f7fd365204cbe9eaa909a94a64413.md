# Audit Report

## Title
Consensus Halt Attack via Empty Miner List in NextRound Validation

## Summary
A critical validation flaw in the AEDPoS consensus contract allows any miner to permanently halt the blockchain by submitting a NextRound transaction with an empty miner list. The vulnerability stems from improper validation logic that incorrectly passes when the proposed round contains zero miners, violating the fundamental consensus invariant.

## Finding Description

The vulnerability exists in the `ValidationForNextRound()` method within `RoundTerminateValidationProvider`, which fails to validate that the next round must contain miners. [1](#0-0) 

When `RealTimeMinersInformation` is an empty collection, the `Any(m => m.InValue != null)` expression returns `false` (standard C# behavior for empty collections), causing the validation to incorrectly return success with `Success = true`.

The validation process registers validators for NextRound behavior: [2](#0-1) 

Other validators fail to prevent empty miner lists:

**MiningPermissionValidationProvider** only validates the sender against the current round's miner list (BaseRound), not the proposed next round: [3](#0-2) 

**NextRoundMiningOrderValidationProvider** compares counts that are both zero when the list is empty, causing the validation to pass (0 == 0): [4](#0-3) 

After validation passes, `ProcessNextRound` stores the empty round: [5](#0-4) 

The `AddRoundInformation` method directly writes the round to state without additional validation: [6](#0-5) 

The `ToRound()` conversion method directly copies miner information without validation: [7](#0-6) 

## Impact Explanation

**Complete Consensus Halt**: After the empty round is stored and becomes the current round, all miners are permanently locked out. When any miner attempts to retrieve a consensus command through the ACS4 interface: [8](#0-7) 

The `IsInMinerList()` method checks if a pubkey exists in `RealTimeMinersInformation.Keys`: [9](#0-8) 

With an empty `RealTimeMinersInformation` dictionary, `Keys.Contains(pubkey)` always returns `false` for ALL miners, causing `GetConsensusCommand` to return `InvalidConsensusCommand`.

Additionally, the `PreCheck()` mechanism verifies miner membership but checks current/previous rounds, not preventing the attack: [10](#0-9) 

**Consequences:**
- No miner can produce blocks (consensus command always returns invalid)
- No transactions can be processed or confirmed
- Blockchain operations halt completely
- Recovery requires hard fork or chain restart with state rollback
- All pending transactions are permanently stuck
- Economic activity ceases entirely

**Severity**: CRITICAL - This violates the fundamental consensus invariant that valid rounds must contain miners, breaking the blockchain's liveness and availability guarantees.

## Likelihood Explanation

**Attacker Capabilities**: The `NextRound` method is publicly accessible as an RPC endpoint: [11](#0-10) 

Any current miner can call this method during round transitions. The attacker simply crafts a `NextRoundInput` with empty `RealTimeMinersInformation` and submits it as a transaction.

**Attack Complexity**: LOW
- Attacker crafts a NextRound transaction with empty miner list
- No complex cryptographic operations required  
- Single transaction execution
- No race conditions or timing dependencies

**Preconditions**: 
- Attacker must be a legitimate miner in the current round (feasible for insider threat or compromised miner node)
- Attacker must have opportunity to submit NextRound transaction (occurs naturally at round boundaries)

**Economic Cost**: Minimal - Only requires being an existing miner with standard transaction fees

**Detection**: The attack would be detected immediately upon execution as consensus halts, but recovery requires hard fork intervention - by then the damage is done.

**Probability**: MEDIUM-HIGH - Malicious or compromised miners periodically have opportunities to produce NextRound blocks during normal consensus operations.

## Recommendation

Add explicit validation to ensure the next round contains miners. Modify `ValidationForNextRound()` in `RoundTerminateValidationProvider`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Validate round number
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // NEW: Validate that next round has miners
    if (extraData.Round.RealTimeMinersInformation == null || 
        extraData.Round.RealTimeMinersInformation.Count == 0)
        return new ValidationResult { Message = "Next round must contain miners." };
    
    // Validate InValues are null
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

Additionally, consider adding a defensive check in `AddRoundInformation()` to assert the round contains miners before storage.

## Proof of Concept

```csharp
[Fact]
public async Task ConsensusHalt_EmptyMinerList_Attack()
{
    // Setup: Initialize consensus with normal miners
    await InitializeAEDPoSContract();
    
    // Attacker is a current miner
    var attackerKeyPair = InitialCoreDataCenterKeyPairs[0];
    var attackerStub = GetAEDPoSContractStub(attackerKeyPair);
    
    // Get current round
    var currentRound = await attackerStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Craft malicious NextRoundInput with EMPTY RealTimeMinersInformation
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        RealTimeMinersInformation = { }, // EMPTY - this is the attack
        TermNumber = currentRound.TermNumber,
        RandomNumber = GenerateRandomNumber()
    };
    
    // Execute attack: Submit NextRound with empty miners
    var result = await attackerStub.NextRound.SendAsync(maliciousNextRound);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Attack succeeds
    
    // Verify consensus is halted: ALL miners now get InvalidConsensusCommand
    var newRound = await attackerStub.GetCurrentRoundInformation.CallAsync(new Empty());
    newRound.RealTimeMinersInformation.Count.ShouldBe(0); // Empty miner list stored
    
    // Try to get consensus command for any miner - all fail
    foreach (var minerKeyPair in InitialCoreDataCenterKeyPairs)
    {
        var minerStub = GetAEDPoSContractStub(minerKeyPair);
        var command = await minerStub.GetConsensusCommand.CallAsync(
            ByteStringHelper.FromHexString(minerKeyPair.PublicKey.ToHex()));
        
        // ALL miners get invalid command - consensus permanently halted
        command.NextBlockMiningLeftMilliseconds.ShouldBe(-1); 
        command.LimitMillisecondsOfMiningBlock.ShouldBe(0);
    }
}
```

## Notes

This vulnerability represents a severe breach of consensus protocol security. The root cause is the semantic mismatch between C#'s `Any()` method behavior on empty collections and the intended validation logic. The fix requires explicit count validation before checking collection contents. This is a critical liveness vulnerability that could be exploited by any malicious or compromised miner node to permanently halt the blockchain.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L32-34)
```csharp
        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-18)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-158)
```csharp
        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** protobuf/aedpos_contract.proto (L34-35)
```text
    rpc NextRound (NextRoundInput) returns (google.protobuf.Empty) {
    }
```
