# Audit Report

## Title
Miner Order Manipulation via Brute-Force InValue Selection

## Summary
The AEDPoS consensus mechanism allows miners to manipulate their position in future mining rounds by brute-forcing InValue candidates offline. The on-chain validation only checks hash preimage correctness but does not verify that InValue was generated using the intended cryptographic signing method, enabling miners to select arbitrary values that optimize their mining schedule position.

## Finding Description

The vulnerability exists in the consensus order determination mechanism where mining position for round N+1 is calculated from a signature derived from the miner's InValue revealed in round N.

**Order Calculation:** The mining order is determined by converting the signature to an integer and computing its modulus with the miner count. [1](#0-0) 

**Signature Calculation:** The signature is computed by XORing the InValue with all signatures from the previous round. [2](#0-1) 

**Insufficient Validation:** The only on-chain validation checks that the hash of the revealed InValue matches the previously committed OutValue. [3](#0-2) 

**Intended but Unenforced Generation:** InValue should be generated by signing round information with the miner's private key, making it deterministic and tied to the miner's identity. However, this generation method is implemented only client-side and not validated on-chain. [4](#0-3) 

**Attack Execution:**
When producing a block in round N-1, a malicious miner can:
1. Generate thousands of random hash values as candidate InValues offline
2. For each candidate, compute the resulting signature by XORing it with known signatures from round N-2 (which are public on-chain)
3. Calculate the mining position in round N+1 using the modulus operation
4. Select the InValue producing the most favorable position (e.g., position 1 for earliest mining opportunity)
5. Commit by publishing OutValue = Hash(chosen_InValue) [5](#0-4) 
6. Later reveal the chosen InValue, which passes validation since Hash(InValue) == OutValue

The contract accepts any InValue that satisfies the hash preimage check, with no verification that it was generated through proper cryptographic signing. [6](#0-5) 

## Impact Explanation

**Consensus Integrity Violation:**
This vulnerability breaks the fundamental security assumption that mining order is unpredictable and determined by cryptographically secure randomness. The AEDPoS consensus mechanism relies on fair, random miner scheduling to ensure decentralization and prevent manipulation.

**Concrete Harms:**
- **Unfair Economic Advantage:** Manipulating miners can consistently secure position 1, gaining first access to transaction fees and MEV opportunities in each round
- **Centralization Pressure:** Miners exploiting this gain cumulative advantages, forcing honest miners to either adopt the manipulation or become economically uncompetitive
- **Consensus Weakening:** Attackers optimizing for consecutive mining positions across round boundaries can attempt sophisticated attacks like selfish mining or chain reorganizations
- **Reward Manipulation:** Mining order affects reward distribution and extra block production rights, allowing attackers to maximize their share

**Affected Parties:**
- Honest miners suffer reduced mining opportunities and rewards
- Network security and decentralization are compromised
- Users face reduced transaction finality guarantees

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active miner in the consensus set (achievable through normal election process)
- Requires only commodity hardware (modern CPU can hash millions of values per second)
- No special privileges beyond normal mining operations

**Attack Complexity:**
- **Simple Execution:** Generate random hashes, compute XOR operations, calculate modulus, select optimal value
- **Undetectable:** All brute-forcing occurs offline; on-chain behavior is indistinguishable from legitimate mining
- **Repeatable:** Can be executed every round indefinitely without detection
- **Low Computational Cost:** With 17 miners (typical setup), approximately 6% chance a random InValue gives position 1, requiring ~17 attempts on average

**No Barriers to Exploitation:**
- Zero additional capital cost beyond normal mining stake
- No risk of detection or penalty
- Direct economic benefit with no downside
- Success appears as statistical "luck" in order assignment

**Probability: Very High**
Once this vulnerability is discovered, rational economic actors will adopt it as it provides guaranteed advantages with zero risk. The complete absence of validation makes exploitation trivial for any miner.

## Recommendation

Add on-chain validation to verify that InValue was generated by signing with the miner's private key. The contract should:

1. Require miners to provide the signature proof along with InValue
2. Verify that InValue = Hash(Sign(round_data)) using the miner's public key
3. Include round-specific data in what gets signed to prevent replay attacks

Example implementation:
```csharp
// In UpdateValueValidationProvider
private bool ValidateInValueGeneration(ConsensusValidationContext validationContext)
{
    var publicKey = validationContext.SenderPubkey;
    var inValue = validationContext.ExtraData.Round.RealTimeMinersInformation[publicKey].InValue;
    var roundData = GetRoundDataForSigning(validationContext.ProvidedRound);
    
    // Recover signature from InValue
    var expectedSignature = Context.RecoverPublicKey(
        HashHelper.ComputeFrom(roundData).ToByteArray(), 
        inValue.ToByteArray()
    );
    
    return expectedSignature.ToHex() == publicKey;
}
```

Alternatively, use verifiable random functions (VRF) which provide cryptographic proof that the random value was generated correctly.

## Proof of Concept

```csharp
[Fact]
public async Task MinerCanManipulateMiningOrderByBruteForceInValue()
{
    // Setup: Create a round with known signatures
    var previousRound = CreateRoundWithSignatures();
    var targetMinersCount = 17;
    
    // Attack: Try different InValue candidates to find optimal mining order
    Hash optimalInValue = null;
    int bestOrder = int.MaxValue;
    
    for (int i = 0; i < 10000; i++)
    {
        // Generate candidate InValue (not through signing!)
        var candidateInValue = HashHelper.ComputeFrom(BitConverter.GetBytes(i));
        
        // Calculate resulting signature
        var signature = previousRound.CalculateSignature(candidateInValue);
        
        // Calculate resulting mining order
        var sigNum = signature.ToInt64();
        var order = Math.Abs(sigNum % targetMinersCount) + 1;
        
        // Keep the InValue that gives us position 1
        if (order == 1)
        {
            optimalInValue = candidateInValue;
            bestOrder = order;
            break;
        }
    }
    
    // Assert: We found an InValue that gives position 1
    optimalInValue.ShouldNotBeNull();
    bestOrder.ShouldBe(1);
    
    // The malicious miner publishes OutValue = Hash(optimalInValue)
    var outValue = HashHelper.ComputeFrom(optimalInValue);
    
    // Later reveals optimalInValue - validation passes!
    var validationResult = ValidateInValue(optimalInValue, outValue);
    validationResult.ShouldBeTrue(); // Passes because Hash(InValue) == OutValue
    
    // Result: Attacker gets position 1 in next round
}

private bool ValidateInValue(Hash inValue, Hash outValue)
{
    // This mimics UpdateValueValidationProvider logic
    return HashHelper.ComputeFrom(inValue) == outValue;
}
```

## Notes

This vulnerability demonstrates a critical gap between the intended design (InValue generated through cryptographic signing) and the actual on-chain enforcement (only hash preimage validation). The client-side implementation in `SecretSharingService` correctly generates InValue by signing, but malicious miners can bypass this by implementing custom mining clients that brute-force favorable InValues instead.

The attack is particularly insidious because:
1. All computation happens offline and is undetectable
2. The resulting on-chain behavior looks identical to honest mining
3. The economic incentive is strong and immediate
4. There's no penalty for exploitation

The fix requires adding cryptographic proof verification on-chain to ensure InValues are generated correctly, not just that they satisfy the hash commitment.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L186-191)
```csharp
    private async Task<Hash> GenerateInValueAsync(IMessage message)
    {
        var data = HashHelper.ComputeFrom(message.ToByteArray());
        var bytes = await _accountService.SignAsync(data.ToByteArray());
        return HashHelper.ComputeFrom(bytes);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-67)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L88-112)
```csharp
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
        }

        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```
