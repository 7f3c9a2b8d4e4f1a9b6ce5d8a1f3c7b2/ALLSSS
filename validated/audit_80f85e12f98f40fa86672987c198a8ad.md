# Audit Report

## Title
Missing LIB Height Validation During NextTerm Transition Allows Consensus State Corruption

## Summary
The AEDPoS consensus contract fails to validate Last Irreversible Block (LIB) height during term transitions, allowing miners to write stale consensus data with lower LIB values to the consensus contract state. While `UpdateValue` operations correctly validate that LIB never decreases, `NextTerm` operations omit this critical check, violating an explicit security invariant and enabling consensus contract state corruption.

## Finding Description

The vulnerability stems from inconsistent application of LIB validation across consensus behaviors. The system implements `LibInformationValidationProvider` to prevent LIB rollback during normal block production, but this validation is explicitly excluded for `NextTerm` operations.

**Vulnerable Code Flow:**

When a miner produces a NextTerm block, they call `GetConsensusExtraData` (a public view method) [1](#0-0) , which invokes `GetConsensusExtraDataForNextTerm` [2](#0-1) .

This calls `GenerateFirstRoundOfNextTerm` which directly copies the LIB height from the current round without any validation [3](#0-2) . The same unvalidated copy occurs in `MinerList.GenerateFirstRoundOfNewTerm` [4](#0-3) .

During validation, `UpdateValue` behavior includes `LibInformationValidationProvider` with an explicit comment stating LIB should not decrease [5](#0-4) . However, `NextTerm` behavior only includes `RoundTerminateValidationProvider`, completely excluding LIB validation [6](#0-5) .

The `LibInformationValidationProvider` explicitly checks that provided LIB heights do not decrease from the base round [7](#0-6) , but this protection is never applied to NextTerm. The `RoundTerminateValidationProvider` only validates round and term number increments with no LIB checks [8](#0-7) .

**Attack Scenario:**

A malicious miner scheduled for a NextTerm block can:
1. Call `GetConsensusExtraData` when the consensus contract state has LIB = X
2. Wait for other miners to advance LIB to Y > X through normal UpdateValue operations
3. Produce their NextTerm block using the cached data with stale LIB = X
4. The block passes validation because NextTerm lacks LIB validation
5. `ProcessNextTerm` saves the round with LIB = X to consensus contract state [9](#0-8) 

## Impact Explanation

This vulnerability violates an explicitly stated security invariant in the consensus contract, creating consensus state corruption with the following impacts:

**Consensus State Integrity Breach:**
- The consensus contract's stored LIB value can regress, violating the invariant that it should only increase
- Future consensus operations will use corrupted base LIB values for validation
- The `LibInformationValidationProvider` checks in subsequent UpdateValue operations will compare against the rolled-back value

**Validation Bypass:**
- The explicit comment states LIB regression "should not happen", yet NextTerm allows exactly this
- Security invariant is bypassed through inconsistent validation application

**Dependent System Impact:**
- Any system querying the consensus contract's round information will receive incorrect LIB values
- Future LIB calculations in UpdateValue operations will use the corrupted base value

Note: While the consensus contract state is corrupted, the blockchain's actual LIB (managed by `IrreversibleBlockFoundLogEventProcessor` via `IrreversibleBlockFound` events) is not directly rolled back, as `ProcessNextTerm` does not fire such events. However, the state inconsistency between consensus contract and blockchain remains a serious integrity violation.

## Likelihood Explanation

**Attacker Prerequisites:**
1. Must be a valid miner in the current round
2. Must be scheduled to produce a NextTerm block

**Achievability:**
- Any party can become a miner through the election process by obtaining votes
- Term transitions occur at regular intervals
- Any miner in rotation will eventually be scheduled for a NextTerm block

**Attack Complexity:** MODERATE
- `GetConsensusExtraData` is a public view method callable without restrictions
- Requires intentional caching of consensus data at time T1 and using it at time T2
- No cryptographic complexity required
- Zero validation enables the attack

**Probability Assessment:** MEDIUM-HIGH

The combination of achievable prerequisites (becoming a miner), regular opportunities (term transitions), and complete absence of validation makes this feasible for a motivated attacker with mining capabilities.

## Recommendation

Add `LibInformationValidationProvider` to the NextTerm validation flow to maintain consistency with UpdateValue and enforce the stated invariant:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add LIB validation
    break;
```

This ensures that NextTerm blocks cannot contain regressed LIB values, maintaining consensus state integrity across all consensus behaviors.

## Proof of Concept

A test demonstrating the vulnerability would:
1. Set up initial state with LIB = 100
2. Generate NextTerm consensus data at this point
3. Advance LIB to 200 through normal UpdateValue operations
4. Produce a NextTerm block using the cached data with LIB = 100
5. Verify the block passes validation despite containing stale LIB
6. Confirm consensus contract state now has LIB = 100 (regressed from 200)

### Citations

**File:** protobuf/acs4.proto (L25-27)
```text
    rpc GetConsensusExtraData (google.protobuf.BytesValue) returns (google.protobuf.BytesValue) {
        option (aelf.is_view) = true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L45-47)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L244-245)
```csharp
        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L51-52)
```csharp
        round.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        round.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L196-196)
```csharp
        AddRoundInformation(nextRound);
```
