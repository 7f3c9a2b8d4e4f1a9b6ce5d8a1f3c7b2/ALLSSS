# Audit Report

## Title
Missing Period Expiration Validation Allows Premature Term Changes

## Summary
The consensus validation logic fails to verify that term changes occur only when the required period has expired and 2/3+1 miners consent. A malicious miner can force a term change prematurely by providing `NextTerm` behaviour without proper validation, breaking the Byzantine fault tolerance guarantee and triggering premature treasury releases and election snapshots.

## Finding Description

The AEDPoS consensus mechanism has a critical validation gap that allows miners to unilaterally force term changes without meeting the required consensus conditions.

**Command Generation vs. Validation Discrepancy:**

The `TerminateRoundCommandStrategy` sets `_isNewTerm` based on the `behaviour` parameter provided in the trigger information. [1](#0-0) 

This behaviour comes from `AElfConsensusTriggerInformation` which is provided by the miner through `GetConsensusBlockExtraData`: [2](#0-1) 

While `MainChainConsensusBehaviourProvider` correctly checks `NeedToChangeTerm()` to determine the appropriate behaviour during command generation: [3](#0-2) 

The `NeedToChangeTerm()` method validates that at least 2/3+1 miners have mined in the new term period based on period expiration: [4](#0-3) 

**The Critical Gap:**

However, the validation phase does NOT re-check these conditions. `RoundTerminateValidationProvider.ValidationForNextTerm()` only verifies structural correctness (round and term numbers properly incremented): [5](#0-4) 

The `NextTerm` method directly processes the consensus information without validating `NeedToChangeTerm()` conditions: [6](#0-5) 

And `ProcessNextTerm` proceeds without verifying whether the period has expired or 2/3+1 consensus exists: [7](#0-6) 

**Attack Execution:**

A malicious miner controls their node software and can modify the trigger information to provide `Behaviour = NextTerm` even when `GetConsensusCommand` suggests `NextRound`. The miner node creates trigger information based on consensus commands via `AEDPoSTriggerInformationProvider`, which extracts behavior from the hint: [8](#0-7) 

Since miners control their own node software, they can override this behavior before calling `GetConsensusExtraData`.

## Impact Explanation

This vulnerability has **CRITICAL** severity with multiple severe impacts:

1. **Consensus Integrity Violation**: The 2/3+1 Byzantine fault tolerance threshold is completely bypassed. A single miner can force term changes, breaking the fundamental consensus safety guarantee.

2. **Premature Treasury Releases**: Term changes trigger treasury releases without proper consensus, causing incorrect fund distributions: [9](#0-8) 

3. **Manipulated Election Snapshots**: Election snapshots are taken with incomplete miner performance data, affecting future miner selection and governance: [10](#0-9) 

4. **Reward Misallocation**: Mining rewards are calculated and donated based on manipulated round data: [11](#0-10) 

5. **Governance Disruption**: Premature term changes affect miner list updates and election contract state, cascading into voting power distribution and future consensus participation.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Capabilities**: Any active miner in the current round can execute this attack. The only requirement is being in the miner list, which is validated by `MiningPermissionValidationProvider`: [12](#0-11) 

**Attack Complexity**: LOW - The attacker simply modifies their node software to provide `Behaviour = NextTerm` in the trigger information when calling `GetConsensusExtraData`, then produces a block with term number incremented by 1.

**Preconditions**: 
- Attacker must be in the current miner list (normal operational requirement)
- No additional economic cost beyond normal block production
- No special privileges needed

**Detection Difficulty**: The attack appears as a legitimate consensus state transition since all validation checks pass. Network nodes would accept the block as valid.

**Verification**: A grep search confirms `NeedToChangeTerm` is ONLY called in `MainChainConsensusBehaviourProvider` for command generation and never during validation, making this vulnerability definitively exploitable.

## Recommendation

Add validation in `RoundTerminateValidationProvider.ValidationForNextTerm()` to verify `NeedToChangeTerm()` conditions before accepting a NextTerm behavior:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Verify term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // ADD THIS VALIDATION:
    // Verify that NeedToChangeTerm conditions are actually met
    var blockchainStartTimestamp = /* retrieve from state */;
    var periodSeconds = /* retrieve from state */;
    if (!validationContext.BaseRound.NeedToChangeTerm(
        blockchainStartTimestamp, 
        validationContext.BaseRound.TermNumber, 
        periodSeconds))
    {
        return new ValidationResult { 
            Message = "Term change conditions not met: insufficient miner consent or period not expired." 
        };
    }

    return new ValidationResult { Success = true };
}
```

Additionally, add a check in `ProcessNextTerm` before processing:
```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // Verify NeedToChangeTerm conditions
    TryToGetCurrentRoundInformation(out var currentRound);
    var blockchainStartTimestamp = GetBlockchainStartTimestamp();
    Assert(currentRound.NeedToChangeTerm(blockchainStartTimestamp, 
        currentRound.TermNumber, State.PeriodSeconds.Value),
        "Term change conditions not met.");
    
    // Continue with existing logic...
    RecordMinedMinerListOfCurrentRound();
    // ...
}
```

## Proof of Concept

A test demonstrating this vulnerability would:

1. Setup a consensus round with current term number N
2. Configure period seconds so that NeedToChangeTerm() returns false (period not expired or < 2/3+1 miners mined in new period)
3. Have a miner call GetConsensusExtraData with triggerInformation.Behaviour = NextTerm
4. Submit the NextTerm transaction with term number N+1
5. Verify that validation passes (ValidationForNextTerm succeeds)
6. Verify that ProcessNextTerm executes successfully
7. Observe premature treasury release and election snapshot

The test would demonstrate that the validation accepts a term change even when `NeedToChangeTerm()` conditions are not satisfied, proving the validation gap exists.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L14-21)
```csharp
        private readonly bool _isNewTerm;

        public TerminateRoundCommandStrategy(Round currentRound, string pubkey, Timestamp currentBlockTime,
            bool isNewTerm) : base(
            currentRound, pubkey, currentBlockTime)
        {
            _isNewTerm = isNewTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L26-48)
```csharp
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-174)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L41-75)
```csharp
    public BytesValue GetTriggerInformationForBlockHeaderExtraData(BytesValue consensusCommandBytes)
    {
        if (consensusCommandBytes == null)
            return new AElfConsensusTriggerInformation
            {
                Pubkey = Pubkey,
                Behaviour = AElfConsensusBehaviour.UpdateValue
            }.ToBytesValue();

        var command = consensusCommandBytes.ToConsensusCommand();
        var hint = command.Hint.ToAElfConsensusHint();

        if (hint.Behaviour == AElfConsensusBehaviour.UpdateValue)
        {
            var newInValue = _inValueCache.GetInValue(hint.RoundId);
            var previousInValue = _inValueCache.GetInValue(hint.PreviousRoundId);
            Logger.LogDebug($"New in value {newInValue} for round of id {hint.RoundId}");
            Logger.LogDebug($"Previous in value {previousInValue} for round of id {hint.PreviousRoundId}");
            var trigger = new AElfConsensusTriggerInformation
            {
                Pubkey = Pubkey,
                InValue = newInValue,
                PreviousInValue = previousInValue,
                Behaviour = hint.Behaviour
            };

            return trigger.ToBytesValue();
        }

        return new AElfConsensusTriggerInformation
        {
            Pubkey = Pubkey,
            Behaviour = hint.Behaviour
        }.ToBytesValue();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
