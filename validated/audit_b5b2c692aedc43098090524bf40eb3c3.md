# Audit Report

## Title
Authorization Bypass in CreateScheme Allows Attacker to Pollute Victim's Manager Scheme List Causing Bounded DoS

## Summary
The `CreateScheme` function in the Profit contract lacks authorization checks when setting an arbitrary address as the scheme manager. Any attacker can create schemes designating a victim as the manager without consent, polluting the victim's managing scheme list up to the state size limit of approximately 3,700-4,000 schemes (128KB). This causes bounded DoS when querying `GetManagingSchemeIds`, degrading performance for victims and clients processing their scheme data.

## Finding Description
The vulnerability exists in the `CreateScheme` function where it accepts an arbitrary `input.Manager` parameter and assigns it as the scheme manager without verifying that the caller has authorization to do so. [1](#0-0) 

The function uses `input.Manager ?? Context.Sender`, accepting any address provided by the caller. There is no assertion like `Assert(manager == Context.Sender, ...)` to verify that the caller has permission to designate the specified manager.

The scheme ID is then added to the manager's list without any permission check: [2](#0-1) 

**Attack Execution Path:**
1. Attacker calls `CreateScheme` with `input.Manager` set to victim's address
2. The scheme is created with victim as manager without consent verification  
3. The scheme ID is added to `State.ManagingSchemeIds[victim]`
4. Attacker repeats this up to the state size limit

**Why Existing Protections Fail:**
The function only validates `ProfitReceivingDuePeriodCount` and scheme uniqueness: [3](#0-2) 

No authorization check exists on the manager field assignment. Compare this to other manager-restricted operations like `AddSubScheme`, which properly verifies: [4](#0-3) 

Or `ResetManager`: [5](#0-4) 

**State Size Bound:**
The attack is bounded by AElf's state size limit of 128KB per state write: [6](#0-5) 

The `CreatedSchemeIds` protobuf message contains a repeated Hash field: [7](#0-6) 

Each Hash is 32 bytes, plus protobuf overhead (field tags, length encoding) results in approximately 35 bytes per entry. This allows approximately 128KB / 35 bytes â‰ˆ 3,700-4,000 schemes maximum per manager address before state writes fail.

**Unbounded View Method:**
The `GetManagingSchemeIds` view method returns the entire list without pagination: [8](#0-7) 

This forces clients to process up to 128KB of data when querying a victim's schemes.

## Impact Explanation
**Operational DoS Impact:**
- Victim's `GetManagingSchemeIds` query returns up to ~4,000 unwanted scheme IDs (128KB of data)
- Clients/nodes processing this data experience degraded performance with memory and CPU overhead
- The victim's legitimate scheme management interface becomes polluted with attacker-created schemes
- Applications displaying scheme lists must process and render thousands of malicious entries

**Authorization Violation:**
- Victims become managers of schemes they never created or authorized
- This violates the expected security invariant that users control their own manager role assignments
- Other manager-privileged operations in the contract properly verify `Context.Sender == scheme.Manager`, establishing the expectation that manager assignment should be consensual

**Affected Parties:**
- Targeted manager addresses (victims)
- Clients/applications querying victim's schemes  
- Blockchain nodes serving large responses

**Severity: Medium** due to:
1. Clear authorization bypass requiring no victim consent
2. Bounded but significant DoS (128KB, ~4,000 schemes)
3. Practical exploitability with reasonable cost
4. Operational degradation rather than direct fund loss

## Likelihood Explanation
**Attacker Capabilities:**
- Any address with sufficient ELF tokens for transaction fees
- No special permissions or trusted role required

**Attack Complexity:**
Simple attack requiring only repeated calls to a public method. The transaction fee is 10 ELF per CreateScheme call: [9](#0-8) 

**Feasibility:**
- Maximum attack cost: ~40,000 ELF to create 4,000 schemes
- Smaller-scale attacks (100-500 schemes) cost 1,000-5,000 ELF and still cause noticeable degradation
- No rate limiting or scheme creation caps per manager exist
- Economically feasible for motivated attackers (competitors, griefers)

**Detection/Mitigation:**
- Attack is publicly visible on-chain
- Victim cannot easily remove unwanted schemes from their list (would require calling `ResetManager` up to 4,000 times at their own gas cost) [10](#0-9) 

- No built-in protection or reversal mechanism

## Recommendation
Add an authorization check in the `CreateScheme` function to ensure that only the intended manager can be designated. The fix should verify that if `input.Manager` is specified, it must match `Context.Sender`:

```csharp
public override Hash CreateScheme(CreateSchemeInput input)
{
    ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);
    
    // NEW: Verify manager authorization
    if (input.Manager != null)
    {
        Assert(input.Manager == Context.Sender, 
            "Only the manager themselves can be designated as scheme manager.");
    }
    
    if (input.ProfitReceivingDuePeriodCount == 0)
        input.ProfitReceivingDuePeriodCount = ProfitContractConstants.DefaultProfitReceivingDuePeriodCount;
    // ... rest of the function
}
```

Alternatively, always set the manager to `Context.Sender` and ignore the input parameter to prevent any possibility of unauthorized manager assignment.

## Proof of Concept
The following test demonstrates the vulnerability:

```csharp
[Fact]
public async Task CreateScheme_WithArbitraryManager_ShouldPolluteManagedSchemes()
{
    // Setup: Attacker and victim addresses
    var attackerKeyPair = SampleECKeyPairs.KeyPairs[1];
    var attackerAddress = Address.FromPublicKey(attackerKeyPair.PublicKey);
    var victimAddress = SampleECKeyPairs.KeyPairs[2].PublicKey.ToAddress();
    
    // Attacker creates scheme with victim as manager (without victim's consent)
    var createSchemeInput = new CreateSchemeInput
    {
        Manager = victimAddress,  // Victim address set by attacker
        IsReleaseAllBalanceEveryTimeByDefault = true
    };
    
    var schemeId = await ProfitContractStub.CreateScheme.SendAsync(createSchemeInput);
    
    // Query victim's managed schemes
    var managedSchemes = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = victimAddress });
    
    // Verify: Victim now manages scheme they didn't create
    Assert.Contains(schemeId.Output, managedSchemes.SchemeIds);
    
    // Verify: Scheme manager is victim, but Context.Sender was attacker
    var scheme = await ProfitContractStub.GetScheme.CallAsync(schemeId.Output);
    Assert.Equal(victimAddress, scheme.Manager);
}
```

This test proves that an attacker can designate an arbitrary victim as a scheme manager without any authorization check, directly polluting the victim's `ManagingSchemeIds` list.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L48-59)
```csharp
        if (input.ProfitReceivingDuePeriodCount == 0)
            input.ProfitReceivingDuePeriodCount = ProfitContractConstants.DefaultProfitReceivingDuePeriodCount;
        else
            Assert(
                input.ProfitReceivingDuePeriodCount > 0 &&
                input.ProfitReceivingDuePeriodCount <= ProfitContractConstants.MaximumProfitReceivingDuePeriodCount,
                "Invalid profit receiving due period count.");

        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L99-99)
```csharp
        Assert(Context.Sender == scheme.Manager, "Only manager can add sub-scheme.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L723-743)
```csharp
    public override Empty ResetManager(ResetManagerInput input)
    {
        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only scheme manager can reset manager.");
        Assert(input.NewManager.Value.Any(), "Invalid new sponsor.");

        // Transfer managing scheme id.
        var oldManagerSchemeIds = State.ManagingSchemeIds[scheme.Manager];
        oldManagerSchemeIds.SchemeIds.Remove(input.SchemeId);
        State.ManagingSchemeIds[scheme.Manager] = oldManagerSchemeIds;
        var newManagerSchemeIds = State.ManagingSchemeIds[input.NewManager] ?? new CreatedSchemeIds();
        newManagerSchemeIds.SchemeIds.Add(input.SchemeId);
        State.ManagingSchemeIds[input.NewManager] = newManagerSchemeIds;

        scheme.Manager = input.NewManager;
        State.SchemeInfos[input.SchemeId] = scheme;
        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** protobuf/profit_contract.proto (L288-291)
```text
message CreatedSchemeIds {
    // The scheme ids.
    repeated aelf.Hash scheme_ids = 1;
}
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L42-49)
```csharp
            case nameof(CreateScheme):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
```
