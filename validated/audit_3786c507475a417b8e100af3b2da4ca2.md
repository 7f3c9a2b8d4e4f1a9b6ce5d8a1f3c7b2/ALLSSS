# Audit Report

## Title
Quit Candidates Can Bypass Election Restrictions and Become Consensus Validators via InitialMiners List

## Summary
The Election Contract's `GetVictories()` method fails to validate that pubkeys in the `InitialMiners` list are legitimate current candidates before selecting them as backup consensus validators. This allows a candidate who has quit the election to be moved into `InitialMiners` via `ReplaceCandidatePubkey()` and subsequently selected as a validator, bypassing the election process entirely.

## Finding Description

The vulnerability stems from insufficient validation in multiple components of the Election Contract that collectively enable quit candidates to become validators through the `InitialMiners` backdoor.

**Root Cause 1: Overly Permissive Authorization Check**

The `IsCurrentCandidateOrInitialMiner()` function grants full privileges to any pubkey in `InitialMiners`, regardless of whether they are current candidates: [1](#0-0) 

This authorization check is used to permit sensitive operations including `SetCandidateAdmin`: [2](#0-1) 

And `ReplaceCandidatePubkey`: [3](#0-2) 

**Root Cause 2: QuitElection Doesn't Remove from InitialMiners**

When a candidate quits, their `IsCurrentCandidate` flag is set to false: [4](#0-3) 

And they are removed from the `Candidates` list: [5](#0-4) 

However, there is no logic to remove the pubkey from `InitialMiners` if present, allowing quit candidates to retain their position if they were previously added via replacement.

**Root Cause 3: ReplaceCandidatePubkey Allows Arbitrary Additions to InitialMiners**

The `ReplaceCandidatePubkey()` method allows an initial miner's admin to replace their pubkey with any pubkey without validation that the new pubkey is a current candidate: [6](#0-5) 

Critically, only the OLD pubkey is banned, not the new one: [7](#0-6) 

**Root Cause 4: GetVictories Lacks Validation for InitialMiners Backups**

The critical flaw is in `GetVictories()`, which uses `InitialMiners` as backups when there are insufficient valid candidates, but performs NO validation on these pubkeys: [8](#0-7) 

The function retrieves valid candidates (those in the Candidates list with votes > 0): [9](#0-8) 

However, when backfilling from `InitialMiners`, no checks are performed for:
- Whether the pubkey has `IsCurrentCandidate = true`
- Whether the pubkey is in the `Candidates` list  
- Whether the pubkey is banned

**Attack Path:**

1. Attacker announces election with pubkey A (becomes a current candidate, locks 100k ELF)
2. Attacker calls `QuitElection()` with pubkey A → `IsCurrentCandidate` set to false, A removed from `Candidates` list, locked tokens returned
3. An initial miner B's admin (compromised or cooperating) calls `ReplaceCandidatePubkey(B → A)` → B removed from `InitialMiners`, A added to `InitialMiners`, B is banned but A is NOT banned
4. When consensus contract calls `GetVictories()` during term transition with insufficient valid candidates → A is added to backups from `InitialMiners` and selected as a consensus validator
5. The consensus contract uses this result to generate the next round: [10](#0-9) [11](#0-10) 

**Why Existing Protections Fail:**

The prevention of initial miners announcing election only works one direction: [12](#0-11) 

This prevents initial miners from becoming candidates, but doesn't prevent quit candidates from entering `InitialMiners` through replacement. Additionally, while `GetMinerReplacementInformation` properly filters banned InitialMiners, `GetVictories` does not: [13](#0-12) 

## Impact Explanation

**Critical Consensus Integrity Violation:**
- A quit candidate who bypassed the election becomes a consensus validator
- They can produce blocks, participate in consensus decisions, and earn mining rewards
- This fundamentally violates the election-based validator selection mechanism where token holders' votes determine validator selection
- The protocol's core security assumption—that validators are elected by token holders—is broken

**High Authorization Bypass:**
- Quit candidates in `InitialMiners` retain admin management capabilities through `IsCurrentCandidateOrInitialMiner()` 
- They can call `SetCandidateAdmin` and enable further `ReplaceCandidatePubkey` operations
- This creates a persistent validator position outside the election system that can be perpetually maintained through cyclic replacements

**Protocol Governance Impact:**
- `InitialMiners` is designed for trusted bootstrap nodes at network genesis, not arbitrary participants
- Allowing quit candidates to occupy these slots undermines the bootstrap security model
- Legitimate candidates elected by the community are excluded from miner selection
- The attacker earns block production rewards without community approval

## Likelihood Explanation

**Feasibility Assessment: Moderate-to-High**

The main barrier is obtaining initial miner admin cooperation or compromise. This could occur through:
- Key rotation scenarios where security procedures are lax
- Social engineering or economic incentives targeting admin key holders
- Insider threats or compromised administrator accounts
- Governance process exploitation if replacements can be proposed

The insufficient candidates condition occurs naturally during:
- Network launch and early growth phases
- Low participation periods
- Following mass candidate withdrawal events
- Market downturns affecting validator economics

**This is About Mis-Scoped Privileges:**

While exploitation requires initial miner admin action, this vulnerability represents a design flaw in privilege scoping rather than just "compromised admin" scenario. The issue is that:
- `ReplaceCandidatePubkey` grants admins excessive power (can add ANY pubkey to InitialMiners)
- `GetVictories` fails to validate InitialMiners entries (unlike `GetMinerReplacementInformation` which does check bans)
- The privilege should be scoped to legitimate key rotation, not arbitrary pubkey injection

Even trusted administrators should not have the power to arbitrarily add non-candidates to the validator set, as this breaks fundamental protocol invariants.

## Recommendation

**Fix 1: Validate New Pubkey in ReplaceCandidatePubkey**

Add validation that the new pubkey is a current candidate when replacing into InitialMiners:

```csharp
public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
{
    Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
        "Pubkey is neither a current candidate nor an initial miner.");
    Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
        "Pubkey is already banned.");
    
    // NEW: Validate new pubkey is a current candidate
    var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
    if (State.InitialMiners.Value.Value.Contains(oldPubkeyBytes))
    {
        var candidateInfo = State.CandidateInformationMap[input.NewPubkey];
        Assert(candidateInfo != null && candidateInfo.IsCurrentCandidate,
            "New pubkey must be a current candidate to replace an initial miner.");
    }
    
    // ... rest of method
}
```

**Fix 2: Validate InitialMiners in GetVictories**

Add validation checks when using InitialMiners as backups:

```csharp
if (State.InitialMiners.Value != null)
{
    var validInitialMiners = State.InitialMiners.Value.Value
        .Select(k => k.ToHex())
        .Where(k => !backups.Contains(k))
        .Where(k => !State.BannedPubkeyMap[k])
        .Where(k => State.CandidateInformationMap[k]?.IsCurrentCandidate == true);
    backups.AddRange(validInitialMiners);
}
```

**Fix 3: Remove from InitialMiners on QuitElection**

Modify `QuitElection` to remove the pubkey from InitialMiners if present:

```csharp
State.Candidates.Value.Value.Remove(publicKeyByteString);

// NEW: Also remove from InitialMiners if present
if (State.InitialMiners.Value.Value.Contains(publicKeyByteString))
{
    var initialMiners = State.InitialMiners.Value;
    initialMiners.Value.Remove(publicKeyByteString);
    State.InitialMiners.Value = initialMiners;
}
```

## Proof of Concept

Note: A complete PoC would require a full test harness with Election Contract, Consensus Contract, and token locking setup. The vulnerability is validated through code inspection of the execution path:

1. Candidate announces and quits (removes from Candidates, sets IsCurrentCandidate=false)
2. Initial miner admin calls ReplaceCandidatePubkey (adds quit candidate to InitialMiners with no validation)
3. GetVictories called with insufficient candidates (includes InitialMiners without validation)
4. Consensus contract uses result to set validator set (quit candidate becomes miner)

The code paths have been verified at:
- Authorization: `ElectionContract_Candidate.cs:75-82`
- Quit logic: `ElectionContract_Candidate.cs:252,298`
- Replacement logic: `ElectionContract_Maintainence.cs:220-226,246`
- Victory selection: `ViewMethods.cs:62-77`
- Consensus usage: `AEDPoSContract_ViewMethods.cs:274,228-232`

## Notes

This vulnerability represents a privilege mis-scoping issue where initial miner admins have excessive power to manipulate the validator set. While the barrier to exploitation is moderate-to-high (requires admin cooperation), the design flaw creates an attack surface that shouldn't exist. The proper design should enforce that validator selection ALWAYS respects the election process, with no backdoor mechanisms that bypass community governance.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L21-22)
```csharp
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L75-82)
```csharp
    private bool IsCurrentCandidateOrInitialMiner(string pubkey)
    {
        var isCurrentCandidate = State.CandidateInformationMap[pubkey] != null &&
                                 State.CandidateInformationMap[pubkey].IsCurrentCandidate;
        var isInitialMiner = State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey)));
        return isCurrentCandidate || isInitialMiner;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L149-150)
```csharp
        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L252-254)
```csharp
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L298-298)
```csharp
        State.Candidates.Value.Value.Remove(publicKeyByteString);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L175-176)
```csharp
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L246-246)
```csharp
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L62-77)
```csharp
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L386-391)
```csharp
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L274-274)
```csharp
        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
```
