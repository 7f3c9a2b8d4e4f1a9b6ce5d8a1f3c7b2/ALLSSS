# Audit Report

## Title
Insufficient MaximalRejectionThreshold Validation Allows Governance Bypass Through Threshold Misconfiguration

## Summary
The Association contract contains an off-by-one error in rejection threshold validation that allows proposals to pass despite overwhelming opposition. The validation permits `MaximalRejectionThreshold = organizationMemberCount - MinimalApprovalThreshold`, while the rejection check uses strict greater-than comparison (`>`), enabling a proposal with 1 approval and 99 rejections in a 100-member organization to be released.

## Finding Description

The vulnerability stems from an inconsistency between the validation logic and the rejection check logic in the Association contract.

The organization validation allows `MaximalRejectionThreshold` to be set to `organizationMemberCount - MinimalApprovalThreshold`: [1](#0-0) 

However, the rejection check uses strict greater-than comparison, only rejecting when `rejectionMemberCount > MaximalRejectionThreshold`: [2](#0-1) 

This means when rejections equal `MaximalRejectionThreshold`, the proposal is NOT rejected. The release logic first checks rejection status, and if not rejected with sufficient approvals, allows release: [3](#0-2) 

The vulnerable entry point is the publicly accessible `CreateOrganization` method: [4](#0-3) 

Organizations can also be reconfigured via `ChangeOrganizationThreshold`: [5](#0-4) 

**Attack Scenario:**
In a 100-member organization with `MinimalApprovalThreshold = 1`, `MaximalRejectionThreshold = 99`, `MinimalVoteThreshold = 100`:
- Configuration passes validation: `99 + 1 = 100 ≤ 100` ✓
- Attacker creates proposal and gets 1 approval
- 99 members reject (99% opposition)
- Rejection check: `99 > 99` = FALSE → Proposal NOT rejected
- Approval check: `1 ≥ 1` = TRUE → Sufficient approvals  
- Vote threshold check: `100 ≥ 100` = TRUE → Sufficient participation
- **Proposal can be released despite 99% rejection**

## Impact Explanation

This vulnerability fundamentally subverts the Association contract's multi-signature governance model. Organizations can be created where the rejection mechanism is effectively disabled through legitimate-appearing threshold configurations.

**Severity Impact:**
- **Governance Capture**: Minority members can execute proposals against overwhelming majority opposition
- **Protocol-Wide Risk**: Association organizations are used throughout the AElf ecosystem for governance of critical operations including cross-chain operations, token management, and treasury control
- **Trust Violation**: Breaks the core security guarantee that sufficient rejections prevent proposal execution

The impact is **HIGH** because it allows unauthorized governance actions that bypass the intended multi-signature protection mechanism.

## Likelihood Explanation

The likelihood is **HIGH** due to:

**Accessible Entry Point**: `CreateOrganization` is publicly callable with no authorization requirements [6](#0-5) 

**No Preconditions**: Any user can create organizations with manipulated thresholds that pass validation

**Detection Difficulty**: The configuration appears mathematically valid (`MaximalRejectionThreshold + MinimalApprovalThreshold ≤ memberCount`), making the semantic vulnerability non-obvious to users

**Execution Simplicity**: 
1. Create organization with boundary threshold values
2. Add members (legitimate or Sybil)
3. Create proposal
4. Obtain minimal approvals
5. Release despite overwhelming rejections

## Recommendation

Fix the off-by-one error by using one of two approaches:

**Option 1: Change rejection check to use >= instead of >**
```csharp
return rejectionMemberCount >= organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**Option 2: Change validation to use strict less-than instead of <=**
```csharp
proposalReleaseThreshold.MaximalRejectionThreshold +
proposalReleaseThreshold.MinimalApprovalThreshold < organizationMemberCount;
```

**Recommended: Option 1** is cleaner as it makes the rejection threshold inclusive, matching typical threshold semantics where "maximal rejection threshold of 99" means "reject if 99 or more members reject."

Apply the same fix pattern to `MaximalAbstentionThreshold` for consistency: [7](#0-6) 

## Proof of Concept

```csharp
[Fact]
public async Task Exploit_MaximalRejectionThreshold_OffByOne_Test()
{
    // Setup: Create 100-member organization with manipulated thresholds
    var members = new List<Address>();
    for (int i = 0; i < 100; i++)
    {
        members.Add(Accounts[i % Accounts.Count].Address);
    }
    
    var createOrgInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { members }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1,
            MaximalRejectionThreshold = 99, // Boundary value that passes validation
            MinimalVoteThreshold = 100,
            MaximalAbstentionThreshold = 0
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { Reviewer1 }
        }
    };
    
    // Create organization - should succeed with these thresholds
    var orgResult = await AssociationContractStub.CreateOrganization.SendAsync(createOrgInput);
    orgResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var orgAddress = orgResult.Output;
    
    // Create proposal
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, orgAddress);
    
    // Simulate voting: 1 approval, 99 rejections
    await ApproveAsync(Reviewer1KeyPair, proposalId);
    
    for (int i = 1; i < 100; i++)
    {
        await RejectAsync(Accounts[i % Accounts.Count].KeyPair, proposalId);
    }
    
    // Check proposal status - should show ready to release despite 99% rejection
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeTrue(); // VULNERABILITY: Proposal can be released!
    
    // Release should succeed
    var releaseResult = await GetAssociationContractTester(Reviewer1KeyPair).Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Proposal executed despite 99 rejections out of 100 votes
}
```

## Notes

This vulnerability affects the fundamental security model of Association governance. The off-by-one error creates a semantic gap between what users expect (rejections at or above the threshold prevent execution) and what actually happens (only rejections strictly greater than the threshold prevent execution).

The same pattern applies to `MaximalAbstentionThreshold`, suggesting both should be reviewed and fixed consistently. The validation logic appears mathematically sound but enables configurations that violate governance intent due to the mismatched comparison operator in the rejection/abstention checks.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L79-80)
```csharp
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-216)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```
