# Audit Report

## Title
Consensus Transaction Signer Mismatch Enables Continuous Block Limit Bypass

## Summary
The AEDPoS consensus contract's continuous block limit mechanism can be bypassed through a pubkey mismatch between block validation and state update phases. Validation checks the block signer's pubkey, while state updates use the transaction signer's pubkey. Two colluding miners can alternate signing consensus transactions while one miner produces all blocks, continuously resetting the counter and bypassing the limit designed to prevent excessive consecutive block production.

## Finding Description

The vulnerability stems from a fundamental architectural mismatch in how public keys are sourced during different phases of consensus block processing:

**Validation Phase (Pre-Execution):**
The `ContinuousBlocksValidationProvider` validates blocks using `validationContext.SenderPubkey`, which is derived from `ExtraData.SenderPubkey` representing the block signer's public key. [1](#0-0) 

This block signer pubkey is validated against the stored state to detect excessive consecutive blocks: [2](#0-1) 

The system cryptographically verifies that `ExtraData.SenderPubkey` matches `header.SignerPubkey` during block header extraction: [3](#0-2) 

**Execution Phase (During Transaction Processing):**
During consensus transaction execution, the contract recovers the public key from the transaction signature (not the block signature): [4](#0-3) 

This transaction-derived pubkey is then used to update the continuous block counter state: [5](#0-4) 

**Missing Validation:**
Critically, there is no enforcement that the transaction signer must equal the block signer. The only transaction signer check verifies membership in the miner list, not equality with the block signer: [6](#0-5) 

**Attack Mechanism:**
With `MaximumTinyBlocksCount = 8`, the counter starts at 7 for a fresh miner: [7](#0-6) 

When colluding miners A and B alternate transaction signers while A produces all blocks:
1. Block N: A produces (block signed by A), transaction signed by B → State updates with B's pubkey, counter resets to 7
2. Block N+1: A produces (block signed by A), transaction signed by A → Validation checks A ≠ B (passes), state updates with A, counter resets to 7
3. Block N+2: A produces (block signed by A), transaction signed by B → Validation checks A = A but counter is 7 > 0 (passes), state updates with B, counter resets to 7

This pattern repeats indefinitely, preventing the counter from ever reaching the negative threshold that would trigger validation failure.

## Impact Explanation

This vulnerability breaks a fundamental consensus security guarantee explicitly designed to prevent single-miner dominance: [8](#0-7) 

The continuous block limit serves critical consensus purposes documented in the blockchain mining status evaluator: [9](#0-8) 

Bypassing this protection enables:

1. **Consensus Centralization**: One miner gains monopolistic control over block production, undermining AEDPoS decentralization guarantees
2. **Transaction Censorship**: Extended block production control enables systematic censorship of specific transactions or addresses
3. **MEV Extraction**: Prolonged mining monopoly maximizes extractable value across more consecutive blocks
4. **Reward Misallocation**: Unfair concentration of mining rewards to the colluding parties
5. **Chain Instability**: Extended single-producer sequences increase reorganization risks and reduce network resilience

## Likelihood Explanation

The attack is **highly feasible** with realistic preconditions:

1. **Direct Entry Points**: Public consensus methods are directly accessible: [10](#0-9) 

2. **Minimal Collusion Requirements**: Requires only 2 out of approximately 17 miners to collude - realistic given that miner coordination already occurs for legitimate consensus operations

3. **No Technical Barriers**: Each signature is independently valid. The transaction signer check only validates miner list membership, not block signer equality. A block producer can include any transaction signed by another miner as long as both are in the active miner list

4. **Economic Incentives**: Block production rewards and MEV opportunities provide strong financial motivation for exploitation

5. **Low Detection Probability**: The attack appears as normal alternating mining when examining components individually; detection requires cross-referencing block signers with transaction signers across multiple blocks

## Recommendation

Enforce that the transaction signer must equal the block signer for consensus transactions. Add validation in `PreCheck()`:

```csharp
private bool PreCheck()
{
    TryToGetCurrentRoundInformation(out var currentRound);
    TryToGetPreviousRoundInformation(out var previousRound);

    _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();
    
    // NEW: Enforce transaction signer matches block signer
    var blockSignerPubkey = Context.GetBlockSenderPubkey(); // Get from block extra data
    if (_processingBlockMinerPubkey != blockSignerPubkey)
    {
        Context.LogDebug(() => 
            $"Transaction signer {_processingBlockMinerPubkey} does not match block signer {blockSignerPubkey}");
        return false;
    }

    if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
        !previousRound.IsInMinerList(_processingBlockMinerPubkey))
        return false;

    return true;
}
```

Alternatively, use the block signer pubkey from the validated extra data for state updates instead of recovering from the transaction signature.

## Proof of Concept

```csharp
[Fact]
public async Task ContinuousBlockLimit_BypassedByTransactionSignerMismatch()
{
    // Setup: Initialize consensus with miners A and B
    var minerA = SampleAccount.Accounts[0];
    var minerB = SampleAccount.Accounts[1];
    var minerList = new MinerList { Pubkeys = { minerA.PublicKey, minerB.PublicKey } };
    
    // Start normal mining - A produces blocks with A's transaction signature
    for (int i = 0; i < 7; i++)
    {
        await ProduceBlock(minerA, minerA); // Block signer: A, Tx signer: A
    }
    
    // 8th block should still pass (counter at 0)
    await ProduceBlock(minerA, minerA);
    
    // 9th block SHOULD FAIL in normal operation
    // But with mismatch: A produces block, B signs transaction
    await ProduceBlock(minerA, minerB); // Block signer: A, Tx signer: B → PASSES (counter reset)
    
    // Continue indefinitely by alternating
    for (int i = 0; i < 100; i++)
    {
        await ProduceBlock(minerA, i % 2 == 0 ? minerA : minerB);
    }
    
    // Verify: Miner A produced >100 consecutive blocks, bypassing the limit
    var blockHeight = await GetCurrentHeight();
    blockHeight.ShouldBeGreaterThan(108); // Should have failed at block 9
}
```

## Notes

This vulnerability requires access to the kernel-level block production infrastructure to fully demonstrate, as it involves coordinating block signing (kernel layer) with transaction signing (contract layer). The proof of concept above represents the logical flow; actual exploitation would require:

1. Miner A's node producing blocks and signing block headers with A's key
2. Including consensus transactions signed with Miner B's key (B would create and sign these transactions and send them to A)
3. Both signatures being cryptographically valid but belonging to different miners

The validation logic trusts that block signer and transaction signer are the same, but this invariant is not enforced, creating the exploitable mismatch.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L17-17)
```csharp
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L29-32)
```csharp
        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L333-335)
```csharp
    /// <summary>
    ///     To prevent one miner produced too many continuous blocks.
    /// </summary>
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-364)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L17-21)
```csharp
    /// <summary>
    ///     Implemented GitHub PR #1952.
    ///     Adjust (mainly reduce) the count of tiny blocks produced by a miner each time to avoid too many forks.
    /// </summary>
    /// <returns></returns>
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L106-112)
```csharp
    #region UpdateTinyBlockInformation

    public override Empty UpdateTinyBlockInformation(TinyBlockInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
