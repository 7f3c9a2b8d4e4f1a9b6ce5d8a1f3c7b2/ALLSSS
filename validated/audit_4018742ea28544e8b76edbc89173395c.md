# Audit Report

## Title
Negative Period Values Bypass Validation Leading to DoS in Profit Claiming

## Summary
The `FixProfitDetail` method in the Profit contract lacks validation on `StartPeriod` and `EndPeriod` values, allowing scheme managers to set negative period values. When beneficiaries attempt to claim profits, these negative periods cause the `ProfitAllPeriods` loop to execute millions of iterations, resulting in gas exhaustion and denial of service.

## Finding Description

The root cause is the complete absence of input validation in the `FixProfitDetail` method. [1](#0-0) 

Unlike `AddBeneficiary`, which properly validates that `EndPeriod >= scheme.CurrentPeriod`, [2](#0-1)  the `FixProfitDetail` method accepts arbitrary period values without any bounds checking. [3](#0-2) 

When these malformed profit details are processed, the validation check in `GetAllProfitsMap` fails to filter them out. The condition `d.EndPeriod >= d.StartPeriod` evaluates to true even for cases like `EndPeriod=100, StartPeriod=-1000000` because `100 >= -1000000` is mathematically true. [4](#0-3) 

The period count calculation then produces extremely large values. When `GetAllProfitsMap` initializes `LastProfitPeriod` from the negative `StartPeriod` and calculates the period range, it produces a value like `100 - (-1000000) = 1000100`. [5](#0-4) 

This enormous count is passed to `ProfitAllPeriods`, where the loop iterates from the negative `LastProfitPeriod` to `maxProfitPeriod`, potentially executing over 1 million iterations. Each iteration performs hash computations and state lookups, causing gas exhaustion. [6](#0-5) 

## Impact Explanation

**Operational Disruption**: Affected beneficiaries cannot execute `ClaimProfits` to withdraw their legitimate profit shares. [7](#0-6)  The same validation logic is used in both view and state-changing functions, causing identical DoS in both contexts.

**View Function Failures**: All profit query functions (`GetAllProfitsMap`, `GetProfitAmount`, `GetAllProfitAmount`) fail with gas exhaustion, breaking user interfaces and preventing users from viewing their profit balances.

**Scope**: The impact is contained to beneficiaries within schemes controlled by malicious or compromised managers. However, this includes the TokenHolder contract which has manager privileges [8](#0-7)  and manages critical staking rewards.

**Severity Justification**: MEDIUM - This is a DoS vulnerability that prevents legitimate profit withdrawals. While funds are not stolen, they become inaccessible until the malformed ProfitDetail is manually corrected, and the attack can affect system-critical contracts.

## Likelihood Explanation

**Attacker Capabilities**: The attacker must obtain scheme manager privileges, which can be achieved by: (1) creating their own scheme (trivial - any user can do this), or (2) compromising an existing manager account. Scheme managers are per-scheme roles, not globally trusted positions.

**Attack Complexity**: Extremely low - a single transaction calling `FixProfitDetail` with negative `StartPeriod` values is sufficient. The method is publicly accessible to authorized managers. [9](#0-8) 

**Feasibility Conditions**:
- For self-managed schemes: Requires victims to become beneficiaries in the attacker's scheme
- For existing schemes: Requires manager account compromise or malicious integration code
- TokenHolder contract integration presents risk if it calls `FixProfitDetail` with unsanitized parameters

**Probability Assessment**: MEDIUM - While obtaining manager role for one's own scheme is trivial, the impact is limited to that scheme's participants. Broader impact requires either social engineering or technical compromise.

## Recommendation

Add validation to the `FixProfitDetail` method to ensure period values are positive and within reasonable bounds:

```csharp
public override Empty FixProfitDetail(FixProfitDetailInput input)
{
    Assert(input.SchemeId != null, "Invalid scheme id.");
    var scheme = State.SchemeInfos[input.SchemeId];
    // ... existing authorization checks ...
    
    // Add validation for period values
    if (input.StartPeriod != 0)
    {
        Assert(input.StartPeriod >= scheme.CurrentPeriod, 
            "StartPeriod must be greater than or equal to current period.");
    }
    
    if (input.EndPeriod != 0)
    {
        Assert(input.EndPeriod >= scheme.CurrentPeriod, 
            "EndPeriod must be greater than or equal to current period.");
        
        var effectiveStartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        Assert(input.EndPeriod >= effectiveStartPeriod, 
            "EndPeriod must be greater than or equal to StartPeriod.");
    }
    
    // ... rest of the method ...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task FixProfitDetail_NegativePeriod_CausesDoS()
{
    var creator = Creators[0];
    var beneficiary = Accounts[0].Address;
    
    // Create scheme
    var schemeId = await CreateSchemeAsync();
    
    // Add beneficiary with normal periods
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiary, Shares = 100 },
        EndPeriod = 1000
    });
    
    // Attacker fixes profit detail with negative StartPeriod
    await creator.FixProfitDetail.SendAsync(new FixProfitDetailInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiary, Shares = 100 },
        StartPeriod = -1000000,
        EndPeriod = 100
    });
    
    // Victim attempts to claim profits - should fail with gas exhaustion
    var result = await creator.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiary
    });
    
    // Transaction will run out of gas due to 1M+ loop iterations
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
}
```

## Notes

The vulnerability is confirmed by examining the data type definition in the protobuf specification, where `start_period` and `end_period` are defined as `int64` (signed 64-bit integers), which can hold negative values. [10](#0-9) 

The Election contract demonstrates legitimate use of `FixProfitDetail` to extend voter welfare periods, [11](#0-10)  but it does not protect against negative period values being propagated from malicious or compromised callers.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L179-180)
```csharp
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L750-809)
```csharp
    public override Empty ClaimProfits(ClaimProfitsInput input)
    {
        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null) throw new AssertionException("Scheme not found.");
        var beneficiary = input.Beneficiary ?? Context.Sender;
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][beneficiary];
        if (profitDetails == null) throw new AssertionException("Profit details not found.");

        Context.LogDebug(
            () => $"{Context.Sender} is trying to profit from {input.SchemeId.ToHex()} for {beneficiary}.");

        // LastProfitPeriod is set as 0 at the very beginning, and be updated as current period every time when it is claimed.
        // What's more, LastProfitPeriod can also be +1 more than endPeroid, for it always points to the next period to claim.
        // So if LastProfitPeriod is 0, that means this profitDetail hasn't be claimed before, so just check whether it is a valid one;
        // And if a LastProfitPeriod is larger than EndPeriod, it should not be claimed, and should be removed later.
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();

        Context.LogDebug(() =>
            $"Profitable details: {profitableDetails.Aggregate("\n", (profit1, profit2) => profit1.ToString() + "\n" + profit2)}");

        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
        // Only can get profit from last profit period to actual last period (profit.CurrentPeriod - 1),
        // because current period not released yet.
        for (var i = 0; i < profitableDetailCount; i++)
        {
            var profitDetail = profitableDetails[i];
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
        }

        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;

        foreach (var profitDetail in profitDetailsToRemove)
        {
            availableDetails.Remove(profitDetail);
        }

        State.ProfitDetailsMap[input.SchemeId][beneficiary] = new ProfitDetails { Details = { availableDetails } };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L856-871)
```csharp
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L113-117)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod < scheme.CurrentPeriod && (d.LastProfitPeriod == 0
                ? d.EndPeriod >= d.StartPeriod
                : d.EndPeriod >= d.LastProfitPeriod)
        ).ToList();
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L128-130)
```csharp
            if (profitDetail.LastProfitPeriod == 0) profitDetail.LastProfitPeriod = profitDetail.StartPeriod;
            
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
```

**File:** protobuf/profit_contract.proto (L38-39)
```text
    rpc FixProfitDetail (FixProfitDetailInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/profit_contract.proto (L238-242)
```text
message ProfitDetail {
    // The start period number.
    int64 start_period = 1;
    // The end period number.
    int64 end_period = 2;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L144-154)
```csharp
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
```
