# Audit Report

## Title
Association Organization Permanent Deadlock via 100% Vote Threshold Requirement

## Summary
The Association contract allows organizations to be configured with `MinimalVoteThreshold` equal to `organizationMemberCount`, requiring 100% member participation. When any single member becomes unavailable, this creates an unrecoverable deadlock that permanently locks all governance functions and any assets controlled by the organization. No recovery mechanism exists.

## Finding Description

The vulnerability originates in the organization validation logic that permits unanimous vote requirements without safeguards against member unavailability.

The validation method explicitly allows `MinimalVoteThreshold` to equal the total member count through a less-than-or-equal comparison. [1](#0-0)  This enables organizations to require 100% member participation for any proposal to pass.

The vote threshold checking logic requires that total votes (approvals + rejections + abstentions) must meet or exceed `MinimalVoteThreshold`. [2](#0-1)  When `MinimalVoteThreshold` equals member count, all members must vote for proposals to reach the release threshold.

All organization modification methods require that `Context.Sender` equals the organization address:
- `ChangeOrganizationThreshold` [3](#0-2) 
- `AddMember` [4](#0-3) 
- `RemoveMember` [5](#0-4) 
- `ChangeMember` [6](#0-5) 

The organization address can only become `Context.Sender` when a proposal is executed via `SendVirtualInlineBySystemContract`. [7](#0-6) 

This creates an inescapable deadlock scenario:
1. Organization configured with `MinimalVoteThreshold = memberCount` (e.g., 3 members, threshold 3)
2. One member becomes unavailable (lost private key, malicious refusal, death, dispute)
3. Maximum achievable votes: `memberCount - 1` (e.g., only 2 members can vote)
4. Required votes: `memberCount` (e.g., threshold remains 3)
5. No proposal can reach threshold → cannot execute any modifications
6. Cannot remove unavailable member (requires proposal execution)
7. Cannot lower threshold (requires proposal execution)
8. Cannot add members to compensate (requires proposal execution)
9. **Permanent deadlock achieved**

While system contracts use this pattern with contract addresses as members [8](#0-7) [9](#0-8)  (which cannot become unavailable like human-controlled addresses), user-created organizations with human members face real unavailability risks that system contracts do not.

## Impact Explanation

**Permanent Loss of Governance Control:**
Association organizations can control significant assets and permissions. The organization address can hold tokens, be set as an authority for contract methods, and manage critical protocol configurations. Once deadlocked, all organization-controlled resources become permanently inaccessible with no recovery mechanism.

**Griefing/Extortion Vector:**
A malicious actor can intentionally create a 100% threshold organization, wait until other members contribute funds or delegate important permissions to it, then refuse to participate in any proposals. This holds all other members' assets hostage indefinitely. The attack cost is zero—the malicious actor simply stops participating.

**Affected Scope:**
- All user-created Association organizations with `MinimalVoteThreshold = organizationMemberCount`
- Any tokens held by such organizations
- Any protocol permissions/authorities delegated to such organizations
- Multi-party agreements and DAOs using Association contract governance

The severity is amplified because:
1. No warning exists that this configuration creates unrecoverable risk
2. The configuration appears reasonable for organizations wanting strong consensus
3. System contracts use this pattern, implicitly validating it as "normal"
4. Member unavailability is common in real-world scenarios (not theoretical)

## Likelihood Explanation

**High Likelihood:**

The vulnerability has high likelihood of occurrence because:

1. **Appears Reasonable:** Users wanting unanimous decision-making will naturally set `MinimalVoteThreshold = memberCount`, not realizing this creates permanent deadlock risk if any member becomes unavailable.

2. **No Warnings:** The contract provides no indication that this configuration is dangerous. The validation permits it without any error message or event warning users of the risk. [10](#0-9) 

3. **System Contract Precedent:** Multiple system contracts create organizations with this exact configuration, [11](#0-10)  which implicitly signals to users that this is a valid and safe pattern.

4. **Common Unavailability:** Member unavailability is realistic:
   - Lost/compromised private keys
   - Inactive/deceased members
   - Business disputes leading to non-participation
   - Malicious griefing attacks

5. **Zero Attack Cost:** For griefing attacks, the malicious actor simply stops participating—no transaction cost, no complex exploit needed.

**Execution Path:**
1. User calls `CreateOrganization` with `MinimalVoteThreshold = memberCount` [12](#0-11) 
2. Organization operates normally while all members remain active
3. One member becomes unavailable (realistic scenario)
4. Deadlock immediately occurs—no proposals can pass, no recovery possible

This is fully executable under normal AElf runtime semantics without requiring any special privileges or unrealistic preconditions.

## Recommendation

Add validation to prevent `MinimalVoteThreshold` from equaling `organizationMemberCount`. Require at least one member buffer to account for unavailability:

```csharp
return proposalReleaseThreshold.MinimalVoteThreshold < organizationMemberCount && // Changed from <=
       proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
       // ... rest of validation
```

Alternatively, implement one of these safeguards:
1. **Time-Based Override:** Allow proposals to execute with reduced threshold after extended waiting period
2. **Emergency Recovery:** Add a recovery mechanism that can be triggered by remaining active members after proving member unavailability
3. **Warning Events:** Emit warning events when organizations are created with high-risk threshold configurations
4. **Documentation:** Clearly document the risk of 100% thresholds in user-facing materials

The recommended fix is to strictly enforce `MinimalVoteThreshold < organizationMemberCount` to prevent the deadlock scenario entirely.

## Proof of Concept

```csharp
[Fact]
public async Task Permanent_Deadlock_With_100_Percent_Threshold()
{
    // Create organization with 3 members requiring 100% participation
    var member1 = Reviewer1;
    var member2 = Reviewer2;
    var member3 = Reviewer3;
    
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { member1, member2, member3 }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 3,  // 100% approval required
            MinimalVoteThreshold = 3,       // 100% participation required
            MaximalAbstentionThreshold = 0,
            MaximalRejectionThreshold = 0
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { member1, member2, member3 }
        }
    };
    
    var organizationAddress = await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    
    // Transfer tokens to organization (simulating real usage)
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = organizationAddress.Output,
        Symbol = "ELF",
        Amount = 10000
    });
    
    // Create proposal to remove one member (member3 who will become "unavailable")
    var proposalId = await AssociationContractStub.CreateProposal.SendAsync(new CreateProposalInput
    {
        OrganizationAddress = organizationAddress.Output,
        ToAddress = AssociationContractAddress,
        ContractMethodName = nameof(AssociationContractStub.RemoveMember),
        Params = member3.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
    });
    
    // Member3 is now "unavailable" - only member1 and member2 can vote
    await AssociationContractStubMember1.Approve.SendAsync(proposalId.Output);
    await AssociationContractStubMember2.Approve.SendAsync(proposalId.Output);
    // member3 cannot/will not vote (unavailable)
    
    // Attempt to release proposal - WILL FAIL
    var releaseResult = await AssociationContractStubMember1.Release.SendAsync(proposalId.Output);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // Organization is now permanently deadlocked:
    // - Cannot remove unavailable member (proposal can't pass)
    // - Cannot lower threshold (proposal can't pass)
    // - Cannot add new members (proposal can't pass)
    // - All tokens held by organization are permanently locked
    // - No recovery mechanism exists
    
    var orgBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = organizationAddress.Output,
        Symbol = "ELF"
    });
    orgBalance.Balance.ShouldBe(10000); // Funds permanently locked
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-58)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L189-191)
```csharp
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-216)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L248-264)
```csharp
    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L173-174)
```csharp
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L200-201)
```csharp
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L229-235)
```csharp
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = actualProposalCount,
                    MinimalVoteThreshold = actualProposalCount,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
```
