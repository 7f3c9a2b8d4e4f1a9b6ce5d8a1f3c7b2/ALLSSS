# Audit Report

## Title
Quadratic Voting Double-Count Vulnerability via VoteId Reuse in Delegated Voting

## Summary
The `Vote()` function in the Vote contract allows a sponsor to call the function multiple times with the same VoteId for delegated quadratic voting scenarios. This causes the `QuadraticVotesCountMap` to increment repeatedly while `VotingRecords` is overwritten, enabling vote inflation without proper token accounting. The sponsor can artificially multiply vote counts by reusing VoteIds, breaking the fairness guarantees of quadratic voting.

## Finding Description

The vulnerability exists in the vote counting logic for delegated quadratic voting (when `IsLockToken = false` and `IsQuadratic = true`).

**Root Cause:**

For delegated voting, the sponsor provides the `VoteId` parameter directly. The validation function `AssertValidVoteInput` only checks that `VoteId != null` but does not verify whether this VoteId already exists in `State.VotingRecords`. [1](#0-0) 

When quadratic voting is enabled, the `Vote()` function unconditionally increments `QuadraticVotesCountMap[input.VoteId]` on every call, regardless of whether the VoteId was previously used. [2](#0-1) 

The `VotingRecords` mapping is then overwritten with the new record, destroying evidence of the previous vote. [3](#0-2) 

For quadratic voting, `UpdateVotingResult` is called with an amount of `1` (not the token amount), incrementing the vote count by 1 each time. [4](#0-3) 

The `UpdateVotingResult` function adds this amount to the voting results, voter count, and votes amount. [5](#0-4) 

**Attack Execution:**
1. Sponsor registers a voting item with `IsLockToken = false` and `IsQuadratic = true`, setting `ticket_cost = 100`
2. Sponsor calls `Vote()` with `VoteId = X`:
   - `QuadraticVotesCountMap[X] = 1`
   - `amount = 100 × 1 = 100`
   - `VotingRecords[X]` stored with `Amount = 100`
   - `Results[option] += 1`, `VotesAmount += 1`
3. Sponsor calls `Vote()` again with **same** `VoteId = X`:
   - `QuadraticVotesCountMap[X] = 2` (incremented)
   - `amount = 100 × 2 = 200`
   - `VotingRecords[X]` **overwritten** with `Amount = 200`
   - `Results[option] += 1` (total now 2), `VotesAmount += 1` (total now 2)
4. Sponsor repeats N times, resulting in N votes counted but only one VotingRecord stored

**Withdrawal Accounting Mismatch:**

When withdrawing, the code subtracts `votingRecord.Amount` from the results. [6](#0-5) 

This creates a critical accounting error:
- If sponsor voted 3 times with VoteId X (ticketCost=100):
  - `Results[option] = 3` (incremented 1 + 1 + 1)
  - `VotesAmount = 3` (incremented 1 + 1 + 1)
  - `VotingRecords[X].Amount = 300` (100 × 3)
- On withdrawal:
  - Attempts to subtract 300 from Results (which is 3)
  - Causes arithmetic underflow and transaction failure

The AElf runtime enforces overflow/underflow checks on all arithmetic operations using the `checked` keyword, causing the withdrawal to fail with `OverflowException`. [7](#0-6) 

## Impact Explanation

**Direct Governance Impact:**
- **Vote Manipulation**: The sponsor can artificially inflate vote counts for any option by reusing VoteIds, allowing a single "voter" to be counted N times without cost
- **Permanent Vote Inflation**: The inflated votes cannot be withdrawn due to arithmetic underflow, making the manipulation permanent
- **Quadratic Voting Fairness Violation**: Quadratic voting is designed so each additional vote costs progressively more, but this vulnerability allows sponsors to record multiple votes while only the final cumulative cost is stored
- **Accounting Inconsistency**: The voting results show N votes, but only one VotingRecord exists, breaking auditability and making it impossible to verify vote integrity

**Who Is Affected:**
- All voting activities using delegated quadratic voting (`IsLockToken = false`, `IsQuadratic = true`)
- Legitimate voters whose votes are diluted by inflated counts
- Any decision-making processes that rely on vote tallies for governance

**Severity Justification:**

This is a **Critical** vulnerability because:
1. It completely undermines the integrity of quadratic voting mechanisms
2. The sponsor can arbitrarily manipulate vote outcomes with zero token cost
3. The manipulation is permanent (votes cannot be withdrawn)
4. No on-chain detection mechanism exists
5. It affects governance decisions that may control significant protocol resources
6. The attack leaves inconsistent state that violates protocol invariants

## Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be the sponsor of a delegated voting item
- Attacker can create voting items with `IsLockToken = false` and `IsQuadratic = true`
- No special privileges beyond being a sponsor are required
- No tokens need to be locked for delegated voting [8](#0-7) 

**Attack Complexity:**
- **Very Low**: Simply call `Vote()` multiple times with the same VoteId
- No complex transaction ordering or timing requirements
- No cryptographic or consensus mechanisms to bypass
- Direct exploitation of missing validation

**Feasibility Conditions:**
- Delegated quadratic voting must be enabled (both flags set appropriately)
- The vulnerability exists in the current code with no mitigating controls
- Any sponsor can create such voting items at will

**Economic Rationality:**
- **Zero cost attack**: No tokens are locked for delegated voting
- **High benefit**: Complete control over vote outcomes
- **No detection**: No on-chain mechanism to detect the reuse
- **No recovery**: Inflated votes are permanent

**Probability:**
**High likelihood** - The sponsor has direct incentive and capability to manipulate outcomes in their favor. The attack is trivial to execute and provides complete control over vote tallies with no cost or risk.

## Recommendation

Add validation in the `Vote()` function to check if a VoteId already exists in delegated voting scenarios:

```csharp
private VotingItem AssertValidVoteInput(VoteInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
    Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
    Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
        "Current voting item already ended.");
    if (!votingItem.IsLockToken)
    {
        Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
        Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
        Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        
        // Add this validation to prevent VoteId reuse
        var existingRecord = State.VotingRecords[input.VoteId];
        Assert(existingRecord == null || existingRecord.IsWithdrawn, 
            "VoteId already exists and has not been withdrawn.");
    }
    else
    {
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        input.Voter = Context.Sender;
        input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
    }

    return votingItem;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task QuadraticVoting_VoteId_Reuse_Vulnerability_Test()
{
    // Register delegated quadratic voting item
    var startTime = TimestampHelper.GetUtcNow();
    var input = new VotingRegisterInput
    {
        TotalSnapshotNumber = 1,
        EndTimestamp = startTime.AddDays(100),
        StartTimestamp = startTime,
        Options = { GenerateOptions(2) },
        AcceptedCurrency = TestTokenSymbol,
        IsLockToken = false,  // Delegated voting
        IsQuadratic = true,   // Quadratic voting enabled
        TicketCost = 100
    };
    
    await VoteContractStub.Register.SendAsync(input);
    input.Options.Clear();
    var votingItemId = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(input), 
        HashHelper.ComputeFrom(DefaultSender));
    
    var votingItem = await VoteContractStub.GetVotingItem.CallAsync(
        new GetVotingItemInput { VotingItemId = votingItemId });
    
    // Use same VoteId multiple times
    var reuseVoteId = HashHelper.ComputeFrom("reused_vote_id");
    var voter = Accounts[11].Address;
    var option = votingItem.Options[0];
    
    // First vote with VoteId
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Voter = voter,
        VoteId = reuseVoteId,
        Option = option
    });
    
    var result1 = await VoteContractStub.GetVotingResult.CallAsync(
        new GetVotingResultInput { VotingItemId = votingItemId, SnapshotNumber = 1 });
    result1.Results[option].ShouldBe(1);  // 1 vote recorded
    result1.VotesAmount.ShouldBe(1);
    
    // Second vote with SAME VoteId - should fail but doesn't!
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Voter = voter,
        VoteId = reuseVoteId,  // REUSING SAME VOTE ID
        Option = option
    });
    
    var result2 = await VoteContractStub.GetVotingResult.CallAsync(
        new GetVotingResultInput { VotingItemId = votingItemId, SnapshotNumber = 1 });
    result2.Results[option].ShouldBe(2);  // 2 votes recorded!
    result2.VotesAmount.ShouldBe(2);
    
    // Check VotingRecord - only one exists with cumulative amount
    var votingRecord = await VoteContractStub.GetVotingRecord.CallAsync(reuseVoteId);
    votingRecord.Amount.ShouldBe(200);  // 100 * 2 = 200
    
    // Withdrawal will fail due to underflow
    await TakeSnapshot(votingItemId, 1);
    var withdrawResult = await WithdrawWithException(DefaultSenderKeyPair, reuseVoteId);
    withdrawResult.Status.ShouldBe(TransactionResultStatus.Failed);
    // Attempts to subtract 200 from Results[option]=2, causing underflow
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L100-103)
```csharp
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-117)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L119-119)
```csharp
        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L122-130)
```csharp
        if (votingItem.IsLockToken)
            // Lock voted token.
            State.TokenContract.Lock.Send(new LockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                LockId = input.VoteId,
                Amount = amount
            });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L176-180)
```csharp
        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L214-220)
```csharp
        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-388)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```
