# Audit Report

## Title
Missing Character Validation in AddNFTType Enables DoS of NFT Protocol Creation

## Summary
The `AddNFTType` method only validates that short names are exactly 2 characters long but does not validate the characters themselves. This allows governance to add NFT types with special characters that will subsequently fail MultiToken contract symbol validation, making it impossible to create NFT protocols of that type and causing a denial-of-service for that NFT category.

## Finding Description

The root cause lies in insufficient validation in the `AddNFTType` method. The method only checks the length of the short name but does not validate the character content: [1](#0-0) 

The validation at line 136 only asserts `input.ShortName.Length == 2`, accepting any characters including special characters like "@", "!", "*", "#", etc.

When an NFT protocol is created, the `GetSymbol` method retrieves the short name and concatenates it with a random number: [2](#0-1) 

This generated symbol (e.g., "@@123456789") is then passed to the MultiToken contract's `Create` method: [3](#0-2) 

The MultiToken contract validates the symbol through `GetSymbolType`: [4](#0-3) 

Which calls `IsValidCreateSymbol` to validate the prefix: [5](#0-4) 

The `IsValidCreateSymbol` method uses a strict regex pattern that only allows alphanumeric characters: [6](#0-5) 

When special characters are present in the symbol prefix, the regex `^[a-zA-Z0-9]+$` validation fails at line 10 of GetSymbolType, causing an assertion error "Invalid Symbol input" that prevents the NFT protocol from being created.

## Impact Explanation

**Operational Impact - DoS:**
- Any NFT type added with special characters becomes permanently unusable
- Users cannot create NFT protocols of that type, as all `Create` calls fail with "Invalid Symbol input"
- The governance action is wasted, requiring another governance proposal to remove it via `RemoveNFTType`
- This affects protocol functionality and user experience, preventing legitimate NFT protocol creation

**Severity:** Medium - causes operational DoS for specific NFT types without directly affecting funds, but is reversible through governance.

## Likelihood Explanation

**Governance Oversight Scenario:**
- Requires Parliament governance to submit and approve an `AddNFTType` proposal with special characters
- This can occur through honest mistake or lack of awareness of downstream validation requirements
- Default NFT types use alphanumeric characters ("AR", "MU", "VW", etc.), which may not alert governance to validation requirements: [7](#0-6) 

- No automated validation exists to catch this during proposal review
- Issue only manifests when users attempt to create NFT protocols of the invalid type

**Likelihood:** Medium - relies on governance oversight, but the validation gap is easily overlooked.

## Recommendation

Add character validation to the `AddNFTType` method to ensure short names only contain alphanumeric characters, matching the MultiToken contract's validation requirements:

```csharp
public override Empty AddNFTType(AddNFTTypeInput input)
{
    AssertSenderIsParliamentDefaultAddress();
    InitialNFTTypeNameMap();
    var fullName = input.FullName;
    Assert(input.ShortName.Length == 2, "Incorrect short name.");
    
    // Add alphanumeric validation
    Assert(Regex.IsMatch(input.ShortName, "^[a-zA-Z0-9]+$"), 
        "Short name must contain only alphanumeric characters.");
    
    Assert(State.NFTTypeFullNameMap[input.ShortName] == null, 
        $"Short name {input.ShortName} already exists.");
    Assert(State.NFTTypeShortNameMap[fullName] == null, 
        $"Full name {fullName} already exists.");
    // ... rest of method
}
```

## Proof of Concept

```csharp
[Fact]
public async Task AddNFTType_WithSpecialCharacters_CausesCreateFailure()
{
    // Step 1: Governance adds NFT type with special characters
    var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    var proposalId = await CreateProposalAsync(
        NFTContractAddress,
        defaultParliament, 
        nameof(NFTContractStub.AddNFTType),
        new AddNFTTypeInput
        {
            ShortName = "@@",  // Special characters
            FullName = "TestType"
        });
    await ApproveWithMinersAsync(proposalId);
    await ParliamentContractStub.Release.SendAsync(proposalId);
    
    // Step 2: Attempt to create NFT protocol of that type
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await NFTContractStub.Create.SendAsync(new CreateInput
        {
            BaseUri = "ipfs://test/",
            Creator = DefaultAddress,
            IsBurnable = true,
            NftType = "TestType",
            ProtocolName = "TEST",
            TotalSupply = 1000000
        });
    });
    
    // Verify it fails with "Invalid Symbol input"
    exception.Message.ShouldContain("Invalid Symbol input");
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-34)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L131-149)
```csharp
    public override Empty AddNFTType(AddNFTTypeInput input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        var fullName = input.FullName;
        Assert(input.ShortName.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
        Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
        State.NFTTypeFullNameMap[input.ShortName] = fullName;
        State.NFTTypeShortNameMap[fullName] = input.ShortName;
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Add(input.ShortName, fullName);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeAdded
        {
            ShortName = input.ShortName,
            FullName = input.FullName
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-63)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;

        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }

        return nftTypes;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L28-31)
```csharp
    private bool IsValidCreateSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+$");
    }
```
