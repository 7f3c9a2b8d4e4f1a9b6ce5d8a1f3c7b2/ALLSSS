# Audit Report

## Title
Hardcoded Election Lock Amount Causes DoS or Incorrect Economic Security When Native Token Decimals Differ from 8

## Summary
The Election contract uses a hardcoded constant `LockTokenForElection = 100_000_00000000` that assumes exactly 8 decimal places for the native token. [1](#0-0)  However, native token decimals are configurable from 0 to 18 during chain initialization, [2](#0-1)  creating a critical mismatch. When chains deploy with different decimals, the election system either becomes completely unusable (DoS) or locks economically incorrect amounts, breaking the intended 100,000 token security barrier.

## Finding Description

The Election contract hardcodes the candidate deposit amount without decimal adjustment. [1](#0-0)  This value is used directly when locking tokens during election announcement. [3](#0-2) 

Meanwhile, native token decimals are fully configurable through `EconomicOptions` which defaults to 8 but can be changed. [4](#0-3)  This configuration flows through the initialization system [5](#0-4)  and is used when creating the native token. [6](#0-5) 

The token system validates decimals only to be between 0 and 18, with no requirement for 8 decimals. [2](#0-1)  Test code confirms that native tokens with 2 decimals are feasible and valid. [7](#0-6) 

When `AnnounceElection` or `AnnounceElectionFor` is called, the `LockCandidateNativeToken` method attempts to transfer the hardcoded amount. [8](#0-7)  The `TransferFrom` method performs balance validation [9](#0-8)  but has no decimal-aware logic, causing failure when the required amount exceeds available supply or accepting drastically reduced amounts when decimals are higher.

## Impact Explanation

**Critical DoS Scenario (decimals < 8):**
With 2 decimals, the hardcoded value represents `100_000_00000000 ÷ 100 = 100,000,000,000` tokens (100 billion). Even if the total supply is proportionally adjusted to billions of tokens, no individual user would possess 100 billion tokens. The `ModifyBalance` method throws "Insufficient balance" [10](#0-9)  making election announcements impossible. This completely disables the validator election mechanism, a core protocol function.

**High Economic Security Break (decimals > 8):**
With 10 decimals, the hardcoded value represents `100_000_00000000 ÷ 10,000,000,000 = 1,000` tokens instead of the intended 100,000 tokens—a 99% reduction in the economic barrier. This makes validator candidacy 100x cheaper than intended, severely undermining the security model that relies on economic stake to prevent Sybil attacks.

The default total supply constant also assumes 8 decimals, [11](#0-10)  demonstrating the systemic assumption mismatch.

## Likelihood Explanation

This vulnerability triggers through public methods accessible to any user. [12](#0-11) [13](#0-12) 

**Preconditions:**
1. Chain initialized with `NativeTokenDecimals ≠ 8`
2. This is explicitly supported—the configuration system allows any value 0-18 with no enforcement
3. Side chains or custom deployments may select different decimals for token compatibility or precision requirements

**Feasibility:**
The codebase demonstrates this configuration is valid and occurs in production test scenarios. [7](#0-6)  The Election contract's initialization performs no validation of native token decimals. [14](#0-13) 

**Probability:** Medium-High. While the mainnet default is 8 decimals, the configuration system is intentionally flexible with no safeguards. Any side chain or custom deployment that deviates immediately triggers the issue upon the first election announcement.

## Recommendation

Implement decimal-aware logic in the Election contract. Query the native token's actual decimals at runtime and adjust the lock amount accordingly:

```csharp
private void LockCandidateNativeToken()
{
    if (State.TokenContract.Value == null)
        State.TokenContract.Value = 
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
    
    // Query native token info to get actual decimals
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
    {
        Symbol = Context.Variables.NativeSymbol
    });
    
    // Calculate amount based on actual decimals (target: 100,000 tokens)
    var targetTokens = 100_000;
    var actualAmount = targetTokens * (long)Math.Pow(10, tokenInfo.Decimals);
    
    var lockId = Context.OriginTransactionId;
    var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
    var sponsorAddress = Context.Sender;
    
    State.TokenContract.TransferFrom.Send(new TransferFromInput
    {
        From = sponsorAddress,
        To = lockVirtualAddress,
        Symbol = Context.Variables.NativeSymbol,
        Amount = actualAmount,
        Memo = "Lock for announcing election."
    });
}
```

Apply the same pattern to `QuitElection` for the refund operation.

## Proof of Concept

```csharp
[Fact]
public async Task AnnounceElection_WithNonStandardDecimals_CausesDoS()
{
    // Initialize chain with 2 decimals instead of 8
    var nativeTokenDecimals = 2;
    var totalSupply = 1_000_000_000_00; // 10 billion tokens with 2 decimals
    
    await InitializeWithCustomDecimals(nativeTokenDecimals, totalSupply);
    
    // Give user reasonable balance (1 million tokens)
    var userBalance = 1_000_000_00; // 1 million tokens with 2 decimals
    await IssueTokens(DefaultSender, userBalance);
    
    // Attempt to announce election
    // This requires 100_000_00000000 base units = 100 billion tokens with 2 decimals
    // User only has 1 million tokens
    var result = await ElectionStub.AnnounceElection.SendAsync(AdminAddress);
    
    // Should fail with "Insufficient balance"
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Insufficient balance");
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L32-38)
```csharp

    private TokenInfo AssertValidToken(string symbol, long amount)
    {
        AssertValidSymbolAndAmount(symbol, amount);
        var tokenInfo = GetTokenInfo(symbol);
        Assert(tokenInfo != null && !string.IsNullOrEmpty(tokenInfo.Symbol), $"Token is not found. {symbol}");
        return tokenInfo;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** src/AElf.OS.Core/EconomicOptions.cs (L8-8)
```csharp
    public long TotalSupply { get; set; } = 1_000_000_000_00000000;
```

**File:** src/AElf.OS.Core/EconomicOptions.cs (L9-9)
```csharp
    public int Decimals { get; set; } = 8;
```

**File:** src/AElf.EconomicSystem/EconomicContractInitializationProvider.cs (L40-40)
```csharp
                    NativeTokenDecimals = _economicOptions.Decimals,
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L54-64)
```csharp
        State.TokenContract.Create.Send(new CreateInput
        {
            Symbol = input.NativeTokenSymbol,
            TokenName = "Native Token",
            TotalSupply = input.NativeTokenTotalSupply,
            Decimals = input.NativeTokenDecimals,
            IsBurnable = input.IsNativeTokenBurnable,
            Issuer = Context.Self,
            LockWhiteList = { lockWhiteList },
            Owner = Context.Self
        });
```

**File:** test/AElf.Contracts.TestBase/ContractTester.cs (L766-776)
```csharp
        var nativeTokenInfo = new TokenInfo
        {
            Symbol = "ELF",
            Decimals = 2,
            Issuer = issuer,
            Owner = issuer,
            IsBurnable = true,
            TokenName = "elf token",
            TotalSupply = TokenTotalSupply,
            IssueChainId = ChainHelper.ConvertBase58ToChainId("AELF")
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L22-52)
```csharp
    public override Empty InitialElectionContract(InitialElectionContractInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");

        State.Candidates.Value = new PubkeyList();

        State.MinimumLockTime.Value = input.MinimumLockTime;
        State.MaximumLockTime.Value = input.MaximumLockTime;

        State.TimeEachTerm.Value = input.TimeEachTerm;

        State.MinersCount.Value = input.MinerList.Count;
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
        foreach (var pubkey in input.MinerList)
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey
            };

        State.CurrentTermNumber.Value = 1;

        State.DataCentersRankingList.Value = new DataCenterRankingList();

        State.Initialized.Value = true;

        return new Empty();
    }
```
