# Audit Report

## Title
Unauthorized Round Termination Due to Missing Extra Block Producer Authorization Check

## Summary
The `GetConsensusBehaviour()` function contains a fallthrough logic error that allows any miner who has reached their maximum block count to prematurely terminate a consensus round, bypassing the restriction that only the designated extra block producer should terminate rounds during the extra block time slot.

## Finding Description

The vulnerability exists in the consensus behavior determination logic where a critical authorization check is missing. [1](#0-0) 

When a miner has `OutValue != null` (has mined), `!_isTimeSlotPassed` (still within their time slot), and `ActualMiningTimes.Count >= _maximumBlocksCount` (reached block limit), but is NOT the extra block producer of the previous round, the function falls through to line 82 and calls `GetConsensusBehaviourToTerminateCurrentRound()`, which returns `NextRound` or `NextTerm` behavior without verifying the miner is authorized to terminate the round.

The validation system fails to prevent this:

1. **PreCheck() Authorization is Insufficient**: [2](#0-1) 

The `PreCheck()` only validates that the miner is in the current or previous round's miner list, NOT that they have authority to terminate rounds.

2. **TimeSlotValidationProvider Doesn't Check Authorization**: [3](#0-2) 

For NextRound/NextTerm, it only calls `CheckRoundTimeSlots()` which validates time slot equality, but does NOT check if the current miner is authorized to terminate the round or if it's the extra block time slot.

3. **RoundTerminateValidationProvider Only Checks Round Number**: [4](#0-3) 

This provider only validates round/term number correctness, not authorization.

4. **IsCurrentMiner() Has Proper Checks But Isn't Called**: [5](#0-4) 

The `IsCurrentMiner()` method contains comprehensive checks for extra block producer authorization and time slot validation, but this method is never called in the NextRound/NextTerm execution path.

## Impact Explanation

This vulnerability breaks the core consensus invariant that only the designated extra block producer can terminate rounds. The impacts include:

1. **Consensus Schedule Disruption**: Unauthorized miners terminate rounds before all miners have had their scheduled time slots, violating the consensus protocol's fairness guarantees.

2. **Unfair Block Production Distribution**: Miners who haven't had their turn lose block production opportunities and associated mining rewards.

3. **Extra Block Producer Role Hijacking**: The attacker becomes the extra block producer of the next round [6](#0-5) 
gaining the privilege to terminate that round as well, enabling repeated exploitation.

4. **Chain Stability Risk**: Coordinated exploitation could manipulate consensus timing and disrupt the intended round schedule, potentially affecting chain liveness.

## Likelihood Explanation

**Attacker Capabilities**: Must be an active miner in the current round who mines legitimate blocks to reach maximum block count.

**Attack Complexity**: LOW - The attacker simply needs to:
1. Mine blocks during their legitimate time slot until reaching `_maximumBlocksCount`
2. While still in their time slot, call `GetConsensusCommand()` [7](#0-6) 

3. Execute the returned `NextRound` transaction [8](#0-7) 

**Feasibility**: HIGH - The entry points are publicly callable, no exceptional conditions required, and no economic barriers beyond normal mining participation.

## Recommendation

Add explicit extra block producer authorization checks before allowing round termination. The fix should:

1. In `GetConsensusBehaviour()`, before returning `GetConsensusBehaviourToTerminateCurrentRound()` at line 82, add a check to verify:
   - The current time is within the extra block time slot (`currentBlockTime >= GetExtraBlockMiningTime()`)
   - The miner is the designated extra block producer for the current round (`IsExtraBlockProducer == true`)

2. Alternatively, add a validation provider that enforces extra block producer authorization during `ValidateBeforeExecution()` for NextRound/NextTerm behaviors, similar to how `IsCurrentMiner()` performs these checks.

3. Consider refactoring to call `IsCurrentMiner()` during NextRound/NextTerm validation to leverage its existing comprehensive authorization logic.

## Proof of Concept

```csharp
// Test scenario demonstrating the vulnerability:
// 1. Setup: Round with multiple miners, one designated as extra block producer
// 2. Attacker miner produces blocks until reaching maximum count while still in their time slot
// 3. Attacker calls GetConsensusCommand() and receives NextRound behavior (should be rejected)
// 4. Attacker executes NextRound transaction successfully (should fail authorization)
// 5. Verify: Round terminates prematurely, attacker becomes extra block producer of next round

[Fact]
public async Task UnauthorizedRoundTermination_Test()
{
    // Setup round with 5 miners
    var initialRound = GenerateRound(5);
    var attackerPubkey = initialRound.RealTimeMinersInformation.Keys.ElementAt(2);
    
    // Attacker mines maximum blocks during their time slot
    for (int i = 0; i < GetMaximumBlocksCount(); i++)
    {
        await ProduceBlock(attackerPubkey);
    }
    
    // Attacker is still within their time slot but has reached max blocks
    Assert.False(IsTimeSlotPassed(attackerPubkey));
    
    // Attacker calls GetConsensusCommand - should get NextRound despite not being extra block producer
    var command = await GetConsensusCommand(attackerPubkey);
    Assert.Equal(AElfConsensusBehaviour.NextRound, command.Behaviour);
    
    // Attacker executes NextRound transaction - should fail but doesn't
    var result = await ExecuteNextRound(attackerPubkey, command);
    Assert.True(result.Success); // VULNERABILITY: This succeeds
    
    // Verify attacker hijacked extra block producer role
    var newRound = await GetCurrentRound();
    Assert.Equal(attackerPubkey, newRound.ExtraBlockProducerOfPreviousRound);
    
    // Verify other miners lost their time slots
    var missedMiners = initialRound.RealTimeMinersInformation.Values
        .Where(m => m.OutValue == null && m.Order > 2).Count();
    Assert.True(missedMiners > 0); // Miners after attacker never got to produce blocks
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L254-254)
```csharp
        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
