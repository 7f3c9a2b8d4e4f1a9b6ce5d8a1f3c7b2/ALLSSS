# Audit Report

## Title
Missing Miner List Validation During Term Transitions Allows Consensus Takeover

## Summary
The NextTerm consensus transition flow lacks validation that the proposed miner list matches the Election Contract's authoritative GetVictories result. Any current miner can submit a term transition with an arbitrary miner list, bypassing the DPoS election mechanism and taking over network consensus.

## Finding Description

The AElf consensus system separates miner list **generation** from miner list **validation**, creating a critical security gap during term transitions.

**Legitimate Generation Flow:**
When an honest miner prepares NextTerm consensus data, they call `GenerateFirstRoundOfNextTerm`, which queries the Election Contract via `TryToGetVictories` to obtain legitimately elected miners. [1](#0-0) 

The Election Contract is called to get the authoritative list of elected block producers. [2](#0-1) 

**Validation Gap - Pre-Execution:**
For NextTerm behavior, the validation system only adds `RoundTerminateValidationProvider`. [3](#0-2) 

This validator only checks that term and round numbers increment correctlyâ€”it never validates the miner list composition against the Election Contract. [4](#0-3) 

**Validation Gap - During Execution:**
The PreCheck authorization only verifies the sender is in the current or previous miner list. [5](#0-4) 

ProcessNextTerm directly extracts the miner list from the input and sets it as the official miner list without any validation against the Election Contract. [6](#0-5) 

**Validation Gap - Type Conversion:**
The NextTermInput.ToRound() conversion blindly copies all miner information without integrity checks. [7](#0-6) 

**Validation Gap - Post-Execution:**
ValidateConsensusAfterExecution only validates that the executed state matches the header data. It checks for miner replacements via `GetNewestPubkey` (for within-term evil miner replacement), but does NOT validate the NextTerm miner list against `GetVictories`. [8](#0-7) 

**Attack Scenario:**
1. Malicious miner M is currently in the miner list [A, B, C, D, M]
2. Election results indicate next term should be [A, B, C, F, G]
3. During term transition, M produces a NextTerm block with RealTimeMinersInformation containing only [M]
4. All validations pass (term/round increment correctly, M is a current miner, time slot valid)
5. ProcessNextTerm executes, calling SetMinerList with the malicious list [M]
6. Only M can produce subsequent blocks, maintaining perpetual control

## Impact Explanation

**Critical Severity - Complete Protocol Compromise:**

**Consensus Takeover:** The attacker gains exclusive block production rights by setting themselves as the only authorized miner(s). All legitimately elected miners are permanently excluded. The attacker maintains control indefinitely by repeating this attack at each term transition.

**Governance Capture:** Control over block production grants control over all governance mechanisms (Parliament/Association/Referendum). The attacker can unilaterally pass proposals, modify system parameters, and control Treasury distributions without any checks or balances.

**Election System Invalidation:** This completely breaks the DPoS security model. The Election Contract's GetVictories result becomes meaningless, invalidating all voter participation and token holder governance rights.

**Economic Damage:** Legitimate miners lose all block rewards, the attacker collects all mining rewards, and network trust collapses, destroying token value.

## Likelihood Explanation

**High Likelihood:**

**Attacker Prerequisites:**
- Must be a current miner (one of the existing block producers)
- Must control their node software to produce custom consensus data
- Must wait for a term transition period (occurs regularly at predictable intervals)

**Attack Complexity: LOW**
- Requires only a single compromised miner
- No cryptographic attacks required
- Uses standard block production mechanisms
- No economic barriers beyond being an existing miner

**Feasibility:** Term transitions occur regularly and predictably. Any current miner has the technical capability to craft custom consensus data. The attack is undetectable until after execution, when the damage is already done.

## Recommendation

Add a validation provider that verifies the NextTerm miner list matches the Election Contract's GetVictories result.

**Proposed Fix:**

Create a new `MinerListValidationProvider` for NextTerm:

```csharp
public class MinerListValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        if (validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextTerm)
            return new ValidationResult { Success = true };
            
        // Query Election Contract for authoritative miner list
        var victories = State.ElectionContract.GetVictories.Call(new Empty());
        var expectedMiners = victories.Value.Select(p => p.ToHex()).OrderBy(x => x).ToList();
        
        // Get proposed miner list from header
        var proposedMiners = validationContext.ExtraData.Round.RealTimeMinersInformation.Keys
            .OrderBy(x => x).ToList();
        
        // Validate they match
        if (expectedMiners.Count != proposedMiners.Count || 
            !expectedMiners.SequenceEqual(proposedMiners))
        {
            return new ValidationResult 
            { 
                Success = false,
                Message = "NextTerm miner list does not match Election Contract victories" 
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Add this provider in `ValidateBeforeExecution` for NextTerm behavior:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new MinerListValidationProvider()); // ADD THIS
    break;
```

## Proof of Concept

Due to the complexity of setting up a full AElf test environment with Election Contract integration, a complete runnable PoC is not provided. However, the vulnerability can be verified by:

1. Examining the validation flow in `ValidateBeforeExecution` which shows no Election Contract validation for NextTerm
2. Tracing `ProcessNextTerm` which directly uses input data without validation
3. Observing that `ValidateConsensusAfterExecution` only validates header vs state consistency, not vs Election Contract

The missing validation is evident from the code paths cited above.

**Notes:**
- This vulnerability only affects main chain (State.IsMainChain.Value == true) where elections occur
- Side chains use different miner list synchronization and are not vulnerable to this specific attack
- The separation of honest generation logic from validation logic is the root cause

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L274-274)
```csharp
        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-124)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
```
