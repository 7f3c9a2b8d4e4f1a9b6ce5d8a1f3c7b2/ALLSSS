# Audit Report

## Title
Missing Size Validation on Encrypted Pieces Allows State Bloat Attack

## Summary
The AEDPoS consensus contract lacks size validation on encrypted secret sharing pieces submitted through the `UpdateValue()` method. A malicious miner can exploit this to inject up to 4.5MB of bloated data per transaction, which persists in state for 40,960 rounds, causing cumulative state bloat and network-wide DoS.

## Finding Description

The vulnerability exists in the secret sharing mechanism where miners submit encrypted pieces without any size constraints. The `UpdateValueInput` message contains an `encrypted_pieces` field defined as `map<string, bytes>` with no size limits in the protobuf schema. [1](#0-0) 

When a miner calls `UpdateValue()`, the execution flow routes through `ProcessConsensusInformation()` to `ProcessUpdateValue()`. If secret sharing is enabled, `ProcessUpdateValue()` invokes `PerformSecretSharing()`: [2](#0-1) 

The critical vulnerability occurs in `PerformSecretSharing()` where encrypted pieces are blindly added to state without any validation: [3](#0-2) 

Similarly, `UpdateLatestSecretPieces()` adds encrypted pieces from trigger information without size checks: [4](#0-3) 

The `UpdateValueValidationProvider` only validates that `OutValue` and `Signature` are non-null, and that `PreviousInValue` hashes correctlyâ€”it performs no size validation on encrypted pieces: [5](#0-4) 

The only protection is the transaction size limit of 5MB: [6](#0-5) 

**Critically**, the standard state size limit (128KB) does NOT apply to system contracts like the consensus contract. The `StateWrittenSizeLimitMethodInjector` explicitly ignores system contracts: [7](#0-6) 

The patcher filtering logic confirms this exemption: [8](#0-7) 

Bloated rounds persist in state because the system retains 40,960 rounds as defined by `KeepRounds`: [9](#0-8) 

Round cleanup only removes rounds older than `KeepRounds`: [10](#0-9) 

The attacker must be a valid miner as verified by `PreCheck()`, which only checks miner membership without any size validation: [11](#0-10) 

## Impact Explanation

**State Bloat Severity:** Normal encrypted pieces for legitimate secret sharing among ~17 miners total approximately 3KB per `UpdateValue` transaction. A malicious miner can inflate this to approximately 4.5MB (leaving room for other required fields within the 5MB transaction limit), achieving a 1500x bloat factor.

**Cumulative Damage:** With 40,960 rounds retained in state, if an attacker bloats even 100 rounds before detection, this results in 450MB of unnecessary state. A sustained attack across multiple mining terms could bloat hundreds or thousands of rounds, potentially reaching gigabytes of bloated state.

**Operational Impact:**
- All full nodes must store and synchronize the bloated state data
- New nodes face significantly longer synchronization times
- State queries and consensus operations degrade in performance
- Storage infrastructure costs increase for all network participants
- Potential chain halt if state size becomes unmanageable

**Affected Parties:** All network participants including full nodes, validators, and end users suffer from degraded performance and increased resource requirements. This is a network-wide availability impact that violates the protocol's state growth invariants.

## Likelihood Explanation

**Attacker Capabilities:** The attacker must be a valid miner in the current or previous round. While this requires winning election, it is achievable through the standard election process without requiring any privileged keys or consensus breaks.

**Attack Complexity:** Low. The attacker only needs to modify their node software to generate oversized `encrypted_pieces` when calling `UpdateValue()`. No complex cryptographic bypasses or precise timing attacks are required.

**Feasibility Conditions:**
- Miner status is required but achievable through the public election process
- No additional economic barriers beyond maintaining miner status
- Attack is immediately executable upon becoming a miner
- Can be repeated across multiple rounds/blocks during the miner's entire tenure

**Detection and Response:** The attack would eventually be detected through monitoring of unusual transaction sizes and state growth. However, damage accumulates before remediation can occur. Network governance would need to vote to exclude the malicious miner, during which time additional bloat continues to accumulate.

**Economic Rationality:** A malicious actor willing to sacrifice their reputation and future mining rewards could execute this attack as a form of griefing, competitive attack against the network, or to cause operational disruption.

## Recommendation

Implement size validation on `encrypted_pieces` in the `UpdateValue()` processing path:

1. Define a maximum reasonable size for encrypted pieces per miner (e.g., 256 bytes per piece * 17 miners = ~4KB total)
2. Add validation in `PerformSecretSharing()` to reject oversized encrypted pieces
3. Add validation in `UpdateLatestSecretPieces()` similarly
4. Consider adding validation in `UpdateValueValidationProvider` to reject blocks with oversized encrypted pieces during consensus validation

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task UpdateValue_WithOversizedEncryptedPieces_CausesStateBloat()
{
    // Setup: Initialize consensus with a miner
    await InitializeConsensusAsync();
    var minerKeyPair = MissionedECKeyPairs.CoreDataCenterKeyPairs[0];
    
    // Create UpdateValueInput with ~4.5MB of bloated encrypted_pieces
    var bloatedInput = new UpdateValueInput
    {
        OutValue = Hash.Generate(),
        Signature = Hash.Generate(),
        RoundId = 1,
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        SupposedOrderOfNextRound = 1,
        ImpliedIrreversibleBlockHeight = 1
    };
    
    // Add ~4.5MB of dummy encrypted pieces
    for (int i = 0; i < 100; i++)
    {
        bloatedInput.EncryptedPieces[$"miner_{i}"] = ByteString.CopyFrom(new byte[45000]);
    }
    
    // Execute UpdateValue - this should store bloated data in state
    await ConsensusStub.UpdateValue.SendAsync(bloatedInput);
    
    // Verify bloated round data persists in state
    var round = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var minerInfo = round.RealTimeMinersInformation[minerKeyPair.PublicKey.ToHex()];
    
    // Assert that oversized encrypted pieces were stored without validation
    Assert.True(minerInfo.EncryptedPieces.Count > 0);
    Assert.True(minerInfo.EncryptedPieces.Values.Sum(v => v.Length) > 4000000); // >4MB
}
```

### Citations

**File:** protobuf/aedpos_contract.proto (L210-210)
```text
    map<string, bytes> encrypted_pieces = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L136-153)
```csharp
    private void UpdateLatestSecretPieces(Round updatedRound, string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        foreach (var encryptedPiece in triggerInformation.EncryptedPieces)
            updatedRound.RealTimeMinersInformation[pubkey].EncryptedPieces
                .Add(encryptedPiece.Key, encryptedPiece.Value);

        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;

        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L5-5)
```csharp
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
```

**File:** src/AElf.CSharp.CodeOps/Patchers/Module/StateWrittenSizeLimitMethodInjector.cs (L17-17)
```csharp
    public bool SystemContactIgnored => true;
```

**File:** src/AElf.CSharp.CodeOps/CSharpContractPatcher.cs (L30-34)
```csharp
    private void Patch<T>(T t, bool isSystemContract)
    {
        var patchers = _policy.GetPatchers<T>().Where(p => !p.SystemContactIgnored || !isSystemContract).ToList();
        patchers.ForEach(v => v.Patch(t));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L10-10)
```csharp
    public const int KeepRounds = 40960;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L117-124)
```csharp
        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```
