# Audit Report

## Title
Malicious Miner Can Manipulate ConfirmedIrreversibleBlockRoundNumber in NextRound to Force Severe Status DoS

## Summary
A malicious miner can manipulate the `ConfirmedIrreversibleBlockRoundNumber` field when calling the `NextRound` method, artificially creating a gap between the current round number and the last irreversible block (LIB) round number. This manipulation forces the blockchain into "Severe" status, reducing maximum block production from 8 blocks to just 1 block per miner, causing a severe denial-of-service attack that throttles blockchain throughput by up to 87.5%.

## Finding Description

The AEDPoS consensus contract contains a critical validation gap in its `NextRound` transition logic. When a miner calls `NextRound` to advance to the next consensus round, the validation system applies only `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider`, but critically **excludes** `LibInformationValidationProvider`. [1](#0-0) 

The `LibInformationValidationProvider` is responsible for ensuring that LIB-related fields (`ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber`) do not decrease or remain incorrectly low. However, this validator is only applied to `UpdateValue` behavior, not to `NextRound` behavior. [2](#0-1) 

The validation logic for `LibInformationValidationProvider` specifically checks that these values don't go backwards: [3](#0-2) 

Without this validation, `ProcessNextRound` directly converts the untrusted `NextRoundInput` to a `Round` object via `ToRound()` and stores it in state: [4](#0-3) 

The `ToRound()` method copies all fields including `ConfirmedIrreversibleBlockRoundNumber` without any validation: [5](#0-4) 

The `AddRoundInformation` method stores this manipulated data directly into state without additional validation: [6](#0-5) 

The manipulated value is then read by `GetMaximumBlocksCount()` to determine blockchain mining status: [7](#0-6) 

The `BlockchainMiningStatusEvaluator` uses these values to calculate the blockchain's status and triggers "Severe" status when the gap is 8 rounds or more: [8](#0-7) 

When Severe status is triggered, the maximum blocks count is reduced to 1: [9](#0-8) 

**Attack Flow:**
1. Malicious miner generates a valid `NextRoundInput` using standard consensus methods
2. Modifies `ConfirmedIrreversibleBlockRoundNumber` to an artificially low value (e.g., `currentRoundNumber - 8`)
3. Calls the public `NextRound` method with this manipulated input
4. `PreCheck()` passes because the caller is an authorized miner
5. Validation uses only `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` - neither checks LIB fields
6. Manipulated round is stored in state without LIB validation
7. `GetMaximumBlocksCount()` reads the manipulated value and calculates a large gap
8. Blockchain enters Severe status
9. Maximum blocks per miner reduced from 8 to 1

The only authorization check is `PreCheck()`, which merely verifies the caller is in the current or previous miner list: [10](#0-9) 

## Impact Explanation

This vulnerability enables a **HIGH severity denial-of-service attack** on the AElf blockchain consensus system with the following impacts:

1. **Operational Impact**: Maximum block production is reduced from the normal limit (8 blocks) to just 1 block per miner time slot, severely throttling blockchain throughput by up to 87.5%. This dramatically reduces the network's transaction processing capacity.

2. **Consensus Integrity**: The attack creates a false perception that the blockchain is in severe distress with stalled irreversible block confirmation, when in reality the LIB may be progressing normally. This violates the integrity guarantees of the consensus status monitoring system.

3. **Affected Parties**: All blockchain users experience dramatically reduced transaction processing capacity. The entire network's ability to process transactions is crippled, affecting dApp functionality, token transfers, and all on-chain operations.

4. **Attack Persistence**: The attacker can repeat this manipulation in subsequent rounds to maintain the DoS condition indefinitely, as there are no mechanisms to detect or prevent repeated manipulation.

5. **No Resource Requirements**: Unlike traditional DoS attacks that require significant computational or economic resources, this attack only requires being a miner and submitting a single malicious transaction per round.

## Likelihood Explanation

The attack is **highly likely** to be exploitable:

**Attacker Capabilities:**
- Attacker must be one of the active miners in the consensus round, which is checked by `PreCheck()`. This is a reasonable precondition as miners are participants in the consensus system.

**Attack Complexity:**
- Very low complexity: The attacker simply generates a valid `NextRoundInput` using standard consensus generation methods, modifies the `ConfirmedIrreversibleBlockRoundNumber` field to an artificially low value (e.g., `currentRoundNumber - 8`), and calls the public `NextRound` method.
- No cryptographic bypasses or complex timing attacks required.

**Feasibility Conditions:**
- No special preconditions required beyond being a miner
- No need for collusion with other miners
- Can be executed at any time during normal consensus operation
- The `NextRound` method is a public RPC method that any miner can call [11](#0-10) 

**Detection Constraints:**
- The attack is difficult to distinguish from legitimate network issues since Severe status is designed to trigger when consensus genuinely degrades
- No on-chain mechanism exists to verify that the provided `ConfirmedIrreversibleBlockRoundNumber` matches the actual LIB progression

**Economic Rationality:**
- Attack cost is negligible (just one transaction fee)
- Potential motivations include: griefing competitors, manipulating transaction fees during congestion, disrupting network operations, or creating arbitrage opportunities during reduced blockchain capacity

## Recommendation

Add `LibInformationValidationProvider` to the validation pipeline for `NextRound` behavior to ensure that `ConfirmedIrreversibleBlockRoundNumber` and related LIB fields cannot decrease or remain artificially low.

**Fix in `AEDPoSContract_Validation.cs`:**

Modify the validation provider setup for `NextRound` behavior to include `LibInformationValidationProvider`:

```csharp
case AElfConsensusBehaviour.NextRound:
    // Is sender's order of next round correct?
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    // Add LIB validation to prevent manipulation
    validationProviders.Add(new LibInformationValidationProvider());
    break;
```

This ensures that any attempt to provide a `ConfirmedIrreversibleBlockRoundNumber` value that is lower than the current value will be rejected during validation, preventing the DoS attack while maintaining the legitimate functionality of the `NextRound` transition.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanManipulateLIBRoundNumber_CausingSevereStatus()
{
    // Setup: Initialize consensus with multiple miners
    var miners = await InitializeConsensusWithMiners(5);
    var maliciousMiner = miners[0];
    
    // Advance several rounds normally
    for (int i = 0; i < 10; i++)
    {
        await ProduceNormalRound(miners);
    }
    
    // Verify normal status (max blocks = 8)
    var maxBlocksBeforeAttack = await ConsensusStub.GetMaximumBlocksCount.CallAsync(new Empty());
    Assert.Equal(8, maxBlocksBeforeAttack.Value);
    
    // ATTACK: Malicious miner creates NextRoundInput with manipulated ConfirmedIrreversibleBlockRoundNumber
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var nextRoundInput = GenerateValidNextRoundInput(currentRound, maliciousMiner);
    
    // Manipulate the LIB round number to create artificial gap
    nextRoundInput.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber - 8;
    
    // Execute attack
    await maliciousMiner.NextRound.SendAsync(nextRoundInput);
    
    // Verify Severe status is triggered (max blocks reduced to 1)
    var maxBlocksAfterAttack = await ConsensusStub.GetMaximumBlocksCount.CallAsync(new Empty());
    Assert.Equal(1, maxBlocksAfterAttack.Value); // DoS successful - throughput reduced by 87.5%
    
    // Verify blockchain is now in Severe status despite normal LIB progression
    var blockchainAge = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var libGap = blockchainAge.RoundNumber - blockchainAge.ConfirmedIrreversibleBlockRoundNumber;
    Assert.True(libGap >= 8); // Artificial gap created by manipulation
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-39)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L24-28)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L127-128)
```csharp
            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
