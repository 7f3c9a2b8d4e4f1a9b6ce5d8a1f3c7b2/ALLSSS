# Audit Report

## Title
Missing LIB Height Monotonicity Validation in NextRound and NextTerm Behaviors Allows Consensus Disruption

## Summary
The consensus validation logic only applies `LibInformationValidationProvider` to `UpdateValue` behavior, allowing malicious miners to submit `NextRound` or `NextTerm` transactions with artificially decreased Last Irreversible Block (LIB) values. This violates the critical LIB monotonicity invariant and can trigger false "Severe" blockchain status, severely degrading consensus performance.

## Finding Description

The `ValidateBeforeExecution` method conditionally adds validation providers based on consensus behavior. [1](#0-0) 

The `LibInformationValidationProvider` validates that LIB values cannot decrease by comparing the base round's LIB against the provided round's LIB, ensuring monotonicity. [2](#0-1) 

However, this critical validation is **only added for `UpdateValue` behavior**, not for `NextRound` or `NextTerm`. The alternative validators for these behaviors (`NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider`) do not check LIB monotonicity. [3](#0-2) 

Both `NextRoundInput` and `NextTermInput` contain `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields. [4](#0-3) [5](#0-4) 

These fields are preserved when converting to Round objects via the `ToRound()` method. [6](#0-5) [7](#0-6) 

The `NextRound` and `NextTerm` methods are public and accept these inputs directly. [8](#0-7) [9](#0-8) 

When `ProcessNextRound` or `ProcessNextTerm` executes, the Round object with potentially decreased LIB values is stored directly via `AddRoundInformation` without any LIB monotonicity validation. [10](#0-9) [11](#0-10) 

The `AddRoundInformation` method simply stores the round to state without validation. [12](#0-11) 

The stored LIB values are then used by `GetMaximumBlocksCount` to evaluate blockchain health status. [13](#0-12) 

If the LIB round number is artificially decreased, the blockchain can falsely enter "Severe" status when `currentRoundNumber >= libRoundNumber + SevereStatusRoundsThreshold`. [14](#0-13) 

When in "Severe" status, the maximum blocks count is reduced to 1, severely limiting block production. [15](#0-14) 

## Impact Explanation

**Critical Consensus Disruption:**
- A malicious miner can trigger false "Severe" blockchain status by decreasing LIB round numbers in their NextRound/NextTerm submissions
- When in "Severe" status, maximum blocks count is reduced to 1, severely degrading blockchain throughput and transaction processing capacity (from potentially 8+ blocks to just 1 block per miner)
- The `IrreversibleBlockHeightUnacceptable` event is fired inappropriately, potentially triggering emergency responses in monitoring systems

**Consensus Integrity Violation:**
- The fundamental invariant that LIB never decreases is violated, undermining the finality guarantees of the blockchain
- Round state contains incorrect LIB information that affects subsequent consensus operations
- Applications and services relying on LIB information for finality guarantees receive corrupted data

**Affected Components:**
- All consensus participants experience degraded performance due to the artificially imposed 1-block limit
- Cross-chain operations may be affected by incorrect LIB information since cross-chain indexing relies on irreversible blocks
- Monitoring and alerting systems receive false signals about blockchain health

## Likelihood Explanation

**High Likelihood:**
- Attack requires only miner privileges, which are normal network participants who can be elected through the governance process
- Extra block producers trigger NextRound regularly at the end of every round (approximately every few minutes)
- Any miner can trigger NextTerm during term transitions (approximately every 7 days based on default period settings)
- The exploit is straightforward: a miner constructs a `NextRoundInput` or `NextTermInput` with manually decreased `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` values
- No additional cryptographic material or special authorization required beyond being an active miner (validated by `PreCheck`)
- The malicious transaction passes all current validation checks since `LibInformationValidationProvider` is not applied

**Detection Difficulty:**
- The malicious transaction appears valid to all current validation checks
- By the time incorrect LIB values are detected through abnormal blockchain behavior, the state has already been corrupted
- Recovery requires manual intervention or protocol-level fixes to restore correct LIB values

## Recommendation

Add `LibInformationValidationProvider` to the validation providers list for both `NextRound` and `NextTerm` behaviors in the `ValidateBeforeExecution` method:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // Add this
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // Add this
        break;
}
```

This ensures that LIB monotonicity is enforced for all consensus behaviors that update round information with LIB data.

## Proof of Concept

A malicious miner would:

1. Wait for their turn to produce an extra block (triggering NextRound) or a term transition (triggering NextTerm)
2. Construct a malicious `NextRoundInput` or `NextTermInput` with:
   - All legitimate round information (miner list, mining times, etc.)
   - **Artificially decreased** `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` values (e.g., setting them to values from 10+ rounds ago)
3. Submit the transaction calling `NextRound()` or `NextTerm()` with this malicious input
4. The validation in `ValidateBeforeExecution` will pass since `LibInformationValidationProvider` is not applied for these behaviors
5. `ProcessNextRound` or `ProcessNextTerm` executes, storing the corrupted LIB values via `AddRoundInformation`
6. On the next call to `GetMaximumBlocksCount`, the blockchain evaluates `currentRoundNumber >= libRoundNumber + SevereStatusRoundsThreshold` and enters "Severe" status
7. Maximum blocks count drops to 1, severely degrading consensus performance

The attack is immediately effective and persists until correct LIB values are restored through legitimate consensus progression or manual intervention.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L16-17)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L16-17)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-156)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L24-28)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L127-128)
```csharp
            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```
