# Audit Report

## Title
Consensus Signature Forgery Allows Mining Order Manipulation in AEDPoS UpdateValue

## Summary
The AEDPoS consensus mechanism fails to verify that the `Signature` field submitted in `UpdateValueInput` matches the deterministically calculated value, allowing any authorized miner to forge signatures that directly control their mining position in the next round. The signature determines next-round order via modulus operation, breaking the randomness-based fairness guarantees of the consensus protocol.

## Finding Description

The vulnerability exists in the UpdateValue consensus flow where miners submit block information including a signature that should be calculated as `XOR(previousInValue, XOR(all signatures from previous round))`. However, the system accepts and uses any signature value provided by the miner without verification.

**Correct Signature Calculation (Block Production):**

During honest block production, the signature is correctly calculated using the previous round's state. [1](#0-0) [2](#0-1) 

**Missing Signature Verification (Block Validation):**

The validation provider only checks that the signature field is non-null and non-empty, never verifying correctness: [3](#0-2) 

**Unverified Signature Storage:**

When processing the block, the provided signature is directly stored without verification: [4](#0-3) 

**Critical Usage for Next Round Order:**

The unverified signature directly determines the miner's position in the next round through modulus arithmetic: [5](#0-4) 

**Attack Execution:**

A malicious authorized miner can:
1. Receive the consensus command with correctly calculated signature
2. Calculate which signature value would yield desired next-round position: `targetSignature` where `(targetSignature.ToInt64() % minersCount) + 1 = desired_position`
3. Replace the correct signature with the forged value in `UpdateValueInput`
4. Broadcast the block with forged signature
5. Validation passes (only null/empty check)
6. Forged signature is stored and used for next round ordering

The post-execution validation comparing round hashes will pass because both the block header and the updated state contain the same forged signature. [6](#0-5) 

## Impact Explanation

This vulnerability breaks a **critical consensus invariant**: that mining order is determined fairly through randomness derived from cryptographic commitments. The impact is HIGH because:

1. **Consensus Integrity Violation**: Any authorized miner can systematically manipulate their position in every round, obtaining position #1 to maximize block rewards and control extra block producer selection
2. **Fairness Breakdown**: The deterministic XOR-based randomness mechanism becomes attacker-controlled, violating the core security property of the AEDPoS protocol
3. **Undetectable Exploitation**: No validation exists to detect the forgery; honest nodes cannot distinguish forged from legitimate signatures
4. **Persistent Attack**: Can be repeated indefinitely across all rounds with no economic cost beyond gas fees

## Likelihood Explanation

The likelihood is **HIGH** because:

1. **Low Barrier**: Any authorized miner can exploit this - protecting against malicious miners is the fundamental purpose of consensus validation
2. **Trivial Execution**: Attack requires simple arithmetic to calculate desired signature value and replacing one field in the transaction
3. **Guaranteed Success**: No verification logic exists to block the attack; forged signatures pass all validation checks
4. **No Detection**: The protocol cannot distinguish forged signatures from correct ones without implementing the missing verification

The only precondition is being an authorized miner, which is the exact threat model consensus systems must defend against.

## Recommendation

Add signature verification in `UpdateValueValidationProvider` or `ProcessUpdateValue`:

```csharp
// In UpdateValueValidationProvider or before storing in ProcessUpdateValue
if (TryToGetPreviousRoundInformation(out var previousRound))
{
    var expectedSignature = previousRound.CalculateSignature(
        extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue
    );
    
    if (minerInRound.Signature != expectedSignature)
    {
        return new ValidationResult { 
            Message = "Signature does not match calculated value." 
        };
    }
}
```

This ensures the signature matches the deterministic calculation before accepting it into the consensus state.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a test miner authorized in the current round
2. Getting the correct consensus command with properly calculated signature
3. Modifying the `UpdateValueInput.Signature` to a forged value: `Hash.FromInt64((desiredPosition - 1))`
4. Submitting the UpdateValue transaction
5. Verifying the forged signature passes validation
6. Confirming the next round assigns the miner to the manipulated position

Test structure:
```csharp
[Fact]
public async Task Malicious_Miner_Can_Forge_Signature_To_Control_Next_Round_Position()
{
    // Setup: Initialize consensus with multiple miners
    // Execute: Miner produces block with forged signature
    // Verify: Next round assigns miner to attacker-chosen position
}
```

---

**Notes:**

The signature field is documented in the protobuf as "Calculated from current in value and signatures of previous round" [7](#0-6) , confirming this is a required calculation, not an arbitrary user input. The absence of verification contradicts this specification and creates the exploitable gap.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-244)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L99-101)
```csharp
            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** protobuf/aedpos_contract.proto (L275-276)
```text
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
```
