# Audit Report

## Title
Cross-Scheme State Confusion Due to One-to-One Mapping Limitation in TokenHolder Contract

## Summary
The TokenHolder contract enforces a one-to-one relationship between manager addresses and schemes, while the underlying Profit contract supports multiple schemes per manager. When `CreateScheme` is called multiple times, subsequent calls overwrite previous scheme metadata but create new schemes in the Profit contract, causing operations to use metadata from one scheme with the SchemeId from another, resulting in users locking wrong token types and being unable to receive appropriate profits.

## Finding Description

The vulnerability stems from an architectural mismatch between TokenHolder and Profit contracts regarding scheme management.

The TokenHolder contract uses a one-to-one mapping for scheme storage [1](#0-0) , allowing only one scheme per manager address.

However, `CreateScheme` creates a new scheme in the Profit contract on every invocation [2](#0-1)  and then overwrites the TokenHolder storage [3](#0-2)  without any duplicate check.

The Profit contract explicitly supports multiple schemes per manager through a repeated list structure [4](#0-3) , defined in the protobuf as `repeated aelf.Hash scheme_ids` [5](#0-4) .

When `UpdateTokenHolderProfitScheme` retrieves the SchemeId, it uses `FirstOrDefault()` to get only the first scheme from the manager's list [6](#0-5) .

**Exploitation Scenario:**

1. Manager calls `CreateScheme` with symbol "ELF", minimum_lock_minutes = 100
   - Profit creates SchemeId_A
   - TokenHolder stores {symbol: "ELF", minimum_lock_minutes: 100}

2. Manager calls `CreateScheme` again with symbol "USDT", minimum_lock_minutes = 200
   - Profit creates SchemeId_B (added to list)
   - TokenHolder **overwrites** to {symbol: "USDT", minimum_lock_minutes: 200}

3. User calls `RegisterForProfits`:
   - Gets mixed scheme: metadata from second scheme (USDT, 200) but SchemeId_A
   - Locks USDT tokens [7](#0-6) 
   - Adds beneficiary to SchemeId_A (ELF scheme) [8](#0-7) 

4. Result: User has locked USDT tokens but is registered for ELF profits, creating a state confusion where locked tokens don't match the profit scheme.

## Impact Explanation

**Critical State Confusion Impact:**
- Users lock incorrect token types that don't match the scheme's expected distribution token
- Wrong lock duration enforcement causes users to lock funds for incorrect periods [9](#0-8) 
- First scheme becomes permanently orphaned and inaccessible through TokenHolder methods since all operations use the overwritten metadata
- Operations like `Withdraw` [10](#0-9) , `ContributeProfits` [11](#0-10) , and `ClaimProfits` [12](#0-11)  all use the corrupted mixed scheme state

This breaks the fundamental security guarantee that locked tokens correspond to the profit scheme they're registered to, creating semantic confusion in the profit distribution mechanism.

## Likelihood Explanation

**High Likelihood:**
- `CreateScheme` is a public method with no access restrictions [13](#0-12) 
- No assertion exists to prevent duplicate calls (verified through code review showing no duplicate check in the method)
- The Profit contract is explicitly designed to support multiple schemes per manager [14](#0-13) , suggesting legitimate use cases
- No warning or error is thrown on subsequent calls, making accidental triggering likely
- Users may legitimately want multiple schemes for different tokens or configurations, making this a realistic scenario

## Recommendation

Add a duplicate check in `TokenHolderContract.CreateScheme` to prevent overwriting existing schemes:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add duplicate check
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
           "Scheme already exists for this address.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, if multiple schemes are intended to be supported, redesign TokenHolder's state structure to use a mapping that supports multiple schemes per address, similar to the Profit contract's architecture.

## Proof of Concept

```csharp
[Fact]
public async Task CrossScheme_StateConfusion_Test()
{
    // Step 1: Create first scheme with ELF
    await TokenHolderStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });

    // Step 2: Create second scheme with USDT (overwrites first)
    await TokenHolderStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",
        MinimumLockMinutes = 200
    });

    // Step 3: Get managing schemes from Profit contract - should have 2
    var schemeIds = await ProfitStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = DefaultSender });
    schemeIds.SchemeIds.Count.ShouldBe(2); // Two schemes exist in Profit

    // Step 4: Get scheme from TokenHolder - should have USDT metadata
    var scheme = await TokenHolderStub.GetScheme.CallAsync(DefaultSender);
    scheme.Symbol.ShouldBe("USDT"); // Metadata from second scheme
    scheme.MinimumLockMinutes.ShouldBe(200);

    // Step 5: Register for profits - will use USDT metadata but SchemeId from first scheme
    await TokenHolderStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = DefaultSender,
        Amount = 1000
    });

    // Verification: User locked USDT but is registered to first scheme (ELF)
    // This demonstrates the state confusion vulnerability
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L10-10)
```csharp
    public MappedState<Address, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-14)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L100-129)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.TokenContract.Approve.Send(new ApproveInput
        {
            Spender = State.ProfitContract.Value,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.ProfitContract.ContributeProfits.Send(new Profit.ContributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Symbol = input.Symbol,
            Amount = input.Amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-165)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L168-176)
```csharp
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-244)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L247-257)
```csharp
    public override Empty ClaimProfits(ClaimProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
        var beneficiary = input.Beneficiary ?? Context.Sender;
        State.ProfitContract.ClaimProfits.Send(new Profit.ClaimProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = beneficiary
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L290-293)
```csharp
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** protobuf/profit_contract.proto (L288-290)
```text
message CreatedSchemeIds {
    // The scheme ids.
    repeated aelf.Hash scheme_ids = 1;
```

**File:** test/AElf.Contracts.Profit.Tests/ProfitTests.cs (L26-39)
```csharp
        for (var i = 0; i < createTimes; i++)
        {
            var executionResult = await creator.CreateScheme.SendAsync(new CreateSchemeInput
            {
            });
            executionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        }

        var createdSchemeIds = await creator.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
        {
            Manager = creatorAddress
        });

        createdSchemeIds.SchemeIds.Count.ShouldBe(createTimes);
```
