# Audit Report

## Title
Insufficient Validation of OutValue in NextRound Allows Denial of Service Against Miners

## Summary
The `ValidationForNextRound()` method in `RoundTerminateValidationProvider` only validates that `InValue` is null for all miners in the next round, but critically fails to validate that `OutValue` is also null. This allows a malicious miner to inject arbitrary non-null `OutValue` data for other miners during round transitions, causing victims to be incorrectly identified as having already mined, preventing them from producing blocks and ultimately leading to their removal from the consensus set as "evil nodes."

## Finding Description

The vulnerability exists in the consensus round transition validation logic. The `ValidationForNextRound()` method only checks that InValue fields are null but completely omits validation of OutValue fields. [1](#0-0) 

The comment explicitly states "In Values Should Be Null" with no mention of OutValue validation. However, when a legitimate next round is generated via `GenerateNextRoundInformation()`, both InValue and OutValue are left as null (default values) in the newly created MinerInRound objects. [2](#0-1) 

A malicious miner can exploit this by calling the public `NextRound` method with crafted data: [3](#0-2) 

The malicious NextRoundInput data is converted to a Round object via `ToRound()`, which directly copies ALL fields including OutValue: [4](#0-3) 

This corrupted round data is then stored directly: [5](#0-4) 

The attack succeeds because consensus behavior determination relies critically on OutValue being null to identify miners who haven't mined yet: [6](#0-5) 

If OutValue is non-null (due to malicious injection), the miner is incorrectly treated as having already mined, causing them to skip the `UpdateValue` behavior. When UpdateValue is not executed, `SupposedOrderOfNextRound` is never set: [7](#0-6) 

Miners who didn't set `SupposedOrderOfNextRound` are classified as "not mined": [8](#0-7) 

These miners have their `MissedTimeSlots` counter incremented in the next round generation: [9](#0-8) 

After 4,320 missed time slots, victims are permanently marked as "evil nodes": [10](#0-9) [11](#0-10) [12](#0-11) 

## Impact Explanation

**Severity: HIGH**

**Consensus Integrity Impact:**
- Victim miners are completely prevented from producing their first consensus block (UpdateValue) during affected rounds because the system incorrectly believes they have already mined
- Each victim's `MissedTimeSlots` counter increments with every affected round
- After 4,320 missed time slots (approximately 3 days at 1 slot per minute), victims are permanently marked as "evil nodes" and removed from the consensus validator set
- The Election contract receives this evil node designation and bans the miner

**Network-Wide Impact:**
- Reduces the effective number of active consensus miners, directly weakening network security
- If multiple miners are targeted simultaneously, could severely impact chain liveness and block production rate
- Honest miners lose all mining rewards for missed blocks
- Network experiences degraded service quality and potentially slower transaction finalization

**Who is Affected:**
- Any honest miner can be targeted by any malicious miner in the current consensus set
- The entire network suffers from reduced consensus security
- Users experience degraded blockchain performance

This is a HIGH severity vulnerability because it enables a single malicious consensus miner to permanently remove honest validators from the network through a simple, low-cost attack that corrupts consensus state.

## Likelihood Explanation

**Probability: HIGH**

**Attacker Prerequisites (Easily Met):**
- Attacker must be a current consensus miner (approximately 17 miners in typical configuration)
- Attacker modifies their node to inject malicious OutValue data

Note: The original report incorrectly states the attacker must be the extra block producer. The permission check only validates the caller is in the miner list, not that they're the extra block producer. [13](#0-12) 

**Attack Complexity: LOW**
- The attack is straightforward: construct a NextRoundInput with non-null OutValue and matching FinalOrderOfNextRound for target miners
- No complex timing requirements, race conditions, or cryptographic operations needed
- Single transaction executes the complete attack
- No additional economic cost beyond normal mining operations

**Feasibility: HIGH**
- The NextRound method is publicly accessible to all miners
- The validation gap ensures the malicious transaction will pass all checks if OutValue and FinalOrderOfNextRound counts are matched [14](#0-13) 

**Detection: DIFFICULT**
- Malicious OutValue data is visible in block data but may not trigger immediate monitoring alerts
- Effects (miners missing slots) could initially be attributed to network connectivity issues
- Requires detailed blockchain analysis to identify the root cause of miner failures

The combination of easy prerequisites, low complexity, high feasibility, and difficult detection makes this a HIGH likelihood vulnerability.

## Recommendation

Add validation in `RoundTerminateValidationProvider.ValidationForNextRound()` to ensure OutValue is also null for all miners in the next round, not just InValue:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    // Check InValue is null
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information - InValue not null." };
    
    // ADD THIS: Check OutValue is also null
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.OutValue != null))
        return new ValidationResult { Message = "Incorrect next round information - OutValue not null." };

    return new ValidationResult { Success = true };
}
```

## Proof of Concept

A malicious miner can execute the following attack:

1. Obtain current round information
2. Generate legitimate next round structure via `GenerateNextRoundInformation()`
3. For victim miner(s), modify their MinerInRound entry to set:
   - `OutValue = Hash.FromString("malicious")`
   - `FinalOrderOfNextRound = 1` (to match the count validation)
4. Leave all `InValue` fields as null (to pass existing validation)
5. Call `NextRound()` with this crafted input
6. Validation passes because only InValue is checked, not OutValue
7. Victim's OutValue is now non-null in the stored round
8. When victim attempts to mine, `GetConsensusBehaviour()` sees OutValue != null and treats them as already having mined
9. Victim never executes UpdateValue, never sets SupposedOrderOfNextRound
10. Next round generation classifies victim as "not mined" and increments MissedTimeSlots
11. After 4,320 rounds, victim is marked as evil node and permanently banned

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L46-55)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L131-135)
```csharp
    private List<MinerInRound> GetNotMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound == 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-56)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
