# Audit Report

## Title
Missing Public Key Length Validation in Cross-Chain Miner Information Update Allows Invalid Addresses and Token Loss

## Summary
The `UpdateInformationFromCrossChain()` function in the AEDPoS consensus contract accepts miner public keys from parent chain consensus data without validating their length. When these keys are later used for token distribution via `DistributeResourceTokensToPreviousMiners()`, invalid-length keys are converted to addresses that don't correspond to any valid keypair, causing permanent loss of distributed resource tokens.

## Finding Description

The vulnerability exists across multiple contract layers where public key validation is absent:

**Entry Point - Election Contract:**
The `AnnounceElectionFor()` method accepts candidate public keys as hex strings without length validation. [1](#0-0) 

The method converts the hex string to bytes and derives an address without verifying it represents a valid ECDSA public key (which should be 33 or 65 bytes). [2](#0-1) 

**Conversion Layer - No Length Checks:**
The `ByteArrayHelper.HexStringToByteArray()` function converts any valid hex string to bytes without length validation. [3](#0-2) 

The `ByteStringHelper.FromHexString()` wrapper also performs no validation. [4](#0-3) 

**Address Derivation - Accepts Any Length:**
The `Address.FromPublicKey()` method accepts byte arrays of any length, simply computing a double hash without validating the input is a valid ECDSA public key. [5](#0-4) 

**Vulnerable Update Flow:**
When side chains receive parent chain consensus data, `UpdateInformationFromCrossChain()` extracts miner public keys from `RealTimeMinersInformation` and stores them without validation. [6](#0-5) 

**Token Distribution - Fund Loss:**
The `DistributeResourceTokensToPreviousMiners()` method distributes side chain resource tokens (transaction fees and rental fees) to addresses derived from these stored public keys. [7](#0-6) 

For each miner, tokens are transferred to addresses created by converting stored keys to addresses, with no validation that the key is valid. [8](#0-7) 

**Cross-Chain Validation Gap:**
The cross-chain validation service validates that proposed data matches cached parent chain data structurally, but does not validate the semantic correctness of public keys within that data. [9](#0-8) 

## Impact Explanation

**Direct Fund Loss:** Resource tokens (transaction and rental fees collected on side chains) distributed to addresses derived from invalid-length public keys are permanently unrecoverable. Since addresses are created by hashing the invalid-length byte array, they don't correspond to any valid ECDSA keypair - no private key exists that can control these addresses. The amount lost per distribution equals `balance / minerList.Count` for each resource token symbol.

**Consensus Data Integrity:** Side chains maintain an incorrect view of the parent chain's miner list, storing invalid public keys that cannot represent actual miners capable of producing blocks.

**Systemic Weakness:** The lack of defensive validation creates a single point of failure. While upstream systems (Election contract, parent chain consensus) should ideally prevent invalid keys from entering the system, the absence of validation at the cross-chain boundary means any upstream failure cascades to fund loss.

The severity is Medium because the immediate exploitability is limited by socioeconomic factors (requires election), but the technical vulnerability is real with concrete fund loss impact.

## Likelihood Explanation

**Attack Requirements:**
1. Register candidate with invalid-length public key via `AnnounceElectionFor()` - technically trivial, just requires any hex string
2. Lock 100,000 native tokens as election deposit [10](#0-9) 
3. Get elected - requires receiving votes from other participants

**Practical Limitations:**
- Rational voters would likely scrutinize candidate public keys before voting
- Invalid keys are detectable by informed participants
- Miners with invalid keys cannot produce blocks (no corresponding private key)
- Such miners miss all time slots and get automatically banned after 4,320 missed slots (~3 days) [11](#0-10) 
- Limited time window for causing damage before detection

**Economic Factors:**
- The 100,000 token lock is recoverable by calling `QuitElection()`
- Cost is primarily opportunity cost of locked tokens
- Benefit is disruption and limited token theft from distributions
- Economic rationality is questionable for direct profit motive

However, the vulnerability is **technically exploitable** with no code-level barriers. The social/economic constraints reduce likelihood but don't eliminate the risk, especially in scenarios with low voter participation or compromised voting mechanisms.

## Recommendation

Add public key length validation at multiple defensive layers:

**1. Election Contract Validation:**
```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkey = input.Pubkey;
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    
    // Add validation: ECDSA public keys must be 33 (compressed) or 65 (uncompressed) bytes
    Assert(pubkeyBytes.Length == 33 || pubkeyBytes.Length == 65, 
        "Invalid public key length. Must be 33 or 65 bytes.");
    
    // ... rest of method
}
```

**2. Cross-Chain Information Update Validation:**
```csharp
public override Empty UpdateInformationFromCrossChain(BytesValue input)
{
    // ... existing checks ...
    
    var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
    
    // Validate all public keys before storing
    foreach (var key in minersKeys)
    {
        var keyBytes = ByteArrayHelper.HexStringToByteArray(key);
        Assert(keyBytes.Length == 33 || keyBytes.Length == 65,
            $"Invalid miner public key length in cross-chain data: {key}");
    }
    
    State.MainChainCurrentMinerList.Value = new MinerList
    {
        Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
    };
    
    // ... rest of method
}
```

**3. Consider Address.FromPublicKey() Enhancement:**
While changing core `Address.FromPublicKey()` behavior may have broader implications, consider adding a separate validated method or documentation warning about expected input constraints.

## Proof of Concept

The vulnerability can be demonstrated with a test showing that:
1. An invalid-length public key (e.g., 10 hex characters = 5 bytes) can be registered via `AnnounceElectionFor()`
2. When this key is used in `Address.FromPublicKey()`, it produces a valid address
3. No validation error occurs despite the key being too short for a valid ECDSA public key
4. Tokens transferred to this address are unrecoverable

```csharp
[Fact]
public async Task InvalidPublicKeyLength_AllowsRegistration_CausesTokenLoss()
{
    // Invalid public key - only 5 bytes (10 hex chars) instead of 33 or 65
    var invalidPubkey = "0a0b0c0d0e";
    
    // Step 1: Register candidate with invalid key - should fail but doesn't
    await ElectionContractStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = invalidPubkey,
        Admin = DefaultSender
    });
    
    // Step 2: Verify invalid key was stored
    var candidateInfo = await ElectionContractStub.GetCandidateInformation.CallAsync(
        new StringValue { Value = invalidPubkey });
    Assert.True(candidateInfo.IsCurrentCandidate);
    
    // Step 3: Convert invalid key to address - produces valid address but uncontrolled
    var invalidKeyBytes = ByteArrayHelper.HexStringToByteArray(invalidPubkey);
    Assert.Equal(5, invalidKeyBytes.Length); // Only 5 bytes, not 33 or 65
    
    var derivedAddress = Address.FromPublicKey(invalidKeyBytes);
    Assert.NotNull(derivedAddress); // Address created successfully
    
    // Step 4: Demonstrate token loss - no one can control this address
    // Any tokens sent to derivedAddress are permanently lost
    // because no valid ECDSA private key corresponds to a 5-byte public key
}
```

## Notes

This vulnerability represents a **defensive validation failure** - the system lacks input validation that should exist regardless of assumptions about upstream data. While the practical exploitability is constrained by socioeconomic factors (election requirements, automatic detection/banning), the technical vulnerability is real with concrete fund loss impact. The absence of validation at the cross-chain boundary creates unnecessary risk that should be mitigated through proper input validation at all trust boundaries.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-19)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
        }
```

**File:** src/AElf.Types/Helper/ByteStringHelper.cs (L21-24)
```csharp
        public static ByteString FromHexString(string hexString)
        {
            return ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(hexString));
        }
```

**File:** src/AElf.Types/Types/Address.cs (L37-41)
```csharp
        public static Address FromPublicKey(byte[] bytes)
        {
            var hash = bytes.ComputeHash().ComputeHash();
            return new Address(hash);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-61)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L66-96)
```csharp
    private void DistributeResourceTokensToPreviousMiners()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
            Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
            if (amount <= 0) continue;
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
        }
    }
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataValidationService.cs (L161-166)
```csharp
            if (!parentChainBlockDataList[i].Equals(parentChainBlockData))
            {
                Logger.LogDebug(
                    $"Incorrect parent chain data. Parent chain height: {targetHeight}.");
                return false;
            }
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L10-10)
```csharp
    public const int KeepRounds = 40960;
```
