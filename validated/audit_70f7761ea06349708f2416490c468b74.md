# Audit Report

## Title
Miners Can Manipulate Mining Order by Providing Arbitrary SupposedOrderOfNextRound Values

## Summary
The AEDPoS consensus contract accepts `SupposedOrderOfNextRound` values from miners without validating that they match the cryptographically-calculated value derived from their signature. This allows malicious miners to arbitrarily control their mining position in subsequent rounds, breaking the consensus mechanism's fairness guarantees.

## Finding Description

The AEDPoS consensus mechanism is designed to determine each miner's position in the next round based on their cryptographic signature using the formula `GetAbsModulus(signature.ToInt64(), minersCount) + 1`. [1](#0-0) 

This proper calculation occurs in `ApplyNormalConsensusData`, which is called by the view function `GetConsensusExtraDataToPublishOutValue` when generating consensus data. [2](#0-1) 

However, when miners submit `UpdateValue` transactions, the contract directly assigns the `SupposedOrderOfNextRound` value from the input without any recalculation or validation: [3](#0-2) 

The validation phase only uses `UpdateValueValidationProvider`, which checks that `OutValue` and `Signature` are non-null/non-empty and validates the `PreviousInValue` relationship, but does NOT verify the `SupposedOrderOfNextRound` calculation: [4](#0-3) 

The `NextRoundMiningOrderValidationProvider` that could validate mining order is only applied for `NextRound` behavior, not for `UpdateValue` behavior: [5](#0-4) 

Furthermore, even this validator only checks counts, not individual value correctness: [6](#0-5) 

The manipulated `SupposedOrderOfNextRound` becomes `FinalOrderOfNextRound`, which directly determines mining order when `GenerateNextRoundInformation` creates the next round: [7](#0-6) 

## Impact Explanation

This vulnerability fundamentally breaks the consensus mechanism's cryptographic fairness guarantees. A malicious miner can:

1. **Control Mining Position**: Consistently choose to be first in mining order by setting `SupposedOrderOfNextRound = 1`, gaining priority in block production and rewards
2. **Produce Extra Blocks**: First miners can produce additional blocks when subsequent miners are late or offline, earning extra rewards
3. **Manipulate Consensus Flow**: By controlling their position, miners can influence round transitions and potentially the sequence of random number generation
4. **Enable Collusion**: Multiple malicious miners can coordinate to systematically manipulate the mining schedule across rounds

The severity is critical because mining order should be unpredictable and determined by cryptographic signatures, not miner choice. This affects all honest miners who lose their fair chance at preferential positions, and compromises the integrity of the consensus mechanism itself.

## Likelihood Explanation

The attack is highly practical with minimal complexity:

**Attacker Requirements**: Any active miner in the consensus set can execute this attack.

**Attack Steps**:
1. Miner calls `GetConsensusExtraData` to obtain a valid `OutValue` and `Signature` for their current `InValue`
2. Miner constructs a custom `UpdateValueInput` with the valid cryptographic values but replaces `SupposedOrderOfNextRound` with their desired position (e.g., 1 for first)
3. Miner directly calls the public `UpdateValue` method with the modified input
4. The contract accepts this transaction as the validation only checks signature/outvalue existence, not correctness of the order value

**Feasibility**: The attack requires no special conditions beyond normal miner participation. The `UpdateValue` method is public [8](#0-7)  and can be called directly by any miner with valid credentials. The cost is minimal (standard transaction fees) while the benefit is continuous preferential positioning.

**Detection**: While manipulation could theoretically be detected by comparing submitted values against recalculated ones, there is no on-chain enforcement, and miners are economically incentivized to exploit this advantage.

## Recommendation

Add validation in `UpdateValueValidationProvider` to verify that the provided `SupposedOrderOfNextRound` matches the value that should be calculated from the signature:

```csharp
// In UpdateValueValidationProvider.ValidateHeaderInformation
var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
var signature = minerInRound.Signature;
var minersCount = validationContext.ProvidedRound.RealTimeMinersInformation.Count;

var expectedOrder = GetAbsModulus(signature.ToInt64(), minersCount) + 1;
if (minerInRound.SupposedOrderOfNextRound != expectedOrder)
{
    return new ValidationResult { Message = "Invalid SupposedOrderOfNextRound - does not match signature calculation." };
}
```

Additionally, consider applying similar validation to ensure `FinalOrderOfNextRound` values in `TuneOrderInformation` resolve conflicts according to the protocol rules rather than allowing arbitrary modifications.

## Proof of Concept

```csharp
[Fact]
public async Task MinerCanManipulateMiningOrder_Test()
{
    // Setup: Initialize consensus with multiple miners
    var miners = GenerateMiners(5);
    await InitializeConsensus(miners);
    
    // Malicious miner generates valid consensus data
    var maliciousMiner = miners[2]; // Originally would be somewhere in middle
    var triggerInfo = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(maliciousMiner.PublicKey),
        InValue = HashHelper.ComputeFrom("test_invalue"),
        Behaviour = AElfConsensusBehaviour.UpdateValue
    };
    
    // Get properly calculated consensus data
    var extraDataResult = await ConsensusStub.GetConsensusExtraData.CallAsync(
        new BytesValue { Value = triggerInfo.ToByteString() });
    var consensusInfo = AElfConsensusHeaderInformation.Parser.ParseFrom(extraDataResult.Value);
    
    // Extract the properly calculated values
    var properOrder = consensusInfo.Round.RealTimeMinersInformation[maliciousMiner.PublicKey.ToHex()]
        .SupposedOrderOfNextRound;
    
    // Verify the proper order would not be 1 (first position)
    properOrder.ShouldNotBe(1);
    
    // Malicious miner constructs UpdateValueInput with MANIPULATED order
    var maliciousInput = new UpdateValueInput
    {
        OutValue = consensusInfo.Round.RealTimeMinersInformation[maliciousMiner.PublicKey.ToHex()].OutValue,
        Signature = consensusInfo.Round.RealTimeMinersInformation[maliciousMiner.PublicKey.ToHex()].Signature,
        PreviousInValue = Hash.Empty,
        SupposedOrderOfNextRound = 1, // MANIPULATED - choosing first position instead of proper order
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        RoundId = consensusInfo.Round.RoundId
    };
    
    // Submit the malicious transaction
    await MaliciousMinerStub.UpdateValue.SendAsync(maliciousInput);
    
    // Advance to next round
    await ProduceNextRound();
    
    // Verify: Malicious miner is now in first position despite signature not indicating this
    var nextRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var maliciousMinerOrder = nextRound.RealTimeMinersInformation[maliciousMiner.PublicKey.ToHex()].Order;
    
    maliciousMinerOrder.ShouldBe(1); // Successfully manipulated to first position
    // This breaks consensus fairness - order should be derived from signature, not miner choice
}
```

## Notes

The vulnerability exists because the contract trusts miner-provided `SupposedOrderOfNextRound` values without cryptographic verification. While the proper calculation exists in `ApplyNormalConsensusData`, it is only used in the view function path and not enforced during transaction validation. The `UpdateValue` method is publicly callable, allowing miners to bypass the intended consensus data generation flow and directly inject manipulated values. This breaks the fundamental invariant that mining order must be determined by unpredictable cryptographic signatures, not miner preference.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-87)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-33)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
