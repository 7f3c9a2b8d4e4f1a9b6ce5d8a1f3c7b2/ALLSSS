# Audit Report

## Title
Initial Miners Can Bypass Election Announcement Check via ReplaceCandidatePubkey to Gain Backup Subsidy

## Summary
The `ReplaceCandidatePubkey` method in the Election contract fails to validate whether the new pubkey is an initial miner, allowing a bypass of the restriction that prevents initial miners from announcing election. This enables an attacker to register an initial miner pubkey in the backup subsidy profit scheme, allowing them to receive candidate subsidies in addition to their role as initial miners.

## Finding Description

The Election contract enforces a critical invariant: initial miners (bootstrap nodes from chain genesis) cannot announce election to prevent them from participating in the candidate subsidy distribution. This is enforced in the `AnnounceElection` method [1](#0-0) .

However, the `ReplaceCandidatePubkey` method contains insufficient validation. When replacing a candidate's pubkey, the method only validates that the new pubkey is not already a candidate [2](#0-1) , but critically **does not check** whether the new pubkey exists in the `InitialMiners` list.

The exploit flow:
1. Attacker announces election with a regular pubkey (not an initial miner), passing the initial miner check
2. Regular pubkey is added to `Candidates` list and potentially to `DataCentersRankingList` with subsidy registration
3. Attacker calls `ReplaceCandidatePubkey` with old=regular pubkey, new=initial miner pubkey
4. The method removes the old pubkey from `Candidates` and adds the initial miner pubkey [3](#0-2) 
5. If in the data center ranking list, subsidy beneficiary is transferred from old to new pubkey [4](#0-3) 
6. The `InitialMiners` list update block only executes if the OLD pubkey was in `InitialMiners` [5](#0-4) 
7. Since the old pubkey (regular candidate) is NOT in `InitialMiners`, this block is skipped and `InitialMiners` remains unchanged

**Result**: The initial miner pubkey now exists in both `Candidates` and `InitialMiners` lists simultaneously, with backup subsidy beneficiary registration active.

## Impact Explanation

This vulnerability enables **reward misallocation** within the Treasury profit distribution system. The Treasury contract allocates funds to separate profit schemes with distinct purposes [6](#0-5) :

- **MinerReward** (20% weight by default): For actual miners producing blocks
- **BackupSubsidy** (5% weight by default): For candidate nodes not currently mining
- **CitizenWelfare** (75% weight by default): For voters

Initial miners are intentionally **excluded** from the candidate subsidy system, as evidenced by the explicit check preventing them from announcing election and their use as fallback miners when insufficient candidates exist [7](#0-6) .

By exploiting this vulnerability, an initial miner can:
1. Remain in the `InitialMiners` list (serving as a backup miner)
2. Be registered as a beneficiary in the `BackupSubsidy` profit scheme [8](#0-7) 
3. Receive backup subsidy distributions intended only for regular candidates

This dilutes the subsidy share of legitimate candidates and misallocates treasury resources contrary to the protocol's economic design.

## Likelihood Explanation

**Execution Path**: The exploit requires only two public method calls with realistic preconditions:
1. `AnnounceElection` with a regular pubkey (requires token lock, but recoverable)
2. `ReplaceCandidatePubkey` as the candidate admin

**Feasibility**: 
- Initial miner pubkeys are public information from chain initialization [9](#0-8) 
- Any user can announce election and become a candidate admin
- The validation checks in `ReplaceCandidatePubkey` all pass incorrectly [10](#0-9) 

**Economic Incentive**: The attacker gains continuous backup subsidy rewards (5% of treasury distributions) across multiple terms with only the temporary cost of locked tokens for election announcement, making the exploit highly profitable.

## Recommendation

Add validation in the `ReplaceCandidatePubkey` method to prevent replacing with an initial miner pubkey:

```csharp
public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
{
    Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
        "Pubkey is neither a current candidate nor an initial miner.");
    Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
        "Pubkey is in already banned.");
    
    // ADD THIS CHECK:
    var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));
    Assert(!State.InitialMiners.Value.Value.Contains(newPubkeyBytes),
        "Cannot replace with an initial miner pubkey.");
    
    // Permission check.
    Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
    
    // ... rest of the method
}
```

This prevents initial miner pubkeys from being added to the `Candidates` list through the replacement mechanism, maintaining the invariant that initial miners cannot participate in candidate elections.

## Proof of Concept

```csharp
[Fact]
public async Task InitialMiner_CanBypass_ElectionCheck_ViaReplacement()
{
    // Setup: Get initial miner pubkey from genesis
    var initialMiners = await ElectionContractStub.GetInitialMiners.CallAsync(new Empty());
    var initialMinerPubkey = initialMiners.Value.First().ToHex();
    
    // Step 1: Attacker announces election with a regular pubkey
    var regularKeyPair = CryptoHelper.GenerateKeyPair();
    var regularPubkey = regularKeyPair.PublicKey.ToHex();
    var attackerStub = GetElectionContractTester(regularKeyPair);
    
    await attackerStub.AnnounceElection.SendAsync(attackerAddress);
    
    // Verify regular pubkey is in Candidates
    var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
    candidates.Value.Select(p => p.ToHex()).ShouldContain(regularPubkey);
    
    // Verify initial miner is NOT in Candidates
    candidates.Value.Select(p => p.ToHex()).ShouldNotContain(initialMinerPubkey);
    
    // Step 2: Replace regular pubkey with initial miner pubkey
    await attackerStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = regularPubkey,
        NewPubkey = initialMinerPubkey
    });
    
    // Verify exploit: Initial miner is now in BOTH Candidates AND InitialMiners
    var candidatesAfter = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
    candidatesAfter.Value.Select(p => p.ToHex()).ShouldContain(initialMinerPubkey);
    
    var initialMinersAfter = await ElectionContractStub.GetInitialMiners.CallAsync(new Empty());
    initialMinersAfter.Value.Select(p => p.ToHex()).ShouldContain(initialMinerPubkey);
    
    // This violates the invariant: initial miner is now eligible for backup subsidy
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L149-150)
```csharp
        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L34-38)
```csharp
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L175-197)
```csharp
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L199-218)
```csharp
        var rankingList = State.DataCentersRankingList.Value;
        //the profit receiver is not exist but candidate in the data center ranking list
        if (rankingList.DataCenters.ContainsKey(input.OldPubkey))
        {
            rankingList.DataCenters.Add(input.NewPubkey, rankingList.DataCenters[input.OldPubkey]);
            rankingList.DataCenters.Remove(input.OldPubkey);
            State.DataCentersRankingList.Value = rankingList;

            // Notify Profit Contract to update backup subsidy profiting item.
            if (State.ProfitContract.Value == null)
                State.ProfitContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            
            var oldProfitReceiver = GetProfitsReceiverOrDefault(input.OldPubkey);
            var profitReceiver = oldProfitReceiver.Value.Any()
                ? oldProfitReceiver
                : null;
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L470-478)
```csharp
    private DividendPoolWeightSetting GetDefaultDividendPoolWeightSetting()
    {
        return new DividendPoolWeightSetting
        {
            CitizenWelfareWeight = 15,
            BackupSubsidyWeight = 1,
            MinerRewardWeight = 4
        };
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L62-76)
```csharp
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L781-795)
```csharp
    private void AddBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var subsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = beneficiaryAddress,
                Shares = 1,
            },
            ProfitDetailId = subsidyId
        });
    }
```
