# Audit Report

## Title
Insufficient Taylor Series Precision in Natural Logarithm Causes Bancor Pricing Underestimation at Boundary Conditions

## Summary
The `Ln` function in BancorHelper implements a Taylor series with a hardcoded 20-iteration limit, resulting in approximation errors when calculating natural logarithms near the domain boundary (x approaching 2). When users purchase amounts close to half the connector balance, this mathematical imprecision propagates through the Bancor pricing formula, causing the protocol to undercharge by approximately 3-5%, leading to systematic fund loss. [1](#0-0) 

## Finding Description
The vulnerability stems from a fundamental limitation in the mathematical implementation used for token pricing calculations. The `Ln` function computes natural logarithms using the Taylor series expansion ln(a) = -x - x²/2 - x³/3 - ... where x = 1-a, with convergence guaranteed for |x| < 1. [2](#0-1) 

The boundary validation permits input values where 0 < a < 2, enforced by checking `Math.Abs(x) >= 1`: [3](#0-2) 

When a user invokes the `Buy` function to purchase tokens, the `GetAmountToPayFromReturn` calculation produces x = bt / (bt - a), where bt is the toConnectorBalance and a is the purchase amount: [4](#0-3) 

For purchases approaching half the pool (a ≈ bt/2), x approaches 2, causing the internal Taylor series variable (1-x) to approach -1. The alternating harmonic series (1 - 1/2 + 1/3 - 1/4 + ... ± 1/20) converges to ln(2) ≈ 0.693147, but with only 20 terms yields approximately 0.668, representing a ~3.6% approximation error.

This error propagates through the exponential calculation: `bf * (Exp(y * Ln(x)) - 1)`. For equal weight ratios (y=1) and x≈2, the payment calculation becomes:
- Correct: bf × (e^0.693 - 1) = bf × (2.00 - 1) = bf
- Erroneous: bf × (e^0.668 - 1) = bf × (1.95 - 1) = 0.95×bf
- Underestimation: ~5%

The `Buy` function contains no validation preventing large purchases relative to pool size: [5](#0-4) 

The only protection is a user-supplied `PayLimit` parameter which an attacker controls and can set arbitrarily high to accept the mispriced transaction.

## Impact Explanation
**Direct Financial Loss**: The protocol systematically undercharges users for boundary trades. For a connector with 2,000,000 tokens, a purchase of 999,998 tokens produces:
- x = 2,000,000 / (2,000,000 - 999,998) ≈ 1.999998
- Approximation error in ln(x) of ~3.6%
- With weight ratio y=1: Payment underestimated by approximately 4-5%
- For a trade correctly priced at 1,000,000 base tokens, user pays only ~950,000
- Protocol loss: ~50,000 tokens per exploit transaction

**Affected Parties**:
- TokenConverter contract loses base token reserves on underpriced trades
- Future liquidity providers receive insufficient backing for resource tokens
- Treasury receives proportionally reduced fee revenue (0.5% of underpriced amount)

The 0.5% transaction fee cannot offset the 4-5% pricing error. This breaks the core Bancor formula invariant that maintains constant reserve ratios and accurate automated price discovery. [6](#0-5) 

## Likelihood Explanation
**Attacker Requirements**: Any user with sufficient capital to purchase approximately half of a connector balance can exploit this vulnerability. The `Buy` function is publicly accessible with no privilege requirements: [7](#0-6) 

**Exploit Complexity**: Medium
1. Attacker identifies connector pairs with substantial liquidity
2. Calculates purchase amount approaching bt/2 to trigger x ≈ 2
3. Sets `PayLimit` sufficiently high to accept the underpriced calculation
4. Executes `Buy` transaction

**Feasibility**: The vulnerability is deterministic and mathematically guaranteed. For production TokenConverter pools with millions of tokens in liquidity, the absolute profit (tens of thousands of tokens per trade) makes exploitation economically rational. The transaction appears as a legitimate large purchase, providing no obvious detection signal.

**Realistic Preconditions**: 
- Connector pools must have adequate liquidity (typical for mainnet resource token converters)
- No additional validation prevents purchases of arbitrary size relative to pool reserves
- The boundary condition x ≈ 2 is mathematically reachable within normal protocol operations

## Recommendation
Implement one or more of the following mitigations:

1. **Increase Taylor Series Precision**: While factorial overflow limits iterations to 20 for the current implementation, consider using alternative mathematical approaches (e.g., range reduction techniques or pre-computed lookup tables) to improve ln() accuracy at boundary values.

2. **Add Purchase Size Limits**: Enforce maximum purchase amounts relative to connector balance:
```csharp
var maxPurchasePercentage = 0.45m; // 45% maximum
Assert(input.Amount <= toConnectorBalance * maxPurchasePercentage, 
    "Purchase amount exceeds maximum allowed percentage of pool");
```

3. **Implement Boundary Protection**: Add explicit checks in `GetAmountToPayFromReturn` to reject calculations where x approaches the problematic boundary:
```csharp
var x = bt / (bt - a);
Assert(x <= 1.95m, "Purchase amount creates pricing boundary condition");
```

4. **Enhanced Slippage Controls**: Replace user-controlled `PayLimit` with protocol-enforced slippage tolerance that accounts for mathematical precision limits.

## Proof of Concept
The vulnerability can be demonstrated by examining the existing test suite which lacks boundary condition validation. All existing tests use small purchase amounts (100, 1000, 10000) relative to connector balances (100_0000): [8](#0-7) 

A proof-of-concept test would call `BancorHelper.GetAmountToPayFromReturn` with:
- fromConnectorBalance = 2,000,000
- toConnectorBalance = 2,000,000  
- amountToReceive = 999,998
- Equal weights (0.5, 0.5)

This produces x ≈ 1.999998, triggering the approximation error and demonstrating the ~5% payment underestimation compared to the mathematically correct Bancor formula result.

---

**Notes**

The vulnerability is confirmed through rigorous code analysis. The 20-iteration limit is a hard constraint due to factorial overflow (21! exceeds long capacity), not a design choice: [9](#0-8) 

The error magnitude varies based on the connector weight ratio (y = wt/wf). The 4-5% underestimation occurs when weights are equal (y=1). Different weight ratios may produce different error magnitudes but the fundamental vulnerability persists. The vulnerability only manifests at extreme boundary conditions (purchases approaching 50% of pool), but represents a genuine pricing invariant violation with concrete financial impact.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L98-98)
```csharp
    private const int _LOOPS = 20; // Max = 20
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L124-143)
```csharp
    private static decimal Ln(decimal a)
    {
        /*
        ln(a) = log(1-x) = - x - x^2/2 - x^3/3 - ...   (where |x| < 1)
            x: a = 1-x    =>   x = 1-a = 1 - 1.004 = -.004
        */
        var x = 1 - a;
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");

        decimal result = 0;
        uint iteration = _LOOPS;
        while (iteration > 0)
        {
            result -= Pow(x, iteration) / iteration;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-127)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");
```

**File:** test/AElf.Contracts.TokenConverter.Internal.Tests/BancorHelperTest.cs (L56-65)
```csharp
    [Theory]
    [InlineData(100L)]
    [InlineData(1000L)]
    [InlineData(10000L)]
    public void BuyResource_Test(long paidElf)
    {
        var resourceAmount1 = BuyOperation(paidElf);
        var resourceAmount2 = BuyOperation(paidElf);
        resourceAmount1.ShouldBeGreaterThanOrEqualTo(resourceAmount2);
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/BancorHelper.cs (L100-101)
```csharp
        //14197454024290336768L, //1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20 * 21,        // NOTE: Overflow during compilation
        //17196083355034583040L, //1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20 * 21 * 22    // NOTE: Overflow during compilation
```
