# Audit Report

## Title
Insufficient Address Validation in Governance Contracts Enables Griefing Attack via Unexecutable Proposals

## Summary
The Association, Parliament, and Referendum governance contracts fail to properly validate the `ToAddress` field of proposals. The validation only checks if the Address object reference is null, but does not verify that the internal `Value` byte array is non-empty. This allows whitelisted proposers to create proposals with empty addresses that pass all validation checks but fail during execution, causing approved proposals to become permanently stuck until expiry.

## Finding Description

The three governance contracts (Association, Parliament, Referendum) use an insufficient validation pattern that only checks if the Address object reference is null, without validating the internal `Value` property:

**Association Contract**: [1](#0-0) 

**Parliament Contract**: [2](#0-1) 

**Referendum Contract**: [3](#0-2) 

The proper validation pattern used elsewhere in the codebase checks both the object reference AND the internal Value: [4](#0-3) 

This same pattern is also used in contract deployment validation: [5](#0-4) 

When a proposal with an empty address value reaches the Release stage, the inline transaction is created: [6](#0-5) 

The `SendVirtualInlineBySystemContract` method simply adds the transaction to a list without immediate validation: [7](#0-6) 

When inline transactions are executed, any failure causes the parent transaction to fail: [8](#0-7) 

The inline transaction with an invalid address triggers a `SmartContractFindRegistrationException`: [9](#0-8) 

When the transaction fails, state changes are reverted and only pre/post traces are committed: [10](#0-9) 

This means the proposal removal at line 198 in the Release method never gets committed, leaving the proposal stuck in storage.

## Impact Explanation

This vulnerability creates a **governance denial-of-service** attack vector:

1. **Wasted Resources**: Organization members spend time and effort reviewing, voting on, and approving proposals that can never be executed
2. **Governance Disruption**: Critical governance decisions cannot be implemented even after proper approval
3. **Storage Waste**: Unexecutable proposals remain in storage until expiry (potentially days/weeks)
4. **Trust Erosion**: Repeated failures damage member confidence in the governance system
5. **Repeatability**: Any whitelisted proposer can create multiple such proposals

While the proposals can eventually be cleared after expiry using the `ClearProposal` method, the temporary DoS and wasted effort constitute significant operational impact on governance processes.

The severity is **Medium** because while it doesn't result in direct fund loss, it significantly disrupts critical governance operations and can be systematically exploited by malicious proposers.

## Likelihood Explanation

The attack is highly feasible:

1. **Attacker Profile**: Any whitelisted proposer can execute this attack. In multi-organization ecosystems, whitelist membership is common and realistic
2. **Technical Complexity**: Trivial - simply create a proposal with an Address object that has an empty Value property
3. **Preconditions**: None beyond being a whitelisted proposer
4. **Detection**: Difficult to detect before Release execution since validation passes at both creation and release stages
5. **Cost**: Only requires transaction fees for proposal creation

The likelihood is **Medium** due to the realistic attacker profile and low execution complexity.

## Recommendation

Update the validation logic in all three governance contracts to check both the Address object reference and its internal Value property:

```csharp
private bool Validate(ProposalInfo proposal)
{
    if (proposal.ToAddress == null || proposal.ToAddress.Value.IsNullOrEmpty() || 
        string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
        !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
        return false;

    return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
}
```

Apply this fix to:
- `contract/AElf.Contracts.Association/Association_Helper.cs`
- `contract/AElf.Contracts.Parliament/Parliament_Helper.cs`
- `contract/AElf.Contracts.Referendum/Referendum_Helper.cs`

## Proof of Concept

```csharp
[Fact]
public async Task EmptyAddressValue_ShouldFailProposalExecution()
{
    // Setup: Create organization with whitelisted proposer
    var organizationAddress = await AssociationContractStub.CreateOrganization.SendAsync(
        new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold { MinimalApprovalThreshold = 1 },
            ProposerWhiteList = new ProposerWhiteList { Proposers = { DefaultSender } },
            OrganizationMemberList = new OrganizationMemberList { OrganizationMembers = { DefaultSender } }
        });

    // Attack: Create proposal with Address object that has empty Value
    var proposalId = await AssociationContractStub.CreateProposal.SendAsync(
        new CreateProposalInput
        {
            ToAddress = new Address { Value = ByteString.Empty }, // Empty Value bypasses validation
            ContractMethodName = "TestMethod",
            OrganizationAddress = organizationAddress.Output,
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
        });

    // Approve the proposal
    await AssociationContractStub.Approve.SendAsync(proposalId.Output);

    // Attempt to release - should fail but proposal validation passes
    var releaseResult = await AssociationContractStub.Release.SendWithExceptionAsync(proposalId.Output);
    
    // Verify: Release transaction fails
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Invalid contract address");
    
    // Verify: Proposal remains in storage (not removed)
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId.Output);
    proposal.ProposalId.ShouldBe(proposalId.Output);
}
```

This test demonstrates that a proposal with an empty Address value passes validation but causes Release execution to fail, leaving the proposal stuck in storage.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L157-166)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = CheckProposalNotExpired(proposal);
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L395-401)
```csharp
    private void ValidateContractOperation(ContractOperation contractOperation, int currentVersion, Hash codeHash)
    {
        Assert(contractOperation.Deployer != null && !contractOperation.Deployer.Value.IsNullOrEmpty(),
            "Invalid input deploying address.");
        Assert(contractOperation.Salt != null && !contractOperation.Salt.Value.IsNullOrEmpty(), "Invalid input salt.");
        Assert(contractOperation.CodeHash != null && !contractOperation.CodeHash.Value.IsNullOrEmpty(),
            "Invalid input code hash.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L266-276)
```csharp
    public void SendVirtualInlineBySystemContract(Hash fromVirtualAddress, Address toAddress, string methodName,
        ByteString args)
    {
        TransactionContext.Trace.InlineTransactions.Add(new Transaction
        {
            From = ConvertVirtualAddressToContractAddressWithContractHashName(fromVirtualAddress, Self),
            To = toAddress,
            MethodName = methodName,
            Params = args
        });
    }
```

**File:** src/AElf.Kernel.Core/Extensions/TransactionTraceExtensions.cs (L8-19)
```csharp
    public static bool IsSuccessful(this TransactionTrace txTrace)
    {
        if (txTrace.ExecutionStatus != ExecutionStatus.Executed) return false;

        if (txTrace.PreTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.InlineTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.PostTraces.Any(trace => !trace.IsSuccessful())) return false;

        return true;
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L105-126)
```csharp
    private static bool TryUpdateStateCache(TransactionTrace trace, TieredStateCache groupStateCache)
    {
        if (trace == null)
            return false;

        if (!trace.IsSuccessful())
        {
            var transactionExecutingStateSets = new List<TransactionExecutingStateSet>();

            AddToTransactionStateSets(transactionExecutingStateSets, trace.PreTraces);
            AddToTransactionStateSets(transactionExecutingStateSets, trace.PostTraces);

            groupStateCache.Update(transactionExecutingStateSets);
            trace.SurfaceUpError();
        }
        else
        {
            groupStateCache.Update(trace.GetStateSets());
        }

        return true;
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L150-161)
```csharp
        try
        {
            executive = await _smartContractExecutiveService.GetExecutiveAsync(
                internalChainContext,
                singleTxExecutingDto.Transaction.To);
        }
        catch (SmartContractFindRegistrationException)
        {
            txContext.Trace.ExecutionStatus = ExecutionStatus.ContractError;
            txContext.Trace.Error += "Invalid contract address.\n";
            return trace;
        }
```
