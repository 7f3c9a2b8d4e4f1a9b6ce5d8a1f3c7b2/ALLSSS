# Audit Report

## Title
Null Dereference in Profit Distribution Causes Permanent DoS When Sub-Scheme Beneficiary Details Are Removed

## Summary
The `DistributeProfitsForSubSchemes` method in the Profit contract accesses `ProfitDetailsMap` without null validation, enabling a permanent denial-of-service condition when sub-scheme profit details are removed via `RemoveBeneficiary` while the sub-scheme remains in the `SubSchemes` list. This creates an irrecoverable state inconsistency that permanently blocks all future profit distributions for the affected scheme.

## Finding Description

The vulnerability exists due to a missing null check when accessing sub-scheme profit details during distribution. The contract attempts to access the `Details` property of `subItemDetail` without verifying it is non-null, causing a `NullReferenceException` when the mapping entry has been deleted. [1](#0-0) 

The contract maintains two separate data structures for managing sub-schemes:
1. The `SubSchemes` list within the `Scheme` object (modified only by `AddSubScheme`/`RemoveSubScheme`)
2. The `ProfitDetailsMap` state mapping (modified by `AddBeneficiary`/`RemoveBeneficiary`)

When `AddSubScheme` is called, both structures are synchronized by adding the sub-scheme to the list and creating corresponding profit details via `AddBeneficiary`. [2](#0-1) 

However, the contract allows these structures to become desynchronized through the following attack path:

**Step 1 - Initial Distribution**: During profit distribution, `DistributeProfitsForSubSchemes` updates `LastProfitPeriod` for all sub-scheme details to the current period, then `DistributeProfits` increments the scheme's `CurrentPeriod`. [3](#0-2) [4](#0-3) 

**Step 2 - Permissionless Claiming**: The `ClaimProfits` method allows anyone to claim profits on behalf of any beneficiary address without authorization checks. When claiming profits for a sub-scheme's virtual address, the method updates `LastProfitPeriod` via `ProfitAllPeriods`. [5](#0-4) [6](#0-5) [7](#0-6) 

After claiming up to current period minus one, `LastProfitPeriod` is set to equal `CurrentPeriod`, creating the condition where `LastProfitPeriod >= CurrentPeriod`.

**Step 3 - Desynchronization via Wrong API**: For schemes with `CanRemoveBeneficiaryDirectly = true`, calling `RemoveBeneficiary` on the sub-scheme's virtual address triggers `RemoveProfitDetails`, which selects all non-removed details for removal when the scheme allows direct removal. [8](#0-7) 

When `LastProfitPeriod >= CurrentPeriod`, the condition evaluates to true, causing complete removal of the detail from the list. [9](#0-8) 

If all details are removed, the entire entry is deleted from `ProfitDetailsMap`. [10](#0-9) 

**Step 4 - Permanent DoS**: The next call to `DistributeProfits` iterates over the `SubSchemes` list and attempts to access `ProfitDetailsMap` for each sub-scheme's virtual address. Since the entry was deleted, `subItemDetail` is null, and accessing `subItemDetail.Details` throws a `NullReferenceException`, causing the transaction to fail permanently.

The root cause is that `RemoveBeneficiary` only removes from `ProfitDetailsMap` but does not update the `SubSchemes` list, while `DistributeProfitsForSubSchemes` assumes all entries in `SubSchemes` have corresponding `ProfitDetailsMap` entries. In contrast, `RemoveSubScheme` properly maintains both data structures. [11](#0-10) 

## Impact Explanation

**Severity: High** - This vulnerability creates a permanent denial-of-service condition with the following impacts:

1. **Permanent Distribution Failure**: Once triggered, the scheme cannot distribute profits in any future period. Every `DistributeProfits` call will revert with a `NullReferenceException`, making the contract's core functionality unusable.

2. **Fund Locking**: All tokens accumulated in the scheme's virtual address become permanently inaccessible to beneficiaries, as distribution is the only mechanism to release these funds to beneficiaries.

3. **Cascading Failures**: If the affected scheme is itself a sub-scheme of parent schemes, the DoS propagates upward through the scheme hierarchy, potentially disabling critical system schemes like Treasury or TokenHolder profit distribution that are fundamental to the AElf economic model.

4. **No Recovery Path**: The contract provides no mechanism to repair this inconsistent state without a contract upgrade. The sub-scheme entry remains in the `SubSchemes` list permanently, causing all future distributions to fail at the same point.

5. **Protocol Treasury Impact**: If system-level schemes (Treasury, Economic contract schemes) are affected, the entire protocol's reward distribution mechanism fails, preventing validator rewards, treasury releases, and token holder dividends from being distributed.

The impact is severe because it affects availability (permanent DoS of core functionality), fund accessibility (irreversible token locking), and can cascade to break system-critical economic mechanisms.

## Likelihood Explanation

**Likelihood: Medium-High** - The vulnerability is feasible under realistic operational conditions:

**Attacker Capabilities:**
- No special privileges required beyond scheme creation (public operation) or compromised scheme manager
- Can also occur through accidental API misuse by legitimate operators managing complex profit schemes

**Attack Complexity: Low**
1. Create a scheme with `CanRemoveBeneficiaryDirectly = true` (valid configuration option)
2. Add a sub-scheme via `AddSubScheme` (manager operation)
3. Distribute profits at least once (manager operation)
4. Call `ClaimProfits` for the sub-scheme's virtual address (public, permissionless operation)
5. Call `RemoveBeneficiary` instead of `RemoveSubScheme` (manager operation or API confusion)
6. Next distribution attempt triggers the permanent DoS

**Realistic Scenarios:**
1. **API Confusion**: The dual-API design (`RemoveBeneficiary` vs `RemoveSubScheme`) creates significant operational confusion. A manager intending to remove a sub-scheme relationship might reasonably call the wrong method, especially since sub-schemes are internally represented as beneficiaries.

2. **Malicious Manager**: A compromised or malicious scheme manager can intentionally trigger this vulnerability to permanently grief all beneficiaries and lock funds.

3. **Accidental Triggering**: Complex schemes with multiple layers of sub-schemes increase the likelihood of operational errors and using the wrong removal API.

**No Existing Protections:**
- No validation prevents calling `RemoveBeneficiary` on sub-scheme virtual addresses
- No check ensures `SubSchemes` and `ProfitDetailsMap` remain synchronized
- `ClaimProfits` has no authorization check, allowing anyone to manipulate `LastProfitPeriod` for any address
- No null check in `DistributeProfitsForSubSchemes` to handle missing entries gracefully

The probability is medium-high because while it requires scheme manager privileges for most steps, the dual-API design makes accidental triggering highly likely in production environments, and the critical Step 4 (claiming profits) is completely permissionless.

## Recommendation

Implement the following fixes to address this vulnerability:

1. **Add Null Check in Distribution**: Add defensive null validation in `DistributeProfitsForSubSchemes` before accessing profit details:

```csharp
var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
if (subItemDetail == null || subItemDetail.Details == null || subItemDetail.Details.Count == 0)
{
    // Log inconsistency and skip this sub-scheme
    Context.LogDebug(() => $"Warning: Sub-scheme {subSchemeShares.SchemeId} has no profit details, skipping distribution");
    continue;
}
foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;
```

2. **Prevent Beneficiary Removal on Sub-Schemes**: Add validation in `RemoveBeneficiary` to prevent removing sub-scheme virtual addresses:

```csharp
// Check if the beneficiary is a sub-scheme virtual address
var isSubScheme = scheme.SubSchemes.Any(s => 
    Context.ConvertVirtualAddressToContractAddress(s.SchemeId) == input.Beneficiary);
Assert(!isSubScheme, "Cannot remove sub-scheme via RemoveBeneficiary. Use RemoveSubScheme instead.");
```

3. **Add Authorization to ClaimProfits**: Restrict profit claiming to the beneficiary or authorized addresses:

```csharp
var beneficiary = input.Beneficiary ?? Context.Sender;
if (input.Beneficiary != null && input.Beneficiary != Context.Sender)
{
    Assert(Context.Sender == scheme.Manager || 
           Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
           "Only beneficiary, manager, or TokenHolder contract can claim profits on behalf of others.");
}
```

4. **Synchronization Check**: Add an integrity check method that validates `SubSchemes` and `ProfitDetailsMap` are synchronized, which can be called periodically or before critical operations.

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_SubScheme_NullDereference_DoS_Test()
{
    // Step 1: Create parent scheme with CanRemoveBeneficiaryDirectly = true
    var parentSchemeId = await CreateSchemeAsync(new CreateSchemeInput
    {
        CanRemoveBeneficiaryDirectly = true
    });
    
    // Step 2: Create and add sub-scheme
    var subSchemeId = await CreateSchemeAsync();
    await Creators[0].AddSubScheme.SendAsync(new AddSubSchemeInput
    {
        SchemeId = parentSchemeId,
        SubSchemeId = subSchemeId,
        SubSchemeShares = 100
    });
    
    // Step 3: Contribute and distribute profits once
    await Creators[0].ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = parentSchemeId,
        Amount = 1000,
        Symbol = "ELF"
    });
    
    await Creators[0].DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = parentSchemeId,
        Period = 1,
        AmountsMap = { { "ELF", 1000 } }
    });
    
    // Step 4: Anyone can claim profits for the sub-scheme's virtual address
    var subSchemeVirtualAddress = await Creators[0].GetSchemeAddress.CallAsync(
        new SchemePeriod { SchemeId = subSchemeId, Period = 0 });
    
    await Creators[0].ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = parentSchemeId,
        Beneficiary = subSchemeVirtualAddress
    });
    
    // Step 5: Manager mistakenly calls RemoveBeneficiary instead of RemoveSubScheme
    await Creators[0].RemoveBeneficiary.SendAsync(new RemoveBeneficiaryInput
    {
        SchemeId = parentSchemeId,
        Beneficiary = subSchemeVirtualAddress
    });
    
    // Step 6: Next distribution fails with NullReferenceException (Permanent DoS)
    await Creators[0].ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = parentSchemeId,
        Amount = 1000,
        Symbol = "ELF"
    });
    
    var result = await Creators[0].DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = parentSchemeId,
        Period = 2,
        AmountsMap = { { "ELF", 1000 } }
    });
    
    // This should fail with NullReferenceException, proving the DoS
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("NullReferenceException");
}
```

## Notes

This vulnerability represents a critical state consistency issue in the Profit contract where two data structures tracking the same conceptual entity (sub-schemes) can become desynchronized through legitimate API calls. The permissionless nature of `ClaimProfits` significantly increases the attack surface, as any external actor can manipulate the `LastProfitPeriod` state to enable the desynchronization condition. The dual-API design for removing sub-schemes (`RemoveBeneficiary` vs `RemoveSubScheme`) creates an operational footgun that makes accidental triggering highly likely in production environments managing complex hierarchical profit schemes.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L109-126)
```csharp
        AddBeneficiary(new AddBeneficiaryInput
        {
            SchemeId = input.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = subSchemeVirtualAddress,
                Shares = input.SubSchemeShares
            },
            EndPeriod = long.MaxValue
        });

        // Add a sub profit scheme.
        scheme.SubSchemes.Add(new SchemeBeneficiaryShare
        {
            SchemeId = input.SubSchemeId,
            Shares = input.SubSchemeShares
        });
        State.SchemeInfos[input.SchemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L149-152)
```csharp
        // Remove profit details
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L346-350)
```csharp
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L376-383)
```csharp
        if (profitDetails.Details.Count != 0)
        {
            State.ProfitDetailsMap[scheme.SchemeId][beneficiary] = profitDetails;
        }
        else
        {
            State.ProfitDetailsMap[scheme.SchemeId].Remove(beneficiary);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L634-637)
```csharp
            var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
            foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;

            State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress] = subItemDetail;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L754-754)
```csharp
        var beneficiary = input.Beneficiary ?? Context.Sender;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L784-784)
```csharp
            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L908-917)
```csharp
                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }

        profitDetail.LastProfitPeriod = lastProfitPeriod;
```
