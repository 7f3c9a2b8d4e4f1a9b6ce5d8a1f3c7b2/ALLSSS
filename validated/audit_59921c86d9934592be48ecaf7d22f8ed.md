# Audit Report

## Title
Period Boundary Validation Bypass Causes Permanent Share Dilution in Profit Distribution

## Summary
The `AddBeneficiary` and `FixProfitDetail` methods in the Profit contract fail to validate that `EndPeriod >= StartPeriod`, allowing profit details with inverted period boundaries to be created. When schemes use delayed distribution (`DelayDistributePeriodCount > 0`), these malformed details have their shares permanently added to `TotalShares` but are filtered out during profit claims, causing irreversible dilution of all legitimate beneficiaries' profits. The Treasury's CitizenWelfare scheme uses delayed distribution and is directly affected.

## Finding Description

The vulnerability exists in the period boundary validation logic of the Profit contract. The `AddBeneficiary` method validates that the user-provided `EndPeriod` is at least the current period, but then calculates `StartPeriod` by adding `DelayDistributePeriodCount` to the current period. [1](#0-0)  There is no validation that the resulting `StartPeriod` is less than or equal to `EndPeriod`.

**Attack Scenario:**
For a scheme with `CurrentPeriod = 100` and `DelayDistributePeriodCount = 1`:
1. Manager calls `AddBeneficiary` with `EndPeriod = 100`
2. Validation passes: `100 >= 100` ✓
3. System calculates: `StartPeriod = 100 + 1 = 101`
4. Result: `StartPeriod (101) > EndPeriod (100)` - invalid state created

The shares from this malformed detail are immediately added to the scheme's `TotalShares`. [2](#0-1) 

When `ClaimProfits` is called, malformed details are filtered out by the `availableDetails` check that requires `EndPeriod >= StartPeriod` when `LastProfitPeriod == 0`. [3](#0-2)  Since these details never make it into `availableDetails`, they are never added to `profitableDetails` [4](#0-3) , and consequently never make it into `profitDetailsToRemove`. [5](#0-4)  Only shares from `profitDetailsToRemove` are subtracted from `TotalShares`, leaving the malformed detail's shares permanently inflating the denominator.

The `FixProfitDetail` method has the same issue - it allows independent modification of `StartPeriod` and `EndPeriod` without validating their relationship. [6](#0-5) 

The same filtering logic exists in view methods. [7](#0-6) 

## Impact Explanation

**Direct Economic Impact:**
When orphaned shares remain in `TotalShares`, all profit distributions use an inflated denominator. For example:
- Legitimate beneficiary Alice: 1,000 shares
- Malformed beneficiary Bob: 9,000 shares (StartPeriod > EndPeriod)
- `TotalShares = 10,000`, but only Alice can claim
- Distribution of 100,000 tokens: Alice receives `(1,000 / 10,000) × 100,000 = 10,000`
- Alice gets 10% instead of 100%, losing 90,000 tokens
- The 90,000 unclaimed tokens remain locked in period-specific virtual addresses indefinitely

**Affected Systems:**
The Treasury's CitizenWelfare scheme uses `DelayDistributePeriodCount = 1` [8](#0-7) , making it directly vulnerable. This affects citizen welfare distributions, a core economic mechanism of the AElf chain.

**Severity: HIGH**
- Causes permanent, irreversible fund lockup
- Affects core Treasury/Welfare economic distributions
- Impact compounds with each distribution period
- No recovery mechanism exists for locked funds

## Likelihood Explanation

**Unintentional Trigger:**
Scheme managers may not understand that `DelayDistributePeriodCount` affects the `StartPeriod` calculation. When adding beneficiaries with reasonable-looking end periods, they can inadvertently create invalid states. For the Treasury Welfare scheme with `DelayDistributePeriodCount = 1`, setting `EndPeriod = CurrentPeriod` creates the vulnerability.

**Intentional Exploitation:**
A malicious or compromised scheme manager can deliberately:
1. Use `AddBeneficiary` to add beneficiaries with strategically chosen `EndPeriod` values to dilute legitimate beneficiaries
2. Use `FixProfitDetail` to modify existing valid profit details into invalid ones

**Feasibility: HIGH**
- Entry points are public methods callable by scheme managers (trusted but not infallible)
- Precondition met: Treasury's Welfare scheme has `DelayDistributePeriodCount = 1`
- Single transaction execution
- Difficult to detect without deep state inspection
- No warning or error returned to indicate the invalid state creation

## Recommendation

Add validation in both `AddBeneficiary` and `FixProfitDetail` to ensure `StartPeriod <= EndPeriod`:

**For AddBeneficiary:**
```csharp
var profitDetail = new ProfitDetail
{
    StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
    EndPeriod = input.EndPeriod,
    Shares = input.BeneficiaryShare.Shares,
    Id = input.ProfitDetailId
};

// Add validation
Assert(profitDetail.StartPeriod <= profitDetail.EndPeriod, 
    $"Invalid period range. StartPeriod ({profitDetail.StartPeriod}) must be <= EndPeriod ({profitDetail.EndPeriod})");
```

**For FixProfitDetail:**
```csharp
var newDetail = fixingDetail.Clone();
newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;

// Add validation
Assert(newDetail.StartPeriod <= newDetail.EndPeriod,
    $"Invalid period range. StartPeriod ({newDetail.StartPeriod}) must be <= EndPeriod ({newDetail.EndPeriod})");
```

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_PeriodBoundaryValidationBypass_ShareDilution_Test()
{
    // Create scheme with DelayDistributePeriodCount = 1 (like Treasury Welfare)
    var creator = Creators[0];
    var schemeId = await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        DelayDistributePeriodCount = 1
    });
    var scheme = await creator.GetScheme.CallAsync(schemeId.Output);
    
    // Add legitimate beneficiary Alice with 1000 shares
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId.Output,
        BeneficiaryShare = new BeneficiaryShare 
        { 
            Beneficiary = Accounts[0].Address, 
            Shares = 1000 
        },
        EndPeriod = long.MaxValue
    });
    
    // Add malformed beneficiary Bob with EndPeriod = CurrentPeriod
    // This bypasses validation but creates StartPeriod > EndPeriod
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId.Output,
        BeneficiaryShare = new BeneficiaryShare 
        { 
            Beneficiary = Accounts[1].Address, 
            Shares = 9000 
        },
        EndPeriod = scheme.CurrentPeriod // Creates StartPeriod = CurrentPeriod + 1
    });
    
    // Verify TotalShares includes both (10000)
    scheme = await creator.GetScheme.CallAsync(schemeId.Output);
    scheme.TotalShares.ShouldBe(10000);
    
    // Contribute and distribute profits
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId.Output,
        Amount = 100000,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    });
    
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId.Output,
        Period = scheme.CurrentPeriod,
        AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, 100000 } }
    });
    
    // Alice claims - should get diluted amount (10000 instead of 100000)
    var aliceBalanceBefore = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput 
        { 
            Owner = Accounts[0].Address, 
            Symbol = ProfitContractTestConstants.NativeTokenSymbol 
        })).Balance;
        
    await Creators[0].ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId.Output,
        Beneficiary = Accounts[0].Address
    });
    
    var aliceBalanceAfter = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput 
        { 
            Owner = Accounts[0].Address, 
            Symbol = ProfitContractTestConstants.NativeTokenSymbol 
        })).Balance;
    
    var aliceProfit = aliceBalanceAfter - aliceBalanceBefore;
    aliceProfit.ShouldBe(10000); // Diluted to 10% instead of 100%
    
    // Bob cannot claim (malformed detail filtered out)
    var bobProfits = await creator.GetProfitAmount.CallAsync(new GetProfitAmountInput
    {
        SchemeId = schemeId.Output,
        Beneficiary = Accounts[1].Address,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    });
    bobProfits.Value.ShouldBe(0);
    
    // 90000 tokens remain locked permanently
    // Verify permanent share dilution persists
    scheme = await creator.GetScheme.CallAsync(schemeId.Output);
    scheme.TotalShares.ShouldBe(10000); // Malformed shares never removed
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L179-188)
```csharp
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;

        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L299-301)
```csharp
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-766)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L767-767)
```csharp
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-792)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L113-117)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod < scheme.CurrentPeriod && (d.LastProfitPeriod == 0
                ? d.EndPeriod >= d.StartPeriod
                : d.EndPeriod >= d.LastProfitPeriod)
        ).ToList();
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L64-64)
```csharp
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
```
