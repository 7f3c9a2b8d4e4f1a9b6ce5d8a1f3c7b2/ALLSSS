# Audit Report

## Title
Unvalidated Revealed PreviousInValues Allow Malicious Miners to Cause Consensus DoS

## Summary
A malicious miner can inject incorrect `PreviousInValue` data for other miners through the `RevealedInValues` mechanism without cryptographic validation. These unvalidated values are written to consensus state and prevent legitimate miners from producing valid blocks, causing denial-of-service against targeted miners.

## Finding Description

The AEDPoS consensus protocol has a critical validation gap where revealed previous in-values for OTHER miners are written to state without verifying the cryptographic commitment `hash(PreviousInValue) == OutValue`.

**Unvalidated Write Path:**

When a miner produces a block, the `UpdateLatestSecretPieces` method processes `RevealedInValues` from trigger information and writes them directly to the Round state if the target miner's `PreviousInValue` is currently empty or null, with NO cryptographic verification. [1](#0-0) 

Similarly, during transaction execution, the `PerformSecretSharing` method writes `MinersPreviousInValues` dictionary entries directly to state without hash validation. [2](#0-1) 

**Insufficient Validation:**

The validation provider only checks the SENDER's own `PreviousInValue` by verifying that `hash(PreviousInValue) == OutValue` from the previous round, but does NOT validate the `PreviousInValue` fields for OTHER miners included in the Round object. [3](#0-2) 

**Victim Cannot Overwrite:**

Once an incorrect value is written, the `ApplyNormalConsensusData` method prevents overwriting because it only sets `PreviousInValue` if currently empty or null. [4](#0-3) 

When the victim miner later produces their block with the correct `PreviousInValue` in their trigger information, the round object passed to `ApplyNormalConsensusData` already contains the attacker's incorrect value, so the correct value cannot overwrite it. The victim's block then contains the incorrect `PreviousInValue`, which is extracted during transaction generation. [5](#0-4) 

This extracted incorrect value is used in the `UpdateValueInput` and fails validation because the hash check reveals the mismatch with the victim's actual previous `OutValue`.

## Impact Explanation

**Consensus Disruption:**
A malicious miner can prevent targeted miners from participating in consensus by corrupting their `PreviousInValue` in state. When the victim attempts to produce a block, the validation checks `hash(corrupted_PreviousInValue) == victim's_previous_OutValue`, which fails, causing the block to be rejected.

**Affected Parties:**
- **Targeted miners**: Cannot produce valid blocks until the round transitions, losing mining rewards and reputation
- **Network**: Reduced active miner count degrades consensus liveness and security
- **Chain security**: If multiple miners are targeted simultaneously, consensus could experience significant disruption

**Severity:** Medium - Requires malicious miner (mis-scoped privilege), affects consensus integrity (critical system), limited to DoS (no fund theft), detectable through monitoring, recoverable through round transitions.

## Likelihood Explanation

**Attacker Capabilities:**
Must be an active miner in the current round to produce blocks with UpdateValue behavior and include `RevealedInValues` in trigger information.

**Attack Complexity:**
Straightforward execution - attacker modifies their off-chain node's `SecretSharingService` to return arbitrary values in `GetRevealedInValues()`, which are then included in the trigger information without on-chain verification. [6](#0-5) 

**Feasibility Conditions:**
1. Attacker must produce a block before the victim in round N+1
2. Victim's `PreviousInValue` must not yet be set in state (first-write-wins vulnerability)
3. Secret sharing must be enabled in the consensus configuration

**Probability:** Medium - requires compromised/malicious miner but attack execution is reliable once conditions are met.

## Recommendation

Add cryptographic validation for ALL miners' `PreviousInValue` entries, not just the sender's:

```csharp
// In UpdateLatestSecretPieces
foreach (var revealedInValue in triggerInformation.RevealedInValues)
{
    if (!updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key)) continue;
    
    // ADD VALIDATION: Verify hash(revealedInValue) == previous OutValue
    if (TryToGetPreviousRoundInformation(out var previousRound) &&
        previousRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
    {
        var expectedHash = HashHelper.ComputeFrom(revealedInValue.Value);
        var previousOutValue = previousRound.RealTimeMinersInformation[revealedInValue.Key].OutValue;
        if (expectedHash != previousOutValue)
        {
            Context.LogDebug(() => $"Invalid revealed in value for {revealedInValue.Key}");
            continue; // Skip invalid values
        }
    }
    
    if (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
        updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null)
        updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
}
```

Apply the same validation in `PerformSecretSharing` for the `MinersPreviousInValues` dictionary.

## Proof of Concept

A PoC would demonstrate:
1. Miner A produces block with incorrect `RevealedInValues[B] = wrong_hash`
2. Verify state now contains wrong hash for miner B's `PreviousInValue`
3. Miner B attempts to produce block
4. Show that B's block validation fails due to `hash(wrong_hash) != B.previous_OutValue`
5. Confirm B cannot produce valid blocks until round transition

The test would require setting up consensus with multiple miners, manipulating trigger information to inject incorrect values, and verifying the validation failure on the victim's subsequent block production attempt.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L39-39)
```csharp
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L112-114)
```csharp
            var revealedInValues = _secretSharingService.GetRevealedInValues(hint.RoundId);
            foreach (var revealedInValue in revealedInValues)
                trigger.RevealedInValues.Add(revealedInValue.Key, revealedInValue.Value);
```
