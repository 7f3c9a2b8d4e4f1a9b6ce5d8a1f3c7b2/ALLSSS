# Audit Report

## Title
Scheme Manager Can Retroactively Increase MinimumLockMinutes to Prevent User Withdrawals

## Summary
The `CreateScheme` function in the TokenHolder contract lacks protection against multiple invocations, allowing a malicious scheme manager to overwrite the `TokenHolderProfitScheme` with a new `MinimumLockMinutes` value. This retroactively applies to existing users who registered under the original scheme, permanently trapping their locked tokens.

## Finding Description

The vulnerability exists because `CreateScheme` unconditionally overwrites scheme parameters in state storage. [1](#0-0) 

When users register for profits, their lock timestamp is recorded separately from the scheme parameters. [2](#0-1) 

During withdrawal, the system retrieves the current scheme and uses its `MinimumLockMinutes` to validate against the original lock timestamp. [3](#0-2) 

The root cause involves three critical design flaws:

1. **Lock timestamps persist separately** - stored in `State.LockTimestamp[lockId]` independent of scheme versions
2. **Withdrawal validation uses CURRENT scheme's MinimumLockMinutes** against ORIGINAL lock timestamp
3. **The Profit contract allows multiple scheme creations** via count-based scheme ID generation [4](#0-3) 

Each `CreateScheme` call creates a new profit scheme with a different ID because the scheme ID is generated from the count of existing schemes. [5](#0-4) 

The `UpdateTokenHolderProfitScheme` helper only updates the `SchemeId` and `Period` fields but leaves `MinimumLockMinutes` unchanged from the overwritten scheme. [6](#0-5) 

**Attack Scenario:**
1. Manager calls `CreateScheme` with `MinimumLockMinutes = 1`
2. User calls `RegisterForProfits` and locks 10,000 ELF at timestamp T0
3. Manager calls `CreateScheme` again with `MinimumLockMinutes = 100000000` (~190 years), overwriting the stored scheme
4. User attempts withdrawal but the check at line 227 fails: `T0 + 100000000 minutes < CurrentTime` returns false
5. User's 10,000 ELF is permanently locked with no recovery mechanism

## Impact Explanation

**HIGH Severity** - This vulnerability enables complete freezing of user funds:

- **Direct Fund Impact**: Users' locked tokens become permanently inaccessible. A user who locks 10,000 ELF expecting a 1-minute lock period can have it changed to 100,000,000 minutes (~190 years), making funds unrecoverable during the user's lifetime.

- **Affected Parties**: All users who have registered for profits in TokenHolder schemes, including individual token holders, DApp staking contracts, and side chain dividend participants (as evidenced by the AEDPoS consensus contract's usage). [7](#0-6) 

- **No Recourse**: Once the scheme parameters are overwritten, there is no mechanism for users to recover their funds. The lock is enforced by the MultiToken contract and cannot be bypassed.

- **Unilateral Execution**: Unlike governance attacks requiring consensus, this can be executed instantly by any scheme manager with a single transaction.

## Likelihood Explanation

**HIGH Likelihood** - The attack is trivial to execute:

- **Attacker Capabilities**: Anyone can become a scheme manager by calling `CreateScheme`. The barrier to entry is minimal - only transaction gas costs.

- **Attack Complexity**: Trivial - requires only one additional `CreateScheme` transaction with modified parameters. No special timing, coordination, or technical sophistication needed.

- **Detection**: Silent attack - no validation prevents multiple scheme creation. Users only discover the issue when attempting withdrawal, by which point their funds are already trapped.

- **Economic Rationality**: Highly favorable for malicious actors - single transaction cost versus potential to lock millions in user funds. Can be combined with social engineering (advertise high yields with short lock periods to attract deposits, then change parameters).

- **Preconditions**: Only requires that users have registered for profits, which is normal operation of the contract.

## Recommendation

Add a check in `CreateScheme` to prevent multiple scheme creation per manager:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add protection against multiple scheme creation
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this manager.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, store the `MinimumLockMinutes` at registration time per user and validate against that value during withdrawal, rather than using the current scheme's value.

## Proof of Concept

```csharp
[Fact]
public async Task RetroactiveMinimumLockMinutesIncrease_LocksUserFunds()
{
    // 1. Manager creates scheme with 1 minute lock
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    // 2. User registers and locks 10000 ELF
    var userStub = GetTokenHolderContractStub(UserKeyPair);
    await userStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = ManagerAddress,
        Amount = 10000_00000000
    });
    
    // 3. Manager calls CreateScheme again with 100000000 minute lock (190 years)
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100000000
    });
    
    // 4. User tries to withdraw after waiting well beyond 1 minute
    // This should succeed based on original 1 minute lock, but fails due to overwritten scheme
    var result = await userStub.Withdraw.SendWithExceptionAsync(ManagerAddress);
    
    // Withdrawal fails with "Cannot withdraw" despite 1 minute having passed
    result.TransactionResult.Error.ShouldContain("Cannot withdraw");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L167-167)
```csharp
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L296-297)
```csharp
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L969-970)
```csharp
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L28-32)
```csharp
        State.TokenHolderContract.CreateScheme.Send(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = AEDPoSContractConstants.SideChainShareProfitsTokenSymbol,
            MinimumLockMinutes = periodSeconds.Div(60)
        });
```
