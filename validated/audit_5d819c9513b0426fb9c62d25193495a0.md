# Audit Report

## Title
NFT Collection Creation Bypass Allows Non-Zero Decimals Through Direct TokenContract Call

## Summary
The NFT contract enforces `Decimals = 0` for NFT collections, but this invariant can be bypassed by calling `TokenContract.Create` directly with NFT collection symbols (ending in "-0") and non-zero decimals. The TokenContract only validates decimals within [0, 18] for NFT collections, not that they equal zero, allowing creation of divisible "NFTs" that violate the fundamental NFT indivisibility property.

## Finding Description

The NFT contract's `Create` method correctly hardcodes `Decimals = 0` when creating NFT protocols, ensuring NFT collections are non-divisible. [1](#0-0) 

However, the `TokenContract.Create` method is publicly accessible and can be called directly by any user possessing a valid SEED NFT. The method routes token creation based on symbol patterns through `GetSymbolType`. [2](#0-1) 

The symbol type classification is purely pattern-based. Symbols ending with "-0" are classified as `SymbolType.NftCollection`. [3](#0-2) 

For NFT collections, `CreateNFTCollection` simply delegates to `CreateToken` without additional validation on decimals. [4](#0-3) 

The `CreateToken` method validates decimals only through `AssertValidCreateInput`, which permits any value between 0 and `MaxDecimals` (18). [5](#0-4) [6](#0-5) 

Only SEED NFT items (within SEED-0 collection) have explicit `Decimals == 0` validation. [7](#0-6) 

Critically, this SEED validation does NOT prevent SEED NFTs from having `OwnedSymbol` values ending in "-0" (NFT collection format), as it only checks that the owned symbol is not of type `SymbolType.Nft` (individual NFT items), allowing `SymbolType.NftCollection` to pass. [8](#0-7) 

**Attack Flow:**
1. Create SEED NFT (e.g., SEED-1) with `ExternalInfo["__seed_owned_symbol"] = "ABC-0"`
2. Call `TokenContract.Create` with `Symbol = "ABC-0"` and `Decimals = 8`
3. System classifies "ABC-0" as NFT collection via pattern matching, validates SEED NFT existence and ownership, then creates token with `Decimals = 8`
4. Result: NFT collection exists with non-zero decimals, making it divisible

The created token is stored with the specified decimals value directly from the input. [9](#0-8) 

## Impact Explanation

**Protocol Invariant Violation**: NFTs are fundamentally non-fungible and indivisible tokens. The protocol design enforces `Decimals = 0` for all NFT collections to guarantee uniqueness and prevent fractional ownership. Creating NFT collections with `Decimals > 0` breaks this core invariant, allowing fractional NFT amounts (e.g., 0.5 of an NFT with `Decimals = 8` represented as 50000000 smallest units).

**Ecosystem Confusion**: dApps, wallets, and NFT marketplaces rely on symbol patterns (symbols ending in "-0" for collections) to identify and handle NFTs. These divisible tokens will be incorrectly treated as proper NFTs, causing:
- Incorrect display/accounting in NFT galleries and marketplaces
- Failed assumptions in smart contracts expecting indivisible NFT units
- User deception when purchasing apparent NFTs that are actually divisible

**Operational Impact**: Once created, these malformed NFT collections can be issued and transferred in fractional amounts via standard token operations, violating the NFT uniqueness guarantee.

## Likelihood Explanation

**Reachable Entry Point**: `TokenContract.Create` is a public method callable by any user with a valid SEED NFT. [10](#0-9) 

**Feasible Preconditions**: 
- Attacker must acquire a SEED NFT for the target symbol via normal SEED NFT acquisition mechanisms
- No special privileges required beyond standard SEED NFT ownership
- SEED creation validation allows OwnedSymbol ending in "-0" because it only rejects `SymbolType.Nft`, not `SymbolType.NftCollection`

**Execution Steps**:
1. Acquire/create SEED NFT with `OwnedSymbol = "ABC-0"`
2. Call `TokenContract.Create(Symbol="ABC-0", Decimals=8, ...)`
3. System validates SEED NFT existence and burns it [11](#0-10) 
4. Token created with `Decimals = 8`
5. Attacker can now issue/transfer fractional amounts

## Recommendation

Add explicit validation in `CreateNFTCollection` to enforce `Decimals == 0`:

```csharp
private Empty CreateNFTCollection(CreateInput input)
{
    Assert(input.Decimals == 0, "NFT collections must have Decimals = 0.");
    return CreateToken(input, SymbolType.NftCollection);
}
```

Additionally, strengthen SEED NFT validation in `CreateNFTInfo` to reject NFT collection symbols as OwnedSymbol:

```csharp
var ownedSymbolType = GetSymbolType(ownedSymbol);
Assert(ownedSymbolType == SymbolType.Token, "OwnedSymbol must be a regular token symbol.");
```

## Proof of Concept

```csharp
[Fact]
public async Task CreateNFTCollectionWithNonZeroDecimals_ShouldFail_ButSucceeds()
{
    // Step 1: Create SEED NFT collection
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "SEED-0",
        TokenName = "SEED Collection",
        TotalSupply = 1000000,
        Decimals = 0,
        Issuer = DefaultAddress,
        Owner = DefaultAddress,
        IsBurnable = true
    });

    // Step 2: Create SEED NFT with OwnedSymbol="VULN-0" (NFT collection format)
    var seedSymbol = "SEED-1";
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = seedSymbol,
        TokenName = "Seed for VULN-0",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultAddress,
        Owner = DefaultAddress,
        IsBurnable = true,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                ["__seed_owned_symbol"] = "VULN-0",
                ["__seed_exp_time"] = (Context.CurrentBlockTime.Seconds + 86400).ToString()
            }
        }
    });

    // Step 3: Issue SEED NFT to attacker
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = seedSymbol,
        Amount = 1,
        To = DefaultAddress
    });

    // Step 4: Create NFT collection with non-zero decimals (SHOULD FAIL BUT SUCCEEDS)
    var result = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "VULN-0",
        TokenName = "Vulnerable NFT Collection",
        TotalSupply = 1000000,
        Decimals = 8, // Non-zero decimals for NFT collection!
        Issuer = DefaultAddress,
        Owner = DefaultAddress,
        IsBurnable = true
    });

    // Verify: NFT collection created with non-zero decimals
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "VULN-0" });
    tokenInfo.Decimals.ShouldBe(8); // VULNERABILITY: Should be 0 for NFT collections!
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L26-26)
```csharp
            Decimals = 0, // Fixed
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L59-65)
```csharp
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L10-13)
```csharp
    private Empty CreateNFTCollection(CreateInput input)
    {
        return CreateToken(input, SymbolType.NftCollection);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L37-52)
```csharp
        if (nftCollectionInfo.Symbol == TokenContractConstants.SeedCollectionSymbol)
        {
            Assert(input.Decimals == 0 && input.TotalSupply == 1, "SEED must be unique.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedOwnedSymbolExternalInfoKey,
                    out var ownedSymbol), "OwnedSymbol does not exist.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var expirationTime)
                   && long.TryParse(expirationTime, out var expirationTimeLong) &&
                   Context.CurrentBlockTime.Seconds <= expirationTimeLong, "Invalid ownedSymbol.");
            var ownedSymbolType = GetSymbolType(ownedSymbol);
            Assert(ownedSymbolType != SymbolType.Nft, "Invalid OwnedSymbol.");
            CheckSymbolLength(ownedSymbol, ownedSymbolType);
            CheckTokenAndCollectionExists(ownedSymbol);
            CheckSymbolSeed(ownedSymbol);
            State.SymbolSeedMap[ownedSymbol.ToUpper()] = input.Symbol;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-277)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L6-6)
```csharp
    public const int MaxDecimals = 18;
```
