# Audit Report

## Title
Secret Sharing Manipulation Through Selective Decrypted Piece Withholding

## Summary
The `RevealSharedInValues()` function incorrectly requires 100% miner participation to reveal InValues, despite Shamir's Secret Sharing only needing a 2/3 threshold. This allows any single malicious miner to selectively withhold decrypted pieces, forcing targeted miners to use deterministic fake values that manipulate consensus randomness and mining order for subsequent rounds.

## Finding Description

The vulnerability exists in a critical threshold mismatch within the secret sharing revelation logic. The `RevealSharedInValues` function calculates the correct 2/3 threshold for Shamir's Secret Sharing but then incorrectly requires 100% miner participation before attempting InValue reconstruction. [1](#0-0) 

However, the actual check on line 36 requires all miners (100%) to have provided decrypted pieces: [2](#0-1) 

While the underlying Shamir reconstruction only needs the 2/3 threshold: [3](#0-2) 

During the `UpdateValue` consensus behavior, miners provide decrypted pieces through `UpdateValueInput`. The `PerformSecretSharing` function accepts whatever decrypted pieces are provided without validating completeness: [4](#0-3) 

The validation provider only checks OutValue and PreviousInValue fields, completely ignoring DecryptedPieces: [5](#0-4) 

When InValue revelation fails due to the overly restrictive 100% requirement, miners must use a deterministic fake value based on pubkey and block height: [6](#0-5) 

This fake value directly affects signature calculation: [7](#0-6) 

The signature is computed by XORing the InValue (or fake value) with all miner signatures: [8](#0-7) 

This signature directly determines the mining order for the next round: [9](#0-8) 

**Attack Execution:**

1. The attacker's off-chain service decrypts all encrypted pieces from other miners (standard operation): [10](#0-9) 

2. The attacker calculates mining orders under two scenarios for each target miner: (A) providing the decrypted piece allows InValue revelation, or (B) withholding forces fake value usage.

3. The attacker selectively omits decrypted pieces from their `UpdateValueInput` where withholding produces more favorable mining orders.

4. Since the fake value is deterministic (based on pubkey and block height), the attacker can predict the exact impact on signatures and resulting mining order.

The evil miner detection mechanism only tracks missed time slots, not decrypted piece withholding: [11](#0-10) 

## Impact Explanation

This vulnerability directly breaks consensus randomness and miner schedule integrity guarantees:

**Consensus Manipulation:** The mining order for round N+1 is determined by signatures calculated using InValues (or fake values) from round N. By forcing specific miners to use predictable fake values instead of their actual InValues, an attacker can influence the XOR-based signature calculation and manipulate which miners receive favorable or unfavorable mining positions.

**Economic Impact:** Mining order directly affects block reward capture frequency, transaction fee collection (earlier positions typically process more transactions), and the ability to produce consecutive blocks for increased revenue.

**Protocol Invariant Violation:** The secret sharing scheme is designed to ensure that as long as 2/3 of miners participate honestly, InValues can be revealed correctly. The implementation requiring 100% participation allows any single miner (even <5% of the network) to selectively block revelations, completely bypassing the intended cryptographic threshold security property.

## Likelihood Explanation

**Attacker Capabilities:** Any single miner in the active consensus set can execute this attack with minimal modifications. The standard consensus node already decrypts all pieces off-chain, and the attack requires only filtering which decrypted pieces to include in the on-chain transaction. No special cryptographic capabilities or computational power are needed beyond normal mining operations.

**Attack Complexity:** The implementation is trivial - modify the off-chain secret sharing service to selectively filter decrypted pieces before calling `UpdateValue`, calculate expected mining orders for different withholding strategies, and submit `UpdateValueInput` with strategically omitted decrypted pieces.

**Detection Probability:** Zero. The system has no mechanism to distinguish between an honest miner who legitimately failed to decrypt due to technical issues versus a malicious miner intentionally withholding valid decryptions.

**Economic Rationality:** High incentive with zero cost. Benefits include improved mining positions that directly increase block rewards and fee capture. Costs are zero - no transaction fees, no stake slashing, and no detection risk. Every round provides new manipulation opportunities.

## Recommendation

Fix the threshold mismatch by changing the revelation check to use the cryptographically correct `minimumCount` threshold:

```csharp
// In AEDPoSContract_SecretSharing.cs, line 36
// BEFORE:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

// AFTER:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

Additionally, consider implementing validation in `UpdateValueValidationProvider` to track and penalize miners who consistently fail to provide decrypted pieces, distinguishing between legitimate technical failures and malicious withholding patterns.

## Proof of Concept

A proof of concept would involve:

1. Set up a test network with multiple miners
2. Implement a malicious miner that decrypts all pieces off-chain but selectively omits specific decrypted pieces from `UpdateValueInput`
3. Monitor the mining orders in subsequent rounds
4. Demonstrate that the attacker can consistently manipulate their position by forcing target miners to use fake values
5. Verify that no evil miner detection occurs despite the manipulation

The test would confirm that a single miner withholding even one decrypted piece causes the revelation to fail (due to the `< minersCount` check), forcing the use of deterministic fake values that alter the XOR-based signature calculation and thus mining order.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L96-96)
```csharp
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L101-101)
```csharp
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L127-135)
```csharp
            var encryptedShares =
                secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].EncryptedPieces;
            if (!encryptedShares.Any() || !encryptedShares.ContainsKey(selfPubkey)) continue;
            var interestingMessage = encryptedShares[selfPubkey];
            var senderPublicKey = ByteArrayHelper.HexStringToByteArray(pubkey);

            var decryptedPiece =
                await _accountService.DecryptMessageAsync(senderPublicKey, interestingMessage.ToByteArray());
            decryptedPieces[pubkey] = decryptedPiece;
```
