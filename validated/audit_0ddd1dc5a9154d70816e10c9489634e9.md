# Audit Report

## Title
Token Supply State Inconsistency After Burn Operations Causes Cross-Chain Transfer DoS

## Summary
The `Burn()` method in the MultiToken contract modifies the local `tokenInfo.Supply` field but fails to persist this change to `State.TokenInfos` by not calling `SetTokenInfo()`. This causes subsequent `GetTokenInfo()` calls to return stale Supply values, leading to incorrect "Total supply exceeded" failures in `CrossChainReceiveToken()` that block legitimate cross-chain token receives after any burn operations.

## Finding Description

The vulnerability exists in the `Burn()` method implementation. The method retrieves `tokenInfo` via `AssertValidToken()`, decrements the local `Supply` field, but critically never calls `SetTokenInfo()` to persist this change back to `State.TokenInfos`. [1](#0-0) 

The `AssertValidToken()` helper retrieves token information from state storage using `GetTokenInfo()`: [2](#0-1) 

The `GetTokenInfo()` method reads directly from `State.TokenInfos`, which stores serialized protobuf messages: [3](#0-2) 

Since protobuf messages in AElf smart contracts are deserialized into new object instances when read from `MappedState`, modifying the local `tokenInfo` object does not automatically persist back to state. The `SetTokenInfo()` helper must be explicitly called to serialize and store the updated object: [4](#0-3) 

The state definition explicitly warns developers about this requirement: [5](#0-4) 

This contrasts sharply with the correct implementation in `Issue()`, which properly calls `SetTokenInfo()` after modifying Supply: [6](#0-5) 

Similarly, `CrossChainReceiveToken()` correctly persists Supply updates by calling `SetTokenInfo()`: [7](#0-6) 

The critical impact occurs because `CrossChainReceiveToken()` performs a supply limit check that relies on accurate Supply data from state. After burn operations, it retrieves the stale (non-decremented) Supply value and incorrectly rejects legitimate cross-chain receives.

## Impact Explanation

**Direct Operational Impact - Cross-Chain Transfer DoS:**

After any burn operation, the `CrossChainReceiveToken()` function will incorrectly fail with "Total supply exceeded" error even when the actual circulating supply is well below the limit.

**Concrete Attack Scenario:**
1. Token has `TotalSupply = 1000`, `Supply = 1000` (all tokens issued)
2. User burns 500 tokens via `Burn()` - local supply becomes 500 but state remains 1000
3. User attempts `CrossChainReceiveToken(100)` from another chain
4. `GetTokenInfo()` returns stale `Supply = 1000` from state
5. Check evaluates: `1000 + 100 <= 1000` → **FAILS** with "Total supply exceeded"
6. Should evaluate: `500 + 100 <= 1000` → **PASSES**

**Affected Operations:**
- All cross-chain token receives after any burn operations
- `GetTokenInfo()` view method returns incorrect circulating supply
- Any external contracts or services relying on accurate Supply data

**Severity:** This is a **Medium severity** issue causing operational DoS of the cross-chain transfer functionality, a core protocol feature. While no direct fund loss occurs, it blocks legitimate user operations and disrupts cross-chain interoperability. The issue persists indefinitely until additional tokens are issued (which would accidentally sync the state via `SetTokenInfo()` in `Issue()`).

## Likelihood Explanation

**Attacker Capabilities:** Any user with burnable tokens can trigger this issue simply by calling the public `Burn()` method. No special privileges required. [8](#0-7) 

**Attack Complexity:** Trivial - just burn tokens and attempt cross-chain receive.

**Preconditions:**
- Token must have `IsBurnable = true` (common for many tokens)
- User must have token balance to burn (normal operation)
- Cross-chain functionality must be in use (core AElf feature)

**Execution Steps:**
1. Call `Burn()` with any amount
2. Attempt `CrossChainReceiveToken()`
3. Observe incorrect "Total supply exceeded" failure

**Probability:** High - affects all burnable tokens with cross-chain functionality enabled. Any production deployment with these features would encounter this bug immediately upon the first burn operation.

## Recommendation

Add a call to `SetTokenInfo(tokenInfo)` in the `Burn()` method after modifying the supply, consistent with the pattern used in `Issue()` and `CrossChainReceiveToken()`.

**Fixed Code Pattern:**
```csharp
private Empty Burn(Address address, string symbol, long amount)
{
    var tokenInfo = AssertValidToken(symbol, amount);
    Assert(tokenInfo.IsBurnable, "The token is not burnable.");
    ModifyBalance(address, symbol, -amount);
    tokenInfo.Supply = tokenInfo.Supply.Sub(amount);
    SetTokenInfo(tokenInfo);  // ADD THIS LINE

    Context.Fire(new Burned
    {
        Burner = address,
        Symbol = symbol,
        Amount = amount
    });
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task BurnWithoutPersist_BreaksCrossChainReceive()
{
    // Create and issue burnable token
    const string symbol = "TEST";
    const long totalSupply = 1000;
    
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = symbol,
        TokenName = "Test Token",
        TotalSupply = totalSupply,
        Decimals = 8,
        Issuer = DefaultAddress,
        IsBurnable = true,
        IssueChainId = Context.ChainId
    });
    
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = symbol,
        Amount = totalSupply,
        To = DefaultAddress
    });
    
    // Burn half the supply
    await TokenContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        Amount = 500
    });
    
    // Verify supply is NOT updated in state
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = symbol });
    tokenInfo.Supply.ShouldBe(totalSupply); // BUG: Still shows 1000 instead of 500
    
    // Cross-chain receive will now fail incorrectly
    // Expected: 500 + 100 <= 1000 (should pass)
    // Actual: 1000 + 100 <= 1000 (fails with "Total supply exceeded")
}
```

## Notes

This vulnerability demonstrates a critical state persistence bug in the MultiToken contract. The explicit warning comment in `TokenContractState.cs` indicates that developers are expected to use `GetTokenInfo`/`SetTokenInfo` helpers, yet the `Burn()` method violates this pattern. The bug affects token supply accounting integrity and breaks the cross-chain transfer mechanism, which is a core AElf protocol feature.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-178)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(input.To, input.Symbol, input.Amount);

        Context.Fire(new Issued
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = input.To,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L318-321)
```csharp
    public override Empty Burn(BurnInput input)
    {
        return Burn(Context.Sender, input.Symbol, input.Amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L323-337)
```csharp
    private Empty Burn(Address address, string symbol, long amount)
    {
        var tokenInfo = AssertValidToken(symbol, amount);
        Assert(tokenInfo.IsBurnable, "The token is not burnable.");
        ModifyBalance(address, symbol, -amount);
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);

        Context.Fire(new Burned
        {
            Burner = address,
            Symbol = symbol,
            Amount = amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L591-638)
```csharp
    public override Empty CrossChainReceiveToken(CrossChainReceiveTokenInput input)
    {
        var transferTransaction = Transaction.Parser.ParseFrom(input.TransferTransactionBytes);
        var transferTransactionId = transferTransaction.GetHash();

        Assert(!State.VerifiedCrossChainTransferTransaction[transferTransactionId],
            "Token already claimed.");

        var crossChainTransferInput =
            CrossChainTransferInput.Parser.ParseFrom(transferTransaction.Params.ToByteArray());
        var symbol = crossChainTransferInput.Symbol;
        var amount = crossChainTransferInput.Amount;
        var receivingAddress = crossChainTransferInput.To;
        var targetChainId = crossChainTransferInput.ToChainId;
        var transferSender = transferTransaction.From;

        var tokenInfo = AssertValidToken(symbol, amount);
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
        Assert(targetChainId == Context.ChainId, "Unable to claim cross chain token.");
        var registeredTokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        AssertCrossChainTransaction(transferTransaction, registeredTokenContractAddress,
            nameof(CrossChainTransfer));
        Context.LogDebug(() =>
            $"symbol == {tokenInfo.Symbol}, amount == {amount}, receivingAddress == {receivingAddress}, targetChainId == {targetChainId}");

        CrossChainVerify(transferTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);

        State.VerifiedCrossChainTransferTransaction[transferTransactionId] = true;
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(receivingAddress, tokenInfo.Symbol, amount);

        Context.Fire(new CrossChainReceived
        {
            From = transferSender,
            To = receivingAddress,
            Symbol = tokenInfo.Symbol,
            Amount = amount,
            Memo = crossChainTransferInput.Memo,
            FromChainId = input.FromChainId,
            ParentChainHeight = input.ParentChainHeight,
            IssueChainId = issueChainId,
            TransferTransactionId = transferTransactionId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L33-39)
```csharp
    private TokenInfo AssertValidToken(string symbol, long amount)
    {
        AssertValidSymbolAndAmount(symbol, amount);
        var tokenInfo = GetTokenInfo(symbol);
        Assert(tokenInfo != null && !string.IsNullOrEmpty(tokenInfo.Symbol), $"Token is not found. {symbol}");
        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L418-422)
```csharp
    private void SetTokenInfo(TokenInfo tokenInfo)
    {
        var symbol = tokenInfo.Symbol;
        State.TokenInfos[symbol] = tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L12-16)
```csharp
    /// <summary>
    /// WARNING: Use GetTokenInfo & SetTokenInfo to operate TokenInfos
    /// due to token symbol alias feature.
    /// </summary>
    public MappedState<string, TokenInfo> TokenInfos { get; set; }
```
