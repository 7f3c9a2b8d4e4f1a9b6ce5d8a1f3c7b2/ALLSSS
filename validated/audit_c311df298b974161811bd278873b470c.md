# Audit Report

## Title
Unbounded DelayDistributePeriodCount Enables Storage Exhaustion and Computational DoS via CachedDelayTotalShares Accumulation

## Summary
The `CreateScheme` method in the Profit contract lacks validation for `DelayDistributePeriodCount`, allowing attackers to set arbitrarily large values up to int32.MaxValue. This causes unbounded growth of `CachedDelayTotalShares` map entries during profit distribution, leading to storage exhaustion and computational denial-of-service in `RemoveBeneficiary` and `ClaimProfits` operations.

## Finding Description

The root cause is the absence of bounds validation for `DelayDistributePeriodCount` in the `CreateScheme` method. While `ProfitReceivingDuePeriodCount` is validated against a maximum of 1024 [1](#0-0) , no such validation exists for `DelayDistributePeriodCount`. The field is directly assigned from user input without any bounds checking [2](#0-1) .

**Attack Vector 1 - Unbounded Storage Accumulation:**
During `DistributeProfits`, each call adds an entry to `CachedDelayTotalShares` at key `(period + DelayDistributePeriodCount)` [3](#0-2) . These entries are only removed when that future period is reached. With `DelayDistributePeriodCount` set to a large value (e.g., 1,000,000 or int32.MaxValue), cache entries accumulate indefinitely as the removal condition won't be satisfied for millions of periods.

**Attack Vector 2 - RemoveBeneficiary Computational DoS:**
The `RemoveBeneficiary` function contains a loop that iterates from `removedMinPeriod` to `removedMinPeriod + DelayDistributePeriodCount` [4](#0-3) . If `DelayDistributePeriodCount` equals int32.MaxValue (2,147,483,647), this attempts approximately 2.1 billion iterations, causing transaction failure or extreme gas consumption.

**Attack Vector 3 - ClaimProfits Computational DoS:**
The `ClaimProfits` function iterates over all keys in `CachedDelayTotalShares` [5](#0-4) . As the cache grows with each distribution period, this iteration becomes increasingly expensive, eventually making profit claims prohibitively costly or impossible.

The protobuf definition confirms `delay_distribute_period_count` is an int32 field with no validation constraints [6](#0-5) , and no maximum constant is defined in the contract constants [7](#0-6) .

## Impact Explanation

**Operational Impact - Computational DoS:**
- `RemoveBeneficiary` becomes completely unusable when `DelayDistributePeriodCount` is set to large values. A loop attempting billions of iterations will exceed gas limits and fail, permanently preventing scheme managers from removing beneficiaries.
- `ClaimProfits` operations experience exponentially increasing costs as cached entries accumulate. After N distribution periods with a large delay, beneficiaries must iterate over N accumulated cache entries to claim profits.
- Any scheme with a large `DelayDistributePeriodCount` becomes permanently broken for beneficiary management.

**Storage Exhaustion:**
- Each `DistributeProfits` call adds one map entry to `CachedDelayTotalShares`
- After 1,000,000 periods, this accumulates substantial storage per malicious scheme
- Multiple malicious schemes can amplify storage consumption
- Blockchain state bloat increases node operation costs system-wide

**Severity Justification:** HIGH
1. Complete denial-of-service for critical profit distribution functions
2. Storage exhaustion affects the entire blockchain state
3. Attack is permanent once scheme is created (no mechanism to modify `DelayDistributePeriodCount` after creation)
4. Impacts both individual scheme operations and system-wide resources

## Likelihood Explanation

**Reachable Entry Point:**
`CreateScheme` is a public RPC method [8](#0-7)  callable by any user without authorization restrictions [9](#0-8) .

**Attacker Capabilities:**
- No special permissions required to create schemes
- Attacker becomes scheme manager upon creation, enabling all subsequent operations
- Can set `DelayDistributePeriodCount` to any int32 value (including int32.MaxValue = 2,147,483,647)
- Can call `DistributeProfits` repeatedly to accumulate cache entries

**Attack Complexity:**
- Single transaction to create malicious scheme
- Straightforward parameter manipulation (no complex state setup)
- Deterministic outcome (guaranteed DoS on affected operations)
- No race conditions or timing dependencies

**Economic Rationality:**
- Initial cost: Single transaction fee to create scheme
- Damage potential: Permanent DoS and storage exhaustion
- Cost-to-impact ratio: Extremely favorable for attacker
- No economic disincentive (attacker doesn't bear computational costs of victim transactions)

**Probability Assessment:** HIGH - Zero barriers to execution, attack is practical and economically rational, no existing protections prevent exploitation. Legitimate test cases show expected values of 0-3 [10](#0-9) , not millions.

## Recommendation

Add bounds validation for `DelayDistributePeriodCount` in the `CreateScheme` method, similar to the existing validation for `ProfitReceivingDuePeriodCount`. Add a constant to `ProfitContractConstants.cs`:

```csharp
public const int MaximumDelayDistributePeriodCount = 1024;
```

Then add validation in `CreateScheme`:

```csharp
Assert(
    input.DelayDistributePeriodCount >= 0 &&
    input.DelayDistributePeriodCount <= ProfitContractConstants.MaximumDelayDistributePeriodCount,
    "Invalid delay distribute period count.");
```

This prevents attackers from setting extreme values while allowing legitimate delay distribution use cases.

## Proof of Concept

```csharp
[Fact]
public async Task Exploit_UnboundedDelayDistributePeriodCount_DoS()
{
    var attacker = Creators[0];
    
    // Attacker creates scheme with maximum int32 DelayDistributePeriodCount
    await attacker.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true,
        ProfitReceivingDuePeriodCount = 10,
        DelayDistributePeriodCount = int.MaxValue // 2,147,483,647
    });
    
    var attackerAddress = Address.FromPublicKey(CreatorKeyPair[0].PublicKey);
    var schemeIds = (await attacker.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = attackerAddress })).SchemeIds;
    var maliciousSchemeId = schemeIds.First();
    
    // Add a beneficiary
    var victim = Address.FromPublicKey(CreatorKeyPair[1].PublicKey);
    await attacker.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = maliciousSchemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = victim, Shares = 100 },
        EndPeriod = 100
    });
    
    // Try to remove beneficiary - will attempt 2.1 billion iterations and fail
    var removeResult = await attacker.RemoveBeneficiary.SendWithExceptionAsync(
        new RemoveBeneficiaryInput
        {
            SchemeId = maliciousSchemeId,
            Beneficiary = victim
        });
    
    // Transaction should fail or consume excessive gas due to unbounded loop
    removeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L44-84)
```csharp
    public override Hash CreateScheme(CreateSchemeInput input)
    {
        ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);

        if (input.ProfitReceivingDuePeriodCount == 0)
            input.ProfitReceivingDuePeriodCount = ProfitContractConstants.DefaultProfitReceivingDuePeriodCount;
        else
            Assert(
                input.ProfitReceivingDuePeriodCount > 0 &&
                input.ProfitReceivingDuePeriodCount <= ProfitContractConstants.MaximumProfitReceivingDuePeriodCount,
                "Invalid profit receiving due period count.");

        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;

        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;

        Context.LogDebug(() => $"Created scheme {State.SchemeInfos[schemeId]}");

        Context.Fire(new SchemeCreated
        {
            SchemeId = scheme.SchemeId,
            Manager = scheme.Manager,
            IsReleaseAllBalanceEveryTimeByDefault = scheme.IsReleaseAllBalanceEveryTimeByDefault,
            ProfitReceivingDuePeriodCount = scheme.ProfitReceivingDuePeriodCount,
            VirtualAddress = scheme.VirtualAddress
        });
        return schemeId;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L247-249)
```csharp
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L793-797)
```csharp
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L949-949)
```csharp
            DelayDistributePeriodCount = input.DelayDistributePeriodCount,
```

**File:** protobuf/profit_contract.proto (L19-20)
```text
    rpc CreateScheme (CreateSchemeInput) returns (aelf.Hash) {
    }
```

**File:** protobuf/profit_contract.proto (L126-126)
```text
    int32 delay_distribute_period_count = 3;
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L1-10)
```csharp
namespace AElf.Contracts.Profit;

public class ProfitContractConstants
{
    public const int ProfitReceivingLimitForEachTime = 10;
    public const int DefaultProfitReceivingDuePeriodCount = 10;
    public const int MaximumProfitReceivingDuePeriodCount = 1024;
    public const int TokenAmountLimit = 5;
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
}
```

**File:** test/AElf.Contracts.Profit.Tests/BVT/SchemeTests.cs (L66-76)
```csharp
        const int delayDistributePeriodCount = 3;
        const int contributeAmountEachTime = 100_000;
        var creator = Creators[0];
        var creatorAddress = Address.FromPublicKey(CreatorKeyPair[0].PublicKey);

        await creator.CreateScheme.SendAsync(new CreateSchemeInput
        {
            IsReleaseAllBalanceEveryTimeByDefault = true,
            ProfitReceivingDuePeriodCount = 100,
            DelayDistributePeriodCount = delayDistributePeriodCount
        });
```
