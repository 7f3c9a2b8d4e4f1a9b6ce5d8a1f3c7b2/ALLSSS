# Audit Report

## Title
Incomplete Auto-Distribution Logic Causes Profit Misallocation Across Multiple Token Types

## Summary
The `RegisterForProfits()` method in the TokenHolder contract contains a premature `break` statement that exits the auto-distribution loop after processing only the first qualifying token. This causes tokens contributed in the same timeframe to be distributed across different periods with different beneficiary sets, resulting in unfair profit allocation where early registrants receive disproportionately higher rewards than later participants with equal stakes.

## Finding Description

The auto-distribution logic in `RegisterForProfits()` iterates through all tokens configured in `AutoDistributeThreshold`, but terminates prematurely after finding the first token that meets its threshold. [1](#0-0) 

The problematic flow occurs when:

1. A beneficiary is added with `StartPeriod` set to the scheme's current period [2](#0-1) 

2. The auto-distribution check runs, but only the FIRST qualifying token gets added to `distributedInput.AmountsMap` before the loop breaks

3. `DistributeProfits()` processes only tokens present in the input's `AmountsMap` [3](#0-2) 

4. The period increments after distribution [4](#0-3) 

5. Remaining qualifying tokens stay in the general ledger until the next registration event triggers their distribution to a different period with a different beneficiary set

This breaks the core invariant that beneficiaries with equal shares should receive proportionally equal rewards from tokens contributed in the same timeframe.

## Impact Explanation

**Direct Fund Impact - Reward Misallocation:**

Consider this concrete scenario:
- Scheme created with `AutoDistributeThreshold = {ELF: 1000, JUN: 1000}`
- Both ELF (1000) and JUN (1000) are contributed to the general ledger in Period 1
- User A registers with 100 shares:
  - Added as beneficiary for Period 1
  - Auto-distribution triggers: only ELF is distributed to Period 1 (loop breaks after first match)
  - Period increments to 2
  - JUN remains in general ledger
- User B registers with 100 shares:
  - Added as beneficiary for Period 2 (cannot claim Period 1 profits)
  - Auto-distribution triggers: JUN is distributed to Period 2
  - Period increments to 3

**Financial Result:**
- User A claims: 100% of ELF (sole beneficiary in Period 1) + 50% of JUN (100/200 shares in Period 2)
- User B claims: 0% of ELF (not eligible for Period 1) + 50% of JUN (100/200 shares in Period 2)

Despite making equal 100-share contributions, User A receives significantly more value due to timing rather than merit. This violates the fundamental fairness guarantee of proportional profit distribution.

**Affected Parties:** All TokenHolder schemes using multi-token auto-distribution, which is a common pattern for dividend-paying DApps handling multiple reward tokens.

## Likelihood Explanation

**Occurrence Probability:** HIGH

The vulnerability triggers deterministically whenever:
1. A scheme configures multiple tokens in `AutoDistributeThreshold` (common for multi-reward systems)
2. Multiple tokens simultaneously meet their respective thresholds (realistic when contributions arrive in batches)
3. Users register sequentially (normal operation)

**Attack Complexity:** TRIVIAL
- No special permissions required - `RegisterForProfits()` is a public method
- Attacker simply monitors when multiple thresholds are met
- First registration captures exclusive access to the first token's period
- Later registrants are automatically disadvantaged

**Detection Difficulty:** The vulnerability manifests as normal contract behavior. Victims only discover the misallocation when claiming profits and comparing actual vs. expected rewards.

## Recommendation

Remove the `break` statement at line 199 in `TokenHolderContract.cs` to allow the loop to process ALL qualifying tokens:

```csharp
foreach (var threshold in scheme.AutoDistributeThreshold)
{
    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
    {
        Owner = virtualAddress,
        Symbol = threshold.Key
    }).Balance;
    if (balance < threshold.Value) continue;
    if (distributedInput == null)
        distributedInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
    distributedInput.AmountsMap[threshold.Key] = 0;
    // REMOVE: break;  <-- This line should be deleted
}
```

This ensures all tokens meeting their thresholds are distributed atomically in the same period to the same beneficiary set, preserving fairness.

## Proof of Concept

```csharp
[Fact]
public async Task MultiToken_AutoDistribute_Unfairness_POC()
{
    // Setup: Create scheme with multiple auto-distribute thresholds
    var nativeTokenSymbol = "ELF";
    var secondToken = "JUN";
    await StarterCreateIssueAndApproveTokenAsync(secondToken, 1000000L, 100000L);
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = nativeTokenSymbol,
        AutoDistributeThreshold =
        {
            { nativeTokenSymbol, 1000 },
            { secondToken, 1000 }
        }
    });
    
    // Contribute BOTH tokens to general ledger
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Amount = 1000,
        Symbol = nativeTokenSymbol
    });
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Amount = 1000,
        Symbol = secondToken
    });
    
    // User A registers first (100 shares)
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = 100,
        SchemeManager = Starter
    });
    
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
    {
        Manager = Starter
    });
    var schemeId = schemeIds.SchemeIds.First();
    
    // Verify period advanced to 2 (auto-distribution occurred)
    var schemeAfterFirstReg = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    schemeAfterFirstReg.Period.ShouldBe(2);
    
    // User B registers with equal shares (100 shares)
    var userBStub = GetTokenHolderContractStub(UserBKeyPair);
    await userBStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = 100,
        SchemeManager = Starter
    });
    
    // Period should now be 3
    var schemeAfterSecondReg = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    schemeAfterSecondReg.Period.ShouldBe(3);
    
    // User A can claim from BOTH periods (1 and 2)
    var profitMapA = await ProfitContractStub.GetProfitsMap.CallAsync(new Profit.ClaimProfitsInput
    {
        Beneficiary = Starter,
        SchemeId = schemeId
    });
    
    // User B can only claim from period 2 onwards
    var profitMapB = await ProfitContractStub.GetProfitsMap.CallAsync(new Profit.ClaimProfitsInput
    {
        Beneficiary = UserB,
        SchemeId = schemeId
    });
    
    // BUG DEMONSTRATED: User A gets more rewards despite equal shares
    // User A should get: 100% ELF (period 1) + 50% JUN (period 2)
    // User B should get: 0% ELF + 50% JUN (period 2)
    // This is UNFAIR - both contributed 100 shares but User A gets all ELF
    profitMapA.Value.Count.ShouldBe(2); // Both tokens claimable
    profitMapB.Value.Count.ShouldBeLessThan(2); // Missing first token
}
```

This test demonstrates that when two users register with equal shares but at different times, the first user gains exclusive access to the first token's profits while both share the second token's profits, creating an unfair advantage based solely on registration timing.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L184-199)
```csharp
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L203-205)
```csharp
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L433-445)
```csharp
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
```
