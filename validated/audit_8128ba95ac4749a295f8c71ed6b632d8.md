# Audit Report

## Title
Critical Miner List Manipulation Vulnerability in NextRound Validation Allows Consensus Takeover

## Summary
The `NextRound` transaction processing lacks validation to ensure that the proposed miner list matches or is derived from the current round's miner list. Any active miner can submit a `NextRound` transaction with an arbitrary set of miners, completely bypassing consensus integrity protections and taking control of the blockchain.

## Finding Description

The AEDPoS consensus contract's `NextRound` method accepts a `NextRoundInput` parameter containing the next round's information, including the miner list. The validation pipeline checks multiple properties of the proposed round but critically **never validates that the miner list is consistent with the current round**. [1](#0-0) 

The `ValidationForNextRound` method only validates: (1) round number increments by 1, and (2) all `InValue` fields are null. It does not compare `extraData.Round.RealTimeMinersInformation` against `validationContext.BaseRound.RealTimeMinersInformation`.

**Why Other Validators Don't Protect:**

`MiningPermissionValidationProvider` only checks that the transaction sender is in the **current** round, not whether the proposed next round's miners are valid: [2](#0-1) 

`NextRoundMiningOrderValidationProvider` validates internal consistency but not miner list origin: [3](#0-2) 

For a freshly crafted next round with `FinalOrderOfNextRound=0` and `OutValue=null`, this check passes as `0 == 0`.

The validation pipeline applies these providers for NextRound behavior: [4](#0-3) 

After validation passes, `ProcessNextRound` directly stores the malicious round: [5](#0-4) 

The `AddRoundInformation` method stores the round without validation: [6](#0-5) 

**Contrast with Legitimate Behavior:**

The legitimate `GenerateNextRoundInformation` method derives miners exclusively from the current round: [7](#0-6) 

However, attackers bypass this by directly calling the public `NextRound` method with arbitrary data: [8](#0-7) 

The `ToRound()` conversion simply transfers all fields including the arbitrary miner list: [9](#0-8) 

## Impact Explanation

Once the malicious round is stored in `State.Rounds[roundNumber]` and the round number is updated, the arbitrary miner list becomes the active consensus authority. This results in:

- **Complete Consensus Takeover**: The attacker replaces all legitimate miners with arbitrary public keys (including non-validated entities)
- **Permanent Control**: The malicious miners control all future round transitions, perpetuating their control
- **Governance Bypass**: The Election Contract and voting mechanisms become irrelevant as consensus is decoupled from elections
- **Chain Integrity Compromise**: Attackers control block production, enabling censorship and transaction manipulation

The impact is **CRITICAL** because:
- 100% of legitimate miners can be displaced in a single transaction
- The malicious round becomes the authoritative source for all future mining permission validation
- The blockchain becomes effectively centralized under attacker control
- Legitimate miners lose all rewards and token holders' votes are nullified

## Likelihood Explanation

**Attack Requirements:**
- Attacker must be a valid miner in the current round (verified by `MiningPermissionValidationProvider`)
- No special privileges beyond current miner status needed

**Attack Complexity:** **LOW**
The attacker crafts a `NextRoundInput` with:
- `RoundNumber = currentRound.RoundNumber + 1` (passes validation)
- `RealTimeMinersInformation` with arbitrary miners and proper structure (passes time slot validation)
- All `InValue`, `OutValue`, `FinalOrderOfNextRound` set to null/0 (passes InValue and mining order validation)

**Feasibility:** **HIGH**
- Trigger opportunity: During the attacker's designated time slot
- Economic barrier: Only normal transaction fees
- Detection: None - the transaction passes all validation checks

The likelihood is **HIGH** because any of the current miners (typically 17-21 on mainnet) can execute this attack immediately during their time slot, and it's undetectable by on-chain validation.

## Recommendation

Add miner list consistency validation in `RoundTerminateValidationProvider.ValidationForNextRound`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing validations
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
        
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Validate miner list consistency
    var currentMiners = validationContext.BaseRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    var nextMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    
    if (currentMiners.Count != nextMiners.Count || 
        !currentMiners.SequenceEqual(nextMiners))
    {
        return new ValidationResult { Message = "Next round miner list must match current round miner list." };
    }
    
    return new ValidationResult { Success = true };
}
```

Alternatively, remove the ability to directly specify `RealTimeMinersInformation` in `NextRoundInput` and always derive it from the current round server-side.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMinerListInNextRound_ShouldFail_ButDoesNot()
{
    // Setup: Initialize chain with legitimate miners
    var legitimateMiners = GenerateMiners(3);
    await InitializeConsensusWithMiners(legitimateMiners);
    
    // Attacker is one of the legitimate miners
    var attackerKeyPair = legitimateMiners[0];
    
    // Craft malicious NextRoundInput with arbitrary miner list
    var maliciousMiners = GenerateMiners(3); // Completely different miners
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = CurrentRoundNumber + 1,
        RealTimeMinersInformation = { 
            // Arbitrary miners - not from current round!
            maliciousMiners.ToDictionary(
                m => m.PublicKey.ToHex(),
                m => new MinerInRound { Pubkey = m.PublicKey.ToHex(), Order = 1 }
            )
        },
        RandomNumber = GenerateRandomNumber(attackerKeyPair)
    };
    
    // Execute attack
    var result = await ConsensusStub.NextRound.SendAsync(maliciousNextRound);
    
    // EXPECTED: Transaction should fail due to invalid miner list
    // ACTUAL: Transaction succeeds and malicious miners take over consensus
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed); // This assertion FAILS
    
    // Verify the attack succeeded
    var newRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    newRound.RealTimeMinersInformation.Keys.ShouldNotContain(legitimateMiners[1].PublicKey.ToHex());
    newRound.RealTimeMinersInformation.Keys.ShouldContain(maliciousMiners[0].PublicKey.ToHex());
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```
