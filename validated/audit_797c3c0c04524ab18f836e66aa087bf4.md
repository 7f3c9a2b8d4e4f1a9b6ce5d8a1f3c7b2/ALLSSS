# Audit Report

## Title
Secret Sharing Data Loss During NextRound Transitions Due to Unpersisted State Modifications

## Summary
The `RevealSharedInValues` function modifies `currentRound` in-memory to reveal miners' previous in values through secret sharing decryption, but these modifications are never persisted to contract state during NextRound transitions. This causes systematic data loss on every round change, breaking the secret sharing mechanism designed for consensus randomness generation and preventing recovery of missed miners' in values.

## Finding Description

The vulnerability exists in the NextRound consensus flow where secret sharing revelations are computed but systematically lost:

**The Core Issue:**

During off-chain block generation for NextRound behavior, `GetConsensusExtraDataForNextRound` first generates the next round object, then calls `RevealSharedInValues` to decrypt and reveal miners' previous in values from the prior round. However, these revelations are written to the `currentRound` object that is subsequently discarded, while only the `nextRound` object (generated before the revelations) is persisted to state. [1](#0-0) [2](#0-1) [3](#0-2) 

The `RevealSharedInValues` function reconstructs miners' in values from decrypted secret pieces and stores them in the `PreviousInValue` field of the current round's miner information: [4](#0-3) 

However, `GenerateNextRoundInformation` creates entirely new `MinerInRound` objects without copying the `PreviousInValue` field, meaning any modifications to `currentRound` after nextRound generation cannot propagate: [5](#0-4) [6](#0-5) 

When the NextRound transaction executes on-chain, only the new round is persisted: [7](#0-6) [8](#0-7) 

Later, when `SupplyCurrentRoundInformation` attempts to recover missing miner data, it reads a fresh round from state and tries to use the `PreviousInValue` fields that were never persisted: [9](#0-8) [10](#0-9) 

The code comments confirm that `PreviousInValue` is intended to contain "previous in value recovered by other miners" through secret sharing, but since these values are lost, the system falls back to less secure alternatives or fake values: [11](#0-10) 

## Impact Explanation

**HIGH Severity - Consensus Integrity Compromise**

This vulnerability systematically breaks a core consensus security mechanism on every round transition:

1. **Secret Sharing Mechanism Failure**: The entire purpose of Shamir's Secret Sharing in AEDPoS is to allow miners to collectively reveal each other's in values even when some miners fail to participate. With revelations lost on every NextRound, this security mechanism becomes non-functional.

2. **Randomness Degradation**: Consensus randomness generation depends on proper in value chains where each miner's `PreviousInValue` hashes to their previous round's `OutValue`. Lost revelations break this chain, forcing the system to use fallback mechanisms that compromise randomness quality.

3. **Failed Miner Recovery**: When miners miss their time slots, `SupplyCurrentRoundInformation` cannot recover their correct previous in values through secret sharing. Instead, it must use potentially stale values from previous rounds or generate fake values, which the code comments indicate "shall only use once during one term" as an abnormal situation.

4. **Security Guarantee Violation**: While blocks continue to be produced (no liveness failure), the cryptographic security guarantees provided by secret sharing are violated, degrading the overall consensus security posture.

## Likelihood Explanation

**CERTAIN - Automatic Execution on Every Round Transition**

This vulnerability has the highest possible likelihood:

1. **Automatic Trigger**: No attacker action is required. The bug executes automatically during normal consensus operation whenever a NextRound transition occurs.

2. **High Frequency**: Round transitions occur regularly (typically every few minutes based on the mining interval configuration), meaning this data loss happens hundreds of times per day across the network.

3. **Universal Impact**: Every miner in the network is affected equally, as the secret sharing revelations are meant to help all miners collectively maintain consensus integrity.

4. **No Detection**: The bug appears as normal operation since blocks continue to be produced. There are no error messages or failed transactions to indicate the security mechanism is broken.

5. **100% Reproducibility**: This occurs with certainty on every single NextRound transition under all network conditions.

## Recommendation

**Fix Approach 1: Persist currentRound modifications before returning nextRound**

Modify `GetConsensusExtraDataForNextRound` to persist the revealed in values to the current round before generating the next round transaction:

```csharp
private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
    string pubkey, AElfConsensusTriggerInformation triggerInformation)
{
    GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

    nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

    if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };

    RevealSharedInValues(currentRound, pubkey);
    
    // Persist the revealed values to currentRound before transitioning
    TryToUpdateRoundInformation(currentRound);

    nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
    // ... rest of method
}
```

**Fix Approach 2: Apply revelations to nextRound instead of currentRound**

Modify `RevealSharedInValues` to accept and modify the nextRound object, ensuring revelations are stored in the object that will be persisted:

```csharp
// Change signature to accept nextRound as parameter
private void RevealSharedInValues(Round nextRound, string publicKey)
{
    // ... existing logic but modify nextRound instead of currentRound
    nextRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
}

// In GetConsensusExtraDataForNextRound, call it after generating nextRound:
GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
RevealSharedInValues(nextRound, pubkey); // Apply to nextRound
```

**Fix Approach 3: Copy PreviousInValue during round generation**

Modify `GenerateNextRoundInformation` to preserve `PreviousInValue` fields when creating new `MinerInRound` objects, though this requires calling `RevealSharedInValues` before generation.

## Proof of Concept

This vulnerability requires examining the actual consensus flow in a live or test network. A proof of concept would demonstrate:

1. Enable secret sharing in the consensus configuration
2. Run multiple rounds with miners sharing encrypted pieces
3. Trigger a NextRound transition
4. Verify via debug logs or state queries that `RevealSharedInValues` was called during block generation
5. Query the persisted round state to confirm `PreviousInValue` fields are empty/null
6. Observe that when miners miss slots in subsequent rounds, `SupplyCurrentRoundInformation` cannot use revealed values and falls back to fake value generation

The vulnerability can be verified by adding logging at the key points:
- After `RevealSharedInValues` modifies currentRound (log the PreviousInValue fields)
- In `ProcessNextRound` before `AddRoundInformation` (confirm only nextRound is persisted)
- In `SupplyCurrentRoundInformation` (confirm PreviousInValue fields are null when read from state)

This demonstrates the systematic data loss on every round transition, confirming the vulnerability's presence and impact.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-176)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L198-203)
```csharp
        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L52-52)
```csharp
            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L46-55)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L105-105)
```csharp
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L173-173)
```csharp
        var currentRound = GetCurrentRoundInformation(new Empty());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-210)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }
```
