# Audit Report

## Title
Off-By-One Error in Continuous Block Production Limit Allows Miners to Exceed Maximum Consecutive Blocks

## Summary
The AEDPoS consensus contract contains an off-by-one error in the continuous block production limit validation. The check uses `BlocksCount < 0` instead of `BlocksCount <= 0`, allowing miners to produce 9 consecutive blocks instead of the intended maximum of 8, providing a 12.5% unfair advantage in block production and mining rewards.

## Finding Description

The vulnerability exists in the validation logic that enforces the maximum number of continuous blocks a miner can produce. The protocol defines `MaximumTinyBlocksCount = 8` [1](#0-0) , which is documented as a mechanism "to avoid too many forks" [2](#0-1)  and "to prevent one miner produced too many continuous blocks" [3](#0-2) .

**Flawed Validation Check:**
The validation provider only rejects when `BlocksCount < 0`, allowing `BlocksCount == 0` to pass [4](#0-3) .

**Flawed Command Generation:**
Similarly, the consensus command generation only forces `NextRound` behavior when `BlocksCount < 0` [5](#0-4) .

**Root Cause Mechanism:**
When a miner produces their first block, `BlocksCount` is initialized to `MaximumTinyBlocksCount - 1 = 7` [6](#0-5) . For each subsequent consecutive block by the same miner, `BlocksCount` is decremented by 1 [7](#0-6) .

**Execution Sequence:**
1. Block 1: Initialize `BlocksCount = 7`
2. Blocks 2-8: `BlocksCount` decrements from 7→6→5→4→3→2→1, all checks pass (not < 0)
3. **Block 9: `BlocksCount = 0`, check `0 < 0` is FALSE, validation PASSES (BUG)**
4. After Block 9: `BlocksCount` decrements to -1
5. Block 10: `BlocksCount = -1`, check `-1 < 0` is TRUE, validation FAILS

The validation occurs before block execution [8](#0-7) , confirming the timing of these checks.

## Impact Explanation

**Consensus Integrity Violation:**
This breaks the core protocol invariant that limits consecutive block production to 8 blocks. The limit is explicitly designed to prevent blockchain centralization and excessive fork creation.

**Unfair Competitive Advantage:**
Any miner can produce 9 consecutive blocks instead of 8, representing a 12.5% excess over the intended limit. This provides:
- Additional mining reward for the 9th block
- Greater influence over consensus compared to compliant miners
- Cumulative advantage as this occurs repeatedly

**Reward Misallocation:**
The extra block production translates directly to extra block rewards, creating systematic unfairness in the reward distribution mechanism that accumulates over time.

**Severity Assessment: Medium**
While this does not enable direct fund theft or complete consensus takeover, it provides measurable unfair advantage in block production power and mining rewards, and violates a documented security invariant.

## Likelihood Explanation

**Automatic Triggering:**
This vulnerability triggers automatically during normal consensus operations - no special actions required beyond producing consecutive blocks.

**Universal Access:**
Any valid miner in the consensus pool can reach this code path. The preconditions are:
- Miner must be in current consensus round (standard for all miners)
- No special permissions or governance actions required

**Deterministic Exploitation:**
The bug occurs deterministically whenever any miner produces maximum consecutive blocks. The flawed check always allows the 9th block when `BlocksCount = 0`.

**Zero Detection Risk:**
The 9th block appears as legitimate according to the validation logic. No monitoring exists to flag this behavior as anomalous.

**Probability Assessment: High**
This will occur naturally in normal operation whenever miners produce consecutive blocks up to the limit.

## Recommendation

Change both validation checks from `BlocksCount < 0` to `BlocksCount <= 0`:

**Fix Location 1 - Validation Provider:**
```csharp
// File: ContinuousBlocksValidationProvider.cs, line 19
if (latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
    latestPubkeyToTinyBlocksCount.BlocksCount <= 0)  // Changed from < 0
```

**Fix Location 2 - Command Generation:**
```csharp
// File: AEDPoSContract_ACS4_ConsensusInformationProvider.cs, line 33
if (currentRound.RealTimeMinersInformation.Count != 1 &&
    currentRound.RoundNumber > 2 &&
    State.LatestPubkeyToTinyBlocksCount.Value != null &&
    State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
    State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount <= 0)  // Changed from < 0
```

This ensures that when `BlocksCount` reaches 0 (meaning no remaining blocks allowed), the validation fails and forces the miner to start a new round.

## Proof of Concept

```csharp
[Fact]
public async Task OffByOne_MinerCanProduce9ConsecutiveBlocks()
{
    // Setup: Initialize consensus with MaximumTinyBlocksCount = 8
    // Expected: Miner should only produce 8 consecutive blocks
    // Actual: Due to BlocksCount < 0 check, miner can produce 9 blocks
    
    // Simulate miner producing consecutive blocks
    // Block 1: BlocksCount initialized to 7
    // Blocks 2-8: BlocksCount decrements 7→6→5→4→3→2→1, all pass validation
    // Block 9: BlocksCount = 0, check "0 < 0" is FALSE, validation PASSES (BUG)
    // Block 10: BlocksCount = -1, check "-1 < 0" is TRUE, validation FAILS
    
    // Verify that block 9 was successfully produced
    // This proves miner exceeded the MaximumTinyBlocksCount = 8 limit
}
```

## Notes

This vulnerability is confirmed through direct code analysis of the AEDPoS consensus contract. The off-by-one error exists in production code and affects the core consensus mechanism's ability to enforce maximum consecutive block limits. The fix is straightforward (change `< 0` to `<= 0` in both locations), but the impact is real as it allows systematic circumvention of a documented protocol invariant designed to maintain consensus fairness and prevent centralization.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L17-19)
```csharp
    /// <summary>
    ///     Implemented GitHub PR #1952.
    ///     Adjust (mainly reduce) the count of tiny blocks produced by a miner each time to avoid too many forks.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L333-334)
```csharp
    /// <summary>
    ///     To prevent one miner produced too many continuous blocks.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L345-345)
```csharp
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L356-356)
```csharp
                    BlocksCount = currentValue.BlocksCount.Sub(1)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L19-19)
```csharp
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L33-33)
```csharp
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L12-12)
```csharp
    ///     This method will be executed before executing a block.
```
