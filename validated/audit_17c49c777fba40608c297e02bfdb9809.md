# Audit Report

## Title
Unvalidated Secret Reconstruction in RevealSharedInValues Allows Consensus State Corruption

## Summary
The `RevealSharedInValues()` function reconstructs miners' InValues from DecryptedPieces using Shamir's Secret Sharing without validating that the reconstructed secret matches the original OutValue hash. A malicious miner can provide corrupted DecryptedPieces that cause incorrect PreviousInValue storage, leading to consensus state corruption when these values are used to generate miner signatures.

## Finding Description

The AEDPoS consensus mechanism uses Shamir's Secret Sharing to reveal miners' previous InValues. However, the reconstruction process lacks critical validation, allowing consensus state corruption.

**Attack Flow:**

1. **Unvalidated DecryptedPieces Storage**: When miners submit UpdateValue transactions, their DecryptedPieces are added directly to other miners' state without validation. [1](#0-0) 

2. **Secret Reconstruction Without Verification**: The `RevealSharedInValues` function reconstructs InValues using `SecretSharingHelper.DecodeSecret` and stores the result without validating it against the original OutValue. [2](#0-1) 

3. **Lagrange Interpolation Properties**: The `DecodeSecret` implementation always succeeds and returns a result, even with corrupted input shares, with no error detection mechanism. [3](#0-2) 

4. **Insufficient Validation Coverage**: The `UpdateValueValidationProvider` only validates the sender's own PreviousInValue against their own previous OutValue, not the revealed values of other miners populated by secret sharing. [4](#0-3) 

5. **Corrupted Value Usage in Consensus**: The unvalidated PreviousInValue is used in `SupplyCurrentRoundInformation` to auto-fill InValue and calculate signatures for miners who failed to produce blocks. [5](#0-4) 

6. **Signature Calculation Impact**: The signature calculation XORs the corrupted PreviousInValue with existing signatures, propagating the corruption through the consensus mechanism. [6](#0-5) 

**Security Guarantee Violated**: The system assumes revealed InValues are correct because they were reconstructed from threshold shares, but Shamir's Secret Sharing has no built-in verification. If any share among the threshold shares (2/3 minimum) is corrupted, the entire reconstruction produces incorrect output silently. [7](#0-6) 

## Impact Explanation

**Critical Consensus State Corruption**: The corrupted PreviousInValue directly affects signature calculations used for:
- Determining mining order through XOR operations
- Maintaining the cryptographic chain of consensus values
- Auto-filling consensus data for non-producing miners

**Affected Parties**:
- All miners in the consensus set
- The entire consensus mechanism's integrity
- Miners who fail to produce blocks have their InValue/Signature fields auto-filled using corrupted data

**Severity Justification**: This is Critical severity because:
1. It directly violates consensus integrity requirements - a core invariant
2. It compromises the verifiable randomness property of AEDPoS
3. It can cause consensus state divergence between honest and malicious nodes
4. The corrupted signatures propagate through subsequent rounds

## Likelihood Explanation

**Attacker Capabilities Required**:
- Must be a miner in the current consensus round (normal consensus participant)
- Can submit UpdateValue transactions (standard miner privilege)
- No additional elevated permissions required

**Attack Complexity**: Low
- Attacker provides arbitrary byte arrays as DecryptedPieces values
- No sophisticated cryptographic attack needed
- The attack is deterministic - corrupted shares always produce corrupted reconstruction

**Feasibility**: High
- Shamir's Secret Sharing reconstruction uses threshold shares (2/3 of miners)
- If the attacker's corrupted DecryptedPiece is among the shares used for reconstruction, the entire secret reconstruction fails
- No error correction capability exists in the scheme
- `DecodeSecret` succeeds silently without indicating corruption

**Detection Difficulty**: High
- No validation failure occurs during reconstruction
- The incorrect PreviousInValue is stored normally
- Corruption only manifests as unexpected signature mismatches in subsequent consensus operations

## Recommendation

Add validation in `RevealSharedInValues` to verify that the reconstructed secret matches the expected OutValue before storing it:

```csharp
var reconstructedSecret = SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount);
var revealedInValue = HashHelper.ComputeFrom(reconstructedSecret);

// Validate against the original OutValue
if (revealedInValue != anotherMinerInPreviousRound.OutValue)
{
    Context.LogDebug(() => $"Invalid secret reconstruction for {publicKeyOfAnotherMiner}");
    continue; // Skip storing corrupted value
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

This ensures that only correctly reconstructed secrets that hash to the original OutValue are stored as PreviousInValue, preventing consensus state corruption from malicious or corrupted shares.

## Proof of Concept

A malicious miner can exploit this vulnerability by:

1. During their UpdateValue transaction, providing arbitrary bytes as DecryptedPieces for target miners
2. When `RevealSharedInValues` is called during round transition, it reconstructs secrets using these corrupted pieces
3. If the malicious miner's piece is among the threshold shares used, the reconstruction produces an incorrect value
4. This incorrect value is stored as PreviousInValue without validation
5. When the target miner fails to produce a block, `SupplyCurrentRoundInformation` uses this corrupted value to calculate their signature
6. The corrupted signature affects subsequent consensus operations through XOR-based calculations

The attack succeeds because there is no validation step comparing the reconstructed value against the original OutValue commitment from the previous round.

## Notes

The vulnerability exists at the intersection of cryptographic secret sharing and consensus state management. While Shamir's Secret Sharing is mathematically sound for reconstruction with honest shares, it provides no inherent verification mechanism. The system must validate reconstructed secrets against committed values (OutValue hashes) to detect corruption. The current implementation trusts that reconstruction is correct without verification, violating the "trust but verify" principle essential for consensus integrity.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
