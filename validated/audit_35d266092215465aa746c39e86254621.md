# Audit Report

## Title
Off-By-One Error Allows Miner to Produce 9 Continuous Blocks Instead of Intended 8-Block Limit

## Summary

An off-by-one error in the AEDPoS consensus contract allows any miner to produce 9 continuous blocks instead of the intended maximum of 8 blocks. The flaw exists in both the block production authorization logic and validation logic, where the condition checks `BlocksCount < 0` instead of `BlocksCount <= 0`, combined with initialization that sets `BlocksCount = MaximumTinyBlocksCount - 1`.

## Finding Description

The AEDPoS consensus mechanism enforces a limit on continuous block production to prevent monopolization. The intended maximum is 8 blocks as defined by the constant. [1](#0-0) 

However, the enforcement logic contains an off-by-one error across multiple components:

**1. GetConsensusCommand Authorization Check**

The method checks whether a miner has exceeded the limit before allowing block production. [2](#0-1) 

This check only forces NextRound when `BlocksCount < 0`, meaning it allows production when `BlocksCount == 0`.

**2. Counter Initialization**

When a miner produces their first block, the counter is initialized. [3](#0-2) 

The initialization sets `BlocksCount = MaximumTinyBlocksCount - 1 = 7`, and for subsequent blocks by the same miner, the counter decrements. [4](#0-3) 

**3. Validation Logic**

The validation provider uses the same flawed condition. [5](#0-4) 

**Block Production Sequence:**
- **Block 1**: `BlocksCount` is `null`, authorization check passes (null doesn't match condition), after execution `BlocksCount = 7`
- **Blocks 2-8**: `BlocksCount` goes from 7 → 6 → 5 → 4 → 3 → 2 → 1, each passing the `< 0` check
- **Block 9**: When `BlocksCount = 0`, the check `0 < 0` is false, allowing production. After this block, `BlocksCount = -1`
- **Block 10**: Would be rejected as `-1 < 0` is true

**Total blocks produced: 9 blocks instead of 8**

The authorization check reads the pre-execution state, allowing the 9th block when the pre-execution state shows `BlocksCount = 0`.

## Impact Explanation

**Consensus Fairness Violation:**
- Each miner can monopolize block production for 12.5% longer than intended (9/8 = 1.125)
- The miner captures an additional block's worth of transaction fees
- Other miners lose one time slot opportunity per round
- Transaction finalization for non-producing miners is delayed by one block time

**Systemic Impact:**
- This is not a targeted exploit but a systematic flaw affecting all rounds
- All miners benefit equally when it's their turn, but it concentrates rewards unfairly
- Violates the consensus mechanism's intended fairness guarantees
- Reduces decentralization by allowing longer monopolization periods

**Severity Assessment: Medium**
- Violates a critical consensus invariant (maximum continuous blocks limit)
- Provides measurable unfair advantage (12.5% extra production time)
- No fund loss or critical DoS, but breaks fairness guarantees
- Affects consensus integrity and decentralization principles

## Likelihood Explanation

**Probability: HIGH**

This vulnerability triggers automatically during normal consensus operation:

**Attacker Capabilities:**
- Any active miner in the consensus round can trigger this
- No special permissions, governance control, or transaction manipulation required
- Happens automatically through the normal block production flow

**Preconditions:**
- Miner must be in the current round's miner list (standard consensus participation)
- Miner must have their allocated time slot (normal consensus flow)
- No additional setup or attack infrastructure needed

**Trigger Mechanism:**
- Occurs every time any miner produces their maximum continuous blocks
- Not an "active exploit" but a design flaw in the limit enforcement
- Happens systematically across all rounds for all miners

The high likelihood is due to this being an automatic protocol behavior rather than requiring attacker action. Every miner producing maximum blocks will produce 9 instead of 8.

## Recommendation

**Fix Option 1: Change the condition check**
Modify the authorization and validation checks from `BlocksCount < 0` to `BlocksCount <= 0`:

In `AEDPoSContract_ACS4_ConsensusInformationProvider.cs` line 33 and `ContinuousBlocksValidationProvider.cs` line 19, change:
```csharp
State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0
```
to:
```csharp
State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount <= 0
```

**Fix Option 2: Adjust initialization**
Modify the initialization to start at `MaximumTinyBlocksCount` instead of `MaximumTinyBlocksCount - 1`:

In `AEDPoSContract_ProcessConsensusInformation.cs` line 345 and line 362, change:
```csharp
BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
```
to:
```csharp
BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount
```

**Recommended approach**: Fix Option 1 is cleaner as it properly checks when the limit is reached rather than adjusting the counter initialization.

## Proof of Concept

The PoC demonstrates the off-by-one error by simulating block production:

```csharp
[Fact]
public async Task OffByOne_MinerProduces9BlocksInsteadOf8()
{
    // Initialize consensus with MaximumTinyBlocksCount = 8
    const int expectedMaxBlocks = 8;
    
    // Simulate miner producing blocks
    int blocksProduced = 0;
    int? blocksCount = null; // Initial state
    
    // Block 1: null state allows production
    if (!(blocksCount < 0)) // null doesn't match < 0
    {
        blocksProduced++;
        blocksCount = expectedMaxBlocks - 1; // = 7
    }
    
    // Blocks 2-9: Continue while BlocksCount >= 0
    while (!(blocksCount < 0)) // Check is < 0, not <= 0
    {
        blocksProduced++;
        blocksCount--;
    }
    
    // Verify the bug: 9 blocks produced instead of 8
    Assert.Equal(9, blocksProduced); // BUG: Should be 8
    Assert.Equal(-1, blocksCount); // Final state
}
```

This test proves that with the current logic (`< 0` check and initialization at `MaximumTinyBlocksCount - 1`), miners can produce 9 blocks instead of the intended 8-block limit.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L339-347)
```csharp
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-357)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```
