# Audit Report

## Title
Solitary Miner Detection Logic Error Causes False Positive and Potential Chain Halt

## Summary
The `SolitaryMinerDetection()` function contains a logic error that incorrectly treats the absence of miners at the start of a new round as evidence of solitary mining. This false positive can block the only operational miner after a network partition, potentially causing a complete consensus halt.

## Finding Description

The vulnerability exists in the solitary miner detection mechanism that prevents a single miner from continuing to mine alone. The `SolitaryMinerDetection()` function is invoked when a miner requests a consensus command. [1](#0-0) 

The root cause is a logic error where the function checks if the current round has zero miners and treats this as evidence of solitary mining. [2](#0-1) 

The `GetMinedMiners()` method returns only miners where `SupposedOrderOfNextRound != 0`. [3](#0-2) 

When a new round is created via `GenerateNextRoundInformation()`, new `MinerInRound` objects are instantiated without explicitly setting the `SupposedOrderOfNextRound` field. [4](#0-3) [5](#0-4) 

Since `SupposedOrderOfNextRound` is defined as `int32` in the protobuf definition, it defaults to 0. [6](#0-5) 

The field is only set when a miner produces a block through `ProcessUpdateValue()`. [7](#0-6) 

**Why the bug occurs:** The logic error treats "no one has mined yet in current round" (count == 0) identically to "only this miner is mining" (solitary mining). At the start of any new round, before any miner produces a block, `GetMinedMiners()` will always return an empty list because all `SupposedOrderOfNextRound` values are still at their default of 0. The subsequent checks correctly validate that only this specific miner mined in the previous 2 rounds, but this doesn't confirm the miner is currently mining alone—it only confirms past behavior during a network partition period.

## Impact Explanation

**Harm:** Complete consensus halt (DoS) preventing any block production.

**Scenario:**
- During rounds N-2 and N-1, a network partition or infrastructure issues cause only MinerA to successfully produce blocks
- Round N begins and `GenerateNextRoundInformation()` creates a new round with all `SupposedOrderOfNextRound` values at 0
- MinerA (the only miner that has been operational) attempts to produce the first block in round N by calling the public `GetConsensusCommand()` method [8](#0-7) 
- `SolitaryMinerDetection()` returns true, causing `GetConsensusCommand` to return `InvalidConsensusCommand` and blocking MinerA from mining
- If network issues persist and other miners remain offline/partitioned, no miner can produce blocks
- Chain halts completely until manual intervention or network recovery

**Who is affected:** The entire blockchain network—all users, dApps, and validators lose access to a functioning chain.

**Severity justification:** HIGH - This is an operational DoS vulnerability affecting consensus integrity. While it requires specific preconditions (network partition lasting 2+ rounds), such conditions are realistic in distributed systems and the impact is catastrophic (complete chain halt).

## Likelihood Explanation

**Attacker capabilities:** No malicious attacker required—this triggers through natural network conditions.

**Preconditions:**
- Multi-miner network with more than 2 miners [9](#0-8) 
- After round 3 (checked at the same location)
- Network partition or miner downtime affecting all but one miner for 2 consecutive rounds
- The working miner continues to be the only operational miner into the next round

**Execution practicality:** The vulnerability triggers automatically through the normal consensus flow. When a miner requests a consensus command via the public `GetConsensusCommand()` method, the solitary detection runs before any block is produced in the new round.

**Feasibility conditions:** Network partitions, infrastructure failures, and miner downtime are common occurrences in distributed blockchain systems. The probability is MEDIUM—not frequent but realistic enough to warrant serious concern.

## Recommendation

Fix the logic at line 75 to properly detect solitary mining. The check should verify whether no OTHER miners have participated, not whether NO miners have participated yet. 

**Recommended fix:**

Replace the current logic that checks for zero miners with a check that examines whether only this specific miner has mined:

```csharp
var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
// Check if no other miners have mined (either count is 0 OR count is 1 and it's only this miner)
var otherMiners = minedMinersOfCurrentRound.Where(m => m.Pubkey != pubkey).ToList();
isAlone = otherMiners.Count == 0 && minedMinersOfCurrentRound.Count > 0;
```

Alternatively, skip checking the current round entirely and only check the previous 2 rounds, since the intent (per the comment) is to detect if the miner "mined blocks only himself for 2 rounds" (referring to past rounds).

## Proof of Concept

A valid test would:
1. Set up a network with 3+ miners after round 3
2. Simulate a network partition where only MinerA mines for 2 consecutive rounds
3. Trigger a round transition to create a new round (round N)
4. Have MinerA call `GetConsensusCommand` before any blocks are produced in round N
5. Verify that `SolitaryMinerDetection` returns true (false positive)
6. Verify that `GetConsensusCommand` returns `InvalidConsensusCommand`
7. Demonstrate that MinerA cannot produce blocks, leading to consensus halt if the partition persists

The test would validate that the false positive occurs specifically because `GetMinedMiners()` returns an empty list at the start of the new round, not because MinerA is actually mining alone at that moment.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L23-24)
```csharp
        if (SolitaryMinerDetection(currentRound, pubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L70-70)
```csharp
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L74-75)
```csharp
            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L46-55)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** protobuf/aedpos_contract.proto (L288-288)
```text
    int32 supposed_order_of_next_round = 11;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-21)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;
```
