# Audit Report

## Title
Vote Counting Inconsistency Enables Governance Manipulation via Member Removal After Voting

## Summary
The Association contract contains a critical vote counting inconsistency where approval/rejection/abstention counts are filtered by current organization members, but the total vote threshold check counts all votes including those from removed members. This allows a majority coalition to manipulate governance by removing dissenting voters after they vote, converting legitimately rejected proposals into passable ones.

## Finding Description

The vulnerability exists in the vote counting logic in `Association_Helper.cs`. The `CheckEnoughVoteAndApprovals` function filters approval counts by current membership [1](#0-0) , while the total vote participation count concatenates all vote lists WITHOUT filtering by current membership [2](#0-1) . Similarly, `IsProposalRejected` [3](#0-2)  and `IsProposalAbstained` [4](#0-3)  both filter their respective vote counts by current members only.

When members are removed via `RemoveMember` [5](#0-4) , the removal does NOT clean up or invalidate existing proposal votes. The removed member's address remains in the proposal's vote lists (added via `Approve` [6](#0-5) , `Reject` [7](#0-6) , or `Abstain` methods), but is no longer in `organization.OrganizationMemberList`.

When checking `IsReleaseThresholdReached` [8](#0-7)  for release, removed members' votes do NOT count toward approval/rejection/abstention thresholds (filtered out) but STILL count toward the MinimalVoteThreshold (not filtered).

**Attack Execution:**
1. Organization has 10 members with MinimalApprovalThreshold=5, MinimalVoteThreshold=8, MaximalRejectionThreshold=2
2. Proposal A receives: 5 approvals, 3 rejections, 1 abstention (9 total votes)
3. Status: REJECTED because 3 rejections > MaximalRejectionThreshold of 2
4. Majority coalition passes a separate proposal to remove 2 of the 3 rejecting members
5. Organization now has 8 members
6. Proposal A recheck: only 1 rejection (filtered to current members) ≤ 2 threshold → passes rejection check
7. Total votes: still 9 (including removed members' votes) ≥ MinimalVoteThreshold of 8 → passes vote threshold
8. Proposal A is NOW PASSABLE and can be released, executing previously rejected actions

## Impact Explanation

This vulnerability breaks the fundamental governance invariant that proposal outcomes must reflect the consensus of current members at release time. The asymmetric filtering creates an exploitable inconsistency enabling:

- **Retroactive Outcome Manipulation**: A majority coalition can change proposal outcomes after voting has concluded by selectively removing dissenting voters
- **Minority Suppression**: Enables systematic disenfranchisement of opposition members to force through contentious proposals
- **Unauthorized Proposal Execution**: Proposals that were legitimately rejected can be made passable, executing actions that did not have proper member approval

All Association-based organizations are vulnerable. Since Association contracts can control critical protocol operations (treasury management, parameter updates, contract upgrades), this enables unauthorized execution of high-impact governance decisions.

## Likelihood Explanation

**Attacker Profile:** Requires a majority coalition within the organization to control enough votes to pass member removal proposals and coordinate the attack sequence.

**Feasibility:** MEDIUM-HIGH
- All operations are legitimate governance actions accessible via public methods
- Requires coordination between two sequential proposals (removal, then release)
- Must execute within proposal expiration timeframes
- The organization configuration must have thresholds that remain valid after removal (checked by `Validate` [9](#0-8) )
- Majority control requirement is realistic in contentious governance scenarios where a slim majority wants to override strong minority opposition

**Detection:** The attack pattern (member removal followed by release of previously rejected proposal) is detectable on-chain but the individual operations appear legitimate.

## Recommendation

Modify the vote counting logic to be consistent. Either:

**Option 1 (Recommended):** Filter total votes by current membership to match the filtering applied to approvals/rejections/abstentions:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    var totalCurrentMemberVotes = proposal.Abstentions
        .Concat(proposal.Approvals)
        .Concat(proposal.Rejections)
        .Count(organization.OrganizationMemberList.Contains); // Add filtering here
    var isVoteThresholdReached =
        totalCurrentMemberVotes >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

**Option 2:** Remove votes from proposals when members are removed:

```csharp
public override Empty RemoveMember(Address input)
{
    var organization = State.Organizations[Context.Sender];
    Assert(organization != null, "Organization not found.");
    var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
    Assert(removeResult, "Remove member failed.");
    
    // Clean up votes from all active proposals (requires tracking proposal IDs)
    // More complex implementation needed
    
    Assert(Validate(organization), "Invalid organization.");
    State.Organizations[Context.Sender] = organization;
    Context.Fire(new MemberRemoved
    {
        OrganizationAddress = Context.Sender,
        Member = input
    });
    return new Empty();
}
```

Option 1 is simpler and more secure as it ensures vote counting always reflects current membership status.

## Proof of Concept

The following test demonstrates the vulnerability:

```csharp
[Fact]
public async Task VoteCountingInconsistency_MemberRemoval_Test()
{
    // Setup organization with 10 members, MinimalApprovalThreshold=5, 
    // MinimalVoteThreshold=8, MaximalRejectionThreshold=2
    var members = new[] { Reviewer1, Reviewer2, Reviewer3, DefaultSender, 
                         Accounts[4].Address, Accounts[5].Address, 
                         Accounts[6].Address, Accounts[7].Address,
                         Accounts[8].Address, Accounts[9].Address };
    
    var organizationAddress = await CreateOrganizationAsync(
        minimalApproveThreshold: 5,
        minimalVoteThreshold: 8,
        maximalAbstentionThreshold: 1,
        maximalRejectionThreshold: 2,
        proposer: Reviewer1,
        members: members);
    
    // Create proposal A
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // Voting: 5 approvals, 3 rejections, 1 abstention (9 total)
    await ApproveAsync(Accounts[0].KeyPair, proposalId);
    await ApproveAsync(Accounts[1].KeyPair, proposalId);
    await ApproveAsync(Accounts[2].KeyPair, proposalId);
    await ApproveAsync(Accounts[3].KeyPair, proposalId);
    await ApproveAsync(Accounts[4].KeyPair, proposalId);
    await RejectAsync(Accounts[5].KeyPair, proposalId);
    await RejectAsync(Accounts[6].KeyPair, proposalId);
    await RejectAsync(Accounts[7].KeyPair, proposalId);
    await AbstainAsync(Accounts[8].KeyPair, proposalId);
    
    // Check: Should be REJECTED (3 rejections > 2)
    var proposal1 = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal1.ToBeReleased.ShouldBeFalse(); // Correctly rejected
    
    // Remove 2 rejecting members via governance (requires organization to call itself)
    var removeStub = GetAssociationContractTester(organizationAddress);
    await removeStub.RemoveMember.SendAsync(Accounts[6].Address);
    await removeStub.RemoveMember.SendAsync(Accounts[7].Address);
    
    // Check again: NOW PASSABLE (1 rejection ≤ 2, but 9 votes still counted)
    var proposal2 = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal2.ToBeReleased.ShouldBeTrue(); // VULNERABILITY: Should still be rejected!
}
```

This test proves that a rejected proposal becomes passable after removing dissenting voters, demonstrating the governance manipulation enabled by the vote counting inconsistency.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L42-43)
```csharp
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L143-161)
```csharp
    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Rejections.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Reject),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
