# Audit Report

## Title
Missing Authorization Check in SetPrimaryTokenSymbol Allows Unauthorized Primary Token Configuration

## Summary
The `SetPrimaryTokenSymbol` function in the MultiToken contract lacks authorization validation, allowing any user to set the chain's primary token symbol if it remains uninitialized. This critical configuration controls transaction fee calculations and can be exploited to cause chain-wide denial of service or fee system manipulation.

## Finding Description

The `SetPrimaryTokenSymbol` function only validates that (1) the primary token hasn't been set yet, and (2) the provided symbol corresponds to an existing token, without verifying the caller's authority. [1](#0-0) 

This represents a critical inconsistency with other administrative functions in the same contract. Methods like `AddAddressToCreateTokenWhiteList` [2](#0-1) , `RemoveAddressFromCreateTokenWhiteList` [3](#0-2) , and `SetTokenIssuerAndOwnerModificationEnabled` [4](#0-3)  all properly implement authorization using `AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress)`.

The authorization helper method `AssertSenderAddressWith` validates that `Context.Sender` equals the required address, throwing an assertion error if unauthorized. [5](#0-4) 

The primary token symbol is intended to be set during genesis initialization: on the main chain by the Economic contract [6](#0-5) , or on side chains by TokenContractInitializationProvider. [7](#0-6) 

However, the initialization provider returns an empty method list if `initializationData` is null, leaving the primary token unset with no initialization calls. [8](#0-7) 

## Impact Explanation

The primary token symbol directly controls transaction size fee calculations. The fee charging logic uses `State.ChainPrimaryTokenSymbol.Value` to determine which token to charge for transaction size fees. [9](#0-8) 

Critically, if `State.ChainPrimaryTokenSymbol.Value` is null, the fee charging functions return success without charging any fees. [10](#0-9) [11](#0-10) 

An attacker who sets an arbitrary token as the primary token could:
1. **Break the fee system entirely**: Set a non-existent or zero-balance token, causing all transaction fee charges to fail and effectively halting the chain
2. **Enable fee manipulation**: Set a token they control to manipulate fee calculations and economic incentives
3. **Cause chain-wide DoS**: Make it impossible for legitimate users to pay transaction fees in the expected token

The impact severity is **CRITICAL** as it affects the entire chain's operability, economic model, and ability to process transactions.

## Likelihood Explanation

The exploit requires that `ChainPrimaryTokenSymbol` remains unset after chain initialization, which could occur if:
1. A side chain is deployed with null initialization configuration (initializationData is null)
2. Genesis initialization fails or is interrupted before SetPrimaryTokenSymbol is called
3. The Economic contract initialization fails on the main chain
4. A test or development deployment skips proper initialization procedures

While production deployments should follow proper initialization sequences, the code provides no enforcement mechanism or authorization guard. The absence of an authorization check violates defensive programming principlesâ€”even if "proper configuration" is expected, critical functions must validate caller authority.

The attack complexity is **LOW**: once the precondition exists (unset primary token), an attacker needs only to call SetPrimaryTokenSymbol with any valid token symbol. The attack cost is minimal (one transaction), and while detection would be immediate, remediation could be impossible since the function can only be called once.

## Recommendation

Add proper authorization to the `SetPrimaryTokenSymbol` function to ensure only the Parliament controller or authorized system contracts can set this critical configuration:

```csharp
public override Empty SetPrimaryTokenSymbol(SetPrimaryTokenSymbolInput input)
{
    AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
    Assert(State.ChainPrimaryTokenSymbol.Value == null, "Failed to set primary token symbol.");
    Assert(!string.IsNullOrWhiteSpace(input.Symbol) && GetTokenInfo(input.Symbol) != null, "Invalid input symbol.");

    State.ChainPrimaryTokenSymbol.Value = input.Symbol;
    Context.Fire(new ChainPrimaryTokenSymbolSet { TokenSymbol = input.Symbol });
    return new Empty();
}
```

Alternatively, restrict the function to be callable only by system contracts (Economic contract or Genesis contract) during the initialization phase:

```csharp
public override Empty SetPrimaryTokenSymbol(SetPrimaryTokenSymbolInput input)
{
    var economicContract = Context.GetContractAddressByName(SmartContractConstants.EconomicContractSystemName);
    var genesisContract = Context.GetZeroSmartContractAddress();
    Assert(Context.Sender == economicContract || Context.Sender == genesisContract, 
           "Only system contracts can set primary token symbol.");
    Assert(State.ChainPrimaryTokenSymbol.Value == null, "Failed to set primary token symbol.");
    Assert(!string.IsNullOrWhiteSpace(input.Symbol) && GetTokenInfo(input.Symbol) != null, "Invalid input symbol.");

    State.ChainPrimaryTokenSymbol.Value = input.Symbol;
    Context.Fire(new ChainPrimaryTokenSymbolSet { TokenSymbol = input.Symbol });
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task SetPrimaryTokenSymbol_MissingAuthorization_Vulnerability()
{
    // Scenario: Chain initialized but primary token not set (simulating initialization failure)
    // Any attacker can now set the primary token to an arbitrary token
    
    // Create a token that the attacker controls
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "ATTACK",
        TokenName = "Attacker Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultSender,
        IsBurnable = true,
        Owner = DefaultSender
    });
    
    // Attacker (any user) successfully sets their token as the primary token
    // This should fail with authorization check but currently succeeds
    var result = await TokenContractStub.SetPrimaryTokenSymbol.SendAsync(
        new SetPrimaryTokenSymbolInput { Symbol = "ATTACK" });
    
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify the attacker's token is now the primary token
    var primaryToken = await TokenContractStub.GetPrimaryTokenSymbol.CallAsync(new Empty());
    primaryToken.Value.ShouldBe("ATTACK");
    
    // This breaks the fee system as fees will now be charged in ATTACK token
    // which users don't have, effectively causing DoS
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L139-147)
```csharp
    public override Empty SetPrimaryTokenSymbol(SetPrimaryTokenSymbolInput input)
    {
        Assert(State.ChainPrimaryTokenSymbol.Value == null, "Failed to set primary token symbol.");
        Assert(!string.IsNullOrWhiteSpace(input.Symbol) && GetTokenInfo(input.Symbol) != null, "Invalid input symbol.");

        State.ChainPrimaryTokenSymbol.Value = input.Symbol;
        Context.Fire(new ChainPrimaryTokenSymbolSet { TokenSymbol = input.Symbol });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L462-467)
```csharp
    public override Empty AddAddressToCreateTokenWhiteList(Address input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        State.CreateTokenWhiteListMap[input] = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L469-474)
```csharp
    public override Empty RemoveAddressFromCreateTokenWhiteList(Address input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        State.CreateTokenWhiteListMap.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L661-669)
```csharp
    public override Empty SetTokenIssuerAndOwnerModificationEnabled(SetTokenIssuerAndOwnerModificationEnabledInput input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        Assert(input != null, "Invalid input.");

        State.TokenIssuerAndOwnerModificationDisabled.Value = !input.Enabled;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L111-114)
```csharp
    private void AssertSenderAddressWith(Address address)
    {
        Assert(Context.Sender == address, "Unauthorized behavior.");
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L66-67)
```csharp
        State.TokenContract.SetPrimaryTokenSymbol.Send(new SetPrimaryTokenSymbolInput
            { Symbol = input.NativeTokenSymbol });
```

**File:** src/AElf.Kernel.Token/TokenContractInitializationProvider.cs (L24-129)
```csharp
    public virtual List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        var methodList = new List<ContractInitializationMethodCall>();
        var initializationData = _tokenContractInitializationDataProvider.GetContractInitializationData();

        // For the main chain, we use the economic contract to initialize the token contract.
        // So no initialization methods are required in here.
        // But for the side chain, which has no economic contract, we need initialize token contract.
        if (initializationData != null)
        {
            var nativeTokenInfo = TokenInfo.Parser.ParseFrom(initializationData.NativeTokenInfoData);
            var resourceTokenList =
                TokenInfoList.Parser.ParseFrom(initializationData.ResourceTokenListData);

            // native token
            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.Create),
                Params = GenerateTokenCreateInput(nativeTokenInfo).ToByteString()
            });

            // resource token
            foreach (var resourceTokenInfo in resourceTokenList.Value)
                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.Create),
                    Params = GenerateTokenCreateInput(resourceTokenInfo).ToByteString()
                });

            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.InitialCoefficients),
                Params = new Empty().ToByteString()
            });

            if (initializationData.PrimaryTokenInfoData != null)
            {
                // primary token
                var chainPrimaryTokenInfo =
                    TokenInfo.Parser.ParseFrom(initializationData.PrimaryTokenInfoData);

                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.Create),
                    Params = GenerateTokenCreateInput(chainPrimaryTokenInfo, initializationData.Creator)
                        .ToByteString()
                });

                foreach (var issueStuff in initializationData.TokenInitialIssueList)
                    methodList.Add(new ContractInitializationMethodCall
                    {
                        MethodName = nameof(TokenContractContainer.TokenContractStub.Issue),
                        Params = new IssueInput
                        {
                            Symbol = chainPrimaryTokenInfo.Symbol,
                            Amount = issueStuff.Amount,
                            Memo = "Initial issue",
                            To = issueStuff.Address
                        }.ToByteString()
                    });

                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.SetPrimaryTokenSymbol),
                    Params = new SetPrimaryTokenSymbolInput
                    {
                        Symbol = chainPrimaryTokenInfo.Symbol
                    }.ToByteString()
                });
            }
            else
            {
                // set primary token with native token 
                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.SetPrimaryTokenSymbol),
                    Params = new SetPrimaryTokenSymbolInput
                    {
                        Symbol = nativeTokenInfo.Symbol
                    }.ToByteString()
                });
            }

            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.InitializeFromParentChain),
                Params = new InitializeFromParentChainInput
                {
                    ResourceAmount = { initializationData.ResourceAmount },
                    RegisteredOtherTokenContractAddresses =
                    {
                        initializationData.RegisteredOtherTokenContractAddresses
                    },
                    Creator = initializationData.Creator
                }.ToByteString()
            });

            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.InitializeAuthorizedController),
                Params = ByteString.Empty
            });
        }

        return methodList;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L29-32)
```csharp
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L59-62)
```csharp
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L385-385)
```csharp
        var symbolToPayTxFee = State.ChainPrimaryTokenSymbol.Value;
```
