# Audit Report

## Title
Continuous Blocks Limit Bypass via RoundNumber Manipulation in UpdateValue/TinyBlock Behaviors

## Summary
A malicious miner can bypass the continuous blocks limit by manipulating the `RoundNumber` field in consensus extra data to values ≤ 2, allowing unlimited consecutive block production and consensus monopolization.

## Finding Description

The AEDPoS consensus mechanism enforces a maximum continuous blocks limit to ensure fair block production distribution among miners. However, a critical validation gap allows this protection to be completely bypassed.

**The Attack Chain:**

**Gap 1: Unvalidated RoundNumber in Simplified Rounds**

When generating consensus extra data for UpdateValue and TinyBlock behaviors, the `GetUpdateValueRound` and `GetTinyBlockRound` methods create simplified round objects that directly copy the `RoundNumber` field from the current round without any cryptographic commitment or validation: [1](#0-0) [2](#0-1) 

These simplified rounds are then included in the block header consensus extra data: [3](#0-2) [4](#0-3) 

**Gap 2: Missing RoundNumber Validation for UpdateValue/TinyBlock**

For NextRound and NextTerm behaviors, the `RoundTerminateValidationProvider` explicitly validates that the provided RoundNumber is correct: [5](#0-4) 

However, for UpdateValue and TinyBlock behaviors, no such validation provider exists. The validation pipeline only includes basic providers and `UpdateValueValidationProvider`, which does NOT check RoundNumber: [6](#0-5) [7](#0-6) 

**Gap 3: Bypassable Continuous Blocks Check**

The `ContinuousBlocksValidationProvider` is intended to prevent excessive consecutive block production. However, it uses the **unvalidated** `ProvidedRound.RoundNumber` from the consensus extra data to decide whether to enforce the limit: [8](#0-7) 

The check on line 13 skips validation if `ProvidedRound.RoundNumber <= 2`. Since `ProvidedRound` returns `ExtraData.Round`, which contains the attacker-controlled value, an attacker can set RoundNumber to 1 or 2 to bypass this protection: [9](#0-8) 

**Why After-Execution Validation Doesn't Catch This:**

The `ValidateConsensusAfterExecution` method attempts to verify consensus data integrity by comparing hashes. However, it first calls `RecoverFromUpdateValue` or `RecoverFromTinyBlock`, which **replace** the provided round with the current round from state: [10](#0-9) [11](#0-10) 

After recovery, `headerInformation.Round` points to `currentRound` (with the correct RoundNumber), so both sides of the GetHash comparison use the same round object, causing validation to pass even though the original block header contained a manipulated RoundNumber.

**Attack Execution:**

1. Attacker (a legitimate miner) calls `GetConsensusExtraData` to generate consensus header information
2. Before signing the block, attacker modifies `Round.RoundNumber` in the consensus extra data to 1 or 2
3. Block passes `ValidateBeforeExecution` because `ContinuousBlocksValidationProvider` skips its check
4. Block is executed and the continuous blocks counter is updated: [12](#0-11) 

5. Block passes `ValidateAfterExecution` because the recovery methods replace the manipulated round
6. Attacker repeats indefinitely, bypassing the maximum blocks limit: [13](#0-12) 

The only validation on block header consensus data is that `SenderPubkey` matches `SignerPubkey`, which doesn't prevent RoundNumber manipulation: [14](#0-13) 

## Impact Explanation

This vulnerability represents a **critical consensus integrity compromise** that completely undermines the fairness guarantees of the AEDPoS consensus mechanism:

1. **Consensus Monopolization**: The attacker bypasses the `MaximumTinyBlocksCount` limit (8 blocks) and produces unlimited consecutive blocks, gaining 100% control of block production instead of their fair share (1/N where N = number of miners).

2. **Miner Starvation**: Other legitimate miners are prevented from producing blocks as the attacker continuously holds the block production slot.

3. **Censorship Power**: With complete control over block production, the attacker can censor transactions, manipulate transaction ordering for MEV extraction, or exclude specific addresses.

4. **Decentralization Failure**: The fundamental property of distributed consensus—that no single party can control the chain—is violated.

The continuous blocks limit exists specifically to prevent a single miner from monopolizing consensus. By bypassing this protection, an attacker breaks the core security assumption of the consensus mechanism.

## Likelihood Explanation

**High Likelihood - Trivially Exploitable**

**Minimal Prerequisites:**
- Attacker must be in the current miner list (achievable through normal staking/election process)
- No special privileges or compromised keys required

**Attack Simplicity:**
- Requires only modifying a single integer field (`RoundNumber`) in the consensus extra data
- No complex cryptographic manipulation needed
- No state setup or precise timing requirements beyond normal mining

**Economic Incentive:**
- Attack cost: Negligible (just a field modification in block header)
- Attack benefit: Complete control of consensus, MEV extraction opportunities, censorship capability
- Risk/reward ratio strongly favors the attacker

**Detection Difficulty:**
- The manipulation is in the block header, not in state
- State round information remains correct, making detection non-trivial
- The attack appears as normal UpdateValue/TinyBlock behavior to monitoring systems

## Recommendation

Add a validation provider for UpdateValue and TinyBlock behaviors that explicitly checks the provided RoundNumber matches the current round number:

```csharp
public class RoundNumberValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        
        // Validate that the provided round number matches the current round for UpdateValue/TinyBlock
        if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.UpdateValue ||
            validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
        {
            if (validationContext.ProvidedRound.RoundNumber != validationContext.BaseRound.RoundNumber)
            {
                validationResult.Message = $"Incorrect round number. Expected: {validationContext.BaseRound.RoundNumber}, Got: {validationContext.ProvidedRound.RoundNumber}";
                return validationResult;
            }
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Add this provider to the validation pipeline in `ValidateBeforeExecution` for UpdateValue and TinyBlock behaviors, similar to how `RoundTerminateValidationProvider` is added for NextRound/NextTerm.

## Proof of Concept

```csharp
[Fact]
public async Task RoundNumberManipulation_BypassesContinuousBlocksLimit()
{
    // Setup: Attacker is a legitimate miner in round 10
    var currentRound = new Round { RoundNumber = 10, /* ... */ };
    
    // Attacker calls GetConsensusExtraData for UpdateValue behavior
    var consensusExtraData = await GetConsensusExtraDataAsync(attackerPubkey, AElfConsensusBehaviour.UpdateValue);
    var headerInfo = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);
    
    // Attacker manipulates RoundNumber to bypass continuous blocks check
    headerInfo.Round.RoundNumber = 1; // Set to <= 2 to bypass line 13 check
    
    // Produce block with manipulated consensus data
    var block = await ProduceBlockAsync(headerInfo);
    
    // Validation should fail but currently passes
    var beforeValidation = await ValidateConsensusBeforeExecutionAsync(block);
    Assert.True(beforeValidation.Success); // Currently passes! (Vulnerability)
    
    // Block is executed
    await ExecuteBlockAsync(block);
    
    // After-execution validation also passes
    var afterValidation = await ValidateConsensusAfterExecutionAsync(block);
    Assert.True(afterValidation.Success); // Passes due to recovery replacing round
    
    // Attacker repeats to exceed MaximumTinyBlocksCount (8)
    for (int i = 0; i < 10; i++) 
    {
        headerInfo = AElfConsensusHeaderInformation.Parser.ParseFrom(await GetConsensusExtraDataAsync(attackerPubkey, AElfConsensusBehaviour.TinyBlock));
        headerInfo.Round.RoundNumber = 2;
        block = await ProduceBlockAsync(headerInfo);
        Assert.True((await ValidateConsensusBeforeExecutionAsync(block)).Success);
        await ExecuteBlockAsync(block);
    }
    
    // Attacker has now produced > 8 consecutive blocks, bypassing the limit
    var producedBlocks = State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount;
    Assert.True(producedBlocks < -8); // Negative indicates excessive production
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-16)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L58-64)
```csharp
    public Round GetTinyBlockRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L28-32)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L155-170)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForTinyBlock(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = currentRound.GetTinyBlockRound(pubkey),
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-92)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L8-28)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-102)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L333-365)
```csharp
    /// <summary>
    ///     To prevent one miner produced too many continuous blocks.
    /// </summary>
    /// <param name="minersCountInTheory"></param>
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L21-33)
```csharp
    public ByteString ExtractConsensusExtraData(BlockHeader header)
    {
        var consensusExtraData =
            _blockExtraDataService.GetExtraDataFromBlockHeader(_consensusExtraDataProvider.BlockHeaderExtraDataKey,
                header);
        if (consensusExtraData == null)
            return null;

        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
    }
```
