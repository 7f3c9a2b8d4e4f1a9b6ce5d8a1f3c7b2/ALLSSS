# Audit Report

## Title
Authorization Bypass in Contract Update Proposals via Context.Self Author Field

## Summary
The `AssertAuthorityByContractInfo` function contains a critical authorization logic flaw that allows any user to propose updates to contracts whose author field is set to the Genesis contract address (`Context.Self`). This affects all contracts deployed by non-whitelisted proposers, completely bypassing the intended restriction that only contract authors can propose updates.

## Finding Description

The vulnerability exists in the authorization check performed during contract update proposals. When `ProposeUpdateContract` is called, it invokes `AssertAuthorityByContractInfo` to verify the caller has permission. [1](#0-0) 

The authorization check is implemented as follows: [2](#0-1) 

**Root Cause:**

The condition checks `contractInfo.Author == Context.Self` (whether the stored author field equals Genesis) rather than `Context.Sender == Context.Self` (whether the caller is Genesis). When a contract has `Author = Context.Self` as its stored state value, the first part of the OR condition is ALWAYS true regardless of who is calling the function, bypassing all authorization.

**The intended logic should be:**
- `Context.Sender == Context.Self` (caller IS Genesis) OR `Context.Sender == contractInfo.Author` (caller IS author)

**But the actual logic is:**
- `contractInfo.Author == Context.Self` (author FIELD is Genesis) OR `Context.Sender == contractInfo.Author` (caller IS author)

**How Contracts Get Author=Context.Self:**

During contract deployment, the author is determined by `DecideNonSystemContractAuthor`: [3](#0-2) 

When the proposer is not in the deployment whitelist, this function returns `Context.Self`, causing the contract's author to be set to the Genesis contract address.

The deployment process that sets this author occurs at: [4](#0-3) 

**Comparison with Intended Behavior:**

The system correctly rejects unauthorized update proposals for contracts with normal authors, as demonstrated in test scenarios: [5](#0-4) 

However, this protection fails for contracts with `Author=Context.Self` because the authorization check validates the stored author field value instead of the caller's identity.

Test evidence shows contracts can be deployed with `author = BasicContractZeroAddress` (Context.Self): [6](#0-5) 

## Impact Explanation

**Authorization Bypass:**
Any user can call `ProposeUpdateContract` on contracts with `Author=Context.Self`, completely bypassing the intended author-only restriction. While governance must still approve the actual update, the proposal stage represents a critical authorization boundary that is completely broken.

**Affected Contracts:**
All contracts deployed when proposers were not in the deployment controller's whitelist have `Author=Context.Self` and are permanently vulnerable. This is a normal operational scenario encoded in the system design, not an edge case.

**Attack Vectors:**
1. **Governance DoS:** Attackers can flood the governance system with malicious update proposals for vulnerable contracts, consuming resources and creating confusion
2. **Loss of Author Control:** Legitimate contract authors lose exclusive control over their contract's update lifecycle, as anyone can now propose updates
3. **Governance Exploitation:** If governance approval thresholds are weak or compromised, malicious code updates could be pushed through proposals that should never have been created
4. **Reputation Damage:** Contract owners cannot prevent unauthorized parties from proposing updates to their contracts

**Severity Justification:**
This violates the fundamental access control invariant that only contract authors should propose updates to their contracts. The flaw affects an entire class of legitimately deployed contracts with no remediation possible without contract redeployment.

## Likelihood Explanation

**Attack Requirements:**
- No special permissions required
- Any address can call the public method `ProposeUpdateContract`
- No economic barriers beyond standard transaction fees
- Target contracts exist by design in normal operations

**Attack Simplicity:**
- Single transaction exploit with no complex setup
- No race conditions or timing dependencies
- Simply call `ProposeUpdateContract` with any contract address that has `Author=Context.Self`

**Preconditions:**
- Contracts with `Author=Context.Self` are created whenever non-whitelisted proposers deploy contracts
- This is standard operational behavior encoded in the deployment logic
- The vulnerable authorization check executes on every update proposal

**Probability:**
High - The vulnerability is deterministic and affects all contracts where the proposer was not whitelisted during deployment, which is an intentional system design pattern.

## Recommendation

Change the authorization check in `AssertAuthorityByContractInfo` from:
```csharp
Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
```

To:
```csharp
Assert(address == Context.Self || address == contractInfo.Author, "No permission.");
```

This validates whether the CALLER is the Genesis contract or the stored author, rather than checking if the STORED AUTHOR FIELD equals Genesis.

## Proof of Concept

```csharp
[Fact]
public async Task ProposeUpdateContract_AuthorContextSelf_AuthorizationBypass_Test()
{
    // Deploy a contract where author will be BasicContractZeroAddress (Context.Self)
    // This happens for non-whitelisted proposers when ContractDeploymentAuthorityRequired is true
    var contractDeploymentInput = new ContractDeploymentInput
    {
        Category = KernelConstants.DefaultRunnerCategory,
        Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
    };

    var deployAddress = await DeployAsync(Tester, ParliamentAddress, BasicContractZeroAddress, contractDeploymentInput);
    
    // Verify the contract has author = BasicContractZeroAddress (Context.Self)
    var contractInfo = ContractInfo.Parser.ParseFrom(
        await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractInfo), 
            deployAddress));
    contractInfo.Author.ShouldBe(BasicContractZeroAddress);
    
    // Create unauthorized attacker tester (not the author, not Genesis)
    var attackerTester = Tester.CreateNewContractTester(AnotherUserKeyPair);
    var code = Codes.Single(kv => kv.Key.Contains("TestContract.BasicFunction")).Value;
    var contractUpdateInput = new ContractUpdateInput
    {
        Address = deployAddress,
        Code = ByteString.CopyFrom(code)
    };
    
    // VULNERABILITY: Unauthorized user can propose update (should fail but succeeds)
    var proposingTxResult = await attackerTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeUpdateContract), 
        contractUpdateInput);
    
    // Demonstrates the authorization bypass - any user can propose updates
    proposingTxResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Expected: Should fail with "No permission."
    // Actual: Succeeds, proving authorization bypass
}
```

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L183-183)
```csharp
        AssertAuthorityByContractInfo(info, Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L317-320)
```csharp
        var address =
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L822-837)
```csharp
        var creator = ContractDeployed.Parser
            .ParseFrom(deploymentResult.Logs.First(l => l.Name.Contains(nameof(ContractDeployed))).Indexed[0])
            .Author;

        creator.ShouldBe(BasicContractZeroAddress);

        var deployAddress = ContractDeployed.Parser
            .ParseFrom(deploymentResult.Logs.First(l => l.Name.Contains(nameof(ContractDeployed))).NonIndexed)
            .Address;

        deployAddress.ShouldNotBeNull();

        var author = Address.Parser.ParseFrom(await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractAuthor), deployAddress));

        author.ShouldBe(BasicContractZeroAddress);
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L1175-1187)
```csharp
        {
            var noPermissionProposingTx = await SideChainTester.GenerateTransactionAsync(SideBasicContractZeroAddress,
                nameof(BasicContractZero.ProposeUpdateContract), AnotherMinerKeyPair, new ContractUpdateInput
                {
                    Address = deployAddress,
                    Code = ByteString.Empty
                });
            var blockReturnSet = await SideChainTester.MineAsync(new List<Transaction> { noPermissionProposingTx });
            var noPermissionProposingTxResult =
                blockReturnSet.TransactionResultMap[noPermissionProposingTx.GetHash()];
            noPermissionProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
            noPermissionProposingTxResult.Error.ShouldContain("No permission.");
        }
```
