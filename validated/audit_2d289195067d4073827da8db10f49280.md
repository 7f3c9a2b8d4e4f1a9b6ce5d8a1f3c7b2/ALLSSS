# Audit Report

## Title
State Update Pattern Violation in SetTransactionFeeDelegations Causes Empty Delegatee Entries to Persist

## Summary
The `SetTransactionFeeDelegations` function contains a critical state management bug where empty delegatee entries (delegatees with zero delegations) are not properly removed from storage. The function attempts removal using direct state property modification without the required write-back operation, violating AElf's state management semantics and the pattern consistently used elsewhere in the contract. This causes empty entries to accumulate, eventually blocking users from managing delegations when the 24-delegatee limit is reached.

## Finding Description

In AElf's protobuf-based state system, modifying nested properties through direct state access requires an explicit write-back to persist changes. The `SetTransactionFeeDelegations` function violates this requirement. [1](#0-0) 

When an existing delegatee's delegations are all removed (by setting values to 0 or negative), the problematic sequence occurs:

1. **Lines 68-80**: The delegation map is modified, removing individual token delegations
2. **Line 83**: State is written with `State.TransactionFeeDelegateesMap[input.DelegatorAddress] = allDelegatees` - this persists the delegatee entry WITH an empty delegations dictionary
3. **Line 86**: Checks if delegation count is 0
4. **Line 91**: Attempts removal via `State.TransactionFeeDelegateesMap[input.DelegatorAddress].Delegatees.Remove(delegateeAddress)` - direct nested property modification

Line 91's approach fails because it accesses a deserialized copy of the state object. The `Remove()` operation modifies this temporary copy but doesn't persist without explicit assignment back to state.

The correct pattern is demonstrated in the same file: [2](#0-1) [3](#0-2) 

Both `RemoveTransactionFeeDelegator` and `RemoveTransactionFeeDelegatee` follow the correct READ → MODIFY → WRITE pattern, explicitly reading state into a variable, modifying it, then writing back.

## Impact Explanation

The impact is operationally significant and affects protocol availability:

**1. Delegatee Limit Denial-of-Service** [4](#0-3) [5](#0-4) 

The contract enforces a hard limit of 24 delegatees. Users who accumulate empty ghost entries will hit this limit and be permanently unable to add new legitimate delegatees, even though their actual active delegatees are fewer than 24. This breaks the delegation management functionality.

**2. Gas Inefficiency During Fee Charging** [6](#0-5) 

The fee charging mechanism iterates through all delegatees in the map, including empty ghost entries. Each empty entry wastes gas during iteration even though it will always fail the charging check (having no delegations to pay from).

**3. State Storage Pollution**

Empty delegatee entries accumulate permanently in contract state, increasing storage costs and degrading system efficiency over the protocol's lifetime.

## Likelihood Explanation

The likelihood is **HIGH** because:

**Reachability**: `SetTransactionFeeDelegations` is a public method with no special authorization requirements beyond sender validation. Any user can trigger this bug.

**Trigger Condition**: The bug manifests during normal delegation management - when a user sets all delegation amounts to 0 or negative values to remove a delegatee. This is a standard operation users perform when cleaning up unwanted delegations or switching delegatees.

**Frequency**: Over the protocol's operational lifetime, as users repeatedly adjust their delegations (adding, modifying, removing), empty entries will steadily accumulate. Each user can encounter this bug up to 24 times before being completely blocked.

**No Attack Required**: This is a logic bug in normal code flow, not requiring any adversarial behavior or special conditions.

**Test Suite Masking** [7](#0-6) 

The existing test only verifies that `delegations.Count` is 0, not whether the delegatee entry itself was removed from the map. The query function returns an empty object whether the delegatee doesn't exist OR exists with empty delegations, masking the bug from test detection.

## Recommendation

Apply the correct read-modify-write pattern consistently. Replace the direct modification at line 91 with the established pattern:

```csharp
// Instead of line 91's direct modification:
// State.TransactionFeeDelegateesMap[input.DelegatorAddress].Delegatees.Remove(delegateeAddress);

// Use the correct pattern:
var delegatees = State.TransactionFeeDelegateesMap[input.DelegatorAddress];
delegatees.Delegatees.Remove(delegateeAddress);
State.TransactionFeeDelegateesMap[input.DelegatorAddress] = delegatees;
```

Additionally, consider moving the state write at line 83 to after the delegatee removal check to avoid persisting intermediate inconsistent state.

## Proof of Concept

```csharp
[Fact]
public async Task SetTransactionFeeDelegations_EmptyDelegatee_ShouldBeRemoved_Test()
{
    await Initialize();
    
    // Step 1: Add a delegatee with delegations
    var delegations = new Dictionary<string, long>
    {
        [NativeToken] = 1000,
        [BasicFeeSymbol] = 500
    };
    await TokenContractStub.SetTransactionFeeDelegations.SendAsync(
        new SetTransactionFeeDelegationsInput()
        {
            DelegatorAddress = User1Address,
            Delegations = { delegations }
        });
    
    // Step 2: Remove all delegations (should remove delegatee entry)
    var emptyDelegations = new Dictionary<string, long>
    {
        [NativeToken] = 0,
        [BasicFeeSymbol] = 0
    };
    await TokenContractStub.SetTransactionFeeDelegations.SendAsync(
        new SetTransactionFeeDelegationsInput()
        {
            DelegatorAddress = User1Address,
            Delegations = { emptyDelegations }
        });
    
    // Step 3: Check if delegatee was actually removed from the list
    var delegateeList = await TokenContractStub.GetTransactionFeeDelegatees.CallAsync(
        new GetTransactionFeeDelegateesInput
        {
            DelegatorAddress = User1Address
        });
    
    // BUG: This will FAIL - delegatee is still in the list despite having no delegations
    delegateeList.DelegateeAddresses.Count.ShouldBe(0);
    delegateeList.DelegateeAddresses.ShouldNotContain(DefaultAddress);
}
```

This test demonstrates that after removing all delegations, the delegatee entry persists in the delegatee list, proving the state update does not complete properly.

---

**Notes**: 

The vulnerability is rooted in AElf's `MappedState` semantics where nested property modifications through direct state access return deserialized copies. Without explicit write-back (`State.X = modifiedValue`), changes to these copies don't persist. The consistent use of the read-modify-write pattern in `RemoveTransactionFeeDelegator` and `RemoveTransactionFeeDelegatee` confirms this is the required approach, making line 91's direct modification approach incorrect and non-functional.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L28-37)
```csharp
        if (!allDelegateesMap.ContainsKey(delegateeAddress))
        {
            // If there has been already DELEGATEE_MAX_COUNT delegatees, and still try to add，fail.
            if (allDelegateesMap.Count() >= TokenContractConstants.DELEGATEE_MAX_COUNT)
            {
                return new SetTransactionFeeDelegationsOutput()
                {
                    Success = false
                };
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L66-98)
```csharp
        else // This delegatee exists, so update
        {
            var delegationsMap = allDelegateesMap[delegateeAddress].Delegations;
            foreach (var (key, value) in delegationsToInput)
            {
                if (value <= 0 && delegationsMap.ContainsKey(key))
                {
                    delegationsMap.Remove(key);
                }
                else if (value > 0)
                {
                    AssertValidToken(key, value);
                    delegationsMap[key] = value;
                }
            }

            // Set and Fire logEvent
            State.TransactionFeeDelegateesMap[input.DelegatorAddress] = allDelegatees;

            // If a delegatee has no delegations, remove it!
            if (allDelegateesMap[delegateeAddress].Delegations.Count != 0)
                return new SetTransactionFeeDelegationsOutput()
                {
                    Success = true
                };
            State.TransactionFeeDelegateesMap[input.DelegatorAddress].Delegatees.Remove(delegateeAddress);
            Context.Fire(new TransactionFeeDelegationCancelled()
            {
                Caller = Context.Sender,
                Delegatee = Context.Sender,
                Delegator = input.DelegatorAddress
            });
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L122-124)
```csharp
        var delegatees = State.TransactionFeeDelegateesMap[input.DelegatorAddress];
        delegatees.Delegatees.Remove(Context.Sender.ToBase58());
        State.TransactionFeeDelegateesMap[input.DelegatorAddress] = delegatees;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L151-153)
```csharp
        var delegatees = State.TransactionFeeDelegateesMap[Context.Sender];
        delegatees.Delegatees.Remove(input.DelegateeAddress.ToBase58());
        State.TransactionFeeDelegateesMap[Context.Sender] = delegatees;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L18-18)
```csharp
    public const int DELEGATEE_MAX_COUNT = 24;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L183-207)
```csharp
        foreach (var (delegatee, delegations) in delegationInfo)
        {
            // compare current block height with the block height when the delegatee added
            if (Context.Transaction.RefBlockNumber < delegations.BlockHeight) continue;

            var delegateeBill = new TransactionFeeBill();
            var delegateeAllowanceBill = new TransactionFreeFeeAllowanceBill();
            var delegateeAddress = Address.FromBase58(delegatee);
            var delegateeChargingResult = ChargeTransactionFeesToBill(input, delegateeAddress,
                ref delegateeBill, ref delegateeAllowanceBill, fee, isSizeFeeFree, delegations);

            if (!delegateeChargingResult) continue;

            bill = delegateeBill;
            allowanceBill = delegateeAllowanceBill;
            fromAddress = delegateeAddress;
            chargingResult = true;
            if (!delegations.IsUnlimitedDelegate)
            {
                ModifyDelegation(delegateeBill, delegateeAllowanceBill, fromAddress, input.ContractAddress,
                    input.MethodName, delegatorAddress);
            }

            break;
        }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenDelegationTest.cs (L51-76)
```csharp
    public async Task SetTokenDelegation_removeDelegatee_Test()
    {
        await SetTokenDelegation_Test();
        var delegations = new Dictionary<string, long>
        {
            [NativeToken] = 0,
            [BasicFeeSymbol] = 0,
            [SizeFeeSymbol] = 0
        };
        await TokenContractStub.SetTransactionFeeDelegations.SendAsync(new SetTransactionFeeDelegationsInput()
        {
            DelegatorAddress = User1Address,
            Delegations =
            {
                delegations
            }
        });

        var delegateAllowance = await TokenContractStub.GetTransactionFeeDelegationsOfADelegatee.CallAsync(
            new GetTransactionFeeDelegationsOfADelegateeInput()
            {
                DelegateeAddress = DefaultAddress,
                DelegatorAddress = User1Address
            });
        delegateAllowance.Delegations.Count().ShouldBe(0);
    }
```
