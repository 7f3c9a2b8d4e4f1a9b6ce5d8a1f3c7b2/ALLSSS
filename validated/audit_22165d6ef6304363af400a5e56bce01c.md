# Audit Report

## Title
Missing Timestamp Validation in NextRound Allows Premature Round Termination and Consensus Timing Manipulation

## Summary
The AEDPoS consensus contract's `NextRound` validation pipeline lacks timestamp validation to ensure rounds can only be terminated after reaching their expected end time. Any miner can call `NextRound` during their own mining time slot to prematurely terminate the round, causing subsequent miners to lose their scheduled mining opportunities and rewards.

## Finding Description

The `NextRound` method is publicly accessible and processes round transitions without validating that the current block time has reached the expected end of the current round. [1](#0-0) 

The validation pipeline is constructed in `ValidateBeforeExecution()`, which adds several validation providers for NextRound behavior: [2](#0-1) 

However, `RoundTerminateValidationProvider.ValidationForNextRound()` only performs structural validation without any timing checks: [3](#0-2) 

The `TimeSlotValidationProvider` only validates internal consistency of the proposed round's time slots (equal intervals between miners), not whether the current round has completed: [4](#0-3) 

The `CheckRoundTimeSlots()` method validates interval consistency but not timing appropriateness: [5](#0-4) 

When generating the next round, `ExpectedMiningTime` values are calculated from `currentBlockTimestamp` without validation: [6](#0-5) 

The permission check in `PreCheck()` only validates miner list membership: [7](#0-6) 

Critically, while the contract has a `GetExtraBlockMiningTime()` method that calculates when the round should end: [8](#0-7) 

And an `IsCurrentMiner()` method with timing checks: [9](#0-8) 

Neither of these timing validations are enforced in the `NextRound` validation pipeline.

## Impact Explanation

**Consensus Integrity Violation**: A miner can terminate a round before all miners have had their designated time slots. For example, in a 17-miner configuration with 4000ms intervals, if miner #3 calls `NextRound` at their slot (T+8000ms), miners #4-17 lose 56 seconds of mining time (14 miners Ã— 4000ms).

**Economic Impact**: Miners who lose their time slots also lose block production rewards. When `ProcessNextRound` executes, miners who haven't mined are marked with incremented `MissedTimeSlots`: [10](#0-9) 

On the main chain, missed miners may be marked as "evil nodes": [11](#0-10) 

**Quantified Impact**: In a 17-miner round, premature termination after miner #3 results in 82% of miners (14/17) losing their mining opportunities and potentially being penalized as evil nodes despite having no fault.

## Likelihood Explanation

**Attacker Preconditions**: The attacker must be an elected miner in the current round - a realistic scenario in the AEDPoS consensus mechanism.

**Attack Execution**: During their legitimate mining time slot, any miner can include a `NextRound` transaction with a structurally valid `NextRoundInput`. All validation checks pass because they only verify:
- Sender is in miner list (MiningPermissionValidationProvider)
- Round number increments correctly (RoundTerminateValidationProvider)  
- InValues are null (RoundTerminateValidationProvider)
- Time slots are internally consistent (TimeSlotValidationProvider)

**No Timing Validation Exists**: There is no check comparing `Context.CurrentBlockTime` against the expected round end time calculated via `GetExtraBlockMiningTime()`.

**Economic Rationality**: The attack has minimal cost (transaction fees) but provides significant benefits (reduced competition, increased mining share). The attack is repeatable in every round.

**Probability**: HIGH - Any miner can exploit this during their legitimate mining window with no special privileges required.

## Recommendation

Add timestamp validation to `RoundTerminateValidationProvider.ValidationForNextRound()` to ensure the current block time has reached or exceeded the expected end time of the current round:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Validate round number
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // Validate InValues are null
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Validate timing - round can only be terminated after expected end time
    var expectedEndTime = validationContext.BaseRound.GetExtraBlockMiningTime();
    if (validationContext.CurrentBlockTime < expectedEndTime)
        return new ValidationResult { Message = "Cannot terminate round before expected end time." };
    
    return new ValidationResult { Success = true };
}
```

Additionally, consider restricting `NextRound` to only be callable by the designated extra block producer of the current round.

## Proof of Concept

```csharp
[Fact]
public async Task PrematureRoundTermination_Attack()
{
    // Setup: Initialize a round with 17 miners
    var initialMiners = GenerateMinerList(17);
    await InitializeConsensusAsync(initialMiners);
    
    // Miner #3 gets their time slot at T+8000ms
    var miner3 = initialMiners[2];
    var currentRound = await GetCurrentRound();
    var miner3Slot = currentRound.RealTimeMinersInformation[miner3.ToHex()].ExpectedMiningTime;
    
    // Miner #3 produces block during their legitimate time slot
    await ProduceBlockAs(miner3, miner3Slot.AddMilliseconds(2000));
    
    // Attacker: Miner #3 calls NextRound prematurely (before other miners get their slots)
    var nextRoundInput = GenerateNextRoundInput(await GetCurrentRound());
    var result = await AEDPoSContractStub.NextRound.SendAsync(nextRoundInput);
    
    // Verification: NextRound succeeds even though round hasn't completed
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Impact: Verify miners #4-17 lost their time slots
    var newRound = await GetCurrentRound();
    newRound.RoundNumber.ShouldBe(currentRound.RoundNumber + 1);
    
    // Miners #4-17 have MissedTimeSlots incremented despite never getting their chance
    for (int i = 3; i < 17; i++)
    {
        var miner = initialMiners[i];
        var minerInfo = newRound.RealTimeMinersInformation[miner.ToHex()];
        minerInfo.MissedTimeSlots.ShouldBeGreaterThan(0); // Penalized unfairly
    }
}
```

## Notes

The vulnerability exists because the validation architecture separates permission checking from timing validation. While `IsCurrentMiner()` includes timing checks for normal block production, the `NextRound` validation pipeline does not leverage these checks. The `GetExtraBlockMiningTime()` helper method exists to calculate round end times but is never used in validation. This allows any miner to prematurely terminate rounds during their legitimate mining windows, disrupting fair consensus operation and mining reward distribution.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L13-19)
```csharp
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-36)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L42-56)
```csharp
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L173-178)
```csharp
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```
