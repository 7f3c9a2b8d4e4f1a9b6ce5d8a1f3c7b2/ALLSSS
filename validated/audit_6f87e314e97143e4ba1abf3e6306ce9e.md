# Audit Report

## Title
Scheme Metadata Overwrite Causes Permanent Token Lock Due to Architectural Mismatch

## Summary
The TokenHolder contract stores only one scheme per manager address, while the underlying Profit contract supports multiple schemes. When a manager creates a second scheme, the TokenHolder metadata is overwritten, causing the withdrawal mechanism to query locked tokens using the wrong token symbol. This results in permanent, irreversible token loss for all users who locked tokens under the first scheme.

## Finding Description

The vulnerability arises from an architectural inconsistency between TokenHolder and Profit contracts:

**Overwriting Scheme Storage**: The `CreateScheme` method stores scheme metadata at a single-address mapping that gets overwritten on subsequent calls. [1](#0-0) 

**Single-Value State Structure**: The state mapping confirms only one scheme can be stored per manager address. [2](#0-1) 

**Multiple Schemes Supported by Profit**: The Profit contract explicitly appends new schemes to a manager's scheme list, supporting multiple schemes per manager. [3](#0-2) 

**LockId Without Scheme Identifier**: When users register for profits, the lockId is generated using only the manager and user addresses, without any scheme-specific identifier. [4](#0-3) 

**Scheme Resolution Mismatch**: During withdrawal, `UpdateTokenHolderProfitScheme` retrieves the first SchemeId from the Profit contract but uses the Symbol from the potentially overwritten TokenHolder state. [5](#0-4) 

**Wrong Symbol Query**: The withdrawal process queries locked amounts using the scheme's symbol, which may be from the overwritten (second) scheme. [6](#0-5) 

**Virtual Address Calculation**: The token lock mechanism computes virtual addresses from the contract, user address, and lockId—but NOT the symbol. [7](#0-6) 

**Symbol-Specific Balance Query**: `GetLockedAmount` queries the balance of a specific symbol at the virtual address. [8](#0-7) 

Since the virtual address is computed without the symbol, tokens locked as "ELF" exist at address V, but querying for "USDT" at the same address V returns 0.

**Attack Scenario**:
1. Manager creates scheme for "ELF"
2. User locks 1,000 ELF tokens
3. Manager creates scheme for "USDT" (overwrites TokenHolder metadata)
4. User attempts withdrawal → queries for "USDT" at the virtual address → returns 0 tokens
5. Unlock executes with amount=0, leaving 1,000 ELF permanently inaccessible

## Impact Explanation

**Permanent Fund Loss**: Users lose 100% of their locked tokens with no recovery mechanism. The `GetLockedAmount` call returns 0 due to the symbol mismatch, causing the `Unlock` operation to execute with amount=0.

**Complete Inaccessibility**: No time-based expiration, emergency unlock, or admin override exists. Even the scheme manager cannot reverse this condition.

**Widespread Scope**: Affects ALL users who registered under a manager before that manager creates a new scheme.

**Critical Invariant Violation**: The fundamental guarantee that "users can unlock tokens they previously locked" is permanently broken.

This represents HIGH severity due to permanent, irreversible fund loss with no recovery path.

## Likelihood Explanation

**Public Entry Points**: Both `CreateScheme` and `RegisterForProfits` are public methods with no special privilege requirements.

**No Duplicate Prevention**: No guard prevents a manager from creating multiple schemes. [9](#0-8) 

**Supported by Design**: The Profit contract explicitly supports and tests multiple schemes per manager, suggesting this is an intended use case.

**Accidental Triggering**: A legitimate manager might create a second scheme thinking they are "updating" their configuration, unaware they are permanently locking users' funds.

**Deterministic Outcome**: No timing constraints, race conditions, or complex preconditions—the vulnerability triggers reliably.

The likelihood is MEDIUM-HIGH because multiple token schemes per manager is a reasonable business requirement, and accidental triggering is highly plausible without proper documentation or warnings.

## Recommendation

**Solution 1 - Prevent Multiple Schemes**: Add validation in `CreateScheme` to reject if a scheme already exists:
```csharp
Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
    "Scheme already exists for this manager.");
```

**Solution 2 - Include SchemeId in Storage**: Change the state structure to map by both manager AND schemeId, and include the schemeId in the lockId generation to differentiate locks between schemes.

**Solution 3 - Emergency Unlock**: Implement an admin override mechanism that allows unlocking tokens even when symbol mismatches occur, though this is less ideal than preventing the issue.

The recommended approach is Solution 1 combined with clear documentation about the one-scheme-per-manager limitation.

## Proof of Concept

```csharp
[Fact]
public async Task SchemeOverwrite_CausesPermanentTokenLock()
{
    // Setup: Manager creates first scheme for ELF
    var manager = DefaultSender;
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    // User locks 1000 ELF tokens
    var user = Accounts[1].Address;
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenHolderContractAddress,
        Symbol = "ELF",
        Amount = 1000
    });
    
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = manager,
        Amount = 1000
    });
    
    // Manager creates second scheme for USDT (OVERWRITES first scheme)
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",
        MinimumLockMinutes = 1
    });
    
    // User attempts to withdraw - should get 1000 ELF back
    await TokenHolderContractStub.Withdraw.SendAsync(manager);
    
    // Verify: User's ELF balance did NOT increase (tokens remain locked)
    var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = user,
        Symbol = "ELF"
    });
    
    // VULNERABILITY: User's 1000 ELF is permanently locked
    balance.Balance.ShouldBe(0); // Expected 1000, got 0 - tokens are lost
}
```

## Notes

This vulnerability demonstrates a critical architectural flaw where two system contracts (TokenHolder and Profit) have incompatible assumptions about scheme multiplicity. The issue is exacerbated by the lockId generation mechanism that doesn't include scheme-specific identifiers, making it impossible to differentiate locks across multiple schemes even if the storage issue were fixed independently.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-158)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L220-225)
```csharp
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L290-298)
```csharp
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L10-10)
```csharp
    public MappedState<Address, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-210)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L111-115)
```csharp
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
```
