# Audit Report

## Title
Unauthorized Round Termination by Non-Extra-Block-Producer Miners

## Summary
The AEDPoS consensus contract fails to validate that only the designated extra block producer can terminate rounds via NextRound/NextTerm transactions. Any miner who has produced their normal block can prematurely terminate the round, violating the fundamental consensus invariant that requires the extra block producer to complete this role.

## Finding Description

The AEDPoS consensus mechanism designates a specific miner as the "extra block producer" for each round through the `CalculateNextExtraBlockProducerOrder()` method, which uses the first miner's signature to deterministically select the extra block producer and marks them with the `IsExtraBlockProducer` flag. [1](#0-0) 

This extra block producer has a designated time slot at the end of each round to terminate it and transition to the next round. [2](#0-1) 

However, the behavior determination logic in `GetConsensusBehaviour()` returns termination behaviors (NextRound/NextTerm) for ANY miner who has produced their block (`OutValue != null`) and whose time slot has passed, without checking if they are the designated extra block producer. [3](#0-2) 

The validation system contains multiple providers, but none verify extra block producer authorization. The `MiningPermissionValidationProvider` only checks miner list membership: [4](#0-3) 

The `TimeSlotValidationProvider` validates time slot spacing but not miner authorization for round termination: [5](#0-4) 

The `RoundTerminateValidationProvider` only validates round/term number increments: [6](#0-5) 

The validation logic for NextRound and NextTerm behaviors applies these providers but includes no check for extra block producer status: [7](#0-6) 

The implementations in both `MainChainConsensusBehaviourProvider` and `SideChainConsensusBehaviourProvider` return NextRound/NextTerm without checking extra block producer status: [8](#0-7) [9](#0-8) 

Even in the execution phase, `PreCheck()` only verifies the miner is in the miner list, not whether they are authorized as the extra block producer: [10](#0-9) 

Notably, the `IsCurrentMiner` view method DOES correctly check for extra block producer authorization during the extra block time slot: [11](#0-10) 

However, this check is not integrated into the transaction validation flow.

## Impact Explanation

**Consensus Integrity Violation**: The core consensus rule that only the designated extra block producer should terminate rounds is violated. This breaks the fundamental scheduling mechanism where each miner gets their allocated time slot before round completion.

**Operational Disruption**: When a non-extra-block-producer miner terminates the round early, subsequent miners in the round lose their opportunity to produce blocks. This disrupts the fair rotation of mining responsibilities and the deterministic mining schedule that AEDPoS consensus relies upon.

**Reward Misallocation**: Miners who lose their time slots due to premature round termination miss out on mining rewards, creating unfair economic outcomes. The attacker gains a competitive advantage by controlling when rounds end.

**Potential Consensus Instability**: Multiple miners could simultaneously attempt to terminate the round once their time slots pass, potentially leading to competing round termination blocks and temporary consensus disagreement among nodes.

The severity is **High** because this directly violates a critical consensus invariant that ensures fair and deterministic block production scheduling.

## Likelihood Explanation

**Attacker Capabilities**: Any registered miner in the current round can exploit this vulnerability. No special permissions beyond standard miner status are required.

**Attack Complexity**: Low. The attacker simply:
1. Produces their normal block (setting `OutValue`)
2. Waits for their time slot to pass
3. Calls the consensus command generation logic
4. Receives NextRound/NextTerm behavior
5. Produces the terminating block

**Preconditions**: 
- Miner must be in the current round's miner list (standard requirement)
- Miner must have produced their normal block
- Current time must be past the miner's time slot
- The actual extra block producer must not have terminated yet

**Economic Incentive**: A malicious miner can deny competitors their time slots, manipulate which miners participate in round completion, and potentially gain timing advantages for transaction inclusion.

The likelihood is **High** because this can occur through normal operations when miners' logic incorrectly triggers round termination, or intentionally by malicious actors seeking unfair advantages.

## Recommendation

Add extra block producer authorization validation in the behavior determination and validation logic:

1. **In `GetConsensusBehaviour()`**: Before returning `GetConsensusBehaviourToTerminateCurrentRound()`, check if the current miner is the designated extra block producer and if the current time is within the extra block time slot.

2. **Add new validation provider**: Create an `ExtraBlockProducerValidationProvider` that validates:
   - For NextRound/NextTerm behaviors, verify the sender is the designated extra block producer
   - Verify the current time is within the extra block time slot

3. **Register the validator**: Add the new validation provider to the validation chain in `AEDPoSContract_Validation.cs` for NextRound and NextTerm cases.

The fix should mirror the logic already present in the `IsCurrentMiner` view method, ensuring that only the designated extra block producer can execute round termination during their designated time slot.

## Proof of Concept

```csharp
// Test demonstrating unauthorized round termination
[Fact]
public async Task UnauthorizedRoundTermination_Test()
{
    // Setup: Initialize consensus with multiple miners
    var miners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensus(miners);
    
    // Miner1 produces their normal block
    await ProduceNormalBlock("miner1");
    
    // Advance time past miner1's slot but before extra block producer's slot
    AdvanceTime(TimeSpan.FromSeconds(10));
    
    // Miner1 (who is NOT the extra block producer) attempts NextRound
    var command = GetConsensusCommand("miner1");
    Assert.Equal(AElfConsensusBehaviour.NextRound, command.Behaviour);
    
    // Execute NextRound transaction - should fail but currently succeeds
    var result = await ExecuteNextRound("miner1", command);
    
    // Vulnerability: Non-extra-block-producer successfully terminated round
    Assert.True(result.Success); // This should be false
    
    // Impact: Miner2 and miner3 lost their time slots
    var currentRound = await GetCurrentRoundNumber();
    Assert.Equal(2, currentRound); // Round was prematurely terminated
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-83)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-23)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```
