# Audit Report

## Title
Cross-Chain Token Creation Bypasses Symbol Namespace Collision Protection

## Summary
The `CrossChainCreateToken` method allows both a token (e.g., "ABC") and its corresponding NFT collection (e.g., "ABC-0") to coexist on the same chain by creating them on different chains first and then syncing them via cross-chain operations. This bypasses the `CheckTokenAndCollectionExists` protection that enforces namespace exclusivity during local token creation, violating the design intent and undermining the SEED NFT system's exclusive symbol rights.

## Finding Description

The token contract enforces a namespace collision protection during local token creation. The `GetSymbolType` function distinguishes between regular tokens (e.g., "ABC"), NFT collections (e.g., "ABC-0"), and NFT items (e.g., "ABC-1") based on symbol format. [1](#0-0) 

When creating tokens or NFT collections locally via the `Create` method, the `AssertValidCreateInput` validation calls `CheckTokenAndCollectionExists` to ensure that both the token symbol and its corresponding collection symbol don't already exist. [2](#0-1) 

The `CheckTokenAndCollectionExists` method validates both the base token symbol and the collection symbol (base + "-0") to prevent namespace collisions. [3](#0-2) 

This protection is confirmed by test cases demonstrating that creating "XYZ" blocks creation of "XYZ-0", and vice versa. [4](#0-3) 

**Root Cause:** The `CrossChainCreateToken` method only calls `AssertNftCollectionExist` to validate NFT items (not tokens or collections) and checks if the exact symbol already exists. It does NOT call `CheckTokenAndCollectionExists` to verify that the related symbol doesn't exist. [5](#0-4) 

The `AssertNftCollectionExist` method only validates NFT items (symbols like "ABC-1"), returning null without performing any validation for regular tokens or NFT collections. [6](#0-5) 

The `GetNftCollectionSymbol` helper method returns null for both regular tokens (single-part symbols) and NFT collections (when `isAllowCollection` is false, which is the default), causing `AssertNftCollectionExist` to skip validation entirely for these symbol types. [7](#0-6) 

## Impact Explanation

**Namespace Invariant Violation:** The explicit design intent that tokens and their corresponding collections cannot coexist on the same chain is violated. This fundamental invariant is enforced during local creation but bypassed during cross-chain creation.

**SEED NFT System Bypass:** The SEED NFT system grants exclusive rights to create specific symbols. Users who own a SEED NFT burn it to create their token, expecting exclusive control over that symbol namespace. [8](#0-7) 

If a SEED owner creates token "ABC" on Chain A, an attacker can create collection "ABC-0" on Chain B and sync it to Chain A, polluting the namespace that should be exclusively controlled by the SEED owner. The SEED NFT validation and exclusive rights enforcement in `CreateNFTInfo` is completely bypassed. [9](#0-8) 

**User Confusion and Trust Degradation:** The presence of both "ABC" and "ABC-0" on the same chain creates ambiguity about their relationship, potentially misleading users into believing they're related when they're controlled by different entities with conflicting interests.

**Protocol Integrity:** This breaks a core security guarantee of the token system, undermining trust in the namespace protection mechanism and the value proposition of SEED NFTs.

## Likelihood Explanation

**Public Entry Point:** `CrossChainCreateToken` is a public RPC method accessible to any user after cross-chain token contract registration. [10](#0-9) 

**No Special Privileges Required:** The attack only requires:
1. Ability to create tokens on two different chains (standard functionality available to all users)
2. Valid cross-chain verification (attacker provides legitimate proof for tokens they legitimately created)
3. No governance approval or special permissions needed

**Feasible Attack Scenario:**
1. **Chain A:** User creates token "ABC" via `Create()` (passes local validation including `CheckTokenAndCollectionExists`)
2. **Chain B:** Attacker creates collection "ABC-0" via `Create()` (passes local validation on Chain B since "ABC" doesn't exist there)
3. **Chain A:** Attacker calls `CrossChainCreateToken` to sync "ABC-0" from Chain B to Chain A
   - Cross-chain verification passes (legitimate proof from Chain B)
   - `AssertNftCollectionExist("ABC-0")` returns null without validation (collection symbol)
   - Only checks `State.TokenInfos["ABC-0"] == null` (doesn't check if "ABC" exists)
4. **Result:** Both "ABC" and "ABC-0" coexist on Chain A

The same attack works in reverse: create collection first, then sync the token.

**Economic Rationality:** Attack cost is minimal (gas fees for token creation and cross-chain transactions), while benefits include namespace squatting, undermining SEED NFT value, and potential exploitation of user confusion.

## Recommendation

Add `CheckTokenAndCollectionExists` validation in the `CrossChainCreateToken` method before registering the token info. This ensures that cross-chain token creation enforces the same namespace collision protection as local creation.

Modify the `CrossChainCreateToken` method to include namespace validation:

```csharp
public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
{
    // ... existing validation code ...
    
    var tokenInfo = new TokenInfo { /* ... */ };
    
    // ADD THIS VALIDATION:
    var symbolType = GetSymbolType(tokenInfo.Symbol);
    if (symbolType != SymbolType.Nft) // Skip for NFT items, validate for tokens and collections
    {
        CheckTokenAndCollectionExists(tokenInfo.Symbol);
    }
    
    // Continue with existing registration logic
    if (State.TokenInfos[tokenInfo.Symbol] == null)
    {
        RegisterTokenInfo(tokenInfo);
        // ...
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreateToken_NamespaceCollision_Test()
{
    // Setup: Create side chain and register contracts
    var sideChainId = await GenerateSideChainAsync();
    await RegisterMainChainTokenContractAddressOnSideChainAsync(sideChainId);
    await RegisterSideChainContractAddressOnMainChainAsync();

    // Step 1: Main chain - Create token "ABC"
    var createTokenResult = await CreateMutiTokenAsync(TokenContractStub, new CreateInput
    {
        Symbol = "ABC",
        TokenName = "ABC Token",
        TotalSupply = 1000,
        Decimals = 2,
        Issuer = DefaultAddress,
        Owner = DefaultAddress,
        IssueChainId = _chainId
    });
    createTokenResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

    // Step 2: Side chain - Create collection "ABC-0"
    var createCollectionTransaction = await CreateTransactionForNFTCreation(
        SideChainTokenContractStub, 
        DefaultAccount.Address, 
        "ABC-0", 
        SideTokenContractAddress);
    var sideBlockExecutedSet = await SideChainTestKit.MineAsync(
        new List<Transaction> { createCollectionTransaction });
    var createCollectionResult = sideBlockExecutedSet.TransactionResultMap[createCollectionTransaction.GetHash()];
    createCollectionResult.Status.ShouldBe(TransactionResultStatus.Mined);

    // Step 3: Sync "ABC-0" from side chain to main chain via CrossChainCreateToken
    var collectionInfo = await SideChainTokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = "ABC-0" });
    var tokenValidationTransaction = CreateTokenInfoValidationTransaction(
        collectionInfo, SideChainTokenContractStub);
    sideBlockExecutedSet = await SideChainTestKit.MineAsync(
        new List<Transaction> { tokenValidationTransaction });
    var merklePath = GetTransactionMerklePathAndRoot(tokenValidationTransaction, out var blockRoot);
    await IndexSideChainTransactionAsync(sideChainId, sideBlockExecutedSet.Height, blockRoot, blockRoot);

    var crossChainCreateTokenInput = new CrossChainCreateTokenInput
    {
        FromChainId = sideChainId,
        ParentChainHeight = sideBlockExecutedSet.Height,
        TransactionBytes = tokenValidationTransaction.ToByteString(),
        MerklePath = merklePath
    };

    // BUG: This should fail but succeeds, allowing namespace collision
    var result = await TokenContractStub.CrossChainCreateToken.SendAsync(crossChainCreateTokenInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // VULNERABILITY: Should have failed

    // Verify both "ABC" and "ABC-0" now exist on main chain
    var tokenABC = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "ABC" });
    tokenABC.Symbol.ShouldBe("ABC"); // Original token exists

    var collectionABC0 = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "ABC-0" });
    collectionABC0.Symbol.ShouldBe("ABC-0"); // Collection also exists - NAMESPACE COLLISION!
}
```

**Notes:**

This vulnerability represents a critical inconsistency between local and cross-chain token creation validation. The namespace protection is a fundamental design invariant enforced by test cases and the SEED NFT system, but the cross-chain path completely bypasses this protection. This allows attackers to pollute symbol namespaces that users have paid for through SEED NFT purchases, undermining the core value proposition of the SEED system and breaking trust in the token namespace guarantees.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L285-293)
```csharp
    private void CheckTokenAndCollectionExists(string symbol)
    {
        var symbols = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        var tokenSymbol = symbols.First();
        CheckTokenExists(tokenSymbol);
        var collectionSymbol = symbols.First() + TokenContractConstants.NFTSymbolSeparator +
                               TokenContractConstants.CollectionSymbolSuffix;
        CheckTokenExists(collectionSymbol);
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/NftApplicationTests.cs (L720-781)
```csharp
    [Fact(DisplayName = "[token] create Test")]
    public async Task CreateTokenTest()
    {
        var res = await CreateMutiTokenAsync(TokenContractStub, new CreateInput
        {
            Symbol = "XYZ",
            TokenName = "Trump Digital Trading Cards #1155",
            TotalSupply = TotalSupply,
            Decimals = 0,
            Issuer = DefaultAddress,
            Owner = DefaultAddress,
            IssueChainId = _chainId,
        });
        res.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        // check symbol repeat
        var exceptionRes = await CreateSeedNftWithExceptionAsync(TokenContractStub, new CreateInput
        {
            Symbol = "XYZ",
            TokenName = "Trump Digital Trading Cards #1155",
            TotalSupply = TotalSupply,
            Decimals = 0,
            Issuer = DefaultAddress,
            IssueChainId = _chainId,
        });
        exceptionRes.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        exceptionRes.TransactionResult.Error.ShouldContain("Token already exists");
        // check collection symbol prefix duplicated
        var failCollection = await CreateSeedNftWithExceptionAsync(TokenContractStub, new CreateInput
        {
            TokenName = "Trump Digital Trading Cards #1155",
            TotalSupply = TotalSupply,
            Decimals = 0,
            Issuer = DefaultAddress,
            IssueChainId = _chainId,
            Symbol = "XYZ-0"
        });
        failCollection.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        failCollection.TransactionResult.Error.ShouldContain("Token already exists.");

        var successCollection = await CreateMutiTokenAsync(TokenContractStub, new CreateInput
        {
            TokenName = "Trump Digital Trading Cards #1155",
            TotalSupply = TotalSupply,
            Decimals = 0,
            Issuer = DefaultAddress,
            Owner = DefaultAddress,
            IssueChainId = _chainId,
            Symbol = "GHJ-0"
        });
        successCollection.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        // check ft symbol prefix duplicated
        var fTokenAsync = await CreateSeedNftWithExceptionAsync(TokenContractStub, new CreateInput
        {
            TokenName = "Trump Digital Trading Cards #1155",
            TotalSupply = TotalSupply,
            Decimals = 0,
            Issuer = DefaultAddress,
            IssueChainId = _chainId,
            Symbol = "GHJ"
        });
        fTokenAsync.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        fTokenAsync.TransactionResult.Error.ShouldContain("Token already exists.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-520)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L35-54)
```csharp
        var owner = nftCollectionInfo.Owner ?? nftCollectionInfo.Issuer;
        Assert(Context.Sender == owner && owner == input.Owner, "NFT owner must be collection's owner");
        if (nftCollectionInfo.Symbol == TokenContractConstants.SeedCollectionSymbol)
        {
            Assert(input.Decimals == 0 && input.TotalSupply == 1, "SEED must be unique.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedOwnedSymbolExternalInfoKey,
                    out var ownedSymbol), "OwnedSymbol does not exist.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var expirationTime)
                   && long.TryParse(expirationTime, out var expirationTimeLong) &&
                   Context.CurrentBlockTime.Seconds <= expirationTimeLong, "Invalid ownedSymbol.");
            var ownedSymbolType = GetSymbolType(ownedSymbol);
            Assert(ownedSymbolType != SymbolType.Nft, "Invalid OwnedSymbol.");
            CheckSymbolLength(ownedSymbol, ownedSymbolType);
            CheckTokenAndCollectionExists(ownedSymbol);
            CheckSymbolSeed(ownedSymbol);
            State.SymbolSeedMap[ownedSymbol.ToUpper()] = input.Symbol;
        }

        return CreateToken(input, SymbolType.Nft);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L57-67)
```csharp
    private void CheckSymbolSeed(string ownedSymbol)
    {
        var oldSymbolSeed = State.SymbolSeedMap[ownedSymbol.ToUpper()];

        Assert(oldSymbolSeed == null || !GetTokenInfo(oldSymbolSeed).ExternalInfo.Value
                   .TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var oldSymbolSeedExpireTime) ||
               !long.TryParse(oldSymbolSeedExpireTime, out var symbolSeedExpireTime)
               || Context.CurrentBlockTime.Seconds > symbolSeedExpireTime,
            "OwnedSymbol has been created");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L153-161)
```csharp
    private string GetNftCollectionSymbol(string inputSymbol, bool isAllowCollection = false)
    {
        var symbol = inputSymbol;
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        const int tokenSymbolLength = 1;
        if (words.Length == tokenSymbolLength) return null;
        Assert(words.Length == 2 && IsValidItemId(words[1]), "Invalid NFT Symbol Input");
        return symbol == $"{words[0]}-0" ? (isAllowCollection ? $"{words[0]}-0" : null) : $"{words[0]}-0";
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L163-170)
```csharp
    private TokenInfo AssertNftCollectionExist(string symbol)
    {
        var collectionSymbol = GetNftCollectionSymbol(symbol);
        if (collectionSymbol == null) return null;
        var collectionInfo = GetTokenInfo(collectionSymbol);
        Assert(collectionInfo != null, "NFT collection not exist");
        return collectionInfo;
    }
```
