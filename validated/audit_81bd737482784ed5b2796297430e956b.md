# Audit Report

## Title
Missing LIB Monotonicity Validation in NextRound Allows Consensus State Corruption

## Summary
The AEDPoS consensus contract fails to validate that `ConfirmedIrreversibleBlockHeight` (LIB) maintains its monotonically increasing invariant when processing `NextRound` transitions. A malicious miner can submit a `NextRound` transaction with decreased LIB values, bypassing validation and corrupting the consensus state stored on-chain.

## Finding Description

The vulnerability exists in the consensus validation pipeline where different validation providers are conditionally applied based on the consensus behavior type.

**Root Cause:**

The `ValidateBeforeExecution` method applies different validation providers based on consensus behavior. For `UpdateValue` behavior, the validation includes `LibInformationValidationProvider` which enforces LIB monotonicity at lines 79-82. However, for `NextRound` behavior at lines 84-88, only `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` are applied - the critical `LibInformationValidationProvider` is omitted. [1](#0-0) 

The `LibInformationValidationProvider` contains the only check that prevents LIB from decreasing. It validates that the provided LIB height and round number are not lower than the base round's values at lines 14-21. [2](#0-1) 

**Attack Path:**

1. A miner with active mining rights calls the public `NextRound` method at lines 161-166. [3](#0-2) 

2. The attacker crafts a `NextRoundInput` with `ConfirmedIrreversibleBlockHeight` set to a value lower than the current consensus state's LIB.

3. Validation occurs via `ValidateConsensusBeforeExecution`, but since `LibInformationValidationProvider` is not in the validation pipeline for `NextRound`, the malicious LIB values pass validation.

4. The `RoundTerminateValidationProvider` that IS applied only checks round number and InValue fields at lines 29-34, not LIB values. [4](#0-3) 

5. Execution proceeds through `ProcessNextRound` at line 39, which calls `input.ToRound()`. [5](#0-4) 

6. The input is converted to a Round object via `ToRound()` at lines 25-40, which preserves the malicious LIB values at lines 34-35. [6](#0-5) 

7. The corrupted round is stored to state via `AddRoundInformation` at line 156, which directly sets the round to state storage at line 105. [7](#0-6) 

8. The consensus state now contains a decreased LIB value, violating the monotonicity invariant.

## Impact Explanation

**Critical Severity** - This vulnerability breaks a fundamental consensus invariant with protocol-wide implications:

**Consensus Integrity Violation:**
- The Last Irreversible Block (LIB) height is a core finality indicator - once a block reaches LIB status, it should never become reversible
- Decreasing the LIB effectively reverts finality decisions, creating uncertainty about transaction permanence

**Block Production Manipulation:**
The corrupted LIB directly affects the `GetMaximumBlocksCount` method which uses `ConfirmedIrreversibleBlockRoundNumber` and `ConfirmedIrreversibleBlockHeight` at lines 25-26 to evaluate blockchain mining status. By manipulating these values, an attacker can:
- Force the chain into Severe status (reducing max blocks to 1) by making LIB appear far behind
- Or prevent Severe status when it should trigger, disrupting consensus recovery mechanisms [8](#0-7) 

**Protocol-Wide State Corruption:**
When generating the next round, the corrupted LIB values are propagated forward at lines 244-245 and 292-293, causing persistent state corruption across multiple rounds. [9](#0-8) 

## Likelihood Explanation

**High Likelihood** - The attack is straightforward and accessible to any active miner:

**Attacker Prerequisites:**
- Must be an active miner in the current miner list (obtainable through election)
- No special privileges beyond standard mining rights required
- No economic cost beyond normal block production

**Attack Complexity:**
- Low complexity - attacker simply modifies `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields in the `NextRoundInput` parameter when calling the public `NextRound` method
- The `NextRound` method is public and accepts arbitrary input parameters from the caller

**Detection Difficulty:**
- The malicious transaction passes all validation checks normally since the critical `LibInformationValidationProvider` is not applied
- The `ValidateConsensusAfterExecution` method at lines 83-128 does not validate LIB monotonicity - it only checks round hash consistency and miner replacement [10](#0-9) 

## Recommendation

Add `LibInformationValidationProvider` to the validation pipeline for `NextRound` behavior in the `ValidateBeforeExecution` method:

```csharp
case AElfConsensusBehaviour.NextRound:
    // Is sender's order of next round correct?
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    // Add LIB validation to prevent monotonicity violations
    validationProviders.Add(new LibInformationValidationProvider());
    break;
```

This ensures that LIB values cannot decrease during `NextRound` transitions, maintaining the critical monotonicity invariant across all consensus behavior types.

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_WithDecreasedLIB_ShouldCorruptConsensusState()
{
    // Setup: Initialize consensus with first round
    var initialMiners = GenerateInitialMiners(3);
    await InitializeConsensus(initialMiners);
    
    // Advance to round 2 with normal LIB progression
    var currentRound = await GetCurrentRoundInformation();
    currentRound.ConfirmedIrreversibleBlockHeight = 100;
    currentRound.ConfirmedIrreversibleBlockRoundNumber = 2;
    await UpdateRound(currentRound);
    
    // Attack: Malicious miner calls NextRound with decreased LIB
    var maliciousNextRoundInput = new NextRoundInput
    {
        RoundNumber = 3,
        ConfirmedIrreversibleBlockHeight = 50, // Decreased from 100
        ConfirmedIrreversibleBlockRoundNumber = 1, // Decreased from 2
        RealTimeMinersInformation = { GenerateNextRoundMinersInfo() }
    };
    
    // Execute attack as active miner
    var result = await AEDPoSContractStub.NextRound.SendAsync(maliciousNextRoundInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: LIB has decreased in consensus state
    var corruptedRound = await GetCurrentRoundInformation();
    corruptedRound.ConfirmedIrreversibleBlockHeight.ShouldBe(50); // Should be >= 100
    corruptedRound.ConfirmedIrreversibleBlockRoundNumber.ShouldBe(1); // Should be >= 2
    
    // Verify impact: GetMaximumBlocksCount now uses corrupted LIB
    var maxBlocksCount = await AEDPoSContractStub.GetMaximumBlocksCount.CallAsync(new Empty());
    // The corrupted LIB causes incorrect blockchain status evaluation
}
```

## Notes

This vulnerability specifically affects the `NextRound` consensus behavior. The `UpdateValue` behavior correctly applies `LibInformationValidationProvider` and is not vulnerable. The inconsistency in validation between these two behaviors is the root cause of the issue.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-112)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-67)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L240-257)
```csharp
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```
