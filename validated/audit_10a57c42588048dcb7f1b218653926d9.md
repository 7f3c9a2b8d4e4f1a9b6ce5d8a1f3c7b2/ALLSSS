# Audit Report

## Title
Missing Validation for Negative Resource Amounts Enables Resource Rental Reversal Attack

## Summary
The `InitializeFromParentChain` method in the MultiToken contract lacks validation for negative `ResourceAmount` values. Non-exclusive side chains bypass the CrossChain contract's validation, allowing negative resource amounts to be set during initialization. This causes the `PayRental` calculation to reverse payment direction - side chain creators receive tokens instead of paying rental fees, draining the consensus contract.

## Finding Description

**Root Cause: Inconsistent Validation Across Initialization Paths**

The `ResourceAmount` state variable is defined as `MappedState<string, int>`, which allows negative integer values. [1](#0-0) 

The `InitializeFromParentChain` method directly sets resource amounts without any non-negativity validation. [2](#0-1) 

In contrast, the `UpdateRentedResources` method explicitly validates that amounts are non-negative, demonstrating inconsistent validation logic. [3](#0-2) 

**Why Protection Mechanisms Fail**

On the parent chain, the `AssertValidSideChainCreationRequest` method validates side chain creation requests. For non-exclusive side chains (`IsPrivilegePreserved = false`), the method returns early with the comment "there is no restriction for non-exclusive side chain creation", completely bypassing `AssertValidResourceTokenAmount` validation. [4](#0-3) 

The `AssertValidResourceTokenAmount` validation that would catch negative values checks that resource amounts are greater than zero, but this is never executed for non-exclusive side chains. [5](#0-4) 

However, `InitialResourceAmount` is included in the `ChainInitializationData` for ALL side chains through the `GetChainInitializationData` method, regardless of whether they are exclusive or non-exclusive. [6](#0-5) 

**Exploitation Path**

When the side chain's `PayRental` method executes, it calculates the rental using the potentially negative `ResourceAmount`. With a negative value (e.g., -100), the rental becomes negative. The balance check passes because any positive `availableBalance` is greater than or equal to the negative rental. The code then adds the negative rental to `donates`, and calls `ModifyBalance(creator, symbol, -donates)`. With a negative `donates` value, this becomes `ModifyBalance(creator, symbol, POSITIVE_AMOUNT)`, crediting tokens to the creator instead of debiting them. [7](#0-6) 

The `ModifyBalance` implementation adds the provided amount to the balance, so a positive amount credits tokens to the address. [8](#0-7) 

## Impact Explanation

**HIGH Severity - Direct Fund Theft and Economic Model Compromise**

This vulnerability enables direct theft of tokens from the consensus contract with the following characteristics:

1. **Direct Fund Loss**: The consensus contract loses tokens with every rental period, proportional to `duration × |ResourceAmount| × Rental`. With typical values (10 minutes duration, ResourceAmount=-100, Rental=1000 tokens/minute), the creator gains 1,000,000 tokens per rental period.

2. **Reversed Economic Flow**: The fundamental economic invariant that resource rental must flow FROM side chain creator TO consensus is violated. Instead, tokens flow from consensus TO creator.

3. **Unbounded Accumulation**: The attack repeats automatically every rental period through normal mining operations when `DonateResourceToken` is called, allowing unlimited token theft over time.

4. **Protocol Integrity**: Breaks the core economic model of side chain resource rental, which is essential for the cross-chain ecosystem's sustainability.

## Likelihood Explanation

**MEDIUM Likelihood - Requires Governance Approval But Exploits Validation Gap**

The attack has the following execution requirements:

1. **Entry Point**: Anyone can call `RequestSideChainCreation` to propose a side chain. [9](#0-8) 

2. **Governance Approval**: Side chain creation requires Parliament governance approval through the `ProposeNewSideChain` mechanism. While this adds a governance hurdle, the proposal is for a non-exclusive side chain - a permitted operation that the code explicitly treats as having "no restriction". [10](#0-9) 

3. **Automatic Exploitation**: Once the side chain is initialized with negative `ResourceAmount` values, the attack executes automatically every rental period. The side chain initialization process calls `InitializeFromParentChain` through the `TokenContractInitializationProvider`. [11](#0-10) 

4. **No Defense-in-Depth**: The MultiToken contract has no secondary validation that would catch or prevent the negative resource amounts from being used in rental calculations.

5. **Economic Rationality**: The one-time cost of obtaining governance approval for side chain creation is far outweighed by the ongoing token theft that accumulates unbounded over time, making this highly profitable for an attacker willing to invest in the governance process.

## Recommendation

Add non-negativity validation to the `InitializeFromParentChain` method to match the validation in `UpdateRentedResources`:

```csharp
public override Empty InitializeFromParentChain(InitializeFromParentChainInput input)
{
    Assert(!State.InitializedFromParentChain.Value, "MultiToken has been initialized");
    State.InitializedFromParentChain.Value = true;
    Assert(input.Creator != null, "creator should not be null");
    
    // Add validation for resource amounts
    foreach (var pair in input.ResourceAmount)
    {
        Assert(pair.Value >= 0, "Invalid resource amount: must be non-negative.");
        State.ResourceAmount[pair.Key] = pair.Value;
    }

    foreach (var pair in input.RegisteredOtherTokenContractAddresses)
        State.CrossChainTransferWhiteList[pair.Key] = pair.Value;

    SetSideChainCreator(input.Creator);
    return new Empty();
}
```

Alternatively, extend the validation in `AssertValidSideChainCreationRequest` to check resource amounts for ALL side chains, not just exclusive ones, since resource rental applies to all side chains.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Attacker proposes a non-exclusive side chain (`IsPrivilegePreserved = false`) with negative `InitialResourceAmount` values (e.g., `{"CPU": -100, "RAM": -100}`)
2. Proposal passes Parliament governance approval
3. Side chain is created and initialized with negative resource amounts via `InitializeFromParentChain`
4. When miners call `DonateResourceToken` on the side chain, `PayRental` executes:
   - Calculates `rental = duration * (-100) * 1000 = -1,000,000`
   - Condition `availableBalance >= rental` passes (e.g., `1000 >= -1,000,000`)
   - `donates = -1,000,000`
   - `ModifyBalance(creator, symbol, -(-1,000,000))` credits 1,000,000 to creator
   - `ModifyBalance(consensusContract, symbol, -1,000,000)` debits 1,000,000 from consensus
5. Attack repeats automatically every rental period, draining consensus contract

**Notes**

The validation gap is particularly concerning because the code comment "there is no restriction for non-exclusive side chain creation" suggests intentional design, but this design assumption fails to account for negative resource values that reverse the economic flow. The inconsistency between `UpdateRentedResources` (which validates non-negativity) and `InitializeFromParentChain` (which does not) confirms this is an oversight rather than intentional behavior.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L26-26)
```csharp
    public MappedState<string, int> ResourceAmount { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L14-26)
```csharp
    public override Empty InitializeFromParentChain(InitializeFromParentChainInput input)
    {
        Assert(!State.InitializedFromParentChain.Value, "MultiToken has been initialized");
        State.InitializedFromParentChain.Value = true;
        Assert(input.Creator != null, "creator should not be null");
        foreach (var pair in input.ResourceAmount) State.ResourceAmount[pair.Key] = pair.Value;

        foreach (var pair in input.RegisteredOtherTokenContractAddresses)
            State.CrossChainTransferWhiteList[pair.Key] = pair.Value;

        SetSideChainCreator(input.Creator);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1040-1097)
```csharp
        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
        {
            var donates = 0L;

            var availableBalance = GetBalance(creator, symbol);

            // Try to update owning rental.
            var owningRental = State.OwningRental[symbol];
            if (owningRental > 0)
            {
                // If Creator own this symbol and current balance can cover the debt, pay the debt at first.
                if (availableBalance > owningRental)
                {
                    donates = owningRental;
                    // Need to update available balance,
                    // cause existing balance not necessary equals to available balance.
                    availableBalance = availableBalance.Sub(owningRental);
                    State.OwningRental[symbol] = 0;
                }
            }

            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
            if (availableBalance >= rental) // Success
            {
                donates = donates.Add(rental);
                ModifyBalance(creator, symbol, -donates);
            }
            else // Fail
            {
                // Donate all existing balance. Directly reset the donates.
                donates = GetBalance(creator, symbol);
                State.Balances[creator][symbol] = 0;

                // Update owning rental to record a new debt.
                var own = rental.Sub(availableBalance);
                State.OwningRental[symbol] = State.OwningRental[symbol].Add(own);

                Context.Fire(new RentalAccountBalanceInsufficient
                {
                    Symbol = symbol,
                    Amount = own
                });
            }

            // Side Chain donates.
            var consensusContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
            ModifyBalance(consensusContractAddress, symbol, donates);

            Context.Fire(new RentalCharged()
            {
                Symbol = symbol,
                Amount = donates,
                Payer = creator,
                Receiver = consensusContractAddress
            });
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1114-1127)
```csharp
    public override Empty UpdateRentedResources(UpdateRentedResourcesInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.ResourceAmount)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.ResourceAmount[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L100-137)
```csharp
    private void AssertValidSideChainCreationRequest(SideChainCreationRequest sideChainCreationRequest,
        Address proposer)
    {
        var proposedRequest = State.ProposedSideChainCreationRequestState[Context.Sender];
        Assert(proposedRequest == null || Context.CurrentBlockTime >= proposedRequest.ExpiredTime,
            "Request side chain creation failed.");

        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var allowance = State.TokenContract.GetAllowance.Call(new GetAllowanceInput
        {
            Owner = proposer,
            Spender = Context.Self,
            Symbol = Context.Variables.NativeSymbol
        }).Allowance;

        Assert(
            allowance >= sideChainCreationRequest.LockedTokenAmount,
            "Allowance not enough.");

        Assert(
            sideChainCreationRequest.IndexingPrice >= 0 &&
            sideChainCreationRequest.LockedTokenAmount >= sideChainCreationRequest.IndexingPrice,
            "Invalid chain creation request.");

        if (!sideChainCreationRequest.IsPrivilegePreserved)
            return; // there is no restriction for non-exclusive side chain creation

        AssertValidResourceTokenAmount(sideChainCreationRequest);

        if (!IsPrimaryTokenNeeded(sideChainCreationRequest))
            return;

        // assert primary token to create
        AssertValidSideChainTokenInfo(sideChainCreationRequest.SideChainTokenCreationRequest);
        Assert(sideChainCreationRequest.SideChainTokenInitialIssueList.Count > 0 &&
               sideChainCreationRequest.SideChainTokenInitialIssueList.All(issue => issue.Amount > 0),
            "Invalid side chain token initial issue list.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L139-145)
```csharp
    private void AssertValidResourceTokenAmount(SideChainCreationRequest sideChainCreationRequest)
    {
        var resourceTokenMap = sideChainCreationRequest.InitialResourceAmount;
        foreach (var resourceTokenSymbol in Context.Variables.GetStringArray(PayRentalSymbolListName))
            Assert(resourceTokenMap.ContainsKey(resourceTokenSymbol) && resourceTokenMap[resourceTokenSymbol] > 0,
                "Invalid side chain resource token request.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L360-388)
```csharp
    private SideChainCreationRequestState ProposeNewSideChain(SideChainCreationRequest request, Address proposer)
    {
        var sideChainLifeTimeController = GetSideChainLifetimeController();
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput =
                new CreateProposalInput
                {
                    ContractMethodName = nameof(CreateSideChain),
                    ToAddress = Context.Self,
                    ExpiredTime =
                        Context.CurrentBlockTime.AddSeconds(SideChainCreationProposalExpirationTimePeriod),
                    Params = new CreateSideChainInput { SideChainCreationRequest = request, Proposer = proposer }
                        .ToByteString(),
                    OrganizationAddress = sideChainLifeTimeController.OwnerAddress
                },
            OriginProposer = Context.Sender
        };
        Context.SendInline(sideChainLifeTimeController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);
        var sideChainCreationRequest = new SideChainCreationRequestState
        {
            SideChainCreationRequest = request,
            ExpiredTime = proposalCreationInput.ProposalInput.ExpiredTime,
            Proposer = proposer
        };
        return sideChainCreationRequest;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L516-557)
```csharp
    private ChainInitializationData GetChainInitializationData(SideChainInfo sideChainInfo,
        SideChainCreationRequest sideChainCreationRequest)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var res = new ChainInitializationData
        {
            CreationHeightOnParentChain = sideChainInfo.CreationHeightOnParentChain,
            ChainId = sideChainInfo.SideChainId,
            Creator = sideChainInfo.Proposer,
            CreationTimestamp = sideChainInfo.CreationTimestamp,
            ChainCreatorPrivilegePreserved = sideChainInfo.IsPrivilegePreserved,
            ParentChainTokenContractAddress = State.TokenContract.Value
        };

        var initialConsensusInfo = GetInitialConsensusInformation();
        res.ChainInitializationConsensusInfo = new ChainInitializationConsensusInfo
            { InitialConsensusData = initialConsensusInfo };

        var nativeTokenInformation = GetNativeTokenInfo().ToByteString();
        res.NativeTokenInfoData = nativeTokenInformation;

        var resourceTokenInformation = GetResourceTokenInfo().ToByteString();
        res.ResourceTokenInfo = new ResourceTokenInfo
        {
            ResourceTokenListData = resourceTokenInformation,
            InitialResourceAmount = { sideChainCreationRequest.InitialResourceAmount }
        };

        if (IsPrimaryTokenNeeded(sideChainCreationRequest))
        {
            var sideChainTokenInformation =
                GetTokenInfo(sideChainCreationRequest.SideChainTokenCreationRequest.SideChainTokenSymbol)
                    .ToByteString();
            res.ChainPrimaryTokenInfo = new ChainPrimaryTokenInfo
            {
                ChainPrimaryTokenData = sideChainTokenInformation,
                SideChainTokenInitialIssueList = { sideChainCreationRequest.SideChainTokenInitialIssueList }
            };
        }

        return res;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L90-96)
```csharp
    public override Empty RequestSideChainCreation(SideChainCreationRequest input)
    {
        AssertValidSideChainCreationRequest(input, Context.Sender);
        var sideChainCreationRequestState = ProposeNewSideChain(input, Context.Sender);
        State.ProposedSideChainCreationRequestState[Context.Sender] = sideChainCreationRequestState;
        return new Empty();
    }
```

**File:** src/AElf.Kernel.Token/TokenContractInitializationProvider.cs (L107-119)
```csharp
            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.InitializeFromParentChain),
                Params = new InitializeFromParentChainInput
                {
                    ResourceAmount = { initializationData.ResourceAmount },
                    RegisteredOtherTokenContractAddresses =
                    {
                        initializationData.RegisteredOtherTokenContractAddresses
                    },
                    Creator = initializationData.Creator
                }.ToByteString()
            });
```
