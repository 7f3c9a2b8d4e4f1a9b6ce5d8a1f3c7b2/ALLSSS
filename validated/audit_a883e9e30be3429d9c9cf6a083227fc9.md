# Audit Report

## Title
Vote Contract Option Length Validation Bypass Causes Permanent Option Denial of Service

## Summary
The Vote contract's `Register` method fails to validate option lengths during voting item creation, allowing options exceeding 1024 bytes to be permanently stored in contract state. These oversized options cannot be removed via `RemoveOption` or `RemoveOptions` methods due to validation order issues, nor can they be voted on, resulting in permanent denial of service on voting item management and state pollution.

## Finding Description

The vulnerability stems from inconsistent option length validation across the Vote contract's lifecycle methods.

**Root Cause - Missing Validation During Registration:**

The `Register` method directly copies input options to the voting item without any length validation. [1](#0-0) 

The validation helper `AssertValidNewVotingItem` only checks voting item existence, timestamp validity, and snapshot numbers, but completely omits option length validation. [2](#0-1) 

The protocol defines the option length limit as 1024 bytes. [3](#0-2) 

**Blocking Validation in RemoveOption:**

The `RemoveOption` method validates option length BEFORE checking if the option exists in the voting item. [4](#0-3)  This validation order prevents removal of any option exceeding 1024 bytes, even if it legitimately exists in state, causing the method to revert with "Invalid input" before reaching the existence check.

**RemoveOptions Has the Same Issue:**

The `RemoveOptions` method checks existence first, then validates length before the actual removal operation. [5](#0-4)  While the order differs, it still fails when attempting to remove oversized options because the length assertion executes before the removal, reverting the transaction.

**Proper Validation in Other Methods:**

In contrast, `AddOption` properly validates option lengths through the `AssertOption` helper before adding options. [6](#0-5) [7](#0-6) 

Similarly, the `Vote` method validates option lengths before accepting votes. [8](#0-7) 

## Impact Explanation

**Operational Denial of Service:**
- Sponsors who register voting items with options exceeding 1024 bytes permanently lose the ability to remove those options through any available contract method
- The voting item becomes polluted with unremovable, invalid options that cannot be cleaned up
- No recovery mechanism exists since both `RemoveOption` and `RemoveOptions` enforce the length check before allowing removal

**Unusable Options:**
- Users cannot vote for options exceeding 1024 bytes because the `Vote` method validates and rejects them
- These options exist in the voting item state but are completely non-functional for voting purposes
- The voting item sponsor cannot fix the issue by removing invalid options

**State Pollution and Resource Exhaustion:**
- Invalid options persist indefinitely in contract state, consuming storage resources
- The protocol enforces a maximum of 64 options per voting item [9](#0-8)  - invalid options could fill these slots, preventing addition of valid options
- Once 64 invalid options are registered, the voting item becomes completely unusable

**Protocol Integrity Violation:**
- The Vote contract is a system contract used across the AElf ecosystem for governance and decision-making
- Permanent unremovable options violate the expected contract behavior and sponsor control guarantees
- Breaks the invariant that sponsors should have full control over their voting items' option management

## Likelihood Explanation

**High Likelihood:**
- The `Register` method is a public entry point accessible to all users without special permissions [10](#0-9) 
- No preconditions required beyond standard transaction fees and token whitelist membership
- No validation error occurs during registration, making the issue non-obvious until removal is attempted
- Any user can trigger this condition by simply providing option strings exceeding 1024 bytes

**Realistic Attack Scenarios:**

1. **Accidental Trigger:** Developers integrating with the Vote contract using programmatically generated option strings (e.g., Base64-encoded data, JSON structures, or detailed descriptions) may exceed the limit without realizing it due to lack of validation feedback during registration

2. **Intentional DoS Attack:** A malicious actor could intentionally create voting items with 64 oversized options to:
   - Permanently lock the voting item in an unusable state
   - Consume contract storage resources
   - Prevent legitimate use of the voting functionality
   - Damage the reputation of the Vote contract system

3. **Integration Errors:** External contracts or applications calling the Vote contract may pass option strings exceeding 1024 bytes without proper client-side validation, resulting in permanently unmanageable voting items

## Recommendation

**Immediate Fix:**
Add option length validation in the `Register` method or `AssertValidNewVotingItem` helper to prevent registration of invalid options:

```csharp
private Hash AssertValidNewVotingItem(VotingRegisterInput input)
{
    // Use input without options and sender's address to calculate voting item id.
    var votingItemId = input.GetHash(Context.Sender);
    Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");
    
    // Validate option lengths
    foreach (var option in input.Options)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, 
            $"Option length exceeds maximum of {VoteContractConstants.OptionLengthLimit} bytes.");
    }
    
    // total snapshot number can't be 0. At least one epoch is required.
    if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;
    Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");
    
    Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");
    return votingItemId;
}
```

**Alternative Recovery Mechanism:**
Consider adding a privileged recovery method that allows removal of invalid options without length validation, or modify `RemoveOption` to check existence before validating length:

```csharp
public override Empty RemoveOption(RemoveOptionInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
    Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
    // Only validate length for options that don't already exist in the item
    // This allows removal of previously added invalid options
    votingItem.Options.Remove(input.Option);
    State.VotingItems[votingItem.VotingItemId] = votingItem;
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task VoteContract_Register_And_Remove_OversizedOption_DoS_Test()
{
    // Create an option that exceeds the 1024 byte limit
    var oversizedOption = new string('A', VoteContractConstants.OptionLengthLimit + 100);
    
    var startTime = TimestampHelper.GetUtcNow();
    var input = new VotingRegisterInput
    {
        TotalSnapshotNumber = 1,
        EndTimestamp = startTime.AddDays(10),
        StartTimestamp = startTime,
        Options = { "ValidOption1", "ValidOption2", oversizedOption },
        AcceptedCurrency = TestTokenSymbol,
        IsLockToken = true
    };
    
    // Step 1: Register voting item WITH oversized option - this SUCCEEDS
    var registerResult = await VoteContractStub.Register.SendAsync(input);
    registerResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Get the voting item ID
    input.Options.Clear();
    var votingItemId = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(input), 
        HashHelper.ComputeFrom(DefaultSender)
    );
    
    // Verify the oversized option was stored
    var votingItem = await VoteContractStub.GetVotingItem.CallAsync(
        new GetVotingItemInput { VotingItemId = votingItemId }
    );
    votingItem.Options.Count.ShouldBe(3);
    votingItem.Options.ShouldContain(oversizedOption);
    
    // Step 2: Try to vote for the oversized option - this FAILS
    var voter = Accounts[11].KeyPair;
    var voteResult = await VoteWithException(voter, votingItemId, oversizedOption, 100);
    voteResult.Status.ShouldBe(TransactionResultStatus.Failed);
    voteResult.Error.ShouldContain("Invalid input");
    
    // Step 3: Try to remove the oversized option using RemoveOption - this FAILS
    var removeResult = await VoteContractStub.RemoveOption.SendWithExceptionAsync(
        new RemoveOptionInput
        {
            VotingItemId = votingItemId,
            Option = oversizedOption
        }
    );
    removeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    removeResult.TransactionResult.Error.ShouldContain("Invalid input");
    
    // Step 4: Try to remove using RemoveOptions (plural) - this ALSO FAILS
    var removeMultipleResult = await VoteContractStub.RemoveOptions.SendWithExceptionAsync(
        new RemoveOptionsInput
        {
            VotingItemId = votingItemId,
            Options = { oversizedOption }
        }
    );
    removeMultipleResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    removeMultipleResult.TransactionResult.Error.ShouldContain("Invalid input");
    
    // Verify the oversized option is still in the voting item - PERMANENT DOS
    var finalVotingItem = await VoteContractStub.GetVotingItem.CallAsync(
        new GetVotingItemInput { VotingItemId = votingItemId }
    );
    finalVotingItem.Options.ShouldContain(oversizedOption);
    finalVotingItem.Options.Count.ShouldBe(3); // Unremovable invalid option persists
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-20)
```csharp
    public override Empty Register(VotingRegisterInput input)
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L49-49)
```csharp
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L284-284)
```csharp
        AssertOption(votingItem, input.Option);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L294-294)
```csharp
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L307-308)
```csharp
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L332-334)
```csharp
            Assert(votingItem.Options.Contains(option), "Option doesn't exist.");
            Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
            votingItem.Options.Remove(option);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-365)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L380-380)
```csharp
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-5)
```csharp
    public const int MaximumOptionsCount = 64;
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L6-6)
```csharp
    public const int OptionLengthLimit = 1024;
```
