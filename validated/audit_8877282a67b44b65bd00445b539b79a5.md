# Audit Report

## Title
Time Slot Validation Allows Malicious Round Crafting with Biased Mining Intervals

## Summary
The AEDPoS consensus contract's `CheckRoundTimeSlots()` validation uses an overly permissive 100% tolerance that allows mining intervals ranging from 0 to 2× the base interval. A malicious extra block producer can exploit this by crafting Round data with manipulated `ExpectedMiningTime` values that pass validation but cause consensus disruption through either DoS attacks (impossibly short intervals) or severe performance degradation (excessively long intervals).

## Finding Description

The AEDPoS consensus system fails to properly validate Round time slot integrity during NextRound transitions, breaking the security guarantee that all miners receive equal time slots for block production.

**Root Cause - Permissive Tolerance Check:**

The time slot validation check at [1](#0-0)  allows any interval where `Math.Abs(miningInterval - baseMiningInterval) ≤ baseMiningInterval`, which mathematically permits intervals from 0ms to 2×baseMiningInterval. This validation is invoked during consensus header validation at [2](#0-1) .

**Missing Protection - No Round Regeneration Check:**

When processing NextRound transactions, the contract directly converts the input at [3](#0-2)  and stores it to state at [4](#0-3)  without verifying it matches what the contract would legitimately generate.

**Mining Interval Calculation Dependency:**

The mining interval used throughout consensus operations is calculated from the first two miners' ExpectedMiningTime values at [5](#0-4) .

**Ineffective After-Execution Validation:**

The after-execution validation at [6](#0-5)  compares the header Round hash with the state Round hash, but since the malicious Round was already stored to state during execution at [7](#0-6) , they are identical.

**Attack Execution Path:**

1. Extra block producer generates consensus data through GetConsensusExtraDataForNextRound at [8](#0-7) 
2. Attacker modifies `Round.RealTimeMinersInformation[*].ExpectedMiningTime` values before including in block header
3. Modified Round passes CheckRoundTimeSlots validation (within 0-2× tolerance)
4. ProcessNextRound stores malicious Round to state
5. ValidateConsensusAfterExecution passes because it compares identical data

## Impact Explanation

The manipulated mining interval directly impacts consensus operations through GetMiningInterval(), which affects time slot validation and tiny block production limits at [9](#0-8) .

**Attack Scenarios:**

1. **DoS Attack (Impossibly Short Intervals):** Setting first two miners 1ms apart creates baseMiningInterval=1ms. This makes TinyBlockSlotInterval = 1ms/8 = 0.125ms and DefaultBlockMiningLimit = 0.075ms, physically impossible for miners to meet, halting consensus.

2. **Consensus Slowdown (Excessively Long Intervals):** Setting first two miners 8000ms+ apart allows intervals up to 16000ms, with TinyBlockSlotInterval = 1000ms and DefaultBlockMiningLimit = 600ms, drastically reducing network throughput.

**Affected Parties:**
- All network participants experience consensus disruption
- Honest miners unable to produce blocks lose rewards
- Users face transaction delays or complete service outage

**Severity:** HIGH - A single malicious miner can compromise consensus integrity for an entire round, causing network-wide DoS or severe performance degradation.

## Likelihood Explanation

**Attacker Requirements:**
- Must be a miner in the current miner list
- Must become the extra block producer for a round

The extra block producer rotates pseudo-randomly based on signatures at [10](#0-9) .

**Attack Complexity:**
LOW - The attacker simply modifies ExpectedMiningTime values in the Round data structure before including it in the block header. Legitimate round generation at [11](#0-10)  shows equal spacing based on mining interval.

**Trigger Conditions:**
NextRound behavior is triggered when miners need to terminate the current round, as determined by [12](#0-11) .

**Detection/Operational Constraints:**
- No cryptographic binding between legitimate Round generation and block production
- Validation only checks mathematical constraints, not semantic correctness of time slots
- Difficult to detect without regenerating and comparing the expected Round

**Probability:** MEDIUM-HIGH - Given the rotating nature of extra block producers, any compromised miner will eventually have opportunity to exploit this vulnerability. The attack is repeatable every time they become the extra block producer.

## Recommendation

Implement Round regeneration verification during NextRound validation:

1. In `TimeSlotValidationProvider.ValidateHeaderInformation`, regenerate the expected next Round using the current round state and compare it against the provided Round.

2. Add strict bounds checking on mining intervals:
   - Define minimum acceptable mining interval (e.g., 500ms)
   - Define maximum acceptable mining interval (e.g., 6000ms)
   - Reject Rounds with intervals outside these bounds

3. Strengthen the tolerance check in `CheckRoundTimeSlots()` from 100% to a more reasonable value (e.g., 10-20%) to account for network delays while preventing abuse.

4. Add validation in `ProcessNextRound` to regenerate the expected Round and verify that `ExpectedMiningTime` values match (within acceptable tolerance) before storing to state.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task MaliciousExtraBlockProducer_CanCraftShortIntervals_CausingDoS()
{
    // Setup: Initialize consensus with 3 miners
    var miners = GetMiners(3);
    await InitializeConsensus(miners);
    
    // Get legitimate next round data
    var legitimateRound = await GetNextRoundData();
    
    // Malicious extra block producer modifies ExpectedMiningTime
    var maliciousRound = legitimateRound.Clone();
    var firstMiner = maliciousRound.RealTimeMinersInformation.Values.First(m => m.Order == 1);
    var secondMiner = maliciousRound.RealTimeMinersInformation.Values.First(m => m.Order == 2);
    
    // Set impossibly short interval: 1ms between first two miners
    secondMiner.ExpectedMiningTime = firstMiner.ExpectedMiningTime.AddMilliseconds(1);
    
    // Adjust remaining miners to maintain relative spacing
    foreach (var miner in maliciousRound.RealTimeMinersInformation.Values.Where(m => m.Order > 2))
    {
        miner.ExpectedMiningTime = firstMiner.ExpectedMiningTime.AddMilliseconds(miner.Order);
    }
    
    // Submit malicious Round via NextRound
    var result = await SubmitNextRound(maliciousRound);
    
    // Verify: Round is accepted despite malicious intervals
    result.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Mining interval is now 1ms
    var currentRound = await GetCurrentRound();
    currentRound.GetMiningInterval().ShouldBe(1);
    
    // Verify: TinyBlockSlotInterval becomes impossibly short (0.125ms)
    var tinyBlockSlot = currentRound.GetMiningInterval() / 8;
    tinyBlockSlot.ShouldBe(0); // Rounds down to 0
    
    // Impact: Honest miners cannot produce blocks in 0.125ms, consensus halts
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L53-53)
```csharp
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L17-17)
```csharp
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L110-110)
```csharp
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L105-105)
```csharp
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L42-49)
```csharp
        private int TinyBlockSlotInterval => MiningInterval.Div(TinyBlocksCount);

        protected int MinersCount => CurrentRound.RealTimeMinersInformation.Count;

        /// <summary>
        ///     Give 3/5 of producing time for mining by default.
        /// </summary>
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```
