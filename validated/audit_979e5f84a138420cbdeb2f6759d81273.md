# Audit Report

## Title
InValue Grinding Attack Enables Mining Order Manipulation in AEDPoS Consensus

## Summary
The AEDPoS consensus contract fails to cryptographically verify that InValues are generated using the legitimate algorithm. Miners can substitute arbitrary hash values as InValues to predetermine their mining order in future rounds, violating the fairness guarantees of the commit-reveal randomness scheme.

## Finding Description

The AEDPoS consensus implements a commit-reveal scheme where miners commit to `OutValue = Hash(InValue)` and later reveal the InValue. The validation logic only checks hash consistency without verifying HOW the InValue was generated. [1](#0-0) 

The validation performs only: `HashHelper.ComputeFrom(previousInValue) == previousOutValue`, with no cryptographic proof that the InValue was generated correctly.

The revealed InValue is used to calculate a signature via XOR operations with previous round signatures: [2](#0-1) 

This signature directly determines the miner's position in the next round through modulo arithmetic: [3](#0-2) 

**Attack Mechanism:**

A malicious miner can exploit this by:

1. Trying thousands of random hash values as InValue candidates off-chain
2. For each candidate, calculating: `signature = XOR(InValue, known_round_signatures)` and `order = (signature.ToInt64() % minersCount) + 1`
3. Selecting an InValue yielding a favorable position (e.g., order 1-2)
4. Committing `OutValue = Hash(chosen_InValue)` when producing their block
5. Later revealing the chosen InValue, which passes validation

While honest nodes generate InValues deterministically by signing round data: [4](#0-3) 

The contract never verifies this signature relationship on-chain. The signature calculation from the InValue occurs during block production: [5](#0-4) 

**Distinction from RandomNumber VRF:**

The AEDPoS contract does implement VRF verification for a separate `RandomNumber` field used for block-level randomness: [6](#0-5) 

However, this VRF verification is NOT applied to the InValue/OutValue mechanism that determines mining order, leaving it vulnerable to grinding.

## Impact Explanation

**Economic Harm:** Miners with early positions (order 1-2) process transactions first in each round, enabling them to collect more lucrative transaction fees. Over extended periods, grinding miners accumulate significantly more rewards than honest miners, creating unfair wealth distribution.

**Consensus Integrity:** The commit-reveal scheme is designed to ensure unpredictable, fair order selection through collective randomness. This vulnerability allows systematic manipulation, breaking the core security assumption that no single miner can predict or control their future position.

**Centralization Risk:** Grinding creates a "rich get richer" dynamic where technically sophisticated miners gain persistent competitive advantages. This economic inequality threatens network decentralization as grinding miners accumulate disproportionate influence.

**Detection Impossibility:** The on-chain contract cannot distinguish ground InValues from legitimate ones since both satisfy `Hash(InValue) == OutValue`. There is no VRF proof or cryptographic signature verification to detect the attack.

## Likelihood Explanation

**Attacker Profile:** Any active miner running their own node software can execute this attack.

**Technical Barriers:** LOW - SHA256 hashing is extremely fast (millions of hashes per second on consumer hardware). A miner can try thousands of InValue candidates in milliseconds before committing their OutValue. The attack requires only modification of the off-chain InValue generation logic.

**Economic Incentive:** HIGH - Increased transaction fee revenue with zero risk of detection or penalty. The grinding is entirely off-chain and indistinguishable from legitimate behavior on-chain.

**Operational Constraints:** NONE - The contract validation logic cannot detect grinding since it only checks hash consistency, not generation method. The attack is most effective for miners producing blocks late in a round (when most signatures are visible), but provides advantage even with partial signature knowledge.

**Feasibility:** Highly practical. The modulo-based order calculation means even small signature manipulation can yield significant positional advantages. With fast hashing hardware, miners can exhaustively search the space of favorable InValues.

## Recommendation

Implement cryptographic verification of InValue generation using Verifiable Random Functions (VRF), similar to the existing `RandomNumber` verification:

1. **Require VRF Proof:** Miners must provide a VRF proof alongside their InValue that demonstrates it was generated by signing specific round data with their private key.

2. **On-Chain Verification:** The `UpdateValueValidationProvider` should verify the VRF proof using `Context.ECVrfVerify()` with the miner's public key, similar to the existing verification in `ProcessConsensusInformation`.

3. **Bind InValue to Round Data:** The VRF input (alpha) should include the round number and previous round hash to prevent pre-computation attacks.

4. **Unified Randomness:** Consider consolidating the separate `RandomNumber` and `InValue/OutValue` mechanisms into a single VRF-verified randomness source to reduce complexity.

The validation should reject any UpdateValue transaction where the InValue cannot be proven to derive from the miner's VRF signing of the round data.

## Proof of Concept

```csharp
// Attacker code (off-chain node modification)
public Hash GrindForFavorableOrder(Round previousRound, int desiredOrder, int minersCount)
{
    // Get known signatures from previous round
    var previousSignatures = previousRound.RealTimeMinersInformation.Values
        .Aggregate(Hash.Empty, (current, miner) => 
            HashHelper.XorAndCompute(current, miner.Signature));
    
    // Try random InValue candidates
    for (int nonce = 0; nonce < 1000000; nonce++)
    {
        var candidateInValue = HashHelper.ComputeFrom($"grind_{nonce}");
        
        // Calculate what signature this would produce
        var signature = HashHelper.XorAndCompute(candidateInValue, previousSignatures);
        
        // Calculate resulting order
        var order = Math.Abs(signature.ToInt64() % minersCount) + 1;
        
        // If favorable, use this InValue
        if (order == desiredOrder)
        {
            // Commit OutValue = Hash(candidateInValue)
            var outValue = HashHelper.ComputeFrom(candidateInValue);
            
            // This passes validation since Hash(candidateInValue) == outValue
            return candidateInValue;
        }
    }
    
    // Fallback to honest generation if grinding fails
    return GenerateHonestInValue();
}

// The contract accepts this ground InValue because validation only checks:
// HashHelper.ComputeFrom(previousInValue) == previousOutValue ✓
// No VRF verification performed ✗
```

**Notes**

The vulnerability stems from a mismatch between off-chain InValue generation (which uses cryptographic signing) and on-chain validation (which only checks hash consistency). While the system includes VRF infrastructure for the `RandomNumber` field, this protection is not applied to the InValue/OutValue mechanism that actually determines mining order. This creates an exploitable gap where miners can grind for favorable positions without detection.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L186-191)
```csharp
    private async Task<Hash> GenerateInValueAsync(IMessage message)
    {
        var data = HashHelper.ComputeFrom(message.ToByteArray());
        var bytes = await _accountService.SignAsync(data.ToByteArray());
        return HashHelper.ComputeFrom(bytes);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L88-93)
```csharp
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-78)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
```
