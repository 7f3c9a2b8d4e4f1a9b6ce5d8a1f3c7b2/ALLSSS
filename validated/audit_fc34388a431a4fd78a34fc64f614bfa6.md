# Audit Report

## Title
Missing Miner List Validation in NextRound Transitions Allows Consensus Disruption via Inflated Miner Count

## Summary
The AEDPoS consensus validation logic fails to verify that the miner set in a NextRound transition matches the current round's authorized miners, allowing a malicious miner to inject fake entries that corrupt consensus order assignments and create persistent block production gaps.

## Finding Description

The vulnerability exists in the NextRound validation flow where validators check internal consistency but never validate miner set membership against the trusted current state.

**Root Cause - Missing Miner Set Validation:**

The `NextRoundMiningOrderValidationProvider` only verifies that the count of miners with `FinalOrderOfNextRound > 0` equals those with `OutValue != null` in the provided round. [1](#0-0) 

For a freshly generated next round, all miners have these fields as null/0, so the validation passes as `0 == 0`. [2](#0-1) 

The `RoundTerminateValidationProvider` only checks that the round number increments by 1 and all `InValue` fields are null. [3](#0-2) 

**Critical Gap:** The validation context provides both `BaseRound` (trusted current state) and `ProvidedRound` (from block header) [4](#0-3) , but no validator compares the pubkey set between them.

**Exploitation Path:**

1. Malicious miner generates legitimate next round via `GenerateNextRoundInformation` [5](#0-4) 

2. Before including in block, attacker modifies `nextRound.RealTimeMinersInformation` to add fake `MinerInRound` entries with default values

3. Validation passes - `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` check internal consistency only [6](#0-5) 

4. Corrupted round is stored directly via `AddRoundInformation` [7](#0-6) 

5. Fake miners are propagated in subsequent rounds as `GenerateNextRoundInformation` includes all miners from current round [8](#0-7) 

6. Fake miners are assigned time slots and orders in next round generation [9](#0-8) 

## Impact Explanation

**Consensus Integrity Breach:**
The inflated miner count directly corrupts the deterministic extra block producer calculation. The modulus operation `GetAbsModulus(sigNum, blockProducerCount) + 1` produces incorrect results when `blockProducerCount` includes fake miners. [10](#0-9) 

**Operational Disruption:**
Fake miners are assigned time slots in the round schedule but cannot produce blocks, creating persistent gaps in block production. Each fake entry represents a missed time slot that delays network progress and affects time-sensitive operations.

**Persistent State Corruption:**
The `GenerateNextRoundInformation` method propagates all miners from the current round's `RealTimeMinersInformation` to the next round. [11](#0-10)  Once injected, fake miners persist through all subsequent NextRound transitions until a NextTerm transition rebuilds the miner list from election results. [12](#0-11) 

**Severity:** High - A single malicious miner can disrupt consensus order assignments for all validators and degrade block production reliability until the next term transition.

## Likelihood Explanation

**Attacker Requirements:**
- Must be a current authorized miner (moderate barrier - requires election or initial authorization)
- Must be selected to produce a NextRound transition block (periodic opportunity that occurs every round)
- Must control their node software to intercept and modify the consensus extra data (technically straightforward)

**Attack Feasibility:**
The attack is trivial to execute - the malicious miner simply adds entries to the `RealTimeMinersInformation` dictionary with default field values before including the data in their block. No complex cryptographic operations, state manipulation, or timing coordination is required.

**Detection Difficulty:**
The corrupted state appears valid to all existing validators. Fake miners manifest only as missed time slots during their assigned windows, which could easily be mistaken for legitimate network connectivity issues or node failures rather than recognized as an active attack.

**Probability:** High - Any malicious miner can exploit this gap trivially, and the validation logic provides no defense against it.

## Recommendation

Add a miner set membership validation provider for NextRound transitions:

```csharp
public class MinerSetValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseMiners = validationContext.BaseRound.RealTimeMinersInformation.Keys.ToHashSet();
        var providedMiners = validationContext.ProvidedRound.RealTimeMinersInformation.Keys.ToHashSet();
        
        // For NextRound (not NextTerm), miner set should match exactly or be a subset
        // (accounting for possible evil miner replacement mid-term)
        if (!providedMiners.IsSubsetOf(baseMiners))
        {
            validationResult.Message = "Provided round contains unauthorized miners.";
            return validationResult;
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Add this validator to the validation pipeline in `AEDPoSContract_Validation.cs` for the NextRound case:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new MinerSetValidationProvider());
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

## Proof of Concept

A PoC would require setting up an AElf test environment with multiple miners, then having one malicious miner:

1. Intercept the `GetConsensusBlockExtraData` call for NextRound behavior
2. Modify the returned `nextRound.RealTimeMinersInformation` to add a fake miner entry with a generated pubkey and default values
3. Include the modified round in the NextRoundInput transaction and block header
4. Observe that validation passes and the fake miner is stored to state
5. Verify in subsequent rounds that the fake miner is assigned a time slot but cannot produce blocks
6. Confirm the fake miner persists through NextRound transitions until NextTerm

The test would demonstrate that the current validators fail to detect and reject the injected fake miner entry.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-23)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L42-55)
```csharp
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L119-122)
```csharp
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-34)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L20-27)
```csharp
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```
