# Audit Report

## Title
Missing Dictionary Key Validation in CrossChainCreate Causes KeyNotFoundException and DoS

## Summary
The `CrossChainCreate` method in the NFT contract directly accesses `ExternalInfo` dictionary keys without validation, causing `KeyNotFoundException` when tokens lack required NFT metadata. This enables permanent DoS attacks on cross-chain NFT protocol creation by pre-creating tokens with NFT collection symbol formats but incomplete metadata.

## Finding Description

The vulnerability exists in the `CrossChainCreate` method where it directly accesses dictionary keys without checking if they exist: [1](#0-0) 

The method verifies token existence but never validates that required NFT metadata keys (`aelf_nft_base_uri` and `aelf_nft_token_id_reuse`) are present in `ExternalInfo`: [2](#0-1) 

**Root Cause:**

Normal NFT protocol creation through `Create()` guarantees these metadata keys are added to `ExternalInfo`: [3](#0-2) 

However, the MultiToken contract's `Create` method accepts arbitrary `ExternalInfo` without enforcing NFT-specific metadata requirements: [4](#0-3) 

The MultiToken contract determines symbol types based purely on format - symbols ending in "-0" are treated as NFT collections: [5](#0-4) [6](#0-5) 

This allows anyone with token creation permissions to create tokens with NFT collection symbol formats (e.g., "XXART-0") but incomplete `ExternalInfo`. When these tokens are synced to sidechains via `CrossChainCreateToken`, the incomplete `ExternalInfo` is preserved: [7](#0-6) 

**Why Existing Protections Fail:**

The `CrossChainCreate` method is a public method with no authorization checks: [8](#0-7) 

The MultiToken contract itself uses defensive `ContainsKey` checks before accessing `ExternalInfo` dictionary entries: [9](#0-8) 

However, the NFT contract does not follow this defensive pattern in `CrossChainCreate`.

## Impact Explanation

**Concrete Harm:**
- **Complete DoS of NFT Protocol Creation**: Attackers can permanently block legitimate NFT protocols from being created on sidechains by pre-creating tokens with matching symbols but incomplete metadata
- **No Recovery Mechanism**: Once a token with incomplete metadata exists and is synced cross-chain, the NFT protocol cannot be created on sidechains for that symbol
- **Cross-Chain Griefing**: Any token created without proper NFT metadata will cause failures when users call `CrossChainCreate` on sidechains
- **Protocol Availability Breach**: All calls to `CrossChainCreate` for affected symbols throw unhandled `KeyNotFoundException`, breaking cross-chain NFT synchronization

**Who is Affected:**
- NFT protocol creators attempting to sync protocols to sidechains
- Sidechain users unable to access NFT protocols
- The broader AElf ecosystem's cross-chain NFT functionality

**Severity Justification:**
High severity because this vulnerability enables complete denial of service for cross-chain NFT protocol creation with permanent impact and no recovery path.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must have permission to call `TokenContract.Create()` through either being in the create whitelist OR owning a seed NFT for the desired symbol [10](#0-9) 

**Attack Complexity:**
Low - The attack requires only:
1. One call to `TokenContract.Create()` with an NFT collection symbol format (e.g., "XXART-0") and empty/incomplete `ExternalInfo`
2. Natural cross-chain token synchronization occurs automatically
3. Any user calling `CrossChainCreate()` triggers the `KeyNotFoundException`

**Feasibility:**
- Seed NFTs are obtainable through normal protocol mechanisms
- No special timing or state requirements
- Attack is difficult to detect until `CrossChainCreate()` is called
- Standard cross-chain synchronization propagates the vulnerability automatically

**Probability:** Medium-High - Seed NFTs are accessible through normal means, the attack is straightforward, and clear griefing motivation exists for competitors' NFT protocols.

## Recommendation

Add defensive key existence checks before accessing `ExternalInfo` dictionary in the `CrossChainCreate` method:

```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    MakeSureTokenContractAddressSet();
    InitialNFTTypeNameMap();
    Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
    {
        Symbol = input.Symbol
    });
    if (string.IsNullOrEmpty(tokenInfo.Symbol))
        throw new AssertionException($"Token info {input.Symbol} not exists.");

    // Add defensive checks for required NFT metadata keys
    Assert(tokenInfo.ExternalInfo != null && 
           tokenInfo.ExternalInfo.Value.ContainsKey(NftBaseUriMetadataKey), 
           "NFT base URI metadata is required.");
    Assert(tokenInfo.ExternalInfo.Value.ContainsKey(NftTokenIdReuseMetadataKey), 
           "NFT token ID reuse metadata is required.");

    var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
    var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
    // ... rest of the method
}
```

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreate_WithIncompleteMetadata_ShouldThrowKeyNotFoundException()
{
    // Step 1: Create a token with NFT collection symbol format but incomplete ExternalInfo
    var incompleteExternalInfo = new ExternalInfo();
    // Deliberately omit aelf_nft_base_uri and aelf_nft_token_id_reuse keys
    
    var createResult = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "XXART-0", // NFT collection format
        TokenName = "Attack Token",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = DefaultAddress,
        IsBurnable = true,
        IssueChainId = ChainId,
        ExternalInfo = incompleteExternalInfo // Incomplete metadata
    });
    
    // Step 2: Attempt CrossChainCreate on sidechain (simulated)
    // This should throw KeyNotFoundException when accessing missing keys
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
        {
            Symbol = "XXART-0"
        });
    });
    
    // Verify KeyNotFoundException is thrown
    exception.Message.ShouldContain("KeyNotFoundException");
}
```

## Notes

This vulnerability demonstrates a critical gap in cross-chain validation logic. While the MultiToken contract properly uses defensive dictionary access patterns, the NFT contract assumes all NFT collection tokens will have complete metadata. The lack of validation in `CrossChainCreate` combined with the permissive `ExternalInfo` handling in `MultiToken.Create` creates a permanent DoS attack vector against cross-chain NFT protocol synchronization.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L7-9)
```csharp
public partial class NFTContract : NFTContractContainer.NFTContractBase
{
    /// <summary>
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-79)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L87-88)
```csharp
        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L196-199)
```csharp
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L501-501)
```csharp
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L19-22)
```csharp
    public const char NFTSymbolSeparator = '-';
    public const int NFTSymbolMaxLength = 30;
    public const string UserContractMethodFeeKey = "UserContractMethodFee";
    public const string CollectionSymbolSuffix = "0";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L326-331)
```csharp
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.LockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.LockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
```
