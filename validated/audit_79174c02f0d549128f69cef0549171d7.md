# Audit Report

## Title
Missing Validation of Decrypted Secret Pieces Allows Consensus Randomness Manipulation

## Summary
The AEDPoS consensus mechanism's secret sharing implementation fails to validate that reconstructed InValues from decrypted pieces match the originally committed OutValues. Malicious miners can submit arbitrary bytes as "decrypted" pieces to manipulate signature calculations and miner ordering in subsequent rounds, breaking the VRF randomness property of the consensus mechanism.

## Finding Description

The secret sharing mechanism uses a commit-reveal scheme where miners commit `OutValue = Hash(InValue)` and later reveal the `InValue` through Shamir's Secret Sharing. However, critical validation is missing.

**Vulnerable Entry Point:**

The `UpdateLatestSecretPieces()` function accepts and stores decrypted pieces from miners without any authenticity validation: [1](#0-0) 

This function iterates through provided decrypted pieces and stores them directly in the round state. A malicious miner controlling their off-chain node software can provide arbitrary bytes instead of actual decryptions.

**Missing Validation in InValue Reconstruction:**

When `RevealSharedInValues()` reconstructs a miner's InValue from collected decrypted pieces, it performs no validation against the committed OutValue: [2](#0-1) 

The function reconstructs the InValue using `SecretSharingHelper.DecodeSecret()` and directly sets it as `PreviousInValue` without verifying that `Hash(revealedInValue) == anotherMinerInPreviousRound.OutValue`.

**Impact on Consensus:**

The fake `PreviousInValue` is later used in `SupplyCurrentRoundInformation()` to calculate signatures for miners who didn't produce blocks: [3](#0-2) 

This signature directly affects miner ordering through the `CalculateSignature()` method: [4](#0-3) 

The resulting signature value determines `FinalOrderOfNextRound` through modulo calculation: [5](#0-4) 

**Why Existing Protections Fail:**

The `UpdateValueValidationProvider` only validates the block producer's own `PreviousInValue` against their previous `OutValue`, not other miners' revealed values: [6](#0-5) 

The ECDH+AES encryption provides confidentiality but not authenticity - there's no mechanism to cryptographically prove a claimed decryption is correct without the recipient's private key.

## Impact Explanation

**Consensus Integrity Breach:**
- Malicious miners can manipulate which miners get assigned to which time slots in subsequent rounds
- This breaks the unpredictability guarantee of the VRF-based consensus mechanism
- Attackers can increase their own mining frequency or strategically favor/punish specific miners

**Concrete Attack Scenario:**
1. Round N: Miner A commits `OutValue_A = Hash(InValue_A)` and shares encrypted pieces
2. Round N+1: Malicious Miner B submits arbitrary fake bytes as the "decrypted" piece for Miner A instead of performing actual decryption
3. Round N+1: `RevealSharedInValues()` uses these fake pieces to reconstruct an incorrect `InValue_A'`
4. Round N+2: If Miner A didn't mine in Round N+1, `SupplyCurrentRoundInformation()` uses the fake `InValue_A'` to calculate Miner A's signature
5. Result: Miner A gets assigned the wrong order in the next round based on the manipulated signature

**Protocol Damage:**
- Violates the "correct round transitions and miner schedule integrity" invariant
- Undermines fairness of block production opportunities
- Enables strategic manipulation of consensus order for economic gain
- Network security is compromised as consensus randomness is foundational to AEDPoS

## Likelihood Explanation

**Attacker Capabilities:**
- Must be a current miner (realistic - these are elected positions)
- Requires secret sharing to be enabled (default configuration)
- No special privileges needed beyond normal miner status

**Attack Complexity:**
- Low complexity - attacker modifies their off-chain `SecretSharingService` to submit arbitrary bytes as "decrypted" pieces: [7](#0-6) 

- No complex cryptographic attacks required
- Can be executed during normal block production workflow

**Detection Difficulty:**
- Very hard to detect on-chain - fake decrypted pieces are indistinguishable from real ones in contract state
- No way to verify claimed decryption without the recipient's private key
- Would require extensive off-chain statistical analysis to identify anomalies

**Economic Rationality:**
- Attack cost: Minimal (submitting incorrect data during normal mining)
- Potential gain: Improved mining positions, increased block rewards, ability to manipulate consensus
- Risk: Low (undetectable through normal validation mechanisms)

## Recommendation

Add validation in `RevealSharedInValues()` to verify that the reconstructed InValue matches the committed OutValue:

```csharp
var revealedInValue = HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// CRITICAL FIX: Validate reconstructed InValue against committed OutValue
if (HashHelper.ComputeFrom(revealedInValue) != anotherMinerInPreviousRound.OutValue)
{
    Context.LogDebug(() => $"Revealed in value does not match committed out value for {publicKeyOfAnotherMiner}");
    continue; // Skip this miner - decrypted pieces are invalid
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

This ensures that only correctly revealed InValues (where `Hash(InValue) == OutValue`) are accepted, preventing malicious miners from submitting arbitrary decrypted pieces.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Setup a network with secret sharing enabled
2. Have Miner A produce a block in Round N with valid encrypted pieces
3. Have Malicious Miner B produce a block in Round N+1 with fake decrypted pieces for Miner A
4. Verify that `RevealSharedInValues()` accepts the fake pieces without validation
5. Have the extra block producer trigger NextRound
6. Verify that if Miner A didn't mine in Round N+1, their signature in Round N+2 is calculated using the fake InValue
7. Show that Miner A's `FinalOrderOfNextRound` is different from what it should be based on their actual InValue

The core issue can be verified by checking that nowhere in the codebase is there validation of `Hash(reconstructedInValue) == OutValue` for revealed values from secret sharing.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L136-153)
```csharp
    private void UpdateLatestSecretPieces(Round updatedRound, string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        foreach (var encryptedPiece in triggerInformation.EncryptedPieces)
            updatedRound.RealTimeMinersInformation[pubkey].EncryptedPieces
                .Add(encryptedPiece.Key, encryptedPiece.Value);

        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;

        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-199)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L108-110)
```csharp
            var decryptedPieces = _secretSharingService.GetDecryptedPieces(hint.RoundId);
            foreach (var decryptedPiece in decryptedPieces)
                trigger.DecryptedPieces.Add(decryptedPiece.Key, ByteString.CopyFrom(decryptedPiece.Value));
```
