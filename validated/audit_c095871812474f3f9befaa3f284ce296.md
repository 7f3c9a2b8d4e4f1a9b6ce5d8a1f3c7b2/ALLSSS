# Audit Report

## Title
LIB Calculation Fails When Insufficient Miners Participated in Previous Round

## Summary
The Last Irreversible Block (LIB) calculation can fail in the current round even when sufficient miners participate, if too few miners mined in the previous round. This occurs because the LIB algorithm retrieves miners who mined in the current round but evaluates their `ImpliedIrreversibleBlockHeight` values from the previous round, filtering out miners with zero heights who didn't participate previously.

## Finding Description

The AEDPoS consensus mechanism calculates LIB by examining miners who successfully mined in the current round and retrieving their implied irreversible block heights from the previous round. The vulnerability exists due to the interaction between several components:

**LIB Calculation Logic**: The `LastIrreversibleBlockHeightCalculator.Deconstruct()` method gets the list of miners who mined in the current round, then looks up their `ImpliedIrreversibleBlockHeight` values from the previous round stored in state. [1](#0-0) 

**Zero Height Filtering**: The `GetSortedImpliedIrreversibleBlockHeights` method explicitly filters out all miners with `ImpliedIrreversibleBlockHeight <= 0`, only considering miners who have positive height values. [2](#0-1) 

**Consensus Threshold Requirement**: The system requires at least `MinersCountOfConsent = (total_miners * 2) / 3 + 1` miners with non-zero heights for successful LIB calculation. [3](#0-2)  If fewer heights are available, LIB returns 0. [4](#0-3) 

**Height Update Mechanism**: Miners only update their `ImpliedIrreversibleBlockHeight` when they successfully mine a block via `ProcessUpdateValue`. [5](#0-4) 

**Execution Scenario** (with 17 miners, requiring 12 for consensus):
- **Round N**: Only 11 out of 17 miners successfully mine blocks. These 11 miners set their `ImpliedIrreversibleBlockHeight` in Round N. The 6 miners who missed retain height=0 in Round N. Round N is saved to state.
- **Round N+1**: All 17 miners successfully participate and mine blocks
- **LIB Calculation in Round N+1**: When the 12th miner processes their block, the LIB calculator retrieves all 12 miners who have mined so far in Round N+1, then looks up their heights from Round N via `TryToGetPreviousRoundInformation`. [6](#0-5) 
- However, if one of these 12 miners was among the 6 who didn't mine in Round N, their height from Round N is 0 and gets filtered out
- Only 11 heights pass the filter, which is less than the required 12
- LIB calculation returns 0, and no `IrreversibleBlockFound` event is fired [7](#0-6) 

The protobuf definition confirms that `implied_irreversible_block_height` defaults to 0 for new `MinerInRound` objects. [8](#0-7) 

The miner identification for LIB calculation is based on `SupposedOrderOfNextRound != 0` which is set when miners successfully mine. [9](#0-8) 

## Impact Explanation

This vulnerability causes **consensus liveness degradation** with the following concrete impacts:

1. **Finality Stall**: When LIB calculation returns 0, the blockchain's Last Irreversible Block height does not advance because the check `currentRound.ConfirmedIrreversibleBlockHeight < libHeight` fails when libHeight is 0, preventing blocks from achieving finality status.

2. **Cross-Chain Operations Disruption**: Cross-chain transfers and indexing operations rely on LIB for finality guarantees through the `IrreversibleBlockFound` event processing. A stalled LIB prevents cross-chain transactions from progressing, as they require irreversible block confirmations for security.

3. **Validator Impact**: Block validators cannot reliably confirm irreversible block heights during the stall period, affecting their synchronization and validation operations.

4. **Temporary DoS**: The system experiences availability degradation affecting dependent services.

**Severity Justification**: Medium - This is an availability/liveness issue rather than a fund-at-risk vulnerability. The impact is temporary and self-healing once miners achieve consistent participation across multiple consecutive rounds. However, during network instability, high latency periods, or coordinated downtime, this can cause extended finality stalls affecting critical operations.

**Quantified Impact**: With 17 miners (typical production configuration), if more than 5 miners (>29% of the network) miss their time slots in one round, the next round's LIB calculation will fail even if all miners participate in that next round.

## Likelihood Explanation

**Natural Occurrence Probability**: HIGH

This vulnerability occurs naturally without any malicious actor:
- Network instability, high latency, or temporary connectivity issues commonly cause miners to miss time slots
- Miner node maintenance, restarts, or brief outages naturally result in missed slots  
- The Byzantine fault tolerance threshold (1/3 or ~33%) is very close to the failure threshold (6 out of 17 miners or ~35%), making this scenario realistic in production environments
- Production blockchain networks regularly experience periods where multiple nodes have degraded performance

**Mathematical Certainty**: If fewer than `MinersCountOfConsent` miners mine in Round N, and at least `MinersCountOfConsent` miners mine in Round N+1, it is **guaranteed** that at least one of the miners in Round N+1 was among those who didn't mine in Round N. This ensures the vulnerability will trigger.

**Preconditions**:
- Standard consensus operation with no special configuration required
- More than (n/3) miners miss time slots in one round (realistic during poor network conditions)
- Sufficient miners participate in the subsequent round to attempt LIB calculation

**Detection**: The issue manifests as LIB height not advancing, which may be difficult to distinguish from normal consensus variations, making it a low-detectability issue that could persist unnoticed.

## Recommendation

Modify the LIB calculation logic to use a more resilient approach that doesn't depend solely on the previous round's heights. Consider one of these solutions:

1. **Use Current Round Heights with Validation**: Look up `ImpliedIrreversibleBlockHeight` values from the current round instead of the previous round, ensuring miners who are actively participating contribute to LIB advancement.

2. **Fallback Mechanism**: When insufficient heights are found from the previous round, implement a fallback that uses a conservative LIB value (e.g., the previous confirmed LIB) rather than returning 0.

3. **Multi-Round Aggregation**: Consider heights from the last N rounds rather than just the previous round, giving more resilience to temporary miner unavailability.

4. **Hybrid Approach**: Check if sufficient miners from the previous round are participating in the current round before attempting LIB calculation, and defer if not.

## Proof of Concept

The vulnerability can be demonstrated with the following scenario:

1. Initialize network with 17 miners (MinersCountOfConsent = 12)
2. Round N: Only 11 miners successfully call `UpdateValue` and mine blocks
3. Round N completes and is saved to state via `AddRoundInformation`
4. Round N+1 begins with all 17 miners participating
5. When the 12th miner in Round N+1 calls `UpdateValue`:
   - `ProcessUpdateValue` is invoked
   - `TryToGetPreviousRoundInformation` retrieves Round N
   - `LastIrreversibleBlockHeightCalculator.Deconstruct` is called
   - Gets 12 miners who mined in Round N+1 via `GetMinedMiners()`
   - Looks up their heights from Round N via `GetSortedImpliedIrreversibleBlockHeights`
   - At least one of the 12 miners has height=0 from Round N (they didn't mine)
   - Filter removes zero heights, leaving only 11
   - Comparison `11 < 12` is true, returns `libHeight = 0`
   - No `IrreversibleBlockFound` event is fired
   - LIB advancement stalls

**Test Verification**: This can be verified by monitoring the `IrreversibleBlockFound` events during periods where miner participation drops below `MinersCountOfConsent` in one round, then recovers in the next round. The absence of LIB advancement events confirms the vulnerability.

## Notes

This vulnerability represents a design flaw in the temporal dependency between rounds for LIB calculation. While the system is designed to be Byzantine fault tolerant (2/3+1 consensus), the LIB calculation logic creates an edge case where current round consensus participation is insufficient due to previous round's participation gaps. The issue is self-healing but can cause extended finality stalls during periods of network instability, which is particularly problematic for cross-chain operations that depend on finality guarantees.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-25)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L26-29)
```csharp
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L14-16)
```csharp
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-278)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L56-64)
```csharp
    private bool TryToGetPreviousRoundInformation(out Round previousRound)
    {
        previousRound = new Round();
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        if (roundNumber < 2) return false;
        var targetRoundNumber = roundNumber.Sub(1);
        previousRound = State.Rounds[targetRoundNumber];
        return !previousRound.IsEmpty;
    }
```

**File:** protobuf/aedpos_contract.proto (L300-300)
```text
    int64 implied_irreversible_block_height = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```
