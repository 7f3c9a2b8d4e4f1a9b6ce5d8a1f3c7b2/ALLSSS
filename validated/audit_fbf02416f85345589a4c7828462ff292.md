# Audit Report

## Title
TokenHash Collision via Ambiguous String Concatenation Causes NFT State Corruption

## Summary
The `CalculateTokenHash` function uses undelimited string concatenation of symbol and tokenId, enabling hash collisions between different NFT protocols when symbol number lengths vary. This allows multiple distinct NFTs to share the same storage slot, corrupting ownership data, balances, and metadata.

## Finding Description

The vulnerability originates from the tokenHash calculation mechanism that uses undelimited string concatenation. [1](#0-0) 

NFT protocol symbols are generated with the format `{2-letter-code}{number}`. [2](#0-1) 

The number portion starts at 9 digits minimum. [3](#0-2) 

The number length dynamically increases as more protocols are created. [4](#0-3) 

This creates ambiguous concatenation scenarios:
- Protocol A: symbol "AR100000000" (9-digit) + tokenId 123 → "AR100000000123"
- Protocol B: symbol "AR1000000001" (10-digit) + tokenId 23 → "AR100000000123"

Both produce identical hash inputs, resulting in the same tokenHash.

During minting, this tokenHash is used to retrieve and store NFTInfo. [5](#0-4) 

When a protocol has `IsTokenIdReuse=true`, the uniqueness check is bypassed, allowing the code to modify existing NFTInfo from a completely different protocol. [6](#0-5) 

The code then increments quantity and adds the new minter without validating that the retrieved NFTInfo's symbol matches the requested protocol. [7](#0-6) 

The corrupted state is then saved to all storage maps. [8](#0-7) 

## Impact Explanation

**Critical State Corruption:**
- Multiple distinct NFTs from different protocols share the same storage slot in `State.NftInfoMap[tokenHash]`
- Balance mappings in `State.BalanceMap[tokenHash]` become mixed between unrelated NFTs
- Allowances, assembled NFTs/FTs, and all token-specific state are improperly shared

**Ownership and Value Corruption:**
- When Protocol B mints a colliding tokenId, it increments the quantity and adds its minter to Protocol A's NFTInfo
- Transfers of one NFT affect balances of the other
- Burns can destroy the wrong NFT's quantity  
- Users querying GetNFTInfo receive incorrect symbol/tokenId data [9](#0-8) 

This violates the fundamental invariant of NFT uniqueness and ownership isolation. The vulnerability enables theft through balance manipulation, permanent state corruption through data mixing, loss of funds through burns affecting wrong tokens, and complete protocol breakdown as NFT identity becomes ambiguous.

## Likelihood Explanation

**Attacker Capabilities:**
- Must be a minter for a protocol with `IsTokenIdReuse=true`
- Can create such a protocol or be added to an existing protocol's minter list [10](#0-9) 
- No special system privileges required beyond normal protocol participation

**Attack Complexity:**
- Straightforward calculation of colliding (symbol, tokenId) pairs using publicly observable symbol format rules
- Symbol generation logic is deterministic and observable on-chain
- Attacker simply mints with the calculated colliding tokenId

**Feasibility Conditions:**
- Guaranteed to occur naturally: As protocols are created, symbol number lengths WILL transition from 9 to 10+ digits by design
- Both 9-digit and 10+ digit symbols will coexist in the system simultaneously
- Any protocol with `IsTokenIdReuse=true` enables the attack vector

**Economic Rationality:**
- Attack cost: Standard minting fees only
- Potential gain: Ability to corrupt high-value NFT ownership data and manipulate balances
- Risk: Low, as minting appears as a normal operation

The vulnerability has HIGH likelihood because symbol length transitions are inevitable in the protocol's design, making collisions a certainty rather than a possibility.

## Recommendation

Modify the `CalculateTokenHash` function to use a delimiter or structured encoding that prevents ambiguous concatenation:

**Option 1 - Add delimiter:**
```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}|{tokenId}");
}
```

**Option 2 - Use structured hashing:**
```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol),
        HashHelper.ComputeFrom(tokenId)
    );
}
```

Additionally, add validation in `PerformMint` to verify retrieved NFTInfo matches the requested symbol:
```csharp
if (nftInfo != null && nftInfo.Symbol != input.Symbol)
{
    throw new AssertionException($"TokenHash collision detected for symbol {input.Symbol}");
}
```

## Proof of Concept

```csharp
[Fact]
public async Task TokenHash_Collision_Corrupts_NFT_State()
{
    // Step 1: Create Protocol A with 9-digit symbol when CurrentSymbolNumberLength = 9
    // Assume symbol generated is "AR100000000"
    var protocolASymbol = "AR100000000";
    await CreateProtocolWithSymbol(protocolASymbol, isTokenIdReuse: true);
    
    // Step 2: Protocol A mints tokenId 123
    await MintNFT(protocolASymbol, tokenId: 123, owner: User1);
    
    // Step 3: Verify Protocol A's NFT exists with correct data
    var nftInfoA = await GetNFTInfo(protocolASymbol, 123);
    nftInfoA.Symbol.ShouldBe(protocolASymbol);
    nftInfoA.TokenId.ShouldBe(123);
    nftInfoA.Quantity.ShouldBe(1);
    
    // Step 4: Simulate symbol length transition to 10 digits
    // Protocol B is created with symbol "AR1000000001"
    var protocolBSymbol = "AR1000000001";
    await CreateProtocolWithSymbol(protocolBSymbol, isTokenIdReuse: true);
    
    // Step 5: Calculate collision - Protocol B mints tokenId 23
    // "AR1000000001" + "23" = "AR100000000123"
    // "AR100000000" + "123" = "AR100000000123" 
    // COLLISION!
    await MintNFT(protocolBSymbol, tokenId: 23, owner: User2);
    
    // Step 6: Verify state corruption
    // Query Protocol A's NFT - it should be unchanged but is now corrupted
    var corruptedNftInfo = await GetNFTInfo(protocolASymbol, 123);
    
    // BUG: NFTInfo now has mixed data from both protocols
    corruptedNftInfo.Quantity.ShouldBe(2); // Was 1, now incremented by Protocol B's mint
    corruptedNftInfo.Minters.Count.ShouldBe(2); // Contains minters from both protocols
    
    // BUG: Query Protocol B's NFT returns Protocol A's symbol
    var protocolBQuery = await GetNFTInfo(protocolBSymbol, 23);
    protocolBQuery.Symbol.ShouldBe(protocolASymbol); // Returns "AR100000000" instead of "AR1000000001"!
    protocolBQuery.TokenId.ShouldBe(123); // Returns 123 instead of 23!
    
    // BUG: Both protocols share the same tokenHash and storage slot
    var hashA = await CalculateTokenHash(protocolASymbol, 123);
    var hashB = await CalculateTokenHash(protocolBSymbol, 23);
    hashA.ShouldBe(hashB); // COLLISION CONFIRMED
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-353)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L393-394)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-437)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L439-441)
```csharp
        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L14-18)
```csharp
    public override NFTInfo GetNFTInfo(GetNFTInfoInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        return GetNFTInfoByTokenHash(tokenHash);
    }
```
