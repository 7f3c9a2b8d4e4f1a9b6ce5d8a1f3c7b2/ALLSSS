# Audit Report

## Title
Period Desynchronization Causes DoS in RegisterForProfits Auto-Distribution

## Summary
The TokenHolderContract maintains a local period counter that becomes desynchronized from the Profit contract's authoritative CurrentPeriod when scheme managers call `Profit.DistributeProfits` directly. This causes subsequent `RegisterForProfits` calls with auto-distribution to fail with an "Invalid period" assertion error, creating a complete denial-of-service for new user registrations.

## Finding Description

The TokenHolderContract wraps the Profit contract and caches the current distribution period locally in `scheme.Period`. This cache must remain synchronized with the Profit contract's `CurrentPeriod` for distributions to succeed. However, the synchronization logic has a critical flaw.

When `RegisterForProfits` is called with auto-distribution enabled, it retrieves the scheme without forcing period synchronization. [1](#0-0)  The method calls `GetValidScheme` with the default parameter `updateSchemePeriod = false`.

This triggers an early return in `UpdateTokenHolderProfitScheme` that skips the period synchronization logic: [2](#0-1)  The condition `if (scheme.SchemeId != null && !updateSchemePeriod) return;` causes the method to exit before reaching the synchronization code at line 297.

When auto-distribution threshold is met, `RegisterForProfits` creates a distribution request using the stale local period: [3](#0-2)  This uses `Period = scheme.Period` which may be out of sync.

The Profit contract strictly validates that the provided period matches its current period: [4](#0-3)  Any mismatch results in an assertion failure with the exact error message reported.

The desynchronization occurs because the Profit contract authorizes both the TokenHolder contract AND the scheme manager to call `DistributeProfits` directly: [5](#0-4)  When the scheme manager calls `Profit.DistributeProfits` directly, it increments the Profit contract's `CurrentPeriod` [6](#0-5)  but the TokenHolder's local cache remains stale.

In contrast, the manual `DistributeProfits` method correctly forces period synchronization: [7](#0-6)  by passing `updateSchemePeriod = true`.

## Impact Explanation

This vulnerability causes a **HIGH severity** denial-of-service on the `RegisterForProfits` function:

1. **Complete functionality loss**: Once desynchronization occurs, ALL users attempting to call `RegisterForProfits` will experience transaction failure during auto-distribution. The function becomes completely unusable for new registrations.

2. **Affects core user functionality**: `RegisterForProfits` is the primary entry point for users to participate in profit schemes. This is not an administrative function but a critical user-facing operation.

3. **Auto-distribution is intended behavior**: The auto-distribution feature is explicitly implemented and tested (as seen in test files), making this a failure of documented functionality, not an edge case.

4. **Requires manual intervention**: Recovery requires someone with appropriate permissions to call `TokenHolder.DistributeProfits` to force period resynchronization, creating operational overhead and potential confusion.

5. **Systemic vulnerability**: All TokenHolder schemes with `AutoDistributeThreshold` configured are vulnerable to this issue, potentially affecting multiple profit distribution schemes across the protocol.

## Likelihood Explanation

The likelihood of this vulnerability being triggered is **HIGH**:

1. **Legitimate access**: The scheme manager who created the TokenHolder profit scheme has legitimate authorization to call `Profit.DistributeProfits` directly. No privilege escalation or unauthorized access is required.

2. **Minimal attack complexity**: The trigger requires only a single direct call to `Profit.DistributeProfits`, bypassing the TokenHolder wrapper. This is trivial to execute.

3. **Dual authorization design**: The Profit contract explicitly allows both the scheme manager and TokenHolder contract to distribute profits, suggesting direct calls are an intended use case rather than a security violation.

4. **Accidental triggers**: This can occur accidentally during normal operations if a scheme manager is unaware they should only distribute through the TokenHolder wrapper, or if they use the Profit contract directly for convenience.

5. **No protective restrictions**: There is no documentation, code comment, or runtime check preventing scheme managers from calling `Profit.DistributeProfits` directly. The authorization model actively enables this pattern.

## Recommendation

**Option 1: Force period synchronization in RegisterForProfits** (Recommended)

Modify `RegisterForProfits` to always sync the period before auto-distribution:

```csharp
public override Empty RegisterForProfits(RegisterForProfitsInput input)
{
    Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
    // Force period synchronization when auto-distribution is enabled
    var scheme = GetValidScheme(input.SchemeManager, true); // Change to true
    // ... rest of the method
}
```

**Option 2: Sync period before auto-distribution check**

Add explicit synchronization before the auto-distribution logic:

```csharp
// Check auto-distribute threshold.
if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
{
    // Ensure period is synchronized before distributing
    UpdateTokenHolderProfitScheme(ref scheme, input.SchemeManager, true);
    var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
    // ... rest of auto-distribution logic
}
```

**Option 3: Restrict Profit.DistributeProfits authorization**

Remove the scheme manager's ability to call `Profit.DistributeProfits` directly, requiring all distributions to go through the TokenHolder wrapper. However, this would be a breaking change to the authorization model.

## Proof of Concept

```csharp
[Fact]
public async Task Period_Desynchronization_DoS_Test()
{
    // Setup: Create scheme with auto-distribution enabled
    var amount = 1000L;
    var nativeTokenSymbol = TokenHolderContractTestConstants.NativeTokenSymbol;
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = nativeTokenSymbol,
        AutoDistributeThreshold = { { nativeTokenSymbol, amount } }
    });
    
    // Contribute profits to trigger auto-distribution threshold
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Amount = amount,
        Symbol = nativeTokenSymbol
    });
    
    // Get the underlying Profit scheme ID
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = Starter });
    var profitSchemeId = schemeIds.SchemeIds.First();
    
    // ATTACK: Scheme manager calls Profit.DistributeProfits directly
    // This increments Profit.CurrentPeriod but leaves TokenHolder.Period stale
    await ProfitContractStub.DistributeProfits.SendAsync(new Profit.DistributeProfitsInput
    {
        SchemeId = profitSchemeId,
        Period = 1
    });
    
    // EXPLOIT: User attempts to register with auto-distribution enabled
    // This should fail with "Invalid period" assertion
    var registerResult = await TokenHolderContractStub.RegisterForProfits
        .SendWithExceptionAsync(new RegisterForProfitsInput
        {
            Amount = amount,
            SchemeManager = Starter
        });
    
    // Verify the DoS condition
    registerResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    registerResult.TransactionResult.Error.ShouldContain("Invalid period");
    
    // Verify period desynchronization
    var profitScheme = await ProfitContractStub.GetScheme.CallAsync(profitSchemeId);
    var tokenHolderScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    profitScheme.CurrentPeriod.ShouldBe(2); // Profit contract advanced
    tokenHolderScheme.Period.ShouldBe(1);   // TokenHolder cache is stale
}
```

This test demonstrates the complete attack path: the scheme manager's direct call to `Profit.DistributeProfits` causes period desynchronization, and subsequent `RegisterForProfits` calls fail with an assertion error, creating a denial-of-service condition.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L133-133)
```csharp
        var scheme = GetValidScheme(input.SchemeManager, true);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L152-152)
```csharp
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L193-197)
```csharp
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L289-289)
```csharp
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L426-428)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L479-480)
```csharp
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```
