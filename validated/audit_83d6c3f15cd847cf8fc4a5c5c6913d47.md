# Audit Report

## Title
Inconsistent Null Handling in GetProfitDetails Causes DoS in TokenHolder and Election Contracts

## Summary
The `GetProfitDetails()` view method in the Profit contract returns null when querying non-existent beneficiaries without defensive handling, causing NullReferenceException crashes in TokenHolderContract.AddBeneficiary, TokenHolderContract.RemoveBeneficiary, and Election contract methods. This creates a denial-of-service condition preventing legitimate profit distribution operations.

## Finding Description

The root cause is the `GetProfitDetails` view method that directly returns the state lookup result without null checking: [1](#0-0) 

When a beneficiary doesn't exist, AElf's MappedState returns null: [2](#0-1) 

In contrast, the similar `GetAllProfitsMap` method properly handles null cases: [3](#0-2) 

This inconsistency causes crashes in critical callers:

**TokenHolderContract.AddBeneficiary** crashes when adding a new beneficiary by accessing `.Details.Any()` without null checking: [4](#0-3) 

**TokenHolderContract.RemoveBeneficiary** crashes by immediately chaining `.Details.Single()`: [5](#0-4) 

**ElectionContract.GetProfitDetailByElectionVotingRecord** crashes by accessing `.Details.FirstOrDefault()` on null: [6](#0-5) 

The Profit contract's own `AddBeneficiary` method demonstrates the correct defensive pattern: [7](#0-6) 

## Impact Explanation

**Operational Denial-of-Service Impact:**

1. **TokenHolder schemes**: Scheme managers cannot add new beneficiaries to their profit schemes. The first `AddBeneficiary` call for any new address triggers a NullReferenceException, causing transaction failure and permanently blocking this core functionality.

2. **Election system**: Vote processing operations that query profit details for voters who haven't been registered yet will fail, disrupting the election reward distribution mechanism.

3. **Profit scheme management**: Attempting to remove non-existent beneficiaries causes crashes.

**Severity:** This breaks core economic functionality (profit distribution, staking rewards, election rewards) across multiple critical system contracts. While no funds are at risk of loss, the availability of essential operations is compromised, preventing legitimate users from participating in the protocol's incentive mechanisms.

## Likelihood Explanation

**High Likelihood - Triggered During Normal Operations:**

All affected methods are public contract methods callable by regular users without special privileges:
- `TokenHolderContract.AddBeneficiary` is callable by any scheme manager
- Election contract methods are triggered during standard voting operations

**Minimal Preconditions:** Simply calling `AddBeneficiary` with a new beneficiary address (the expected normal use case) triggers the vulnerability.

**Execution Practicality:** The bug manifests during legitimate operationsâ€”the first time anyone tries to add a new beneficiary to a TokenHolder profit scheme, the transaction fails with a NullReferenceException.

**Detection:** The bug is deterministic and reproducible. Every `AddBeneficiary` call for a non-existent beneficiary will fail consistently.

## Recommendation

Add null checking to `GetProfitDetails` consistent with `GetAllProfitsMap`:

```csharp
public override ProfitDetails GetProfitDetails(GetProfitDetailsInput input)
{
    var details = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];
    return details ?? new ProfitDetails();
}
```

Alternatively, add null checks in all callers before accessing the `Details` property, similar to how `GetAllProfitsMap` handles it.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task AddBeneficiary_WithNewBeneficiary_ShouldNotCrash()
{
    // Setup: Create a TokenHolder profit scheme
    var schemeManager = Accounts[0];
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });
    
    // Attempt to add a NEW beneficiary (who doesn't exist in ProfitDetailsMap yet)
    var newBeneficiary = Accounts[1].Address;
    
    // This will throw NullReferenceException because GetProfitDetails returns null
    // and the code tries to access detail.Details.Any()
    var result = await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = newBeneficiary,
        Shares = 100
    });
    
    // Transaction should succeed but will fail with NullReferenceException
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L46-49)
```csharp
    public override ProfitDetails GetProfitDetails(GetProfitDetailsInput input)
    {
        return State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L108-110)
```csharp
        var profitDetails = State.ProfitDetailsMap[schemeId][beneficiary];

        if (profitDetails == null) return new GetAllProfitsMapOutput();
```

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L13-13)
```csharp
    public MappedState<Hash, Address, ProfitDetails> ProfitDetailsMap { get; set; }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L40-46)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L74-78)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L170-177)
```csharp
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```
