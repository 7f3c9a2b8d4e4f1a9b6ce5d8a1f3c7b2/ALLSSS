# Audit Report

## Title
Off-By-One Error in GetAllChainsIdAndHeight() Invalidates Genesis Block Height and Causes Cross-Chain DoS

## Summary
The `GetAllChainsIdAndHeight()` method uses an incorrect strict greater-than comparison (`>`) instead of greater-than-or-equal (`>=`) when validating parent chain height, causing it to reject the valid genesis block height of 1. This creates a denial-of-service condition for side chains created at parent chain heights 1 or 2, preventing cross-chain cache initialization and parent chain data indexing.

## Finding Description

The vulnerability exists in the `GetAllChainsIdAndHeight()` method which validates parent chain height using a strict comparison against `AElfConstants.GenesisBlockHeight`: [1](#0-0) 

The constant `GenesisBlockHeight` is defined as 1: [2](#0-1) 

During side chain initialization, `CurrentParentChainHeight` is set to `CreationHeightOnParentChain - 1`: [3](#0-2) 

This creates two problematic scenarios:

**Scenario 1: Side chain created at parent height 2**
- `CurrentParentChainHeight = 2 - 1 = 1`
- Before any parent block indexing, calling `GetAllChainsIdAndHeight()` fails because `1 > 1` is false

**Scenario 2: Side chain created at parent height 1 (genesis)**
- `CurrentParentChainHeight = 1 - 1 = 0` initially
- After indexing parent genesis block, `CurrentParentChainHeight = 1`
- Function permanently fails because `1 > 1` is false

The side chain creation process directly uses `Context.CurrentHeight` without minimum height validation: [4](#0-3) 

## Impact Explanation

This function is critical for cross-chain operations as it's called by `GetAllChainIdHeightPairsAtLibAsync()`: [5](#0-4) 

This method is used in two critical flows:

1. **Initial sync** - registers new chains in the cross-chain cache: [6](#0-5) 

2. **Continuous updates** - updates cross-chain cache with latest heights: [7](#0-6) 

**Affected parties:**
- Side chains created at parent heights 1 or 2 are permanently affected
- Cross-chain cache cannot be initialized or updated
- Parent chain block data cannot be indexed
- All cross-chain functionality (verification, indexing, merkle proofs) becomes unavailable

The severity is Low-to-Medium depending on deployment context:
- **Low** in production (governance approval processes typically span multiple blocks)
- **High** in test/genesis environments (early block creation is common)

## Likelihood Explanation

**Feasibility:**
The bug triggers naturally without any attacker involvement when:
1. A side chain is deployed during genesis or very early parent chain blocks
2. Cross-chain initialization is attempted before sufficient parent chain growth
3. Test environments that routinely create side chains at early heights

**No minimum height validation exists:** There is no check preventing side chain creation at genesis or early blocks. The method is a public view function callable by anyone without special privileges.

**Probability:**
- **Low in production**: Side chain creation typically occurs after governance processes that span multiple blocks, naturally avoiding heights 1-2
- **High in test/development**: Genesis scenarios and early-stage testing routinely trigger this condition
- **Technically possible**: No protocol-level barrier prevents early side chain creation

The existing tests avoid this bug by using `parentChainHeightOfCreation = 10`: [8](#0-7) 

## Recommendation

Change the comparison from strict greater-than to greater-than-or-equal:

```csharp
// Current (incorrect):
Assert(parentChainHeight > AElfConstants.GenesisBlockHeight, "Invalid parent chain height");

// Fixed:
Assert(parentChainHeight >= AElfConstants.GenesisBlockHeight, "Invalid parent chain height");
```

This allows the genesis block height (1) as a valid value, which is correct since:
1. Genesis block height is a valid starting point for cross-chain indexing
2. The initialization logic explicitly sets `CurrentParentChainHeight` to values that can be 1
3. Other parts of the system (like side chain indexing) correctly use `AElfConstants.GenesisBlockHeight` as a valid target height: [9](#0-8) 

## Proof of Concept

```csharp
[Fact]
public async Task GetAllChainsIdAndHeight_FailsForEarlyParentChainHeight()
{
    // Create side chain at parent height 2
    var parentChainId = 123;
    var parentChainHeightOfCreation = 2L;
    var sideChainId = await InitAndCreateSideChainAsync(
        parentChainHeightOfCreation, 
        parentChainId, 
        lockedTokenAmount: 10L
    );
    
    // CurrentParentChainHeight is now set to 2 - 1 = 1
    // Calling GetAllChainsIdAndHeight should succeed but will fail
    // because assertion checks: 1 > 1 which is false
    
    var exception = await Assert.ThrowsAsync<Exception>(async () => 
    {
        await CrossChainContractStub.GetAllChainsIdAndHeight.CallAsync(new Empty());
    });
    
    Assert.Contains("Invalid parent chain height", exception.Message);
}
```

This test demonstrates that when a side chain is created at parent height 2, the `GetAllChainsIdAndHeight()` method fails with "Invalid parent chain height" error, even though the height value of 1 is legitimate and represents the genesis block.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L125-125)
```csharp
        Assert(parentChainHeight > AElfConstants.GenesisBlockHeight, "Invalid parent chain height");
```

**File:** src/AElf.Types/AElfConstants.cs (L6-6)
```csharp
        public const long GenesisBlockHeight = 1;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L18-18)
```csharp
        State.CurrentParentChainHeight.Value = input.CreationHeightOnParentChain - 1;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L151-151)
```csharp
            CreationHeightOnParentChain = Context.CurrentHeight,
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataService.cs (L174-175)
```csharp
            }).GetAllChainsIdAndHeight
            .CallAsync(new Empty());
```

**File:** src/AElf.CrossChain/Application/CrossChainService.cs (L29-33)
```csharp
        var chainIdHeightPairs =
            await _crossChainIndexingDataService.GetAllChainIdHeightPairsAtLibAsync();
        foreach (var chainIdHeight in chainIdHeightPairs.IdHeightDict)
            // register new chain
            _crossChainCacheEntityService.RegisterNewChain(chainIdHeight.Key, chainIdHeight.Value);
```

**File:** src/AElf.CrossChain/Application/CrossChainService.cs (L44-47)
```csharp
        var chainIdHeightPairs =
            await _crossChainIndexingDataService.GetAllChainIdHeightPairsAtLibAsync();

        await _crossChainCacheEntityService.UpdateCrossChainCacheAsync(blockHash, blockHeight, chainIdHeightPairs);
```

**File:** test/AElf.Contracts.CrossChain.Tests/CrossChainIndexingActionTest.cs (L224-228)
```csharp
        long parentChainHeightOfCreation = 10;
        await InitAndCreateSideChainAsync(parentChainHeightOfCreation, parentChainId);

        var height = await CrossChainContractStub.GetParentChainHeight.CallAsync(new Empty());
        Assert.Equal(parentChainHeightOfCreation - 1, height.Value);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L704-706)
```csharp
            var target = currentSideChainHeight != 0
                ? currentSideChainHeight + 1
                : AElfConstants.GenesisBlockHeight;
```
