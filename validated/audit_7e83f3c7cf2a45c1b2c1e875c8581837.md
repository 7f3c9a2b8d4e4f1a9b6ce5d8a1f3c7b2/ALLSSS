# Audit Report

## Title
Manipulation of IsMinerListJustChanged Flag Allows Unauthorized Extra Block Production After Miner List Changes

## Summary
A malicious block producer can manipulate the `IsMinerListJustChanged` flag to `false` in `NextRoundInput` during miner replacements, bypassing consensus rules that restrict extra block production rights when the miner list changes. This allows the previous round's extra block producer to continue producing tiny blocks and earning additional mining rewards unfairly.

## Finding Description

The AEDPoS consensus mechanism uses the `IsMinerListJustChanged` flag to control whether the extra block producer from the previous round can continue producing tiny blocks in the current round. When miner replacements occur, this flag should be set to `true` to prevent the extra block producer from retaining their privileges.

**Vulnerability Location:**

The consensus behavior determination logic checks this flag to control tiny block production. When the flag is false and the miner is the extra block producer from the previous round, they can produce up to `_maximumBlocksCount + blocksBeforeCurrentRound` blocks instead of their normal allocation. [1](#0-0) 

When miner replacement occurs, the system correctly detects it via the Election contract and sets `isMinerListChanged = true`: [2](#0-1) 

This flag is transferred through `NextRoundInput` structure: [3](#0-2) 

And converted to the Round object that gets stored: [4](#0-3) 

**The Attack Vector:**

A malicious block producer can modify their node software to manipulate the `IsMinerListJustChanged` flag in the `NextRoundInput` before submitting the `NextRound` transaction. When `ProcessNextRound` executes, it directly converts and stores the input without validation: [5](#0-4) 

The manipulated round object is stored directly via `AddRoundInformation(nextRound)` at line 156, with no independent verification of the flag's correctness.

**Why Validations Fail:**

1. **Pre-execution validation** only checks round number increment and that InValues are null, but does not verify the flag's correctness: [6](#0-5) 

2. **Post-execution validation** uses the manipulated flag from the stored state to calculate hashes, causing both the header and state hashes to match despite the manipulation: [7](#0-6) 

At line 99, `isContainPreviousInValue` is set based on the stored (manipulated) `IsMinerListJustChanged` flag. Both hashes at lines 100-101 are calculated using this same manipulated value, so they will always match. The Election contract verification at lines 103-123 only executes if hashes don't match, which they do in this attack.

The hash calculation uses the manipulated flag to determine whether to include previous in values: [8](#0-7) [9](#0-8) 

## Impact Explanation

**Direct Financial Impact:**
The exploiting miner can produce additional tiny blocks beyond their legitimate allocation. Each extra block earns mining rewards, giving the attacker an unfair advantage over honest miners who correctly respect the `IsMinerListJustChanged` constraint.

**Consensus Integrity Violation:**
This breaks the fundamental consensus rule that extra block production rights should not carry over when the miner list changes. The rule exists to ensure fair rotation of block production opportunities and prevent any single miner from dominating after miner replacements.

**Affected Parties:**
- Honest miners who lose their proportional share of block production and rewards
- The network's consensus fairness guarantees
- Token holders whose mining rewards are unfairly distributed

The impact is measurable and concrete: the attacker gains `blocksBeforeCurrentRound` additional block production slots, each yielding mining rewards.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a miner in the consensus set (achievable through normal election process)
- Must be the block producer who terminates a round when miner replacement occurs
- This opportunity rotates regularly among all miners

**Attack Complexity:**
- **LOW** - Requires only modifying node software to change one boolean flag value in the `NextRoundInput` before transaction submission
- No cryptographic operations or complex multi-step processes required
- The block producer controls the generation of their own consensus transactions

**Feasibility:**
- Miner replacements occur regularly when evil miners (those who miss time slots beyond the tolerable threshold) are detected
- Any miner can become the terminating block producer through normal rotation
- The attack is difficult to detect because the manipulated flag becomes legitimate on-chain state that passes all validations

**Probability:**
HIGH - The combination of regular occurrence, low complexity, direct financial benefit, and lack of detection makes this highly likely to be exploited by rational profit-maximizing miners.

## Recommendation

Add independent validation of the `IsMinerListJustChanged` flag by querying the Election contract to verify whether miner replacement actually occurred. The validation should happen in `ValidateBeforeExecution` or `ProcessNextRound` before storing the round information.

**Suggested Fix:**

In `ProcessNextRound`, after line 114 (`TryToGetCurrentRoundInformation(out var currentRound)`), add validation:

```csharp
// Validate IsMinerListJustChanged flag
if (State.IsMainChain.Value && previousRound.TermNumber == currentRound.TermNumber)
{
    var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
        new GetMinerReplacementInformationInput
        {
            CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
        });
    
    var actualMinerListChanged = minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0;
    Assert(nextRound.IsMinerListJustChanged == actualMinerListChanged, 
        "IsMinerListJustChanged flag does not match actual miner list state");
}
```

This ensures the flag value in `NextRoundInput` matches the ground truth from the Election contract, preventing manipulation.

## Proof of Concept

A malicious miner would:
1. Call `GetConsensusCommand` and `GenerateConsensusTransactions` to get the `NextRoundInput`
2. When miner replacement has occurred (flag is `true`), modify the `IsMinerListJustChanged` field to `false` in their local copy
3. Sign and broadcast the modified `NextRound` transaction
4. The transaction passes pre-execution validation (no flag check)
5. `ProcessNextRound` stores the manipulated round
6. Post-execution validation passes (both hashes use the same manipulated flag)
7. In subsequent blocks, the attacker's `GetConsensusBehaviour` check at line 73 of `ConsensusBehaviourProviderBase.cs` passes (because `!CurrentRound.IsMinerListJustChanged` evaluates to true)
8. The attacker continues producing tiny blocks with the extra allocation

The vulnerability is confirmed through code analysis showing that no validation step independently verifies the flag against the actual miner list state in the Election contract.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L298-346)
```csharp
        var isMinerListChanged = false;
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }

        currentRound.GenerateNextRoundInformation(currentBlockTime, blockchainStartTimestamp, out nextRound,
            isMinerListChanged);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L60-63)
```csharp
    public Hash GetHash(bool isContainPreviousInValue = true)
    {
        return HashHelper.ComputeFrom(GetCheckableRound(isContainPreviousInValue));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```
