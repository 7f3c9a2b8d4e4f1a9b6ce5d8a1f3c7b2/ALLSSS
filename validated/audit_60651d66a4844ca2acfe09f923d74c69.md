# Audit Report

## Title
Permissionless Proposal Deletion Enables Griefing of Approved Governance Actions Across All Governance Contracts

## Summary
A critical timing vulnerability exists in all three AElf governance contracts (Association, Parliament, and Referendum) where the `ClearProposal()` function allows any address to permanently delete expired proposals without authorization, while the `Release()` function rejects proposals at the exact moment of expiration. This creates a zero-width window enabling griefing attacks that can permanently block approved governance actions.

## Finding Description

The vulnerability stems from inconsistent expiration time checks across proposal deletion and release operations in all three governance contracts.

**In Association Contract:**
The `ClearProposal()` function allows anyone to delete proposals when the expiration time is reached [1](#0-0) , requiring only `Context.CurrentBlockTime >= proposal.ExpiredTime` with no authorization checks.

However, the `Release()` function calls `GetValidProposal()` [2](#0-1) , which internally validates using a strict less-than check [3](#0-2) . The validation returns false when `Context.CurrentBlockTime >= proposal.ExpiredTime`, meaning proposals cannot be released at or after their expiration time.

**In Parliament Contract:**
The same pattern exists with `ClearProposal()` allowing permissionless deletion at expiration [4](#0-3) , while `Release()` uses `GetValidProposal()` [5](#0-4)  which validates via `CheckProposalNotExpired()` requiring `Context.CurrentBlockTime < proposal.ExpiredTime` [6](#0-5) .

**In Referendum Contract:**
The identical vulnerability exists with permissionless `ClearProposal()` [7](#0-6)  and strict expiration validation in `Validate()` [8](#0-7) .

**Root Cause:** At exactly `CurrentBlockTime == ExpiredTime`, proposals transition from "cannot be released" (due to strict `<` check) to "can be deleted by anyone" (due to `>=` check), creating a zero-width griefing window with no grace period or authorization requirement.

## Impact Explanation

This vulnerability enables **HIGH severity** denial-of-service attacks against the entire governance system:

**Direct Governance Disruption:**
- Approved proposals that reached voting thresholds can be permanently deleted before execution
- Organization members' voting efforts and transaction fees are wasted
- Time-critical governance actions (emergency responses, parameter updates, fund transfers) can be blocked

**Systemic Impact:**
- Affects all three governance mechanisms (Association, Parliament, Referendum)
- Creates griefing opportunities for malicious actors or competing interests
- Undermines trust in the governance process
- No recovery mechanism exists - deleted proposals cannot be restored

**Who Is Affected:**
- Proposers who worked to achieve approval but faced legitimate delays
- Organization members whose votes are nullified
- Entire organizations whose governance processes are disrupted
- Beneficiaries of proposed actions who lose expected outcomes

The impact qualifies as HIGH because it breaks governance availability guarantees and can cause operational DoS without requiring privileged access.

## Likelihood Explanation

The likelihood of exploitation is **HIGH** due to multiple realistic factors:

**Low Attack Complexity:**
- Single transaction call to `ClearProposal(proposalId)` with no authorization required
- Minimal gas cost (single storage deletion)
- Can be easily automated with monitoring scripts
- No special permissions or tokens needed

**Realistic Delay Scenarios:**
Proposers may legitimately fail to release before expiration due to:
- Network congestion causing transaction delays
- Gas price spikes making immediate release expensive
- Proposer not actively monitoring the exact expiration timestamp
- Time zone differences or human unavailability
- Block production timing uncertainty in AEDPoS consensus

**No Prevention Mechanisms:**
- No on-chain warning system before proposals become vulnerable
- Proposer cannot "lock in" their release intention
- No grace period between expiration and deletion eligibility
- No special handling for approved proposals vs rejected ones

The attack is highly feasible whether executed maliciously or occurring accidentally through automated cleanup scripts.

## Recommendation

Implement one or more of the following mitigations across all three governance contracts:

**Option 1: Add Grace Period**
```csharp
public override Empty ClearProposal(Hash input)
{
    var proposal = State.Proposals[input];
    var gracePeriod = new Timestamp { Seconds = proposal.ExpiredTime.Seconds + 86400 }; // 24 hours
    Assert(proposal != null && Context.CurrentBlockTime >= gracePeriod, "Proposal clear failed");
    State.Proposals.Remove(input);
    return new Empty();
}
```

**Option 2: Restrict to Proposer**
```csharp
public override Empty ClearProposal(Hash input)
{
    var proposal = State.Proposals[input];
    Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
    Assert(Context.Sender == proposal.Proposer || Context.Sender == proposal.OrganizationAddress, 
           "No permission to clear");
    State.Proposals.Remove(input);
    return new Empty();
}
```

**Option 3: Allow Release at Expiration**
```csharp
private bool Validate(ProposalInfo proposal)
{
    // ... other checks ...
    return proposal.ExpiredTime != null && Context.CurrentBlockTime <= proposal.ExpiredTime; // Changed < to <=
}
```

**Recommended Approach:** Combine Option 1 (grace period) with Option 3 (allow release at expiration) to provide both flexibility for proposers and eventual cleanup capability.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Create an organization and proposal with expiration time T
2. Achieve approval threshold through member votes
3. Wait until `CurrentBlockTime == T` (expiration moment)
4. Attacker calls `ClearProposal(proposalId)` - succeeds (proposal deleted)
5. Proposer calls `Release(proposalId)` - fails with "Invalid proposal"
6. Approved proposal is permanently lost with no recovery mechanism

The attack succeeds because at the exact moment of expiration:
- `ClearProposal()` check `CurrentBlockTime >= ExpiredTime` evaluates to true
- `Validate()` check `CurrentBlockTime < ExpiredTime` evaluates to false
- Any address can execute the deletion before the proposer can release

## Notes

This vulnerability is systemic across the entire AElf governance framework, affecting:
- **Association Contract** for multi-signature governance
- **Parliament Contract** for miner-based governance  
- **Referendum Contract** for token-weighted voting

The issue represents a fundamental design flaw in proposal lifecycle management where the transition from "active" to "expired" state lacks proper protections for approved proposals. The zero-width timing window makes this exploitable even without malicious intent, as automated cleanup processes could inadvertently delete pending approved proposals.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L179-186)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L177-180)
```csharp
    private bool CheckProposalNotExpired(ProposalInfo proposal)
    {
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L154-161)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```
