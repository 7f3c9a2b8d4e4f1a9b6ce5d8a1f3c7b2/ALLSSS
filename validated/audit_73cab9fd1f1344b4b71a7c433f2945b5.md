# Audit Report

## Title
Inconsistent Time Slot Validation Allows Consensus Disruption via Non-Uniform Mining Intervals

## Summary
The AEDPoS consensus contract contains a critical validation flaw where `CheckRoundTimeSlots` permits mining intervals up to 2x the base interval, while `GetMiningInterval` only examines the first two miners. This mismatch allows any miner to inject non-uniform round data that passes validation but causes consensus disruption by creating time windows where no miner is considered valid, halting block production.

## Finding Description

The vulnerability stems from an inconsistency between validation and consumption of mining interval data:

**Root Cause 1: Overly Permissive Tolerance Check**

The `CheckRoundTimeSlots` method validates time slot equality using a tolerance check that only fails when the absolute difference **exceeds** the base interval: [1](#0-0) 

The condition `Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval` means an interval of exactly 2x the base (where the difference equals the base) passes validation.

**Root Cause 2: Limited Interval Calculation Scope**

The `GetMiningInterval` method only examines miners with `Order == 1 || Order == 2`: [2](#0-1) 

This creates a fundamental mismatch: validation checks all consecutive pairs, but the returned interval only reflects the first two miners' spacing.

**Root Cause 3: No Canonical Round Verification**

The `PreCheck` method only verifies that the transaction sender is in the current or previous round's miner list: [3](#0-2) 

No verification exists that the submitted `NextRoundInput` matches the canonical output of `GenerateNextRoundInformation`, which always produces uniform intervals: [4](#0-3) 

**Exploitation Path:**

1. Attacker (valid miner) calls the public `NextRound` method with crafted `NextRoundInput`: [5](#0-4) 

2. The input is converted directly via `ToRound()` without verifying uniformity: [6](#0-5) 

3. Validation via `TimeSlotValidationProvider` calls `CheckRoundTimeSlots` for new rounds: [7](#0-6) 

4. Non-uniform intervals (e.g., 4000ms, 8000ms) pass because |8000-4000| = 4000 ≤ 4000

**Downstream Impact:**

Functions that depend on `GetMiningInterval()` break with non-uniform data:

1. **IsCurrentMiner Time Window**: Uses `GetMiningInterval()` to calculate valid mining windows: [8](#0-7) 

For a miner with actual 8000ms interval but `GetMiningInterval()` returning 4000ms, the calculated window is too short, creating gaps where NO miner is considered current.

2. **TimeSlotValidationProvider.CheckMinerTimeSlot**: Uses `GetMiningInterval()` to validate time slots during block validation: [9](#0-8) 

Blocks produced during the gap period fail validation, halting block production.

3. **IsTimeSlotPassed**: Marks slots as expired using `GetMiningInterval()`: [10](#0-9) 

4. **ArrangeAbnormalMiningTime**: Calculates incorrect future mining times: [11](#0-10) 

## Impact Explanation

**Severity: High - Complete Consensus DoS**

The vulnerability enables a malicious miner to create time windows where the consensus system cannot identify any valid block producer, causing complete block production failure during those periods. This breaks the fundamental consensus guarantee that there is always exactly one valid miner for any given time slot.

The attack affects all network participants:
- **Network-wide block production halt** during gap periods
- **Chain liveness violation** - no new blocks can be produced
- **Transaction processing stoppage** until the malicious round expires
- **Violation of consensus invariants** - the "uniform time slot" and "continuous miner schedule" guarantees

The impact is particularly severe because:
1. Attack is deterministic and repeatable every round
2. Affects ALL nodes simultaneously (consensus-level issue)
3. Requires only single malicious miner
4. No automatic recovery mechanism exists within affected round

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements:**
- Must be a valid miner in current or previous round (common - multiple miners exist)
- Can submit transactions to consensus contract (standard miner capability)

**Attack Complexity: Low**
- Exploitation is deterministic - tolerance boundary at exactly 2x base interval
- No timing constraints or race conditions required
- Single transaction execution
- No sophisticated coordination needed

**Feasibility: High**
- Any miner can craft custom `NextRoundInput` data
- Validation happens before execution but doesn't verify canonical generation
- No additional authorization beyond miner status required
- The public `NextRound` method is directly accessible

**Detection Constraints:**
- Appears as valid round data until downstream functions fail
- No proactive detection mechanism in validation logic
- Manual inspection required to identify malicious rounds

## Recommendation

Implement strict canonical round verification in the validation pipeline:

1. **Add canonical round comparison**: In `TimeSlotValidationProvider`, when validating a new round, generate the expected next round using `GenerateNextRoundInformation` and compare it against the provided round to ensure mining intervals are uniform.

2. **Strengthen CheckRoundTimeSlots**: Change the tolerance check from `>` to `>=` to reject intervals that equal or exceed the base interval deviation, preventing the 2x boundary case.

3. **Consider extending GetMiningInterval**: Instead of only checking the first two miners, verify that ALL consecutive pairs have uniform intervals and return the consensus interval.

## Proof of Concept

A proof-of-concept would involve:

1. Deploy AEDPoS contract with multiple miners (e.g., 3 miners)
2. As a valid miner, craft `NextRoundInput` with non-uniform intervals:
   - Order 1: T + 4000ms
   - Order 2: T + 8000ms (4000ms interval)
   - Order 3: T + 16000ms (8000ms interval)
3. Call `NextRound` method with this malicious input
4. Verify that `CheckRoundTimeSlots` passes (4000ms ≤ 4000ms tolerance)
5. Verify that `GetMiningInterval()` returns 4000ms
6. Attempt block production for Order 3 miner between T+20000 and T+24000
7. Observe that both `IsCurrentMiner` returns false and `CheckMinerTimeSlot` validation fails
8. Confirm that no blocks can be produced during this gap period, demonstrating consensus halt

## Notes

This vulnerability is particularly critical because it bypasses all existing validation mechanisms through a mathematical edge case in the tolerance check combined with an inconsistency in how mining intervals are calculated versus validated. The attack is practical, requiring only standard miner privileges, and causes immediate network-wide impact with no automatic recovery path.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L49-55)
```csharp
        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-99)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-36)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L13-19)
```csharp
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L157-167)
```csharp
        var miningInterval = currentRound.GetMiningInterval();
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;

        // Check normal time slot.
        if (timeSlotStartTime <= Context.CurrentBlockTime && Context.CurrentBlockTime <=
            timeSlotStartTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]NORMAL");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L19-37)
```csharp
    public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
        bool mustExceededCurrentRound = false)
    {
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }

        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
    }
```
