# Audit Report

## Title
Consensus Disruption via Unvalidated Mining Order Manipulation in UpdateValue Transaction

## Summary
The AEDPoS consensus contract fails to validate `SupposedOrderOfNextRound` and `TuneOrderInformation` fields in `UpdateValueInput`, allowing malicious miners to set arbitrary mining orders for the next round. Combined with a flawed after-execution validation that compares an object against itself, attackers can create duplicate mining orders that break consensus round transitions.

## Finding Description

The vulnerability consists of three interconnected flaws:

**Flaw 1: Missing Input Validation in ProcessUpdateValue**

The `ProcessUpdateValue` method directly accepts and applies order values from miner-provided input without verification: [1](#0-0) [2](#0-1) 

The system should calculate `SupposedOrderOfNextRound` from the miner's signature using the formula in `ApplyNormalConsensusData`: [3](#0-2) 

However, no validation exists to verify the provided value matches this calculation, and `TuneOrderInformation` modifications have no authorization checks.

**Flaw 2: Insufficient UpdateValue Validation**

The `UpdateValueValidationProvider` only validates cryptographic fields, not order manipulation: [4](#0-3) 

**Flaw 3: Broken After-Execution Validation**

The `ValidateConsensusAfterExecution` method has a critical logic error where it modifies the `currentRound` object via `RecoverFromUpdateValue`, then assigns this modified object to `headerInformation.Round`, causing the subsequent hash comparison to compare the same object against itself: [5](#0-4) [6](#0-5) 

Since `RecoverFromUpdateValue` modifies and returns `this`, both variables reference the same modified object, making the hash comparison always pass.

**Flaw 4: Reference Equality Bug in NextRoundMiningOrderValidationProvider**

While the `NextRoundMiningOrderValidationProvider` attempts to detect duplicate orders, it uses `Distinct()` on `MinerInRound` objects, which uses reference equality for protobuf messages: [7](#0-6) 

This counts distinct object references rather than distinct `FinalOrderOfNextRound` values, failing to detect duplicates.

**Attack Execution:**

1. Malicious miner produces a block with correct consensus extra data in the header (generated by `GetConsensusBlockExtraData`)
2. But includes a crafted `UpdateValue` transaction with arbitrary `SupposedOrderOfNextRound` (e.g., 1) and/or `TuneOrderInformation` setting multiple miners to the same order
3. `ValidateConsensusBeforeExecution` passes (only validates header)
4. `ProcessUpdateValue` executes, writing malicious orders to state
5. `ValidateConsensusAfterExecution` passes (compares object against itself)
6. When `GenerateNextRoundInformation` runs for the next round, it assigns duplicate `Order` values: [8](#0-7) 

## Impact Explanation

**High Severity - Consensus Integrity Violation**

Multiple miners assigned identical mining orders will attempt to produce blocks at the same time slot, causing:

1. **Fork Conditions**: Multiple valid blocks at the same height with the same order
2. **Round Transition Failure**: The blockchain cannot proceed normally to subsequent rounds
3. **Network-Wide Impact**: All nodes experience synchronization failures
4. **Service Disruption**: Token transfers, governance votes, cross-chain operations, and all other blockchain functions become unavailable
5. **Manual Intervention Required**: Emergency governance action needed to recover

This violates the critical consensus invariant: "Each miner has a unique order in each round ensuring sequential block production."

## Likelihood Explanation

**High Likelihood**

- **Reachable Entry Point**: `UpdateValue` is the standard method called by all miners during normal block production
- **Low Attacker Requirements**: Any authorized miner can exploit this; even 2 colluding miners sufficient
- **No Special Privileges Needed**: Only requires normal mining permission
- **Trivial Execution**: Craft `UpdateValueInput` with desired order values
- **No Detection**: All validation checks pass due to the bugs identified
- **Minimal Cost**: Standard transaction fees only

The combination of easy execution, low barrier to entry, and multiple bypassed validation layers makes exploitation highly probable.

## Recommendation

**Fix 1: Validate SupposedOrderOfNextRound**

In `ProcessUpdateValue`, calculate the expected value and compare:

```csharp
var expectedOrder = GetAbsModulus(updateValueInput.Signature.ToInt64(), currentRound.RealTimeMinersInformation.Count) + 1;
Assert(minerInRound.SupposedOrderOfNextRound == expectedOrder, "Invalid supposed order of next round");
```

**Fix 2: Validate TuneOrderInformation Authorization**

Only allow tuning when resolving legitimate conflicts detected during the current miner's update:

```csharp
// Calculate and verify tuning is legitimate based on current state
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    Assert(IsLegitimateOrderTuning(currentRound, tuneOrder.Key, tuneOrder.Value), 
           "Unauthorized order tuning");
}
```

**Fix 3: Fix ValidateConsensusAfterExecution**

Compare against a fresh copy of state instead of the modified object:

```csharp
if (TryToGetCurrentRoundInformation(out var currentRound))
{
    var expectedRound = currentRound.Clone(); // Create copy before modification
    if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
        expectedRound.RecoverFromUpdateValue(headerInformation.Round, headerInformation.SenderPubkey.ToHex());
    
    if (expectedRound.GetHash(isContainPreviousInValue) != currentRound.GetHash(isContainPreviousInValue))
        return new ValidationResult { Success = false, Message = "State mismatch after execution" };
}
```

**Fix 4: Fix NextRoundMiningOrderValidationProvider**

Check distinct order VALUES, not objects:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanSetDuplicateMiningOrders_BreaksConsensus()
{
    // Setup: 3 miners in round
    var round = CreateRoundWith3Miners();
    
    // Malicious miner 1 crafts UpdateValue with arbitrary order
    var maliciousInput = new UpdateValueInput
    {
        OutValue = validOutValue,
        Signature = validSignature,
        SupposedOrderOfNextRound = 1, // Should be calculated from signature, but set to 1
        TuneOrderInformation = 
        {
            { miner2Pubkey, 1 }, // Set miner 2 to also have order 1
            { miner3Pubkey, 1 }  // Set miner 3 to also have order 1
        },
        // ... other required fields
    };
    
    // Execute UpdateValue - should fail but doesn't
    await ConsensusContract.UpdateValue(maliciousInput);
    
    // Generate next round - will assign duplicate orders
    var nextRound = await GenerateNextRound();
    
    // Verify: All three miners have Order = 1 (consensus broken)
    Assert.Equal(1, nextRound.RealTimeMinersInformation[miner1Pubkey].Order);
    Assert.Equal(1, nextRound.RealTimeMinersInformation[miner2Pubkey].Order);
    Assert.Equal(1, nextRound.RealTimeMinersInformation[miner3Pubkey].Order);
    
    // Result: Consensus cannot proceed - multiple miners mining at same slot
}
```

**Notes:**
- The vulnerability requires miner-level access but no additional privileges
- Attack can be executed during any normal round
- Impact is immediate and network-wide
- The validation bypass is architectural, not a race condition
- Recovery requires emergency governance intervention

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-32)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-92)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-32)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
```
