# Audit Report

## Title
Empty Pubkey Candidate Registration Causes Consensus Failure During Term Transition

## Summary
The Election Contract accepts empty pubkey strings without validation, allowing an empty candidate to be registered and elected. When the consensus contract attempts to generate a new term with this empty pubkey, it crashes with an `IndexOutOfRangeException` during miner sorting, permanently halting blockchain consensus.

## Finding Description

The vulnerability exists in the interaction between the Election and Consensus contracts:

**Missing Validation in Registration:**

The `AnnounceElectionFor` method converts the input pubkey string to a byte array without any length validation. [1](#0-0)  When an empty string `""` is passed, `ByteArrayHelper.HexStringToByteArray("")` returns an empty byte array. [2](#0-1) 

The internal `AnnounceElection` method creates an empty `ByteString` and adds it to the candidates list without any length checks. [3](#0-2)  The existing validations only check initial miner status, banned status, and duplicate announcementsâ€”no pubkey length validation exists.

**Election Propagation:**

The empty pubkey candidate can accumulate votes through the standard voting process. The `GetValidCandidates` method filters by vote amount but performs no pubkey structure validation. [4](#0-3) 

During elections, `GetVictories` sorts candidates by `ObtainedActiveVotedVotesAmount` and returns the top N. If the empty pubkey has sufficient votes, it is included in the victory list. [5](#0-4) 

**Consensus Crash:**

During term transitions, `GenerateFirstRoundOfNextTerm` retrieves election victories and calls `GenerateFirstRoundOfNewTerm` on the miner list. [6](#0-5) 

The critical failure occurs in `GenerateFirstRoundOfNewTerm`, which attempts to create a dictionary mapping each miner's hex string to their first byte using `miner => miner[0]`. [7](#0-6) 

When `miner` is an empty `ByteString` (length = 0), the indexing operation `miner[0]` throws an `IndexOutOfRangeException`, causing the entire term generation process to crash and preventing any further term transitions.

## Impact Explanation

This is a **HIGH severity** vulnerability because it causes complete denial of service of the blockchain's consensus mechanism:

1. **Consensus Halt**: The blockchain cannot transition to new terms, freezing the miner list indefinitely
2. **Block Production Failure**: When the current term expires or miners lose authorization, block production may cease entirely
3. **Network-Wide Impact**: All network participants (users, dApps, validators) are affected by the frozen blockchain
4. **Recovery Complexity**: Requires emergency intervention through governance or potentially a hard fork to fix
5. **Economic Damage**: Halted transactions lead to frozen funds, disrupted services, and significant economic losses

The vulnerability breaks the fundamental consensus invariant that term transitions must always succeed, directly affecting the blockchain's liveness and availability guarantees.

## Likelihood Explanation

This is **MEDIUM likelihood** because:

**Attacker Requirements:**
- Must lock 100,000 ELF tokens as candidate registration deposit [8](#0-7) 
- Must coordinate sufficient voting power to place the empty candidate in the top N miners

**Feasibility Factors:**
- **Low Technical Complexity**: Single public contract call to register, followed by standard voting operations
- **High Economic Barrier**: Requires substantial capital for deposit and voting power (potentially millions of locked ELF)
- **Medium Coordination**: Can be executed by a single well-funded adversary or coordinated group
- **Detection Window**: The malicious candidate is visible in the candidate list but may not be noticed until the term transition attempt

**Assessment**: While economically expensive, the attack is technically trivial and could be executed by a determined, well-funded adversary. The one-time economic cost results in persistent blockchain DoS until fixed through governance intervention.

## Recommendation

Add pubkey length validation in the `AnnounceElection` method to ensure pubkeys meet minimum length requirements:

```csharp
private void AnnounceElection(byte[] pubkeyBytes)
{
    // Add validation
    Assert(pubkeyBytes != null && pubkeyBytes.Length > 0, "Invalid pubkey: cannot be empty.");
    
    var pubkey = pubkeyBytes.ToHex();
    var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);
    
    // ... rest of existing code
}
```

Additionally, consider adding a specific check for standard ECDSA public key length (33 or 65 bytes) to enforce proper key format:

```csharp
Assert(pubkeyBytes.Length == 33 || pubkeyBytes.Length == 65, 
    "Invalid pubkey length: must be 33 (compressed) or 65 (uncompressed) bytes.");
```

## Proof of Concept

```csharp
[Fact]
public async Task EmptyPubkey_CausesConsensusFailure_Test()
{
    // Setup: Get a sponsor with sufficient tokens
    var sponsorKeyPair = ValidationDataCenterKeyPairs.First();
    
    // Attack: Register empty pubkey candidate
    var electionStub = GetElectionContractTester(sponsorKeyPair);
    await electionStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Admin = Address.FromPublicKey(sponsorKeyPair.PublicKey),
        Pubkey = "" // Empty pubkey
    });
    
    // Verify candidate was registered
    var candidates = await electionStub.GetCandidates.CallAsync(new Empty());
    candidates.Value.Count.ShouldBeGreaterThan(0);
    
    // Simulate voting for empty candidate to make it a victory
    // (In real attack, would require coordinated voting)
    
    // When consensus attempts term transition with empty pubkey in miner list,
    // GenerateFirstRoundOfNewTerm will throw IndexOutOfRangeException
    // at: miner => miner[0] when miner.Length == 0
}
```

## Notes

The vulnerability is rooted in the missing input validation at the entry point combined with unsafe array indexing during consensus operations. The attack requires significant economic resources but is technically straightforward to execute. The impact is catastrophic as it completely halts consensus, making this a critical security issue that should be addressed immediately through adding proper pubkey length validation.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-126)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-19)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-83)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```
