# Audit Report

## Title
Inconsistent Vote Counting Allows Governance Threshold Bypass Through Member Removal

## Summary
The Association contract contains a critical inconsistency in vote threshold validation. While rejection and abstention checks correctly filter votes by current membership, the minimum vote threshold check counts ALL votes including those from removed members. This allows attackers to bypass `MaximalAbstentionThreshold` and `MaximalRejectionThreshold` by removing opposing members after they vote.

## Finding Description

The vulnerability exists in the vote counting logic that determines whether a proposal can be released. When checking if sufficient votes have been cast, the contract inconsistently applies membership filtering.

The `IsProposalAbstained()` function correctly filters abstentions to only count votes from current organization members [1](#0-0) 

Similarly, `IsProposalRejected()` filters rejections by current membership [2](#0-1) 

However, in `CheckEnoughVoteAndApprovals()`, while approvals are correctly filtered by current membership at line 49, the total vote count at lines 55-57 does NOT filter by current membership [3](#0-2) 

This inconsistency is exploitable because `RemoveMember()` can be called to remove members who have already voted, without any validation of active proposals or vote invalidation [4](#0-3) 

While voting methods correctly enforce that only current members can vote at the time of voting [5](#0-4) 

Once votes are cast, they remain in the proposal's vote lists (defined as `repeated aelf.Address` fields) even after member removal [6](#0-5) 

**Attack Flow:**
1. Malicious proposal P1 is created and voted on
2. Honest members abstain/reject, blocking the proposal due to `MaximalAbstentionThreshold` or `MaximalRejectionThreshold`
3. Attackers create and pass proposal P2 to remove the opposing members
4. Proposal P1 now passes because:
   - Abstentions/rejections from removed members no longer count (filtered check passes)
   - But their votes still count toward `MinimalVoteThreshold` (unfiltered check passes)
   - Approvals from current members meet `MinimalApprovalThreshold`

## Impact Explanation

This vulnerability allows attackers to completely bypass two critical governance safeguards designed to protect against minority-opposed proposals:
- `MaximalAbstentionThreshold`: Blocks proposals with too many abstentions (indicating lack of engagement)
- `MaximalRejectionThreshold`: Blocks proposals with too much active opposition

**Concrete Attack Scenario:**
- Organization with 15 members, thresholds: `MinimalVoteThreshold=10`, `MinimalApprovalThreshold=6`, `MaximalAbstentionThreshold=3`
- Attackers control 6 members, honest members are 9
- Malicious proposal created, 6 approve, 7 abstain
- Proposal correctly blocked (7 abstentions > 3 threshold)
- Attackers pass a second proposal removing the 7 abstaining members
- First proposal now evaluates as: Total votes=13 (includes removed members) ≥ 10, Approvals from current=6 ≥ 6, Abstentions from current=0 ≤ 3
- Malicious proposal executes despite originally failing governance checks

This compromises the integrity of Association governance, potentially leading to unauthorized fund transfers, configuration changes, or other malicious actions that the organization's threshold design intended to prevent.

## Likelihood Explanation

The attack is highly practical with realistic preconditions:

**Entry Points:** All standard public methods on the Association contract - `Approve()`, `Abstain()`, `RemoveMember()`, and `Release()` [7](#0-6) 

**Feasible Preconditions:** Attackers need:
- Sufficient members to meet `MinimalApprovalThreshold` for both proposals (typically majority or significant minority)
- Access to proposer whitelist, which is often granted to organization members
- This is realistic for scenarios where attackers have significant but not complete organizational control

**Execution Practicality:** The attack sequence uses only standard governance operations without any special privileges beyond normal proposal execution rights.

**Detection:** While the attack leaves on-chain evidence (member removal followed by proposal release), by the time it's detected, the malicious proposal has already executed and caused damage.

**Economic Rationality:** If the malicious proposal yields sufficient value (e.g., transferring organization treasury funds), the cost of executing two proposals is negligible, making this economically rational for attackers.

## Recommendation

Modify the `CheckEnoughVoteAndApprovals()` method in `Association_Helper.cs` to filter the total vote count by current organization membership, consistent with how abstentions and rejections are filtered. 

The fix should change the vote threshold check to filter by current membership, similar to how the Parliament contract correctly implements this logic [8](#0-7) 

The corrected logic should be:
- Count only votes from current organization members when checking `MinimalVoteThreshold`
- This ensures that votes from removed members do not contribute to passing the threshold

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
// Requires AElf test framework setup

[Fact]
public async Task Test_VoteCountingInconsistency_AllowsThresholdBypass()
{
    // Setup: Create organization with 15 members
    // Thresholds: MinimalVoteThreshold=10, MinimalApprovalThreshold=6, MaximalAbstentionThreshold=3
    
    // Step 1: Create malicious proposal P1
    var proposalId1 = await CreateProposal(maliciousAction);
    
    // Step 2: 6 attackers approve, 7 honest members abstain
    for (int i = 0; i < 6; i++) await Approve(proposalId1, attackers[i]);
    for (int i = 0; i < 7; i++) await Abstain(proposalId1, honestMembers[i]);
    
    // Verify P1 is blocked (7 abstentions > 3 threshold)
    var canRelease = await CanReleaseProposal(proposalId1);
    Assert.False(canRelease); // Proposal correctly blocked
    
    // Step 3: Create proposal P2 to remove the 7 abstaining members
    var proposalId2 = await CreateRemoveMemberProposal(honestMembers[0..7]);
    for (int i = 0; i < 6; i++) await Approve(proposalId2, attackers[i]);
    await ReleaseProposal(proposalId2);
    
    // Step 4: Now P1 can be released despite originally failing
    canRelease = await CanReleaseProposal(proposalId1);
    Assert.True(canRelease); // BUG: Proposal now passes!
    
    // The attack succeeds: malicious proposal executes
    await ReleaseProposal(proposalId1);
}
```

## Notes

The Parliament contract does NOT have this vulnerability - it correctly filters the total vote count by current membership. This inconsistency between Association and Parliament implementations suggests the Association contract's behavior is unintentional and represents a security flaw rather than a design choice.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-201)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }

    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Rejections.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Reject),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }

    public override Empty Abstain(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Abstentions.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Abstain),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }

    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** protobuf/association_contract.proto (L92-96)
```text
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L94-102)
```csharp
    private bool IsVoteThresholdReached(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
                .Count(parliamentMembers.Contains) * AbstractVoteTotal >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold * parliamentMembers.Count;
        return isVoteThresholdReached;
    }
```
