# Audit Report

## Title 
Incorrect Use of TotalSupply Instead of Supply in GetNeededDeposit Causes Inflated Deposit Requirements

## Summary
The `GetNeededDeposit` function incorrectly uses `tokenInfo.TotalSupply` instead of `tokenInfo.Supply` when calculating tokens in external circulation. Since `TotalSupply` represents the maximum issuable amount (immutable cap) while `Supply` represents actual circulating tokens (decreases on burn), this causes systematic overcounting of external tokens whenever tokens are burned or remain unissued, forcing users to deposit excessive base tokens when enabling connectors.

## Finding Description

The vulnerability exists in the `GetNeededDeposit` function where it calculates tokens in external circulation using `TotalSupply` instead of `Supply`. [1](#0-0) 

The TokenInfo structure defines two distinct fields with different semantics: `supply` represents "The current supply of the token" (actual circulating amount) while `total_supply` represents "The total supply of the token" (maximum cap). [2](#0-1) 

When tokens are burned, only `Supply` decreases while `TotalSupply` remains constant, as confirmed by the Burn implementation which only modifies the Supply field. [3](#0-2) 

The TokenConverter contract burns tokens through `HandleFee` on every Buy/Sell operation, with half of each transaction fee being permanently burned. [4](#0-3) 

The inflated `amountOutOfTokenConvert` is then passed to the Bancor formula to calculate the required deposit. Additionally, `TotalSupply` is incorrectly used as the token balance parameter in the Bancor calculation. [5](#0-4) 

This calculated deposit amount is strictly enforced when users call `EnableConnector`, requiring the exact inflated amount to be transferred. [6](#0-5) 

## Impact Explanation

**Economic Impact:** Users enabling connectors must deposit excessive base tokens proportional to `(TotalSupply - Supply)`. This gap grows continuously as:
1. Tokens are burned via `HandleFee` on every Buy/Sell transaction
2. Tokens remain unissued (common with gradual issuance schedules)

**Quantified Example:** 
- Token with TotalSupply = 1,000,000, Supply = 600,000 (400,000 burned/unissued)
- Contract balance = 300,000, AmountToTokenConvert = 200,000
- Wrong calculation: 1,000,000 - 300,000 - 200,000 = 500,000 tokens external
- Correct calculation: 600,000 - 300,000 - 200,000 = 100,000 tokens external
- **Result: 5x excessive deposit requirement**

**Who is Affected:** Any user attempting to enable connectors for tokens where `Supply < TotalSupply`, which includes the base token ELF itself due to fee burning in the protocol.

**Severity:** Can make connector enablement prohibitively expensive, effectively preventing token listings and locking excess capital with no benefit to the protocol or users.

## Likelihood Explanation

**Automatic Trigger:** This is not an active attack but a systemic calculation error that triggers automatically whenever `Supply < TotalSupply`, which occurs in two common scenarios:

1. **Token Burns:** Every Buy/Sell transaction burns tokens via `HandleFee`, decreasing `Supply` while `TotalSupply` remains constant
2. **Gradual Issuance:** Many tokens intentionally maintain high `TotalSupply` with gradual issuance, leaving a persistent gap between `TotalSupply` and `Supply`

**Attack Complexity:** None required - the vulnerability triggers during normal protocol operations. No special privileges needed beyond being a regular user calling `EnableConnector`.

**Feasibility:** Extremely high probability. The condition `Supply < TotalSupply` is common and persists throughout the token's lifecycle as the protocol continuously burns fees.

**Detection:** Users may notice unusually high deposit requirements but likely attribute it to the Bancor pricing model rather than identifying it as a calculation error.

## Recommendation

Replace all occurrences of `tokenInfo.TotalSupply` with `tokenInfo.Supply` in the `GetNeededDeposit` function:

**Line 73:** Change from `tokenInfo.TotalSupply` to `tokenInfo.Supply`
**Line 79-80:** Change from `tokenInfo.TotalSupply` to `tokenInfo.Supply`

The corrected calculation should be:
```csharp
var amountOutOfTokenConvert = tokenInfo.Supply - balance - input.AmountToTokenConvert;
```

And for the Bancor balance parameter:
```csharp
var tb = toConnector.IsVirtualBalanceEnabled
    ? toConnector.VirtualBalance.Add(tokenInfo.Supply)
    : tokenInfo.Supply;
```

This ensures the calculation only accounts for tokens that actually exist in circulation, not the maximum possible issuance cap.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Create a token with TotalSupply = 1,000,000
2. Issue Supply = 600,000 tokens
3. Transfer 300,000 tokens to the TokenConverter contract
4. Burn 100,000 tokens (simulating fee burns), reducing Supply to 500,000
5. Call GetNeededDeposit with AmountToTokenConvert = 200,000
6. Observe that the calculated deposit uses TotalSupply (1,000,000) instead of Supply (500,000)
7. Verify the deposit requirement is inflated by the 500,000 burned/unissued token difference

The test would show that EnableConnector enforces payment of this inflated amount, locking excess capital unnecessarily.

**Notes:**

This vulnerability affects the core economic model of the TokenConverter. The use of `TotalSupply` appears to be a conceptual error - the developer may have intended to calculate "all tokens that could ever exist" rather than "all tokens that currently exist." However, only currently existing tokens require backing deposits, as burned tokens are permanently removed from circulation and unissued tokens don't yet exist in the economy.

The impact compounds over time as the protocol naturally burns fees, making the issue progressively worse. This is particularly problematic for the base token (ELF) itself, which experiences continuous fee burning through normal protocol operations.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-73)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L77-83)
```csharp
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
```

**File:** protobuf/token_contract.proto (L255-258)
```text
    // The current supply of the token.
    int64 supply = 3;
    // The total supply of the token.
    int64 total_supply = 4;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L328-328)
```csharp
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L252-257)
```csharp
        State.TokenContract.Burn.Send(
            new BurnInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                Amount = burnFee
            });
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L276-285)
```csharp
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });
```
