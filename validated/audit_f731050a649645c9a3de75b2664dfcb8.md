# Audit Report

## Title
Null Reference Exception in GetMaximumBlocksCount() Causes Consensus DoS During Contract Upgrades with LIB Lag

## Summary
The `GetMaximumBlocksCount()` function accesses `MinedMinerListMap` entries without null checks, causing `NullReferenceException` when historical round data is missing after contract upgrades. This crashes all consensus operations during abnormal blockchain status, preventing the chain from recovering from Last Irreversible Block (LIB) lag.

## Finding Description

The vulnerable code directly accesses `.Pubkeys` on `MinedMinerListMap` entries without null validation: [1](#0-0) 

**Root Cause Chain:**

When a key doesn't exist in `MappedState`, the indexer loads null bytes from state provider and passes them to deserialization: [2](#0-1) 

These null bytes are deserialized, returning `default(T)` which is null for reference types like `MinerList`: [3](#0-2) 

**Evidence of Known Risk:**

The codebase contains defensive null checking for `MinedMinerListMap` elsewhere, proving developers are aware entries can be null: [4](#0-3) 

**Trigger Conditions:**

The vulnerable path executes when abnormal blockchain status is detected: [5](#0-4) 

Abnormal status occurs when LIB round lags by 2+ rounds: [6](#0-5) 

**Execution Path:**

This function is invoked during all consensus operations: [7](#0-6) 

Affecting all four consensus transaction types: [8](#0-7) 

**Recording Logic:**

`MinedMinerListMap` is only populated during round transitions via `RecordMinedMinerListOfCurrentRound()`: [9](#0-8) 

Called exclusively from NextRound: [10](#0-9) 

And NextTerm: [11](#0-10) 

**State Definition:**

The state variable is defined as: [12](#0-11) 

**Initial Deployment:**

FirstRound initialization does NOT populate MinedMinerListMap: [13](#0-12) 

## Impact Explanation

**Critical Consensus DoS:**
- All consensus operations (`UpdateValue`, `NextRound`, `NextTerm`, `UpdateTinyBlockInformation`) throw unhandled `NullReferenceException` and fail
- Block production completely halts during abnormal status
- The chain cannot recover from LIB lag, creating a permanent deadlock
- No graceful fallback or error handling exists

**Network-Wide Impact:**
- All miners cannot produce blocks during recovery periods
- All users cannot submit transactions
- The entire blockchain halts during the most critical recovery period when the system needs to catch up on LIB
- Creates a catch-22: abnormal status requires recovery actions, but those actions crash

**Severity: High** because:
1. Causes complete consensus failure during stress conditions
2. No recovery mechanism - the exception prevents any consensus progress
3. Affects core protocol functionality, not peripheral features
4. Breaks fundamental blockchain availability guarantees

## Likelihood Explanation

**Primary Trigger Scenario - Contract Upgrade:**

1. Consensus contract upgraded from version without `MinedMinerListMap` at round N
2. New contract state is empty (no historical data migration performed)
3. Blockchain continues operating from round N  
4. Network stress causes LIB lag (common during high load or network partitions)
5. `libRoundNumber + 2 < currentRoundNumber` becomes true (abnormal status)
6. Any consensus operation calls `GetMaximumBlocksCount()`
7. Access to `MinedMinerListMap[N-1]` and `MinedMinerListMap[N-2]` returns null
8. `NullReferenceException` thrown on `.Pubkeys` access
9. Transaction fails, consensus halts

**Alternative Scenarios:**
- State inconsistencies after chain rollbacks or consensus failures
- Early deployment edge cases with imported LIB state

**Attack Complexity:** None - this is a latent bug triggered by:
- Standard system operations (contract upgrades)
- Natural network stress conditions (LIB lag)
- No attacker interaction required

**Probability: Medium-High** because:
- Contract upgrades are common operational procedures in blockchain systems
- Network stress causing LIB lag is realistic and expected
- The combination of upgrade + stress is foreseeable
- No defensive initialization or state migration logic exists to prevent this

## Recommendation

Add null checks before accessing `MinedMinerListMap` entries in the abnormal status branch:

```csharp
if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
{
    var previousRound = State.MinedMinerListMap[currentRoundNumber.Sub(1)];
    var previousPreviousRound = State.MinedMinerListMap[currentRoundNumber.Sub(2)];
    
    // Add null checks
    if (previousRound == null || previousPreviousRound == null)
    {
        // Fallback to default maximum blocks count during recovery
        Context.LogDebug(() => "MinedMinerListMap incomplete during abnormal status, using default count");
        return AEDPoSContractConstants.MaximumTinyBlocksCount;
    }
    
    var previousRoundMinedMinerList = previousRound.Pubkeys;
    var previousPreviousRoundMinedMinerList = previousPreviousRound.Pubkeys;
    var minersOfLastTwoRounds = previousRoundMinedMinerList
        .Intersect(previousPreviousRoundMinedMinerList).Count();
    // ... rest of the logic
}
```

Additionally, implement state migration logic during contract upgrades to populate `MinedMinerListMap` with historical data, or initialize it defensively during the first execution after upgrade.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Deploy consensus contract at round 1000
2. Upgrade contract to version with `MinedMinerListMap` feature (state is empty)
3. Simulate LIB lag: set `libRoundNumber = 998`, `currentRoundNumber = 1001`
4. Call any consensus operation (e.g., `UpdateValue`)
5. Observe execution path:
   - `ProcessConsensusInformation()` is called
   - At line 68, `GetMaximumBlocksCount()` is invoked
   - Blockchain status evaluates as Abnormal (998 + 2 < 1001)
   - Lines 44-45 access `State.MinedMinerListMap[1000].Pubkeys` and `State.MinedMinerListMap[999].Pubkeys`
   - Both entries return null (not initialized post-upgrade)
   - `NullReferenceException` thrown
   - Transaction fails, consensus operation aborted

The test would verify that without null checks, the consensus operation crashes, while with the recommended fix, it gracefully falls back to default behavior.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L42-55)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L119-129)
```csharp
        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L95-108)
```csharp
    private ValuePair LoadKey(TKey key)
    {
        var path = GetSubStatePath(key.ToString());
        var bytes = Provider.Get(path);
        var value = SerializationHelper.Deserialize<TEntity>(bytes);
        var originalValue = SerializationHelper.Deserialize<TEntity>(bytes);

        return new ValuePair
        {
            OriginalValue = originalValue,
            Value = value,
            IsDeleted = false
        };
    }
```

**File:** src/AElf.Types/Helper/SerializationHelper.cs (L88-91)
```csharp
        public static T Deserialize<T>(byte[] bytes)
        {
            if (bytes == null)
                return default;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L35-53)
```csharp
        switch (input)
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
                break;
            case TinyBlockInput tinyBlockInput:
                randomNumber = tinyBlockInput.RandomNumber;
                ProcessTinyBlock(tinyBlockInput);
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L67-69)
```csharp
        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-112)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-165)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L223-230)
```csharp
    private void RecordMinedMinerListOfCurrentRound()
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        State.MinedMinerListMap.Set(currentRound.RoundNumber, new MinerList
        {
            Pubkeys = { currentRound.GetMinedMiners().Select(m => ByteStringHelper.FromHexString(m.Pubkey)) }
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L233-235)
```csharp
        var removeTargetRoundNumber = currentRound.RoundNumber.Sub(3);
        if (removeTargetRoundNumber > 0 && State.MinedMinerListMap[removeTargetRoundNumber] != null)
            State.MinedMinerListMap.Remove(removeTargetRoundNumber);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L46-46)
```csharp
    public MappedState<long, MinerList> MinedMinerListMap { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L74-92)
```csharp
    public override Empty FirstRound(Round input)
    {
        /* Basic checks. */
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
        State.FirstRoundNumberOfEachTerm[1] = 1;
        State.MiningInterval.Value = input.GetMiningInterval();
        SetMinerList(input.GetMinerList(), 1);

        AddRoundInformation(input);

        Context.LogDebug(() =>
            $"Initial Miners: {input.RealTimeMinersInformation.Keys.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");

        return new Empty();
    }
```
