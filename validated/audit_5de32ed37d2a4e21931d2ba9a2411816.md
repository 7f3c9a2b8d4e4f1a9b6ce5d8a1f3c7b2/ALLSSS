# Audit Report

## Title
Proposal Hash Squatting via Expired Entry Overwrite Enables Denial-of-Service and Authorship Hijacking

## Summary
The `RegisterContractProposingData` function in the Genesis contract allows any address to overwrite expired proposal entries without validating they are the original proposer. This enables attackers to hijack expired proposal hashes, permanently blocking legitimate proposers from re-submitting their proposals and potentially stealing contract authorship through governance manipulation.

## Finding Description

The vulnerability exists in the `RegisterContractProposingData` helper function [1](#0-0) , which is invoked during contract deployment and update proposals [2](#0-1) [3](#0-2) .

The root cause is insufficient validation when an expired proposal entry is overwritten. The function checks whether no entry exists OR the current time exceeds the expiration time [4](#0-3) , but then unconditionally creates a new entry with the caller as the proposer [5](#0-4) . There is no verification that the caller is the original proposer when overwriting an expired entry.

Proposal hashes are deterministically computed from input parameters [6](#0-5) . The default expiration period is 72 hours (259,200 seconds) [7](#0-6) .

The proposer identity is critical because:
1. `ReleaseApprovedContract` validates that only the registered proposer can progress the proposal [8](#0-7) 
2. When contracts are deployed, the proposer can become the contract author (if whitelisted) [9](#0-8) [10](#0-9) 

**Attack Flow:**
1. Original proposer Alice calls `ProposeNewContract` with specific parameters, creating a proposal entry that expires in 72 hours
2. Proposal expires due to governance delays or timing issues  
3. Attacker Bob calls `ProposeNewContract` with identical parameters
4. `RegisterContractProposingData` allows the overwrite because `Context.CurrentBlockTime >= registered.ExpiredTime`
5. Bob becomes the new proposer, locking out Alice for another 72 hours
6. If Bob is whitelisted and his proposal passes governance, Bob becomes the contract author

## Impact Explanation

**Denial-of-Service Impact:** When a legitimate proposer's entry expires, an attacker can immediately re-register the same proposal hash as their own. The original proposer cannot re-submit for another 72 hours due to the "Already proposed" assertion. For deterministic contract deployments requiring specific salt values to achieve particular contract addresses, this becomes a permanent denial-of-service since changing the salt changes the resulting address.

**Authorship Hijacking Impact:** If the attacker is in the deployment controller's proposer whitelist and their duplicate proposal passes through Parliament approval and code checking, the attacker becomes the contract author instead of the legitimate designer. Contract authors have privileged operations including the ability to propose contract updates [11](#0-10)  and transfer authorship [12](#0-11) .

**Indefinite Squatting:** An attacker can maintain control over a proposal hash indefinitely by re-registering it every 72 hours before expiration, effectively preventing the legitimate proposer from ever using those parameters.

This violates the security invariant that proposal lifecycle should be controlled exclusively by the original proposer.

## Likelihood Explanation

**Attack Complexity:** Low. The attacker needs to:
1. Monitor the chain for expired proposal entries (easily automated)
2. Extract the input parameters from the original proposal transaction (publicly available on-chain)
3. Call `ProposeNewContract` or `ProposeUpdateContract` with identical parameters immediately after expiration

**Economic Barriers:** Minimal. No explicit fees, stakes, or deposits are required beyond standard transaction gas costs. The attacker doesn't need to complete the full governance process to achieve denial-of-service; merely registering the hash is sufficient to block the legitimate proposer.

**Entry Points:** The attack uses public methods `ProposeNewContract` [2](#0-1)  and `ProposeUpdateContract` [3](#0-2)  that are accessible to any address.

**Realistic Scenario:** Legitimate proposals may expire due to governance bottlenecks, Parliament coordination delays, or deliberate timing by participants. Once expired, they become vulnerable to hijacking.

## Recommendation

Add validation in `RegisterContractProposingData` to ensure that when overwriting an expired entry, the caller must be the original proposer:

```csharp
private void RegisterContractProposingData(Hash proposedContractInputHash)
{
    var registered = State.ContractProposingInputMap[proposedContractInputHash];
    
    // If entry exists and is expired, only allow original proposer to re-register
    if (registered != null && Context.CurrentBlockTime >= registered.ExpiredTime)
    {
        Assert(registered.Proposer == Context.Sender, "Only original proposer can re-register expired proposal.");
    }
    else
    {
        Assert(registered == null, "Already proposed.");
    }
    
    var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
    State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
    {
        Proposer = Context.Sender,
        Status = ContractProposingInputStatus.Proposed,
        ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
    };
}
```

Alternatively, automatically clean up expired entries or extend the expiration time for the original proposer upon re-submission.

## Proof of Concept

```csharp
[Fact]
public async Task ProposalHashSquatting_ExploitTest()
{
    // Alice proposes a contract
    var aliceAddress = Address.FromString("Alice");
    var bobAddress = Address.FromString("Bob");
    
    var deploymentInput = new ContractDeploymentInput
    {
        Category = 0,
        Code = ByteString.CopyFrom(new byte[] { 0x01, 0x02, 0x03 })
    };
    
    // Alice proposes at time T
    var proposalHash = await GenesisContract.ProposeNewContract.SendAsync(deploymentInput);
    
    // Verify Alice is the proposer
    var proposalInfo1 = await GenesisContract.ContractProposingInputMap[proposalHash].GetAsync();
    Assert.Equal(aliceAddress, proposalInfo1.Proposer);
    
    // Advance time by 72 hours + 1 second to expire the proposal
    await AdvanceBlockTimeAsync(259201);
    
    // Bob hijacks the expired proposal by re-proposing with identical parameters
    await GenesisContract.ProposeNewContract.SendWithDifferentSender(deploymentInput, bobAddress);
    
    // Verify Bob is now the proposer
    var proposalInfo2 = await GenesisContract.ContractProposingInputMap[proposalHash].GetAsync();
    Assert.Equal(bobAddress, proposalInfo2.Proposer);
    
    // Alice cannot re-propose (DoS)
    var result = await GenesisContract.ProposeNewContract.SendWithExpectedExceptionAsync(deploymentInput, aliceAddress);
    Assert.Contains("Already proposed", result.TransactionResult.Error);
    
    // If Bob is whitelisted and proposal passes, Bob becomes the author instead of Alice
}
```

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L175-178)
```csharp
    private Hash CalculateHashFromInput(IMessage input)
    {
        return HashHelper.ComputeFrom(input);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L122-173)
```csharp
    public override Hash ProposeNewContract(ContractDeploymentInput input)
    {
        // AssertDeploymentProposerAuthority(Context.Sender);
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();

        if (input.ContractOperation != null)
        {
            ValidateContractOperation(input.ContractOperation, 0, codeHash);
            
            // Remove one time signer if exists. Signer is only needed for validating signature.
            RemoveOneTimeSigner(input.ContractOperation.Deployer);
            
            AssertContractAddressAvailable(input.ContractOperation.Deployer, input.ContractOperation.Salt);
        }

        // Create proposal for deployment
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName =
                    nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.ProposeContractCodeCheck),
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(DeploySmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = input.Category,
                    IsSystemContract = false
                }.ToByteString(),
                OrganizationAddress = State.ContractDeploymentController.Value.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
            },
            OriginProposer = Context.Sender
        };
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput.ToByteString());

        Context.Fire(new ContractProposed
        {
            ProposedContractInputHash = proposedContractInputHash
        });

        return proposedContractInputHash;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-232)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);

        Assert((input.Address == Context.Self || info.SerialNumber > 0) && input.ContractOperation == null ||
               info.SerialNumber == 0 && input.ContractOperation != null, "Not compatible.");

        if (input.ContractOperation != null)
        {
            ValidateContractOperation(input.ContractOperation, info.Version, codeHash);
            RemoveOneTimeSigner(input.ContractOperation.Deployer);
            AssertSameDeployer(input.Address, input.ContractOperation.Deployer);
        }

        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();

        // Create proposal for contract update
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName =
                    nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.ProposeContractCodeCheck),
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(UpdateSmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = info.Category,
                    IsSystemContract = info.IsSystemContract
                }.ToByteString(),
                OrganizationAddress = State.ContractDeploymentController.Value.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
            },
            OriginProposer = Context.Sender
        };
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);

        Context.Fire(new ContractProposed
        {
            ProposedContractInputHash = proposedContractInputHash
        });

        return proposedContractInputHash;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L277-290)
```csharp
    public override Empty ReleaseApprovedContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];
        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.Proposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
        contractProposingInput.Status = ContractProposingInputStatus.Approved;
        State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release),
            input.ProposalId.ToByteString());
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L309-322)
```csharp
    public override Address DeploySmartContract(ContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        // AssertDeploymentProposerAuthority(Context.Origin);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address =
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
        return address;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L519-535)
```csharp
    public override Empty SetContractAuthor(SetContractAuthorInput input)
    {
        var info = State.ContractInfos[input.ContractAddress];
        Assert(info != null, "Contract not found.");
        var oldAuthor = info.Author;
        Assert(Context.Sender == info.Author, "No permission.");
        info.Author = input.NewAuthor;
        State.ContractInfos[input.ContractAddress] = info;
        Context.Fire(new AuthorUpdated()
        {
            Address = input.ContractAddress,
            OldAuthor = oldAuthor,
            NewAuthor = input.NewAuthor
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-5)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
```
