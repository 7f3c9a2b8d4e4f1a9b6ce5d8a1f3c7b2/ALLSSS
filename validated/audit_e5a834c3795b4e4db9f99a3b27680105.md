# Audit Report

## Title
Cross-Chain Token Property Inconsistency Allows Denial of Service on Cross-Chain Transfers

## Summary
The `CrossChainCreateToken` function fails to update critical token properties when a token already exists on the destination chain, only modifying the ExternalInfo field. An attacker can front-run legitimate cross-chain token deployments by creating tokens with mismatched properties (particularly `IssueChainId`), permanently breaking cross-chain transfer functionality for that token symbol.

## Finding Description

The vulnerability exists in `CrossChainCreateToken`'s handling of pre-existing tokens. When a token symbol already exists on the destination chain, the function only updates the ExternalInfo field for NFT alias synchronization, leaving all critical security properties unchanged. [1](#0-0) 

Critical properties that remain frozen include:
- **IssueChainId**: Required for cross-chain transfer validation
- **TotalSupply**: Controls maximum token issuance
- **Decimals**: Defines token precision
- **Issuer**: Controls who can issue tokens
- **Owner**: Controls token management rights

The `ValidateTokenInfoExists` function explicitly validates all these properties as security-critical, confirming they must match between chains: [2](#0-1) 

**Attack Vector: Front-Running Cross-Chain Token Creation**

On the main chain (where `State.SideChainCreator.Value == null`), anyone can create tokens by burning seed NFTs: [3](#0-2) 

Critically, the `Create` function accepts user-controlled `IssueChainId` without validation: [4](#0-3) 

The validation function `AssertValidCreateInput` does NOT check IssueChainId: [5](#0-4) 

An attacker can exploit this by:
1. Obtaining a seed NFT for the target token symbol
2. Calling `Create()` with an incorrect `IssueChainId` before legitimate cross-chain synchronization
3. When legitimate `CrossChainCreateToken` is called, it finds the token exists and fails to update properties
4. The `IssueChainId` mismatch permanently breaks cross-chain transfers

The `CrossChainReceiveToken` function enforces strict `IssueChainId` validation: [6](#0-5) 

When the stored `IssueChainId` doesn't match the transfer's `IssueChainId`, this assertion fails, permanently blocking all cross-chain transfers for that token.

## Impact Explanation

**Critical Cross-Chain Transfer Failure**

When `IssueChainId` (or other properties) diverge between chains, the protocol's cross-chain transfer mechanism becomes permanently inoperable:
- Users cannot transfer tokens between chains
- The token loses all cross-chain utility
- DApps and DEXs expecting cross-chain operations fail
- TokenConverter contracts may operate with incorrect decimal precision

**No Recovery Mechanism**

The `SetTokenInfo` method that could update token properties is private: [7](#0-6) 

There is no public method in the token contract to update token properties after creation. Once a token is created with wrong properties, it cannot be fixed through the protocol.

**Economic Impact**
- Token holders lose cross-chain functionality and liquidity
- The attacker's cost is one seed NFT, making this economically viable for disrupting valuable tokens
- Legitimate token projects suffer reputational damage

## Likelihood Explanation

**Public Entry Point with Minimal Guards**

`CrossChainCreateToken` is a public RPC method accessible to anyone with valid merkle proofs. The only requirement is that the source chain's token contract address is registered via `RegisterCrossChainTokenContractAddress` (a one-time administrative action). [8](#0-7) 

**Economically Feasible Attack**

On the main chain, token creation requires burning a seed NFT. For high-value tokens with significant cross-chain usage, the cost of one seed NFT is negligible compared to the disruption caused.

**Test Evidence of Intentional Behavior Change**

A test explicitly shows this behavior was intentionally changed to "allow" calling `CrossChainCreateToken` when the token exists: [9](#0-8) 

This confirms the behavior change was intentional but the security implications were not fully considered.

## Recommendation

**Option 1: Reject CrossChainCreateToken for Existing Tokens**

Revert to the previous behavior where `CrossChainCreateToken` fails if the token already exists. This prevents property inconsistencies but may require additional coordination for legitimate cross-chain deployments.

```csharp
if (State.TokenInfos[tokenInfo.Symbol] != null)
{
    Assert(false, "Token already exists.");
}
```

**Option 2: Update All Properties When Token Exists**

Allow `CrossChainCreateToken` to overwrite existing token properties, but require proper authorization (e.g., from token owner or governance):

```csharp
if (State.TokenInfos[tokenInfo.Symbol] != null)
{
    var existingToken = State.TokenInfos[tokenInfo.Symbol];
    // Require authorization from existing token owner
    Assert(Context.Sender == existingToken.Owner || 
           IsAddressInCreateWhiteList(Context.Sender), 
           "Not authorized to update token.");
    
    // Update all critical properties
    existingToken.IssueChainId = tokenInfo.IssueChainId;
    existingToken.TotalSupply = tokenInfo.TotalSupply;
    existingToken.Decimals = tokenInfo.Decimals;
    existingToken.Issuer = tokenInfo.Issuer;
    existingToken.Owner = tokenInfo.Owner;
    existingToken.TokenName = tokenInfo.TokenName;
    existingToken.IsBurnable = tokenInfo.IsBurnable;
    
    // Also update external info for NFT alias
    if (isSymbolAliasSet && 
        validateTokenInfoExistsInput.ExternalInfo.TryGetValue(
            TokenContractConstants.TokenAliasExternalInfoKey, out var tokenAliasSetting))
    {
        existingToken.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey] = tokenAliasSetting;
    }
    
    SetTokenInfo(existingToken);
}
```

**Option 3: Validate IssueChainId in Create Function**

Add validation to ensure `IssueChainId` can only be set to the current chain or remains unspecified:

```csharp
private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
{
    Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
           && input.Symbol.Length > 0
           && input.Decimals >= 0
           && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");
    
    // Validate IssueChainId
    Assert(input.IssueChainId == 0 || input.IssueChainId == Context.ChainId,
           "Invalid issue chain id.");

    CheckSymbolLength(input.Symbol, symbolType);
    if (symbolType == SymbolType.Nft) return;
    CheckTokenAndCollectionExists(input.Symbol);
    if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
}
```

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreateToken_PropertyInconsistency_DoS_Test()
{
    // Setup: Create a token on side chain with correct IssueChainId
    await GenerateSideChainAsync();
    var sideChainId = ChainHelper.ConvertBase58ToChainId("tDVW");
    
    // Step 1: Attacker creates token on main chain with WRONG IssueChainId
    var attackerSeedSymbol = "ATTACK-SEED-0";
    await CreateSeedNFT(attackerSeedSymbol);
    
    var maliciousCreateInput = new CreateInput
    {
        Symbol = "ATTACK",
        TokenName = "Attack Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAccount.Address,
        IsBurnable = true,
        IssueChainId = 999, // WRONG chain ID set by attacker
        Owner = DefaultAccount.Address
    };
    
    await TokenContractStub.Create.SendAsync(maliciousCreateInput);
    
    // Step 2: Legitimate CrossChainCreateToken is called from side chain
    var legitimateTokenInfo = new TokenInfo
    {
        Symbol = "ATTACK",
        TokenName = "Attack Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = SideChainTestKit.DefaultAccount.Address,
        IsBurnable = true,
        IssueChainId = sideChainId, // Correct chain ID
        Owner = SideChainTestKit.DefaultAccount.Address
    };
    
    var validationTx = CreateTokenInfoValidationTransaction(legitimateTokenInfo, TokenContractStub);
    var executedSet = await MineAsync(new List<Transaction> { validationTx });
    var merklePath = GetTransactionMerklePathAndRoot(validationTx, out var blockRoot);
    
    await IndexSideChainTransactionAsync(executedSet.Height, blockRoot, sideChainId);
    
    var crossChainInput = new CrossChainCreateTokenInput
    {
        FromChainId = sideChainId,
        ParentChainHeight = executedSet.Height,
        TransactionBytes = validationTx.ToByteString(),
        MerklePath = merklePath
    };
    
    // CrossChainCreateToken succeeds but doesn't update IssueChainId
    await TokenContractStub.CrossChainCreateToken.SendAsync(crossChainInput);
    
    // Step 3: Verify token has WRONG IssueChainId
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
    {
        Symbol = "ATTACK"
    });
    
    Assert.Equal(999, tokenInfo.IssueChainId); // Still has attacker's wrong value!
    Assert.NotEqual(sideChainId, tokenInfo.IssueChainId); // Not the legitimate value
    
    // Step 4: Attempt cross-chain transfer - this will FAIL
    var transferInput = new CrossChainTransferInput
    {
        To = DefaultAccount.Address,
        Symbol = "ATTACK",
        Amount = 100,
        ToChainId = ChainHelper.ConvertBase58ToChainId("AELF"),
        IssueChainId = sideChainId, // Legitimate chain ID
        Memo = "Test transfer"
    };
    
    var transferTx = await SideChainTokenContractStub.CrossChainTransfer.SendAsync(transferInput);
    
    // Now try to receive on main chain
    var receiveInput = new CrossChainReceiveTokenInput
    {
        FromChainId = sideChainId,
        ParentChainHeight = transferTx.TransactionResult.BlockNumber,
        TransferTransactionBytes = transferTx.Transaction.ToByteString(),
        MerklePath = GetMerklePath(transferTx.TransactionResult.TransactionId)
    };
    
    // This FAILS because IssueChainId doesn't match
    var result = await TokenContractStub.CrossChainReceiveToken.SendWithExceptionAsync(receiveInput);
    
    Assert.True(result.TransactionResult.Status == TransactionResultStatus.Failed);
    Assert.Contains("Incorrect issue chain id", result.TransactionResult.Error);
    
    // Cross-chain transfers are now PERMANENTLY broken for this token!
}
```

## Notes

This vulnerability represents a critical flaw in the cross-chain token synchronization mechanism. The root cause is the combination of:

1. **Insufficient validation** in the `Create` function allowing arbitrary `IssueChainId` values
2. **Incomplete update logic** in `CrossChainCreateToken` that only modifies ExternalInfo for existing tokens
3. **No recovery mechanism** to fix incorrect token properties after creation

The test evidence showing the behavior was intentionally changed to "allow" CrossChainCreateToken on existing tokens suggests this was a design decision made for NFT alias synchronization without fully considering the security implications for other token properties.

The impact is severe because cross-chain functionality is a core feature of the AElf ecosystem, and this vulnerability allows cheap disruption of high-value tokens' cross-chain operations with no recovery path.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L54-65)
```csharp
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L76-76)
```csharp
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L444-447)
```csharp
        var validationResult = tokenInfo.TokenName == input.TokenName &&
                               tokenInfo.IsBurnable == input.IsBurnable && tokenInfo.Decimals == input.Decimals &&
                               tokenInfo.Issuer == input.Issuer && tokenInfo.TotalSupply == input.TotalSupply &&
                               tokenInfo.IssueChainId == input.IssueChainId && tokenInfo.Owner == input.Owner;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-488)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L522-531)
```csharp
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L608-609)
```csharp
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L418-422)
```csharp
    private void SetTokenInfo(TokenInfo tokenInfo)
    {
        var symbol = tokenInfo.Symbol;
        State.TokenInfos[symbol] = tokenInfo;
    }
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/MultiTokenContractCrossChainTest.cs (L328-328)
```csharp
    [Fact(Skip = "Now we allow this.")]
```
