# Audit Report

## Title
Threshold Mismatch in Secret Sharing Reconstruction on Side Chains Leads to Consensus State Corruption

## Summary
The `RevealSharedInValues` function in the AEDPoS consensus contract incorrectly calculates the Shamir secret sharing threshold using the current round's miner count instead of the previous round's miner count. When side chains update their miner list from the main chain, this causes a threshold mismatch between secret encoding and decoding, resulting in incorrect secret reconstruction and corrupted consensus state.

## Finding Description

The vulnerability exists in the `RevealSharedInValues` function where the threshold calculation uses the wrong round's miner count: [1](#0-0) 

The function calculates `minimumCount` from `currentRound.RealTimeMinersInformation.Count`, but the secrets being decoded were originally encoded in the previous round. The function then iterates through `previousRound.RealTimeMinersInformation` and attempts to decode those secrets using the current round's threshold: [2](#0-1) 

This contrasts with the correct implementation in `SecretSharingService`, which consistently uses the same round's miner count for both threshold calculation and secret operations: [3](#0-2) [4](#0-3) 

**Exploitation Path on Side Chains:**

Side chains update their miner list from the main chain via cross-chain updates: [5](#0-4) 

When the main chain miner list changes, the side chain's round generation detects this and creates a new round with the updated miner count: [6](#0-5) [7](#0-6) 

Subsequently, when `RevealSharedInValues` is called during extra block generation: [8](#0-7) 

The function attempts to decode secrets from a round with N miners using a threshold calculated from a round with M miners (where M â‰  N), violating the fundamental requirement of Shamir's secret sharing.

## Impact Explanation

**Consensus State Corruption:**

Shamir's secret sharing requires the same threshold for encoding and decoding. The implementation uses Lagrange interpolation for reconstruction: [9](#0-8) 

When the threshold parameter doesn't match the encoding threshold, the Lagrange interpolation reconstructs an incorrect secret value. This incorrectly decoded value is then stored as `PreviousInValue` in the consensus state: [10](#0-9) 

These corrupted `PreviousInValue` entries pollute the consensus state. The `PreviousInValue` is used in signature calculations that determine mining order through randomness. This breaks the consensus randomness invariant, as the revealed values no longer correspond to the actual in values used by miners, compromising the integrity of the secret sharing mechanism used for consensus security.

**Who is Affected:**

All side chains in the AElf ecosystem are vulnerable whenever the main chain undergoes a miner list update, which is a regular occurrence in the consensus protocol.

## Likelihood Explanation

**High Likelihood - Occurs Automatically:**

This vulnerability triggers automatically during normal consensus operations:

1. **Reachable Entry Point:** The vulnerability is in the consensus flow executed during extra block production via `GetConsensusExtraData`.

2. **Feasible Preconditions:**
   - Side chain is running (standard configuration)
   - Main chain undergoes a miner list update (regular occurrence)
   - Side chain syncs the new miner list via `UpdateInformationFromCrossChain`
   
3. **Execution Practicality:** The bug triggers during the second round after the side chain adopts a new miner count from the main chain (when transitioning from the first new-miner-list round to the second). No special conditions or attacker involvement required - this happens during normal consensus operations.

## Recommendation

Fix the threshold calculation in `RevealSharedInValues` to use the previous round's miner count instead of the current round's:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    Context.LogDebug(() => "About to reveal shared in values.");
    
    if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;
    
    if (!TryToGetPreviousRoundInformation(out var previousRound)) return;
    
    // FIX: Use previousRound's miner count for threshold calculation
    var minersCount = previousRound.RealTimeMinersInformation.Count;
    var minimumCount = minersCount.Mul(2).Div(3);
    minimumCount = minimumCount == 0 ? 1 : minimumCount;
    
    foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
    {
        // ... rest of the logic remains the same
    }
}
```

Alternatively, skip secret revelation entirely when the miner list has just changed:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    Context.LogDebug(() => "About to reveal shared in values.");
    
    if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;
    
    if (!TryToGetPreviousRoundInformation(out var previousRound)) return;
    
    // Skip revelation if miner list has changed
    if (currentRound.IsMinerListJustChanged) return;
    
    // ... rest of the logic
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ThresholdMismatch_WhenMinerListChanges_CorruptsPreviousInValue()
{
    // Setup: Side chain with 5 initial miners
    var initialMiners = 5;
    var newMiners = 3;
    
    // Round N: 5 miners perform secret sharing
    // Encoded with threshold = 5 * 2/3 = 3
    await ProduceNormalBlocksWithSecretSharing(initialMiners);
    
    // Main chain updates miner list to 3 miners
    await UpdateMinerListFromMainChain(newMiners);
    
    // Round N+1: Generated with 3 miners, IsMinerListJustChanged = true
    // Secret sharing disabled for this round
    await ProduceExtraBlockForRoundTransition();
    
    // Round N+1 -> N+2 transition: RevealSharedInValues called
    // currentRound has 3 miners -> threshold = 3 * 2/3 = 2
    // previousRound (N) has 5 miners -> secrets encoded with threshold = 3
    // VULNERABILITY: Decoding with threshold=2 when encoded with threshold=3
    var result = await ProduceExtraBlockForRoundTransition();
    
    // Verify: PreviousInValue is incorrectly decoded
    var currentRoundInfo = await GetCurrentRoundInformation();
    var previousInValue = currentRoundInfo.RealTimeMinersInformation.Values.First().PreviousInValue;
    
    // The decoded PreviousInValue will be cryptographically incorrect
    // because Lagrange interpolation used wrong threshold
    Assert.NotEqual(expectedCorrectInValue, previousInValue);
}
```

## Notes

The vulnerability specifically manifests when the new miner list size is smaller than or equal to the previous miner list size. The check at line 36 of `RevealSharedInValues` (`if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount)`) only skips decoding when the previous round had fewer decrypted pieces than the current round's miner count. When the old miner list is larger, this check passes and decoding proceeds with the wrong threshold.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L25-53)
```csharp
        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L101-104)
```csharp
        var minersCount = secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        var secretShares =
            SecretSharingHelper.EncodeSecret(newInValue.ToByteArray(), minimumCount, minersCount);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L144-149)
```csharp
    private void RevealPreviousInValues(SecretSharingInformation secretSharingInformation, string selfPubkey)
    {
        var round = secretSharingInformation.PreviousRound;
        var minersCount = round.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-64)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L285-295)
```csharp
    private void GenerateNextRoundInformation(Round currentRound, Timestamp currentBlockTime, out Round nextRound)
    {
        TryToGetPreviousRoundInformation(out var previousRound);
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-189)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```
