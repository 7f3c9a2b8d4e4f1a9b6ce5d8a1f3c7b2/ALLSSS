# Audit Report

## Title
Permanent Method Fee Controller Lock Due to Null Parliament Contract During Initialization

## Summary
The TokenContract's `RequiredMethodFeeControllerSet()` method contains a critical flaw that persists an `AuthorityInfo` with null `OwnerAddress` when the Parliament contract is not deployed. This creates an irrecoverable state where all method fee governance operations permanently fail, with no administrative override mechanism.

## Finding Description

The vulnerability exists in the `RequiredMethodFeeControllerSet()` helper method that initializes the method fee controller authority. [1](#0-0) 

When `State.MethodFeeController.Value` is null, the method attempts to retrieve the Parliament contract address. If Parliament is not deployed or registered, `Context.GetContractAddressByName()` returns null, creating an empty `AuthorityInfo` object. The conditional check at line 101 fails because `State.ParliamentContract.Value` is null, leaving the object's `OwnerAddress` and `ContractAddress` fields null. This invalid authority is then unconditionally persisted to state at line 108.

The defensive code comment "Parliament Auth Contract maybe not deployed" indicates developers anticipated this scenario, but the handling creates a worse problem than immediate failure. [2](#0-1) 

Once corrupted, subsequent calls to `ChangeMethodFeeController()` will always fail. [3](#0-2) 

The authorization check at line 27 delegates to `AssertSenderAddressWith()` which compares `Context.Sender` against nullâ€”an assertion that can never pass in AElf's execution model. [4](#0-3) 

Similarly, `SetMethodFee()` performs the same check and will permanently fail. [5](#0-4) 

The `CheckOrganizationExist()` validation would also fail as it attempts to call a null contract address. [6](#0-5) 

## Impact Explanation

**Complete Governance Breakdown**: The method fee controller becomes permanently locked. No address can satisfy the `Context.Sender == null` check, preventing all changes to transaction fee parameters for the TokenContract.

**No Recovery Path**: Contract upgrades via `UpdateSmartContract` preserve state rather than resetting it. [7](#0-6) 

The update mechanism modifies code but maintains contract state. Any migration logic would still require passing the broken authorization check. No administrative override exists, as verified by examining the authorization methods. [8](#0-7) 

**Critical System Impact**: TokenContract is a foundational system contract. Loss of fee governance affects the ability to adjust economic parameters critical for chain operation.

**Severity: HIGH** - Permanent, irrecoverable loss of method fee governance for a critical system contract.

## Likelihood Explanation

**Precondition**: `RequiredMethodFeeControllerSet()` must be called before Parliament contract deployment. This can occur via `GetMethodFeeController()` (a public view method with no authorization), `SetMethodFee()`, or `ChangeMethodFeeController()`. [9](#0-8) 

**Deployment Order**: In standard test configurations, Token is deployed before Parliament. [10](#0-9) 

**Production Protection**: In production mainchain/sidechain genesis blocks, all contracts deploy atomically with no external call window between Token and Parliament initialization. [11](#0-10) 

The network only starts accepting external transactions after genesis is complete (line 73), ensuring all system contracts are deployed before any external calls can be made.

**Vulnerable Scenarios**:
- Test environments where Parliament is intentionally omitted
- Custom deployment configurations outside standard initialization flow
- Manual contract deployments
- Development/staging environments

The code's defensive handling with the "maybe not deployed" comment confirms developers anticipated this scenario, suggesting it's considered a realistic edge case rather than impossible.

**Trigger Complexity**: LOW - Single call to `GetMethodFeeController()` (a public view method) triggers the corruption if preconditions are met.

**Overall Likelihood: MEDIUM** - Unlikely in production with standard procedures, but realistic in test/development environments and custom deployments where the defensive code pattern indicates this scenario was anticipated.

## Recommendation

Modify `RequiredMethodFeeControllerSet()` to either:

1. **Fail fast when Parliament is not deployed** instead of persisting null values:
   - Remove the unconditional persistence at line 108
   - Assert that Parliament contract exists before setting the controller
   - Return early or throw an exception if Parliament is not available

2. **Add a recovery mechanism** that allows resetting the controller through an alternative authorization path:
   - Add a privileged method that can reset the MethodFeeController when it's in an invalid state
   - Use Genesis contract authority or another trusted system contract as a fallback

3. **Validate controller state** in authorization checks:
   - Check that `OwnerAddress` is not null before comparing against `Context.Sender`
   - Provide clear error messages when the controller is in an invalid state

The defensive comment acknowledges the scenario but the current handling (persisting invalid state) is worse than immediate failure, which would allow operators to recognize and address the issue during deployment.

## Proof of Concept

```csharp
[Fact]
public async Task MethodFeeController_PermanentLock_WhenParliamentNotDeployed()
{
    // Setup: Deploy Token contract WITHOUT Parliament contract
    var tokenContract = await DeployTokenContractWithoutParliamentAsync();
    
    // Trigger: Call GetMethodFeeController (public view method)
    // This will initialize controller with null OwnerAddress
    var controller = await tokenContract.GetMethodFeeController.CallAsync(new Empty());
    
    // Verify: Controller has null OwnerAddress
    controller.OwnerAddress.ShouldBeNull();
    controller.ContractAddress.ShouldBeNull();
    
    // Impact: All governance operations now permanently fail
    // Attempting to change controller fails with "Unauthorized behavior"
    var newController = new AuthorityInfo { /* any valid authority */ };
    var result = await tokenContract.ChangeMethodFeeController.SendWithExceptionAsync(newController);
    result.TransactionResult.Error.ShouldContain("Unauthorized behavior");
    
    // Attempting to set method fees fails with "Unauthorized to set method fee"
    var methodFees = new MethodFees { /* any valid fees */ };
    var feeResult = await tokenContract.SetMethodFee.SendWithExceptionAsync(methodFees);
    feeResult.TransactionResult.Error.ShouldContain("Unauthorized to set method fee");
    
    // Even after deploying Parliament contract later, the lock persists
    await DeployParliamentContractAsync();
    
    // Controller remains locked because state was already persisted with nulls
    var changeResult = await tokenContract.ChangeMethodFeeController.SendWithExceptionAsync(newController);
    changeResult.TransactionResult.Error.ShouldContain("Unauthorized behavior");
}
```

## Notes

This vulnerability demonstrates a design flaw where defensive programming (handling the "Parliament maybe not deployed" scenario) inadvertently creates a worse security state than would occur from immediate failure. The atomic deployment in production environments provides protection, but the presence of the defensive code pattern confirms that non-standard deployment scenarios were anticipated by developers and should be considered realistic attack vectors for test, development, and custom deployment environments.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L54-58)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L91-109)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo();

        // Parliament Auth Contract maybe not deployed.
        if (State.ParliamentContract.Value != null)
        {
            defaultAuthority.OwnerAddress =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L111-114)
```csharp
    private void AssertSenderAddressWith(Address address)
    {
        Assert(Context.Sender == address, "Unauthorized behavior.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L98-144)
```csharp
    private void UpdateSmartContract(Address contractAddress, byte[] code, Address author, bool isUserContract)
    {
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        Assert(author == info.Author, "No permission.");

        var oldCodeHash = info.CodeHash;
        var newCodeHash = HashHelper.ComputeFrom(code);
        Assert(oldCodeHash != newCodeHash, "Code is not changed.");
        AssertContractNotExists(newCodeHash);

        info.CodeHash = newCodeHash;
        info.IsUserContract = isUserContract;
        info.Version++;

        var reg = new SmartContractRegistration
        {
            Category = info.Category,
            Code = ByteString.CopyFrom(code),
            CodeHash = newCodeHash,
            IsSystemContract = info.IsSystemContract,
            Version = info.Version,
            ContractAddress = contractAddress,
            IsUserContract = isUserContract
        };

        var contractInfo = Context.UpdateSmartContract(contractAddress, reg, null, info.ContractVersion);
        Assert(contractInfo.IsSubsequentVersion,
            $"The version to be deployed is lower than the effective version({info.ContractVersion}), please correct the version number.");

        info.ContractVersion = contractInfo.ContractVersion;
        reg.ContractVersion = info.ContractVersion;

        State.ContractInfos[contractAddress] = info;
        State.SmartContractRegistrations[reg.CodeHash] = reg;

        Context.Fire(new CodeUpdated
        {
            Address = contractAddress,
            OldCodeHash = oldCodeHash,
            NewCodeHash = newCodeHash,
            Version = info.Version,
            ContractVersion = info.ContractVersion
        });

        Context.LogDebug(() => "BasicContractZero - update success: " + contractAddress.ToBase58());
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L16-43)
```csharp
    public override Empty InitializeAuthorizedController(Empty input)
    {
        var defaultParliamentController = GetDefaultParliamentController();
        if (State.UserFeeController.Value == null)
        {
            var defaultUserFeeController = GetDefaultUserFeeController(defaultParliamentController);
            CreateReferendumControllerForUserFee(defaultParliamentController.OwnerAddress);
            CreateAssociationControllerForUserFee(defaultParliamentController.OwnerAddress,
                defaultUserFeeController.ReferendumController.OwnerAddress);
            State.UserFeeController.Value = defaultUserFeeController;
        }

        if (State.DeveloperFeeController.Value == null)
        {
            var developerController = GetDefaultDeveloperFeeController(defaultParliamentController);
            CreateDeveloperController(defaultParliamentController.OwnerAddress);
            CreateAssociationControllerForDeveloperFee(defaultParliamentController.OwnerAddress,
                developerController.DeveloperController.OwnerAddress);
            State.DeveloperFeeController.Value = developerController;
        }

        if (State.SideChainCreator.Value == null || State.SideChainRentalController.Value != null) return new Empty();
        var sideChainRentalController = GetDefaultSideChainRentalController(defaultParliamentController);
        CreateAssociationControllerForSideChainRental(State.SideChainCreator.Value,
            defaultParliamentController.OwnerAddress);
        State.SideChainRentalController.Value = sideChainRentalController;
        return new Empty();
    }
```

**File:** test/AElf.Contracts.TestBase/ContractTester.cs (L742-745)
```csharp
            list.AddGenesisSmartContract(TokenContractCode, TokenSmartContractAddressNameProvider.Name,
                tokenContractCallList);
            list.AddGenesisSmartContract(ParliamentContractCode, ParliamentSmartContractAddressNameProvider.Name,
                parliamentContractCallList);
```

**File:** src/AElf.OS.Core/Node/Application/OsBlockchainNodeContextService.cs (L40-78)
```csharp
    public async Task<OsBlockchainNodeContext> StartAsync(OsBlockchainNodeContextStartDto dto)
    {
        var transactions = new List<Transaction>();

        transactions.Add(GetTransactionForDeployment(dto.ZeroSmartContract,
            ZeroSmartContractAddressNameProvider.Name,
            dto.SmartContractRunnerCategory));

        transactions.AddRange(dto.InitializationSmartContracts
            .Select(p => GetTransactionForDeployment(p.Code, p.SystemSmartContractName,
                dto.SmartContractRunnerCategory,
                p.ContractInitializationMethodCallList)));

        if (dto.InitializationTransactions != null)
            transactions.AddRange(dto.InitializationTransactions);

        // Add transaction for initialization
        transactions.Add(GetTransactionForGenesisOwnerInitialization(dto));

        var blockchainNodeContextStartDto = new BlockchainNodeContextStartDto
        {
            ChainId = dto.ChainId,
            ZeroSmartContractType = dto.ZeroSmartContract,
            Transactions = transactions.ToArray()
        };

        var context = new OsBlockchainNodeContext
        {
            BlockchainNodeContext =
                await _blockchainNodeContextService.StartAsync(blockchainNodeContextStartDto),
            AElfNetworkServer = _networkServer
        };

        await _networkServer.StartAsync();

        foreach (var nodePlugin in _nodePlugins) await nodePlugin.StartAsync(dto.ChainId);

        return context;
    }
```
