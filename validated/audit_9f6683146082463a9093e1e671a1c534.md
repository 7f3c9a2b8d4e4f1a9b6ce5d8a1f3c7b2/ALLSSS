# Audit Report

## Title
Case-Insensitive Token Uniqueness Check Bypassed in Cross-Chain Token Creation

## Summary
The `CrossChainCreateToken` function performs only a case-sensitive token existence check, while the normal `Create` flow enforces case-insensitive uniqueness. This inconsistency allows tokens with symbols differing only in case (e.g., "ABC" and "abc") to coexist on the same chain, causing balance fragmentation, operational confusion, and SymbolSeedMap conflicts.

## Finding Description

**Root Cause - Case-Sensitive vs Case-Insensitive Checks:**

The normal token creation flow calls `CheckTokenExists`, which enforces case-insensitive uniqueness through `State.InsensitiveTokenExisting[symbol.ToUpper()]`. [1](#0-0) 

The normal `CreateToken` method calls `CheckTokenExists` before registering the token. [2](#0-1) 

When a token is registered via `RegisterTokenInfo`, both the case-sensitive `TokenInfos` map and the case-insensitive `InsensitiveTokenExisting` tracking state are updated. [3](#0-2) 

However, `CrossChainCreateToken` only checks `State.TokenInfos[tokenInfo.Symbol] == null`, which is case-sensitive, completely bypassing the case-insensitive validation performed by `CheckTokenExists`. [4](#0-3) 

**Storage Implementation:**

All token-related state maps use the exact symbol string as the key without normalization. The state definitions show `MappedState<string, TokenInfo> TokenInfos` and `MappedState<Address, string, long> Balances`, meaning "ABC" and "abc" are stored as completely separate keys, maintaining distinct balances and token information. [5](#0-4) 

**SymbolSeedMap Conflict:**

The SymbolSeedMap consistently uses `.ToUpper()` for both writes and reads. When creating SEED NFTs, the owned symbol is normalized to uppercase before storage. [6](#0-5) 

When checking existing seeds, the lookup also uses uppercase normalization. [7](#0-6) 

Similarly, when consuming a seed during token creation, the uppercase key is used. [8](#0-7) 

If both "ABC" and "abc" tokens exist, they conflict when used in SEED NFT operations since both normalize to the same uppercase key "ABC".

## Impact Explanation

**Critical Protocol Invariant Violated:**
The protocol's fundamental assumption that token symbols are case-insensitively unique is broken. This creates multiple concrete harms:

1. **Balance Fragmentation**: User balances are split across case variants (e.g., `State.Balances[user]["ABC"]` vs `State.Balances[user]["abc"]`), making total holdings opaque and potentially causing funds to appear "lost" to users and contracts expecting consolidated balances.

2. **SymbolSeedMap Corruption**: When both "ABC" and "abc" are used in NFT creation flows, they share `SymbolSeedMap["ABC"]`, causing one to overwrite the other's SEED mapping. This breaks the one-time-use SEED NFT enforcement and could allow unauthorized token creation or prevent legitimate token creation.

3. **Cross-Chain State Divergence**: Parent and child chains can have different token uniqueness states - parent chain with "ABC" only, child chain with both "ABC" and "abc" - violating cross-chain consistency guarantees.

4. **Contract Integration Failures**: Smart contracts and dApps assuming case-insensitive symbol resolution will interact with incorrect token variants, causing failed transactions, misrouted funds, and broken allowances.

**Severity: Medium** - No direct fund theft, but significant operational disruption, state integrity violation, and potential for user fund confusion. The vulnerability requires cross-chain conditions but has measurable impact on token accounting and NFT creation mechanisms.

## Likelihood Explanation

**Feasibility: Medium**

**Preconditions:**
1. Token with specific casing exists on child chain (e.g., "abc" created via normal `Create`)
2. Token with different casing exists on parent chain (e.g., "ABC")
3. Cross-chain registration initiated from parent to child

**Execution Path:**
1. Parent chain has token "ABC" (created normally)
2. Attacker creates token "abc" on child chain via normal `Create` flow
3. User initiates legitimate cross-chain registration from parent to child
4. `CrossChainCreateToken` checks `State.TokenInfos["ABC"] == null` - passes (only "abc" exists)
5. `RegisterTokenInfo` called for "ABC"
6. Both "ABC" and "abc" now coexist on child chain

**Accessibility:**
`CrossChainCreateToken` is a public RPC method callable by anyone with valid cross-chain merkle proof. [9](#0-8) 

**Complexity:** Medium - requires cross-chain operation setup but no privileged access. Attacker only needs to time token creation on child chain before cross-chain sync occurs, which is a race condition in normal protocol operations.

**Detection:** Low - duplicate tokens are visible in contract state but require explicit case-sensitive queries to detect. Most UIs and explorers would normalize symbols, masking the issue.

## Recommendation

Modify `CrossChainCreateToken` to use the same case-insensitive validation as the normal token creation flow. Add a call to `CheckTokenExists` before `RegisterTokenInfo`:

```csharp
public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
{
    // ... existing validation code ...
    
    var tokenInfo = new TokenInfo
    {
        Symbol = validateTokenInfoExistsInput.Symbol,
        // ... other fields ...
    };

    var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
    if (State.TokenInfos[tokenInfo.Symbol] == null)
    {
        // ADD THIS LINE: Enforce case-insensitive uniqueness check
        CheckTokenExists(tokenInfo.Symbol);
        
        RegisterTokenInfo(tokenInfo);
        // ... rest of the method ...
    }
    // ... rest of the method ...
}
```

This ensures that cross-chain token creation respects the same case-insensitive uniqueness constraint as local token creation.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreateToken_CaseInsensitiveDuplicate_ShouldFail()
{
    // Setup: Create side chain and register token contract addresses
    var sideChainId = await GenerateSideChainAsync();
    await RegisterMainChainTokenContractAddressOnSideChainAsync(sideChainId);

    // Step 1: Create token "abc" on main chain (normal creation)
    var createLowerCase = await CreateTransactionForTokenCreation(
        TokenContractStub, 
        DefaultAccount.Address, 
        "abc",  // lowercase symbol
        TokenContractAddress
    );
    await MineAsync(new List<Transaction> { createLowerCase });

    // Step 2: Create token "ABC" on side chain (normal creation)
    var createUpperCase = await CreateTransactionForTokenCreation(
        SideChainTokenContractStub,
        SideChainTestKit.DefaultAccount.Address,
        "ABC",  // uppercase symbol - different case
        SideTokenContractAddress
    );
    var sideChainExecuted = await SideChainTestKit.MineAsync(new List<Transaction> { createUpperCase });

    // Step 3: Get token info and create validation transaction
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = "abc" }
    );
    var validationTx = CreateTokenInfoValidationTransaction(tokenInfo, TokenContractStub);
    var mainChainExecuted = await MineAsync(new List<Transaction> { validationTx });
    
    // Step 4: Setup cross-chain merkle proof
    var merklePath = GetTransactionMerklePathAndRoot(validationTx, out var blockRoot);
    await BootMinerChangeRoundAsync(AEDPoSContractStub, true);
    await MainAndSideIndexAsync(ChainHelper.ConvertBase58ToChainId("AELF"), mainChainExecuted.Height, blockRoot);
    var boundParentChainHeightAndMerklePath = 
        await GetBoundParentChainHeightAndMerklePathByHeight(mainChainExecuted.Height);

    // Step 5: Attempt CrossChainCreateToken with "abc" (should fail but currently succeeds)
    var crossChainInput = new CrossChainCreateTokenInput
    {
        FromChainId = ChainHelper.ConvertBase58ToChainId("AELF"),
        ParentChainHeight = boundParentChainHeightAndMerklePath.BoundParentChainHeight,
        TransactionBytes = validationTx.ToByteString(),
        MerklePath = merklePath
    };
    crossChainInput.MerklePath.MerklePathNodes.AddRange(
        boundParentChainHeightAndMerklePath.MerklePathFromParentChain.MerklePathNodes
    );
    
    // VULNERABILITY: This should fail with "Token already exists" but currently succeeds
    // because CrossChainCreateToken only does case-sensitive check
    var result = await SideChainTokenContractStub.CrossChainCreateToken.SendAsync(crossChainInput);
    
    // Verify vulnerability: Both "ABC" and "abc" now exist on side chain
    var upperCaseInfo = await SideChainTokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = "ABC" }
    );
    var lowerCaseInfo = await SideChainTokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = "abc" }
    );
    
    Assert.NotNull(upperCaseInfo.Symbol); // Both exist
    Assert.NotNull(lowerCaseInfo.Symbol);
    Assert.NotEqual(upperCaseInfo.Symbol, lowerCaseInfo.Symbol); // Different symbols coexist
}
```

This test demonstrates that tokens differing only in case can coexist on the same chain after cross-chain creation, violating the case-insensitive uniqueness invariant.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L59-59)
```csharp
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L87-88)
```csharp
        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-508)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L16-19)
```csharp
    public MappedState<string, TokenInfo> TokenInfos { get; set; }
    public MappedState<string, bool> InsensitiveTokenExisting { get; set; }
    public MappedState<string, string> SymbolSeedMap { get; set; }
    public MappedState<Address, string, long> Balances { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L51-51)
```csharp
            State.SymbolSeedMap[ownedSymbol.ToUpper()] = input.Symbol;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L59-59)
```csharp
        var oldSymbolSeed = State.SymbolSeedMap[ownedSymbol.ToUpper()];
```

**File:** protobuf/token_contract.proto (L76-76)
```text
    rpc CrossChainCreateToken(CrossChainCreateTokenInput) returns (google.protobuf.Empty) {
```
