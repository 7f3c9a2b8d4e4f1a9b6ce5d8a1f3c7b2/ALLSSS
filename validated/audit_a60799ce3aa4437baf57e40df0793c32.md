# Audit Report

## Title
NextRound Validation Bypass via RoundId Collision Allows Invalid Time Slot Distribution

## Summary
A malicious block producer can bypass critical time slot validation (`CheckRoundTimeSlots`) when transitioning to a new consensus round by crafting a `ProvidedRound` with the same `RoundId` as `BaseRound`. This allows introduction of a round with invalid time slot distribution (unequal intervals, zero/negative spacing) into consensus state, compromising temporal fairness guarantees of the AEDPoS consensus mechanism.

## Finding Description

The vulnerability exists in the interaction between `TimeSlotValidationProvider` and the `RoundId` calculation mechanism during NextRound transitions.

**Root Cause:**

The `RoundId` property is calculated as the sum of all miners' `ExpectedMiningTime.Seconds` values: [1](#0-0) 

When validating NextRound behavior, `TimeSlotValidationProvider` uses `RoundId` equality to determine the validation path: [2](#0-1) 

If `ProvidedRound.RoundId == BaseRound.RoundId`, the critical `CheckRoundTimeSlots()` validation is skipped (line 14 condition fails, control jumps to line 20-31 which only validates the sender's individual time slot against BaseRound).

**Why Existing Validators Fail:**

For NextRound behavior, these validation providers are registered: [3](#0-2) 

None explicitly enforce that `ProvidedRound.RoundId` must differ from `BaseRound.RoundId`:

1. `RoundTerminateValidationProvider` only validates `RoundNumber` increment and InValues nullity: [4](#0-3) 

2. `NextRoundMiningOrderValidationProvider` only checks `FinalOrderOfNextRound` consistency: [5](#0-4) 

The bypassed `CheckRoundTimeSlots()` method enforces critical temporal invariants: [6](#0-5) 

**Execution Path:**

1. Malicious miner crafts `ProvidedRound` with `RoundNumber = BaseRound.RoundNumber + 1` but `RoundId = BaseRound.RoundId`
2. Achieves RoundId collision by selecting `ExpectedMiningTime` values that sum to target (e.g., for 5 miners with BaseRound.RoundId=15000: [100, 200, 300, 14200, 200] seconds instead of legitimate sequential [3000, 6000, 9000, 12000, 15000] seconds)
3. Submits transaction calling the public `NextRound` method: [7](#0-6) 

4. `TimeSlotValidationProvider` sees matching RoundId, executes only `CheckMinerTimeSlot()` against BaseRound (lines 20-31), skipping `CheckRoundTimeSlots()` on ProvidedRound
5. Other validators pass (RoundNumber increments correctly, sender is valid miner, FinalOrderOfNextRound can be set properly)
6. Malicious round accepted and stored in state: [8](#0-7) 

## Impact Explanation

**Consensus Integrity Compromise:**

Once the malicious round is accepted into `State.Rounds`, it becomes the authoritative `BaseRound` for subsequent block validation and mining schedule determination. The invalid time slot distribution enables:

1. **Unfair Mining Windows**: Attacker can allocate disproportionate time slots (e.g., give themselves 90% of round time, compress others into remaining 10%), violating the equal opportunity principle of AEDPoS
2. **Temporal Ordering Violation**: Setting intervals to zero or near-zero breaks the temporal spacing guarantee that prevents block production conflicts and ensures deterministic ordering
3. **Persistent State Corruption**: The malicious round remains in state affecting all consensus operations (GetMiningInterval, IsTimeSlotPassed, etc.) until the next legitimate NextRound overwrites it

**Affected Parties:**
- All miners in the compromised round face distorted time slot allocations
- Network consensus fairness is undermined as block production schedule becomes manipulable
- Subsequent blocks may be incorrectly validated due to corrupted BaseRound reference

**Severity: Medium** - Requires privileged BP position but straightforward exploitation. Impact is limited to one round's duration (temporary), does not directly enable fund theft, but compromises consensus fairness which is a core protocol invariant.

## Likelihood Explanation

**Attacker Requirements:**
- Active block producer with mining permission (achievable in DPoS via stake or election)
- Ability to produce a NextRound block (any miner can when appropriate timing conditions met)
- Custom consensus client to craft malicious round data instead of using legitimate `GenerateNextRoundInformation`: [9](#0-8) 

**Attack Complexity:**
- **Moderate** - Requires understanding RoundId calculation and validation flow
- Mathematical constraint satisfaction is straightforward: attacker solves for ExpectedMiningTime values summing to target RoundId (infinite solutions exist for N miners with sum S)
- Example: BaseRound.RoundId=5040 (5 miners) â†’ Malicious times [800, 1060, 1060, 1060, 1060] have wildly unequal spacing but sum to 5040

**Feasibility:**
- No cryptographic or economic barriers beyond being an elected/staked BP
- Validation logic is deterministic and bypassable as demonstrated
- Periodic opportunity at every round transition when miner's turn arrives

**Detection Difficulty:**
- Malicious round appears structurally valid (correct RoundNumber, proper fields populated)
- Other validators pass all checks, masking the manipulation
- Time slot inequality only becomes apparent in subsequent mining operations

**Probability: Medium-High** - Straightforward exploitation for any active BP with custom client, periodic opportunity window, no runtime detection mechanisms exist for this specific bypass.

## Recommendation

Add explicit validation that `ProvidedRound.RoundId` must differ from `BaseRound.RoundId` for NextRound behavior. Modify the validation logic to enforce this constraint:

In `TimeSlotValidationProvider.ValidateHeaderInformation()`:
```csharp
// For NextRound behavior, explicitly check RoundId must differ
if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.NextRound)
{
    if (validationContext.ProvidedRound.RoundId == validationContext.BaseRound.RoundId)
    {
        return new ValidationResult 
        { 
            Message = "NextRound must have different RoundId from current round." 
        };
    }
}

// Then continue with existing logic
if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
{
    validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
    // ...
}
```

Alternatively, add this check in `RoundTerminateValidationProvider.ValidationForNextRound()` to enforce the invariant at the appropriate validation layer.

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_RoundIdCollision_BypassesTimeSlotValidation()
{
    // Setup: Initialize consensus with 5 miners
    var initialMiners = GenerateInitialMiners(5);
    await InitializeConsensus(initialMiners);
    
    // Mine first round normally
    await ProduceNormalBlocks(initialMiners, roundCount: 1);
    
    // Get current round to calculate RoundId
    var currentRound = await GetCurrentRound();
    var targetRoundId = currentRound.RoundId; // e.g., 15000
    
    // Craft malicious NextRound with same RoundId but invalid spacing
    var maliciousRound = new Round
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RealTimeMinersInformation = 
        {
            // Invalid spacing: [100, 200, 300, 14200, 200] seconds
            // Sum = 15000 (matches targetRoundId) but wildly unequal
            {initialMiners[0], new MinerInRound 
            { 
                Pubkey = initialMiners[0], 
                Order = 1,
                ExpectedMiningTime = Timestamp.FromSeconds(100),
                FinalOrderOfNextRound = 1
            }},
            {initialMiners[1], new MinerInRound 
            { 
                Pubkey = initialMiners[1], 
                Order = 2,
                ExpectedMiningTime = Timestamp.FromSeconds(200),
                FinalOrderOfNextRound = 2
            }},
            {initialMiners[2], new MinerInRound 
            { 
                Pubkey = initialMiners[2], 
                Order = 3,
                ExpectedMiningTime = Timestamp.FromSeconds(300),
                FinalOrderOfNextRound = 3
            }},
            {initialMiners[3], new MinerInRound 
            { 
                Pubkey = initialMiners[3], 
                Order = 4,
                ExpectedMiningTime = Timestamp.FromSeconds(14200), // Unfair advantage
                FinalOrderOfNextRound = 4
            }},
            {initialMiners[4], new MinerInRound 
            { 
                Pubkey = initialMiners[4], 
                Order = 5,
                ExpectedMiningTime = Timestamp.FromSeconds(200),
                FinalOrderOfNextRound = 5
            }}
        }
    };
    
    // Verify RoundId collision
    maliciousRound.RoundId.ShouldBe(targetRoundId);
    
    // Verify invalid spacing (should fail CheckRoundTimeSlots)
    var validationResult = maliciousRound.CheckRoundTimeSlots();
    validationResult.Success.ShouldBeFalse(); // Confirms spacing is invalid
    
    // Submit malicious NextRound transaction
    var nextRoundInput = NextRoundInput.Create(maliciousRound, GenerateRandomNumber());
    var result = await ConsensusStub.NextRound.SendAsync(nextRoundInput);
    
    // VULNERABILITY: Transaction succeeds despite invalid time slots
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify malicious round was stored
    var storedRound = await GetCurrentRound();
    storedRound.RoundNumber.ShouldBe(maliciousRound.RoundNumber);
    storedRound.RoundId.ShouldBe(targetRoundId);
    
    // Demonstrate impact: miner at order 4 has unfair time advantage
    var miner4Time = storedRound.RealTimeMinersInformation[initialMiners[3]].ExpectedMiningTime;
    var miner3Time = storedRound.RealTimeMinersInformation[initialMiners[2]].ExpectedMiningTime;
    var unfairInterval = (miner4Time - miner3Time).Seconds;
    unfairInterval.ShouldBe(13900); // 14200 - 300 = massively unfair
}
```

## Notes

The vulnerability exploits a design flaw where `RoundId` serves dual purposes: as a round identifier and as a validation discriminator. Since `RoundId` is derived from attacker-controllable `ExpectedMiningTime` values rather than being cryptographically committed or sequentially incremented, it can be manipulated to bypass validation logic that relies on RoundId equality checks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-36)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
