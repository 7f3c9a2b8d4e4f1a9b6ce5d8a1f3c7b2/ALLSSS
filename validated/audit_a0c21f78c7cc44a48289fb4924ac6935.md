# Audit Report

## Title
Banned Candidates Persist in Election Snapshots Due to Incomplete Removal Logic

## Summary
The `GetPreviousTermSnapshotWithNewestPubkey()` function contains a critical logic flaw where banned candidates are not removed from election snapshots when their replacement pubkey already exists in the snapshot. This allows banned validators to be re-selected as consensus miners, bypassing the network's security ban mechanism.

## Finding Description

The vulnerability exists in the snapshot processing logic that handles banned candidates. When a candidate's pubkey is banned and replaced, the system should remove the banned pubkey from historical election snapshots. However, a flawed conditional check causes banned candidates to persist in snapshots under specific circumstances. [1](#0-0) 

The problematic code checks if the newest replacement pubkey already exists in the snapshot. When it does, the code executes `continue`, which skips both the addition of the new pubkey (already present) AND the removal of the banned candidate. This leaves the banned candidate in the snapshot with full vote weight.

The exploitation path leverages legitimate contract operations:

1. A candidate (B) quits election via `QuitElection()`, which removes them from the active candidates list and sets `IsCurrentCandidate = false`: [2](#0-1) 

2. Another candidate (A) is marked as evil/banned via `UpdateCandidateInformation()` with `IsEvilNode = true`, which sets the banned flag: [3](#0-2) 

3. A's admin replaces A's pubkey with B's pubkey via `ReplaceCandidatePubkey()`. This succeeds because B is no longer in the candidates list after quitting: [4](#0-3) 

4. The replacement updates the pubkey mapping chain: [5](#0-4) 

5. When `GetNewestPubkey(A)` is called, it returns B by following the replacement chain: [6](#0-5) 

6. Historical snapshots containing both A and B result in A remaining in the processed snapshot because the condition `snapshot.ElectionResult.ContainsKey(newestPubkey)` evaluates to true (B already exists), causing the removal of A to be skipped.

7. The consensus contract calls `GetMinerReplacementInformation()`, which selects alternative candidates from this flawed snapshot without filtering for banned pubkeys: [7](#0-6) 

8. The consensus contract directly uses these alternatives without additional validation, transferring the evil miner's time slot and consensus information to the "alternative" (which could be the banned candidate A): [8](#0-7) 

This breaks the security invariant that banned validators cannot participate in consensus.

## Impact Explanation

**Critical Consensus Security Violation:**

The vulnerability directly undermines the network's ability to permanently exclude malicious or compromised validators. When a node is marked as evil, the intention is permanent exclusion from consensus participation. However, this bug allows banned candidates to:

- Retain their historical vote weight in election snapshots
- Be selected as replacement miners by the consensus contract's `GenerateNextRoundInformation()` method
- Resume block production and consensus participation  
- Potentially collect mining rewards

**Quantified Impact:**

- A banned candidate with high vote count from previous terms has priority in selection due to vote-based ordering
- The consensus contract transfers the evil miner's time slot and order directly to the "alternative" candidate without validation
- No additional checks occur once the alternative is selected and added to `currentRound.RealTimeMinersInformation`

**Affected Parties:**

- **Network integrity**: Compromised nodes regain validator privileges
- **Honest validators**: Must operate alongside previously-banned malicious nodes
- **Token holders**: Network security degraded, staked value at risk

The severity is **High** because it directly compromises the consensus security model, allowing banned validators to bypass security measures and regain consensus participation rights.

## Likelihood Explanation

**Realistic Attack Scenario:**

The vulnerability is exploitable through a sequence of legitimate contract operations:

1. **Setup (Historical)**: Multiple candidates participate in elections across several terms, building vote history in snapshots
2. **Trigger Event**: One candidate quits election (normal operation available to any candidate admin)
3. **Ban Event**: Another candidate is detected as malicious and banned by the consensus contract
4. **Exploitation**: The banned candidate's admin replaces the banned pubkey with the quit candidate's pubkey
5. **Execution**: During next term transitions, the consensus contract automatically queries historical snapshots for miner replacements and selects the banned candidate

**Feasibility Analysis:**

- All operations are accessible to candidate admins (unprivileged actors with no special permissions)
- No special timing windows required beyond normal admin control
- The bug triggers automatically during the consensus contract's routine snapshot processing
- Detection is difficult because pubkey replacement appears as a legitimate administrative operation

**Probability Assessment:**

Medium-to-High likelihood because:
- Requires coordination of specific events (quit + ban + replacement), but all are normal operations
- A sophisticated attacker controlling multiple candidate identities could orchestrate this deliberately
- The scenario could also occur naturally without malicious intent
- Once conditions are met, the vulnerability triggers automatically without additional action
- The consensus contract queries historical snapshots regularly during term transitions

The combination of High impact and Medium-to-High likelihood makes this a critical security concern requiring immediate remediation.

## Recommendation

Fix the logic in `GetPreviousTermSnapshotWithNewestPubkey()` to ensure banned candidates are always removed from snapshots, even when their replacement already exists:

```csharp
foreach (var bannedCandidate in bannedCandidates)
{
    var newestPubkey = GetNewestPubkey(bannedCandidate);
    
    // Always remove the banned candidate first
    if (snapshot.ElectionResult.ContainsKey(bannedCandidate))
    {
        snapshot.ElectionResult.Remove(bannedCandidate);
    }
    
    // If newest pubkey not exists or same as old pubkey (which is banned), skip addition
    if (newestPubkey == null || newestPubkey == bannedCandidate)
    {
        continue;
    }
    
    // Only add replacement if it doesn't already exist
    if (!snapshot.ElectionResult.ContainsKey(newestPubkey))
    {
        var electionResult = snapshot.ElectionResult[bannedCandidate];
        snapshot.ElectionResult.Add(newestPubkey, electionResult);
    }
}
```

Additionally, add defensive validation in `GetMinerReplacementInformation()` to filter banned pubkeys from alternative candidates:

```csharp
var maybeNextCandidates = latestSnapshot.ElectionResult
    // Except initial miners
    .Where(cs => !State.InitialMiners.Value.Value.Contains(
        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
    // Except current miners
    .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
    // Except banned pubkeys
    .Where(cs => !State.BannedPubkeyMap[cs.Key])
    .OrderByDescending(s => s.Value).ToList();
```

## Proof of Concept

The vulnerability can be demonstrated through the following scenario:

1. **Initial state**: Term 5 snapshot contains candidates A and B with vote weights
2. **Execute**: `QuitElection()` for candidate B (removes from active candidates)
3. **Execute**: `UpdateCandidateInformation()` with `IsEvilNode=true` for candidate A (bans A)
4. **Execute**: `ReplaceCandidatePubkey(oldPubkey=A, newPubkey=B)` (succeeds because B is not an active candidate)
5. **Trigger**: During next term transition, consensus contract calls `GetMinerReplacementInformation()`
6. **Observe**: `GetPreviousTermSnapshotWithNewestPubkey()` processes Term 5 snapshot
7. **Bug triggers**: When processing banned candidate A, `GetNewestPubkey(A)` returns B, but B already exists in snapshot, so `continue` executes
8. **Result**: A remains in snapshot, can be selected as alternative miner

The test would verify that after step 8, candidate A's pubkey remains in the processed snapshot returned by `GetPreviousTermSnapshotWithNewestPubkey()` and can be selected by `GetMinerReplacementInformation()` as an alternative candidate, despite being banned.

## Notes

This vulnerability represents a critical gap in the election contract's snapshot processing logic. The fix must ensure that banned candidates are always removed from snapshots regardless of whether their replacement pubkey is already present. The issue is particularly severe because it occurs during automated consensus contract operations, making it difficult to detect and prevent once the preconditions are established.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L149-158)
```csharp
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-377)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-279)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });

        // Update candidate information.
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;

        // Remove candidate public key from the Voting Item options.
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(pubkey))
        {
            dataCenterList.DataCenters[pubkey] = 0;
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
            State.DataCentersRankingList.Value = dataCenterList;
        }

        var managedCandidatePubkey = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedCandidatePubkey.Value.Remove(ByteString.CopyFrom(pubkeyBytes));
        if (managedCandidatePubkey.Value.Any())
            State.ManagedCandidatePubkeysMap[Context.Sender] = managedCandidatePubkey;
        else
            State.ManagedCandidatePubkeysMap.Remove(Context.Sender);

        State.CandidateSponsorMap.Remove(pubkey);

        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-246)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }

        var rankingList = State.DataCentersRankingList.Value;
        //the profit receiver is not exist but candidate in the data center ranking list
        if (rankingList.DataCenters.ContainsKey(input.OldPubkey))
        {
            rankingList.DataCenters.Add(input.NewPubkey, rankingList.DataCenters[input.OldPubkey]);
            rankingList.DataCenters.Remove(input.OldPubkey);
            State.DataCentersRankingList.Value = rankingList;

            // Notify Profit Contract to update backup subsidy profiting item.
            if (State.ProfitContract.Value == null)
                State.ProfitContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            
            var oldProfitReceiver = GetProfitsReceiverOrDefault(input.OldPubkey);
            var profitReceiver = oldProfitReceiver.Value.Any()
                ? oldProfitReceiver
                : null;
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
        }

        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }

        //     For CandidateVotes and CandidateInformation, just replace value of origin pubkey.
        var candidateVotes = State.CandidateVotes[input.OldPubkey];
        if (candidateVotes != null)
        {
            candidateVotes.Pubkey = newPubkeyBytes;
            State.CandidateVotes[input.NewPubkey] = candidateVotes;
            State.CandidateVotes.Remove(input.OldPubkey);
        }

        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }

        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-291)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-343)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }
```
