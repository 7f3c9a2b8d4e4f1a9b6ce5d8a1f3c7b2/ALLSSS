# Audit Report

## Title
Secret Sharing Manipulation Through Selective Decrypted Piece Withholding

## Summary
The AEDPoS consensus contract contains a critical threshold mismatch in its secret sharing implementation. The `RevealSharedInValues()` function requires 100% miner participation to reveal InValues, despite Shamir's Secret Sharing only needing a 2/3 threshold. A malicious miner can exploit this by selectively withholding decrypted pieces to force targeted miners into using predictable fake values, thereby manipulating consensus randomness and mining order.

## Finding Description

The vulnerability exists in the secret sharing revelation logic where a threshold mismatch allows consensus manipulation.

The `RevealSharedInValues()` function enforces a 100% participation requirement before attempting InValue reconstruction: [1](#0-0) 

However, the cryptographic scheme only requires a 2/3 threshold (`minimumCount`) for successful secret reconstruction: [2](#0-1) [3](#0-2) 

During the `UpdateValue` consensus behavior, miners provide their decrypted pieces through `UpdateValueInput`. The `PerformSecretSharing` function processes these pieces without any validation: [4](#0-3) 

No validation mechanism exists to ensure miners provide all decrypted pieces they possess. A malicious miner can simply omit certain pubkeys from their `DecryptedPieces` map.

When InValue revelation fails due to insufficient decrypted pieces, miners without a valid `PreviousInValue` must use a deterministic fake value: [5](#0-4) 

This fake value is then used in signature calculation: [6](#0-5) [7](#0-6) 

The signature determines the next round's mining order: [8](#0-7) 

## Impact Explanation

**Consensus Randomness Manipulation**: An attacker can selectively prevent specific miners' InValue revelation, forcing them to use predictable fake values instead of their actual InValues. Since the signature is computed by XORing the InValue with all previous round signatures, and mining order is calculated from this signature, the attacker can influence which miners receive favorable or unfavorable mining positions.

**Concrete Attack Scenario**:
1. Attacker decrypts all other miners' encrypted pieces off-chain (possible since pieces are public on-chain)
2. For each target miner, attacker calculates resulting mining orders under two scenarios:
   - Scenario A: Provide the decrypted piece (allowing InValue revelation)
   - Scenario B: Withhold the decrypted piece (forcing fake value usage)
3. Attacker selectively withholds pieces where scenario B produces more favorable mining order
4. This manipulation increases attacker's mining frequency, enables consecutive block production, or disadvantages competing miners

**Severity Justification**: The cryptographic protocol is designed for 2/3 Byzantine fault tolerance, but the implementation requires 100% honest participation. This allows any single malicious miner to manipulate consensus without detection or penalty. Mining order directly affects block rewards and transaction fee capture, creating economic incentives for exploitation.

## Likelihood Explanation

**Attacker Capabilities**: A single malicious miner in the active miner set can execute this attack. The attacker only needs to:
1. Run standard consensus node software
2. Selectively omit certain pubkeys from their `DecryptedPieces` map when calling `UpdateValue`

**Attack Complexity**: Trivial. The encrypted pieces are stored on-chain in the round information, allowing any miner to decrypt them. The attacker simply filters which decrypted pieces to include in their `UpdateValueInput` before submitting the transaction.

**Detection/Penalties**: None. The validation provider explicitly allows `Hash.Empty` as a valid `PreviousInValue`: [9](#0-8) 

The system cannot distinguish between an honest miner who failed to decrypt due to technical issues versus a malicious miner intentionally withholding decryptions.

**Economic Rationality**: Mining order determines when miners produce blocks within a round. Earlier positions typically capture more transactions and fees. The attack cost is zero (just omitting data), while the benefit is improved mining position and increased rewards.

## Recommendation

Change the on-chain `RevealSharedInValues()` function to match the cryptographic protocol's 2/3 threshold requirement:

```csharp
// In AEDPoSContract_SecretSharing.cs, line 36:
// Change from:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

// To:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

This ensures that secret reconstruction succeeds with the intended Byzantine fault tolerance threshold, preventing a single malicious miner from blocking InValue revelation. The same fix should be applied to the off-chain `SecretSharingService.RevealPreviousInValues()` function for consistency.

## Proof of Concept

A complete proof of concept would require:
1. Setting up a test consensus network with multiple miners
2. Having one miner selectively omit `DecryptedPieces` entries in their `UpdateValueInput`
3. Observing that target miners fail InValue revelation checks in `RevealSharedInValues()`
4. Verifying that target miners use deterministic fake values in subsequent rounds
5. Demonstrating that mining order changes based on which pieces are withheld

The vulnerability is validated through code analysis showing:
- No validation exists on the completeness of `DecryptedPieces` submissions
- The 100% requirement contradicts the 2/3 cryptographic threshold
- Fake values are deterministic and influence mining order through signature calculation

## Notes

This vulnerability represents a fundamental mismatch between the cryptographic protocol's design (2/3 threshold) and its implementation (100% requirement). The off-chain `SecretSharingService` contains the same issue at line 162, confirming this is a systematic implementation error rather than an isolated bug. The vulnerability is particularly severe because it allows manipulation of consensus randomness, which is the foundation of fair mining order distribution in AEDPoS.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L22-23)
```csharp
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L50-50)
```csharp
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L96-96)
```csharp
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L101-101)
```csharp
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```
