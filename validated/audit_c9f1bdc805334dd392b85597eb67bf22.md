# Audit Report

## Title
Unvalidated Miner Order Assignment Enables Consensus DoS via Invalid Orders

## Summary
The AEDPoS consensus contract's `ProcessUpdateValue` function accepts user-provided order values through `TuneOrderInformation` without validation, allowing malicious miners to assign invalid orders (outside the valid range [1, minersCount]) to any miner. This causes `BreakContinuousMining()` to throw an `InvalidOperationException` during next round generation, permanently halting consensus.

## Finding Description

The vulnerability exists in the consensus order assignment flow where user-controlled order values bypass all validation checks.

**Entry Point:** The `UpdateValue` method is publicly accessible to any miner. [1](#0-0) 

**Insufficient Authorization:** The `PreCheck()` function only verifies the caller is in the current or previous miner list, without validating order values. [2](#0-1) 

**Missing Validation - Direct Assignment:** In `ProcessUpdateValue`, user-provided `TuneOrderInformation` values are directly assigned to `FinalOrderOfNextRound` without bounds checking. [3](#0-2) 

**User-Controlled Input:** The protobuf definition shows `tune_order_information` is a user-controlled map with no constraints. [4](#0-3) 

**Validation Provider Insufficient:** The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue` - it does NOT validate order values. [5](#0-4) 

**Propagation to Next Round:** During next round generation, miners who successfully mined use their `FinalOrderOfNextRound` values directly as the `Order` in the next round. [6](#0-5) 

**Critical Failure Point:** The `BreakContinuousMining()` function uses `First(i => i.Order == 1)` which throws `InvalidOperationException` when no miner has Order == 1. [7](#0-6) 

Similarly for Order == 2: [8](#0-7) 

**Execution Path:** When NextRound behavior is triggered, `GetConsensusExtraDataForNextRound` calls `GenerateNextRoundInformation`. [9](#0-8) 

Which calls `BreakContinuousMining` where the exception occurs. [10](#0-9) 

**Attack Scenario:**
1. Five miners (A, B, C, D, E) all successfully mine in the current round
2. Malicious Miner B calls `UpdateValue` with `TuneOrderInformation = { "A": 10, "B": 11, "C": 12, "D": 13, "E": 14 }`
3. All miners' `FinalOrderOfNextRound` become invalid (outside [1, 5])
4. When NextRound generation occurs, all miners are assigned invalid Orders (10-14)
5. Since all miners mined, no valid orders [1-5] are assigned to anyone
6. `BreakContinuousMining()` attempts to find Order == 1, fails, and throws `InvalidOperationException`
7. Next round generation fails, consensus permanently halts

## Impact Explanation

**Consensus Halt (Critical Availability):**
When invalid orders are assigned via `TuneOrderInformation`, the next round cannot be generated because `BreakContinuousMining()` throws an unhandled exception. This blocks all consensus progression.

**Protocol-Wide Impact:**
- All nodes cannot progress past the corrupted round
- Mining rewards are not distributed
- Cross-chain operations depending on round progression are blocked
- The entire blockchain becomes non-responsive
- Requires emergency governance intervention (contract upgrade or manual state repair)

**Severity Justification:**
This is a critical availability vulnerability. Unlike temporary DoS attacks that may recover, this creates a permanent consensus halt. The entire blockchain infrastructure becomes non-functional until extraordinary governance measures are taken.

## Likelihood Explanation

**Attacker Capabilities:**
Any miner in the current miner list can exploit this vulnerability. Becoming a miner requires winning the election through normal staking mechanisms, which is the intended system design.

**Attack Complexity:**
The attack is trivial to execute:
- Call the public `UpdateValue` method with crafted `TuneOrderInformation`
- No race conditions or timing requirements needed
- Single transaction with immediate effect
- No economic cost beyond standard transaction fees

**Feasibility:**
The attack has minimal barriers:
- No special privileges required beyond being a miner
- No need to compromise other miners
- Attack succeeds deterministically
- Cannot be prevented by other miners or validators

**Detection/Prevention:**
Currently there is no validation preventing this attack. By the time invalid orders are observable on-chain, the next round generation has already failed and consensus is halted.

**Likelihood Assessment:**
HIGH - Any miner can execute this attack at any time with a single transaction. The attack is practical, requires minimal effort, and immediately achieves complete consensus DoS.

## Recommendation

Add validation in `ProcessUpdateValue` to ensure all order values in `TuneOrderInformation` are within the valid range [1, minersCount]:

```csharp
// In ProcessUpdateValue, before line 259:
var minersCount = currentRound.RealTimeMinersInformation.Count;
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount, 
        $"Invalid order value: {tuneOrder.Value}. Must be between 1 and {minersCount}.");
    Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key),
        "Cannot tune order for non-existent miner.");
}

// Then apply the tuning:
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

Additionally, add duplicate order detection to ensure no two miners are assigned the same order value in `FinalOrderOfNextRound`.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousOrderAssignment_CausesConsensusDos()
{
    // Setup: 5 miners all successfully mine in current round
    var miners = await BootMinerAsync();
    await ProduceBlocksAsync(miners, 1); // All miners produce blocks
    
    // Attack: Malicious miner assigns invalid orders
    var maliciousMiner = miners[1];
    var invalidTuneOrders = new Dictionary<string, int>
    {
        { miners[0].ToHex(), 10 },  // Invalid: outside [1,5]
        { miners[1].ToHex(), 11 },
        { miners[2].ToHex(), 12 },
        { miners[3].ToHex(), 13 },
        { miners[4].ToHex(), 14 }
    };
    
    // Call UpdateValue with malicious TuneOrderInformation
    await GenerateUpdateValueTransaction(maliciousMiner, invalidTuneOrders);
    
    // Verify: Next round generation fails with InvalidOperationException
    var exception = await Assert.ThrowsAsync<InvalidOperationException>(
        async () => await TriggerNextRoundAsync(miners[0])
    );
    
    Assert.Contains("Sequence contains no matching element", exception.Message);
    // Consensus is now permanently halted
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L67-67)
```csharp
        BreakContinuousMining(ref nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L83-84)
```csharp
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-176)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```
