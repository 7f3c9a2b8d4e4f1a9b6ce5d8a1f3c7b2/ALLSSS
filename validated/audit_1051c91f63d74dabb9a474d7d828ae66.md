# Audit Report

## Title
Missing Validation of Mining Order Values Allows Consensus State Corruption

## Summary
The AEDPoS consensus contract's `ProcessUpdateValue` method accepts user-provided `SupposedOrderOfNextRound` and `TuneOrderInformation` values without validating they are within the valid range [1, minersCount]. Any active miner can submit an UpdateValue transaction with out-of-range order values, corrupting consensus state and causing next round generation to fail with array index exceptions or produce invalid mining schedules with severely delayed block times.

## Finding Description

The vulnerability exists in the consensus contract's handling of mining order information for the next round.

**Root Cause - Unchecked State Writes:**

The `ProcessUpdateValue` method directly writes user-provided order values to state without validation: [1](#0-0) [2](#0-1) 

**Missing Validation:**

The `UpdateValueValidationProvider` only validates cryptographic fields (OutValue, Signature, PreviousInValue) but does NOT check order values: [3](#0-2) 

The validation chain for `UpdateValue` behavior explicitly excludes order validation: [4](#0-3) 

**Expected Calculation:**

The correct order calculation in `ApplyNormalConsensusData` ensures values are in range [1, minersCount]: [5](#0-4) [6](#0-5) 

However, a miner can bypass this by modifying their node software to provide arbitrary values in `UpdateValueInput` before signing and submitting the transaction.

**Attack Execution:**

1. Miner's node generates `UpdateValueInput` via `ExtractInformationToUpdateConsensus`
2. Miner modifies node code to change `SupposedOrderOfNextRound` to out-of-range value (e.g., 100) or injects malicious `TuneOrderInformation` entries
3. Signs and submits the modified transaction
4. Validation passes because order values are not checked
5. Corrupted values persist in state

**Impact on Next Round Generation:**

*Timing Corruption:* Mining times are calculated by multiplying order values with mining interval: [7](#0-6) 

With order=100 and miningInterval=4000ms, the expected mining time becomes 400 seconds in the future instead of 4-16 seconds.

*Array Index Exceptions:* The order assignment logic assumes all orders are within valid range: [8](#0-7) 

If all mined miners have out-of-range FinalOrderOfNextRound values (e.g., [100, 101, 102, 103] with minersCount=4), then `ableOrders` contains [1, 2, 3, 4], but if miners needing reassignment exceed available orders, `ableOrders[i]` throws `IndexOutOfRangeException`.

*BreakContinuousMining Failures:* The logic searches for specific order positions that may not exist with corrupted values: [9](#0-8) [10](#0-9) 

If no miner has Order==1 or Order==minersCount due to corruption, `First()` throws exception or `FirstOrDefault()` returns null, causing logic failures.

**Inadequate Post-Validation:**

The `ValidateConsensusAfterExecution` hash comparison is ineffective because `RecoverFromUpdateValue` copies the malicious order values to both the provided round and state round: [11](#0-10) [12](#0-11) 

Both sides of the hash comparison contain the same corrupted values, so validation passes.

## Impact Explanation

**High Severity - Consensus Protocol Integrity Breach:**

1. **Timing Integrity Loss:** Round schedules become invalid with miners scheduled hundreds of seconds late, breaking the fundamental block time assumption.

2. **Operational Failure:** Array index exceptions crash next round generation, preventing network progression. The `First()` method will throw "Sequence contains no matching element" exception when searching for expected order positions.

3. **Liveness Loss:** The network cannot produce blocks at expected intervals. Cross-chain mechanisms depending on timing assumptions fail. The blockchain halts if critical order positions cannot be located.

4. **Cascading Failures:** Subsequent rounds inherit corruption as these values persist in state, causing long-term consensus degradation until manual intervention.

All network participants suffer from consensus failure. While there is no direct fund loss, the protocol becomes unusable, equivalent to total system failure for a blockchain network.

## Likelihood Explanation

**High Likelihood - Low-Complexity Attack:**

**Attacker Profile:** Any active miner in the current round can exploit this. Miners control their node software and transaction generation process.

**Attack Complexity: LOW**
- Miner modifies node software to inject malicious order values into locally-generated `UpdateValueInput`
- No special timing, coordination, or external conditions required
- Standard transaction submission through existing infrastructure
- Validation does not prevent the attack

**Technical Feasibility:** The attack is straightforward because:
- `GenerateConsensusTransactions` constructs transactions locally in miner's node
- Miners can modify code to alter values before cryptographic signing
- No cryptographic commitment to order values exists before submission
- Permission check only verifies miner is in current miner list, not transaction content validity

**Economic Rationality:** A malicious or compromised miner could execute this to disrupt network operations with minimal cost (only standard transaction fees).

## Recommendation

Add validation to verify order values are within valid range [1, minersCount]:

```csharp
// In ProcessUpdateValue method, after line 240:
var minersCount = currentRound.RealTimeMinersInformation.Count;

// Validate SupposedOrderOfNextRound
Assert(
    updateValueInput.SupposedOrderOfNextRound >= 1 && 
    updateValueInput.SupposedOrderOfNextRound <= minersCount,
    $"Invalid SupposedOrderOfNextRound: must be between 1 and {minersCount}."
);

// Validate TuneOrderInformation entries
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    Assert(
        tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount,
        $"Invalid FinalOrderOfNextRound for {tuneOrder.Key}: must be between 1 and {minersCount}."
    );
    
    Assert(
        currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key),
        $"Invalid miner pubkey in TuneOrderInformation: {tuneOrder.Key}."
    );
}
```

Alternatively, add a dedicated validation provider for UpdateValue behavior that validates order values before state updates.

## Proof of Concept

```csharp
// Test demonstrating vulnerability
[Fact]
public async Task MaliciousOrderValues_CorruptConsensusState()
{
    // Setup: Initialize consensus with 4 miners
    var miners = GenerateMiners(4);
    await InitializeConsensus(miners);
    
    // Miner produces block and gets UpdateValueInput
    var miner = miners[0];
    var updateInput = await GetUpdateValueInput(miner);
    
    // ATTACK: Modify order to out-of-range value
    updateInput.SupposedOrderOfNextRound = 100; // Instead of 1-4
    
    // Submit malicious transaction - validation should fail but doesn't
    var result = await ConsensusContract.UpdateValue(updateInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // PASSES
    
    // Verify corrupted state persists
    var round = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    var corruptedMiner = round.RealTimeMinersInformation[miner.PublicKey.ToHex()];
    corruptedMiner.SupposedOrderOfNextRound.ShouldBe(100); // Corrupted value in state
    
    // Next round generation will fail
    var exception = await Should.ThrowAsync<Exception>(async () => 
    {
        await TriggerNextRound();
    });
    
    // Exception occurs during BreakContinuousMining when searching for Order==1
    exception.Message.ShouldContain("Sequence contains no matching element");
}
```

## Notes

This vulnerability represents a fundamental gap in Byzantine Fault Tolerance for the AEDPoS consensus protocol. While miners are expected to follow protocol rules, the contract should validate all inputs to protect against Byzantine behavior. The lack of bounds checking on order values allows a single malicious miner to corrupt consensus state, violating the security assumption that the system can tolerate Byzantine faults as long as less than 1/3 of miners are malicious.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L28-33)
```csharp
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-44)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L94-94)
```csharp
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L24-27)
```csharp
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-92)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```
