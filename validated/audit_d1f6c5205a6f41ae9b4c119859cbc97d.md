# Audit Report

## Title
NFT Token Hash Collision via Ambiguous String Concatenation Enables Cross-Protocol Denial of Service and State Corruption

## Summary
The NFT contract's `CalculateTokenHash` function concatenates symbol and tokenId without a delimiter, enabling hash collisions across different protocols. This vulnerability allows attackers to either permanently block legitimate NFT mints (DoS) or corrupt NFT state across protocols, depending on the `IsTokenIdReuse` configuration.

## Finding Description

The root cause lies in the `CalculateTokenHash` implementation which performs simple string concatenation: [1](#0-0) 

NFT protocol symbols are generated with a 2-letter prefix followed by a variable-length random number. The minimum length starts at 9 digits: [2](#0-1) 

The symbol generation concatenates the prefix with the random number: [3](#0-2) 

As more protocols are created, the random number length dynamically increases: [4](#0-3) 

Users can specify arbitrary tokenId values without validation: [5](#0-4) 

**Collision Example:**
- Protocol A with symbol "AR123456789" (9-digit number) minting tokenId 999 produces hash of "AR123456789999"
- Protocol B with symbol "AR1234567899" (10-digit number) minting tokenId 99 produces hash of "AR123456789999"
- Both produce identical hashes despite representing completely different NFTs from different protocols

The collision detection checks if the hash already exists but does not distinguish between protocols: [6](#0-5) 

When `IsTokenIdReuse` is false, this assertion fails causing DoS. When `IsTokenIdReuse` is true, the assertion is bypassed and both protocols modify the same state: [7](#0-6) 

All critical NFT state is keyed by the tokenHash: [8](#0-7) 

This affects all NFT operations including transfers, burns, approvals, and queries: [9](#0-8) [10](#0-9) [11](#0-10) [12](#0-11) [13](#0-12) 

## Impact Explanation

**Denial of Service Impact:**
When a protocol with a shorter symbol (e.g., "AR123456789") mints a specific tokenId first, any subsequent protocol whose symbol creates a collision (e.g., "AR1234567899") is permanently blocked from minting that tokenId. The assertion error message is misleading as it states the tokenId already exists when in reality only the hash collision exists. This blocks legitimate protocol operators from utilizing specific tokenId ranges.

**State Corruption Impact:**
When `IsTokenIdReuse=true`, the collision check is bypassed and both protocols write to the same storage locations:
- `State.NftInfoMap[tokenHash]` stores conflated metadata from both NFTs
- `State.BalanceMap[tokenHash]` mixes balances across different protocols
- `State.AllowanceMap[tokenHash]` conflates approval permissions between unrelated NFTs

This results in:
- Incorrect NFT metadata returned by `GetNFTInfo`
- Wrong balance queries via `GetBalance`
- Misrouted transfer operations affecting unintended NFTs
- Incorrect burn operations potentially destroying the wrong assets
- Mixed allowance permissions creating unauthorized transfer capabilities

**Severity Justification:**
This is HIGH/CRITICAL severity because:
1. Breaks the fundamental invariant that each (symbol, tokenId) pair must be globally unique
2. Enables systematic DoS against new protocols as the ecosystem scales
3. Corrupts core state storage affecting all NFT operations
4. Requires only mint permission (obtainable by creating a protocol or being added as a minter)
5. Impact increases as more protocols are created and symbol lengths grow

## Likelihood Explanation

**Attacker Requirements:**
- Mint permission on at least one NFT protocol (obtainable by creating their own protocol or being added as a minter to an existing one)
- Ability to calculate collision pairs (straightforward arithmetic)
- Ability to monitor on-chain protocol creation events
- No special privileges or governance control required

**Attack Feasibility:**
The attack is highly feasible:
1. Symbol generation is deterministic and observable on-chain through protocol creation events
2. Collision calculation is simple arithmetic - for any symbol S of length N, find symbol S' of length N+1 where S + tokenId1 == S' + tokenId2
3. Attacker can frontrun or strategically mint colliding tokenIds
4. No special timing windows required beyond standard transaction ordering
5. Probability increases as ecosystem scales with more 10+ digit symbols

**Detection Difficulty:**
- Collisions appear as legitimate mint transactions
- Error messages don't indicate cross-protocol collision
- No on-chain monitoring currently exists to detect this pattern
- Victims may not realize their DoS is due to collision from another protocol

The cost-benefit strongly favors the attacker as the attack cost is only gas fees while the potential gain includes blocking competitors' protocols or causing widespread state corruption.

## Recommendation

Add a delimiter or use a structured hashing approach that prevents ambiguous concatenation. The fix should ensure that different (symbol, tokenId) pairs always produce different hashes even when their string concatenations could be identical.

**Recommended Fix:**
```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    // Option 1: Add delimiter
    return HashHelper.ComputeFrom($"{symbol}-{tokenId}");
    
    // Option 2: Use structured hashing (preferred)
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol),
        HashHelper.ComputeFrom(tokenId)
    );
}
```

The structured hashing approach (Option 2) is preferred as it eliminates any possibility of collision while maintaining efficiency.

## Proof of Concept

```csharp
[Fact]
public async Task NFT_HashCollision_Test()
{
    // Setup: Create two protocols with specific symbols that will collide
    
    // Protocol A: Symbol with 9-digit number
    var symbolA = "AR123456789"; // 2-letter prefix + 9 digits
    var tokenIdA = 999L;
    var expectedHashA = CalculateTokenHash(symbolA, tokenIdA); // "AR123456789999"
    
    // Protocol B: Symbol with 10-digit number
    var symbolB = "AR1234567899"; // 2-letter prefix + 10 digits
    var tokenIdB = 99L;
    var expectedHashB = CalculateTokenHash(symbolB, tokenIdB); // "AR123456789999"
    
    // Verify collision exists
    Assert.Equal(expectedHashA, expectedHashB);
    
    // Test 1: DoS Scenario (IsTokenIdReuse = false)
    // Create Protocol A with IsTokenIdReuse = false
    await CreateProtocolA(symbolA, isTokenIdReuse: false);
    
    // Mint in Protocol A first
    await MintNFT(symbolA, tokenIdA);
    
    // Create Protocol B with IsTokenIdReuse = false
    await CreateProtocolB(symbolB, isTokenIdReuse: false);
    
    // Attempt to mint in Protocol B - should fail with DoS
    var result = await MintNFT(symbolB, tokenIdB);
    Assert.True(result.Status == TransactionResultStatus.Failed);
    Assert.Contains("already exists", result.Error);
    
    // Test 2: State Corruption Scenario (IsTokenIdReuse = true)
    // Create Protocol C with IsTokenIdReuse = true
    var symbolC = "AR1234567899";
    await CreateProtocolC(symbolC, isTokenIdReuse: true);
    
    // Mint in Protocol C - should succeed but corrupt state
    var mintResult = await MintNFT(symbolC, tokenIdB);
    Assert.True(mintResult.Status == TransactionResultStatus.Mined);
    
    // Verify state corruption: both protocols share same tokenHash
    var nftInfoA = await GetNFTInfo(symbolA, tokenIdA);
    var nftInfoC = await GetNFTInfo(symbolC, tokenIdB);
    
    // State is corrupted - both queries return the same conflated data
    Assert.Equal(nftInfoA.TokenHash, nftInfoC.TokenHash);
    Assert.True(nftInfoA.Symbol != nftInfoC.Symbol); // Different symbols
    Assert.True(nftInfoA.TokenId != nftInfoC.TokenId); // Different tokenIds
    // But they share the same state storage!
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L21-24)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-85)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L295-298)
```csharp
    public override Empty Approve(ApproveInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = input.Amount;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L392-392)
```csharp
        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-441)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }

        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-30)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L14-18)
```csharp
    public override NFTInfo GetNFTInfo(GetNFTInfoInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        return GetNFTInfoByTokenHash(tokenHash);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L32-42)
```csharp
    public override GetBalanceOutput GetBalance(GetBalanceInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var balance = State.BalanceMap[tokenHash][input.Owner];
        return new GetBalanceOutput
        {
            Owner = input.Owner,
            Balance = balance,
            TokenHash = tokenHash
        };
    }
```
