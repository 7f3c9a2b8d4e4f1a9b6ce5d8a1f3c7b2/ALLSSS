# Audit Report

## Title
Broken After-Execution Validation Enables Consensus State Poisoning via Same-Object Hash Comparison

## Summary
The `ValidateConsensusAfterExecution` method contains a critical bug where the hash comparison always passes because both sides reference the same object. Recovery methods modify the Round object in-place and return `this`, which gets assigned to `headerInformation.Round`, causing the validation to compare an object's hash with itself. This allows malicious miners to commit arbitrary consensus data to StateDb, corrupting future block validations.

## Finding Description

### Root Cause: In-Place Modification with Self-Return

The recovery methods in the Round class modify the object in-place and return `this`: [1](#0-0) [2](#0-1) 

Both methods modify `RealTimeMinersInformation` entries directly on the caller object and return `this`.

### Broken Validation Pattern

The critical flaw exists in the after-execution validation where the return value from recovery is incorrectly assigned: [3](#0-2) 

The validation flow:
1. Line 87: Load `currentRound` from StateDb (post-execution state)
2. Lines 90-92 or 95-97: Call recovery method which modifies `currentRound` in-place and returns it
3. The return value (which IS `currentRound`) gets assigned to `headerInformation.Round`
4. Lines 100-101: Compare `headerInformation.Round.GetHash()` vs `currentRound.GetHash()`

After step 3, both variables reference the same object, making the hash comparison meaningless—it compares an object's hash with itself, which always passes.

### Correct Usage Pattern for Comparison

The before-execution validation demonstrates the correct usage—calling recovery for side effects only without assignment: [4](#0-3) 

Here, recovery updates `baseRound` with timing information from the header, but `extraData.Round` remains untouched, preserving the original header data for subsequent validation. This inconsistency confirms the bug in after-execution validation.

### State Modification During Execution

During block processing, consensus fields are modified and written to StateDb: [5](#0-4) [6](#0-5) 

Fields like `ProducedBlocks`, `ProducedTinyBlocks`, `Signature`, `OutValue`, and `ImpliedIrreversibleBlockHeight` are modified during processing. The after-execution validation should verify that the round data in the header matches what was written to state, but the broken hash comparison prevents this.

### Manipulable Fields

The simplified round structures include the manipulable fields: [7](#0-6) [8](#0-7) 

For UpdateValue: `OutValue`, `Signature`, `ProducedBlocks`, `ProducedTinyBlocks`, `ImpliedIrreversibleBlockHeight`, and ordering fields. For TinyBlock: `ProducedBlocks`, `ProducedTinyBlocks`, `ImpliedIrreversibleBlockHeight`. All these can be manipulated by a malicious miner.

### Validation Pipeline Integration

The broken validation is part of the mandatory block processing pipeline: [9](#0-8) 

The `ValidateBlockAfterExecuteAsync` method calls the consensus service validation, which invokes the contract's `ValidateConsensusAfterExecution`. When this validation is broken, corrupted consensus data gets committed to the blockchain state.

## Impact Explanation

### Consensus Integrity Compromise

This vulnerability breaks the fundamental consensus integrity invariant—the state written during execution must match what was declared in the block header. Malicious miners can write arbitrary consensus data to StateDb that differs from their block headers.

### Cascading Validation Failures

Future blocks load the corrupted round data as their `BaseRound` for validation: [10](#0-9) 

Validation providers depend on this data: [11](#0-10) [12](#0-11) 

Mining permission checks and time slot validation rely on the `BaseRound` data. Corrupted state can cause legitimate blocks to be rejected or malicious blocks to be accepted.

### Concrete Attack Scenarios

1. **Production Counter Manipulation**: Miner provides inflated `ProducedBlocks` in header, actual correct value written to state, validation passes, future blocks use corrupted counters
2. **Signature/Cryptographic Field Corruption**: Miner provides invalid `Signature` or `OutValue` in header, bypassing cryptographic validation
3. **LIB Height Manipulation**: Incorrect `ImpliedIrreversibleBlockHeight` affects finality calculations
4. **Round Ordering Corruption**: Invalid `SupposedOrderOfNextRound`/`FinalOrderOfNextRound` disrupts miner scheduling

**Severity: CRITICAL** - Corrupted consensus state leads to denial of service, consensus manipulation, chain instability, and complete loss of trust in consensus integrity.

## Likelihood Explanation

### Attacker Requirements

The attacker must be an active miner: [13](#0-12) 

The miner must be in either current or previous round's miner list. This is a realistic precondition in a DPoS system.

### Attack Complexity: LOW

1. Miner produces a block with UpdateValue/TinyBlock behavior during their assigned time slot
2. Crafts block header with manipulated consensus fields (e.g., incorrect `ProducedBlocks` count)
3. Before-execution validation may pass if manipulation is subtle
4. Block executes, writing manipulated data to StateDb
5. After-execution validation passes due to same-object bug
6. Corrupted state is committed to blockchain

### Feasibility: HIGH

- No additional permissions beyond normal miner role
- Bug is deterministic and always present
- Exploitable in a single block
- No economic penalties or detection mechanisms
- Works for UpdateValue, TinyBlock, and potentially NextRound behaviors

**Likelihood: HIGH** - Any malicious miner can exploit this during their mining slot. The attack surface is continuously available as miners rotate through the consensus schedule.

## Recommendation

Fix the after-execution validation by not assigning the recovery method's return value:

```csharp
public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
{
    var headerInformation = new AElfConsensusHeaderInformation();
    headerInformation.MergeFrom(input.Value);
    if (TryToGetCurrentRoundInformation(out var currentRound))
    {
        // Call recovery for side effects only, don't assign the return value
        if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
            currentRound.RecoverFromUpdateValue(headerInformation.Round,
                headerInformation.SenderPubkey.ToHex());

        if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
            currentRound.RecoverFromTinyBlock(headerInformation.Round,
                headerInformation.SenderPubkey.ToHex());

        // Now compare headerInformation.Round (original header) vs currentRound (recovered from state)
        var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
        if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
            currentRound.GetHash(isContainPreviousInValue))
        {
            // validation logic...
        }
    }
    return new ValidationResult { Success = true };
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ValidateConsensusAfterExecution_SameObjectHashComparison_AlwaysPasses()
{
    // Setup: Create a round with specific data
    var originalRound = new Round
    {
        RoundNumber = 1,
        RealTimeMinersInformation = 
        {
            ["miner1"] = new MinerInRound
            {
                Pubkey = "miner1",
                ProducedBlocks = 5,
                OutValue = Hash.FromString("original")
            }
        }
    };
    
    // Miner crafts a header with DIFFERENT data (attack scenario)
    var maliciousHeader = new AElfConsensusHeaderInformation
    {
        Behaviour = AElfConsensusBehaviour.UpdateValue,
        SenderPubkey = ByteString.CopyFromUtf8("miner1"),
        Round = new Round
        {
            RoundNumber = 1,
            RealTimeMinersInformation = 
            {
                ["miner1"] = new MinerInRound
                {
                    Pubkey = "miner1",
                    ProducedBlocks = 999, // MANIPULATED
                    OutValue = Hash.FromString("malicious") // MANIPULATED
                }
            }
        }
    };
    
    // Simulate after-execution validation logic
    var currentRound = originalRound; // Loaded from state
    var headerInformation = maliciousHeader;
    
    // BUG: This assignment makes both variables reference the same object
    headerInformation.Round = currentRound.RecoverFromUpdateValue(
        headerInformation.Round, 
        headerInformation.SenderPubkey.ToHex()
    );
    
    // Hash comparison - will ALWAYS pass because comparing same object
    var hash1 = headerInformation.Round.GetHash();
    var hash2 = currentRound.GetHash();
    
    // Assertion: These hashes are identical even though original data was different
    hash1.ShouldBe(hash2); // PASSES - validation is broken
    
    // Verify they are the same object reference
    object.ReferenceEquals(headerInformation.Round, currentRound).ShouldBeTrue();
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-101)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-60)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-252)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-56)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = pubkey,
                    OutValue = minerInRound.OutValue,
                    Signature = minerInRound.Signature,
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    PreviousInValue = minerInRound.PreviousInValue,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
                    Order = minerInRound.Order,
                    IsExtraBlockProducer = minerInRound.IsExtraBlockProducer
                }
            }
        };
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L58-82)
```csharp
    public Round GetTinyBlockRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = minerInRound.Pubkey,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight
                }
            }
        };

        foreach (var otherPubkey in RealTimeMinersInformation.Keys.Except(new List<string> { pubkey }))
            round.RealTimeMinersInformation.Add(otherPubkey, new MinerInRound());

        return round;
    }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusValidationProvider.cs (L80-99)
```csharp
    public async Task<bool> ValidateBlockAfterExecuteAsync(IBlock block)
    {
        if (block.Header.Height == AElfConstants.GenesisBlockHeight)
            return true;

        var consensusExtraData = _consensusExtraDataExtractor.ExtractConsensusExtraData(block.Header);
        if (consensusExtraData == null || consensusExtraData.IsEmpty)
        {
            Logger.LogDebug($"Invalid consensus extra data {block}");
            return false;
        }

        var isValid = await _consensusService.ValidateConsensusAfterExecutionAsync(new ChainContext
        {
            BlockHash = block.GetHash(),
            BlockHeight = block.Header.Height
        }, consensusExtraData.ToByteArray());

        return isValid;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```
