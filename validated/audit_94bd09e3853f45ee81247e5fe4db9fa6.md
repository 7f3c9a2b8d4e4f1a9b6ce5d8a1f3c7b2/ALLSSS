# Audit Report

## Title
Governance Bypass via Malicious Authorization Contract in Method Fee Controller

## Summary
The `ChangeMethodFeeController` method across all ACS1-implementing system contracts validates new authority by calling `ValidateOrganizationExist` on an attacker-supplied contract address without verifying it's a legitimate system authorization contract. An attacker can deploy a malicious contract that always returns true, obtain one Parliament approval to change the controller, and permanently control method fees without further governance oversight.

## Finding Description

The `ChangeMethodFeeController` method calls `CheckOrganizationExist` to validate the new authority information. [1](#0-0) 

The `CheckOrganizationExist` helper method performs a cross-contract call to `authorityInfo.ContractAddress` without any validation that this address is a legitimate system governance contract (Parliament, Association, or Referendum). [2](#0-1) 

This pattern exists identically across all system contracts implementing ACS1: [3](#0-2) [4](#0-3) [5](#0-4) 

The legitimate governance contracts implement `ValidateOrganizationExist` by checking if an organization exists in their state: [6](#0-5) [7](#0-6) [8](#0-7) 

**Attack Execution Path:**
1. Attacker deploys a malicious contract implementing `ValidateOrganizationExist` that always returns `true`
2. Attacker creates a Parliament proposal to call `ChangeMethodFeeController` with `AuthorityInfo` containing their malicious contract address as `ContractAddress` and their own address as `OwnerAddress`
3. Parliament approves the proposal (contract address may not be thoroughly validated during review)
4. Proposal is released via Parliament's virtual address (the current controller owner) [9](#0-8) 
5. The validation calls the malicious contract which returns `true`, bypassing the check
6. The controller is changed to attacker's `AuthorityInfo`
7. Attacker can now directly call `SetMethodFee` because they are the `MethodFeeController.Value.OwnerAddress` [10](#0-9) 

**Why Existing Protections Fail:**
The `AssertSenderAddressWith` check only verifies the sender is the current controller owner, which is satisfied when Parliament releases the proposal. There is no validation that `authorityInfo.ContractAddress` is in the system contract mapping available via `Context.GetSystemContractNameToAddressMapping()`. The validation is circular - it asks the attacker-provided contract to validate itself.

## Impact Explanation

**Critical Severity** - This vulnerability breaks the fundamental governance invariant that method fee controllers must be legitimate, auditable governance organizations subject to ongoing oversight.

**Concrete Impact:**
1. **Permanent Governance Bypass**: After obtaining one Parliament approval, the attacker permanently controls method fee configuration for the affected contract without requiring any further governance oversight
2. **Protocol-Wide Denial of Service**: The attacker can set prohibitive fees (e.g., millions of tokens) for critical system methods, effectively DoS-ing the protocol
3. **Censorship**: The attacker can selectively increase fees for specific methods to prevent their use
4. **Economic Manipulation**: The attacker can set zero fees for specific methods to manipulate protocol economics
5. **Widespread Vulnerability**: This pattern affects all 15+ system contracts implementing ACS1, including MultiToken, Parliament, Association, Referendum, Consensus, CrossChain, Economic, Election, Genesis, Profit, TokenConverter, TokenHolder, Treasury, Vote, and Configuration contracts

## Likelihood Explanation

**High Likelihood** - The attack is feasible under realistic conditions:

**Attacker Requirements:**
- Deploy one malicious contract (trivial)
- Create a Parliament proposal (public method)
- Obtain sufficient Parliament votes for approval

**Feasibility Factors:**
1. **Governance Inattention**: Block Producers may not thoroughly validate the contract address in proposals, assuming the contract logic itself handles validation
2. **Address Obfuscation**: A contract address appears as a valid address; without explicit checking against system contract mappings, malicious addresses may not be obvious
3. **Trust in Code**: MPs may assume that if a proposal can be created and passes basic validation, the target parameters are properly validated
4. **Economic Rationality**: The cost is obtaining one governance approval, but the reward is permanent control over method fees without further oversight

**Not Applicable Threat Model Violations:**
This attack does NOT require:
- Compromised genesis/organization/consensus keys
- Consensus breaks or chain reorgs
- Cryptographic breaks
- Social engineering of individual users
- Network-layer attacks

The attack works through legitimate protocol mechanisms (governance proposals) with a missing validation check.

## Recommendation

Add validation in the `CheckOrganizationExist` method to ensure the contract address is one of the legitimate system governance contracts:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a system authorization contract
    var systemContracts = Context.GetSystemContractNameToAddressMapping();
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Contract address must be a legitimate authorization contract.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

Apply this fix to all affected contracts: MultiToken, Parliament, Association, Referendum, Consensus, CrossChain, Economic, Election, Genesis, Profit, TokenConverter, TokenHolder, Treasury, Vote, and Configuration.

## Proof of Concept

```csharp
// Deploy malicious authorization contract
public class MaliciousAuthContract : MaliciousAuthContractContainer.MaliciousAuthContractBase
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        // Always return true, bypassing validation
        return new BoolValue { Value = true };
    }
}

// Attack test
[Fact]
public async Task Exploit_ChangeMethodFeeController_WithMaliciousContract()
{
    // Deploy malicious contract
    var maliciousContractAddress = await DeployMaliciousAuthContractAsync();
    var attackerAddress = DefaultSender;
    
    // Get current controller (Parliament default organization)
    var currentController = await TokenContractStub.GetMethodFeeController.CallAsync(new Empty());
    
    // Create proposal to change controller to malicious contract
    var proposalInput = new CreateProposalInput
    {
        ToAddress = TokenContractAddress,
        ContractMethodName = nameof(TokenContractStub.ChangeMethodFeeController),
        Params = new AuthorityInfo
        {
            ContractAddress = maliciousContractAddress,  // Malicious contract
            OwnerAddress = attackerAddress                // Attacker controls this
        }.ToByteString(),
        OrganizationAddress = currentController.OwnerAddress,
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
    };
    
    var proposalId = await ParliamentContractStub.CreateProposal.SendAsync(proposalInput);
    
    // Approve with miners
    await ApproveWithMinersAsync(proposalId.Output);
    
    // Release proposal - validation will pass due to malicious contract
    await ParliamentContractStub.Release.SendAsync(proposalId.Output);
    
    // Verify attacker now controls method fee controller
    var newController = await TokenContractStub.GetMethodFeeController.CallAsync(new Empty());
    newController.ContractAddress.ShouldBe(maliciousContractAddress);
    newController.OwnerAddress.ShouldBe(attackerAddress);
    
    // Attacker can now set arbitrary fees without governance
    var maliciousFees = new MethodFees
    {
        MethodName = nameof(TokenContractStub.Transfer),
        Fees = { new MethodFee { Symbol = "ELF", BasicFee = 1000000000 } } // 1B ELF fee = DoS
    };
    
    var result = await TokenContractStub.SetMethodFee.SendAsync(maliciousFees);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Protocol is now under attacker control - fees set without governance oversight
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L56-60)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L70-74)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L218-221)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```
