# Audit Report

## Title
Missing LIB Height Validation in NextTerm Consensus Behavior Enables Consensus DoS Attack

## Summary
A malicious miner can inject negative `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` values during term transitions due to missing `LibInformationValidationProvider` validation for `NextTerm` behavior. This causes the blockchain to immediately enter Severe mining status, reducing block production to 1 block per round and effectively DoS'ing the consensus mechanism.

## Finding Description

**Root Cause:**

The `NextTermInput.Create()` method directly copies `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` from the provided Round parameter without any validation. [1](#0-0) 

These fields are defined as `int64` in the protobuf schema, which allows negative values in protobuf. [2](#0-1) 

**Missing Validation:**

In `ValidateBeforeExecution`, the `LibInformationValidationProvider` is only applied to `UpdateValue` behavior, NOT to `NextTerm` behavior. [3](#0-2) 

For `NextTerm` behavior, only `RoundTerminateValidationProvider` is applied: [4](#0-3) 

The `LibInformationValidationProvider` prevents LIB values from going backward by rejecting cases where new LIB values are less than existing values: [5](#0-4) 

The `RoundTerminateValidationProvider` only validates that term and round numbers increment correctly, but does NOT validate LIB heights: [6](#0-5) 

**Attack Execution Path:**

A malicious miner can manipulate the consensus extra data in their block header to include a Round object with negative LIB values. The `NextTerm` method processes this input: [7](#0-6) 

Which calls `ProcessConsensusInformation`, routing to `ProcessNextTerm`: [8](#0-7) 

`ProcessNextTerm` converts the input to Round and stores it: [9](#0-8) 

`AddRoundInformation` directly persists the malicious Round to state without validation: [10](#0-9) 

**Consensus DoS Impact:**

Once negative LIB values are stored, `GetMaximumBlocksCount()` reads the malicious `libRoundNumber` from state: [11](#0-10) 

The `BlockchainMiningStatusEvaluator` evaluates blockchain mining status. With a negative `libRoundNumber` (e.g., -100) and positive `currentRoundNumber` (e.g., 100), the Severe status condition becomes: `100 >= -100 + 8` which evaluates to TRUE: [12](#0-11) 

In Severe status, the blockchain restricts mining to 1 block per round and continuously fires `IrreversibleBlockHeightUnacceptable` events: [13](#0-12) 

## Impact Explanation

This vulnerability enables a **Consensus Denial-of-Service attack** with severe operational impact:

- **Blockchain Throughput**: Reduced from normal 8+ blocks per round to just 1 block per round, causing severe performance degradation affecting all network participants
- **Network Disruption**: Continuous `IrreversibleBlockHeightUnacceptable` events signal abnormal blockchain state
- **Consensus Integrity**: The blockchain enters an abnormal Severe status despite being otherwise functional
- **Recovery Complexity**: Requires majority miner coordination to transition to the next term with corrected LIB values

The attack has **persistent effect** - once malicious values are stored in state, they remain until the next term transition. All users, applications, and services dependent on the blockchain experience severely degraded performance during this period.

A code comment indicates this validation was intended but never implemented at the contract level: [14](#0-13) 

## Likelihood Explanation

**HIGH Likelihood** - The attack is highly feasible:

**Attacker Capabilities Required:**
- Must be a current miner in the active miner list (multiple parties possess this capability in any decentralized network)
- Can generate and broadcast consensus blocks with manipulated consensus extra data (standard miner capability)

**Attack Complexity:** LOW
- Simple modification of consensus extra data by changing LIB fields to negative values in the Round protobuf message
- No complex state manipulation or precise timing requirements  
- Single malicious block during term transition achieves persistent DoS effect

**Attack Window:**
- Any term transition provides an opportunity (these occur regularly based on election/term configuration)
- No detection or prevention at the validation layer - the gap allows negative values to pass through

**Economic Rationality:**
- Attack cost: Normal block production cost (attacker is already producing blocks as a legitimate miner)
- Attack benefit: Severe network disruption, potential competitive advantage if attacker operates alternative infrastructure
- Low cost + high impact = economically rational for adversarial miners

The attack requires only privileges that multiple parties legitimately hold, has simple execution with guaranteed impact, making it a realistic threat scenario.

## Recommendation

Apply `LibInformationValidationProvider` to `NextTerm` behavior in the same manner as `UpdateValue` behavior:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add this line
    break;
```

This ensures that LIB height values cannot decrease during term transitions, preventing the injection of negative or backward-moving LIB values.

## Proof of Concept

A proof of concept would involve:

1. Setting up a test environment with a miner in the active miner list
2. During a term transition, creating a `NextTermInput` with a Round containing negative `ConfirmedIrreversibleBlockHeight` (e.g., -1000000) and `ConfirmedIrreversibleBlockRoundNumber` (e.g., -100)
3. Submitting this as consensus extra data in a NextTerm block
4. Observing that validation passes (no `LibInformationValidationProvider` applied)
5. Verifying the negative values are persisted to state via `AddRoundInformation`
6. Confirming subsequent `GetMaximumBlocksCount()` calls return 1 due to Severe status evaluation
7. Observing `IrreversibleBlockHeightUnacceptable` events being fired

The test would demonstrate that the blockchain enters Severe mining status immediately after the malicious term transition, confirming the consensus DoS attack.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L16-17)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
```

**File:** protobuf/aedpos_contract.proto (L257-259)
```text
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L41-44)
```csharp
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L323-325)
```csharp
        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-28)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L127-128)
```csharp
            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```
