# Audit Report

## Title
Null Reference Exception in ProfitDetails Retrieval Causes DoS of TokenHolder Contract Functions

## Summary
The Profit contract's `GetProfitDetails` view method returns null for non-existent beneficiaries without defensive handling. The TokenHolder contract's `AddBeneficiary` and `RemoveBeneficiary` methods directly access properties on the returned object without null checks, causing NullReferenceException and transaction failures during normal profit distribution operations.

## Finding Description

The Profit contract's `GetProfitDetails` method directly returns the mapped state value without null handling [1](#0-0) , which returns null when a beneficiary has never been registered in a profit scheme.

The TokenHolder contract's `AddBeneficiary` method retrieves profit details and immediately accesses the `.Details` property without checking if the returned object is null [2](#0-1) . When adding a NEW beneficiary (the primary use case for this method), the beneficiary doesn't exist in the profit scheme yet, causing `GetProfitDetails` to return null and `.Details.Any()` to throw NullReferenceException.

Similarly, `RemoveBeneficiary` chains `.Details.Single()` directly on the call result without null checking [3](#0-2) , which crashes if the beneficiary doesn't exist or has already been removed.

The Election contract also accesses `.Details` properties without null validation [4](#0-3) , causing similar failures in vote-related operations.

Notably, the Profit contract's own internal methods handle this correctly - the private `GetAllProfitsMap` method explicitly checks for null and returns an empty result [5](#0-4) , and the `AddBeneficiary` method handles null by creating a new instance [6](#0-5) . This confirms that null returns are expected behavior that calling contracts should handle.

## Impact Explanation

**Operational Impact - DoS of Critical TokenHolder Functions:**

The `AddBeneficiary` function becomes completely non-functional for its primary use case of adding new beneficiaries to profit schemes. Since new beneficiaries by definition don't have existing profit details, every call fails with NullReferenceException. This breaks the core mechanism for registering users in token holder dividend distribution systems.

The `RemoveBeneficiary` function fails when called with non-existent or already-removed beneficiary addresses, allowing accidental DoS scenarios or preventing cleanup operations.

Election contract operations that query voter profit details may also fail, potentially affecting voting reward mechanisms.

**Affected Parties:**
- DApp operators cannot onboard new users to profit distribution schemes
- Token holders cannot be registered for staking rewards or dividends
- The entire TokenHolder profit distribution subsystem becomes unusable for new registrations

**Severity Justification:**
Medium severity - While no funds are directly at risk and existing beneficiaries' profits remain claimable, the availability of core profit distribution functionality is completely broken for new registrations. This prevents the protocol from onboarding new participants to reward schemes, which is a critical operational capability.

## Likelihood Explanation

**Reachable Entry Points:**
Both `AddBeneficiary` and `RemoveBeneficiary` are public methods on the TokenHolder contract, callable by scheme managers [7](#0-6) . The `GetValidScheme` helper requires the caller to be a scheme manager [8](#0-7) , which is a legitimate privileged role in the system.

**Attack Complexity:**
Trivial - No attack is needed. This occurs in **normal legitimate operations** when:
1. A scheme manager adds the first beneficiary to a new profit scheme
2. A scheme manager adds any new beneficiary who hasn't been registered before
3. A scheme manager attempts to remove a beneficiary with an incorrect address
4. Election operations process voters who haven't been added to the welfare scheme

**Feasibility:**
The vulnerability triggers automatically during standard protocol usage. The fact that the Profit contract's own `AddBeneficiary` method handles null correctly by checking and creating a new instance confirms that null values are the expected normal case for new beneficiaries.

**Probability:**
High - This will occur immediately upon any attempt to use the TokenHolder contract for its intended purpose of managing profit distribution to new users.

## Recommendation

Add null checks before accessing properties on the `ProfitDetails` object returned from `GetProfitDetails`:

**For TokenHolder.AddBeneficiary:**
```csharp
var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
{
    SchemeId = scheme.SchemeId,
    Beneficiary = input.Beneficiary
});
var shares = input.Shares;
if (detail != null && detail.Details.Any())
{
    // Only keep one detail.
    State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = input.Beneficiary
    });
    shares.Add(detail.Details.Single().Shares);
}
```

**For TokenHolder.RemoveBeneficiary:**
```csharp
var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
{
    Beneficiary = input.Beneficiary,
    SchemeId = scheme.SchemeId
});
if (detail == null || !detail.Details.Any())
{
    return new Empty(); // Or throw appropriate error
}
var lockedAmount = detail.Details.Single().Shares;
```

**For Election.GetProfitDetailByElectionVotingRecord:**
```csharp
var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
{
    Beneficiary = electionVotingRecord.Voter,
    SchemeId = State.WelfareHash.Value
});

if (profitDetails == null)
{
    return null;
}

ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
```

## Proof of Concept

```csharp
[Fact]
public async Task AddBeneficiary_NewBeneficiary_CausesNullReferenceException()
{
    // Setup: Create a scheme
    var schemeManager = Accounts[0].Address;
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });
    
    // Attempt to add a new beneficiary who has never been registered
    var newBeneficiary = Accounts[1].Address;
    
    // This should work but will throw NullReferenceException
    // because GetProfitDetails returns null for new beneficiary
    // and code accesses detail.Details.Any() without null check
    var result = await TokenHolderContractStub.AddBeneficiary.SendAsync(
        new AddTokenHolderBeneficiaryInput
        {
            Beneficiary = newBeneficiary,
            Shares = 100
        });
    
    // Expected: Transaction succeeds and beneficiary is added
    // Actual: Transaction fails with NullReferenceException
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L46-49)
```csharp
    public override ProfitDetails GetProfitDetails(GetProfitDetailsInput input)
    {
        return State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L108-110)
```csharp
        var profitDetails = State.ProfitDetailsMap[schemeId][beneficiary];

        if (profitDetails == null) return new GetAllProfitsMapOutput();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-68)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }

        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = shares
            }
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L74-78)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-283)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L170-177)
```csharp
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```
