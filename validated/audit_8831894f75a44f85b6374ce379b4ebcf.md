# Audit Report

## Title
Self-Referential Method Fee Setting Enables Governance Lockout

## Summary
The `SetMethodFee` function in the Genesis contract lacks validation to prevent setting transaction fees on itself, allowing governance to configure a fee that must be paid to modify any method fees. If set excessively high and the Parliament organization's virtual address lacks sufficient funds, governance becomes permanently locked out of all method fee management system-wide.

## Finding Description

The `SetMethodFee` method stores fee configurations without validating whether `input.MethodName` references itself, allowing a fee to be set on the method responsible for modifying all fees. [1](#0-0) 

When Parliament releases an approved proposal, the transaction originates from the organization's virtual address calculated via `CalculateVirtualHash` and executed through `SendVirtualInlineBySystemContract`. [2](#0-1) 

Before any transaction executes, the pre-execution plugin generates a `ChargeTransactionFees` transaction that retrieves the method fee via `GetMethodFee` and attempts to charge `Context.Sender`. [3](#0-2) 

The `GetMethodFee` method returns the stored fee from `State.TransactionFees[input.Value]` without any special exemption for `SetMethodFee` or other critical governance methods. [4](#0-3) 

The fee charging implementation in `ChargeTransactionFees` attempts to deduct the fee from the sender's balance and returns `Success = false` with `ChargingInformation = "Transaction fee not enough"` if insufficient balance exists. [5](#0-4) 

The `IsStopExecuting` method checks the `ChargeTransactionFeesOutput.Success` field and returns `true` (blocking main transaction execution) when `Success` is `false`. [6](#0-5) 

The fee charging logic in `TryToChargeTransactionFee` treats all addresses identically, including organization virtual addresses, with no exemptions based on address type. [5](#0-4) 

Both `SetMethodFee` and `ChangeMethodFeeController` require authorization from `State.MethodFeeController.Value.OwnerAddress`, which defaults to Parliament's default organization, providing no alternative recovery mechanism. [7](#0-6) 

## Impact Explanation

Once a prohibitively high fee is configured for `SetMethodFee`, all future method fee modifications require paying that fee from Parliament's virtual address. Since `SetMethodFee` is the only mechanism to modify method fees (including reducing its own fee), and `ChangeMethodFeeController` requires identical authorization from the same organization address, governance lockout occurs if the organization cannot afford the fee.

This affects system-wide fee management capability across all contracts implementing ACS1. Test evidence confirms organizations must pre-fund their virtual addresses before releasing proposals that execute token transfers. [8](#0-7) 

If the fee exceeds economically feasible amounts (e.g., 10^18 ELF, far exceeding total supply), recovery becomes mathematically impossible, resulting in permanent loss of fee governance across the entire protocol.

## Likelihood Explanation

While this requires Parliament governance approval (2/3 miner consensus), it represents a realistic threat through:

1. **Human error**: Accidental misconfiguration during routine fee updates. Example: intending to set 100 ELF (100 * 10^8 base units) but mistakenly entering 100 * 10^18, creating an unpayable fee.

2. **Lack of validation**: The `SetMethodFee` implementation performs no bounds checking on fee amounts or validation preventing self-referential fee setting. [1](#0-0) 

3. **Approval blindness**: Multiple miners could approve routine-looking fee adjustment proposals without detailed value verification, especially for methods like `SetMethodFee` that appear to be routine governance maintenance.

The attack requires only one successful governance proposal with `input.MethodName = "SetMethodFee"` and an excessive fee value. The precondition (governance approval) is routine as Parliament regularly votes on fee adjustments during normal network operations.

## Recommendation

Add validation to `SetMethodFee` to prevent self-referential fee setting and implement reasonable upper bounds:

```csharp
public override Empty SetMethodFee(MethodFees input)
{
    // Prevent self-referential fee setting
    Assert(input.MethodName != nameof(SetMethodFee), 
        "Cannot set fee on SetMethodFee method.");
    Assert(input.MethodName != nameof(ChangeMethodFeeController),
        "Cannot set fee on ChangeMethodFeeController method.");
    
    foreach (var methodFee in input.Fees)
    {
        AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        // Add reasonable upper bound (e.g., 1000 ELF)
        Assert(methodFee.BasicFee <= 1000_00000000, 
            "Fee exceeds maximum allowed amount.");
    }

    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, 
        "Unauthorized to set method fee.");
    State.TransactionFees[input.MethodName] = input;

    return new Empty();
}
```

Additionally, consider implementing an emergency recovery mechanism through a separate controller or time-locked override capability for critical governance methods.

## Proof of Concept

```csharp
[Fact]
public async Task SetMethodFee_SelfReferential_Causes_Governance_Lockout_Test()
{
    // 1. Get current method fee controller (Parliament default organization)
    var methodFeeController = await GenesisContractStub.GetMethodFeeController.CallAsync(new Empty());
    var parliamentOrg = methodFeeController.OwnerAddress;
    
    // 2. Create proposal to set excessive fee on SetMethodFee itself
    var excessiveFee = 1000000_00000000; // 1 million ELF - exceeds total supply
    var setFeeInput = new MethodFees
    {
        MethodName = nameof(GenesisContractStub.SetMethodFee),
        Fees = { new MethodFee { Symbol = "ELF", BasicFee = excessiveFee } }
    };
    
    var proposalId = await CreateProposalAsync(GenesisContractAddress, 
        parliamentOrg, nameof(GenesisContractStub.SetMethodFee), setFeeInput);
    
    // 3. Approve with miners and release
    await ApproveWithMinersAsync(proposalId);
    await ParliamentContractStub.Release.SendAsync(proposalId);
    
    // 4. Verify fee was set
    var methodFee = await GenesisContractStub.GetMethodFee.CallAsync(
        new StringValue { Value = nameof(GenesisContractStub.SetMethodFee) });
    methodFee.Fees[0].BasicFee.ShouldBe(excessiveFee);
    
    // 5. Attempt to reduce fee - will fail due to insufficient balance
    var reduceFeeInput = new MethodFees
    {
        MethodName = nameof(GenesisContractStub.SetMethodFee),
        Fees = { new MethodFee { Symbol = "ELF", BasicFee = 1_00000000 } }
    };
    
    var recoverProposalId = await CreateProposalAsync(GenesisContractAddress,
        parliamentOrg, nameof(GenesisContractStub.SetMethodFee), reduceFeeInput);
    
    await ApproveWithMinersAsync(recoverProposalId);
    
    // Release will fail - ChargeTransactionFees cannot charge 1M ELF from parliament org
    var releaseResult = await ParliamentContractStub.Release.SendWithExceptionAsync(recoverProposalId);
    releaseResult.TransactionResult.Error.ShouldContain("Transaction fee not enough");
    
    // 6. Governance is now permanently locked - cannot modify any fees
    // Even transferring funds to parliament org won't help if fee exceeds total supply
}
```

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L9-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L34-47)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var fees = State.TransactionFees[input.Value];
        if (fees == null && input.Value == nameof(ReleaseApprovedUserSmartContract))
        {
            fees = new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        }

        return fees;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L58-121)
```csharp
    public async Task<IEnumerable<Transaction>> GetPreTransactionsAsync(IReadOnlyList<ServiceDescriptor> descriptors,
        ITransactionContext transactionContext)
    {
        try
        {
            var chainContext = new ChainContext
            {
                BlockHash = transactionContext.PreviousBlockHash,
                BlockHeight = transactionContext.BlockHeight - 1
            };

            var tokenContractAddress = await _smartContractAddressService.GetAddressByContractNameAsync(
                chainContext,
                TokenSmartContractAddressNameProvider.StringName);

            if (transactionContext.BlockHeight < AElfConstants.GenesisBlockHeight + 1 ||
                tokenContractAddress == null)
                return new List<Transaction>();

            if (!IsApplicableToTransaction(descriptors, transactionContext.Transaction, tokenContractAddress))
                return new List<Transaction>();

            var tokenStub = _contractReaderFactory.Create(new ContractReaderContext
            {
                Sender = transactionContext.Transaction.From,
                ContractAddress = tokenContractAddress,
                RefBlockNumber = transactionContext.Transaction.RefBlockNumber
            });

            if (IsExemptedTransaction(transactionContext.Transaction, tokenContractAddress, tokenStub))
                return new List<Transaction>();

            var txCost = await _txFeeService.CalculateFeeAsync(transactionContext, chainContext);
            var chargeTransactionFeesInput = new ChargeTransactionFeesInput
            {
                MethodName = transactionContext.Transaction.MethodName,
                ContractAddress = transactionContext.Transaction.To,
                TransactionSizeFee = txCost
            };

            var transactionSizeFeeSymbols =
                await _transactionSizeFeeSymbolsProvider.GetTransactionSizeFeeSymbolsAsync(chainContext);
            if (transactionSizeFeeSymbols != null)
                foreach (var transactionSizeFeeSymbol in transactionSizeFeeSymbols.TransactionSizeFeeSymbolList)
                    chargeTransactionFeesInput.SymbolsToPayTxSizeFee.Add(new SymbolToPayTxSizeFee
                    {
                        TokenSymbol = transactionSizeFeeSymbol.TokenSymbol,
                        BaseTokenWeight = transactionSizeFeeSymbol.BaseTokenWeight,
                        AddedTokenWeight = transactionSizeFeeSymbol.AddedTokenWeight
                    });

            var chargeFeeTransaction = GetTransaction(tokenStub, chargeTransactionFeesInput);
            return new List<Transaction>
            {
                chargeFeeTransaction
            };
        }
        catch (Exception e)
        {
            Logger.LogError(
                $"Failed to generate ChargeTransactionFees tx.Transaction to: {transactionContext.Transaction.To},transation method name: {transactionContext.Transaction.MethodName}. Error message: {e.Message}");
            throw;
        }
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L123-129)
```csharp
    public bool IsStopExecuting(ByteString txReturnValue, out string preExecutionInformation)
    {
        var chargeTransactionFeesOutput = new ChargeTransactionFeesOutput();
        chargeTransactionFeesOutput.MergeFrom(txReturnValue);
        preExecutionInformation = chargeTransactionFeesOutput.ChargingInformation;
        return !chargeTransactionFeesOutput.Success;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L84-126)
```csharp
    private ChargeTransactionFeesOutput TryToChargeTransactionFee(ChargeTransactionFeesInput input, Address fromAddress,
        TransactionFeeBill bill, TransactionFreeFeeAllowanceBill allowanceBill, Dictionary<string, long> fee,
        bool isSizeFeeFree)
    {
        Context.LogDebug(() => "TryToChargeTransactionFee Start");
        var chargingResult =
            ChargeTransactionFeesToBill(input, fromAddress, ref bill, ref allowanceBill, fee, isSizeFeeFree);
        if (!chargingResult)
        {
            var delegatorAddress = fromAddress;
            chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                isSizeFeeFree, delegatorAddress);
        }

        if (!chargingResult)
        {
            var transactionFeeDelegatees =
                State.TransactionFeeDelegateInfoMap[fromAddress][input.ContractAddress][input.MethodName] ??
                State.TransactionFeeDelegateesMap[fromAddress];
            if (transactionFeeDelegatees != null)
            {
                var delegateeAddress = transactionFeeDelegatees.Delegatees;
                foreach (var (delegatee, _) in delegateeAddress)
                {
                    chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                        isSizeFeeFree, Address.FromBase58(delegatee));
                    if (chargingResult)
                    {
                        break;
                    }
                }
            }
        }

        ModifyBalance(fromAddress, bill, allowanceBill);
        var chargingOutput = new ChargeTransactionFeesOutput { Success = chargingResult };
        if (!chargingResult)
            chargingOutput.ChargingInformation = "Transaction fee not enough.";
        
        Context.LogDebug(() => "TryToChargeTransactionFee End");
        Context.LogDebug(() => "ChargeTransactionFees End");
        return chargingOutput;
    }
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L659-683)
```csharp
    public async Task Release_Proposal_Success_Test()
    {
        var minimalApproveThreshold = 2;
        var minimalVoteThreshold = 3;
        var maximalAbstentionThreshold = 1;
        var maximalRejectionThreshold = 1;
        var organizationAddress = await CreateOrganizationAsync(minimalApproveThreshold, minimalVoteThreshold,
            maximalAbstentionThreshold, maximalRejectionThreshold, Reviewer1);
        var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
        await TransferToOrganizationAddressAsync(organizationAddress);
        await ApproveAsync(Reviewer3KeyPair, proposalId);
        await ApproveAsync(Reviewer2KeyPair, proposalId);
        await ApproveAsync(Reviewer1KeyPair, proposalId);

        var associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
        var result = await associationContractStub.Release.SendAsync(proposalId);
        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        // Check inline transaction result
        var getBalance = TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = "ELF",
            Owner = Reviewer1
        }).Result.Balance;
        getBalance.ShouldBe(100);
    }
```
