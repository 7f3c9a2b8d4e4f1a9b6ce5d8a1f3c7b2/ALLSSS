# Audit Report

## Title
NextRound Validation Fails to Detect Duplicate Mining Orders Due to Incorrect Distinct() Usage

## Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` function incorrectly validates uniqueness of `FinalOrderOfNextRound` values by calling `.Distinct()` on `MinerInRound` objects instead of the order values themselves. This allows a malicious extra block producer to submit a round with duplicate mining orders, breaking the consensus schedule and potentially causing chain halt.

## Finding Description

The validation logic contains a critical bug where it attempts to verify that miners who mined blocks have distinct `FinalOrderOfNextRound` values, but the implementation is flawed. [1](#0-0) 

The code calls `.Distinct()` on a collection of `MinerInRound` objects. Since `MinerInRound` is a protobuf-generated class [2](#0-1) , its equality comparison includes all fields (pubkey, signature, order, etc.). Different miners will always be considered distinct objects even if they share the same `FinalOrderOfNextRound` value.

**Attack Scenario:**
1. Attacker becomes extra block producer (role rotates among miners)
2. Crafts malicious `NextRoundInput` where multiple miners have identical `FinalOrderOfNextRound` (e.g., all set to 1)
3. Sets `OutValue != null` for those miners
4. Validation counts: `distinctCount = 3` (three distinct miner objects) vs `OutValue count = 3`
5. Validation incorrectly passes (3 == 3)

This validation is invoked during NextRound behavior processing: [3](#0-2) 

The validated round is then stored and used for subsequent round generation: [4](#0-3) 

When the next round transition occurs, the generation logic uses these duplicate orders: [5](#0-4) 

The `occupiedOrders` list will contain duplicates, but `.Contains()` only excludes each value once. This results in multiple miners assigned `Order = 1` in the next round, while some valid order slots remain empty, creating an invalid consensus schedule.

## Impact Explanation

**Severity: HIGH** - This directly violates the critical consensus invariant that each miner must have a unique mining order within a round.

When multiple miners have the same `Order` value:
- Multiple miners attempt to produce blocks at the same time slot
- The consensus protocol cannot handle overlapping mining times
- Block production fails or creates competing blocks at the same height
- Chain may halt due to inability to reach consensus
- All network participants experience disruption
- Miners lose block rewards during failed rounds
- Chain liveness and safety guarantees are violated

This breaks the fundamental "one miner per time slot" invariant that the AEDPoS consensus depends on for proper operation.

## Likelihood Explanation

**Probability: HIGH** - This vulnerability is easily exploitable with standard miner privileges.

**Attacker Requirements:**
- Must be selected as extra block producer (rotates regularly among all miners)
- No special privileges beyond being a legitimate miner
- Can call the public `NextRound` method [6](#0-5) 

**Attack Complexity:**
- Low - simply craft a `NextRoundInput` with duplicate `FinalOrderOfNextRound` values
- No economic cost beyond normal mining operations
- The validation bypass is guaranteed due to the `.Distinct()` bug
- Detection is difficult as it appears as a normal round transition

**Feasibility:**
- Extra block producer role rotates regularly among miners
- Any malicious miner can exploit this during their turn
- The attack is reproducible and reliable
- No other validations check for duplicate orders [7](#0-6) 

## Recommendation

Fix the validation to check for distinct `FinalOrderOfNextRound` values rather than distinct miner objects:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Add this line
    .Distinct()
    .Count();
```

This ensures the validation correctly checks that all miners who mined have unique `FinalOrderOfNextRound` values, preventing duplicate order assignments in subsequent rounds.

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_Duplicate_FinalOrderOfNextRound_Should_Be_Rejected()
{
    // Setup: Initialize consensus with multiple miners
    await InitializeConsensusWithMiners();
    var currentRound = await GetCurrentRoundInformation();
    
    // Attacker crafts malicious NextRoundInput
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber
    };
    
    // Set multiple miners with identical FinalOrderOfNextRound = 1
    var minerKeys = currentRound.RealTimeMinersInformation.Keys.Take(3).ToList();
    foreach (var minerKey in minerKeys)
    {
        maliciousInput.RealTimeMinersInformation[minerKey] = new MinerInRound
        {
            Pubkey = minerKey,
            FinalOrderOfNextRound = 1,  // All set to same value
            OutValue = HashHelper.ComputeFrom("test"),  // Set to pass OutValue check
            Order = 1
        };
    }
    
    maliciousInput.RandomNumber = ByteString.CopyFrom(await GenerateRandomProof());
    
    // Attack: Submit malicious round as extra block producer
    var result = await ExtraBlockProducerStub.NextRound.SendAsync(maliciousInput);
    
    // Expected: Should fail validation
    // Actual: Passes due to .Distinct() bug, creating invalid consensus state
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);  // This will fail, proving the bug
    
    // Verify invalid state: multiple miners with same order
    var nextRound = await GetCurrentRoundInformation();
    var ordersWithDuplicates = nextRound.RealTimeMinersInformation.Values
        .GroupBy(m => m.Order)
        .Where(g => g.Count() > 1)
        .ToList();
    ordersWithDuplicates.ShouldBeEmpty();  // This assertion fails, proving consensus is broken
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-21)
```csharp
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** protobuf/aedpos_contract.proto (L266-290)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```
