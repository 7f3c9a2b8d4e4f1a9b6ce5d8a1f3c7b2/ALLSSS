# Audit Report

## Title 
Arithmetic Overflow in PayRental Calculation Causes Permanent DoS of Side Chain Resource Fee Collection

## Summary
The `PayRental()` method performs uncapped multiplication of unbounded `duration` with `ResourceAmount` and `Rental` parameters, where duration grows based on elapsed time since last payment. With moderate rental parameters, side chains experiencing extended downtime trigger checked arithmetic overflow, causing permanent DoS of the resource rental collection mechanism until governance intervention.

## Finding Description

The vulnerability exists in the rental fee calculation logic that executes automatically on every block for side chains. The `PayRental()` method calculates rental charges using: [1](#0-0) 

Where `duration` is the unbounded time difference in minutes since the last payment: [2](#0-1) 

The multiplication operations use checked arithmetic that throws `OverflowException` on overflow: [3](#0-2) 

The root cause is that governance-controlled rental parameters lack upper bound validation. The `UpdateRental` method only validates non-negativity: [4](#0-3) 

Similarly, `UpdateRentedResources` has the same insufficient validation: [5](#0-4) 

The execution path is automatic and unavoidable. `PayRental()` is called from `DonateResourceToken()` on all side chains: [6](#0-5) 

And `DonateResourceToken()` is automatically invoked by miners each block via the system transaction generator: [7](#0-6) 

When overflow occurs, the entire system transaction fails with `OverflowException`, preventing all subsequent rental collection attempts until governance reduces the parameters.

## Impact Explanation

**Severity: HIGH**

The impact is complete operational failure of a critical side chain economic mechanism. When the overflow occurs, it causes:

1. **Permanent DoS**: `DonateResourceToken()` fails on every block attempt, completely breaking the resource rental collection system
2. **Economic disruption**: Side chain creators stop paying rental fees for resources (CPU, RAM, DISK, NET), violating the economic model
3. **Consensus impact**: The consensus contract stops receiving rental payments that should fund validator rewards

Based on test parameters from the codebase: [8](#0-7) 

Overflow timing with realistic parameter ranges (long max = 9,223,372,036,854,775,807):
- **Moderate parameters** (ResourceAmount=1000, Rental=10 billion): Overflow after ~640 days downtime
- **High parameters** (ResourceAmount=10000, Rental=100 billion): Overflow after ~6.4 days downtime  
- **Very high parameters** (ResourceAmount=100000, Rental=1 trillion): Overflow after ~1.5 hours downtime

The only recovery path is emergency governance intervention to reduce `Rental` or `ResourceAmount` values, which requires proposal creation, approval, and execution—a multi-step, time-consuming process during which the DoS persists.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The vulnerability has high likelihood because:

1. **No attacker required**: The vulnerability triggers automatically based on time passage—no malicious action needed
2. **Realistic preconditions**: Side chains can experience extended downtime due to:
   - Network partitions separating validators
   - All validators going offline simultaneously
   - Critical bugs requiring emergency fixes
   - Economic attacks causing validator departures
3. **Legitimate parameter values**: Governance may legitimately set moderate-to-high rental rates for resource pricing, unknowingly creating overflow risk
4. **Automatic trigger**: Once the threshold is reached, the next miner's automatic `DonateResourceToken()` call immediately triggers the overflow
5. **Observable in production**: The overflow manifests as clear `OverflowException` in transaction results, making it detectable but not preventable once triggered

The combination of realistic downtime scenarios, legitimate parameter choices, and automatic triggering makes this vulnerability highly likely to occur in production side chains.

## Recommendation

Implement upper bound validation for rental parameters to prevent overflow scenarios:

```csharp
public override Empty UpdateRental(UpdateRentalInput input)
{
    AssertControllerForSideChainRental();
    foreach (var pair in input.Rental)
    {
        Assert(
            Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
            "Invalid symbol.");
        Assert(pair.Value >= 0, "Invalid amount.");
        
        // Add upper bound validation to prevent overflow
        // Assuming max duration of 365 days = 525,600 minutes
        // And max ResourceAmount of 100,000
        // Max safe Rental = long.MaxValue / (525600 * 100000) ≈ 175,000,000,000
        const long maxSafeRental = 175_000_000_000;
        Assert(pair.Value <= maxSafeRental, 
            $"Rental value {pair.Value} exceeds maximum safe value {maxSafeRental}");
        
        State.Rental[pair.Key] = pair.Value;
    }

    return new Empty();
}

public override Empty UpdateRentedResources(UpdateRentedResourcesInput input)
{
    AssertControllerForSideChainRental();
    foreach (var pair in input.ResourceAmount)
    {
        Assert(
            Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
            "Invalid symbol.");
        Assert(pair.Value >= 0, "Invalid amount.");
        
        // Add upper bound validation
        const int maxSafeResourceAmount = 100_000;
        Assert(pair.Value <= maxSafeResourceAmount,
            $"ResourceAmount value {pair.Value} exceeds maximum safe value {maxSafeResourceAmount}");
        
        State.ResourceAmount[pair.Key] = pair.Value;
    }

    return new Empty();
}
```

Additionally, consider adding a duration cap in `PayRental()` to limit the maximum time window for rental calculation, preventing unbounded duration accumulation during extended downtime periods.

## Proof of Concept

```csharp
[Fact]
public async Task PayRental_Overflow_DoS_Test()
{
    // Initialize side chain with moderate rental parameters
    await InitializeTokenContractAsync();
    
    // Set rental parameters that will cause overflow after ~6 days
    var rentalInput = new UpdateRentalInput
    {
        Rental =
        {
            { "CPU", 100_000_000_000 }, // 100 billion per unit per minute
            { "RAM", 100_000_000_000 },
            { "DISK", 100_000_000_000 },
            { "NET", 100_000_000_000 }
        }
    };
    
    var resourceInput = new UpdateRentedResourcesInput
    {
        ResourceAmount =
        {
            { "CPU", 10000 },
            { "RAM", 10000 },
            { "DISK", 10000 },
            { "NET", 10000 }
        }
    };
    
    await UpdateSideChainRentalAsync(
        nameof(TokenContractImplContainer.TokenContractImplStub.UpdateRental), rentalInput);
    await UpdateSideChainRentalAsync(
        nameof(TokenContractImplContainer.TokenContractImplStub.UpdateRentedResources), resourceInput);
    
    // Simulate 7 days (10,080 minutes) of downtime
    // This will cause overflow: 10080 * 10000 * 100_000_000_000 > long.MaxValue
    var blockTime = TimestampHelper.GetUtcNow();
    BlockTimeProvider.SetBlockTime(blockTime.AddMinutes(10080));
    
    // Attempt to call DonateResourceToken - should fail with overflow
    var result = await TokenContractStub.DonateResourceToken.SendWithExceptionAsync(
        new TotalResourceTokensMaps());
    
    // Verify the DoS: transaction fails with overflow exception
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Overflow");
    
    // Verify side chain rental collection is completely broken
    // All subsequent attempts also fail
    var secondAttempt = await TokenContractStub.DonateResourceToken.SendWithExceptionAsync(
        new TotalResourceTokensMaps());
    secondAttempt.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L947-950)
```csharp
        if (!isMainChain)
        {
            PayRental();
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1031-1031)
```csharp
        var duration = (Context.CurrentBlockTime - State.LastPayRentTime.Value).Seconds.Div(60);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1061-1061)
```csharp
            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1107-1107)
```csharp
            Assert(pair.Value >= 0, "Invalid amount.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1122-1122)
```csharp
            Assert(pair.Value >= 0, "Invalid amount.");
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L79-85)
```csharp
    public static long Mul(this long a, long b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee/DonateResourceTransactionGenerator.cs (L60-71)
```csharp
        generatedTransactions.AddRange(new List<Transaction>
        {
            new()
            {
                From = from,
                MethodName = nameof(TokenContractImplContainer.TokenContractImplStub.DonateResourceToken),
                To = tokenContractAddress,
                RefBlockNumber = preBlockHeight,
                RefBlockPrefix = BlockHelper.GetRefBlockPrefix(preBlockHash),
                Params = input
            }
        });
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainSideChainRentFeeTest.cs (L19-26)
```csharp
    private const int CpuAmount = 4;
    private const int RamAmount = 8;
    private const int DiskAmount = 512;
    private const int NetAmount = 1000;

    private const long ResourceSupply = 1_0000_0000_00000000;

    private const long Rental = 100;
```
