# Audit Report

## Title
NFT Collection Symbol Collision Enables Namespace Hijacking via SEED NFT Manipulation

## Summary
The MultiToken contract allows SEED NFTs to be created for NFT collection symbols (ending in "-0"), which can be exploited to permanently hijack base token namespaces. Due to mutual exclusion enforcement between base symbols and their collection counterparts, an attacker who creates "TARGET-0" first can permanently block the legitimate creation of "TARGET", causing economic loss from burned SEED NFTs and irreversible namespace denial.

## Finding Description

The vulnerability arises from the interaction between four core mechanisms in the MultiToken contract:

**1. Collection Symbol Format**

The collection suffix is hardcoded as "0": [1](#0-0) 

Collection symbols are constructed by appending "-0" to the base symbol: [2](#0-1) 

**2. Symbol Type Classification**

Symbols ending in "-0" are classified as `NftCollection` type: [3](#0-2) 

**3. Mutual Exclusion Enforcement**

When creating tokens or NFT collections, the contract checks that BOTH the base symbol AND its collection symbol don't already exist: [4](#0-3) 

This validation is called for all non-NFT token types: [5](#0-4) 

**4. Insufficient SEED NFT Validation**

When creating SEED NFTs, the contract explicitly allows `ownedSymbol` to be of type `NftCollection` (only rejecting `Nft` type): [6](#0-5) 

**Attack Execution Path:**

1. SEED issuer creates SEED NFT with `ownedSymbol="TARGET-0"` (passes validation since it's `NftCollection` type, not `Nft`)
2. Attacker obtains this SEED NFT through legitimate means
3. Attacker calls `Create()` with symbol "TARGET-0"
4. The symbol is classified as `NftCollection` and routed to `CreateNFTCollection()`: [7](#0-6) 
5. SEED NFT validation passes: [8](#0-7) 
6. The SEED NFT is consumed (burned): [9](#0-8) 
7. Token "TARGET-0" is registered in the system
8. Legitimate owner with SEED NFT for "TARGET" attempts creation but `CheckTokenAndCollectionExists("TARGET")` now fails because "TARGET-0" exists

## Impact Explanation

**Critical Severity - Permanent Namespace Hijacking:**

- **Token Creation DoS**: Legitimate token creators are permanently blocked from using their SEED NFTs. Once "TARGET-0" exists, "TARGET" can never be created due to the mutual exclusion check, and vice versa.

- **Economic Loss**: SEED NFTs are valuable one-time-use tokens that get burned upon token creation. Victims lose their SEED NFTs without being able to create their intended tokens, with no recovery mechanism.

- **Brand Squatting**: Attackers can preemptively register collection symbols for high-value brand names, permanently denying legitimate trademark holders their namespace rights.

- **Irreversibility**: No recovery mechanism exists in the contract. Once a collection symbol is registered, the corresponding base symbol is permanently blocked from creation.

## Likelihood Explanation

**Medium-to-High Likelihood:**

**Attacker Requirements:**
- Obtain SEED NFT with `ownedSymbol` set to a collection symbol ending in "-0"
- This requires SEED issuer cooperation (social engineering, insider threat) or exploiting permissive SEED issuance policies

**Feasibility Factors:**
- The code explicitly permits SEED NFTs for collection symbols as shown in tests: [10](#0-9) 
- No ownership relationship enforcement exists between "PREFIX" and "PREFIX-0" symbols
- SEED issuance depends on governance/administrative processes which may not distinguish between base and collection symbols

**Attack Complexity:** Low once SEED NFT is obtained
- Single `Create()` transaction with valid SEED NFT
- No sophisticated contract interactions required
- Front-running opportunity if legitimate and malicious SEED NFTs exist simultaneously

## Recommendation

Add validation to prevent SEED NFTs from being created for collection symbols:

```csharp
// In TokenContract_NFT_Actions.cs, CreateNFTInfo method
var ownedSymbolType = GetSymbolType(ownedSymbol);
Assert(ownedSymbolType != SymbolType.Nft, "Invalid OwnedSymbol.");
// ADD THIS CHECK:
Assert(ownedSymbolType != SymbolType.NftCollection, "SEED NFTs cannot be created for collection symbols.");
```

Alternatively, enforce that if a SEED NFT exists for a base symbol, it implicitly grants rights to create both the base symbol and its collection symbol, or implement a registration system that reserves both symbols atomically.

## Proof of Concept

```csharp
[Fact]
public async Task NamespaceHijacking_Via_CollectionSymbol_SEED_NFT()
{
    // Step 1: Create SEED NFT for collection symbol "TARGET-0"
    var collectionSeedInput = BuildSeedCreateInput(new CreateInput
    {
        Symbol = "TARGET-0",  // Collection symbol
        TokenName = "Target Collection",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultAddress,
        Owner = DefaultAddress
    });
    
    await TokenContractStub.Create.SendAsync(collectionSeedInput);
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = collectionSeedInput.Symbol,
        Amount = 1,
        To = DefaultAddress
    });
    
    // Step 2: Attacker uses SEED NFT to create "TARGET-0"
    var attackResult = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "TARGET-0",
        TokenName = "Hijacked Collection",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultAddress,
        Owner = DefaultAddress
    });
    attackResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 3: Create SEED NFT for base symbol "TARGET"
    var baseSeedInput = BuildSeedCreateInput(new CreateInput
    {
        Symbol = "TARGET",  // Base symbol
        TokenName = "Target Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAddress,
        Owner = DefaultAddress
    });
    
    await TokenContractStub.Create.SendAsync(baseSeedInput);
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = baseSeedInput.Symbol,
        Amount = 1,
        To = DefaultAddress
    });
    
    // Step 4: Legitimate owner tries to create "TARGET" but fails
    var victimResult = await TokenContractStub.Create.SendWithExceptionAsync(new CreateInput
    {
        Symbol = "TARGET",
        TokenName = "Target Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAddress,
        Owner = DefaultAddress
    });
    
    // Verify the attack succeeded - "TARGET" cannot be created
    victimResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    victimResult.TransactionResult.Error.ShouldContain("Token already exists");
    
    // The victim's SEED NFT was burned but they got nothing
    var victimBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = baseSeedInput.Symbol
    });
    victimBalance.Balance.ShouldBe(0);  // SEED burned but no token created
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L22-22)
```csharp
    public const string CollectionSymbolSuffix = "0";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L280-281)
```csharp
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L285-293)
```csharp
    private void CheckTokenAndCollectionExists(string symbol)
    {
        var symbols = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        var tokenSymbol = symbols.First();
        CheckTokenExists(tokenSymbol);
        var collectionSymbol = symbols.First() + TokenContractConstants.NFTSymbolSeparator +
                               TokenContractConstants.CollectionSymbolSuffix;
        CheckTokenExists(collectionSymbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L46-49)
```csharp
            var ownedSymbolType = GetSymbolType(ownedSymbol);
            Assert(ownedSymbolType != SymbolType.Nft, "Invalid OwnedSymbol.");
            CheckSymbolLength(ownedSymbol, ownedSymbolType);
            CheckTokenAndCollectionExists(ownedSymbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L40-42)
```csharp
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L59-60)
```csharp
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L62-64)
```csharp
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/NftApplicationTests.cs (L300-302)
```csharp
            var seedInput = BuildSeedCreateInput( new CreateInput
            {
                Symbol = "ABCDEFGHIJKLMNOPQRSTUVWXYZABC-0",
```
