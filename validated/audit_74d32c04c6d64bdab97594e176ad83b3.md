# Audit Report

## Title
Scheme Manager Can Steal Profit Shares from Locked Token Holders via RemoveBeneficiary

## Summary
The TokenHolder contract's `RemoveBeneficiary` function allows a scheme manager to remove profit shares from users who registered via `RegisterForProfits` with locked tokens, while those tokens remain locked. This enables theft of future profit distributions that should belong to locked token holders.

## Finding Description

The vulnerability exists in the authorization model of the `RemoveBeneficiary` function, which fails to distinguish between two types of beneficiaries:

1. **Manager-added beneficiaries** (via `AddBeneficiary`) - no tokens locked
2. **Self-registered beneficiaries** (via `RegisterForProfits`) - tokens locked as collateral

**Attack Execution Path:**

When a user registers for profits, their tokens are locked and a lock ID is stored [1](#0-0) , and they receive profit shares [2](#0-1) .

However, the scheme manager can call `RemoveBeneficiary`, which only validates that the caller is the scheme manager [3](#0-2) . This function removes the user's profit shares but **does not unlock their tokens** - there is no call to `State.TokenContract.Unlock` and no cleanup of the lock state.

The removal propagates to the Profit contract, which sets the beneficiary's `EndPeriod` to `CurrentPeriod - 1` [4](#0-3) , preventing them from receiving any future profits. The scheme is created with `CanRemoveBeneficiaryDirectly = true` [5](#0-4) , which enables immediate removal of active beneficiaries [6](#0-5) .

The legitimate `Withdraw` function shows the proper flow: it unlocks tokens after the minimum lock period expires [7](#0-6) , but users whose shares were removed cannot receive profits during the lock period, even though their capital remains locked.

## Impact Explanation

**Critical - Direct Financial Theft:**

Users who lock tokens via `RegisterForProfits` have an economic expectation: locked capital guarantees proportional profit share. This vulnerability breaks that invariant by allowing managers to:

1. Remove user profit shares while tokens remain locked
2. Redistribute those shares to other beneficiaries (including the manager)
3. Force users to wait for the minimum lock period before recovering their capital via `Withdraw`

**Quantified Example:**
- User locks 10,000 tokens for 30-day minimum lock period
- Manager has 10,000 shares (total: 20,000 shares)
- Manager calls `RemoveBeneficiary` on the user
- New total shares: 10,000 (only manager)
- If 10,000 tokens profit distributed: Manager receives 10,000 (100%) instead of 5,000 (50%)
- User receives 0 while their 10,000 tokens remain locked for 30 days
- **Net theft: 5,000 tokens per distribution period**

This affects all users who register via `RegisterForProfits` and is particularly severe for users with large lock amounts or long minimum lock periods.

## Likelihood Explanation

**High Likelihood:**

**Attacker Capabilities:**
- Attacker must be a scheme manager (achieved by calling `CreateScheme` - permissionless [8](#0-7) )
- No additional privileges required

**Attack Complexity:**
- Single function call to `RemoveBeneficiary`
- No timing constraints or complex state manipulation
- Works immediately after users register

**Feasibility:**
- Users registering via `RegisterForProfits` is expected normal usage
- No preconditions beyond normal scheme operation
- Works on any TokenHolder scheme

**Detection:**
- Appears as legitimate manager function
- No on-chain validation prevents this
- Users only discover after attempting to claim profits

**Economic Rationality:**
- Zero cost to execute
- Direct profit theft with no risk
- Highly profitable even for small amounts

## Recommendation

Add a check in the `RemoveBeneficiary` function to prevent removal of beneficiaries who have locked tokens. The function should verify if the beneficiary has an active lock by checking `State.LockIds[Context.Sender][input.Beneficiary]` and reject the removal if a lock exists.

Alternatively, modify `RemoveBeneficiary` to automatically unlock tokens proportionally when shares are removed, similar to how `Withdraw` operates. This maintains the invariant that locked tokens always receive proportional profit shares.

A third option is to disable `CanRemoveBeneficiaryDirectly` for TokenHolder schemes, or add a separate flag to distinguish between manager-added and self-registered beneficiaries.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveBeneficiary_StealsFromLockedTokenHolder_Test()
{
    // Setup: Create scheme with 30-day lock period
    var lockMinutes = 43200; // 30 days
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = lockMinutes
    });
    
    // User locks 10,000 tokens and registers for profits
    var userAmount = 10000L;
    var userStub = GetTester<TokenHolderContractImplContainer.TokenHolderContractImplStub>(
        TokenHolderContractAddress, UserKeyPairs.First());
    await userStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = userAmount,
        SchemeManager = Starter
    });
    
    // Contribute profits
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 10000L
    });
    
    // Manager removes user's beneficiary status
    await TokenHolderContractStub.RemoveBeneficiary.SendAsync(
        new RemoveTokenHolderBeneficiaryInput
        {
            Beneficiary = UserAddresses.First(),
            Amount = 0 // Remove all shares
        });
    
    // Distribute profits
    await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeManager = Starter,
        AmountsMap = { { "ELF", 0L } }
    });
    
    // Verify: User cannot claim profits despite locked tokens
    var userProfitsMap = await userStub.GetProfitsMap.CallAsync(new ClaimProfitsInput
    {
        SchemeManager = Starter
    });
    userProfitsMap.Value["ELF"].ShouldBe(0); // User receives ZERO profits
    
    // Verify: User's tokens are still locked (cannot withdraw before lock period)
    var withdrawResult = await userStub.Withdraw.SendWithExceptionAsync(Starter);
    withdrawResult.TransactionResult.Error.ShouldContain("Cannot withdraw");
    
    // This proves the vulnerability: User has 0 profit shares but tokens remain locked
}
```

**Notes**

The vulnerability is confirmed by examining the complete execution flow across TokenHolder and Profit contracts. The core issue is that `RemoveBeneficiary` in TokenHolderContract.cs only removes profit shares without touching the lock state (`State.LockIds` and `State.LockTimestamp`), and without calling `State.TokenContract.Unlock`. This creates a state inconsistency where users have locked tokens but no corresponding profit entitlement, breaking the fundamental economic guarantee of the TokenHolder contract.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-25)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-84)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-167)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L168-176)
```csharp
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-236)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L351-356)
```csharp
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }
```
