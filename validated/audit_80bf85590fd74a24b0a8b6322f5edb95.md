# Audit Report

## Title
Consensus Behavior Validation Bypass Allows Indefinite Term Change Prevention

## Summary
The AEDPoS consensus validation system validates that block data is internally consistent with the claimed behavior (NextRound vs NextTerm) but never independently verifies that the claimed behavior matches what consensus rules require. A malicious miner can produce NextRound blocks when NextTerm is mandated, indefinitely preventing term transitions and freezing governance.

## Finding Description

The vulnerability exists in a critical gap between honest behavior determination and validation enforcement:

**Honest Behavior Determination:**
When honest nodes determine which behavior to use when terminating a round, the `MainChainConsensusBehaviourProvider` calls `NeedToChangeTerm()` to decide between NextRound and NextTerm. [1](#0-0) 

The `NeedToChangeTerm()` method checks if at least two-thirds (MinersCountOfConsent) of miners have mining times indicating the term period has elapsed. [2](#0-1) 

**Critical Validation Gap:**
The validation system reads the behavior from `extraData.Behaviour` (the CLAIMED behavior in the block header) and adds validators based solely on that claim, not on what the behavior SHOULD be according to consensus rules. [3](#0-2) 

The `RoundTerminateValidationProvider` validates internal consistency with the claimed behavior but never calls `NeedToChangeTerm()` to verify the behavior choice was correct. It only checks that round numbers increment properly and InValues are null. [4](#0-3) 

**Execution Without Correctness Check:**
The `ProcessConsensusInformation` method dispatches to either `ProcessNextRound` or `ProcessNextTerm` based solely on the input type without validating that the chosen behavior matches consensus requirements. [5](#0-4) 

**Insufficient Access Control:**
The `NextRound` method is public and callable by any miner. [6](#0-5)  The `PreCheck()` validation only confirms the sender is in the current or previous round miner list. [7](#0-6) 

**Attack Execution:**
A malicious miner can:
1. Construct a valid `NextRoundInput` with incremented round number but unchanged term number
2. Set all InValues to null (as required for NextRound)
3. Include this in a block with `extraData.Behaviour = NextRound` when `NeedToChangeTerm()` would return true
4. Validation passes because it only checks internal consistency (round number increments, InValues null)
5. `ProcessNextRound()` executes instead of `ProcessNextTerm()`

**Critical Operations Skipped:**
When `ProcessNextRound()` executes instead of `ProcessNextTerm()`, critical operations are bypassed. [8](#0-7) 

The term number is not updated, the miner list is not refreshed with election results, election snapshots preserving voting records are not taken, and treasury releases tied to term boundaries do not occur.

## Impact Explanation

**HIGH - Consensus Integrity Violation**

This vulnerability fundamentally breaks the AEDPoS democratic consensus mechanism:

1. **Election Results Never Applied**: New miners elected through governance cannot join the consensus, as the miner list update only occurs in `ProcessNextTerm`
2. **Governance Capture**: Current miners can maintain control indefinitely by preventing term changes, rendering the election system ineffective
3. **Reward Distribution Halted**: Mining rewards and treasury releases tied to term boundaries don't occur, breaking the economic incentive structure
4. **Historical Record Incomplete**: Election snapshots that preserve voting records are not taken, damaging protocol auditability
5. **Protocol Invariant Broken**: The consensus rule that terms MUST change when `NeedToChangeTerm()` returns true (when 2/3+ miners have mined past the term threshold) is violated

This affects all network participants and compromises the entire governance, election, and reward distribution system.

## Likelihood Explanation

**HIGH Likelihood**

**Reachable Attack Path:**
- The `NextRound` method is public and directly callable by any current miner
- Only requires passing `PreCheck()` which merely confirms sender is in the miner list
- No complex cryptographic operations or special permissions required beyond being a current miner

**Feasible Execution:**
- Attacker modifies their node software to generate `NextRound` blocks instead of `NextTerm` when term change is required
- The malicious behavior is indistinguishable from a valid NextRound transition to other validators
- Block validation passes because it only checks internal consistency with the claimed behavior

**Economic Rationality:**
- Incumbent miners have strong economic incentive to prevent replacement by new election winners
- Attack cost is negligible (just modify block generation logic)
- Continued mining revenue provides substantial benefit

**No Detection Mechanism:**
- Validation only checks data consistency with claimed behavior, not behavior correctness
- No monitoring exists to detect that term changes are being prevented when consensus rules require them
- The attack appears as normal consensus operation

## Recommendation

Add behavior correctness validation to `RoundTerminateValidationProvider` or `ValidateBeforeExecution`:

```csharp
// In RoundTerminateValidationProvider.ValidateHeaderInformation() or ValidateBeforeExecution()
// After line 16 in RoundTerminateValidationProvider.cs:

if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) 
{
    // Verify NextRound is correct choice
    var blockchainStartTimestamp = GetBlockchainStartTimestamp();
    if (validationContext.BaseRound.NeedToChangeTerm(
        blockchainStartTimestamp, 
        validationContext.CurrentTermNumber, 
        periodSeconds))
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = "NextTerm behavior required but NextRound claimed" 
        };
    }
    return ValidationForNextRound(validationContext);
}

if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) 
{
    // Verify NextTerm is correct choice
    var blockchainStartTimestamp = GetBlockchainStartTimestamp();
    if (!validationContext.BaseRound.NeedToChangeTerm(
        blockchainStartTimestamp, 
        validationContext.CurrentTermNumber, 
        periodSeconds))
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = "NextRound behavior required but NextTerm claimed" 
        };
    }
    return ValidationForNextTerm(validationContext);
}
```

This ensures the validation not only checks internal consistency but also verifies the behavior choice matches consensus requirements.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task MaliciousMiner_CanBypassTermChange_WhenNeedToChangeTermReturns True()
{
    // Setup: Initialize consensus with miners and advance until term change is required
    var miners = GenerateMiners(5);
    await InitializeConsensus(miners);
    
    // Advance time so that 2/3+ miners have mined past term threshold
    await AdvanceToTermChangeRequired();
    
    // Verify NeedToChangeTerm would return true
    var currentRound = await GetCurrentRound();
    var blockchainStartTime = await GetBlockchainStartTimestamp();
    var periodSeconds = await GetPeriodSeconds();
    Assert.True(currentRound.NeedToChangeTerm(blockchainStartTime, currentRound.TermNumber, periodSeconds));
    
    // Malicious miner constructs NextRound input when NextTerm is required
    var maliciousMiner = miners[0];
    var nextRoundInput = CreateNextRoundInput(currentRound); // Round+1, Term unchanged, InValues null
    
    // Execute NextRound instead of NextTerm
    await ExecuteAsTransactionWithMiner(maliciousMiner, () => ConsensusContract.NextRound(nextRoundInput));
    
    // Verify attack succeeded
    var newRound = await GetCurrentRound();
    Assert.Equal(currentRound.RoundNumber + 1, newRound.RoundNumber); // Round advanced
    Assert.Equal(currentRound.TermNumber, newRound.TermNumber); // Term did NOT change (vulnerability)
    
    // Verify critical operations were skipped
    var minerList = await GetMinerList(newRound.TermNumber);
    Assert.Equal(miners, minerList); // Miner list unchanged (should have been updated)
    
    var snapshot = await GetElectionSnapshot(currentRound.TermNumber);
    Assert.Null(snapshot); // Snapshot not taken (should have been taken)
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L35-53)
```csharp
        switch (input)
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
                break;
            case TinyBlockInput tinyBlockInput:
                randomNumber = tinyBlockInput.RandomNumber;
                ProcessTinyBlock(tinyBlockInput);
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
