# Audit Report

## Title
Authorization Bypass in TokenHolder ContributeProfits Enables Front-Running of Beneficiary Removal

## Summary
The `ContributeProfits()` function in TokenHolderContract lacks authorization checks, allowing any user to contribute tokens to any profit scheme and force premature distributions via auto-distribution thresholds. This enables malicious beneficiaries to front-run their removal by triggering distribution before the manager can remove them, locking in their share of accumulated profits.

## Finding Description

The vulnerability exists due to missing authorization validation in `ContributeProfits()`. The function only validates that the scheme exists but does not verify that the caller has permission to contribute to the scheme. [1](#0-0) 

This contrasts with `DistributeProfits()` which properly checks that the sender is either the scheme manager or the token contract system. [2](#0-1) 

The authorization bypass enables exploitation through the auto-distribution mechanism. When creating TokenHolder schemes, they are configured with `CanRemoveBeneficiaryDirectly = true`. [3](#0-2) 

The `RegisterForProfits()` function checks if the scheme's virtual address balance exceeds configured `AutoDistributeThreshold` values and automatically triggers distribution when thresholds are met. [4](#0-3) 

When a beneficiary is removed from a scheme with `CanRemoveBeneficiaryDirectly = true`, the Profit contract's `RemoveProfitDetails()` function sets their `EndPeriod` to `scheme.CurrentPeriod.Sub(1)`. [5](#0-4) 

This EndPeriod value allows the removed beneficiary to claim profits from the just-distributed period, since the profit claiming logic calculates claimable periods up to `Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod)`. [6](#0-5) 

**Attack Scenario:**
1. Scheme accumulates 10,000 ELF in virtual address
2. Bob is a beneficiary with 30% shares
3. Manager plans to remove Bob, then distribute to remaining beneficiaries
4. Bob detects removal intent and calls `ContributeProfits()` with 100 ELF to reach auto-distribution threshold
5. Bob or anyone calls `RegisterForProfits()`, triggering automatic distribution
6. Distribution occurs at period N, moving to period N+1
7. Bob receives 30% × 10,100 ELF = 3,030 ELF
8. Manager calls `RemoveBeneficiary(Bob)` during period N+1
9. Bob's `EndPeriod` is set to N (N+1-1), but Bob already claimed from period N
10. Net result: Bob gains ~2,930 ELF that should have been distributed to other beneficiaries

## Impact Explanation

This vulnerability has HIGH impact due to direct fund theft:

- **Fund Misallocation:** Malicious beneficiaries can extract their proportional share of accumulated profits that the scheme manager intended to distribute after their removal
- **Beneficiary Rights Violation:** Legitimate beneficiaries lose their rightful increased share that would result from the malicious beneficiary's removal
- **Manager Control Bypass:** Scheme managers lose the ability to control distribution timing relative to beneficiary changes, fundamentally breaking the intended governance model

The economic impact is quantifiable: In the example scenario, legitimate beneficiaries collectively lose 3,000 ELF (30% of 10,000 ELF accumulated) that should have been distributed only to them after Bob's removal.

## Likelihood Explanation

This vulnerability has MEDIUM-HIGH likelihood:

**Reachability:** `ContributeProfits()` is a public function with no caller restrictions. [7](#0-6) 

**Preconditions (All Realistic):**
- Attacker must be an existing beneficiary (common in profit schemes)
- Scheme must have `AutoDistributeThreshold` configured (typical for managed schemes)
- Accumulated profits must exceed contribution cost (makes attack profitable)
- Attacker needs tokens to contribute (readily available)

**Execution Simplicity:** Two function calls—`ContributeProfits()` followed by `RegisterForProfits()` or waiting for another participant to trigger registration.

**Economic Rationality:** Highly profitable when: (beneficiary's share % × accumulated profits) > contribution cost. Example: 20% share of 50,000 ELF = 10,000 ELF gain for ~1,000 ELF cost = 9,000 ELF profit.

**Detection Window:** Beneficiary removal scenarios are detectable through on-chain governance proposals, making the attack predictable and executable.

**Blockchain Characteristics:** The manager cannot front-run the attacker once the contribution transaction is broadcast, as transaction ordering is determined by block producers.

## Recommendation

Add authorization check to `ContributeProfits()` similar to `DistributeProfits()`:

```csharp
public override Empty ContributeProfits(ContributeProfitsInput input)
{
    var scheme = GetValidScheme(input.SchemeManager);
    
    // Add authorization check
    Assert(Context.Sender == input.SchemeManager || 
           Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName),
           "Only scheme manager or token contract can contribute profits.");
    
    // ... rest of implementation
}
```

Alternative mitigation: Remove auto-distribution feature or require scheme manager approval before distribution occurs, ensuring manager can coordinate beneficiary changes with distribution timing.

## Proof of Concept

The vulnerability is proven through code analysis showing:

1. **Missing Authorization:** `ContributeProfits()` only calls `GetValidScheme()` which validates scheme existence but not caller authority [8](#0-7) 

2. **Authorization Contrast:** Compare with protected functions like `DistributeProfits()` which explicitly validate `Context.Sender == input.SchemeManager` [9](#0-8) 

3. **Auto-Distribution Trigger:** Anyone can contribute tokens, and `RegisterForProfits()` automatically triggers distribution when thresholds are exceeded [10](#0-9) 

4. **Removal Timing:** The removal logic sets `EndPeriod = CurrentPeriod - 1`, allowing claims from the distributed period [11](#0-10) 

A test demonstrating this attack would:
- Create a TokenHolder scheme with auto-distribute threshold
- Add multiple beneficiaries including malicious actor
- Accumulate profits in the scheme
- Have malicious actor call `ContributeProfits()` to reach threshold
- Call `RegisterForProfits()` to trigger distribution
- Verify malicious actor received their share
- Attempt to remove malicious actor
- Verify removal is ineffective as profits already distributed

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L100-129)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.TokenContract.Approve.Send(new ApproveInput
        {
            Spender = State.ProfitContract.Value,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.ProfitContract.ContributeProfits.Send(new Profit.ContributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Symbol = input.Symbol,
            Amount = input.Amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L131-147)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager, true);
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
        var distributeProfitsInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L178-206)
```csharp
        // Check auto-distribute threshold.
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L340-360)
```csharp
        if (detailsCanBeRemoved.Any())
        {
            foreach (var profitDetail in detailsCanBeRemoved)
            {
                // set remove sign
                profitDetail.IsWeightRemoved = true;
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }

                removedDetails.TryAdd(scheme.CurrentPeriod, profitDetail.Shares);
            }

```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L845-862)
```csharp
    private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
        bool isView = false, string targetSymbol = null)
    {
        var profitsMap = new Dictionary<string, long>();
        var lastProfitPeriod = profitDetail.LastProfitPeriod;

        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
```
