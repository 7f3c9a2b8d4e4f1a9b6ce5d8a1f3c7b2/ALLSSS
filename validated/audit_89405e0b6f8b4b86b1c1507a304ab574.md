# Audit Report

## Title
Banned Miners Can Be Re-Selected Through GetVictories Backup Mechanism

## Summary
The `GetVictories()` function in the Election contract contains a critical vulnerability where its backup selection mechanism fails to verify banned status when selecting miners from `currentMiners` and `InitialMiners` lists. This allows miners that were explicitly marked as evil/banned to automatically rejoin consensus in the next term, completely bypassing the node banning security mechanism.

## Finding Description

The vulnerability exists in the private `GetVictories(List<string> currentMiners)` method's backup selection logic. When insufficient valid candidates exist (those with active votes), the backup mechanism activates to fill remaining miner slots.

**The Critical Flaw:**

The backup selection logic at lines 62-74 adds miners from `currentMiners` and `InitialMiners` without checking `State.BannedPubkeyMap`: [1](#0-0) 

The code collects backups from current miners and initial miners, then takes from this list without any banned status verification. The `GetValidCandidates()` helper only filters based on vote amount (> 0), not banned status: [2](#0-1) 

**How Miners Get Banned:**

When miners are detected as evil, `UpdateCandidateInformation` with `IsEvilNode=true` properly sets the banned flag and removes them from candidates: [3](#0-2) 

Similarly, when pubkeys are replaced, the old pubkey is banned: [4](#0-3) 

**Why Existing Protections Fail:**

The contract has a properly functioning `GetMinerReplacementInformation()` method that **DOES** check for banned miners during mid-term replacement: [5](#0-4) 

Note line 389 explicitly filters `.Where(k => !State.BannedPubkeyMap[k])` when selecting from initial miners. However, `GetVictories()` completely lacks this validation.

**Execution Path:**

The consensus contract calls `GetVictories()` during new term generation via `TryToGetVictories()`: [6](#0-5) 

This occurs in `GenerateFirstRoundOfNextTerm()`: [7](#0-6) 

## Impact Explanation

**Consensus Integrity Violation - Critical Severity:**

This vulnerability directly violates the miner schedule integrity invariant fundamental to AEDPoS consensus security:

1. **Evil Node Persistence**: Miners explicitly marked as evil through `UpdateCandidateInformation(IsEvilNode=true)` automatically rejoin consensus in the next term, completely defeating the network's security mechanism for removing malicious nodes.

2. **Unauthorized Block Rewards**: Banned miners continue earning mining rewards they are not entitled to receive, representing unauthorized extraction of value from the reward pool.

3. **Continued Malicious Behavior**: Whatever malicious behavior caused the ban (censoring transactions, excessive downtime, attempted double-signing) can continue uninterrupted after the term transition.

4. **Network-Wide Impact**: This affects the entire blockchain's security and liveness. All honest miners must operate alongside nodes that the system explicitly flagged for exclusion.

5. **Automatic Exploitation**: No manual intervention can prevent this - it triggers automatically during normal term transitions whenever preconditions are met.

The severity is **Critical** because it breaks a core consensus security guarantee: that the network can permanently exclude malicious actors from block production.

## Likelihood Explanation

**High Probability with Zero Attack Complexity:**

**Preconditions:**
1. The number of valid candidates (with active votes > 0) must be less than `State.MinersCount.Value`, triggering `diff > 0`
2. A banned miner must exist in `currentMiners` or `InitialMiners` lists
3. That miner was previously banned via `UpdateCandidateInformation(IsEvilNode=true)` or `ReplaceCandidatePubkey`

**Why This Is Highly Likely:**

1. **Bootstrap Phases**: During network launch or validator set expansion, having insufficient candidates with votes is extremely common
2. **Low Participation Chains**: Chains with limited election participation naturally have fewer valid candidates than required miner slots
3. **Validator Set Expansion**: When `MinersCount` increases, there's often a lag before enough candidates announce and receive votes

**Attack Complexity: Zero**

This is **not an exploit** requiring attacker action - it's an automatic system failure:
- The banned node takes no action
- No special transactions are needed
- It happens through normal consensus term transitions
- There's no distinguishable attack signature
- Defenders cannot prevent it without code changes

**Realistic Scenario:**

Network with 5 initial miners requiring 5 miners per term:
1. Only 3 candidates announce election and receive votes (validCandidates = 3)
2. One initial miner M1 gets banned for missing time slots during term N
3. At term N+1 start, `GetVictories()` calculates: diff = 5 - 3 = 2
4. Backup mechanism activates, adding from currentMiners and InitialMiners
5. M1 is included in backups **without banned status check**
6. M1 operates as a miner in term N+1 despite being marked as evil

## Recommendation

Add banned status verification to the backup selection logic in `GetVictories()`. Modify the code at lines 66-69 to filter out banned pubkeys, similar to how `GetMinerReplacementInformation()` correctly implements this check:

```csharp
// Valid candidates not enough.
if (diff > 0)
{
    victories =
        new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
    var backups = currentMiners
        .Where(k => !validCandidates.Contains(k))
        .Where(k => !State.BannedPubkeyMap[k])  // ADD THIS LINE
        .ToList();
    if (State.InitialMiners.Value != null)
        backups.AddRange(
            State.InitialMiners.Value.Value.Select(k => k.ToHex())
                .Where(k => !backups.Contains(k))
                .Where(k => !State.BannedPubkeyMap[k]));  // ADD THIS LINE

    victories.AddRange(backups.OrderBy(p => p)
        .Take(Math.Min(diff, currentMiners.Count))
        .Select(v => ByteStringHelper.FromHexString(v)));
    Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
    return victories;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task BannedMiner_ShouldNotBeReselected_InNextTerm()
{
    // Setup: Initialize election with 5 initial miners
    await InitializeElectionContract(5);
    
    // Ban one initial miner (miner at index 0)
    var bannedMinerPubkey = InitialMiners[0];
    await ElectionContractStub.UpdateCandidateInformation.SendAsync(
        new UpdateCandidateInformationInput
        {
            Pubkey = bannedMinerPubkey,
            IsEvilNode = true
        });
    
    // Verify miner is banned
    var isBanned = await ElectionContractStub.IsPubkeyBanned.CallAsync(
        new StringValue { Value = bannedMinerPubkey });
    Assert.True(isBanned);
    
    // Only 3 candidates announce and receive votes (less than required 5)
    for (int i = 1; i <= 3; i++)
    {
        await AnnounceElectionAndVote(InitialMiners[i], 100000);
    }
    
    // Get victories for next term - this should NOT include the banned miner
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    
    // VULNERABILITY: The banned miner IS included in victories list
    Assert.DoesNotContain(
        victories.Value,
        v => v.ToHex() == bannedMinerPubkey
    ); // This assertion FAILS, proving the vulnerability
}
```

## Notes

The vulnerability is confirmed by comparing `GetVictories()` backup logic with `GetMinerReplacementInformation()`, which correctly implements banned status checking. The fix is straightforward: add `.Where(k => !State.BannedPubkeyMap[k])` filters to both backup sources (currentMiners and InitialMiners) before adding them to the victories list.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L62-74)
```csharp
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L386-391)
```csharp
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L245-246)
```csharp
        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-233)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-282)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
```
