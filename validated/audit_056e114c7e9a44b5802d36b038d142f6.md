# Audit Report

## Title
Missing Period Expiration Validation Allows Premature Term Changes

## Summary
The AEDPoS consensus validation fails to verify that term changes meet the required period expiration and 2/3+1 miner consent conditions. A malicious miner can unilaterally force premature term changes by providing `NextTerm` behavior in trigger information, bypassing Byzantine fault tolerance guarantees and causing premature treasury releases and election snapshot manipulation.

## Finding Description

The AEDPoS consensus mechanism has a critical validation gap between command generation and validation phases.

**Command Generation Phase (Proper Checks):**

During command generation, `MainChainConsensusBehaviourProvider` correctly determines whether to return `NextRound` or `NextTerm` by calling `NeedToChangeTerm()`: [1](#0-0) 

The `NeedToChangeTerm()` method validates that at least 2/3+1 miners (`MinersCountOfConsent`) have mined in the new term period by checking period expiration: [2](#0-1) [3](#0-2) 

**Validation Phase (Critical Gap):**

However, during block validation, the system does NOT re-check these conditions. The validation for `NextTerm` behavior only adds `RoundTerminateValidationProvider`: [4](#0-3) 

This validator only verifies structural correctness without checking consensus conditions: [5](#0-4) 

**Attack Execution:**

A malicious miner controls their node software and can modify the behavior in `AElfConsensusTriggerInformation` to be `NextTerm` even when conditions aren't met. The trigger information is passed directly to `GetConsensusBlockExtraData`: [6](#0-5) 

The system processes `NextTerm` based on the provided behavior without re-validating consensus conditions: [7](#0-6) 

The `NextTerm` method then processes the premature term change: [8](#0-7) 

## Impact Explanation

This vulnerability has **CRITICAL** severity with multiple severe impacts:

1. **Consensus Integrity Violation**: The 2/3+1 Byzantine fault tolerance threshold is completely bypassed. A single miner can force term changes without proper consensus, fundamentally breaking the consensus safety guarantee.

2. **Premature Treasury Releases**: Term changes trigger treasury releases using the PREVIOUS term number before the period has properly completed: [9](#0-8) 

3. **Manipulated Election Snapshots**: Election snapshots are taken with incomplete miner performance data from the previous round, affecting future miner selection and voting power: [10](#0-9) 

4. **Reward Misallocation**: Mining rewards are calculated and donated based on incomplete round data.

5. **Governance Disruption**: Premature term changes cascade into election contract state, affecting voting power distribution and future consensus participation.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Capabilities**: Any active miner in the current round can execute this attack. The only requirement is being in the miner list, which is checked during the normal permission validation: [11](#0-10) 

**Attack Complexity**: LOW - The attacker modifies their node software to provide `Behaviour = NextTerm` in the trigger information when calling `GetConsensusExtraData`, then produces a block with term number incremented by 1.

**Preconditions**: 
- Attacker must be an active miner (normal operational requirement)
- No additional economic cost beyond normal block production
- No special privileges needed beyond being a miner

**Detection Difficulty**: The attack appears as a legitimate consensus state transition since all validation checks pass (structural correctness). Network nodes would accept the block as valid.

**Verification**: The grep search confirms `NeedToChangeTerm` is ONLY called in `MainChainConsensusBehaviourProvider` for command generation and NEVER during validation, making this vulnerability definitively exploitable.

## Recommendation

Add validation of the `NeedToChangeTerm()` conditions in `RoundTerminateValidationProvider.ValidationForNextTerm()`:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Is next term number correct?
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // ADD THIS: Verify term change conditions are met
    var blockchainStartTimestamp = GetBlockchainStartTimestamp();
    var periodSeconds = GetPeriodSeconds();
    if (!validationContext.BaseRound.NeedToChangeTerm(blockchainStartTimestamp, 
        validationContext.BaseRound.TermNumber, periodSeconds))
        return new ValidationResult { Message = "Term change conditions not met: period not expired or insufficient miner consent." };
    
    return new ValidationResult { Success = true };
}
```

This ensures that term changes can only occur when both the period has expired AND 2/3+1 miners have mined in the new term period, preserving the Byzantine fault tolerance guarantee.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Deploy AEDPoS contract with multiple miners
2. Advance to mid-term (before period expiration)
3. Have one malicious miner create trigger information with `Behaviour = NextTerm`
4. Call `GetConsensusExtraData` with this trigger information
5. Submit the resulting consensus transaction via `NextTerm`
6. Verify that:
   - The term change is accepted (validation passes)
   - Treasury release occurs prematurely
   - Election snapshot is taken with incomplete data
   - `NeedToChangeTerm()` would have returned false for the current state

This demonstrates that a single miner can force term changes without meeting the required consensus conditions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L239-243)
```csharp
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L13-18)
```csharp
    private BytesValue GetConsensusBlockExtraData(BytesValue input, bool isGeneratingTransactions = false)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);

        Assert(triggerInformation.Pubkey.Any(), "Invalid pubkey.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L45-47)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```
