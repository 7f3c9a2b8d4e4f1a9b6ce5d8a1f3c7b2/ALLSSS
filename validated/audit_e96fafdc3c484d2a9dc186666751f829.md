# Audit Report

## Title
Missing Miners Count Validation in NextTerm Allows Bypass of Maximum Miner Restrictions

## Summary
The `NextTerm` method accepts user-controlled input containing a miner list and directly sets it without validating that the number of miners respects the governance-controlled `MaximumMinersCount`. A malicious miner can exploit this by crafting a `NextTermInput` with an excessive number of miners, bypassing the restriction established through Parliament governance.

## Finding Description

The vulnerability exists in the consensus contract's term transition logic. The public `NextTerm` method processes input through `ProcessConsensusInformation`, which only validates that the **caller** is authorized (must be in current or previous miner list), but does not validate the **content** of the provided input. [1](#0-0) 

The `ProcessNextTerm` method converts the input to a Round object and directly uses all keys from `nextRound.RealTimeMinersInformation` to create the new miner list without any count validation: [2](#0-1) 

The `GetMinersCount` helper calculates what the count should be based on blockchain age and the configured maximum, but this calculated value is only used for reporting to the Election Contract via `UpdateMinersCountToElectionContract`, not for enforcing the limit: [3](#0-2) [4](#0-3) 

The validation framework for `NextTerm` behavior only checks round and term number correctness, not miner count or miner list validity: [5](#0-4) 

In contrast, the legitimate term transition flow retrieves the miner list from the Election Contract based on governance-approved election results: [6](#0-5) 

The governance control mechanism requires Parliament authorization to set `MaximumMinersCount`: [7](#0-6) 

## Impact Explanation

**Consensus Integrity Impact:**
This vulnerability allows an attacker to bypass the governance-controlled maximum miners count, a critical consensus parameter. An attacker could inflate the miner set to an arbitrary size (e.g., 1000 miners instead of the intended 17), breaking the fundamental invariant that the consensus miner schedule must respect governance decisions.

**Operational Impact:**
- **Performance Degradation**: An excessive number of miners would significantly degrade consensus performance and block production efficiency
- **DoS Conditions**: The computational overhead of managing hundreds or thousands of validators could cause denial-of-service conditions in consensus processing
- **Economic Disruption**: Mining reward calculations and distributions would be spread across an inflated miner set, diluting rewards and breaking economic incentive assumptions
- **Downstream Effects**: Election snapshot operations and treasury releases would process excessive miner data

**Governance Impact:**
This directly undermines the governance control mechanism. The Parliament organization sets `MaximumMinersCount` through formal proposal and approval processes to maintain optimal consensus parameters. This vulnerability allows a single malicious miner to unilaterally override that governance decision.

## Likelihood Explanation

**Attacker Prerequisites:**
The attacker must be a current or previous round miner to pass the `PreCheck` validation. This is a realistic precondition within the threat model:
- Any miner in the active consensus set can execute this attack
- Miners are not considered fully trusted roles (unlike genesis/organization controllers)
- Being in the previous round's miner list still grants access

**Attack Complexity:**
The attack is straightforward:
1. Construct a `NextTermInput` with correct round/term numbers but excessive `RealTimeMinersInformation` entries
2. Call the public `NextTerm` RPC method with this crafted input
3. The transaction passes all existing validations and updates the miner list

**Execution Practicality:**
- Direct call to a public method exposed via RPC: [8](#0-7) 
- No complex state manipulation required
- Single transaction execution
- No race conditions or precise timing dependencies

**Detection:**
The attack would be immediately visible on-chain as the miner list suddenly expands beyond the configured maximum. However, prevention is difficult since the transaction passes all existing validations.

## Recommendation

Add validation in `ProcessNextTerm` to enforce that the miner count in the input matches the governance-approved maximum:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // Add validation: Ensure miner count respects maximum
    var expectedMinersCount = GetMinersCount(nextRound);
    var actualMinersCount = nextRound.RealTimeMinersInformation.Count;
    Assert(actualMinersCount <= State.MaximumMinersCount.Value, 
        $"Miner count {actualMinersCount} exceeds maximum {State.MaximumMinersCount.Value}");
    
    // Optionally, validate the miner list matches Election Contract results
    if (State.IsMainChain.Value && TryToGetVictories(out var victories))
    {
        var expectedMiners = victories.Pubkeys.Select(p => p.ToHex()).OrderBy(k => k).ToList();
        var providedMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        Assert(expectedMiners.SequenceEqual(providedMiners), 
            "Provided miner list does not match Election Contract results");
    }
    
    // ... rest of existing logic
}
```

## Proof of Concept

```csharp
[Fact]
public async Task NextTerm_WithExcessiveMiners_ShouldBypassMaximumCount()
{
    // Setup: Initialize consensus with governance-approved maximum of 5 miners
    await SetMaximumMinersCount(5);
    
    // Become a valid miner
    var maliciousMinerKeyPair = SampleKeyPairs.First();
    await AddMinerToCurrentRound(maliciousMinerKeyPair);
    
    // Craft malicious NextTermInput with 100 miners (exceeds limit of 5)
    var maliciousInput = CreateNextTermInputWithExcessiveMiners(100);
    
    // Execute attack - should fail but currently succeeds
    var result = await ConsensusStub.NextTerm.SendAsync(maliciousInput);
    
    // Verify attack succeeded - miner list now has 100 miners
    var currentMiners = await GetCurrentMinerList();
    Assert.Equal(100, currentMiners.Count); // Vulnerability: This passes, should be rejected
    
    // Verify governance limit was bypassed
    var maxCount = await GetMaximumMinersCount();
    Assert.Equal(5, maxCount); // Limit is still 5 but actual count is 100
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** protobuf/aedpos_contract.proto (L37-39)
```text
    // Update consensus information, create a new term.
    rpc NextTerm (NextTermInput) returns (google.protobuf.Empty) {
    }
```
