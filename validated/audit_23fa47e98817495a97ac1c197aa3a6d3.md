# Audit Report

## Title
Unbounded Loop in GetAllProfitsMap() Enables DoS of Profit Query View Methods

## Summary
The `GetAllProfitsMap()` private method contains an unbounded loop that processes all profit details without an upper limit. A malicious scheme manager can repeatedly call `AddBeneficiary` to inflate any address's profit detail count to thousands of entries. When anyone queries profits for that address, the contract performs millions of state reads, causing timeout and operational denial-of-service.

## Finding Description

The vulnerability exists in the profit query mechanism where view methods fail to limit computational complexity before performing expensive calculations.

**Attack Setup:**

Any user can call `CreateScheme()` to become a scheme manager with no authorization required [1](#0-0) . As the scheme manager, the attacker can repeatedly call `AddBeneficiary()` targeting any victim address [2](#0-1) . Each call adds a new `ProfitDetail` to the beneficiary's details list with no limit on the total count [3](#0-2) .

When `input.EndPeriod == 0`, it is automatically set to `long.MaxValue` [4](#0-3) . The cleanup mechanism never removes these details because the condition requires `d.EndPeriod != long.MaxValue` [5](#0-4) , making the pollution permanent.

**DoS Trigger:**

When anyone calls view methods `GetProfitAmount()` [6](#0-5) , `GetAllProfitAmount()` [7](#0-6) , or `GetAllProfitsMap()` [8](#0-7) , they all invoke the private `GetAllProfitsMap()` method that contains the vulnerability.

**The Critical Flaw:**

The main loop iterates over ALL available details without any cap [9](#0-8) . For EVERY detail, the expensive `ProfitAllPeriods()` method is called to calculate total profits [10](#0-9) .

The existing `ProfitReceivingLimitForEachTime` constant (value 10) [11](#0-10)  is used to calculate `profitableDetailCount` [12](#0-11) , but this limit is only checked AFTER the expensive calculation at line 130 executes [13](#0-12) . The protection only prevents the second `ProfitAllPeriods()` call for claimable profits [14](#0-13) , NOT the first call for total profits.

The `ProfitAllPeriods()` method contains nested loops iterating through periods and performing state reads for each period and token symbol [15](#0-14) , resulting in millions of operations when details are inflated.

## Impact Explanation

**Severity: HIGH**

**Operational DoS:**
- When a victim has 10,000+ profit details (each potentially spanning hundreds of periods), querying profits results in millions of state reads (10,000 details × ~100 periods × multiple token symbols)
- View methods timeout or fail completely, disabling all profit query functionality
- Nodes processing these queries experience severe CPU and memory exhaustion

**Affected Parties:**
- **Primary victims**: Any address added as a beneficiary by malicious scheme managers loses the ability to query their profits
- **Secondary victims**: Applications and users attempting to query profit information experience failures
- **Node operators**: Experience resource exhaustion when processing malicious queries

**No Recovery Mechanism:**
- Details with `EndPeriod = long.MaxValue` are never automatically cleaned up
- DoS persists permanently until manual state intervention
- Victims have no way to remove malicious entries themselves

**Security Guarantee Broken:**
Users should always be able to query their profit amounts through view methods. This vulnerability completely breaks that guarantee for targeted addresses, which is a critical protocol-level failure.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Capabilities:**
- Any user can execute the attack without special permissions
- Only requires calling two public methods: `CreateScheme` followed by repeated `AddBeneficiary` calls
- Attack setup cost is minimal (transaction fees for creating scheme and adding beneficiaries)

**Attack Complexity:**
- Straightforward two-step attack: (1) Create scheme to become manager, (2) Call AddBeneficiary repeatedly targeting victim
- No sophisticated exploit logic required
- Can be fully automated with simple scripts
- No timing dependencies or race conditions

**Feasibility:**
- Works under normal blockchain operation
- No victim interaction required - attacker unilaterally chooses victims
- Attack succeeds regardless of profit distribution state
- All preconditions are trivially achievable

**Economic Rationality:**
- High impact-to-cost ratio makes griefing attacks economically attractive
- Permanent damage with minimal one-time investment
- No detection mechanisms exist to prevent detail accumulation

## Recommendation

Enforce the `ProfitReceivingLimitForEachTime` limit BEFORE entering the main calculation loop in `GetAllProfitsMap()`. The limit should cap the number of details processed for both total profit calculation and claimable profit calculation:

```csharp
private GetAllProfitsMapOutput GetAllProfitsMap(Hash schemeId, Address beneficiary, string symbol = null)
{
    // ... existing code ...
    
    var availableDetails = profitDetails.Details.Where(d =>
        d.LastProfitPeriod < scheme.CurrentPeriod && (d.LastProfitPeriod == 0
            ? d.EndPeriod >= d.StartPeriod
            : d.EndPeriod >= d.LastProfitPeriod)
    ).ToList();
    
    // Apply limit BEFORE processing
    var profitableDetailCount = Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, availableDetails.Count);
    availableDetails = availableDetails.Take(profitableDetailCount).ToList();
    
    var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
    
    // Now process only limited details
    for (var i = 0; i < availableDetails.Count; i++)
    {
        // ... rest of the logic ...
    }
}
```

Additionally, consider implementing a hard limit on the number of profit details per beneficiary per scheme to prevent accumulation.

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_GetAllProfitsMap_DoS_Test()
{
    // Attacker creates a scheme
    var attacker = Creators[0];
    var schemeId = await CreateSchemeAsync();
    
    // Attacker adds victim as beneficiary 1000 times (simulating attack)
    var victim = Address.FromPublicKey(CreatorKeyPair[1].PublicKey);
    for (var i = 0; i < 1000; i++)
    {
        await attacker.AddBeneficiary.SendAsync(new AddBeneficiaryInput
        {
            SchemeId = schemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = victim,
                Shares = 1
            },
            EndPeriod = 0 // Will become long.MaxValue
        });
    }
    
    // Distribute profits multiple times to create periods
    for (var period = 1; period <= 50; period++)
    {
        await attacker.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeId = schemeId,
            Amount = 1000,
            Symbol = "ELF"
        });
        
        await attacker.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeId = schemeId,
            Period = period,
            AmountsMap = { { "ELF", 1000 } }
        });
    }
    
    // Now querying victim's profits will cause DoS
    // With 1000 details × 50 periods = 50,000 iterations
    var result = await attacker.GetAllProfitsMap.CallAsync(new GetAllProfitsMapInput
    {
        SchemeId = schemeId,
        Beneficiary = victim
    });
    
    // This call will timeout or consume excessive resources
    // In production, this would cause node resource exhaustion
}
```

## Notes

This vulnerability demonstrates a critical design flaw where computational complexity protection (`ProfitReceivingLimitForEachTime`) is applied incorrectly. The limit protects the second calculation phase but not the first, more expensive phase. This asymmetric protection enables the DoS attack. The issue is exacerbated by the permanent nature of details with `EndPeriod = long.MaxValue`, which creates a persistent attack surface with no built-in cleanup mechanism.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L44-44)
```csharp
    public override Hash CreateScheme(CreateSchemeInput input)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L158-174)
```csharp
    public override Empty AddBeneficiary(AddBeneficiaryInput input)
    {
        AssertValidInput(input);
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;

        var schemeId = input.SchemeId;
        var scheme = State.SchemeInfos[schemeId];

        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-207)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L853-871)
```csharp
        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L62-64)
```csharp
    public override Int64Value GetProfitAmount(GetProfitAmountInput input)
    {
        var allProfitsMapResult = GetAllProfitsMap(input.SchemeId, input.Beneficiary, input.Symbol);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L72-74)
```csharp
    public override GetAllProfitAmountOutput GetAllProfitAmount(GetAllProfitAmountInput input)
    {
        var allProfitsMapResult = GetAllProfitsMap(input.SchemeId, input.Beneficiary, input.Symbol);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L98-100)
```csharp
    public override GetAllProfitsMapOutput GetAllProfitsMap(GetAllProfitsMapInput input)
    {
        return GetAllProfitsMap(input.SchemeId, input.Beneficiary);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L119-120)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, availableDetails.Count);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L125-125)
```csharp
        for (var i = 0; i < availableDetails.Count; i++)
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L130-130)
```csharp
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L132-132)
```csharp
            if(i >= profitableDetailCount) continue;
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L133-133)
```csharp
            var claimableProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount,true, symbol);
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-5)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
```
