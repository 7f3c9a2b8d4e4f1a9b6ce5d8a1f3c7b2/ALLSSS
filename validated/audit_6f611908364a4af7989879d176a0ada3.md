# Audit Report

## Title
Consensus Denial of Service via Malicious FinalOrderOfNextRound Values Due to Incorrect Distinct Validation

## Summary
The `NextRoundMiningOrderValidationProvider` contains a critical validation bug where it calls `.Distinct()` on `MinerInRound` objects instead of their `FinalOrderOfNextRound` values. This allows a malicious validator to inject duplicate `FinalOrderOfNextRound` values that pass validation but cause permanent consensus halt when the subsequent round attempts to use these corrupted mining order values.

## Finding Description

**Root Cause:**

The validation incorrectly applies `.Distinct()` to a collection of `MinerInRound` objects rather than to their `FinalOrderOfNextRound` values: [1](#0-0) 

Since `MinerInRound` is a protobuf-generated class where each miner instance is a distinct object by reference, the distinct count will always equal the number of miner objects regardless of whether their `FinalOrderOfNextRound` values contain duplicates. The validation should check: `providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0).Select(m => m.FinalOrderOfNextRound).Distinct().Count()`.

**Exploitation Path:**

1. **Attack Trigger:** During a round transition, a malicious validator crafts a `NextRoundInput` where `Order` and `ExpectedMiningTime` are correctly set for the current round, but `FinalOrderOfNextRound` values contain duplicates (e.g., all set to 1).

2. **Validation Bypass:** The flawed validation is added to the validation pipeline for NextRound behavior: [2](#0-1) 

The time slot validation only checks the current round's `Order` field via `BaseRound`, not the malicious `FinalOrderOfNextRound` values in the provided round: [3](#0-2) 

The round termination validator only checks that `InValue` is null, allowing malicious `FinalOrderOfNextRound` values through: [4](#0-3) 

3. **State Corruption:** The malicious round data is stored via the `NextRound` method: [5](#0-4) 

Which calls `ProcessConsensusInformation` that eventually stores the round: [6](#0-5) 

The round is persisted to state: [7](#0-6) 

4. **Consensus Corruption:** When generating the subsequent round, the system uses these duplicate `FinalOrderOfNextRound` values to assign identical `Order` values: [8](#0-7) 

Multiple miners receive identical `Order` values and consequently identical `ExpectedMiningTime` values (calculated as `currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order))`).

5. **Consensus Halt:** Any attempt to validate the corrupted subsequent round fails because the time slot check calculates a zero mining interval: [9](#0-8) 

When miners at indices 0 and 1 have identical `ExpectedMiningTime` due to duplicate orders, `baseMiningInterval` becomes 0, causing the validation to fail with "Mining interval must greater than 0."

## Impact Explanation

**Severity: HIGH**

This vulnerability enables a single malicious validator to permanently halt the entire blockchain consensus mechanism:

- **Complete Consensus Halt:** No new blocks can be produced after the corrupted round completes execution
- **Network-Wide Impact:** All validators are unable to progress to the next round due to systematic validation failures
- **No Automatic Recovery:** The system has no built-in mechanism to recover from this state; manual intervention or chain rollback would be required
- **Operational Paralysis:** All on-chain operations cease, affecting all network participants

The vulnerability violates the critical consensus invariant: "Correct round transitions and time-slot validation, miner schedule integrity."

## Likelihood Explanation

**Probability: HIGH**

The attack is highly feasible:

- **Low Attacker Requirements:** Only requires being an active validator in the current round (a realistic precondition)
- **Low Complexity:** Single `NextRound` transaction with crafted `FinalOrderOfNextRound` values
- **No Special Privileges:** Uses standard validator capabilities; no elevated permissions needed beyond validator set membership
- **Natural Execution Opportunity:** Occurs during the normal rotation when it's the attacker's turn to propose round transition
- **Low Cost:** Only transaction fees required; no economic barriers
- **Delayed Detection:** Malicious values appear valid during the current round; attack only manifests when generating the next round

## Recommendation

Fix the validation in `NextRoundMiningOrderValidationProvider` to check the distinct count of `FinalOrderOfNextRound` values rather than `MinerInRound` objects:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
```

Additionally, consider adding a validation check to ensure no duplicate `Order` values exist when a new round is generated, as an additional safeguard.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousNextRound_WithDuplicateFinalOrderOfNextRound_ShouldCauseConsensusHalt()
{
    // Setup: Initialize consensus with multiple validators
    var initialMiners = GenerateInitialMiners(5);
    await InitializeConsensus(initialMiners);
    
    // Step 1: Complete first round normally
    await ProduceNormalBlocks(initialMiners);
    
    // Step 2: Malicious validator crafts NextRoundInput with duplicate FinalOrderOfNextRound
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = 2,
        RealTimeMinersInformation = GenerateMaliciousMinersInfo(initialMiners, duplicateOrder: 1)
    };
    
    // Step 3: Submit malicious NextRound transaction - validation passes due to bug
    var result = await ConsensusContract.NextRound.SendAsync(maliciousNextRound);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 4: Attempt to generate next round - should fail with mining interval validation
    var nextRoundGeneration = await ConsensusContract.GenerateConsensusCommand.CallAsync(new BytesValue());
    
    // Verify: System cannot progress - consensus is halted
    nextRoundGeneration.ValidationFailureMessage.ShouldContain("Mining interval must greater than 0");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-50)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-47)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```
