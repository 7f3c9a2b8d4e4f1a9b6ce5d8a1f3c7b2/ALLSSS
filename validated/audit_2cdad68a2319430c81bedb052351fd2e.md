# Audit Report

## Title
Missing Pubkey Uniqueness Validation in RealTimeMinersInformation Allows Consensus DoS

## Summary
The AEDPoS consensus contract accepts external Round objects via `NextRound` without validating that `RealTimeMinersInformation` dictionary values have unique `Pubkey` fields. A malicious miner can submit a Round with duplicate Pubkey entries, causing immediate chain halt when subsequent miners attempt block generation through `ExtractInformationToUpdateConsensus`, which calls `ToDictionary` on non-unique keys and throws an `ArgumentException`.

## Finding Description

The protocol defines `RealTimeMinersInformation` as `map<string, MinerInRound>` where map keys are arbitrary strings and each `MinerInRound` contains a `pubkey` field. [1](#0-0) [2](#0-1)  By convention, map keys should equal their corresponding `MinerInRound.Pubkey` values, but this invariant is not enforced.

When accepting external Round objects via the public `NextRound` method [3](#0-2) , the validation only checks:
- Round number increments by 1 [4](#0-3) 
- All InValues are null [5](#0-4) 
- FinalOrderOfNextRound distinct count validation [6](#0-5) 

**Critical Failure Point:**

When miners generate consensus transactions for `UpdateValue` behavior, the system calls `ExtractInformationToUpdateConsensus` [7](#0-6) , which creates three dictionaries using `RealTimeMinersInformation.Values.Where(...).ToDictionary(m => m.Pubkey, ...)`: [8](#0-7) [9](#0-8) [10](#0-9) 

If duplicate Pubkey values exist in the collection, `ToDictionary` throws an `ArgumentException` per standard .NET behavior, preventing the generation of consensus transactions required for block production.

**Secondary Issue:**

The `GetSortedImpliedIrreversibleBlockHeights` function filters miners by `specificPublicKeys.Contains(i.Pubkey)` [11](#0-10) . If duplicate Pubkeys exist, multiple entries match the filter, inflating the heights list used in LIB calculations [12](#0-11) .

## Impact Explanation

**Primary Impact - Consensus DoS:**

Once a malicious Round with duplicate Pubkeys is stored via `AddRoundInformation` [13](#0-12) [14](#0-13) , all subsequent miners attempting to produce blocks with `UpdateValue` behavior will fail when their consensus module calls `ExtractInformationToUpdateConsensus`. The thrown `ArgumentException` prevents block generation, resulting in complete chain halt affecting all network participants.

**Secondary Impact - LIB Manipulation:**

Before the DoS manifests, the duplicate entries can cause double-counting in the LIB calculation. This could advance the Last Irreversible Block height prematurely, violating the 2/3+ consensus assumption and potentially affecting cross-chain operations dependent on accurate LIB finality.

**Severity:** High - A single malicious or buggy miner can halt the entire blockchain with one transaction.

## Likelihood Explanation

**Attacker Capabilities:**

The attacker must be a current miner, which is validated by `PreCheck()` [15](#0-14) . The attacker needs access to produce blocks at the appropriate time to submit `NextRound`.

**Attack Complexity:**

Low - The attacker crafts a `NextRoundInput` where `RealTimeMinersInformation` contains entries with duplicate `Pubkey` values (e.g., two different map keys pointing to MinerInRound objects with the same Pubkey). The public `NextRound` method [16](#0-15)  accepts this input, and the malformed Round passes all existing validation checks [17](#0-16)  and is persisted to state.

**Feasibility:**

Blockchain consensus typically assumes up to 1/3 Byzantine miners. This vulnerability requires only ONE malicious or buggy miner, well within standard threat models. Additionally, this could occur accidentally through buggy client software, making it both a malicious attack vector and an operational risk.

**Detection:**

The attack is detected immediately when the next block production fails, but by then the malformed state is persisted, requiring manual intervention or rollback to restore chain operation.

## Recommendation

Add validation in `RoundTerminateValidationProvider` to ensure:
1. All Pubkey values in `RealTimeMinersInformation.Values` are unique
2. Map keys match their corresponding `MinerInRound.Pubkey` values

Recommended fix in `RoundTerminateValidationProvider.ValidationForNextRound`:

```csharp
// After existing round number and InValue checks, add:
var pubkeys = extraData.Round.RealTimeMinersInformation.Values.Select(m => m.Pubkey).ToList();
if (pubkeys.Count != pubkeys.Distinct().Count())
    return new ValidationResult { Message = "Duplicate Pubkey values detected in RealTimeMinersInformation." };

foreach (var kvp in extraData.Round.RealTimeMinersInformation)
{
    if (kvp.Key != kvp.Value.Pubkey)
        return new ValidationResult { Message = "Map key does not match MinerInRound.Pubkey field." };
}
```

## Proof of Concept

```csharp
[Fact]
public async Task DuplicatePubkeyInNextRound_CausesDoS()
{
    // Setup: Initialize consensus with valid miners
    var initialMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensus(initialMiners);
    
    // Attack: Craft NextRoundInput with duplicate Pubkeys
    var maliciousRound = new NextRoundInput
    {
        RoundNumber = 2,
        TermNumber = 1,
        RealTimeMinersInformation =
        {
            ["key1"] = new MinerInRound { Pubkey = "miner1", Order = 1 },
            ["key2"] = new MinerInRound { Pubkey = "miner2", Order = 2 },
            ["duplicate"] = new MinerInRound { Pubkey = "miner1", Order = 3 } // DUPLICATE!
        }
    };
    
    // Submit malicious NextRound (will pass validation and be stored)
    var result = await ConsensusStub.NextRound.SendAsync(maliciousRound);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Attempt to generate UpdateValue transaction for next block
    // This will throw ArgumentException in ExtractInformationToUpdateConsensus
    var exception = await Assert.ThrowsAsync<Exception>(() => 
        ConsensusStub.GenerateConsensusTransactions.CallAsync(triggerInfo));
    
    exception.Message.ShouldContain("An item with the same key has already been added");
}
```

## Notes

This vulnerability demonstrates a critical gap in input validation where the protocol assumes well-formed inputs from trusted miners but fails to enforce invariants on externally-provided data structures. The attack surface is particularly concerning because it can manifest as either deliberate malice or accidental bugs in client implementations, and requires only a single compromised/buggy miner to execute.

The fix should be implemented at the validation layer before state persistence to prevent malformed Rounds from entering the system. Additional defensive checks in `ExtractInformationToUpdateConsensus` could provide defense-in-depth but should not replace proper input validation.

### Citations

**File:** protobuf/aedpos_contract.proto (L34-34)
```text
    rpc NextRound (NextRoundInput) returns (google.protobuf.Empty) {
```

**File:** protobuf/aedpos_contract.proto (L247-247)
```text
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** protobuf/aedpos_contract.proto (L284-284)
```text
    string pubkey = 9;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-30)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L32-34)
```csharp
        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-20)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L144-146)
```csharp
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L26-28)
```csharp
        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L14-16)
```csharp
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
