# Audit Report

## Title
Authorization Bypass in Contract Update Proposals for Genesis-Authored Contracts

## Summary
The `AssertAuthorityByContractInfo` method contains a logic error that allows any address to create update proposals for contracts authored by Genesis. The condition checks whether the contract's author IS Genesis (`contractInfo.Author == Context.Self`) instead of whether the CALLER is Genesis, causing the authorization check to always pass for Genesis-authored contracts.

## Finding Description

The vulnerability exists in the authorization logic for contract update proposals. When `ProposeUpdateContract` is invoked, it validates authority via `AssertAuthorityByContractInfo`: [1](#0-0) 

The authorization method implements flawed conditional logic: [2](#0-1) 

**Root Cause:**

The condition `contractInfo.Author == Context.Self` evaluates whether the stored contract author equals the Genesis address, not whether the caller has authority. When executing within Genesis contract context, `Context.Self` always equals the Genesis contract address.

For contracts deployed by non-whitelisted proposers, the author assignment logic returns Genesis as the author: [3](#0-2) 

This causes the authorization check to evaluate as:
- `Genesis == Genesis || Caller == Genesis` → `TRUE || ...` → Always passes

Test evidence shows the expected behavior on sidechains, where unauthorized users receive "No permission" errors: [4](#0-3) 

Meanwhile, mainchain tests confirm contracts are deployed with Genesis as author: [5](#0-4) 

## Impact Explanation

This vulnerability breaks the authorization invariant that only contract authors should propose updates. All contracts deployed by non-whitelisted proposers on mainchain have Genesis as their author and are vulnerable to unauthorized proposal creation.

**Impact is LIMITED to proposal creation spam:**
- Attackers can flood governance with malicious proposals at transaction cost only
- Legitimate governance participants must review and reject spam proposals
- Actual contract updates still require full Parliament approval and code check processes

The vulnerability does NOT allow:
- Direct unauthorized contract updates
- Fund theft or supply manipulation  
- Bypassing governance approval requirements

## Likelihood Explanation

The vulnerability is **highly likely to be exploited**:

**Public Attack Surface:** `ProposeUpdateContract` is publicly accessible with no rate limiting: [6](#0-5) 

**Low Complexity Attack:**
1. Identify Genesis-authored contract addresses via block explorer
2. Craft arbitrary update proposal with malicious code
3. Call `ProposeUpdateContract` - authorization automatically passes
4. Repeat to spam governance system

**Minimal Cost:** Only standard transaction fees required, no special permissions or token holdings needed.

## Recommendation

Correct the authorization logic to check whether the CALLER has authority, not whether the contract's author IS Genesis:

```csharp
private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
{
    Assert(address == Context.Self || address == contractInfo.Author, "No permission.");
}
```

This validates that the caller (`address` parameter, which is `Context.Sender`) is either Genesis itself OR the contract's stored author.

## Proof of Concept

```csharp
[Fact]
public async Task ProposeUpdateContract_UnauthorizedUser_GenesisAuthoredContract_Test()
{
    // Deploy a contract as a whitelisted user (gets Genesis as author on mainchain)
    var contractDeploymentInput = new ContractDeploymentInput
    {
        Category = KernelConstants.DefaultRunnerCategory,
        Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
    };
    
    var deployedAddress = await DeployAsync(Tester, ParliamentAddress, BasicContractZeroAddress, contractDeploymentInput);
    
    // Verify contract has Genesis as author
    var contractInfo = ContractInfo.Parser.ParseFrom(await Tester.CallContractMethodAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractInfo), 
        deployedAddress));
    contractInfo.Author.ShouldBe(BasicContractZeroAddress); // Genesis is the author
    
    // Attempt to propose update from UNAUTHORIZED user (different from deployer)
    var unauthorizedTester = Tester.CreateNewContractTester(AnotherUserKeyPair);
    var contractUpdateInput = new ContractUpdateInput
    {
        Address = deployedAddress,
        Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TestContract.BasicFunction")).Value)
    };
    
    // This SHOULD fail with "No permission" but currently SUCCEEDS
    var proposingTxResult = await unauthorizedTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeUpdateContract), 
        contractUpdateInput);
    
    // VULNERABILITY: Unauthorized user can create proposals for Genesis-authored contracts
    proposingTxResult.Status.ShouldBe(TransactionResultStatus.Mined); // Currently passes
    // proposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed); // Expected behavior
    // proposingTxResult.Error.ShouldContain("No permission."); // Expected error
}
```

**Notes:**
- The vulnerability is valid and exploitable but impact is limited to governance spam
- Authorization invariant is violated: non-authors can create proposals  
- Actual contract updates still require full governance approval processes
- The fix is straightforward: validate the caller's identity, not the author's identity

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-175)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L183-183)
```csharp
        AssertAuthorityByContractInfo(info, Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L248-260)
```csharp
        var creator = ContractDeployed.Parser.ParseFrom(deploymentResult.Logs[1].Indexed[0]).Author;
        creator.ShouldBe(BasicContractZeroAddress);
        var deployAddress = ContractDeployed.Parser.ParseFrom(deploymentResult.Logs[1].NonIndexed).Address;
        deployAddress.ShouldNotBeNull();

        var contractVersion = ContractDeployed.Parser.ParseFrom(deploymentResult.Logs[1].NonIndexed).Version;
        contractVersion.ShouldBe(1);
        var contractInfo = ContractInfo.Parser.ParseFrom(await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractInfo), deployAddress));
        contractInfo.Version.ShouldBe(1);
        contractInfo.Author.ShouldBe(BasicContractZeroAddress);
        contractInfo.IsUserContract.ShouldBeFalse();
        contractInfo.ContractVersion.ShouldBe("1.0.0.0");
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L1175-1187)
```csharp
        {
            var noPermissionProposingTx = await SideChainTester.GenerateTransactionAsync(SideBasicContractZeroAddress,
                nameof(BasicContractZero.ProposeUpdateContract), AnotherMinerKeyPair, new ContractUpdateInput
                {
                    Address = deployAddress,
                    Code = ByteString.Empty
                });
            var blockReturnSet = await SideChainTester.MineAsync(new List<Transaction> { noPermissionProposingTx });
            var noPermissionProposingTxResult =
                blockReturnSet.TransactionResultMap[noPermissionProposingTx.GetHash()];
            noPermissionProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
            noPermissionProposingTxResult.Error.ShouldContain("No permission.");
        }
```
