# Audit Report

## Title
Unauthorized ExtraBlockProducer Assignment Allows Any Miner to Gain Privileged Mining Rights

## Summary
The `GenerateFirstRoundOfNextTerm()` function unconditionally assigns the sender's public key to `ExtraBlockProducerOfPreviousRound` without validating that the sender was the legitimate extra block producer of the current round. This allows any miner to produce the NextTerm block during term transitions and gain unauthorized mining privileges, disrupting consensus fairness.

## Finding Description

The AEDPoS consensus mechanism fails to enforce that only the designated extra block producer can execute the NextTerm transaction when transitioning between terms. This occurs due to multiple validation gaps:

**Root Cause:** The `GenerateFirstRoundOfNextTerm()` method unconditionally assigns the sender as the previous round's extra block producer without verification. [1](#0-0) 

**Missing Authorization Checks:**

1. **PreCheck Insufficient:** The `PreCheck()` method only verifies miner list membership (current or previous round), not the extra block producer role, and explicitly allows "failed miners performing NextTerm". [2](#0-1) 

2. **MiningPermissionValidationProvider Inadequate:** Only checks if sender is in the base round's miner list, not their role. [3](#0-2) 

3. **RoundTerminateValidationProvider Missing Check:** For NextTerm, only validates that term and round numbers increment by 1, not producer authorization. [4](#0-3) 

4. **Validation Provider Registration:** NextTerm behavior only registers `RoundTerminateValidationProvider`, lacking any extra block producer role validation. [5](#0-4) 

**Exploit Path:** Any miner receives NextTerm behavior when term change conditions are met, which is time-based rather than role-based. [6](#0-5) 

The term change determination uses `NeedToChangeTerm()` which checks if 2/3 of miners' latest mining times indicate the term period has elapsed, not who should produce the term-ending block. [7](#0-6) 

**Security Impact:** The `ExtraBlockProducerOfPreviousRound` field grants special mining privileges at the start of the next round, allowing mining before the round start time. [8](#0-7) 

It also permits producing additional tiny blocks beyond normal limits. [9](#0-8) 

**Intended Design:** Each round has exactly one designated extra block producer calculated using the first miner's signature for fair rotation. [10](#0-9) 

The extra block time slot is specifically reserved after all regular miners' slots. [11](#0-10) 

## Impact Explanation

**Consensus Integrity Violation:** An attacker who successfully produces the NextTerm block gains unauthorized mining privileges at the start of the new term. This allows them to produce additional blocks during time slots reserved for the legitimate extra block producer, disrupting the fair block production schedule and consensus fairness.

**Reward Misallocation:** The attacker receives more block production opportunities and consequently more mining rewards than deserved, while the legitimate extra block producer loses their earned privilege. This creates economic imbalance in the consensus system.

**Fairness Violation:** The extra block producer role is carefully calculated based on cryptographic randomness (first miner's signature) to ensure fair rotation among miners. This vulnerability allows any miner to bypass this fairness mechanism by racing to produce the NextTerm block first, undermining the deterministic and fair nature of the AEDPoS consensus algorithm.

## Likelihood Explanation

**High Probability:** When term change conditions are met (approximately every 7 days based on `PeriodSeconds` configuration), multiple miners simultaneously receive NextTerm behavior since the check is purely time-based. The consensus mechanism provides no protection against multiple miners attempting to produce the NextTerm block concurrently, creating a guaranteed race condition at every term transition.

**Low Attack Complexity:** An attacker only needs to:
1. Be a legitimate miner in the current or previous term
2. Monitor when `NeedToChangeTerm()` returns true (publicly observable)
3. Race to produce the NextTerm block before the designated extra block producer
4. Leverage network latency and block propagation timing to win the race

**Repeatable Attack:** This vulnerability can be exploited at every term transition, providing persistent opportunities for privilege escalation throughout the blockchain's lifetime.

## Recommendation

Add validation in `ValidateBeforeExecution()` to verify that the sender of a NextTerm transaction is the designated extra block producer of the current round. Specifically:

1. Create a new validation provider `ExtraBlockProducerValidationProvider` that checks:
   - For NextTerm behavior, verify `validationContext.SenderPubkey == validationContext.BaseRound.GetExtraBlockProducerInformation().Pubkey`

2. Register this provider in `ValidateBeforeExecution()` for NextTerm behavior:
```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new ExtraBlockProducerValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

This ensures only the miner designated as the extra block producer (with `IsExtraBlockProducer = true`) can successfully execute NextTerm transactions, preventing unauthorized privilege escalation.

## Proof of Concept

The vulnerability can be demonstrated by showing that when `NeedToChangeTerm()` returns true:
1. Any miner in the current/previous round can call `NextTerm` method
2. Validation passes without checking if sender is the designated extra block producer
3. Sender's pubkey gets assigned to `ExtraBlockProducerOfPreviousRound`
4. Sender gains mining privileges for time slots before round start

A test would create a scenario where:
- Term change conditions are met
- A non-extra-block-producer miner executes NextTerm 
- Verify the transaction succeeds and grants unauthorized privileges
- Verify the legitimate extra block producer lost their privilege

## Notes

This vulnerability exists because the validation layer treats NextTerm similarly to NextRound, only checking structural correctness of the new round data without verifying role-based authorization. The time-based term change mechanism combined with absent authorization checks creates a systemic race condition at every term boundary. The `EnsureTransactionOnlyExecutedOnceInOneBlock()` mechanism prevents multiple consensus transactions per block but does not prevent the wrong miner from winning the race to execute NextTerm.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L254-254)
```csharp
        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L30-35)
```csharp
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```
