# Audit Report

## Title
Banned Miners Can Be Re-Selected Through GetVictories Backup Mechanism

## Summary
The `GetVictories()` function in the Election contract contains a critical vulnerability where its backup selection mechanism fails to verify banned status when selecting miners from `currentMiners` and `InitialMiners` lists. This allows miners explicitly marked as evil/banned to automatically rejoin consensus in the next term, completely bypassing the node banning security mechanism.

## Finding Description

The vulnerability exists in the Election contract's `GetVictories()` method. When the number of valid candidates with active votes is insufficient to fill the required miner count, a backup selection mechanism activates that selects additional miners from `currentMiners` and `InitialMiners` lists.

**The Critical Flaw:**

The backup selection logic collects miners without checking `State.BannedPubkeyMap`: [1](#0-0) 

This code:
1. Identifies the shortfall (`diff`) when valid candidates are insufficient
2. Collects current miners not in valid candidates as backups
3. Adds initial miners to the backup pool
4. Selects from these backups **without any banned status verification**

The helper method `GetValidCandidates()` only filters based on vote amount, not banned status: [2](#0-1) 

**How Miners Get Banned:**

When miners are detected as evil, the consensus contract calls `UpdateCandidateInformation` with `IsEvilNode=true`, which properly sets the banned flag: [3](#0-2) 

Similarly, when pubkeys are replaced, the old pubkey is banned: [4](#0-3) 

**Proof of Inconsistency:**

The contract has a properly functioning `GetMinerReplacementInformation()` method that **DOES** check for banned miners during mid-term replacement: [5](#0-4) 

Line 389 explicitly filters: `.Where(k => !State.BannedPubkeyMap[k])` when selecting from initial miners. However, `GetVictories()` completely lacks this validation.

**Execution Path:**

The consensus contract calls `GetVictories()` during new term generation in `GenerateFirstRoundOfNextTerm`: [6](#0-5) 

Specifically, `TryToGetVictories` queries the Election contract: [7](#0-6) 

**Why Validation Doesn't Prevent This:**

The mining permission validation only checks if a pubkey exists in the miner list, not whether it's banned: [8](#0-7) 

Once a banned miner is included in the victory list through the backup mechanism, they pass this validation because they are indeed in `RealTimeMinersInformation`.

## Impact Explanation

**Consensus Integrity Violation - Critical Severity:**

This vulnerability directly violates the core security invariant that the network can permanently exclude malicious actors from block production:

1. **Evil Node Persistence**: Miners explicitly marked as evil through `UpdateCandidateInformation(IsEvilNode=true)` can automatically rejoin consensus in the next term, completely defeating the network's security mechanism.

2. **Unauthorized Block Rewards**: Banned miners continue earning mining rewards they are not entitled to receive, representing unauthorized value extraction from the reward pool.

3. **Continued Malicious Behavior**: Whatever behavior caused the ban (e.g., censoring transactions, excessive downtime, malicious validation) continues uninterrupted after the term transition.

4. **Network-Wide Impact**: All honest miners must operate alongside nodes that the system explicitly flagged for exclusion. All users' transactions are subject to processing by banned malicious nodes.

5. **Automatic Exploitation**: No manual intervention can prevent this vulnerability - it triggers automatically during normal term transitions whenever the preconditions are met.

The severity is **Critical** because it breaks a fundamental consensus security guarantee.

## Likelihood Explanation

**High Probability with Zero Attack Complexity:**

**Preconditions:**
1. Valid candidates with active votes < `State.MinersCount.Value` (triggers backup mechanism)
2. A banned miner exists in `currentMiners` or `InitialMiners` lists
3. That miner was previously banned via `UpdateCandidateInformation(IsEvilNode=true)` or `ReplaceCandidatePubkey`

**Why This Is Highly Likely:**

1. **Bootstrap Phases**: During network launch or validator set expansion, having insufficient candidates with votes is common
2. **Low Participation Networks**: Chains with limited election participation naturally have fewer valid candidates than required miner slots
3. **Validator Set Expansion**: When `MinersCount` increases, there's often a lag before enough candidates receive votes

**Attack Complexity: Zero**

This is an automatic system failure requiring no attacker action:
- The banned node performs no special actions
- No exploit transactions are needed
- Happens through normal consensus term transitions
- No distinguishable attack signature
- Defenders cannot prevent it without code changes

**Realistic Scenario:**

Network with 5 required miners:
1. Only 3 candidates receive votes (`validCandidates = 3`)
2. Initial miner M1 gets banned for malicious behavior during term N
3. At term N+1 start: `diff = 5 - 3 = 2`
4. Backup mechanism activates, selecting from `currentMiners` and `InitialMiners`
5. M1 included in backups **without banned check**
6. M1 operates as miner in term N+1 despite being banned

This scenario is realistic during early network phases or periods of low validator participation.

## Recommendation

Add banned status verification to the backup selection logic in `GetVictories()`. The fix should mirror the logic used in `GetMinerReplacementInformation()`:

```csharp
private List<ByteString> GetVictories(List<string> currentMiners)
{
    var validCandidates = GetValidCandidates();
    List<ByteString> victories;
    var diff = State.MinersCount.Value - validCandidates.Count;
    
    if (diff > 0)
    {
        victories = new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
        
        // Filter out banned miners from backups
        var backups = currentMiners
            .Where(k => !validCandidates.Contains(k))
            .Where(k => !State.BannedPubkeyMap[k])  // ADD THIS CHECK
            .ToList();
            
        if (State.InitialMiners.Value != null)
            backups.AddRange(
                State.InitialMiners.Value.Value
                    .Select(k => k.ToHex())
                    .Where(k => !backups.Contains(k))
                    .Where(k => !State.BannedPubkeyMap[k]));  // ADD THIS CHECK
        
        victories.AddRange(backups.OrderBy(p => p)
            .Take(Math.Min(diff, currentMiners.Count))
            .Select(v => ByteStringHelper.FromHexString(v)));
        
        return victories;
    }
    
    // ... rest of method
}
```

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

```csharp
// Test Setup:
// 1. Initialize Election contract with 5 initial miners (MinersCount = 5)
// 2. Only 3 candidates announce and receive votes (validCandidates = 3)
// 3. Ban one of the initial miners via UpdateCandidateInformation(IsEvilNode=true)
//    This sets State.BannedPubkeyMap[bannedMiner] = true

// Test Execution:
// 4. Trigger term transition by calling consensus contract's NextTerm
//    This internally calls GenerateFirstRoundOfNextTerm
//    Which calls Election.GetVictories()

// Expected Behavior (with vulnerability):
// 5. GetVictories() calculates: diff = 5 - 3 = 2
// 6. Backup mechanism activates
// 7. Banned miner is selected from InitialMiners without BannedPubkeyMap check
// 8. Banned miner appears in the new term's miner list
// 9. Banned miner can successfully mine blocks and earn rewards

// Verification:
// Assert that the banned miner's pubkey is present in the returned victories list
// Assert that the new round's RealTimeMinersInformation contains the banned miner
// Assert that the banned miner can successfully call UpdateValue/mine blocks
```

The test confirms that banned miners automatically rejoin consensus when valid candidates are insufficient, bypassing the banning mechanism entirely.

---

## Notes

This vulnerability represents an inconsistency in the codebase where `GetMinerReplacementInformation()` correctly implements banned status checking but `GetVictories()` does not. This strongly indicates the missing check is a bug rather than intentional design. The fix is straightforward: apply the same `.Where(k => !State.BannedPubkeyMap[k])` filter used in the replacement logic to the backup selection logic in `GetVictories()`.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L62-77)
```csharp
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L382-392)
```csharp
        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L245-246)
```csharp
        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
