# Audit Report

## Title
Inconsistent Vote Counting Allows Governance Bypass Through Member Removal

## Summary
The Association contract's vote threshold checking logic contains a critical inconsistency where individual vote type counts (approvals, rejections, abstentions) are filtered by current organization membership, but the total vote count for `MinimalVoteThreshold` validation includes all votes regardless of membership status. This allows organizations to bypass rejection and abstention thresholds by removing dissenting members after they have voted.

## Finding Description

The vulnerability exists in the vote counting implementation within the `CheckEnoughVoteAndApprovals` helper function and related validation methods.

**Rejection Count - Filtered by Current Membership:** [1](#0-0) 

**Abstention Count - Filtered by Current Membership:** [2](#0-1) 

**Approval Count - Filtered by Current Membership:** [3](#0-2) 

**Total Vote Count - NOT Filtered:** [4](#0-3) 

The total vote count simply concatenates and counts all addresses from the three vote lists without filtering by current membership. This creates an exploitable inconsistency.

**Attack Vector Enabled by RemoveMember:** [5](#0-4) 

The `RemoveMember` function can only be called by the organization itself (requires `Context.Sender` to be the organization address), meaning it must be executed through an approved proposal. Once members are removed, their votes on existing proposals are handled inconsistently:
- Their rejections/abstentions are excluded from threshold checks (filtered out)
- Their votes still count toward the `MinimalVoteThreshold` (not filtered)

**Attack Sequence:**
1. Organization with 10 members, thresholds: MinimalApprovalThreshold=5, MinimalVoteThreshold=8, MaximalRejectionThreshold=2
2. Malicious proposal P1 receives: 5 approvals, 4 rejections (total: 9 votes)
3. P1 cannot be released because rejectionCount (4) > MaximalRejectionThreshold (2)
4. Majority creates and passes proposal P2 to remove the 4 rejecting members
5. After removal, P1's status changes:
   - Approvals (filtered): 5 (still members) ≥ 5 ✓
   - Rejections (filtered): 0 (removed members don't count) ≤ 2 ✓
   - Total votes (unfiltered): 9 (all votes still count) ≥ 8 ✓
6. P1 can now be released despite originally being rejected

## Impact Explanation

This vulnerability enables **governance capture** through threshold manipulation. The Association contract's safety mechanism relies on rejection and abstention thresholds to protect minority interests and prevent malicious proposals. By exploiting this inconsistency, a controlling majority can:

1. **Bypass Rejection Thresholds**: Execute proposals that should be blocked by dissenting votes
2. **Undermine Minority Protection**: Remove the votes of members who oppose dangerous actions
3. **Circumvent Governance Intent**: Release proposals that failed legitimate voting requirements

The impact is HIGH because:
- It allows execution of unauthorized proposals (fund transfers, parameter changes, etc.)
- It breaks the fundamental governance invariant that threshold checks represent actual member votes
- All Association-based organizations are affected
- The attack leaves proposals appearing to meet thresholds despite being legitimately rejected

## Likelihood Explanation

**Attacker Requirements:**
- Control sufficient members to pass a member removal proposal (≥ MinimalApprovalThreshold)
- Ability to coordinate two proposals: the malicious proposal and the removal proposal

**Feasibility: HIGH**
- All operations use public, standard contract methods
- No special privileges required beyond normal member voting rights
- Member removal is a legitimate governance operation that may not raise suspicion
- Attack complexity is MEDIUM (requires coordination but no technical sophistication)

**Realistic Scenarios:**
1. Organizations with narrow majorities (e.g., 6/10 members) wanting to bypass minority protections
2. Contentious proposals that receive legitimate rejections
3. Gradual member removals that accumulate exploitable discrepancies

**Detection Difficulty:**
The exploit manifests as normal governance operations (member changes, proposal releases), making it difficult to detect without specific monitoring of the relationship between member changes and proposal vote counts.

## Recommendation

The total vote count must also filter by current organization membership to maintain consistency with individual vote type counts. Modify `CheckEnoughVoteAndApprovals`:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter total votes by current membership, consistent with other counts
    var totalVoteCount = 
        proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
        proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
        proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached =
        totalVoteCount >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

This ensures that only votes from current members count toward all thresholds, preventing the inconsistency from being exploited.

## Proof of Concept

```csharp
[Fact]
public async Task GovernanceBypass_RemoveMemberInconsistency_Test()
{
    // Setup: Organization with 10 members, thresholds designed to require broad support
    var organizationMembers = new[] { 
        Reviewer1, Reviewer2, Reviewer3,
        Accounts[4].Address, Accounts[5].Address, Accounts[6].Address,
        Accounts[7].Address, Accounts[8].Address, Accounts[9].Address,
        DefaultSender
    };
    
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { organizationMembers }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 5,      // Need 5 approvals
            MinimalVoteThreshold = 8,          // Need 8 total votes
            MaximalRejectionThreshold = 2,     // Block if >2 rejections
            MaximalAbstentionThreshold = 10
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { Reviewer1 }
        }
    };
    
    var orgResult = await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    var organizationAddress = orgResult.Output;
    
    // Create malicious proposal
    var maliciousProposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // Vote on malicious proposal: 5 approve, 4 reject
    await ApproveAsync(Reviewer1KeyPair, maliciousProposalId);
    await ApproveAsync(Reviewer2KeyPair, maliciousProposalId);
    await ApproveAsync(Reviewer3KeyPair, maliciousProposalId);
    await ApproveAsync(Accounts[4].KeyPair, maliciousProposalId);
    await ApproveAsync(Accounts[5].KeyPair, maliciousProposalId);
    
    await RejectAsync(Accounts[6].KeyPair, maliciousProposalId);
    await RejectAsync(Accounts[7].KeyPair, maliciousProposalId);
    await RejectAsync(Accounts[8].KeyPair, maliciousProposalId);
    await RejectAsync(Accounts[9].KeyPair, maliciousProposalId);
    
    // Verify proposal is initially blocked (4 rejections > 2 threshold)
    var proposal1 = await AssociationContractStub.GetProposal.CallAsync(maliciousProposalId);
    proposal1.ToBeReleased.ShouldBeFalse(); // Blocked by rejections
    proposal1.RejectionCount.ShouldBe(4);
    
    // Create proposal to remove the 4 rejecting members
    var removeMemberProposalId = await CreateAssociationProposalAsync(
        Reviewer1KeyPair, 
        Accounts[6].Address, 
        nameof(AssociationContractStub.RemoveMember),
        organizationAddress);
    
    // Same 5 members approve the removal (they have majority)
    await ApproveAsync(Reviewer1KeyPair, removeMemberProposalId);
    await ApproveAsync(Reviewer2KeyPair, removeMemberProposalId);
    await ApproveAsync(Reviewer3KeyPair, removeMemberProposalId);
    await ApproveAsync(Accounts[4].KeyPair, removeMemberProposalId);
    await ApproveAsync(Accounts[5].KeyPair, removeMemberProposalId);
    
    // Release member removal proposals (repeat for each member)
    await ReleaseProposalAsync(Reviewer1KeyPair, removeMemberProposalId);
    // ... repeat for Accounts[7], [8], [9] ...
    
    // VULNERABILITY: Check malicious proposal status after member removal
    var proposal2 = await AssociationContractStub.GetProposal.CallAsync(maliciousProposalId);
    
    // The inconsistency allows release:
    // - Filtered rejection count: 0 (removed members don't count)
    // - Unfiltered total votes: 9 (all votes still count)
    proposal2.ToBeReleased.ShouldBeTrue(); // NOW RELEASABLE despite being rejected!
    
    // The malicious proposal can now be released
    await ReleaseProposalAsync(Reviewer1KeyPair, maliciousProposalId);
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-53)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-58)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
