# Audit Report

## Title
Invalid Order Values Can Corrupt Block Production Sequence Through Unvalidated TuneOrderInformation

## Summary
A malicious miner can inject arbitrary values (including zero or negative integers) into the `TuneOrderInformation` field of `UpdateValue` transactions to corrupt miners' `FinalOrderOfNextRound` values. These corrupted values propagate to become `Order` values in the next round without validation, breaking critical consensus functions and causing blockchain halt.

## Finding Description

The vulnerability exists across three critical stages of the AEDPoS consensus mechanism:

**Stage 1 - Unvalidated Input Processing:**

In `ProcessUpdateValue`, the `TuneOrderInformation` map from `UpdateValueInput` is applied directly to miners' `FinalOrderOfNextRound` values without any bounds checking or range validation: [1](#0-0) 

The protobuf definition explicitly allows int32 values including negatives and zero: [2](#0-1) 

**Stage 2 - Invalid Values Propagated to Next Round:**

When `NextRound` is triggered, `GenerateNextRoundInformation` uses these corrupted `FinalOrderOfNextRound` values directly as the `Order` for miners in the next round: [3](#0-2) 

The `Order` field is directly assigned from `FinalOrderOfNextRound` at line 32 without validation that it's a positive integer in the valid range [1, minersCount].

**Stage 3 - Validation Bypass:**

The `NextRoundMiningOrderValidationProvider` validates the wrong data structure. The critical flaw is that `providedRound` refers to the newly generated next round returned from `GenerateNextRoundInformation`: [4](#0-3) [5](#0-4) 

In the newly created round structure, `FinalOrderOfNextRound` and `OutValue` are NOT initialized (default to 0 and null respectively) for all miners. Therefore, the validation check becomes: `count(FinalOrderOfNextRound > 0) = 0 == count(OutValue != null) = 0`, which passes even when `Order` values are invalid.

**Legitimate Code Path Analysis:**

In the legitimate consensus flow, `FinalOrderOfNextRound` is calculated in `ApplyNormalConsensusData`: [6](#0-5) 

Line 21 calculates `supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1`, producing values in range [1, minersCount]. The conflict resolution loop (lines 31-40) never produces 0 due to the loop condition. Therefore, `FinalOrderOfNextRound = 0` can ONLY occur through malicious `TuneOrderInformation` injection.

## Impact Explanation

**Severity: HIGH - Complete Consensus Disruption**

Critical consensus functions rely on valid `Order` values and will fail catastrophically with invalid orders:

1. **GetMiningInterval() Crash:** This function filters miners by `Order == 1` or `Order == 2` and accesses `firstTwoMiners[1]`: [7](#0-6) 

If no miner has `Order == 1` or `Order == 2`, the `firstTwoMiners` list will have fewer than 2 elements, causing an `ArgumentOutOfRangeException` when accessing index [1] at line 79. This function is called during next round generation and multiple consensus operations.

2. **FirstMiner() Returns Invalid Data:** [8](#0-7) 

If no miner has `Order == 1`, this returns an empty `MinerInRound`, breaking time slot calculations and other functions that depend on the first miner.

**Attack Outcome:** The blockchain halts as no valid mining schedule exists. Block production stops completely, requiring manual intervention or chain rollback to recover.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH - Exploitable by Miners with Modified Node Software**

**Reachable Entry Point:** The `UpdateValue` method is a public RPC method accessible to all miners: [9](#0-8) 

**Feasible Preconditions:**
- Attacker must be a current miner (normal operational role achievable through staking)
- Attacker modifies their node software to inject malicious `TuneOrderInformation` values instead of using the legitimate `ExtractInformationToUpdateConsensus` method
- Cost: Only requires producing one malicious block with crafted `TuneOrderInformation`

**No Effective Protections:**
The `UpdateValueValidationProvider` only validates `OutValue` and `Signature` fields, NOT the `TuneOrderInformation` values: [10](#0-9) 

The legitimate flow populates `TuneOrderInformation` via: [11](#0-10) 

However, a malicious miner can bypass this and inject arbitrary values.

## Recommendation

Add validation in `ProcessUpdateValue` to ensure all `TuneOrderInformation` values are within valid range:

```csharp
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    Assert(tuneOrder.Value > 0 && tuneOrder.Value <= minersCount, 
        $"Invalid FinalOrderOfNextRound value: {tuneOrder.Value}. Must be in range [1, {minersCount}]");
    Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key),
        $"Cannot tune order for non-existent miner: {tuneOrder.Key}");
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

Additionally, add validation in `NextRoundMiningOrderValidationProvider` to check the actual `Order` values being committed in the next round, not just `FinalOrderOfNextRound`.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up a consensus round with multiple miners
2. Have one miner call `UpdateValue` with `TuneOrderInformation[targetMiner] = 0`
3. Trigger `NextRound` 
4. Observe that `GetMiningInterval()` throws `ArgumentOutOfRangeException`
5. Confirm blockchain cannot produce further blocks

The attack succeeds because no validation prevents setting `FinalOrderOfNextRound = 0`, and the validator checks the wrong data structure (newly generated round with all defaults) rather than validating the corrupted Order values being committed.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-33)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-17)
```csharp
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L142-148)
```csharp
    public MinerInRound FirstMiner()
    {
        return RealTimeMinersInformation.Count > 0
            ? RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == 1)
            // Unlikely.
            : new MinerInRound();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```
