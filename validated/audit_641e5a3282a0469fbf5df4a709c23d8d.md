# Audit Report

## Title
Unvalidated Extra Block Producer Invariant Enables Consensus DoS via Single() Exception

## Summary
The AEDPoS consensus contract fails to validate that exactly one extra block producer exists in round data submitted by miners. The `IsCurrentMiner` function uses `.Single()` to retrieve the extra block producer, which throws an `InvalidOperationException` when zero or multiple miners have `IsExtraBlockProducer=true`. Byzantine miners can exploit this by submitting malformed `NextRoundInput` or `NextTermInput` to cause denial of service in consensus and cross-chain operations.

## Finding Description

The vulnerability exists in the consensus round validation logic where the critical invariant of exactly one extra block producer per round is not enforced during input validation.

**Root Cause:** The `IsCurrentMiner` function unconditionally retrieves the extra block producer using the `.Single()` LINQ operator: [1](#0-0) 

This operator throws `InvalidOperationException` if zero or multiple elements match the predicate `m.Value.IsExtraBlockProducer`. Similarly, `GetExtraBlockProducerInformation` uses `.First()` which throws when no element exists: [2](#0-1) 

**Attack Vector:** Miners submit consensus updates via the public `NextRound` method: [3](#0-2) 

The input is processed by `ProcessNextRound` which converts `NextRoundInput` to `Round` via `ToRound()`: [4](#0-3) 

The `ToRound()` method performs a direct field-by-field copy without validation: [5](#0-4) 

**Missing Validation:** The validation pipeline includes `RoundTerminateValidationProvider` which only validates round numbers, term numbers, and InValue fieldsâ€”but does NOT validate the extra block producer count: [6](#0-5) 

**Contrast with Normal Behavior:** During legitimate round generation, the system always assigns exactly one extra block producer: [7](#0-6) 

However, when miners submit their own round data through `NextRound`, this generation logic is bypassed.

**Permission Check:** The `PreCheck()` method only verifies the sender is in the current or previous round's miner list but does not validate the structural integrity of the submitted round data: [8](#0-7) 

## Impact Explanation

**Cross-Chain Communication Blocked:** The `IsCurrentMiner` check gates critical cross-chain indexing operations. Both `ProposeCrossChainIndexing` and `ReleaseCrossChainIndexingProposal` call `AssertAddressIsCurrentMiner`: [9](#0-8) 

This assertion invokes `CheckCrossChainIndexingPermission` in the consensus contract: [10](#0-9) 

Which in turn calls `IsCurrentMiner`: [11](#0-10) 

When malicious round data violates the extra block producer invariant, any call to `IsCurrentMiner` throws an exception at the `.Single()` line, completely blocking all cross-chain indexing operations and halting parent-child chain communication.

**Consensus Operation Disruption:** The same `IsCurrentMiner` function is used throughout consensus validation for mining permission checks and time slot validation. The exception propagates through the consensus system, preventing normal block production workflows.

**Severity: HIGH** - Complete denial of service for consensus and cross-chain functionality. The system cannot recover until the malicious round data ages out or requires emergency governance intervention.

## Likelihood Explanation

**Attacker Requirements:** Only active miners can call `NextRound` due to the permission check in `PreCheck()`. This requires a byzantine miner, which is a realistic threat in any consensus system's threat model.

**Attack Complexity: TRIVIAL**
1. Construct `NextRoundInput` with `RealTimeMinersInformation` where zero or multiple miners have `IsExtraBlockProducer = true`
2. Submit via `NextRound` transaction during the attacker's mining turn
3. The corrupted round passes all existing validations
4. Gets stored in state
5. Subsequent `IsCurrentMiner` calls throw exceptions, causing DoS

**Detection and Remediation:** The attack is immediately visible as consensus and cross-chain operations begin failing. The malicious miner is traceable from block data and could face slashing. However, the damage is done before remediation can occur.

**Probability: MEDIUM** - While requiring a byzantine miner reduces likelihood compared to permissionless attacks, the technical execution is trivial and the validation gap is definitive. This is feasible for compromised nodes or attackers willing to sacrifice their miner stake for temporary but severe disruption.

## Recommendation

Add validation of the extra block producer invariant in the validation pipeline. The `RoundTerminateValidationProvider` should be extended to verify that exactly one miner has `IsExtraBlockProducer = true` in the submitted round data:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing round number validation
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    // NEW: Validate extra block producer count
    var extraBlockProducerCount = extraData.Round.RealTimeMinersInformation.Values
        .Count(m => m.IsExtraBlockProducer);
    if (extraBlockProducerCount != 1)
        return new ValidationResult { Message = "Invalid extra block producer count. Expected exactly 1." };

    // Existing InValue validation
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

Additionally, consider adding defensive checks in `IsCurrentMiner` and `GetExtraBlockProducerInformation` to use `.SingleOrDefault()` and `.FirstOrDefault()` with explicit null checks, returning `false` or a safe default instead of throwing exceptions.

## Proof of Concept

```csharp
[Fact]
public async Task Byzantine_Miner_Can_DoS_Consensus_With_Invalid_ExtraBlockProducer_Count()
{
    // Setup: Initialize consensus with valid first round
    await InitializeConsensus();
    
    // Advance to a state where NextRound can be called
    await ProduceNormalBlocks();
    
    // Attacker: Active miner constructs malicious NextRoundInput
    var currentRound = await GetCurrentRound();
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RealTimeMinersInformation = { currentRound.RealTimeMinersInformation }
    };
    
    // Set ZERO or MULTIPLE extra block producers (breaking invariant)
    foreach (var miner in maliciousInput.RealTimeMinersInformation.Values)
    {
        miner.IsExtraBlockProducer = false; // All false = zero extra block producers
    }
    
    // Submit malicious round via NextRound
    await MaliciousMinerSubmitNextRound(maliciousInput);
    
    // Verify: Cross-chain operations now throw exceptions
    var exception = await Assert.ThrowsAsync<InvalidOperationException>(
        async () => await ProposeCrossChainIndexing()
    );
    
    // Verify: Exception originates from .Single() in IsCurrentMiner
    Assert.Contains("Sequence contains no matching element", exception.Message);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-170)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-302)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }

    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```
