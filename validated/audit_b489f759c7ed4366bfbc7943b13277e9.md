# Audit Report

## Title
Secret Sharing Data Loss During NextRound Transitions Due to Unpersisted State Modifications

## Summary
The AEDPoS consensus contract loses secret sharing revelations during every NextRound transition because `RevealSharedInValues` modifies `currentRound` in-memory after `nextRound` has already been generated, and only `nextRound` is persisted to state. This systematically breaks the secret sharing mechanism designed for consensus randomness and failed miner recovery.

## Finding Description

The vulnerability exists in the NextRound consensus flow where secret sharing revelations are computed but systematically discarded:

**The Core Issue:**

During off-chain block generation, `GetConsensusExtraDataForNextRound` first generates the next round object via `GenerateNextRoundInformation`, then calls `RevealSharedInValues` to decrypt miners' previous in values from the prior round. [1](#0-0) 

However, `RevealSharedInValues` modifies `currentRound` by reconstructing in values from secret pieces and storing them in the `PreviousInValue` field [2](#0-1) , but the method returns only `nextRound` which was created before these revelations occurred. [3](#0-2) 

The problem is that `GenerateNextRoundInformation` creates entirely new `MinerInRound` objects that only copy specific fields: `Pubkey`, `Order`, `ExpectedMiningTime`, `ProducedBlocks`, and `MissedTimeSlots` - notably excluding `PreviousInValue`. [4](#0-3)  This means modifications to `currentRound` after `nextRound` generation cannot propagate forward.

When the NextRound transaction executes on-chain, only the new round is persisted to state. [5](#0-4) 

Later, when `SupplyCurrentRoundInformation` attempts to recover missing miner data, it reads a fresh round from state and tries to use `PreviousInValue` fields that were never persisted. [6](#0-5)  The code comments explicitly state this field should contain "previous in value recovered by other miners" through secret sharing, but these values are systematically lost.

When the recovery fails, the system falls back to generating fake values, which comments indicate "shall only use once during one term" as an abnormal situation. [7](#0-6) 

## Impact Explanation

**HIGH Severity - Consensus Security Mechanism Failure**

This vulnerability systematically breaks a core consensus security mechanism:

1. **Secret Sharing Non-Functional**: The Shamir Secret Sharing mechanism is designed to allow miners to collectively reveal each other's in values when some miners fail to participate. With revelations lost on every NextRound, this security feature becomes non-operational.

2. **Randomness Quality Degradation**: Consensus randomness depends on proper in value chains where each miner's `PreviousInValue` should hash to their previous `OutValue`. Lost revelations force the system to use fallback mechanisms that compromise cryptographic security guarantees.

3. **Failed Miner Recovery Broken**: When miners miss time slots, the system cannot recover their correct previous in values through the designed secret sharing mechanism. Instead, it must use stale values or generate fake placeholder values, converting what should be a rare abnormal case into standard operation.

4. **Security Guarantee Violation**: While blocks continue to be produced (no liveness failure), the cryptographic security guarantees of the consensus protocol are violated, degrading overall consensus integrity.

## Likelihood Explanation

**CERTAIN - Automatic Execution on Every Round Transition**

This vulnerability has maximum likelihood:

1. **No Attacker Required**: The bug executes automatically during normal consensus operation on every NextRound transition
2. **High Frequency**: Round transitions occur regularly (every few minutes), meaning hundreds of occurrences per day
3. **Universal Impact**: All miners are affected equally
4. **Silent Failure**: Blocks continue to be produced with no error messages, masking the broken security mechanism
5. **100% Reproducibility**: Occurs with certainty on every single NextRound under all conditions

## Recommendation

Modify `GetConsensusExtraDataForNextRound` to call `RevealSharedInValues` on `currentRound` **before** generating `nextRound`, or ensure that revealed `PreviousInValue` data is explicitly copied into the `nextRound` object before returning it. Alternatively, modify `GenerateNextRoundInformation` to preserve the `PreviousInValue` field when creating new `MinerInRound` objects.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a multi-miner AEDPoS network with secret sharing enabled
2. Having one miner miss their time slot
3. Proceeding to NextRound transition
4. Observing that `RevealSharedInValues` sets `PreviousInValue` on `currentRound` but this is never persisted
5. When `SupplyCurrentRoundInformation` executes, the revealed values are missing from state
6. The system falls back to fake values instead of using secret sharing revelations

The test would verify that after a NextRound transition, the `PreviousInValue` fields that should contain secret sharing revelations are null/empty in the persisted state, forcing the fallback to fake value generation.

## Notes

This is a design-level bug where the ordering of operations in `GetConsensusExtraDataForNextRound` causes systematic data loss. The secret sharing cryptography itself works correctly - the issue is that computed revelations are written to the wrong object (one that gets discarded) instead of the object that gets persisted. While UpdateValue behavior has a similar mechanism (`UpdateLatestSecretPieces`) that works correctly because it operates on the round that gets returned, the NextRound behavior's implementation is flawed.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-189)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L198-203)
```csharp
        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L110-156)
```csharp
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L173-191)
```csharp
        var currentRound = GetCurrentRoundInformation(new Empty());
        Context.LogDebug(() => $"Before supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
        TryToGetPreviousRoundInformation(out var previousRound);
        foreach (var miner in notMinedMiners)
        {
            Context.LogDebug(() => $"Miner pubkey {miner.Pubkey}");

            Hash previousInValue = null;
            Hash signature = null;

            // Normal situation: previous round information exists and contains this miner.
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L203-210)
```csharp
            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }
```
