# Audit Report

## Title
Unvalidated Boolean Parsing in CrossChainCreate Enables NFT Protocol Creation DoS

## Summary
An attacker can create a token on mainchain with malicious `NftTokenIdReuseMetadataKey` values (e.g., "1", "yes", "TRUE") by directly calling the MultiToken contract's Create method. When cross-chained to sidechains and `CrossChainCreate()` is invoked, the unprotected `bool.Parse()` call throws a `FormatException`, permanently preventing NFT protocol creation for that symbol.

## Finding Description

The vulnerability exists in the NFT contract's `CrossChainCreate()` method, which retrieves token information and directly parses the boolean metadata value without validation or error handling. The vulnerable code performs an unprotected parse operation on the `NftTokenIdReuseMetadataKey` external info value. [1](#0-0) 

C#'s `bool.Parse()` only accepts "True" or "False" (case-insensitive) and throws a `FormatException` for any other input like "1", "yes", "TRUE", etc. This is standard C# behavior.

The root cause is that the MultiToken contract's `Create()` method accepts arbitrary ExternalInfo values without validating their content or format. The token creation assigns ExternalInfo directly from input without content validation. [2](#0-1) 

The validation method `AssertValidCreateInput` only checks token name length, symbol length, and decimals - it does not validate ExternalInfo content. [3](#0-2) 

While the NFT contract's `Create()` method properly sets this value using `bool.ToString()` which produces valid "True"/"False" strings. [4](#0-3) 

The NFT contract also protects reserved metadata keys through validation to prevent users from overriding system-managed fields. [5](#0-4)  The reserved keys include the vulnerable `NftTokenIdReuseMetadataKey`. [6](#0-5) 

However, an attacker can bypass the NFT contract entirely by calling MultiToken.Create directly. The only requirement is possessing a seed NFT for the target symbol or being whitelisted. The MultiToken Create method checks for seed NFT ownership before allowing token creation on mainchain. [7](#0-6) 

Once created with malicious ExternalInfo, the token can be legitimately cross-chained via `CrossChainCreateToken`, which validates token existence but preserves the malicious ExternalInfo values. [8](#0-7) 

The `ValidateTokenInfoExists` method only validates that ExternalInfo matches between chains, not its content validity. [9](#0-8) 

On the sidechain, the duplicate protocol check only prevents re-creation after successful creation, not after repeated failures. [10](#0-9) 

## Impact Explanation

**Operational Impact - DoS of NFT Protocol Creation:**
- When `CrossChainCreate()` is called on a sidechain for a poisoned token symbol, the unhandled `FormatException` causes transaction failure
- Since the protocol state remains null after failure, the duplicate check passes on subsequent attempts
- However, the parsing error recurs on every attempt, creating a permanent DoS condition
- This blocks legitimate NFT functionality for that symbol namespace on affected sidechains
- Multiple symbols can be poisoned if the attacker obtains multiple seed NFTs
- No fund loss occurs, but NFT protocol deployment becomes impossible for affected symbols

**Severity Justification:** Medium - Operational DoS with no direct fund impact, but permanently damages protocol functionality on sidechains for affected symbols. The attack requires obtaining seed NFTs but is otherwise straightforward to execute.

## Likelihood Explanation

**Attacker Capabilities:**
- Must obtain seed NFTs for target symbols (e.g., "XX123456" with valid NFT type prefix like "XX")
- Seed NFTs can be purchased or obtained through normal protocol mechanisms
- No special privileges or compromised roles required beyond seed NFT ownership

**Attack Complexity:**
- Low - straightforward execution path:
  1. Obtain seed NFT for desired symbol
  2. Call `MultiToken.Create()` with malicious ExternalInfo containing invalid boolean strings (e.g., {"aelf_nft_token_id_reuse": "1"})
  3. Call `ValidateTokenInfoExists()` on mainchain to establish cross-chain proof
  4. Call `CrossChainCreateToken()` on sidechain with merkle proof
  5. Any call to `CrossChainCreate()` â†’ permanent transaction failure due to FormatException

**Economic Rationality:**
- Cost: Seed NFT acquisition price + transaction fees
- Detection: Malicious ExternalInfo visible on-chain but may not be detected before cross-chaining
- Attack is economically feasible for targeted DoS scenarios

**Probability:** High - All preconditions are realistic and execution is straightforward under normal AElf contract semantics. Seed NFTs are obtainable through standard mechanisms.

## Recommendation

Add input validation or error handling to the `CrossChainCreate` method:

**Option 1 - Validate before parsing:**
```csharp
var isTokenIdReuseString = tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey];
Assert(isTokenIdReuseString == "True" || isTokenIdReuseString == "False", 
    "Invalid token ID reuse value format");
var isTokenIdReuse = bool.Parse(isTokenIdReuseString);
```

**Option 2 - Use TryParse with default:**
```csharp
var isTokenIdReuse = bool.TryParse(
    tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey], 
    out var result) ? result : false;
```

**Option 3 - Validate in MultiToken contract (more comprehensive):**
Add validation in `AssertValidCreateInput` or `CreateToken` to verify that ExternalInfo values for known NFT metadata keys are properly formatted before allowing token creation.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreate_WithMaliciousBooleanValue_ShouldFail()
{
    // 1. Setup: Obtain seed NFT
    var seedSymbol = await CreateSeedNFT();
    
    // 2. Attack: Call MultiToken.Create directly with malicious ExternalInfo
    var maliciousSymbol = "XX123456";
    var createResult = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = maliciousSymbol,
        TokenName = "Malicious Token",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = DefaultAddress,
        IsBurnable = true,
        IssueChainId = MainChainId,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                { "aelf_nft_type", "Any" },
                { "aelf_nft_base_uri", "ipfs://test/" },
                { "aelf_nft_token_id_reuse", "1" } // Malicious value - not "True" or "False"
            }
        }
    });
    createResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // 3. Cross-chain the token to sidechain
    await CrossChainTokenToSideChain(maliciousSymbol);
    
    // 4. Attempt NFT.CrossChainCreate on sidechain - should throw FormatException
    var crossChainCreateResult = await SideChainNFTContractStub.CrossChainCreate
        .SendWithExceptionAsync(new CrossChainCreateInput
        {
            Symbol = maliciousSymbol
        });
    
    // Verify DoS: Transaction fails with FormatException
    crossChainCreateResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    crossChainCreateResult.TransactionResult.Error.ShouldContain("FormatException");
    
    // Verify protocol was not created (remains null)
    var protocolInfo = await SideChainNFTContractStub.GetNFTProtocolInfo.CallAsync(
        new StringValue { Value = maliciousSymbol });
    protocolInfo.ShouldBeNull();
    
    // Verify retry also fails (permanent DoS)
    var retryResult = await SideChainNFTContractStub.CrossChainCreate
        .SendWithExceptionAsync(new CrossChainCreateInput
        {
            Symbol = maliciousSymbol
        });
    retryResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
}
```

## Notes

This vulnerability demonstrates a defense-in-depth failure where:
1. The NFT contract correctly protects its own Create method with reserved key validation
2. However, the lower-level MultiToken contract lacks awareness of NFT-specific metadata semantics
3. The cross-chain system faithfully preserves malicious data without semantic validation
4. The final parsing operation lacks defensive error handling

The fix should be applied at the earliest reasonable point - either validating NFT metadata in MultiToken.Create when NFT-related keys are present, or adding robust error handling in NFT.CrossChainCreate.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L79-79)
```csharp
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L88-88)
```csharp
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L199-199)
```csharp
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L449-456)
```csharp
        if (tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.Count > 0 ||
            input.ExternalInfo != null && input.ExternalInfo.Count > 0)
        {
            validationResult = validationResult && tokenInfo.ExternalInfo.Value.Count == input.ExternalInfo.Count;
            if (tokenInfo.ExternalInfo.Value.Any(keyPair =>
                    !input.ExternalInfo.ContainsKey(keyPair.Key) || input.ExternalInfo[keyPair.Key] != keyPair.Value))
                throw new AssertionException("Token validation failed.");
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L501-501)
```csharp
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L118-123)
```csharp
    private void AssertMetadataKeysAreCorrect(IEnumerable<string> metadataKeys)
    {
        var reservedMetadataKey = GetNftMetadataReservedKeys();
        foreach (var metadataKey in metadataKeys)
            Assert(!reservedMetadataKey.Contains(metadataKey), $"Metadata key {metadataKey} is reserved.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L100-106)
```csharp
        {
            NftTypeMetadataKey,
            NftBaseUriMetadataKey,
            AssembledNftsKey,
            AssembledFtsKey,
            NftTokenIdReuseMetadataKey
        };
```
