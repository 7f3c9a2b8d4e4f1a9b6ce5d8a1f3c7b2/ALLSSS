# Audit Report

## Title
Secret Sharing Threshold Validation Requires 100% Participation Instead of Configured 2/3 Threshold

## Summary
The AEDPoS consensus secret sharing mechanism implements Shamir's 2/3 threshold secret sharing for fault tolerance, but the validation logic incorrectly requires 100% miner participation before attempting secret reconstruction. This defeats the purpose of threshold cryptography and enables any single miner to prevent secret reconstruction through a no-cost griefing attack.

## Finding Description

The vulnerability stems from a fundamental mismatch between the cryptographic threshold and the validation threshold in the secret sharing implementation.

**Threshold Configuration (2/3):**
The system correctly calculates `minimumCount = minersCount * 2 / 3` as the threshold for Shamir's Secret Sharing. [1](#0-0) 

**Incorrect Validation Check (100%):**
However, the `RevealSharedInValues` method checks whether `DecryptedPieces.Count < minersCount` (requiring 100% of miners) before attempting reconstruction: [2](#0-1) 

**Cryptographic Reconstruction Uses Correct Threshold:**
The actual `DecodeSecret` call correctly uses `minimumCount` (2/3) for Lagrange interpolation: [3](#0-2) 

The cryptographic implementation only requires `threshold` number of shares to reconstruct the secret: [4](#0-3) 

**Attack Execution Path:**
1. A malicious miner omits `DecryptedPieces` from their `UpdateValue` transaction (passive attack)
2. The `PerformSecretSharing` method stores whatever pieces are provided without validation: [5](#0-4) 
3. When `RevealSharedInValues` executes, it fails the 100% check and skips reconstruction for all miners
4. The system falls back to a deterministic fake value computed from the miner's public key and block height: [6](#0-5) 
5. The `PreviousInValue` field is explicitly marked as optional: [7](#0-6) 

**No Punishment Mechanism:**
The evil miner detection only checks `MissedTimeSlots`, not failure to submit `DecryptedPieces`: [8](#0-7) 

## Impact Explanation

**MEDIUM Severity** - This vulnerability has multiple impacts on consensus integrity:

1. **Defeats Threshold Cryptography Design**: Shamir's Secret Sharing is specifically designed to provide fault tolerance when only t-of-n parties cooperate. By requiring n-of-n participation, the system completely loses this benefit and becomes as brittle as a non-threshold scheme.

2. **No-Cost Griefing Attack**: Any single malicious miner can prevent ALL other miners' `PreviousInValue` from being revealed by simply omitting their `DecryptedPiece`. This affects the entire miner set, making it a denial-of-service vector for the secret sharing mechanism.

3. **Weakens Consensus Randomness**: When `PreviousInValue` cannot be revealed through secret sharing, the system falls back to a deterministic value. This predictability allows miners to selectively reveal their true `InValue` or use the fallback, potentially manipulating the consensus randomness used for mining order determination.

4. **No Accountability**: Since the attack is passive (omission rather than invalid submission) and there's no punishment mechanism for withholding `DecryptedPieces`, attackers face zero consequences for this behavior.

## Likelihood Explanation

**HIGH Likelihood** - This attack is trivially exploitable:

- **Attacker Capabilities**: Any active miner in the consensus set can execute this attack with no special privileges beyond being a block producer
- **Attack Complexity**: Trivial - the attacker simply omits their `DecryptedPieces` from their `UpdateValue` transaction
- **No Preconditions**: Attack works regardless of network conditions or other miners' behavior
- **Zero Cost**: No economic cost or punishment for the attacker
- **Difficult Detection**: The attack is indistinguishable from legitimate network issues or temporary unavailability

## Recommendation

Change the validation check in `RevealSharedInValues` from requiring 100% participation to requiring only the threshold (2/3):

**Current code** (line 36 in AEDPoSContract_SecretSharing.cs):
```csharp
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**Fixed code**:
```csharp
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

This change will:
- Enable secret reconstruction with only 2/3 of miners participating (as designed)
- Maintain fault tolerance even when some miners are offline or malicious
- Properly utilize the threshold cryptography implementation

Additionally, consider adding validation in `PerformSecretSharing` to ensure miners provide their `DecryptedPieces`, and potentially adding a punishment mechanism for miners who consistently fail to provide decrypted pieces.

## Proof of Concept

To demonstrate this vulnerability, a test should:

1. Set up a consensus scenario with N miners (e.g., 7 miners, threshold = 4)
2. Have all miners produce blocks normally in round R
3. In round R+1, have miners submit their `UpdateValue` transactions
4. Have one malicious miner submit `UpdateValue` with an empty or partial `DecryptedPieces` map
5. Call or wait for `RevealSharedInValues` to execute
6. Assert that despite having 6 out of 7 decrypted pieces (exceeding the 2/3 threshold), the secret reconstruction is skipped
7. Verify that affected miners' `PreviousInValue` fields remain unset or fall back to deterministic fake values
8. Demonstrate that the malicious miner receives no punishment (their `MissedTimeSlots` counter is not incremented)

The test would need to interact with the AEDPoS consensus contract state and simulate multiple mining rounds to properly demonstrate the attack path and its impact on the secret sharing mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-48)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L94-96)
```csharp
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```
