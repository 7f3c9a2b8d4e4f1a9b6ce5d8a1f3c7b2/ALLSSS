# Audit Report

## Title
Token Dust Accumulation from Integer Division in Resource Token Distribution

## Summary
The `DistributeResourceTokensToPreviousMiners` method on side chains uses integer division to distribute resource tokens to miners, causing remainder tokens to be permanently locked in the consensus contract with no recovery mechanism. This leads to gradual, irreversible token loss over time.

## Finding Description

The vulnerability exists in the resource token distribution mechanism for AElf side chains. When the consensus contract distributes accumulated resource tokens to miners during cross-chain updates, integer division truncates any remainder, leaving tokens permanently stuck.

**Root Cause:**

The distribution calculates each miner's share using integer division that truncates remainders. [1](#0-0)  The `Div` extension method performs standard C# integer division without remainder handling. [2](#0-1) 

**Execution Path:**

1. On side chains, resource tokens accumulate in the consensus contract balance through `DonateResourceToken`, where tokens are sent to the consensus contract address. [3](#0-2) 

2. When `UpdateInformationFromCrossChain` is invoked by the CrossChain contract, [4](#0-3)  it calls `DistributeResourceTokensToPreviousMiners`. [5](#0-4) 

3. For each resource token symbol, the consensus contract's balance is retrieved and divided equally among miners. [6](#0-5) 

4. Each miner receives the calculated amount via transfer. [7](#0-6) 

5. The remainder (`balance % minerCount`) stays locked in the consensus contract with no method to recover it.

**No Recovery Mechanism:**

Analysis of all public methods defined in the consensus contract protobuf interface [8](#0-7)  reveals no administrative functions to withdraw locked tokens. The `DistributeResourceTokensToPreviousMiners` method is the only location in the consensus contract that transfers tokens out of the contract's own balance. The `Donate` method in the dividends pool handles external donations but does not touch the consensus contract's accumulated resource token balance. [9](#0-8) 

## Impact Explanation

**Direct Fund Loss:**
Resource tokens that should be distributed to miners are permanently locked in the consensus contract. The impact compounds over time because:

- Each cross-chain update leaves a remainder of up to (minerCount - 1) token base units per symbol
- Multiple resource token symbols (defined in `PayTxFeeSymbolListName` and `PayRentalSymbolListName`) are affected simultaneously [10](#0-9) 
- No administrative recovery function exists
- The accumulated dust can never be reclaimed

**Quantified Impact:**
For each update cycle where `balance % minerCount != 0`, up to (minerCount - 1) token base units per symbol are locked. With typical side chain configurations and frequent cross-chain updates, this accumulates to measurable amounts over time.

**Affected Parties:**
- Side chain miners receive marginally less resource token compensation than intended
- Side chain resource token economics are distorted as tokens accumulate in an inaccessible address  
- The consensus contract becomes an unintended permanent token sink

**Severity:** MEDIUM - Individual losses per update are small (measured in minimum token units), but the cumulative effect is irreversible and there is no recovery mechanism. This violates the intended token distribution economics of the system.

## Likelihood Explanation

**Entry Point:**
The vulnerability is triggered through `UpdateInformationFromCrossChain`, which can only be called by the CrossChain system contract during normal cross-chain consensus synchronization. [11](#0-10) 

**Preconditions:**
The issue occurs whenever the consensus contract's resource token balance is not evenly divisible by the miner count. This is extremely common because:

- Resource token balances vary based on contract execution and resource consumption patterns
- Miner counts are rarely exact divisors of accumulated token amounts
- No attacker involvement is required - this happens during normal operations

**Execution Probability:**
This occurs automatically on every cross-chain update cycle on side chains where a remainder exists. Given typical token accumulation patterns and miner counts, the majority of distribution events will have at least one token symbol with a non-zero remainder.

**Probability:** HIGH - This is not an attack scenario but a systematic flaw that occurs during routine cross-chain consensus updates on all AElf side chains.

## Recommendation

Implement a remainder handling mechanism in `DistributeResourceTokensToPreviousMiners`:

**Option 1: Distribute remainder to first miner(s)**
```
var baseAmount = balance.Div(minerList.Count);
var remainder = balance.Sub(baseAmount.Mul(minerList.Count));
var index = 0;
foreach (var pubkey in minerList)
{
    var amount = baseAmount;
    if (index < remainder) amount = amount.Add(1);
    // transfer amount
    index++;
}
```

**Option 2: Keep cumulative remainder for next distribution**
Track accumulated remainders in contract state and add them to the next distribution cycle's balance before division.

**Option 3: Add recovery function**
Add a governance-controlled method to withdraw accumulated dust after a certain threshold or time period, ensuring it gets distributed appropriately.

## Proof of Concept

```csharp
[Fact]
public async Task DemonstrateRemainderLossInResourceTokenDistribution()
{
    SetToSideChain();
    InitialContracts();
    
    var mockedCrossChain = SampleAccount.Accounts.Last();
    var mockedCrossChainStub = GetTester<AEDPoSContractImplContainer.AEDPoSContractImplStub>(
        ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        mockedCrossChain.KeyPair);
    
    // Setup: Create resource token and transfer to consensus contract
    await CreateAndIssueToken("READ");
    var totalAmount = 10_00000000L; // 10 tokens with 8 decimals
    await TokenStub.Transfer.SendAsync(new TransferInput
    {
        Symbol = "READ",
        Amount = totalAmount,
        To = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name]
    });
    
    // Configure 3 miners (totalAmount not evenly divisible by 3)
    var headerInformation = new AElfConsensusHeaderInformation
    {
        Round = new Round
        {
            RoundNumber = 2,
            RealTimeMinersInformation =
            {
                { Accounts[0].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                { Accounts[1].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                { Accounts[2].KeyPair.PublicKey.ToHex(), new MinerInRound() }
            }
        }
    };
    
    // Trigger distribution via UpdateInformationFromCrossChain
    await mockedCrossChainStub.UpdateInformationFromCrossChain.SendAsync(
        new BytesValue { Value = headerInformation.ToByteString() });
    
    // Verify: Check consensus contract still has remainder
    var consensusBalance = await TokenStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        Symbol = "READ"
    });
    
    // Expected remainder: 10_00000000 % 3 = 1
    // Each miner gets: 10_00000000 / 3 = 333333333 (integer division)
    // Total distributed: 333333333 * 3 = 999999999
    // Remainder stuck: 10_00000000 - 999999999 = 1
    consensusBalance.Balance.ShouldBe(1); // Demonstrates the remainder is stuck
    
    // Verify no mechanism exists to recover this remainder
    // (All public methods checked - none can withdraw these tokens)
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-38)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L53-53)
```csharp
        DistributeResourceTokensToPreviousMiners();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L73-83)
```csharp
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
            Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
            if (amount <= 0) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L84-94)
```csharp
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1001-1005)
```csharp
                        Context.LogDebug(() => $"Adding {amount} of {symbol}s to consensus address account.");
                        // Side Chain
                        receiver =
                            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
                        ModifyBalance(receiver, symbol, amount);
```

**File:** protobuf/aedpos_contract.proto (L17-181)
```text
service AEDPoSContract {
    
    option (aelf.csharp_state) = "AElf.Contracts.Consensus.AEDPoS.AEDPoSContractState";
    
    // Initialize the consensus contract. 
    rpc InitialAElfConsensusContract (InitialAElfConsensusContractInput) returns (google.protobuf.Empty) {
    }
    
    // Initializes the consensus information in the first round.
    rpc FirstRound (Round) returns (google.protobuf.Empty) {
    }
    
    // Update consensus information.
    rpc UpdateValue (UpdateValueInput) returns (google.protobuf.Empty) {
    }

    // Update consensus information, create a new round.
    rpc NextRound (NextRoundInput) returns (google.protobuf.Empty) {
    }

    // Update consensus information, create a new term.
    rpc NextTerm (NextTermInput) returns (google.protobuf.Empty) {
    }

    // Update consensus tiny block information.
    rpc UpdateTinyBlockInformation (TinyBlockInput) returns (google.protobuf.Empty) {
    }
    
    // Set the maximum count of miners, by default, is unlimited. 
    // If you want to control the count of miners, you need to set it through parliament.
    rpc SetMaximumMinersCount (google.protobuf.Int32Value) returns (google.protobuf.Empty) {
    }
    
    // The authority information for SetMaximumMinersCount, by default, is governed by parliament.
    rpc ChangeMaximumMinersCountController (AuthorityInfo) returns (google.protobuf.Empty) {
    }
    
    // Set miner increase interval
    rpc SetMinerIncreaseInterval (google.protobuf.Int64Value) returns (google.protobuf.Empty){
    }
    
    // Election Contract can notify AEDPoS Contract to aware candidate replacement happened.
    rpc RecordCandidateReplacement (RecordCandidateReplacementInput) returns (google.protobuf.Empty) {
    }

    // Get the list of current miners.
    rpc GetCurrentMinerList (google.protobuf.Empty) returns (MinerList) {
        option (aelf.is_view) = true;
    }
    
    // Get the list of current miners (hexadecimal format).
    rpc GetCurrentMinerPubkeyList (google.protobuf.Empty) returns (PubkeyList) {
        option (aelf.is_view) = true;
    }
    
    // Get the list of current miners and current round number.
    rpc GetCurrentMinerListWithRoundNumber (google.protobuf.Empty) returns (MinerListWithRoundNumber) {
        option (aelf.is_view) = true;
    }
    
    // Get information of the round according to round number.
    rpc GetRoundInformation (google.protobuf.Int64Value) returns (Round) {
        option (aelf.is_view) = true;
    }
    
    // Get the current round number.
    rpc GetCurrentRoundNumber (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    
    // Get the current round information.
    rpc GetCurrentRoundInformation (google.protobuf.Empty) returns (Round) {
        option (aelf.is_view) = true;
    }
    
    // Get the previous round information.
    rpc GetPreviousRoundInformation (google.protobuf.Empty) returns (Round) {
        option (aelf.is_view) = true;
    }
    
    // Get the current term number.
    rpc GetCurrentTermNumber (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    
    // Get the welfare reward the current term.
    rpc GetCurrentTermMiningReward (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    
    // Get the list of miners according to term number.
    rpc GetMinerList (GetMinerListInput) returns (MinerList) {
        option (aelf.is_view) = true;
    }
    
    // Get the list of miner in previous term.
    rpc GetPreviousMinerList (google.protobuf.Empty) returns (MinerList) {
        option (aelf.is_view) = true;
    }
    
    // Get the amount of mined blocks in previous term.
    rpc GetMinedBlocksOfPreviousTerm (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    
    // Get the miner that produces the next block.
    rpc GetNextMinerPubkey (google.protobuf.Empty) returns (google.protobuf.StringValue) {
        option (aelf.is_view) = true;
    }
    
    // Check to see if the account address is on the miner list for the current round.
    rpc IsCurrentMiner (aelf.Address) returns (google.protobuf.BoolValue) {
        option (aelf.is_view) = true;
    }
    
    // Query the left time before the next election takes effects (seconds).
    rpc GetNextElectCountDown (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    
    // Get term information according term number.
    rpc GetPreviousTermInformation (google.protobuf.Int64Value) returns (Round) {
        option (aelf.is_view) = true;
    }
    
    // Get random hash (Keep this for compatibility).
    rpc GetRandomHash (google.protobuf.Int64Value) returns (aelf.Hash) {
        option (aelf.is_view) = true;
    }
    
    // Get the maximum of tiny blocks produced by a miner each round.
    rpc GetMaximumBlocksCount (google.protobuf.Empty) returns (google.protobuf.Int32Value) {
        option (aelf.is_view) = true;
    }

    // Get the maximum count of miners.
    rpc GetMaximumMinersCount (google.protobuf.Empty) returns (google.protobuf.Int32Value) {
        option (aelf.is_view) = true;
    }
    
    // Get the authority information for SetMaximumMinersCount.
    rpc GetMaximumMinersCountController (google.protobuf.Empty) returns (AuthorityInfo) {
        option (aelf.is_view) = true;
    }
    
    // Get miner increase interval
    rpc GetMinerIncreaseInterval (google.protobuf.Empty) returns (google.protobuf.Int64Value){
        option (aelf.is_view) = true;
    }
    
    // Gets the list of miners in the main chain.
    rpc GetMainChainCurrentMinerList (google.protobuf.Empty) returns (MinerList) {
        option (aelf.is_view) = true;
    }
    
    // Get the list of miners in the previous term.
    rpc GetPreviousTermMinerPubkeyList (google.protobuf.Empty) returns (PubkeyList) {
        option (aelf.is_view) = true;
    }
    
    // Query the current mining reward for each block.
    rpc GetCurrentMiningRewardPerBlock (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L37-94)
```csharp
    public override Empty Donate(DonateInput input)
    {
        EnsureTokenContractAddressSet();

        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();

        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = Context.Self
        });

        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            Spender = State.TokenHolderContract.Value
        });

        State.TokenHolderContract.ContributeProfits.Send(new ContributeProfitsInput
        {
            SchemeManager = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        Context.Fire(new DonationReceived
        {
            From = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            PoolContract = Context.Self
        });

        var currentReceivedDividends = State.SideChainReceivedDividends[Context.CurrentHeight];
        if (currentReceivedDividends != null && currentReceivedDividends.Value.ContainsKey(input.Symbol))
            currentReceivedDividends.Value[input.Symbol] =
                currentReceivedDividends.Value[input.Symbol].Add(input.Amount);
        else
            currentReceivedDividends = new Dividends
            {
                Value =
                {
                    {
                        input.Symbol, input.Amount
                    }
                }
            };

        State.SideChainReceivedDividends[Context.CurrentHeight] = currentReceivedDividends;

        Context.LogDebug(() => $"Contributed {input.Amount} {input.Symbol}s to side chain dividends pool.");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L13-14)
```csharp
    public const string PayTxFeeSymbolListName = "SymbolListToPayTxFee";
    public const string PayRentalSymbolListName = "SymbolListToPayRental";
```
