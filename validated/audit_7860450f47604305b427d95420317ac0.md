# Audit Report

## Title
Period Desynchronization Between TokenHolder and Profit Contracts Causes DOS in RegisterForProfits

## Summary
The TokenHolder contract maintains a local `Period` counter that becomes desynchronized from ProfitContract's `CurrentPeriod` when managers call `ProfitContract.DistributeProfits` directly. This causes `RegisterForProfits` with auto-distribute to revert with "Invalid period" errors, creating a DOS condition for new user registrations.

## Finding Description

The vulnerability stems from improper period synchronization between TokenHolder and Profit contracts, breaking the core token staking and profit registration functionality.

**Root Cause Analysis:**

When users call `RegisterForProfits`, the method retrieves the scheme without period synchronization by calling `GetValidScheme(input.SchemeManager)` with the default parameter. [1](#0-0) 

This invokes `GetValidScheme` with `updateSchemePeriod = false` by default. [2](#0-1) 

The critical flaw occurs in `UpdateTokenHolderProfitScheme`, which returns early without synchronizing the period when `scheme.SchemeId != null && !updateSchemePeriod`. [3](#0-2) 

Meanwhile, the ProfitContract explicitly allows scheme managers to call `DistributeProfits` directly, not just through the TokenHolder wrapper. [4](#0-3) 

When called directly, ProfitContract strictly validates that the input period matches its current period and increments it after successful distribution. [5](#0-4) [6](#0-5) 

**Attack Scenario:**

1. Manager creates a TokenHolder scheme with auto-distribute threshold configured
2. Manager calls `ProfitContract.DistributeProfits` directly (bypassing TokenHolder), which increments ProfitContract's `CurrentPeriod` from 1 to 2
3. TokenHolder's `Period` remains at 1 (now desynchronized)
4. User calls `TokenHolder.RegisterForProfits` when auto-distribute threshold is met
5. Auto-distribute logic uses the stale period from TokenHolder's local state [7](#0-6) 
6. ProfitContract receives period 1 but expects period 2, triggering assertion failure
7. Transaction reverts with "Invalid period" error message

**Additional Storage Bug:**

The synchronization logic contains a separate bug where it saves to `Context.Sender` instead of the `manager` parameter, potentially storing period updates to incorrect addresses. [8](#0-7) 

## Impact Explanation

**Severity: HIGH**

This vulnerability causes complete denial-of-service of the `RegisterForProfits` function when auto-distribute thresholds are configured:

- **Core Functionality Broken**: Users cannot stake tokens and register for profit schemes, which is the primary purpose of the TokenHolder contract
- **Permanent DOS Until Manual Recovery**: Once desynchronized, every subsequent `RegisterForProfits` call with auto-distribute will fail with period validation errors
- **Economic Impact**: New participants cannot join profit distribution schemes, breaking the token holder dividend mechanism that incentivizes token ownership
- **Poor User Experience**: Users encounter cryptic "Invalid period" errors without understanding the root cause or having any ability to fix it themselves

While the manager can recover by calling `TokenHolder.DistributeProfits` (which properly synchronizes with `updateSchemePeriod = true`), this requires manual intervention and may not be immediately obvious to scheme managers. [9](#0-8) 

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability has a high probability of occurrence in production:

- **Accidental Trigger**: Managers may legitimately interact with both the TokenHolder wrapper and the underlying ProfitContract directly, not realizing this creates desynchronization
- **Low Barrier**: Only requires normal transaction fees to trigger; no special resources or complex setup needed
- **Public Methods**: Both `ProfitContract.DistributeProfits` and `TokenHolder.RegisterForProfits` are publicly accessible with documented APIs
- **Common Configuration**: Auto-distribute thresholds are a standard feature used to automate profit distribution when sufficient funds accumulate
- **Repeatable**: Manager can continuously trigger desynchronization by calling ProfitContract directly multiple times
- **Invisible Desynchronization**: The period mismatch is not detectable until users attempt registration, making it difficult to diagnose

The vulnerability requires no special privileges beyond being a scheme manager (a legitimate and intended role), and can occur through normal contract usage patterns without malicious intent.

## Recommendation

**Fix 1: Always Synchronize Period in RegisterForProfits**

Change `RegisterForProfits` to always synchronize the period before checking auto-distribute thresholds:

```csharp
public override Empty RegisterForProfits(RegisterForProfitsInput input)
{
    Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
    var scheme = GetValidScheme(input.SchemeManager, true); // Set updateSchemePeriod = true
    // ... rest of method
}
```

**Fix 2: Correct Storage Bug**

Fix the storage location in `UpdateTokenHolderProfitScheme`:

```csharp
private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
    bool updateSchemePeriod)
{
    if (scheme.SchemeId != null && !updateSchemePeriod) return;
    // ... synchronization logic ...
    State.TokenHolderProfitSchemes[manager] = scheme; // Use manager, not Context.Sender
}
```

**Fix 3: Alternative - Prevent Direct ProfitContract Calls**

Consider restricting `ProfitContract.DistributeProfits` to only accept calls from registered wrapper contracts (like TokenHolder), though this may break backward compatibility.

## Proof of Concept

```csharp
[Fact]
public async Task RegisterForProfits_DOS_Via_Period_Desync_Test()
{
    // Setup: Create TokenHolder scheme with auto-distribute
    var amount = 1000L;
    var symbol = "ELF";
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = symbol,
        AutoDistributeThreshold = { { symbol, amount } }
    });
    
    // Get the underlying profit scheme ID
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = Starter });
    var schemeId = schemeIds.SchemeIds.First();
    
    // Contribute profits to reach threshold
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Amount = amount,
        Symbol = symbol
    });
    
    // ATTACK: Manager calls ProfitContract.DistributeProfits directly
    // This increments ProfitContract's CurrentPeriod but NOT TokenHolder's Period
    await ProfitContractStub.DistributeProfits.SendAsync(new Profit.DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1
    });
    
    // Verify desynchronization: ProfitContract is now at period 2
    var profitScheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    profitScheme.CurrentPeriod.ShouldBe(2L);
    
    // TokenHolder still thinks it's at period 1
    var tokenHolderScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    tokenHolderScheme.Period.ShouldBe(1L);
    
    // DOS: User tries to RegisterForProfits with auto-distribute
    // This will fail because TokenHolder uses stale period 1, but ProfitContract expects period 2
    var result = await TokenHolderContractStub.RegisterForProfits.SendWithExceptionAsync(
        new RegisterForProfitsInput
        {
            SchemeManager = Starter,
            Amount = 100L
        });
    
    // Verify DOS occurs with "Invalid period" error
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Invalid period");
}
```

## Notes

The vulnerability is valid and exploitable under normal operating conditions. The desynchronization occurs because:

1. TokenHolder maintains a local period cache for performance
2. The cache is only updated when explicitly requested via `updateSchemePeriod = true`
3. `RegisterForProfits` uses the default `updateSchemePeriod = false` for performance
4. ProfitContract allows managers to bypass the TokenHolder wrapper entirely

The combination of these design decisions creates a synchronization gap that results in DOS. The fix requires either always synchronizing the period in critical paths or preventing direct ProfitContract access for wrapped schemes.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L133-133)
```csharp
        var scheme = GetValidScheme(input.SchemeManager, true);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L152-152)
```csharp
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L196-196)
```csharp
                        Period = scheme.Period
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-278)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L289-289)
```csharp
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L298-298)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L426-428)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L478-480)
```csharp
        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```
