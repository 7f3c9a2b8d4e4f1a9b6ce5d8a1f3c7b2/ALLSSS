# Audit Report

## Title
Reentrancy Vulnerability in TokenConverter Allows Bancor Pricing Manipulation via Stale Connector Balances

## Summary
The TokenConverter contract's `Buy` and `Sell` functions are vulnerable to reentrancy attacks through token transfer callbacks. The contract calculates Bancor prices using `State.DepositBalance`, executes external token transfers that can trigger callbacks, and only afterward updates the state variable. This allows attackers to exploit stale deposit balances to obtain artificially favorable prices, breaking the Bancor bonding curve's price discovery mechanism.

## Finding Description

The vulnerability stems from a dangerous state update ordering pattern in both `Buy` and `Sell` functions.

**Buy Function Vulnerability:**

The `Buy` function calculates purchase price using `GetSelfBalance(fromConnector)`, which for deposit accounts reads from `State.DepositBalance[connector.Symbol]`. [1](#0-0) [2](#0-1) 

After price calculation, the contract executes `TransferFrom` to transfer the base token from the sender: [3](#0-2) 

**Critically**, `State.DepositBalance` is only updated AFTER this transfer completes: [4](#0-3) 

**Reentrancy Vector:**

The MultiToken contract's `DoTransferFrom` implementation creates the reentrancy opportunity by calling `DealWithExternalInfoDuringTransfer` BEFORE updating allowances: [5](#0-4) 

This callback mechanism checks if the token has `TransferCallbackExternalInfoKey` configured and executes `Context.SendInline` to invoke external contract code: [6](#0-5) [7](#0-6) 

**Attack Scenario:**

1. Attacker calls `Buy(amount=100)` with `State.DepositBalance[NT-TOKEN] = 1000`
2. Price calculated based on balance of 1000
3. During `TransferFrom`, if base token has callback configured, it triggers
4. **Reentrant `Buy(amount=100)` call reads `State.DepositBalance[NT-TOKEN]` = still 1000 (not updated yet)**
5. Both purchases complete at the first purchase's price level
6. State is updated twice, but both used stale balance for pricing

The Bancor formula confirms that with a lower (stale) `fromConnectorBalance`, the calculated `amountToPay` is proportionally lower: [8](#0-7) 

**Sell Function Also Vulnerable:**

The same pattern exists in `Sell`: price calculation uses current state, then the first `Transfer` call occurs (which can trigger callback), then state is updated: [9](#0-8) 

No reentrancy guards exist in the TokenConverter contract to prevent this attack.

## Impact Explanation

**Severity: HIGH - Direct Fund Loss**

The vulnerability breaks the core economic invariant of the Bancor bonding curve: that price increases as supply is purchased. An attacker can:

1. **Extract Value**: Purchase tokens at stale (lower) prices during reentrancy, receiving more tokens per unit of payment than legitimate buyers
2. **Drain Reserves**: Repeated reentrancy allows accumulating tokens at artificially low prices, depleting connector reserves faster than intended
3. **Disrupt Economics**: The Bancor curve no longer enforces proper price discovery, affecting all subsequent legitimate traders

The severity is amplified because multiple reentrancy levels are possible, both Buy and Sell are exploitable, all connector pairs are affected if the base token has callbacks, and protocol loses funds permanently to attackers.

## Likelihood Explanation

**Likelihood: MEDIUM-LOW** (dependent on token configuration)

**Required Conditions:**
1. A token used in TokenConverter (base token or resource token) must have `TransferCallbackExternalInfoKey` configured in its `ExternalInfo`
2. Attacker controls the callback contract to reenter TokenConverter
3. The connector must be enabled for trading

**Feasibility Analysis:**

**Path 1 - Existing Tokens Have Callbacks:** If ELF (base token) or active resource tokens have transfer callbacks configured, the vulnerability is immediately exploitable with no additional setup beyond normal token approval. However, this is **unlikely** for system tokens.

**Path 2 - Malicious Token Addition:** Attacker creates token with callback, must get governance approval via `AddPairConnector` (requires Parliament/connector controller): [10](#0-9) 

**Critical observation**: `EnableConnector` has NO access control - anyone can enable with sufficient deposit: [11](#0-10) 

The transfer callback feature is a legitimate part of the MultiToken system design, making this an architectural vulnerability. If any token (even for legitimate purposes) has callbacks configured and is used in TokenConverter, the vulnerability becomes exploitable.

## Recommendation

Implement a reentrancy guard in the TokenConverter contract:

1. Add a state variable to track reentrancy: `private bool _locked;`
2. Create a modifier to prevent reentrancy:
```csharp
private void BeginNonReentrant()
{
    Assert(!_locked, "ReentrancyGuard: reentrant call");
    _locked = true;
}

private void EndNonReentrant()
{
    _locked = false;
}
```
3. Apply the guard to `Buy` and `Sell` functions by calling `BeginNonReentrant()` at the start and `EndNonReentrant()` at the end

Alternatively, follow the Checks-Effects-Interactions pattern by updating `State.DepositBalance` BEFORE making external calls.

## Proof of Concept

The PoC would require:
1. Creating a test token with `TransferCallbackExternalInfoKey` configured to point to a malicious contract
2. The malicious contract implements a callback that reenters `TokenConverter.Buy`
3. Setting up a connector pair with this token
4. Calling `Buy` and observing that both the original and reentrant calls execute at the same price
5. Verifying that `State.DepositBalance` remains stale during the reentrant call
6. Confirming the attacker receives more tokens than they should based on proper Bancor pricing

The test would demonstrate that two purchases occur at the price level of the first purchase, when the second should have a higher price due to the increased balance from the first purchase.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L133-140)
```csharp
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L141-141)
```csharp
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-194)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-378)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L91-94)
```csharp
        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-13)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-94)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```
