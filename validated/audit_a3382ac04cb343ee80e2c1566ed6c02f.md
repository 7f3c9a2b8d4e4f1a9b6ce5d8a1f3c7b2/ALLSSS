# Audit Report

## Title
Authorization Bypass in Contract Update Proposals for Non-Whitelisted Deployers

## Summary
A logic error in `AssertAuthorityByContractInfo` allows anyone to propose updates to contracts deployed by non-whitelisted users, removing the deployer's exclusive control over their contracts. The vulnerability stems from checking whether the contract's AUTHOR is Contract Zero instead of checking whether the SENDER has appropriate authority.

## Finding Description

The vulnerability exists in the authorization logic for contract update proposals. When a non-whitelisted user deploys a contract, `DecideNonSystemContractAuthor` assigns `Context.Self` (Contract Zero's address) as the contract author instead of the deployer's address. [1](#0-0) 

This author assignment is then used during contract deployment: [2](#0-1) 

The critical flaw occurs in the update authorization check. When anyone attempts to propose a contract update, the system validates their authority: [3](#0-2) 

The `AssertAuthorityByContractInfo` function contains the flawed logic: [4](#0-3) 

The condition `contractInfo.Author == Context.Self || address == contractInfo.Author` checks if the contract's AUTHOR is Contract Zero, not whether the SENDER is authorized. When the author IS Contract Zero (which happens for all non-whitelisted deployments), the first condition is always TRUE regardless of who is proposing the update.

**Attack Flow**:
1. Non-whitelisted user deploys contract â†’ author set to Context.Self
2. Any attacker calls `ProposeUpdateContract` on that contract
3. Authorization check passes because `contractInfo.Author == Context.Self` is TRUE
4. Attacker can propose malicious updates (still requires governance approval)

Test evidence confirms this behavior:
- Non-whitelisted deployments result in BasicContractZeroAddress as author: [5](#0-4) 
- Whitelisted deployments retain deployer as author: [6](#0-5) 

## Impact Explanation

**Authorization Model Broken**: Non-whitelisted deployers lose exclusive control over their contracts. While whitelisted deployers retain authorship and can exclusively propose updates, non-whitelisted deployers have their contracts "owned" by Contract Zero, allowing anyone to propose updates.

**Increased Attack Surface**: The number of users who can propose malicious updates increases from 1 (the deployer) to all users on the chain. This dramatically increases the attack surface for social engineering attacks against governance.

**Governance Overhead**: The governance system must review proposals from arbitrary users instead of just trusted contract authors, increasing workload and potential for mistakes.

**Asymmetric Security Model**: Creates an unfair two-tier system where whitelisted users have security guarantees that non-whitelisted users do not, even though both pay for deployment through governance proposals.

This is classified as **Medium severity** because:
- Authorization bypass is complete for proposing updates
- Governance approval still required for execution (defense-in-depth mitigation)
- Real-world impact on shared side chains where non-whitelisted deployment is intended
- Breaks fundamental security guarantee of deployer control

## Likelihood Explanation

**High Likelihood** because:

**Attacker Capabilities**: Any user with a standard account can exploit this. No special permissions, resources, or technical sophistication required.

**Preconditions**: 
- Contract deployed by non-whitelisted user (common on shared side chains)
- `ContractDeploymentAuthorityRequired` is true (production setting)
- Attacker knows address of target contract

**Attack Complexity**: Low
1. Identify contract deployed by non-whitelisted user
2. Call `ProposeUpdateContract` with malicious code
3. Use social engineering to convince governance

**Real-World Scenarios**: Shared side chains explicitly designed to allow "anyone to propose contracts" are directly affected. Even on main chain, users not in the proposer whitelist are vulnerable.

## Recommendation

Fix the authorization logic in `AssertAuthorityByContractInfo` to check if the SENDER (not the author) is authorized:

```csharp
private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
{
    // Check if sender is Contract Zero (system call) OR sender is the contract author
    Assert(address == Context.Self || address == contractInfo.Author, "No permission.");
}
```

This correctly validates:
- System calls from Contract Zero are allowed (for internal operations)
- Only the contract author can propose updates
- Non-whitelisted deployers retain control even though their contracts are "authored" by Contract Zero

Alternative: Consider storing the actual deployer separately from the author and checking deployer permissions, or documenting that non-whitelisted deployments are "public contracts" that anyone can update (though this seems unintended based on the security model).

## Proof of Concept

The vulnerability is demonstrated by the existing test suite showing the contrasting behavior:

**Test 1** - Non-whitelisted deployment results in BasicContractZeroAddress as author: [7](#0-6) 

**Test 2** - Whitelisted deployment preserves deployer as author: [8](#0-7) 

**Missing Test** that would expose the vulnerability:
After Test 1 deploys a contract with BasicContractZeroAddress as author, an additional test attempting `ProposeUpdateContract` from an unauthorized address (e.g., `AnotherMinerKeyPair`) would succeed instead of failing with "No permission." This contrasts with Test 2 where such an attempt correctly fails (lines 1175-1187 of the same file).

---

## Notes

The vulnerability is subtle because the code appears to check authorization, but the logic is inverted. Instead of checking "is the sender authorized?" it checks "is the author special?" This distinction matters critically when the author is Contract Zero - it should grant privileges to Contract Zero when IT is the sender, not grant privileges to everyone when Contract Zero is merely recorded as the author.

The defense-in-depth mechanism (governance approval) prevents immediate exploitation for malicious updates, but the authorization bypass is complete for the proposal stage. This increases governance workload and opens social engineering attack vectors while fundamentally violating the security expectation that deployers control their contracts.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-183)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L309-322)
```csharp
    public override Address DeploySmartContract(ContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        // AssertDeploymentProposerAuthority(Context.Origin);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address =
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
        return address;
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L750-838)
```csharp
    [Fact]
    public async Task ChangeContractZeroOwner_Test()
    {
        var createOrganizationResult = await Tester.ExecuteContractWithMiningAsync(ParliamentAddress,
            nameof(ParliamentContractImplContainer.ParliamentContractImplStub.CreateOrganization),
            new CreateOrganizationInput
            {
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1000,
                    MinimalVoteThreshold = 1000
                }
            });

        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.ReturnValue);

        var contractDeploymentController = await GetContractDeploymentController(Tester, BasicContractZeroAddress);
        const string proposalCreationMethodName =
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ChangeContractDeploymentController);
        var proposalId = await CreateProposalAsync(Tester, contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposalCreationMethodName,
            new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = ParliamentAddress
            });
        await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
        var txResult2 = await ReleaseProposalAsync(Tester, ParliamentAddress, proposalId);
        txResult2.Status.ShouldBe(TransactionResultStatus.Mined);

        // test deployment with only one miner
        var contractDeploymentInput = new ContractDeploymentInput
        {
            Category = KernelConstants.DefaultRunnerCategory,
            Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
        };

        // propose contract code
        var proposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput);

        var contractProposalId = ProposalCreated.Parser
            .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
            .ProposalId;

        var proposedContractInputHash = ContractProposed.Parser
            .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ContractProposed))).NonIndexed)
            .ProposedContractInputHash;

        var tester = Tester.CreateNewContractTester(Tester.InitialMinerList.First());
        await ApproveWithTesterAsync(tester, ParliamentAddress, contractProposalId);

        // release contract code and trigger code check proposal
        var releaseApprovedContractTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ReleaseApprovedContract), new ReleaseContractInput
            {
                ProposalId = contractProposalId,
                ProposedContractInputHash = proposedContractInputHash
            });

        var codeCheckProposalId = ProposalCreated.Parser
            .ParseFrom(releaseApprovedContractTxResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated)))
                .NonIndexed).ProposalId;

        await ApproveWithMinersAsync(Tester, ParliamentAddress, codeCheckProposalId);

        // release code check proposal and deployment completes
        var deploymentResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ReleaseCodeCheckedContract),
            new ReleaseContractInput
                { ProposedContractInputHash = proposedContractInputHash, ProposalId = codeCheckProposalId });

        var creator = ContractDeployed.Parser
            .ParseFrom(deploymentResult.Logs.First(l => l.Name.Contains(nameof(ContractDeployed))).Indexed[0])
            .Author;

        creator.ShouldBe(BasicContractZeroAddress);

        var deployAddress = ContractDeployed.Parser
            .ParseFrom(deploymentResult.Logs.First(l => l.Name.Contains(nameof(ContractDeployed))).NonIndexed)
            .Address;

        deployAddress.ShouldNotBeNull();

        var author = Address.Parser.ParseFrom(await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractAuthor), deployAddress));

        author.ShouldBe(BasicContractZeroAddress);
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L841-941)
```csharp
    public async Task ChangeContractZeroOwnerByAssociation_Test()
    {
        var createOrganizationResult = await Tester.ExecuteContractWithMiningAsync(AssociationContractAddress,
            nameof(AssociationContractImplContainer.AssociationContractImplStub.CreateOrganization),
            new Association.CreateOrganizationInput
            {
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { AnotherMinerAddress }
                },
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { AnotherMinerAddress }
                }
            });

        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.ReturnValue);

        var contractDeploymentController = await GetContractDeploymentController(Tester, BasicContractZeroAddress);
        const string proposalCreationMethodName =
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ChangeContractDeploymentController);
        var proposalId = await CreateProposalAsync(Tester, contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposalCreationMethodName,
            new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = AssociationContractAddress
            });
        await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
        var txResult2 = await ReleaseProposalAsync(Tester, ParliamentAddress, proposalId);
        txResult2.Status.ShouldBe(TransactionResultStatus.Mined);

        var contractDeploymentControllerAfterChanged =
            await GetContractDeploymentController(Tester, BasicContractZeroAddress);

        contractDeploymentControllerAfterChanged.ContractAddress.ShouldBe(AssociationContractAddress);
        contractDeploymentControllerAfterChanged.OwnerAddress.ShouldBe(organizationAddress);

        // test deployment with only one miner
        var contractDeploymentInput = new ContractDeploymentInput
        {
            Category = KernelConstants.DefaultRunnerCategory,
            Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
        };

        var anotherMinerTester = Tester.CreateNewContractTester(AnotherMinerKeyPair);

        // propose contract code
        var proposingTxResult = await anotherMinerTester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput);

        var contractProposalId = ProposalCreated.Parser
            .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
            .ProposalId;

        var proposedContractInputHash = ContractProposed.Parser
            .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ContractProposed))).NonIndexed)
            .ProposedContractInputHash;

        await ApproveWithTesterAsync(anotherMinerTester, AssociationContractAddress, contractProposalId);

        // release contract code and trigger code check proposal
        var releaseApprovedContractTxResult = await anotherMinerTester.ExecuteContractWithMiningAsync(
            BasicContractZeroAddress,
            nameof(BasicContractZero.ReleaseApprovedContract), new ReleaseContractInput
            {
                ProposalId = contractProposalId,
                ProposedContractInputHash = proposedContractInputHash
            });

        var codeCheckProposalId = ProposalCreated.Parser
            .ParseFrom(releaseApprovedContractTxResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated)))
                .NonIndexed).ProposalId;

        await ApproveWithMinersAsync(Tester, ParliamentAddress, codeCheckProposalId);

        // release code check proposal and deployment completes
        var deploymentResult = await anotherMinerTester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ReleaseCodeCheckedContract),
            new ReleaseContractInput
                { ProposedContractInputHash = proposedContractInputHash, ProposalId = codeCheckProposalId });

        var creator = ContractDeployed.Parser
            .ParseFrom(deploymentResult.Logs.First(l => l.Name.Contains(nameof(ContractDeployed))).Indexed[0])
            .Author;

        creator.ShouldBe(AnotherMinerAddress);

        var deployAddress = ContractDeployed.Parser
            .ParseFrom(deploymentResult.Logs.First(l => l.Name.Contains(nameof(ContractDeployed))).NonIndexed)
            .Address;
        var author = Address.Parser.ParseFrom(await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractAuthor), deployAddress));

        author.ShouldBe(AnotherMinerAddress);
    }
```
