# Audit Report

## Title
Proposer Whitelist Validation Bypass Allows Organization DoS via Empty Addresses

## Summary
The Referendum contract's `Empty()` validation method only checks if the proposer whitelist has zero entries, without validating whether individual addresses contain valid byte data. This allows an attacker to poison the whitelist with empty `Address` objects (protobuf default with `Value = ByteString.Empty`), permanently disabling all proposal creation for the affected organization.

## Finding Description

The root cause lies in insufficient address validation during whitelist updates. The `Empty()` extension method only validates the count of addresses [1](#0-0) , without checking whether the `Address.Value` field contains valid data.

When `ChangeOrganizationProposerWhiteList` is called [2](#0-1) , it updates the organization's whitelist and validates using the `Validate(organization)` method [3](#0-2) . However, this validation only ensures the list count is non-zero via `organization.ProposerWhiteList.Empty()`, not that addresses have valid content.

Unlike other contracts in the codebase that properly validate addresses using the standard pattern [4](#0-3)  and [5](#0-4)  and [6](#0-5) , the Referendum contract lacks per-address validation. The standard validation utility exists [7](#0-6)  but is not used.

**Attack Execution Path:**
1. Malicious authorized proposer creates a proposal calling `ChangeOrganizationProposerWhiteList` with `ProposerWhiteList { Proposers = { new Address() } }`
2. The protobuf-generated `Address` object has `Value = ByteString.Empty` by default
3. Proposal gets approved through token-weighted voting
4. During release, the whitelist update passes validation because `Count() == 1` (Empty() returns false)
5. State is persisted with the invalid whitelist
6. All subsequent `CreateProposal` attempts fail at `AssertIsAuthorizedProposer` [8](#0-7)  because `Context.Sender` (a real address with 32 valid bytes) will never match the empty address in the whitelist via the `Contains()` check [9](#0-8) 

The entry point is the public `CreateProposal` method [10](#0-9)  which calls authorization validation that will always fail after the attack.

## Impact Explanation

**HIGH Severity** - This vulnerability causes permanent and irreversible denial-of-service of critical governance functionality:

- **Operational Impact**: The organization becomes completely unable to create new proposals, as all `CreateProposal` calls will fail authorization checks
- **Governance Capture**: The organization is permanently bricked - it cannot execute any governance actions requiring new proposals, including attempts to fix the whitelist itself (which would require creating a proposal since `ChangeOrganizationProposerWhiteList` requires `Context.Sender` to be the organization address, which can only happen via proposal execution)
- **Scope**: All members of the affected Referendum organization lose governance capabilities
- **Permanence**: No recovery mechanism exists - fixing the whitelist requires proposal creation, which is now impossible

The test suite confirms that empty whitelists should be rejected [11](#0-10) , indicating this is an unintended security gap. The same vulnerability also affects the Association contract [12](#0-11)  which has identical validation logic [13](#0-12) .

## Likelihood Explanation

**MEDIUM Likelihood** - The attack requires governance participation but is achievable:

**Attacker Prerequisites:**
- Must be an authorized proposer in the target organization
- Must convince token holders to approve the malicious proposal through token-weighted voting

**Attack Complexity:**
- **LOW** - Single proposal with simple payload: `new ProposerWhiteList { Proposers = { new Address() } }`
- Protobuf naturally allows empty Address objects (default `Value = ByteString.Empty`)
- No special cryptographic or technical knowledge required

**Feasibility:**
- **MEDIUM** - Requires insider access (authorized proposer role) but realistic in governance attack scenarios
- Attack could be disguised within a complex multi-part proposal bundle
- Could be executed by a compromised proposer account
- Social engineering could be used to gain approval ("updating whitelist for security")
- Once executed, damage is permanent and irreversible

## Recommendation

Add per-address validation in the `Validate(Organization)` method to check that each address in the whitelist contains valid byte data:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    // Add validation for each address in the whitelist
    foreach (var proposer in organization.ProposerWhiteList.Proposers)
    {
        if (proposer == null || proposer.Value.IsNullOrEmpty())
            return false;
    }
    
    Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

The same fix should be applied to the Association contract's validation method.

## Proof of Concept

```csharp
[Fact]
public async Task ProposerWhitelist_EmptyAddress_DoS_Test()
{
    // Setup: Create a referendum organization with valid proposer
    var organizationAddress = await CreateOrganizationAsync();
    
    // Attack: Create proposal to change whitelist to contain empty address
    var maliciousWhitelist = new ProposerWhiteList
    {
        Proposers = { new Address() } // Empty address with ByteString.Empty
    };
    
    var proposalId = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair,
        maliciousWhitelist,
        nameof(ReferendumContractStub.ChangeOrganizationProposerWhiteList),
        organizationAddress,
        ReferendumContractAddress
    );
    
    // Approve and release the malicious proposal
    await ApproveAllowanceAsync(Accounts[3].KeyPair, 5000, proposalId);
    await ApproveAsync(Accounts[3].KeyPair, proposalId);
    var releaseResult = await ReferendumContractStub.Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Organization is now DoS'd - no one can create proposals
    var newProposalInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress,
        ToAddress = ReferendumContractAddress,
        ContractMethodName = "SomeMethod",
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        Params = ByteString.Empty
    };
    
    // This should fail because no real address matches the empty address in whitelist
    var result = await ReferendumContractStub.CreateProposal.SendWithExceptionAsync(newProposalInput);
    result.TransactionResult.Error.ShouldContain("Unauthorized to propose");
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L18-21)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L537-545)
```csharp
    public override Empty SetSigner(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input.");

        if (State.SignerMap[Context.Sender] == input) return new Empty();

        State.SignerMap[Context.Sender] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L101-101)
```csharp
        Assert(input.Value.Any(), "Admin is needed while announcing election.");
```

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L34-37)
```csharp
        public static bool IsNullOrEmpty(this ByteString byteString)
        {
            return byteString == null || byteString.IsEmpty;
        }
```

**File:** test/AElf.Contracts.Referendum.Tests/ReferendumContractTest.cs (L774-788)
```csharp
        // invalid proposal whitelist
        {
            var organizationAddress = await CreateOrganizationAsync();
            var newProposalWhitelist = new ProposerWhiteList();
            var changeProposerWhitelistProposalId = await CreateReferendumProposalAsync(DefaultSenderKeyPair,
                newProposalWhitelist,
                nameof(ReferendumContractStub.ChangeOrganizationProposerWhiteList), organizationAddress,
                ReferendumContractAddress);
            var keyPair = Accounts[3].KeyPair;
            await ApproveAllowanceAsync(keyPair, 5000, changeProposerWhitelistProposalId);
            await ApproveAsync(keyPair, changeProposerWhitelistProposalId);
            var ret = await ReferendumContractStub.Release.SendWithExceptionAsync(
                changeProposerWhitelistProposalId);
            ret.TransactionResult.Error.ShouldContain("Invalid organization");
        }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```
