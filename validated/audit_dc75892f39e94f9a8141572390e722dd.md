# Audit Report

## Title
RemoveSubScheme Fails to Update CachedDelayTotalShares Leading to Profit Misallocation

## Summary
The `RemoveSubScheme` function in ProfitContract does not update the `CachedDelayTotalShares` map when removing a sub-scheme, unlike the analogous `RemoveBeneficiary` function. This inconsistency causes stale cached share values to persist and be used during profit distribution in schemes with delayed distribution enabled (`DelayDistributePeriodCount > 0`), resulting in inflated total shares calculations that cause legitimate beneficiaries to receive less than their entitled share of profits.

## Finding Description

The vulnerability stems from an implementation inconsistency between two related functions in the Profit contract:

**The Vulnerable Function - RemoveSubScheme:** [1](#0-0) 

This function removes a sub-scheme by: (1) Clearing the profit details for the sub-scheme's virtual address, (2) Removing the sub-scheme from the `SubSchemes` list, (3) Updating `TotalShares` to subtract the removed shares, but **critically does NOT update `CachedDelayTotalShares`**.

**The Correct Implementation - RemoveBeneficiary:** [2](#0-1) 

This function properly handles delayed distribution by iterating through affected cached periods and subtracting the removed shares from each cached entry in `CachedDelayTotalShares`.

**How Delayed Distribution Works:**

When `DistributeProfits` is called for a scheme with `DelayDistributePeriodCount > 0`, it caches the current `TotalShares` for future periods: [3](#0-2) 

The cached `totalShares` value is then stored in `DistributedProfitsInfo.TotalShares`: [4](#0-3) 

When beneficiaries claim profits, this stored `TotalShares` is used as the denominator in the profit calculation: [5](#0-4) 

**Why AddSubScheme Also Participates:**

When adding a sub-scheme, the function internally calls `AddBeneficiary` which properly handles delayed distribution: [6](#0-5) 

This means when a sub-scheme is added, its shares are correctly cached for future periods. When it's removed via `RemoveSubScheme`, the cached values are NOT updated, leaving stale inflated totals.

**Production Impact - TreasuryContract:**

The TreasuryContract creates the Welfare scheme with delayed distribution enabled: [7](#0-6) 

The TreasuryContract also uses `RemoveSubScheme` in its `ResetWeight` function to adjust sub-scheme allocations: [8](#0-7) 

This demonstrates the vulnerability can occur in production during legitimate weight adjustment operations via `SetDividendPoolWeightSetting` or `SetMinerRewardWeightSetting`.

## Impact Explanation

**Direct Financial Impact:**

When a sub-scheme is added and subsequently removed before the delayed period arrives:

1. **Period N**: Sub-scheme added with X shares → `TotalShares` increases, cached as `CachedDelayTotalShares[N + DelayDistributePeriodCount]`
2. **Period N**: `DistributeProfits` called → caches the inflated total (including X shares)
3. **Period N+1**: Sub-scheme removed → `TotalShares` decreases, but cached value remains unchanged
4. **Period N+DelayDistributePeriodCount**: Distribution uses the stale cached value with inflated denominator
5. **Result**: Each beneficiary receives `(theirShares / inflatedTotal) * amount` instead of `(theirShares / actualTotal) * amount`

**Quantified Example:**
- Initial state: 100 shares from regular beneficiaries, `DelayDistributePeriodCount = 1` (as in Welfare scheme)
- Period 1: Add sub-scheme with 100 shares → `TotalShares = 200`, `CachedDelayTotalShares[2] = 200`
- Period 1: Distribute 1000 ELF
- Period 2: Remove sub-scheme → `TotalShares = 100`, but `CachedDelayTotalShares[2]` still `= 200`
- Period 2: Distribution uses cached `totalShares = 200`
- **Impact**: Beneficiaries with 100 shares receive only 500 ELF (100/200 × 1000) instead of 1000 ELF
- **Loss**: 50% underpayment to legitimate beneficiaries, 500 ELF permanently locked in period virtual address

**Locked Funds:**
The unclaimed portion cannot be recovered because no beneficiary has sufficient shares to claim it under the inflated denominator calculation.

## Likelihood Explanation

**Triggering Conditions:**

1. **Scheme Configuration**: Requires `DelayDistributePeriodCount > 0` - confirmed in production (TreasuryContract Welfare scheme with delay of 1 period)
2. **Manager Permissions**: Requires scheme manager authority for `AddSubScheme`/`RemoveSubScheme` - this is by design for the TreasuryContract
3. **Operational Sequence**: Normal operations like weight rebalancing via `ResetWeight` can trigger this

**Realistic Scenarios:**

1. **Legitimate Operations**: TreasuryContract's `ResetWeight` function legitimately calls `RemoveSubScheme` to adjust reward distribution weights between schemes. If this occurs during a delayed distribution period, the bug triggers automatically.

2. **Governance Changes**: Protocol governance may decide to adjust sub-scheme allocations for economic policy reasons (e.g., changing the weights between MinerReward/Subsidy/Welfare via `SetDividendPoolWeightSetting`), inadvertently triggering the vulnerability.

3. **No Detection**: The issue is silent - no transaction reverts, no events indicate the problem. Beneficiaries only discover underpayment when they claim and notice the shortfall.

**Probability Assessment:**

While requiring manager access, this is not a malicious attack scenario but rather a **logic bug that occurs during legitimate operations**. The TreasuryContract demonstrates this functionality is actively used in production. The probability of occurrence is **MEDIUM-HIGH** given:
- Production code uses both features together (delayed distribution + RemoveSubScheme)
- No warnings or checks prevent this scenario
- Can happen accidentally during routine governance adjustments

## Recommendation

Update the `RemoveSubScheme` function to mirror the logic in `RemoveBeneficiary` by updating the `CachedDelayTotalShares` map when removing a sub-scheme:

Add the following logic after line 152 in `RemoveSubScheme`:

```csharp
// Update cached delay total shares (similar to RemoveBeneficiary)
if (scheme.DelayDistributePeriodCount > 0)
{
    var currentPeriod = scheme.CurrentPeriod;
    for (var period = currentPeriod;
         period < currentPeriod.Add(scheme.DelayDistributePeriodCount);
         period++)
    {
        if (scheme.CachedDelayTotalShares.ContainsKey(period))
        {
            scheme.CachedDelayTotalShares[period] =
                scheme.CachedDelayTotalShares[period].Sub(shares.Shares);
        }
    }
}
```

This ensures that when a sub-scheme is removed, all future cached periods have their total shares decremented accordingly, maintaining consistency with the current `TotalShares` value.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveSubScheme_WithDelayedDistribution_ShouldUpdateCachedShares()
{
    const int delayDistributePeriodCount = 1;
    const int contributeAmount = 100_000;
    const int subSchemeShares = 50;
    
    var creator = Creators[0];
    var creatorAddress = Address.FromPublicKey(CreatorKeyPair[0].PublicKey);

    // Create main scheme with delayed distribution
    await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true,
        ProfitReceivingDuePeriodCount = 100,
        DelayDistributePeriodCount = delayDistributePeriodCount
    });

    var schemeIds = (await creator.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = creatorAddress })).SchemeIds;
    var mainSchemeId = schemeIds[0];
    
    // Create sub-scheme
    await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        ProfitReceivingDuePeriodCount = 100
    });
    
    schemeIds = (await creator.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = creatorAddress })).SchemeIds;
    var subSchemeId = schemeIds[1];

    // Add sub-scheme with shares
    await creator.AddSubScheme.SendAsync(new AddSubSchemeInput
    {
        SchemeId = mainSchemeId,
        SubSchemeId = subSchemeId,
        SubSchemeShares = subSchemeShares
    });

    // Add regular beneficiary
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = mainSchemeId,
        BeneficiaryShare = new BeneficiaryShare 
        { 
            Beneficiary = Accounts[0].Address, 
            Shares = subSchemeShares 
        }
    });

    // Contribute and distribute for period 1
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        Amount = contributeAmount,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol,
        SchemeId = mainSchemeId
    });

    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = mainSchemeId,
        Period = 1
    });

    // Remove sub-scheme before delayed period arrives
    await creator.RemoveSubScheme.SendAsync(new RemoveSubSchemeInput
    {
        SchemeId = mainSchemeId,
        SubSchemeId = subSchemeId
    });

    var scheme = await creator.GetScheme.CallAsync(mainSchemeId);
    
    // BUG: TotalShares is correctly updated to 50
    scheme.TotalShares.ShouldBe(subSchemeShares);
    
    // BUG: CachedDelayTotalShares[2] still contains 100 (not updated!)
    // This causes beneficiaries to receive half their entitled share
    scheme.CachedDelayTotalShares[2].ShouldBe(subSchemeShares); // This will FAIL - actual value is 100
    
    // Distribute period 2 - uses inflated cached shares
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        Amount = contributeAmount,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol,
        SchemeId = mainSchemeId
    });

    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = mainSchemeId,
        Period = 2
    });

    var distributedInfo = await creator.GetDistributedProfitsInfo.CallAsync(
        new SchemePeriod { SchemeId = mainSchemeId, Period = 2 });
    
    // BUG: Uses inflated totalShares of 100 instead of correct 50
    distributedInfo.TotalShares.ShouldBe(100); // Should be 50
    
    // Beneficiary receives only half their entitled share due to inflated denominator
}
```

**Notes**

This vulnerability represents a critical inconsistency in the ProfitContract's handling of delayed distribution. The root cause is that `RemoveSubScheme` was not updated to handle the `CachedDelayTotalShares` mechanism when `RemoveBeneficiary` was properly implemented with this logic. The TreasuryContract's legitimate use of both delayed distribution (Welfare scheme) and dynamic sub-scheme management (ResetWeight) creates a real-world scenario where this bug can manifest, causing permanent fund lock and beneficiary underpayment.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L109-118)
```csharp
        AddBeneficiary(new AddBeneficiaryInput
        {
            SchemeId = input.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = subSchemeVirtualAddress,
                Shares = input.SubSchemeShares
            },
            EndPeriod = long.MaxValue
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L131-156)
```csharp
    public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
    {
        Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");

        var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
        if (shares == null) return new Empty();

        var subSchemeId = input.SubSchemeId;
        var subScheme = State.SchemeInfos[subSchemeId];
        Assert(subScheme != null, "Sub scheme not found.");

        var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
        // Remove profit details
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L243-258)
```csharp
        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-68)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L520-540)
```csharp
    private void ResetWeight(Hash parentSchemeId, Hash subSchemeId, int oldWeight,
        int newWeight)
    {
        if (oldWeight == newWeight)
            return;

        // old weight equals 0 indicates the subScheme has not been registered
        if (oldWeight > 0)
            State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
            {
                SchemeId = parentSchemeId,
                SubSchemeId = subSchemeId
            });

        State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
        {
            SchemeId = parentSchemeId,
            SubSchemeId = subSchemeId,
            SubSchemeShares = newWeight
        });
    }
```
