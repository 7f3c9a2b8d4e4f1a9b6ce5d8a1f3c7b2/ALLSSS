# Audit Report

## Title
Legitimate Vote Target Changes Blocked by Missing Profit Details Due to Integer Division Rounding

## Summary
When voters attempt to change their voting target with `IsResetVotingTime = true`, the operation fails for legitimate active votes due to missing profit details. This occurs because the profit detail `EndPeriod` is calculated using integer division that rounds down, creating a timing gap where profit details are removed before the vote lock expires.

## Finding Description

The vulnerability stems from a mismatch between two time-tracking mechanisms in the Election contract:

**Integer Division Rounding in EndPeriod Calculation:**

The `GetEndPeriod` method calculates when a voter's profit eligibility ends by dividing the lock time by the term duration using integer division: [1](#0-0) 

When `lockTime` is not perfectly divisible by `TimeEachTerm`, this rounds down. For example, a 30-day lock (2,592,000 seconds) with 7-day periods (604,800 seconds) yields `EndPeriod = currentPeriod + 4` (representing only 28 days), while the actual vote lock remains active for the full 30 days stored in `State.LockTimeMap`.

**Profit Detail Removal After Claiming:**

When `ClaimProfits` is called on the CitizenWelfare scheme, it processes all claimable periods and updates each profit detail's `LastProfitPeriod` to point to the next period to claim: [2](#0-1) 

After claiming up to `EndPeriod`, `LastProfitPeriod` becomes `EndPeriod + 1`. Subsequently, the profit detail is identified for removal because it satisfies the condition `LastProfitPeriod > EndPeriod`: [3](#0-2) 

The detail is then completely removed from the beneficiary's list: [4](#0-3) 

**Vote Change Failure:**

When a voter attempts to change their voting target, the function first validates that the vote hasn't expired using the full original `lockTime`: [5](#0-4) 

This check passes because the actual lock time (30 days) hasn't fully elapsed, even though the profit detail's rounded `EndPeriod` (28 days) has already passed.

If `IsResetVotingTime = true`, the function calls `ExtendVoterWelfareProfits`: [6](#0-5) 

This function attempts to locate the profit detail using `GetProfitDetailByElectionVotingRecord`, which tries two lookups (by ID, then by Shares): [7](#0-6) 

Since the profit detail was completely removed, both lookups fail and return `null`. This causes `ExtendVoterWelfareProfits` to throw an `AssertionException`: [8](#0-7) 

## Impact Explanation

**Denial of Service on Core Voting Functionality:**
Voters are unable to change their voting targets when `IsResetVotingTime = true` during the timing window between the rounded-down `EndPeriod` and the actual vote expiration. Users are forced to either:
1. Change targets without resetting voting time (`IsResetVotingTime = false`), losing the benefit of extended profit participation
2. Wait until the vote fully expires, then withdraw and create a new vote, incurring additional transaction costs

**User Population Affected:**
Any voter whose `lockTime` is not perfectly divisible by `TimeEachTerm` experiences this issue. This affects a significant portion of users since:
- Common lock periods (30, 60, 90, 180 days) often don't align perfectly with period durations
- The timing window typically lasts 1-6 days depending on the remainder
- Profit claiming is routine user behavior

**No Direct Fund Loss:**
Importantly, this is not a fund theft vulnerability. Tokens remain locked and fully recoverable after the vote expires through the normal withdrawal process.

**Severity Assessment:**
Medium severity is appropriate because while this causes operational disruption to core voting functionality, there is no permanent loss of funds or unauthorized access.

## Likelihood Explanation

**High Probability of Occurrence:**
This issue occurs naturally through routine protocol usage with no attacker required:

1. **Fractional Periods Are Common:** Lock times like 30, 60, or 90 days with 7-day periods create 2-6 day gaps
2. **Profit Claiming Is Routine:** Users or automated systems regularly call `ClaimProfits` to realize rewards
3. **Vote Changes Are Common:** Users frequently adjust their voting strategies to optimize rewards
4. **No Special Conditions:** The vulnerability triggers through standard public method calls with typical parameters

**Minimal Complexity:**
The trigger path is straightforward:
1. User votes with a lock time not perfectly divisible by `TimeEachTerm`
2. Time elapses past the rounded-down `EndPeriod`
3. Anyone calls `ClaimProfits` on the welfare scheme
4. User attempts to change voting target with `IsResetVotingTime = true`
5. Operation fails with `AssertionException`

## Recommendation

**Option 1: Align EndPeriod with Vote Expiration**
Modify `GetEndPeriod` to round up instead of down, ensuring profit eligibility covers the entire vote lock period:

```csharp
private long GetEndPeriod(long lockTime)
{
    var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
    var periods = lockTime.Add(State.TimeEachTerm.Value).Sub(1).Div(State.TimeEachTerm.Value); // Round up
    return periods.Add(treasury.CurrentPeriod);
}
```

**Option 2: Handle Missing Profit Details Gracefully**
Modify `ExtendVoterWelfareProfits` to handle missing profit details by re-creating them:

```csharp
if (extendingDetail != null)
{
    // Update existing detail
    State.ProfitContract.FixProfitDetail.Send(...);
}
else
{
    // Profit detail was already removed but vote is still active
    // Re-create the profit detail with the new end period
    var votesWeight = GetVotesWeight(votingRecord.Amount, lockTime);
    State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
    {
        SchemeId = State.WelfareHash.Value,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = electionVotingRecord.Voter,
            Shares = votesWeight
        },
        EndPeriod = endPeriod,
        ProfitDetailId = voteId
    });
}
```

**Option 3: Prevent Premature Removal**
Modify `ClaimProfits` to not remove profit details if the corresponding vote hasn't fully expired by cross-referencing with `State.LockTimeMap` and vote timestamp.

## Proof of Concept

```csharp
[Fact]
public async Task VoteChangeBlockedByMissingProfitDetail_IntegerDivisionRounding()
{
    // Setup: Create a vote with lock time not divisible by TimeEachTerm
    const long lockTime = 30 * 86400; // 30 days in seconds
    const long timeEachTerm = 7 * 86400; // 7 days in seconds  
    // EndPeriod will be currentPeriod + 4 (28 days), leaving 2 days gap
    
    var voterKeyPair = VoterKeyPairs[0];
    var candidateKeyPair = ValidationDataCenterKeyPairs[0];
    
    // Step 1: Vote for a candidate
    var voteResult = await VoteToCandidateAsync(voterKeyPair, 
        candidateKeyPair.PublicKey.ToHex(), lockTime, 1000);
    var voteId = Hash.Parser.ParseFrom(voteResult.ReturnValue);
    
    // Step 2: Advance time past EndPeriod (28 days) but before full lock expiration (30 days)
    await ProduceBlocks(voterKeyPair, 29 * 86400 / 4); // 29 days worth of blocks
    
    // Step 3: Claim profits (triggers removal of profit detail)
    await ProfitContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = ProfitItemsIds[ProfitType.CitizenWelfare],
        Beneficiary = Address.FromPublicKey(voterKeyPair.PublicKey)
    });
    
    // Verify profit detail was removed
    var profitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(
        new GetProfitDetailsInput
        {
            Beneficiary = Address.FromPublicKey(voterKeyPair.PublicKey),
            SchemeId = ProfitItemsIds[ProfitType.CitizenWelfare]
        });
    profitDetails.Details.Count.ShouldBe(0); // Detail removed
    
    // Step 4: Attempt to change vote target with IsResetVotingTime = true
    var newCandidate = ValidationDataCenterKeyPairs[1].PublicKey.ToHex();
    var electionStub = GetElectionContractTester(voterKeyPair);
    
    var result = await electionStub.ChangeVotingOption.SendAsync(new ChangeVotingOptionInput
    {
        CandidatePubkey = newCandidate,
        VoteId = voteId,
        IsResetVotingTime = true
    });
    
    // Expected: Transaction fails with "Cannot find profit detail of given vote id"
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Cannot find profit detail");
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L29-31)
```csharp
        var actualLockedSeconds = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockingSeconds = State.LockTimeMap[input.VoteId];
        Assert(actualLockedSeconds < claimedLockingSeconds, "This vote already expired.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L33-37)
```csharp
        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L141-159)
```csharp
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L168-185)
```csharp
    private ProfitDetail GetProfitDetailByElectionVotingRecord(ElectionVotingRecord electionVotingRecord)
    {
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
            profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);
        }

        return profitDetail;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L612-616)
```csharp
    private long GetEndPeriod(long lockTime)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        return lockTime.Div(State.TimeEachTerm.Value).Add(treasury.CurrentPeriod);
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-789)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L801-806)
```csharp
        foreach (var profitDetail in profitDetailsToRemove)
        {
            availableDetails.Remove(profitDetail);
        }

        State.ProfitDetailsMap[input.SchemeId][beneficiary] = new ProfitDetails { Details = { availableDetails } };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L908-908)
```csharp
                    lastProfitPeriod = period + 1;
```
