# Audit Report

## Title
Pending Proposals from Removed Proposers Can Still Be Executed After Whitelist Changes

## Summary
The governance contracts (Parliament, Association, and Referendum) validate proposer authorization only at proposal creation time. When a proposer is removed from the whitelist via `ChangeOrganizationProposerWhiteList()`, their pending proposals remain executable because the `Release()` function does not re-validate authorization status, allowing removed proposers to execute previously created proposals and undermining the whitelist security model.

## Finding Description

This vulnerability breaks the fundamental security guarantee that whitelist removal immediately revokes all governance privileges from an address. The issue exists because authorization is validated at two different lifecycle points with inconsistent checks:

**Authorization at Proposal Creation:**

In Parliament, the `CreateProposal` function validates proposer authorization by calling `AssertIsAuthorizedProposer`, which verifies that the proposer is either in the whitelist or is a parliament member with appropriate permissions. [1](#0-0) 

The authorization check implementation confirms the proposer must be in the whitelist or have parliament member authority. [2](#0-1) 

Association follows the same pattern, requiring proposers to be in the organization's whitelist. [3](#0-2) [4](#0-3) 

Referendum also validates proposers against the whitelist at creation time. [5](#0-4) [6](#0-5) 

**Missing Re-validation at Proposal Release:**

The critical flaw occurs in the `Release` function. In Parliament, it only verifies that the caller is the original proposer without re-checking their current authorization status. [7](#0-6) 

Association has the identical vulnerability - Release only checks the caller matches the original proposer. [8](#0-7) 

Referendum also fails to re-validate authorization at release time. [9](#0-8) 

**Whitelist Changes Don't Invalidate Existing Proposals:**

When the whitelist is updated via `ChangeOrganizationProposerWhiteList`, the function simply updates the stored whitelist without any validation or cleanup of pending proposals from removed addresses. [10](#0-9) 

Association follows the same pattern. [11](#0-10) 

Referendum also lacks proposal cleanup on whitelist changes. [12](#0-11) 

**Attack Sequence:**
1. Malicious actor creates proposal while legitimately authorized
2. Governance detects malicious intent and removes actor from whitelist
3. Removed actor cannot create NEW proposals (correctly blocked)
4. However, their OLD proposal continues collecting votes
5. Once approved, removed actor successfully calls `Release()`
6. Proposal executes despite actor no longer being authorized

## Impact Explanation

**High Severity - Governance Authorization Bypass**

This vulnerability directly undermines AElf's governance security model. The whitelist mechanism exists to control proposal privileges, and when an address is removed - typically due to discovered malicious behavior, compromised keys, or loss of trust - the expectation is that ALL governance privileges are immediately revoked.

However, removed proposers retain the ability to execute any proposals created while authorized. This enables:

- **Unauthorized system configuration changes** affecting protocol parameters
- **Fund transfers or treasury manipulation** if proposals target financial contracts  
- **Contract upgrades or deployments** that could introduce malicious code
- **Consensus parameter modifications** affecting chain security
- **Fee structure changes** impacting economic security

The impact spans all three governance contract types:
- **Parliament**: Controls critical system governance and the default organization for protocol-level decisions
- **Association**: Powers multi-signature governance in organizational settings
- **Referendum**: Enables token-weighted community voting

A single compromised proposer can "time-bomb" the system by creating proposals before removal, then executing them afterward to bypass whitelist protection.

## Likelihood Explanation

**Medium-High Likelihood**

The attack requires initial authorization but is otherwise straightforward:

**Attacker Prerequisites:**
- Must be initially authorized (whitelist member or parliament member)
- Represents insider threat or compromised authorized address scenario
- No additional special permissions required

**Attack Execution:**
- Zero cost to maintain pending proposals in contract storage
- Proposals support far-future expiration times
- Uses standard public methods with no blockchain state manipulation
- Cannot be easily detected without manual cross-referencing of pending proposals against whitelist changes

**Economic Rationality:**
Highly rational for malicious actors. Once they suspect removal or after committing malicious acts, they can pre-emptively create proposals. The attack has zero ongoing cost and high potential impact.

The test suite validates that removed proposers cannot create new proposals but does not verify they cannot release existing ones. [13](#0-12) 

## Recommendation

Add authorization re-validation to the `Release` function in all three governance contracts:

**For Parliament:**
```csharp
public override Empty Release(Hash proposalId)
{
    var proposalInfo = GetValidProposal(proposalId);
    Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
    
    // ADD THIS: Re-validate proposer authorization at release time
    AssertIsAuthorizedProposer(proposalInfo.OrganizationAddress, Context.Sender);
    
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    // ... rest of function
}
```

**For Association:**
```csharp
public override Empty Release(Hash input)
{
    var proposalInfo = GetValidProposal(input);
    Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
    
    // ADD THIS: Re-validate proposer authorization at release time
    AssertIsAuthorizedProposer(proposalInfo.OrganizationAddress, Context.Sender);
    
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    // ... rest of function
}
```

**For Referendum:**
```csharp
public override Empty Release(Hash input)
{
    var proposal = GetValidProposal(input);
    Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
    
    // ADD THIS: Re-validate proposer authorization at release time
    AssertIsAuthorizedProposer(proposal.OrganizationAddress, Context.Sender);
    
    var organization = State.Organizations[proposal.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
    // ... rest of function
}
```

This ensures that proposer authorization is validated both at creation AND execution time, closing the authorization bypass window.

## Proof of Concept

```csharp
[Fact]
public async Task RemovedProposer_CanStillReleaseOldProposal_Test()
{
    // Setup: Create organization with Reviewer1 in whitelist
    var organizationAddress = await CreateOrganizationAsync(
        minimalApproveThreshold: 1, 
        minimalVoteThreshold: 1,
        maximalAbstentionThreshold: 1,
        maximalRejectionThreshold: 1,
        Reviewer1);
    
    // Reviewer1 creates a proposal while authorized
    var proposalInput = new CreateProposalInput
    {
        ContractMethodName = "SomeMethod",
        ToAddress = TokenContractAddress,
        Params = ByteString.Empty,
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(7),
        OrganizationAddress = organizationAddress
    };
    
    var associationStub = GetAssociationContractTester(Reviewer1KeyPair);
    var proposalId = await associationStub.CreateProposal.SendAsync(proposalInput);
    proposalId.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var createdProposalId = Hash.Parser.ParseFrom(proposalId.TransactionResult.ReturnValue);
    
    // Approve the proposal
    await associationStub.Approve.SendAsync(createdProposalId);
    
    // Governance removes Reviewer1 from whitelist
    var newWhitelist = new ProposerWhiteList { Proposers = { Reviewer2 } };
    var changeProposalId = await CreateAssociationProposalAsync(
        Reviewer1KeyPair, 
        newWhitelist,
        nameof(associationStub.ChangeOrganizationProposerWhiteList), 
        organizationAddress);
    await ApproveAsync(Reviewer1KeyPair, changeProposalId);
    var changeResult = await associationStub.Release.SendAsync(changeProposalId);
    changeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify Reviewer1 cannot create NEW proposals
    var newProposalResult = await associationStub.CreateProposal.SendWithExceptionAsync(proposalInput);
    newProposalResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    newProposalResult.TransactionResult.Error.ShouldContain("Unauthorized to propose");
    
    // VULNERABILITY: Reviewer1 CAN still release their OLD proposal
    var releaseResult = await associationStub.Release.SendAsync(createdProposalId);
    
    // This should fail but currently succeeds - demonstrating the vulnerability
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

This test demonstrates that after being removed from the whitelist, a proposer can no longer create new proposals (correctly blocked) but can still release proposals they created before removal (vulnerability).

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L162-177)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var defaultOrganizationAddress = State.DefaultOrganizationAddress.Value;
        Assert(defaultOrganizationAddress == Context.Sender, "No permission.");
        var organization = State.Organizations[defaultOrganizationAddress];
        Assert(
            input.Proposers.Count > 0 || !organization.ProposerAuthorityRequired ||
            organization.ParliamentMemberProposingAllowed, "White list can't be empty.");
        State.ProposerWhiteList.Value = input;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L790-839)
```csharp
    public async Task Change_OrganizationProposalWhitelist_Test()
    {
        var minimalApproveThreshold = 1;
        var minimalVoteThreshold = 1;
        var maximalAbstentionThreshold = 1;
        var maximalRejectionThreshold = 1;
        var organizationAddress = await CreateOrganizationAsync(minimalApproveThreshold, minimalVoteThreshold,
            maximalAbstentionThreshold, maximalRejectionThreshold, Reviewer1);

        var proposerWhiteList = new ProposerWhiteList
        {
            Proposers = { Reviewer2 }
        };

        var associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
        var changeProposalId = await CreateAssociationProposalAsync(Reviewer1KeyPair, proposerWhiteList,
            nameof(associationContractStub.ChangeOrganizationProposerWhiteList), organizationAddress);
        await ApproveAsync(Reviewer1KeyPair, changeProposalId);
        var releaseResult = await associationContractStub.Release.SendAsync(changeProposalId);
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        await TransferToOrganizationAddressAsync(organizationAddress);
        var transferInput = new TransferInput
        {
            Symbol = "ELF",
            Amount = 100,
            To = Reviewer1,
            Memo = "Transfer"
        };
        associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
        var createProposalInput = new CreateProposalInput
        {
            ContractMethodName = nameof(TokenContractStub.Approve),
            ToAddress = TokenContractAddress,
            Params = transferInput.ToByteString(),
            ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(2),
            OrganizationAddress = organizationAddress
        };
        var result = await associationContractStub.CreateProposal.SendWithExceptionAsync(createProposalInput);
        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        result.TransactionResult.Error.ShouldContain("Unauthorized to propose.");

        //Verify association proposal
        var verifyResult = await associationContractStub.ValidateProposerInWhiteList.CallAsync(
            new ValidateProposerInWhiteListInput
            {
                OrganizationAddress = organizationAddress,
                Proposer = Reviewer2
            });
        verifyResult.Value.ShouldBeTrue();
    }
```
