# Audit Report

## Title
Missing TermNumber Validation in NextRound Allows Consensus Time Slot Bypass

## Summary
The AEDPoS consensus contract fails to validate the `TermNumber` field during `NextRound` transitions. A malicious miner can craft a `NextRoundInput` with an incorrect `TermNumber` that bypasses validation, gets stored in state, and subsequently causes time slot checks to be incorrectly bypassed, allowing miners to produce blocks outside their assigned schedule.

## Finding Description

The vulnerability exists in the validation pipeline for `NextRound` consensus behavior, where `TermNumber` validation is completely omitted.

**Root Cause:**

The `ToRound()` method performs no validation and blindly copies all fields including `TermNumber`: [1](#0-0) 

The pre-execution validation for `NextRound` only checks `RoundNumber` increment and `InValue` nullity, completely omitting `TermNumber` validation: [2](#0-1) 

In contrast, `NextTerm` validation explicitly checks that `TermNumber` increments by exactly 1: [3](#0-2) 

During normal operation, `GenerateNextRoundInformation` correctly keeps `TermNumber` unchanged: [4](#0-3) 

**Execution Path:**

1. A malicious miner includes consensus extra data with wrong `TermNumber` in their block, which calls the public `NextRound` method: [5](#0-4) 

2. `ProcessNextRound` converts the unvalidated input and stores it, only updating `RoundNumber` (NOT `TermNumber`): [6](#0-5) 

Compare this to `ProcessNextTerm` which explicitly updates BOTH `TermNumber` and `RoundNumber`: [7](#0-6) 

3. The manipulated Round is stored with incorrect `TermNumber`: [8](#0-7) 

4. During subsequent block validation, the stored Round with wrong `TermNumber` becomes the `PreviousRound`: [9](#0-8) 

5. The validation context is built with the manipulated `PreviousRound` and the correct global `CurrentTermNumber`: [10](#0-9) 

6. Time slot validation checks if it's the first round of a term, which incorrectly returns true when `PreviousRound.TermNumber` differs from `CurrentTermNumber`: [11](#0-10) 

When the check at line 56 detects `PreviousRound.TermNumber != termNumber`, it returns true, causing line 39 to bypass all time slot validation.

## Impact Explanation

This vulnerability breaks the fundamental consensus invariant of time slot validation. The AEDPoS consensus mechanism assigns specific time windows to each miner to ensure fair, distributed block production. By bypassing time slot checks, a malicious miner can:

1. **Violate Consensus Schedule**: Produce blocks outside their assigned time slot, breaking the deterministic mining order
2. **Monopolize Block Production**: Continuously mine blocks during other miners' time slots across multiple rounds
3. **Gain Unfair Economic Advantage**: Collect more block rewards and transaction fees than legitimately entitled
4. **Create State Inconsistency**: Stored Round objects have incorrect TermNumbers that diverge from the global `State.CurrentTermNumber`, violating data integrity
5. **Undermine Decentralization**: Centralize block production power, compromising network security

The impact is significant as it allows elected miners to bypass core consensus timing constraints that ensure fair block production scheduling.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a valid miner in the current round (verified by `PreCheck()`)
- This is realistic as miners are selected through the public election/staking mechanism

**Attack Complexity:**
The attack is straightforward:
1. Craft a `NextRoundInput` with `RoundNumber = currentRoundNumber + 1` (valid) and `TermNumber = currentTermNumber + 1` (invalid but unchecked)
2. Populate other required fields correctly
3. Include this in the consensus extra data when producing a block
4. The invalid `TermNumber` passes all validations and gets stored in state
5. Subsequent rounds experience bypassed time slot validation

**Feasibility:**
- No special privileges beyond being an elected miner
- No economic cost beyond standard transaction fees
- Immediately exploitable once in the miner list
- Difficult to detect as the global `State.CurrentTermNumber` remains correct while individual Round objects are corrupted

The likelihood is high as any malicious miner can exploit this without additional barriers.

## Recommendation

Add `TermNumber` validation to the `NextRound` validation pipeline, ensuring it remains unchanged from the current round:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Validate RoundNumber increment
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // ADD THIS: Validate TermNumber remains unchanged
    if (validationContext.BaseRound.TermNumber != extraData.Round.TermNumber)
        return new ValidationResult { Message = "TermNumber must remain unchanged during NextRound." };
    
    // Validate InValue nullity
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

## Proof of Concept

A proof of concept would involve:

1. Setting up an AEDPoS test environment with multiple miners
2. Having one miner craft a `NextRoundInput` with:
   - `RoundNumber = currentRound.RoundNumber + 1` (valid)
   - `TermNumber = currentRound.TermNumber + 1` (invalid)
   - All other fields populated correctly
3. Calling `NextRound` with this crafted input
4. Verifying the round is stored with the incorrect `TermNumber`
5. In the next round, demonstrating that `IsFirstRoundOfCurrentTerm` incorrectly returns true
6. Showing that time slot validation is bypassed, allowing blocks to be produced outside assigned time slots

The test would confirm that the manipulated `TermNumber` persists in state and causes validation bypass in subsequent rounds.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-24)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-175)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L56-64)
```csharp
    private bool TryToGetPreviousRoundInformation(out Round previousRound)
    {
        previousRound = new Round();
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        if (roundNumber < 2) return false;
        var targetRoundNumber = roundNumber.Sub(1);
        previousRound = State.Rounds[targetRoundNumber];
        return !previousRound.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-106)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-58)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }

    private bool IsFirstRoundOfCurrentTerm(out long termNumber, ConsensusValidationContext validationContext)
    {
        termNumber = validationContext.CurrentTermNumber;
        return validationContext.PreviousRound.TermNumber != termNumber ||
               validationContext.CurrentRoundNumber == 1;
    }
```
