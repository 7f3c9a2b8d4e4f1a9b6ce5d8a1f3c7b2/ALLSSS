# Audit Report

## Title
Predictable NFT Symbol Generation Allows Miner Manipulation via Known Block Height Random Seed

## Summary
The NFT contract's symbol generation mechanism uses a random seed from the previous block (H-1) that is already finalized and publicly accessible on-chain when miners are building block H. This allows miners to predict the exact NFT symbol that will be generated for any pending transaction and selectively censor, delay, or front-run transactions to monopolize valuable NFT symbols.

## Finding Description

The vulnerability exists in the NFT symbol generation where the random seed is deterministic and known before transaction inclusion decisions are made.

When the `Create` method is called to create a new NFT protocol, it invokes `GetSymbol`, which calls `GenerateSymbolNumber()`. [1](#0-0) [2](#0-1) 

The `GenerateSymbolNumber()` function retrieves random bytes using the block height from the previous block (H-1): [3](#0-2) 

The random hash for height H-1 is generated and stored during consensus transaction execution using EC-VRF verification: [4](#0-3) 

The random hash is stored in `State.RandomHashes`, which is a public mapping accessible through the `GetRandomHash` view method with no authorization checks: [5](#0-4) 

Block execution order confirms that system transactions (including consensus transactions) execute before user transactions: [6](#0-5) 

**Root Cause**: When a miner is building block H, the random hash for H-1 has already been finalized and stored during H-1's execution. The symbol generation deterministically combines this known random hash with the known sender address: [7](#0-6) 

The conversion to a numeric symbol is deterministic: [8](#0-7) 

**Attack Scenario**:
1. User Alice submits an NFT Create transaction to the mempool
2. Miner Bob is building block H
3. Bob reads `State.RandomHashes[H-1]` via the public `GetRandomHash` method
4. Bob simulates Alice's transaction: `symbol = Hash(Alice.Address, RandomHash[H-1])`
5. If the symbol is valuable (e.g., "AR0001"), Bob can:
   - Exclude Alice's transaction from block H
   - Submit his own transaction to claim that symbol first
   - Delay Alice's transaction until less valuable symbols are available

## Impact Explanation

**Direct Impact**:
- **Unfair Symbol Allocation**: Certain NFT symbols have inherently higher market value (e.g., lower numbers like "AR0001" vs "AR9999", memorable patterns). Miners can monopolize these valuable symbols for themselves or allies.
- **Censorship Attack**: Miners can indefinitely delay transactions that would generate desirable symbols, preventing legitimate users from obtaining them.
- **Front-Running**: Miners can observe pending NFT creation transactions, identify which would generate valuable symbols, and submit their own transactions first to claim those symbols.

**Who Is Affected**:
- All users attempting to create NFT protocols via the `Create` method
- The NFT protocol's fairness and market integrity
- Users who lose the ability to fairly compete for desirable symbols

**Severity Justification**: HIGH severity because:
1. Miners have complete predictability and control over symbol assignment
2. Attack is passive (requires only transaction simulation using publicly available data)
3. Strong economic incentive exists when certain symbols command premium market prices
4. Users cannot defend against this manipulation
5. No on-chain detection mechanism exists to identify censorship

## Likelihood Explanation

**Attacker Capabilities**: 
- Only requires being a block producer (miner) in the AEDPoS consensus
- No special privileges beyond normal mining capabilities
- Attack involves passive observation and transaction selection

**Attack Complexity**: LOW
- Miners can trivially simulate NFT creation transactions before including them
- Random hash for H-1 is publicly readable via the `GetRandomHash` view method
- No complex cryptographic attacks or state manipulation required
- Simple deterministic calculation

**Feasibility Conditions**:
- Occurs naturally during normal block production
- No additional setup or preconditions needed
- Works on every block where NFT creation transactions are present
- Economic incentive aligns with rational profit-seeking miner behavior

**Detection/Operational Constraints**:
- Censorship appears as normal transaction pool dynamics
- Front-running is observable but not provably malicious (indistinguishable from legitimate transaction)
- No on-chain evidence distinguishes malicious censorship from network congestion
- Victims cannot prove intentional manipulation

**Probability**: HIGH - Any rational profit-seeking miner will exploit this when valuable symbols are at stake, especially for patterns that command premium prices in secondary markets.

## Recommendation

Implement commit-reveal scheme or use future block randomness:

**Option 1: Commit-Reveal Scheme**
- Users commit to a hidden nonce when creating NFT
- Symbol is generated using: `Hash(Sender, RandomHash[H], UserNonce)`
- Prevents miners from predicting outcome without knowing user's nonce

**Option 2: Future Block Randomness**
- Use `Context.CurrentHeight + N` (where N > 0) for random seed
- Random hash for block H+N is unknown when transaction is included in block H
- Requires delayed symbol finalization but prevents prediction

**Option 3: Per-Transaction Randomness**
- Incorporate transaction hash into symbol generation
- Use: `Hash(Sender, RandomHash[H-1], TxHash)`
- Transaction hash cannot be predicted by miners before inclusion

## Proof of Concept

```csharp
// Miner exploitation simulation (not executable test, but demonstrates the attack)
// 
// 1. Miner observes pending NFT Create transaction from Alice
// 2. Miner reads the previous block's random hash (publicly available)
var randomHashForPreviousBlock = consensusContract.GetRandomHash(currentHeight - 1);

// 3. Miner simulates Alice's transaction locally
var aliceAddress = GetAddressFromPendingTransaction(aliceTx);
var simulatedRandomBytes = consensusContract.GetRandomBytes(currentHeight - 1);
var simulatedHash = HashHelper.ConcatAndCompute(
    HashHelper.ComputeFrom(aliceAddress),
    HashHelper.ComputeFrom(simulatedRandomBytes)
);
var predictedSymbol = ConvertHashToInt64(simulatedHash, from, to);
var fullSymbol = $"AR{predictedSymbol}"; // e.g., "AR0001"

// 4. Miner makes decision
if (IsValuableSymbol(fullSymbol)) {
    // Exclude Alice's transaction and submit own transaction
    SubmitOwnNFTCreateTransaction();
    DelayTransaction(aliceTx);
} else {
    // Include Alice's transaction normally
    IncludeTransaction(aliceTx);
}
```

The vulnerability is demonstrated by the fact that all inputs to the symbol generation are known to the miner before the transaction is included in a block, making the outcome 100% predictable.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L20-20)
```csharp
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-26)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L71-74)
```csharp
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L75-77)
```csharp
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L78-82)
```csharp
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L117-122)
```csharp
    public override Hash GetRandomHash(Int64Value input)
    {
        Assert(input.Value > 1, "Invalid block height.");
        Assert(Context.CurrentHeight >= input.Value, "Block height not reached.");
        return State.RandomHashes[input.Value] ?? Hash.Empty;
    }
```

**File:** src/AElf.Kernel.SmartContractExecution/Application/BlockExecutingService.cs (L58-64)
```csharp
        var nonCancellable = nonCancellableTransactions.ToList();
        var cancellable = cancellableTransactions.ToList();
        var nonCancellableReturnSets =
            await _transactionExecutingService.ExecuteAsync(
                new TransactionExecutingDto { BlockHeader = blockHeader, Transactions = nonCancellable },
                CancellationToken.None);
        Logger.LogTrace("Executed non-cancellable txs");
```
