# Audit Report

## Title
Delegation Slot Exhaustion via Unconsumed Zero-Value Non-Unlimited Delegatees

## Summary
The `ModifyDelegation` function in transaction fee charging does not remove delegatee entries when delegation amounts are consumed to zero, creating "zombie" delegatees that persist with zero-value entries. Since there is a hard limit of 24 delegatees per delegator, these zombies can exhaust all available slots, permanently blocking users from adding new valid delegatees until manual cleanup.

## Finding Description
The vulnerability stems from a critical inconsistency between delegation state management in `SetTransactionFeeDelegateInfos` and `ModifyDelegation`.

In `SetTransactionFeeDelegateInfos`, there is a validation requiring non-unlimited delegations to have at least one entry [1](#0-0) , and a cleanup mechanism that removes delegatees when the delegations dictionary becomes empty [2](#0-1) .

However, when transaction fees are charged from delegations, the `ModifyDelegation` function only performs subtraction operations without removing entries that reach zero [3](#0-2)  and [4](#0-3) . After a delegation amount is fully consumed, the dictionary entry persists with value 0. Since the cleanup check only triggers when `Delegations.Count == 0` (empty dictionary), but not when entries exist with zero values (`Count > 0`), these "zombie" delegatees remain indefinitely.

The system enforces a hard limit of 24 delegatees per delegator-contract-method combination [5](#0-4)  and [6](#0-5) . When all 24 slots are occupied by zombie delegatees, the assertion prevents adding any new delegatees.

In contrast, manual update operations through `UpdateDelegateInfo` properly remove zero-value entries [7](#0-6) , demonstrating that the cleanup logic exists elsewhere but is missing from the automatic fee charging path.

## Impact Explanation
**Denial of Service Impact:**
- When all 24 delegatee slots contain exhausted delegations with zero-value entries, users cannot add new valid delegatees because the count check fails
- The delegation feature becomes permanently unavailable until manual cleanup
- Users must identify each zombie delegatee individually and call `RemoveTransactionFeeDelegateeInfos` or `RemoveTransactionFeeDelegatorInfos` for cleanup, incurring gas costs

**Affected Parties:**
- Delegators who actively use delegations for transaction fee payment
- Legitimate delegatees who cannot be added when slots are exhausted
- DApp users relying on delegation functionality

**Storage & Operational Impact:**
- Persistent storage bloat from useless zero-value entries
- Additional gas expenditure for manual cleanup operations
- Poor user experience with cryptic "delegatee limit reached" errors

This is **HIGH severity** because it causes operational DoS of a core token contract feature during normal usage (no attacker required), and the 24-slot limit makes exhaustion practically achievable through regular transaction fee consumption.

## Likelihood Explanation
**Occurrence Probability:** Very High
- Occurs automatically during normal transaction fee charging when delegations are consumed
- No malicious actor required - happens to regular users as they pay fees
- The more actively delegations are used, the faster slots fill with zombies
- Each delegation that gets fully consumed creates a permanent zombie until manual cleanup

**Feasibility:**
- Entry point: Automatic transaction fee charging via `ChargeTransactionFees`
- No special permissions required
- No economic cost beyond normal transaction fees
- State persists indefinitely until manual intervention

**Detection Difficulty:**
- Users may not realize their slots are filled with zero-value entries
- No automatic notification or self-healing mechanism
- Manifests as confusing assertion failures when attempting to add new delegatees

## Recommendation
Modify the `ModifyDelegation` function to include cleanup logic that removes delegation entries when they reach zero and removes delegatees when all their delegations are exhausted:

```csharp
private void ModifyDelegation(TransactionFeeBill bill, TransactionFreeFeeAllowanceBill allowanceBill,
    Address delegateeAddress, Address contractAddress, string methodName, Address delegatorAddress)
{
    var delegateInfo = State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] ??
        State.TransactionFeeDelegateesMap[delegatorAddress];
    
    foreach (var (symbol, amount) in bill.FeesMap)
    {
        if (amount <= 0) continue;
        var newAmount = delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol].Sub(amount);
        if (newAmount <= 0)
        {
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations.Remove(symbol);
        }
        else
        {
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol] = newAmount;
        }
    }

    foreach (var (symbol, amount) in allowanceBill.FreeFeeAllowancesMap)
    {
        if (amount <= 0) continue;
        var newAmount = delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol].Sub(amount);
        if (newAmount <= 0)
        {
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations.Remove(symbol);
        }
        else
        {
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol] = newAmount;
        }
    }
    
    // Clean up delegatee if all delegations exhausted
    if (delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations.Count == 0 &&
        !delegateInfo.Delegatees[delegateeAddress.ToBase58()].IsUnlimitedDelegate)
    {
        delegateInfo.Delegatees.Remove(delegateeAddress.ToBase58());
    }
}
```

This matches the cleanup behavior already present in `UpdateDelegateInfo` and ensures consistency across all delegation modification paths.

## Proof of Concept
```csharp
[Fact]
public async Task DelegationSlotExhaustion_ZombieEntries_Test()
{
    // Setup: Create delegator and 24 delegatees, set up delegations that will be consumed
    var delegator = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[0].PublicKey);
    var contractAddress = TokenContractAddress;
    var methodName = nameof(TokenContract.Transfer);
    
    // Set up 24 delegatees each with exactly 100 tokens delegation
    for (int i = 1; i <= 24; i++)
    {
        var delegatee = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[i].PublicKey);
        await TokenContractStub.SetTransactionFeeDelegateInfos.SendAsync(new SetTransactionFeeDelegateInfosInput
        {
            DelegatorAddress = delegator,
            DelegateInfoList = {
                new DelegateInfo {
                    ContractAddress = contractAddress,
                    MethodName = methodName,
                    Delegations = { { "ELF", 100 } },
                    IsUnlimitedDelegate = false
                }
            }
        });
        
        // Consume exactly 100 tokens through fee charging to create zombie
        // (Fee charging logic that consumes all delegation)
    }
    
    // Verify: All 24 slots occupied by zombies with zero-value entries
    var delegateeList = await TokenContractStub.GetTransactionFeeDelegateeList.CallAsync(
        new GetTransactionFeeDelegateeListInput {
            DelegatorAddress = delegator,
            ContractAddress = contractAddress,
            MethodName = methodName
        });
    delegateeList.DelegateeAddresses.Count.ShouldBe(24);
    
    // Attempt to add 25th delegatee - should fail with "delegatee limit reached"
    var newDelegatee = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[25].PublicKey);
    var result = await TokenContractStub.SetTransactionFeeDelegateInfos.SendAsync(new SetTransactionFeeDelegateInfosInput
    {
        DelegatorAddress = delegator,
        DelegateInfoList = {
            new DelegateInfo {
                ContractAddress = contractAddress,
                MethodName = methodName,
                Delegations = { { "ELF", 1000 } },
                IsUnlimitedDelegate = false
            }
        }
    });
    
    result.TransactionResult.Error.ShouldContain("The quantity of delegatee has reached its limit");
}
```

## Notes
This vulnerability represents a state management inconsistency where the automatic fee charging path (`ModifyDelegation`) lacks the cleanup logic present in manual update paths (`UpdateDelegateInfo`). The issue is exacerbated by the fixed 24-delegatee limit, making it a practical DoS vector during normal operations rather than a theoretical edge case.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L209-210)
```csharp
            Assert(delegateInfo.IsUnlimitedDelegate || delegateInfo.Delegations.Count > 0,
                "Delegation cannot be null.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L226-227)
```csharp
                Assert(existDelegateeList.Count < TokenContractConstants.DELEGATEE_MAX_COUNT,
                    "The quantity of delegatee has reached its limit");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L233-242)
```csharp
            if (existDelegateeInfoList.Delegatees[delegateeAddress].Delegations.Count == 0 &&
                !existDelegateeInfoList.Delegatees[delegateeAddress].IsUnlimitedDelegate)
            {
                existDelegateeInfoList.Delegatees.Remove(delegateeAddress);
                toCancelTransactionList.Value.Add(new DelegateTransaction
                {
                    ContractAddress = delegateInfo.ContractAddress,
                    MethodName = delegateInfo.MethodName
                });
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L284-288)
```csharp
                if (existDelegation.ContainsKey(symbol))
                {
                    if (amount <= 0)
                    {
                        existDelegation.Remove(symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L215-223)
```csharp
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            var delegateInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] ??
                State.TransactionFeeDelegateesMap[delegatorAddress];
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol] =
                delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol].Sub(amount);
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L225-234)
```csharp
        foreach (var (symbol, amount) in allowanceBill.FreeFeeAllowancesMap)
        {
            if (amount <= 0) continue;

            var delegateInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] ??
                State.TransactionFeeDelegateesMap[delegatorAddress];
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol] =
                delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol].Sub(amount);
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L18-18)
```csharp
    public const int DELEGATEE_MAX_COUNT = 24;
```
