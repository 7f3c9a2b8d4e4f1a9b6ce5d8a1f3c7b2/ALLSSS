# Audit Report

## Title
RoundId Manipulation Bypasses Time Slot Validation in NextRound Consensus Transitions

## Summary
A malicious miner can craft a NextRound transition with manipulated `ExpectedMiningTime` values that sum to equal the current `BaseRound.RoundId`, causing the `TimeSlotValidationProvider` to skip critical time slot equality checks. This allows acceptance of consensus rounds with arbitrary, unequal time slots, breaking the core AEDPoS scheduling invariant and potentially halting block production.

## Finding Description

The AEDPoS consensus mechanism enforces equal time slot distribution among miners through the `CheckRoundTimeSlots()` validation. However, a critical flaw in the `TimeSlotValidationProvider` allows this validation to be bypassed.

**Root Cause:**

The `RoundId` property is computed as the sum of all miners' `ExpectedMiningTime.Seconds` values: [1](#0-0) 

The `TimeSlotValidationProvider` uses RoundId equality to determine whether the provided round is a new round: [2](#0-1) 

When `ProvidedRound.RoundId == BaseRound.RoundId`, the validation assumes it's the same round and skips `CheckRoundTimeSlots()`, only validating the individual miner's time slot.

**Attack Mechanism:**

1. A malicious miner calculates the current `BaseRound.RoundId` (publicly readable state)
2. When producing a NextRound block, instead of using legitimate consensus extra data, the miner crafts malicious `NextRoundInput` where:
   - `RoundNumber` = current + 1 (passes `RoundTerminateValidationProvider`)
   - All `InValue` fields are null (passes `RoundTerminateValidationProvider`)
   - `ExpectedMiningTime` values are manipulated to sum exactly to `BaseRound.RoundId`
   - Example: 16 miners with 1 second each, 1 miner with 28,899,999,984 seconds

3. During validation via `ValidateBeforeExecution`: [3](#0-2) 

4. The `RoundTerminateValidationProvider` only checks round number increment and InValue nullity, not ExpectedMiningTime values: [4](#0-3) 

5. The `TimeSlotValidationProvider` sees equal RoundIds and bypasses the critical `CheckRoundTimeSlots()` method, which would normally reject unequal intervals: [5](#0-4) 

6. No other validation provider checks `ExpectedMiningTime` reasonableness: [6](#0-5) 

7. After validation passes, the malicious round is stored in state: [7](#0-6) 

**Invariant Violation:**

Legitimate round generation enforces equal time slots by using a constant mining interval: [8](#0-7) 

The attack bypasses this invariant entirely.

## Impact Explanation

**Consensus Integrity Violation:**

The accepted malicious round has arbitrary, unequal time slots that violate the fundamental AEDPoS invariant of equal time distribution among miners. This breaks the consensus scheduling mechanism that all miners rely on to determine when to produce blocks.

**Concrete Harms:**

1. **Consensus Disruption**: Miners assigned compressed time slots (e.g., 1-second intervals) cannot physically produce blocks within their allocated time, while the attacker with an extended slot (e.g., 28 billion seconds) effectively monopolizes block production for an extended period

2. **Chain Halt Risk**: If multiple critical miners receive invalid time slots, consensus may fail to progress through rounds, halting the chain until manual intervention

3. **Reward Manipulation**: Unequal time slots enable unfair distribution of block production opportunities and mining rewards, as the attacker can produce more blocks than intended by the protocol

4. **Cascading Failures**: Subsequent rounds may be built on the malicious round, inheriting broken timing assumptions that persist across multiple rounds

**Affected Parties:**
- All network participants experience consensus breakdown
- Honest miners cannot fulfill their block production duties
- Users face degraded or halted transaction finality
- Chain liveness depends on attacker behavior

**Severity Justification**: HIGH - This directly compromises a core consensus invariant with practical exploitation requiring only standard miner privileges, and can result in chain halt.

## Likelihood Explanation

**Attacker Requirements:**
- Must be a current miner (obtainable through standard election process)
- Must mine during their valid time slot to trigger NextRound

**Attack Complexity**: LOW
- Simple arithmetic to calculate target RoundId sum from publicly readable state
- No cryptographic breaking required
- No race conditions or precise timing coordination needed
- Single transaction execution via the public `NextRound` method: [9](#0-8) 

**Feasibility:**

Miners control their own block production and can craft arbitrary consensus extra data. While legitimate data is generated via `GetConsensusExtraDataForNextRound`: [10](#0-9) 

The miner can bypass this and provide malicious data directly in the block header, which is then validated via `ValidateConsensusBeforeExecution`: [11](#0-10) 

**Probability Assessment**: HIGH - Any malicious miner can execute this attack during their assigned time slot with near certainty, limited only by normal consensus flow constraints.

## Recommendation

Implement direct validation of `ExpectedMiningTime` values in the validation flow:

1. **Option 1**: Always validate time slots for NextRound regardless of RoundId equality. Modify `TimeSlotValidationProvider` to remove the RoundId equality bypass for NextRound behavior.

2. **Option 2**: Add explicit validation that all `ExpectedMiningTime` values in NextRound are within reasonable bounds and maintain equal intervals. This could be added to `RoundTerminateValidationProvider` or a new dedicated provider.

3. **Option 3**: Verify that the provided round matches the round that would be generated by the legitimate `GenerateNextRoundInformation` method, rejecting any deviations.

**Recommended Fix** (Option 1 - most direct):

Modify `TimeSlotValidationProvider.ValidateHeaderInformation` to always check time slots for NextRound:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    // For NextRound, always validate time slots regardless of RoundId
    if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.NextRound)
    {
        validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
        if (!validationResult.Success) return validationResult;
    }
    else if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
    {
        // For other behaviors, check time slots if new round
        validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
        if (!validationResult.Success) return validationResult;
    }
    else
    {
        // Validate individual miner time slot
        if (!CheckMinerTimeSlot(validationContext))
        {
            validationResult.Message = 
                $"Time slot already passed before execution.{validationContext.SenderPubkey}";
            validationResult.IsReTrigger = true;
            return validationResult;
        }
    }

    validationResult.Success = true;
    return validationResult;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task RoundIdManipulation_BypassesTimeSlotValidation()
{
    // Setup: Initialize consensus with legitimate round
    await InitializeConsensusAsync();
    var currentRound = await GetCurrentRoundAsync();
    var currentRoundId = currentRound.RoundId; // Sum of legitimate ExpectedMiningTime values
    
    // Attacker: Current miner crafts malicious NextRoundInput
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RealTimeMinersInformation = { }
    };
    
    // Manipulate ExpectedMiningTime to sum to current RoundId
    var minerKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
    for (int i = 0; i < minerKeys.Count - 1; i++)
    {
        maliciousNextRound.RealTimeMinersInformation[minerKeys[i]] = new MinerInRound
        {
            Pubkey = minerKeys[i],
            Order = i + 1,
            ExpectedMiningTime = new Timestamp { Seconds = 1 }, // 1 second slot
            InValue = null // Required to pass RoundTerminateValidationProvider
        };
    }
    
    // Last miner gets extended time to make RoundId sum equal
    var lastMiner = minerKeys.Last();
    var compensationSeconds = currentRoundId - (minerKeys.Count - 1);
    maliciousNextRound.RealTimeMinersInformation[lastMiner] = new MinerInRound
    {
        Pubkey = lastMiner,
        Order = minerKeys.Count,
        ExpectedMiningTime = new Timestamp { Seconds = compensationSeconds },
        InValue = null
    };
    
    // Execute: Call NextRound with malicious input
    var result = await ConsensusStub.NextRound.SendAsync(maliciousNextRound);
    
    // Verify: Attack succeeded - malicious round accepted
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var newRound = await GetCurrentRoundAsync();
    newRound.RoundNumber.ShouldBe(currentRound.RoundNumber + 1);
    
    // Verify: Time slots are unequal (invariant violated)
    var timeSlots = newRound.RealTimeMinersInformation.Values
        .OrderBy(m => m.Order)
        .Select(m => m.ExpectedMiningTime.Seconds)
        .ToList();
    
    // Most miners have 1 second slots, last miner has billions of seconds
    timeSlots.Take(timeSlots.Count - 1).ShouldAllBe(t => t == 1);
    timeSlots.Last().ShouldBeGreaterThan(1000000); // Massively extended slot
    
    // This violates the equal time slot invariant and disrupts consensus
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-104)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }

        var service = new HeaderInformationValidationService(validationProviders);

        Context.LogDebug(() => $"Validating behaviour: {extraData.Behaviour.ToString()}");

        var validationResult = service.ValidateInformation(validationContext);

        if (validationResult.Success == false)
            Context.LogDebug(() => $"Consensus Validation before execution failed : {validationResult.Message}");

        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-56)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```
