# Audit Report

## Title
Voluntary Key Rotation Bypasses Performance Penalties in Miner Reward Distribution

## Summary
The Treasury contract's `UpdateBasicMinerRewardWeights` function incorrectly allows miners to bypass quadratic performance penalties by rotating their public key before reward distribution. The `IsReplacedEvilMiner` flag, which should only apply to miners replacing genuinely evil nodes, is unconditionally set during voluntary key rotations, enabling underperforming miners to receive 100-150% excess rewards.

## Finding Description

The Treasury contract implements a performance-based reward system where the `UpdateBasicMinerRewardWeights` function calculates reward shares using `CalculateShares`, which imposes quadratic penalties on miners producing fewer than 80% of average blocks. [1](#0-0) 

However, miners with the `IsReplacedEvilMiner` flag bypass this penalty entirely and receive their raw `ProducedBlocks` count as shares. [2](#0-1) 

The critical flaw is that `RecordMinerReplacement` unconditionally sets this flag for ALL miner replacements, regardless of whether the replacement is for an evil miner or a voluntary key rotation. [3](#0-2) 

When a candidate admin voluntarily rotates their key via `ReplaceCandidatePubkey`, the Election contract calls `PerformReplacement`, which triggers the AEDPoS contract's `RecordCandidateReplacement`. [4](#0-3) 

The AEDPoS contract then transfers the entire `MinerInRound` object (including the `ProducedBlocks` count) to the new pubkey and notifies the Treasury contract. [5](#0-4) 

In stark contrast, when evil miners are automatically replaced during round generation, the system creates a fresh `MinerInRound` object with default values (ProducedBlocks = 0) and never calls `RecordMinerReplacement`. [6](#0-5) 

The only access control for `ReplaceCandidatePubkey` is a check that the sender is the candidate admin—there are no performance thresholds, timing restrictions, or cooldown periods. [7](#0-6) 

## Impact Explanation

This vulnerability directly violates the protocol's economic invariant that miners must maintain reliable block production to receive proportional rewards. The quadratic penalty formula ensures miners producing 50-80% of average blocks receive significantly reduced shares.

**Concrete Impact:**
- A miner producing 200 blocks (average 400) normally receives 100 shares via the penalty formula (200²/400)
- After key rotation, they receive 200 shares directly (100% excess reward)
- A miner producing 160 blocks (average 400) normally receives 64 shares (160²/400)
- After rotation, they receive 160 shares (150% excess reward)

This misallocates Treasury funds intended for high-performing miners to underperforming ones, diluting rewards for honest miners and undermining consensus security incentives. Over multiple terms, strategic key rotations by underperforming miners cause cumulative protocol fund loss.

## Likelihood Explanation

**Attack Prerequisites:**
1. Candidate is an active miner producing below-average blocks
2. Candidate admin has authority to call `ReplaceCandidatePubkey` (set during candidate announcement)
3. Zero timing restrictions—rotation can occur at any point

**Execution Complexity:** Single transaction with no special conditions or external dependencies.

**Economic Incentive:** Zero cost beyond gas fees, with guaranteed profit equal to the bypassed penalty. For a miner at 50% performance, this doubles their reward with no detection risk. The key rotation appears legitimate (standard operational practice), making malicious intent indistinguishable from security-motivated key management.

**Attacker Profile:** Any candidate admin can execute this attack—these are typically organizations controlled by the candidate themselves.

## Recommendation

Modify `RecordMinerReplacement` to only set the `IsReplacedEvilMiner` flag when `input.IsOldPubkeyEvil` is true:

```csharp
public override Empty RecordMinerReplacement(RecordMinerReplacementInput input)
{
    Assert(
        Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
        "Only AEDPoS Contract can record miner replacement.");

    if (!input.IsOldPubkeyEvil)
    {
        var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
        State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
        State.LatestMinedTerm.Remove(input.OldPubkey);
    }
    else
    {
        var replaceCandidates = State.ReplaceCandidateMap[input.CurrentTermNumber] ?? new StringList();
        replaceCandidates.Value.Add(input.NewPubkey);
        State.ReplaceCandidateMap[input.CurrentTermNumber] = replaceCandidates;
        // Only set flag for actual evil miner replacements
        State.IsReplacedEvilMiner[input.NewPubkey] = true;
    }

    return new Empty();
}
```

Additionally, ensure that actual evil miner replacements in `GenerateNextRoundInformation` call `RecordMinerReplacement` with `IsOldPubkeyEvil` set to true.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Deploy a miner node producing ~50% of average blocks (e.g., 200 blocks when average is 400)
2. Before term end, call `ReplaceCandidatePubkey` with a new public key as candidate admin
3. Observe that during the next `UpdateBasicMinerRewardWeights` call:
   - The new pubkey has `IsReplacedEvilMiner` flag set to true
   - The new pubkey has 200 `ProducedBlocks` (transferred from old pubkey)
   - Reward shares = 200 (direct) instead of 100 (via penalty formula)
4. Compare final Treasury distribution to verify 100% excess reward received

**Notes**

The developer comment at line 804 in `TreasuryContract.cs` ("The new miner may have more shares than his actually contributes, but it's ok") suggests this bypass was intended for miners who genuinely replaced evil nodes mid-term. However, the implementation is inverted:
- Voluntary key rotations (where penalty should apply) set the flag and bypass penalties
- Actual evil miner replacements (intended beneficiaries) never set the flag and receive 0 shares

This indicates a fundamental misunderstanding of when the flag would be set, resulting in the opposite of the intended behavior.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L596-596)
```csharp
        State.IsReplacedEvilMiner[input.NewPubkey] = true;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L802-812)
```csharp
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-302)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;

        // Notify Consensus Contract to update replacement information. (Update from old record.)
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L140-154)
```csharp
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L328-338)
```csharp
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
```
