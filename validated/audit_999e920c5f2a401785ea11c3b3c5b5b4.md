# Audit Report

## Title
Side Chain Validators Can Prevent Validator Set Updates by Omitting Consensus Data from Cross-Chain Indexing

## Summary
Side chain validators with 67% collusion can permanently freeze the validator set by proposing parent chain blocks without consensus information in the `extra_data` field. The cross-chain contract's validation logic does not enforce the presence of consensus data, allowing malicious validators to prevent validator rotation while maintaining normal cross-chain operations, creating an irreversible centralization risk.

## Finding Description

Side chains rely exclusively on cross-chain indexing for validator set updates and never use the `NextTerm` mechanism. [1](#0-0) 

The validator update mechanism depends on consensus information being passed through the `extra_data` field of `ParentChainBlockData`. When this data is present, it updates the side chain's `MainChainCurrentMinerList`. [2](#0-1) 

During round generation, if the main chain miner list has changed, the side chain generates a new first round with updated validators. [3](#0-2) 

**Root Cause**: The `ValidateParentChainBlockData` function validates chain ID, sequential height, and merkle tree root, but does NOT validate the presence or requirement of consensus data in the `extra_data` field. [4](#0-3) 

When parent chain blocks are indexed, consensus data extraction is conditional - if the `extra_data` map does not contain the consensus key, the update is simply skipped without any error. [5](#0-4) 

Only current miners can propose cross-chain indexing data. [6](#0-5) 

The CrossChainIndexingController is a parliament organization where miners both propose and approve proposals with a 67% approval threshold. [7](#0-6) [8](#0-7) 

**Attack Vector**: A malicious validator with 67% collusion receives proper parent chain block data (including consensus information) from the off-chain service, but when calling `ProposeCrossChainIndexing`, constructs `ParentChainBlockData` with all required validation fields (height, chain_id, transaction_status_merkle_tree_root, indexed_merkle_path) but omits the `extra_data` field. The validation passes, colluding miners approve it, the data gets indexed, but `UpdateConsensusInformation` is never called, preventing validator set updates indefinitely.

## Impact Explanation

**Critical Consensus Integrity Break**: This vulnerability fundamentally breaks the security model where side chains inherit validator rotation from the main chain. The initial validator set gains permanent, irrevocable control with no on-chain recovery mechanism.

**Permanent Validator Control**: Colluding validators can:
- Censor any transactions arbitrarily
- Extract unlimited MEV without competition from new validators
- Reorganize blocks for double-spending attacks
- Selectively refuse cross-chain transactions
- Hold the entire side chain hostage

**System-Wide Security Failure**: All side chain users, dApps, and assets become subject to the permanent control of a potentially malicious validator set. The expected security guarantee from main chain validator rotation is completely nullified.

**No Recovery Path**: Once validators stop including consensus data, there is no contract-level mechanism to force them to include it or to update the validator set through alternative means. [9](#0-8)  The side chain becomes permanently compromised.

## Likelihood Explanation

**Feasibility: HIGH**
- Validators have legitimate authority to propose cross-chain indexing data
- Attack execution is trivial - simply omit the `extra_data` field from the data structure
- No sophisticated techniques or timing requirements needed
- Zero cost to execute the attack once 67% validators collude

**Detection: LOW**
- The side chain continues operating normally for other functions
- Cross-chain transactions still work (merkle paths are validated)
- No obvious on-chain indicators that validator synchronization has stopped
- Users cannot easily verify if the validator set matches the main chain

**Economic Incentive: HIGH**
- Permanent control of economically significant side chain
- Can extract long-term value through transaction censorship and MEV
- Expected value increases with side chain economic activity
- Rational choice for compromised or malicious validator sets

**Prerequisites**: Requires 67% collusion among side chain validators. While significant, this is realistic for side chains with small initial validator sets or economically motivated validator groups.

**Overall Likelihood: MEDIUM to HIGH** - The 67% collusion requirement is non-trivial but achievable on valuable side chains. Once colluding, execution is immediate, irreversible, and has zero technical barriers.

## Recommendation

Add mandatory validation in `ValidateParentChainBlockData` to ensure consensus data is present in `extra_data` for parent chain blocks that should contain it. Alternatively, make consensus information updates mandatory rather than conditional, and fail the indexing if consensus data is missing when expected.

Suggested fix in `ValidateParentChainBlockData`:
```csharp
private bool ValidateParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData,
    out Dictionary<int, List<ParentChainBlockData>> validatedParentChainBlockData)
{
    var parentChainId = State.ParentChainId.Value;
    var currentHeight = State.CurrentParentChainHeight.Value;
    validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
    foreach (var blockData in parentChainBlockData)
    {
        if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
            blockData.TransactionStatusMerkleTreeRoot == null)
            return false;
        if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
                State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
                State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
            return false;

        // NEW: Validate consensus data presence on last block
        if (currentHeight + 1 == parentChainBlockData.Last().Height)
        {
            if (!blockData.ExtraData.ContainsKey(ConsensusExtraDataName))
                return false;
        }

        currentHeight += 1;
    }

    if (parentChainBlockData.Count > 0)
        validatedParentChainBlockData[parentChainId] = parentChainBlockData.ToList();

    return true;
}
```

## Proof of Concept

A test demonstrating the vulnerability would:

1. Initialize a side chain with test validators
2. Propose parent chain block data with valid fields BUT empty/missing `extra_data`
3. Have 67% of validators approve the proposal
4. Release and index the data
5. Verify that `MainChainCurrentMinerList` was NOT updated
6. Propose subsequent parent chain blocks the same way
7. Verify that validator set remains permanently frozen despite main chain validator changes

The core vulnerability is that step 2 passes validation when it should fail if consensus data synchronization is expected.

## Notes

This vulnerability represents a fundamental design flaw in the side chain consensus synchronization mechanism. The validation layer treats consensus data as optional when it should be mandatory for maintaining the security model. The 67% collusion threshold aligns with the parliament approval requirement, making this a realistic attack vector for economically motivated validator sets on valuable side chains.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-23)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L56-61)
```csharp

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-295)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L349-354)
```csharp
    private bool IsMainChainMinerListChanged(Round currentRound)
    {
        return State.MainChainCurrentMinerList.Value.Pubkeys.Any() &&
               GetMinerListHash(currentRound.RealTimeMinersInformation.Keys) !=
               GetMinerListHash(State.MainChainCurrentMinerList.Value.Pubkeys.Select(p => p.ToHex()));
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L613-623)
```csharp
        State.ParliamentContract.CreateOrganizationBySystemContract.Send(
            new CreateOrganizationBySystemContractInput
            {
                OrganizationCreationInput = new Parliament.CreateOrganizationInput
                {
                    ProposalReleaseThreshold = proposalReleaseThreshold,
                    ProposerAuthorityRequired = true,
                    ParliamentMemberProposingAllowed = true
                },
                OrganizationAddressFeedbackMethod = nameof(SetInitialIndexingControllerAddress)
            });
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L720-743)
```csharp
    private bool ValidateParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData,
        out Dictionary<int, List<ParentChainBlockData>> validatedParentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
        foreach (var blockData in parentChainBlockData)
        {
            if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
                blockData.TransactionStatusMerkleTreeRoot == null)
                return false;
            if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
                    State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
                    State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
                return false;

            currentHeight += 1;
        }

        if (parentChainBlockData.Count > 0)
            validatedParentChainBlockData[parentChainId] = parentChainBlockData.ToList();

        return true;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L783-788)
```csharp
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L286-286)
```csharp
        AssertAddressIsCurrentMiner(Context.Sender);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Constants.cs (L8-11)
```csharp
    private const int DefaultMinimalApprovalThreshold = 6667;
    private const int DefaultMaximalAbstentionThreshold = 1000;
    private const int DefaultMaximalRejectionThreshold = 1000;
    private const int DefaultMinimalVoteThresholdThreshold = 6667;
```
