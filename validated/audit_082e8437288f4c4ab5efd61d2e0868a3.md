# Audit Report

## Title
Continuous Blocks Limit Bypass via RoundNumber Manipulation in UpdateValue/TinyBlock Behaviors

## Summary
The AEDPoS consensus contract contains a critical validation asymmetry that allows malicious miners to bypass the continuous blocks limit enforcement. By manipulating the `RoundNumber` field in consensus extra data for `UpdateValue` and `TinyBlock` behaviors, an attacker can produce unlimited consecutive blocks beyond the intended 8-block limit, monopolizing block production and mining rewards.

## Finding Description

The vulnerability stems from three interconnected flaws in the consensus validation pipeline:

**Flaw 1: Missing RoundNumber Validation for UpdateValue/TinyBlock**

The `GetUpdateValueRound` and `GetTinyBlockRound` methods directly copy `RoundNumber` from the current state without validation: [1](#0-0) [2](#0-1) 

While `RoundTerminateValidationProvider` enforces strict `RoundNumber` increment validation for `NextRound` and `NextTerm` behaviors: [3](#0-2) 

This provider is **only added** for `NextRound` and `NextTerm`, not for `UpdateValue` or `TinyBlock`: [4](#0-3) 

**Flaw 2: ContinuousBlocksValidationProvider Relies on Unvalidated RoundNumber**

The continuous blocks enforcement mechanism checks `ProvidedRound.RoundNumber` from the block header: [5](#0-4) 

Where `ProvidedRound` is sourced directly from unvalidated consensus extra data: [6](#0-5) 

The recovery methods called during `ValidateBeforeExecution` only update miner-specific fields, **not** `RoundNumber`: [7](#0-6) [8](#0-7) 

**Flaw 3: Post-Execution Hash Validation is Ineffective**

After block execution, `ValidateConsensusAfterExecution` replaces the header round with the state round: [9](#0-8) 

Since `RecoverFromUpdateValue` returns `this` (the current round from state), the assignment makes both sides of the subsequent hash comparison point to the same object: [10](#0-9) 

This renders the hash validation meaningless - it always compares identical objects.

**Exploitation Sequence:**

1. Malicious miner modifies node software to override consensus extra data generation
2. Sets `RoundNumber` to 1 or 2 in block header (instead of actual current round number)
3. Submits `UpdateValue` or `TinyBlock` block to network
4. `ValidateBeforeExecution` runs: `ProvidedRound.RoundNumber` = 2, so `ContinuousBlocksValidationProvider` validation is skipped
5. Block executes and updates state
6. `ValidateConsensusAfterExecution` replaces header round with state round, hash validation passes
7. Miner continues producing blocks indefinitely, bypassing the continuous blocks counter

## Impact Explanation

**Critical Consensus Integrity Violation:**

The continuous blocks limit is a fundamental fairness mechanism defined by: [11](#0-10) 

The counter mechanism tracks consecutive block production: [12](#0-11) 

When the limit is exhausted (BlocksCount < 0), the advisory check suggests transitioning to NextRound: [13](#0-12) 

By bypassing this enforcement, a malicious miner can:
- **Monopolize block production**: Produce unlimited consecutive blocks far beyond the 8-block limit
- **Starve honest miners**: Prevent other miners from producing blocks and earning rewards
- **Capture disproportionate rewards**: Earn the majority of mining rewards unfairly
- **Centralize consensus**: Undermine the distributed security model of AEDPoS
- **Manipulate LIB calculation**: Skewed block production affects Last Irreversible Block height calculations

## Likelihood Explanation

**Attack Feasibility: HIGH**

The attack has minimal barriers to execution:

1. **Access Requirements**: Only requires being an elected miner in the consensus set (no special privileges)
2. **Technical Complexity**: Low - simple modification of `RoundNumber` field before block submission
3. **Detection Difficulty**: High - the manipulated value is corrected during post-execution, making forensic analysis difficult
4. **Economic Cost**: None beyond normal mining operation costs
5. **Preventive Controls**: The advisory check in `GetConsensusCommand` can be bypassed by manually constructing blocks

Any miner can execute this attack by:
- Modifying their node's consensus extra data generation logic
- Overriding `GetUpdateValueRound`/`GetTinyBlockRound` output to set `RoundNumber = 1`
- Submitting blocks with manipulated headers to the network

The attack is **immediately executable** and **economically profitable** for any active miner.

## Recommendation

Implement strict `RoundNumber` validation for all consensus behaviors:

1. **Add RoundTerminateValidationProvider for UpdateValue/TinyBlock** or create a dedicated `RoundNumberConsistencyProvider` that validates the provided `RoundNumber` matches the current state round number for these behaviors.

2. **Fix ValidateConsensusAfterExecution logic**: Instead of replacing the header round with the state round, properly recover and then compare distinct objects:

```csharp
// Create a copy of currentRound for comparison
var recoveredRound = currentRound.Clone();
if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
    recoveredRound.RecoverFromUpdateValue(headerInformation.Round, headerInformation.SenderPubkey.ToHex());

// Now compare the original header round against the properly recovered state round
if (headerInformation.Round.GetHash(isContainPreviousInValue) != recoveredRound.GetHash(isContainPreviousInValue))
{
    // Validation failure
}
```

3. **Add explicit RoundNumber validation**: Before any validation provider runs, verify that `extraData.Round.RoundNumber == State.CurrentRoundNumber.Value` for UpdateValue and TinyBlock behaviors.

## Proof of Concept

A malicious miner would execute the following attack:

```csharp
// In modified node software:
public override BytesValue GetConsensusExtraData(BytesValue input)
{
    var triggerInfo = AElfConsensusTriggerInformation.Parser.ParseFrom(input.Value);
    
    // Generate normal consensus extra data
    var headerInfo = base.GetConsensusBlockExtraData(input);
    var consensusInfo = AElfConsensusHeaderInformation.Parser.ParseFrom(headerInfo.Value);
    
    // EXPLOIT: Manipulate RoundNumber for UpdateValue/TinyBlock behaviors
    if (consensusInfo.Behaviour == AElfConsensusBehaviour.UpdateValue || 
        consensusInfo.Behaviour == AElfConsensusBehaviour.TinyBlock)
    {
        // Set RoundNumber to 1 or 2 to bypass ContinuousBlocksValidationProvider
        consensusInfo.Round.RoundNumber = 1;
    }
    
    return consensusInfo.ToBytesValue();
}
```

**Expected Result**: The malicious miner can produce unlimited consecutive blocks. The continuous blocks counter increments indefinitely without triggering validation failure, allowing the attacker to capture the majority of block production and mining rewards.

**Actual Result**: Validation passes because:
1. `ContinuousBlocksValidationProvider` skips the check when `RoundNumber <= 2`
2. Post-execution hash validation compares the same object against itself
3. No other validator checks `RoundNumber` consistency for these behaviors

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L16-16)
```csharp
            RoundNumber = RoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L63-63)
```csharp
            RoundNumber = RoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-30)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-91)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-14)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-32)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-97)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```
