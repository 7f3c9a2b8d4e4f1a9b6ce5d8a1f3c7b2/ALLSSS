# Audit Report

## Title
Candidate Admin Separation Invariant Can Be Bypassed Through AnnounceElectionFor

## Summary
The Election contract enforces an invariant that "Candidate cannot be others' admin" through a validation check in `AnnounceElection`. However, this critical check is absent from `AnnounceElectionFor` and `SetCandidateAdmin`, allowing candidates to bypass the restriction and become admins for other candidates, violating the intended separation of roles and enabling centralization of control over multiple candidate slots.

## Finding Description

The Election contract maintains two state mappings that track candidate-admin relationships: [1](#0-0) 

The `AnnounceElection` method explicitly enforces the separation invariant: [2](#0-1) 

This assertion verifies that when someone becomes a candidate, their address is not currently managing any other candidates. The error message "Candidate cannot be others' admin" explicitly states the intended invariant.

However, the `AnnounceElectionFor` method completely lacks this validation: [3](#0-2) 

The method directly assigns the admin and updates the managed list without checking whether the admin is already a candidate. Similarly, `SetCandidateAdmin` allows changing admins without this validation: [4](#0-3) 

**Exploitation Path:**
1. Alice calls `AnnounceElection(Alice_address)` - the check at line 102 passes because `ManagedCandidatePubkeysMap[Alice]` is null (Alice isn't managing anyone YET)
2. Alice becomes a candidate with herself as admin, and `ManagedCandidatePubkeysMap[Alice]` now contains Alice's pubkey
3. Alice calls `AnnounceElectionFor(Bob_pubkey, Alice_address)` - no check validates whether Alice (the admin) is already a candidate
4. Bob is registered with Alice as admin, and `ManagedCandidatePubkeysMap[Alice]` now contains BOTH Alice's and Bob's pubkeys

**Result:** Alice is both a candidate AND manages another candidate (Bob), directly violating the stated invariant.

The root cause is that the invariant check only prevents someone who is ALREADY managing others from becoming a candidate. It does not prevent a candidate from later becoming an admin for others through the alternate registration path.

## Impact Explanation

**Authorization Centralization:**
The candidate admin has privileged control over managed candidates. The Treasury contract explicitly enforces admin-only permissions when setting profit receivers: [5](#0-4) 

This allows the candidate-admin to redirect profits from managed candidates to any address, effectively extracting mining rewards earned by infrastructure they don't operate.

Only the admin can quit election for managed candidates: [6](#0-5) 

And only the admin can replace candidate pubkeys: [7](#0-6) 

**Governance Integrity Impact:**
- **Centralization of Power:** A single entity can control multiple candidate slots while appearing as independent candidates, violating decentralization principles
- **Sybil Attack Vector:** An attacker can register multiple candidates to increase election probability while maintaining control through a single admin address
- **Profit Manipulation:** The admin can unilaterally redirect profits from all managed candidates, extracting value without operating corresponding infrastructure
- **Competitive Manipulation:** A candidate can control their competitors' operations, creating conflicts of interest

This directly violates the explicitly stated design invariant. The invariant exists to ensure fairness and prevent centralization in the miner election process, which is fundamental to AEDPoS consensus security.

## Likelihood Explanation

**Reachability:** Both `AnnounceElection` and `AnnounceElectionFor` are public RPC methods callable by any user without special privileges.

**Attacker Capabilities:** Any user with sufficient tokens for candidate deposits can execute this attack. The cost is 2Ã— the candidate deposit per candidate: [8](#0-7) 

**Execution Practicality:**
- Step 1: Call `AnnounceElection(own_address)` - standard operation requiring one candidate deposit
- Step 2: Call `AnnounceElectionFor(target_pubkey, own_address)` - standard operation requiring another deposit
- Both operations execute in normal transaction flow with no timing constraints or complex state preconditions

**Economic Rationality:** The attack is economically viable when the attacker can extract value through profit manipulation or seeks to centralize mining power. The benefit of controlling multiple candidate slots and redirecting their profits outweighs the deposit costs for long-term attackers.

**Detection:** The vulnerability can be detected by querying `GetManagedPubkeys`: [9](#0-8) 

If a candidate address manages multiple pubkeys including non-self pubkeys, it indicates exploitation.

**Probability:** HIGH - The bypass is straightforward with no special timing requirements, state dependencies, or race conditions. It can be executed immediately after becoming a candidate.

## Recommendation

Add the same invariant validation to `AnnounceElectionFor` and `SetCandidateAdmin`:

```csharp
// In AnnounceElectionFor, before line 128:
var adminAddress = input.Admin ?? Context.Sender;
Assert(State.ManagedCandidatePubkeysMap[adminAddress] == null || 
       !IsCandidateAddress(adminAddress), 
       "Candidate cannot be others' admin.");

// In SetCandidateAdmin, before line 42:
Assert(State.ManagedCandidatePubkeysMap[input.Admin] == null || 
       !IsCandidateAddress(input.Admin), 
       "Candidate cannot be others' admin.");
```

Where `IsCandidateAddress` checks if the address corresponds to a current candidate's pubkey in the `CandidateInformationMap`.

## Proof of Concept

```csharp
[Fact]
public async Task BypassCandidateAdminSeparation_Test()
{
    // Alice announces election with herself as admin
    var aliceKeyPair = SampleECKeyPairs.KeyPairs[0];
    var aliceAddress = Address.FromPublicKey(aliceKeyPair.PublicKey);
    
    await ElectionContractStub.AnnounceElection.SendAsync(aliceAddress);
    
    // Verify Alice is a candidate and manages herself
    var aliceManagedPubkeys = await ElectionContractStub.GetManagedPubkeys.CallAsync(aliceAddress);
    Assert.Single(aliceManagedPubkeys.Value);
    
    // Bob's pubkey (but Alice will be admin)
    var bobKeyPair = SampleECKeyPairs.KeyPairs[1];
    var bobPubkey = bobKeyPair.PublicKey.ToHex();
    
    // Alice registers Bob with herself as admin - THIS SHOULD FAIL BUT DOESN'T
    await ElectionContractStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = bobPubkey,
        Admin = aliceAddress
    });
    
    // Verify Alice now manages both herself AND Bob - INVARIANT VIOLATED
    var aliceManagedAfter = await ElectionContractStub.GetManagedPubkeys.CallAsync(aliceAddress);
    Assert.Equal(2, aliceManagedAfter.Value.Count); // Alice manages 2 candidates!
    
    // Verify Alice can control Bob's profits
    var bobAdmin = await ElectionContractStub.GetCandidateAdmin.CallAsync(new StringValue { Value = bobPubkey });
    Assert.Equal(aliceAddress, bobAdmin); // Alice is Bob's admin
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L68-73)
```csharp
    public MappedState<string, Address> CandidateAdmins { get; set; }

    /// <summary>
    ///     Admin address -> Pubkey
    /// </summary>
    public MappedState<Address, PubkeyList> ManagedCandidatePubkeysMap { get; set; }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-57)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;

        var pubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey));

        var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
        if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            newAdminManagedPubkeys.Value.Add(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;

        var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender] ?? new PubkeyList();
        if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[Context.Sender] = oldAdminManagedPubkeys;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L102-102)
```csharp
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-609)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L181-181)
```csharp
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L427-430)
```csharp
    public override PubkeyList GetManagedPubkeys(Address input)
    {
        return State.ManagedCandidatePubkeysMap[input];
    }
```
