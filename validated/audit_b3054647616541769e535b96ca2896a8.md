# Audit Report

## Title
Invalid Behaviour Enum Bypass Enables Consensus State Freeze and Chain DOS

## Summary
A malicious miner can craft blocks with invalid `AElfConsensusBehaviour` enum values (e.g., 999) to bypass critical consensus validation and state update logic. This prevents consensus state progression while still allowing blocks to be committed, enabling unlimited continuous block production and complete chain halt.

## Finding Description

The vulnerability exists in the consensus validation and transaction generation flow where invalid enum values bypass essential security checks.

**Recovery Logic Bypass**: The `ValidateBeforeExecution` method conditionally calls recovery methods only for specific enum values (`UpdateValue` and `TinyBlock`). [1](#0-0)  When an invalid behaviour value (e.g., 999) is provided, both conditional checks fail, leaving `baseRound` unmodified from its state-fetched value.

**Validation Provider Skip**: The switch statement that adds behaviour-specific validators has no default case for invalid values. [2](#0-1)  This means critical validators like `UpdateValueValidationProvider`, `LibInformationValidationProvider`, `NextRoundMiningOrderValidationProvider`, and `RoundTerminateValidationProvider` are never added to the validation pipeline. Only three basic validators execute: `MiningPermissionValidationProvider`, `TimeSlotValidationProvider`, and `ContinuousBlocksValidationProvider`.

**Protobuf Enum Definition**: The `AElfConsensusBehaviour` enum only defines 5 valid values (0-4). [3](#0-2)  However, protobuf parsers accept any integer value without validation, allowing values like 999 to be parsed successfully.

**Empty Transaction Generation**: When consensus transactions are generated, invalid behaviour values hit the default case and return an empty transaction list. [4](#0-3) 

**State Update Prevention**: Without a consensus transaction, `ProcessConsensusInformation` never executes. This means the critical `ResetLatestProviderToTinyBlocksCount` method never runs, [5](#0-4)  preventing the continuous block counter from decrementing. [6](#0-5) 

**Continuous Block Limit Bypass**: The `ContinuousBlocksValidationProvider` checks if the block counter has gone negative. [7](#0-6)  Since state never updates, the counter remains at its initial positive value and never triggers the limit.

**Time Slot Validation Bypass**: The `TimeSlotValidationProvider` checks `ActualMiningTimes` from the baseRound. [8](#0-7)  Without recovery or state updates, the baseRound never reflects recent mining activity, using stale data that allows continued validation bypass.

**Recovery Methods**: The recovery methods that should update baseRound with current block information only execute for `UpdateValue` and `TinyBlock` behaviours. [9](#0-8) 

**After Execution Validation**: The `ValidateConsensusAfterExecution` method would pass because it compares the header Round hash with current state. [10](#0-9)  Since state never updates and the attacker can craft the header to match stale state, validation succeeds.

## Impact Explanation

**Critical Consensus DOS**: A single malicious miner can completely halt the blockchain by producing unlimited consecutive blocks:
- Each block passes basic validation (mining permission checks) because the miner is authorized [11](#0-10) 
- Continuous block limits never trigger because `LatestPubkeyToTinyBlocksCount.BlocksCount` never decrements
- Time slot validation passes because `ActualMiningTimes` in state is never updated to reflect previous blocks
- Consensus state (rounds, terms, LIB heights) never advances, freezing all consensus progression
- Other miners cannot produce blocks as their time slots never arrive according to stale state
- The entire chain becomes non-functional with no automatic recovery mechanism

**Complete Security Mechanism Bypass**: All consensus safety mechanisms are disabled:
- Round transition validation bypassed
- Term transition validation bypassed
- LIB height validation bypassed
- UpdateValue data validation bypassed
- Secret sharing mechanisms disabled

The severity is **CRITICAL** as it enables complete chain DOS by a single compromised miner with no recovery mechanism available.

## Likelihood Explanation

**Attack Feasibility: HIGH**

**Entry Point**: Any authorized miner can execute this attack through normal block production by modifying their mining software.

**Attack Complexity: LOW**
- Requires only being an authorized miner (normal operational requirement in any PoS/DPoS system)
- Technical execution: Modify mining software to set `Behaviour` field in consensus header to invalid value (e.g., 999)
- No complex timing, coordination, or multi-step setup required
- Can be executed immediately and repeatedly

**Preconditions**: 
- Attacker controls at least one miner node (realistic in any PoS/DPoS system)
- Miner is in current round's miner list (normal operational state)

**Detection Difficulty**: 
- No enum validation exists in the codebase
- Invalid values parse successfully via protobuf
- Blocks appear structurally valid at network layer
- Detection requires monitoring consensus state progression
- Once attack begins, rapid response is difficult as other miners are locked out

## Recommendation

Add explicit validation for the `AElfConsensusBehaviour` enum value:

1. **In ValidateBeforeExecution**, add enum value validation before processing:
```csharp
private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
{
    // Validate behaviour enum is within valid range
    if (!Enum.IsDefined(typeof(AElfConsensusBehaviour), extraData.Behaviour) ||
        extraData.Behaviour == AElfConsensusBehaviour.Nothing)
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = $"Invalid consensus behaviour: {extraData.Behaviour}" 
        };
    }
    // ... rest of existing logic
}
```

2. **In GenerateTransactionListByExtraData**, add validation before switch statement:
```csharp
private TransactionList GenerateTransactionListByExtraData(AElfConsensusHeaderInformation consensusInformation,
    ByteString pubkey, ByteString randomNumber)
{
    var behaviour = consensusInformation.Behaviour;
    
    if (!Enum.IsDefined(typeof(AElfConsensusBehaviour), behaviour) ||
        behaviour == AElfConsensusBehaviour.Nothing)
    {
        return new TransactionList(); // or throw assertion
    }
    
    // ... existing switch statement
}
```

3. **Add default case** to the switch statement in ValidateBeforeExecution that returns validation failure for unrecognized behaviours.

## Proof of Concept

A test demonstrating the vulnerability would:

1. Set up a test chain with multiple miners
2. Have one miner craft a block with `AElfConsensusHeaderInformation.Behaviour = 999` 
3. Verify the block passes `ValidateBeforeExecution` (only basic validators run)
4. Verify `GenerateConsensusTransactions` returns empty list
5. Verify block is accepted without state update
6. Verify subsequent blocks with same invalid behaviour continue to be accepted
7. Verify `LatestPubkeyToTinyBlocksCount.BlocksCount` never decrements
8. Verify consensus state remains frozen while blocks continue to be produced

The test would confirm that invalid enum values bypass all consensus safety mechanisms and enable unlimited continuous block production by a single miner.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** protobuf/aedpos_contract.proto (L321-327)
```text
enum AElfConsensusBehaviour {
    UPDATE_VALUE = 0;
    NEXT_ROUND = 1;
    NEXT_TERM = 2;
    NOTHING = 3;
    TINY_BLOCK = 4;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-127)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L180-181)
```csharp
            default:
                return new TransactionList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L69-69)
```csharp
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L17-19)
```csharp
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L41-41)
```csharp
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-47)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }

    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```
