# Audit Report

## Title
Virtual Balance Mismatch Causes Denial of Service in TokenConverter Sell Operations

## Summary
The TokenConverter contract uses a 10 million token virtual balance for deposit connectors in Bancor pricing calculations, but this virtual balance does not represent actual tokens held by the contract. When deposit balances are low, the Bancor formula calculates payouts exceeding actual holdings, causing `Sell` transactions to fail with SafeMath underflow exceptions, preventing legitimate users from selling resource tokens.

## Finding Description
The vulnerability stems from a fundamental mismatch between the balance used for pricing calculations and the balance used for state updates in the `Sell` method.

The `NativeTokenToResourceBalance` constant is set to 10 million tokens (10_000_000_00000000). [1](#0-0) 

This constant is assigned as the `VirtualBalance` for native token deposit connectors during system initialization. [2](#0-1) 

The `GetSelfBalance` method combines this virtual balance with the actual deposit balance when calculating pricing. When `IsVirtualBalanceEnabled` is true, it returns `connector.VirtualBalance.Add(realBalance)`. [3](#0-2) 

This inflated balance is used by the Bancor formula in the `Sell` method to calculate `amountToReceive`. [4](#0-3) 

However, the actual state update attempts to subtract `amountToReceive` from only the real `DepositBalance`, without the virtual component. [5](#0-4) 

When `amountToReceive` exceeds the actual `DepositBalance`, the `SafeMath.Sub` operation throws an overflow exception using C#'s checked arithmetic. [6](#0-5) 

The Bancor formula for equal weights simplifies to a ratio calculation where the return is proportional to the total balance including virtual amounts. [7](#0-6) 

Connectors can be initialized with zero deposit balance when all resource tokens are already held by the contract, as the `GetNeededDeposit` calculation returns zero in this case. [8](#0-7) [9](#0-8) 

## Impact Explanation
**Denial of Service - Medium Severity**

Users are unable to sell resource tokens when deposit balances are insufficient relative to the 10M virtual balance. The `Sell` method is publicly accessible with no special authorization required. [10](#0-9) 

The transaction reverts cleanly without fund loss, but creates significant operational disruption:

- Legitimate sell operations fail unexpectedly despite pricing calculations indicating they should succeed
- Resource tokens become effectively frozen until sufficient deposits accumulate through Buy operations
- Impact multiplies across multiple resource token pairs (READ, WRITE, STORAGE, TRAFFIC, etc.), each with its own 10M virtual balance
- More severe during early system stages or after periods of heavy withdrawals

The issue affects system availability rather than fund security. No tokens are lost or stolen—transactions simply revert with overflow exceptions. This justifies Medium severity: significant operational impact without direct fund loss.

## Likelihood Explanation
**High Likelihood**

The vulnerability is highly likely to manifest in realistic scenarios because:

1. The `Sell` method is publicly accessible requiring no special privileges—any user holding resource tokens can call it
2. System initialization naturally creates this condition when enabling connectors
3. The mathematical condition for failure occurs when the Bancor formula calculates returns based on (virtual + real) balance that exceed the real balance alone
4. No attack is required—this is a natural system state during normal operation, especially in early adoption phases or after sustained selling pressure

The preconditions exist by design in the system's initialization and pricing mechanism.

## Recommendation

The fix requires ensuring that virtual balances used for pricing calculations are also backed by actual reserves when processing withdrawals. There are several approaches:

**Option 1: Remove virtual balance from pricing calculation in Sell operations**
Modify `GetSelfBalance` to not include virtual balance when called from the Sell path, or create a separate method that returns only real balances for withdrawal calculations.

**Option 2: Enforce minimum deposit reserves**
Add validation in the `Sell` method to ensure `DepositBalance[toConnector.Symbol]` is sufficient before allowing the transaction:

```csharp
Assert(State.DepositBalance[toConnector.Symbol] >= amountToReceive, 
    "Insufficient deposit balance to process sell transaction.");
```

**Option 3: Adjust virtual balance mechanism**
Only enable virtual balances after sufficient real deposits exist, or dynamically adjust virtual balance to never exceed actual reserves.

The simplest and safest fix is Option 2, as it preserves the existing pricing model while protecting against underflow.

## Proof of Concept

```csharp
[Fact]
public async Task Sell_Fails_With_Low_Deposit_Balance_And_Virtual_Balance()
{
    // Setup: Create resource token and initialize contracts
    await CreateWriteToken();
    await InitializeTokenConverterContract();
    
    // Enable connector with ZERO deposit balance
    // (all resource tokens already in contract)
    var enableResult = await DefaultStub.EnableConnector.SendAsync(
        new ToBeConnectedTokenInfo
        {
            TokenSymbol = WriteConnector.Symbol,
            AmountToTokenConvert = 100_0000L  // All tokens in contract
        });
    enableResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify deposit balance is 0 (only virtual balance exists)
    var depositBalance = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = WriteConnector.Symbol });
    // depositBalance.Value will be VirtualBalance (100_0000) but real DepositBalance is 0
    
    // User attempts to sell resource tokens
    // This will calculate amountToReceive based on virtual+real balance
    // But will fail when trying to subtract from real balance (0)
    var sellResult = await DefaultStub.Sell.SendWithExceptionAsync(
        new SellInput
        {
            Symbol = WriteConnector.Symbol,
            Amount = 1000L,
            ReceiveLimit = 0
        });
    
    // Transaction fails with overflow exception due to SafeMath.Sub underflow
    sellResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    sellResult.TransactionResult.Error.ShouldContain("Arithmetic operation resulted in an overflow");
}
```

This test demonstrates that when deposit balance is zero but virtual balance exists, the Sell operation fails with an arithmetic overflow exception, proving the DoS condition.

### Citations

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L20-20)
```csharp
    public const long NativeTokenToResourceBalance = 10_000_000_00000000;
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L240-249)
```csharp
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-161)
```csharp
    public override Empty Sell(SellInput input)
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L297-297)
```csharp
        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L47-49)
```csharp
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-84)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```
