# Audit Report

## Title
Missing Cross-Chain Verification in NFT Protocol Creation Allows Unauthorized Protocol Registration

## Summary
The `CrossChainCreate()` function in the NFT contract lacks any cross-chain verification mechanisms. Any address can call this function to create NFT protocols for tokens that exist in the local TokenContract, completely bypassing the mainchain-only creation requirement and proper merkle proof verification that is standard in AElf's cross-chain operations.

## Finding Description

The vulnerability exists in the `CrossChainCreate()` function which accepts only a symbol parameter and performs no cryptographic verification. [1](#0-0) 

The function simply checks if the protocol already exists, reads token information from the local TokenContract, and creates an NFT protocol from that data without any authorization or cross-chain validation.

The input message definition shows it only accepts a symbol string: [2](#0-1) 

This contrasts sharply with the secure implementation in MultiToken's `CrossChainCreateToken()`, which properly implements cross-chain verification: [3](#0-2) 

The MultiToken contract accepts comprehensive cross-chain verification parameters including chain ID, parent chain height, transaction bytes, and merkle path: [4](#0-3) 

Most critically, MultiToken calls the `CrossChainVerify` helper method that performs cryptographic merkle proof validation through the CrossChain contract: [5](#0-4) 

The NFT contract has NO such verification despite the function's name suggesting cross-chain functionality. Additionally, while the `Create()` function enforces mainchain-only creation with a chain ID check, [6](#0-5)  the `CrossChainCreate()` function has no such chain ID validation, allowing it to be called on any chain.

## Impact Explanation

**Critical Security Violations**:

1. **Unauthorized Protocol Creation**: Any address can create NFT protocols for any token in the local TokenContract without authorization from the token creator or proper cross-chain validation from the source chain.

2. **Bypass Mainchain-Only Invariant**: The system enforces that NFT protocols should only be created on the AELF mainchain through the `Create()` function, but `CrossChainCreate()` allows this security boundary to be bypassed on sidechains.

3. **Front-Running Attacks**: Attackers can monitor pending legitimate cross-chain NFT protocol registrations and front-run them by calling `CrossChainCreate()` first with the same symbol. The legitimate transaction will then fail since the protocol already exists.

4. **Cross-Chain Integrity Violation**: This completely defeats AElf's cross-chain security model which requires cryptographic merkle proof verification for all cross-chain operations, as demonstrated by the proper implementation in MultiToken.

**Affected Parties**:
- NFT protocol creators expecting secure cross-chain registration
- Token creators whose tokens can be converted to NFT protocols without their consent
- The entire sidechain NFT infrastructure's integrity and trustworthiness

The severity is **CRITICAL** because it breaks fundamental cross-chain security guarantees that the AElf blockchain relies upon for secure multi-chain operations.

## Likelihood Explanation

**Attacker Requirements**:
- Any address can call the function - it has no authorization checks
- Only requires ability to send a transaction (standard capability for any blockchain user)
- Function is publicly accessible as a standard RPC method [7](#0-6) 

**Attack Complexity**: 
- Extremely Low - single function call with one parameter (symbol)
- Precondition: A token with the target symbol must exist in the local TokenContract, which is very common on sidechains where tokens are cross-chain transferred for DeFi and NFT operations

**Feasibility**:
- Standard gas costs only
- No timing requirements or race conditions
- Easily reproducible on any sidechain
- Difficult to prevent or detect before execution since it's a legitimate contract method

The probability is **HIGH** - the attack is trivial to execute and economically rational for griefing, front-running legitimate cross-chain operations, or exploiting protocol assumptions about NFT protocol creation authority.

## Recommendation

The `CrossChainCreate()` function should be redesigned to match the security model of MultiToken's `CrossChainCreateToken()` implementation:

1. **Change input parameters** to accept cross-chain verification data:
   - Source chain ID
   - Parent chain height  
   - Transaction bytes containing the protocol creation validation
   - Merkle path for verification

2. **Add whitelist validation** for source chain NFT contract addresses

3. **Implement cryptographic verification** by calling `CrossChainVerify` helper method with the merkle path to validate the transaction occurred on the source chain

4. **Add chain ID validation** to ensure the function is only called on appropriate chains (e.g., sidechains for receiving mainchain protocols)

The corrected implementation should follow the pattern established in MultiToken at lines 478-534, particularly the critical `CrossChainVerify` call at line 488.

## Proof of Concept

The following test demonstrates the vulnerability by showing that any address can call `CrossChainCreate()` on a sidechain to create an NFT protocol for an existing token, without any cross-chain verification:

```csharp
[Fact]
public async Task CrossChainCreate_WithoutVerification_Vulnerability_Test()
{
    // Setup: Create a token on sidechain (simulating cross-chain transfer)
    var tokenSymbol = "NFTTEST";
    await SideChainTokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = tokenSymbol,
        TokenName = "Test NFT Token",
        TotalSupply = 1000000,
        Decimals = 0,
        Issuer = DefaultAccount.Address,
        IsBurnable = true,
        IssueChainId = SideChainId,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                { "aelf_nft_type", "Art" },
                { "aelf_nft_base_uri", "ipfs://test/" },
                { "aelf_nft_token_id_reuse", "false" }
            }
        }
    });

    // Vulnerability: ANY address can call CrossChainCreate without verification
    var attackerStub = GetNFTContractStub(AttackerAccount.KeyPair);
    var result = await attackerStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
    {
        Symbol = tokenSymbol
    });

    // Attack succeeds - protocol created without cross-chain verification
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify unauthorized protocol was created
    var protocolInfo = await attackerStub.GetNFTProtocolInfo.CallAsync(new StringValue 
    { 
        Value = tokenSymbol 
    });
    protocolInfo.Symbol.ShouldBe(tokenSymbol);
    
    // Legitimate cross-chain operation now fails
    var legitimateResult = await SideChainNFTContractStub.CrossChainCreate
        .SendWithExceptionAsync(new CrossChainCreateInput { Symbol = tokenSymbol });
    legitimateResult.TransactionResult.Error.ShouldContain("already created");
}
```

## Notes

This vulnerability is particularly severe because:

1. **Design Intent vs Implementation**: The function name "CrossChainCreate" suggests it should handle cross-chain verification, but it completely lacks this functionality.

2. **Inconsistent Security Model**: The regular `Create()` method properly enforces mainchain-only creation, but `CrossChainCreate()` bypasses this security boundary.

3. **Established Pattern Ignored**: The codebase already has a correct implementation pattern in MultiToken's `CrossChainCreateToken()` with proper merkle proof verification, but the NFT contract doesn't follow it.

4. **No Authorization Checks**: Unlike other sensitive operations, there are no permission checks, whitelist validations, or governance controls on this function.

The vulnerability requires immediate attention as it fundamentally breaks the trust model for cross-chain NFT protocol creation in the AElf ecosystem.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L16-17)
```csharp
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** protobuf/nft_contract.proto (L25-26)
```text
    rpc CrossChainCreate (CrossChainCreateInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/nft_contract.proto (L132-134)
```text
message CrossChainCreateInput {
    string symbol = 1;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-534)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }

        return new Empty();
    }
```

**File:** protobuf/token_contract.proto (L571-580)
```text
message CrossChainCreateTokenInput {
    // The chain id of the chain on which the token was created.
    int32 from_chain_id = 1;
    // The height of the transaction that created the token.
    int64 parent_chain_height = 2;
    // The transaction that created the token.
    bytes transaction_bytes = 3;
    // The merkle path created from the transaction that created the transaction.
    aelf.MerklePath merkle_path = 4;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```
