# Audit Report

## Title
Assembled NFTs Can Be Minted Multiple Times Allowing Disassembly Without Returning Locked Assets

## Summary
When an NFT protocol has `IsTokenIdReuse = true`, minters can call `Mint()` to increase the quantity of an already-assembled NFT, creating additional copies that are not backed by locked assets in `AssembledNftsMap`. Subsequent disassemblies of these unbacked copies burn the NFT but return nothing, causing permanent loss of the originally locked assets.

## Finding Description

The vulnerability exists in the interaction between the `Assemble()`, `Mint()`, and `Disassemble()` methods in the NFT contract.

When `Assemble()` is called, it locks NFTs/FTs by transferring them to the contract and storing references in `AssembledNftsMap`, then calls `PerformMint()` with `isTokenIdMustBeUnique = true` to create the assembled NFT. [1](#0-0) 

However, after assembly, a minter can call the public `Mint()` method with the same `tokenId`. The `Mint()` method calls `PerformMint()` with the default parameter `isTokenIdMustBeUnique = false`. [2](#0-1) 

In `PerformMint()`, the token ID reuse check only triggers when either `IsTokenIdReuse` is false OR `isTokenIdMustBeUnique` is true. [3](#0-2) 

For protocols with `IsTokenIdReuse = true`, when `isTokenIdMustBeUnique = false` (regular Mint), the check evaluates to `if (!true || false)` = `if (false)`, allowing the mint to bypass the uniqueness assertion. The code then increments the existing NFT's quantity. [4](#0-3) 

This creates multiple copies of the assembled NFT, but `AssembledNftsMap` only has ONE entry per token hash. [5](#0-4) 

When `Disassemble()` is called the first time, it burns one copy, retrieves the locked assets from `AssembledNftsMap`, transfers them back, and crucially removes the map entry. [6](#0-5) 

A second `Disassemble()` call burns another copy successfully, but when it tries to retrieve from `AssembledNftsMap`, the entry is gone (removed at line 209), so the condition at line 204 evaluates to false and no assets are returned. The NFT is burned without returning its supposed backing.

## Impact Explanation

**Direct Fund Impact**: Permanent loss of locked NFT/FT value. When fake assembled NFTs (those minted after the initial assembly) are disassembled, they are burned but the locked assets are not returned because the `AssembledNftsMap` entry was already removed by the first disassembly.

**Affected Parties**:
- Holders of unbacked assembled NFTs who expect to receive locked assets upon disassembly
- The protocol's integrity, as it allows existence of unbacked assembled NFTs that appear identical to properly backed ones
- Market participants who may trade these unbacked assembled NFTs at full value, unaware they cannot be disassembled for their components

**Severity**: Critical - This breaks the fundamental invariant that assembled NFTs should always be backed by their locked components. The locked NFTs/FTs (which could have significant value) are permanently lost when unbacked copies are disassembled.

## Likelihood Explanation

**Attacker Capabilities Required**:
1. Must be a minter of an NFT protocol (added by protocol creator via `AddMinters()`) [7](#0-6) 
2. Protocol must have `IsTokenIdReuse = true` (set during protocol creation) [8](#0-7) 
3. Protocol must have `IsBurnable = true` (required for Disassemble to work) [9](#0-8) 

**Attack Complexity**: Low - straightforward sequence of public method calls (Assemble → Mint with same tokenId → Disassemble → Disassemble)

**Feasibility**: High - While requiring minter role is a constraint, this is a legitimate and commonly granted capability. Protocols may enable `IsTokenIdReuse` for legitimate use cases (re-minting after burn). The burn function's requirement that only minters can burn means this particularly affects the minter community.

**Detection**: Difficult - the unbacked assembled NFTs appear identical to properly backed ones in terms of token hash, symbol, and token ID. Only by checking the actual `AssembledNftsMap` state or attempting disassembly would the issue be discovered.

## Recommendation

Modify the `Assemble()` method to mark assembled token IDs as permanently unique, preventing any subsequent mints regardless of the `IsTokenIdReuse` setting. Options include:

1. **Add a separate mapping to track assembled token IDs**:
```csharp
public MappedState<Hash, bool> IsAssembledTokenMap { get; set; }
```

Then in `PerformMint()`, add an additional check:
```csharp
if (State.IsAssembledTokenMap[tokenHash])
    Assert(false, $"Token id {tokenId} is an assembled NFT and cannot be re-minted.");
```

2. **Enforce `isTokenIdMustBeUnique` for all assembled NFTs** by setting a flag in metadata that `PerformMint()` can check.

3. **Prevent minting when `AssembledNftsMap` entry exists**:
```csharp
if (State.AssembledNftsMap[tokenHash] != null || State.AssembledFtsMap[tokenHash] != null)
    Assert(false, $"Token id {tokenId} is an assembled NFT and cannot be re-minted.");
```

## Proof of Concept

```csharp
[Fact]
public async Task AssembledNFT_CanBeMintedMultipleTimes_CausingAssetLoss()
{
    // Setup: Create protocol with IsTokenIdReuse = true and IsBurnable = true
    var symbol = await CreateTest(); // Creates protocol with IsBurnable = true
    await AddMinterAsync(symbol);
    
    // Step 1: Mint an NFT to use as component
    var componentHash = (await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        Alias = "component",
        Owner = DefaultAddress,
        Uri = $"{BaseUri}component"
    })).Output;
    
    // Step 2: Assemble NFT with locked component
    var assembleResult = await NFTContractStub.Assemble.SendAsync(new AssembleInput
    {
        Symbol = symbol,
        TokenId = 100, // Specific token ID
        AssembledNfts = new AssembledNfts
        {
            Value = { [componentHash.ToHex()] = 1 }
        }
    });
    
    // Verify component is locked in contract
    var componentBalance = (await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = NFTContractAddress,
        Symbol = symbol,
        TokenId = 1
    })).Balance;
    componentBalance.ShouldBe(1); // Component locked
    
    // Step 3: Mint DUPLICATE assembled NFT (VULNERABILITY)
    await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        TokenId = 100, // SAME token ID as assembled NFT
        Owner = User1Address,
        Uri = $"{BaseUri}duplicate"
    });
    
    // Now there are 2 copies but only 1 entry in AssembledNftsMap
    var nftInfo = await NFTContractStub.GetNFTInfo.CallAsync(new GetNFTInfoInput
    {
        Symbol = symbol,
        TokenId = 100
    });
    nftInfo.Quantity.ShouldBe(2); // 2 copies exist
    
    // Step 4: First disassemble returns locked component
    await NFTContractStub.Disassemble.SendAsync(new DisassembleInput
    {
        Symbol = symbol,
        TokenId = 100
    });
    
    // Component returned to sender
    var returnedBalance = (await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = symbol,
        TokenId = 1
    })).Balance;
    returnedBalance.ShouldBe(1); // Component returned
    
    // Step 5: Second disassemble BURNS NFT but returns NOTHING (ASSET LOSS)
    await User1NFTContractStub.Disassemble.SendAsync(new DisassembleInput
    {
        Symbol = symbol,
        TokenId = 100,
        Owner = User1Address
    });
    
    // The second NFT was burned
    nftInfo = await NFTContractStub.GetNFTInfo.CallAsync(new GetNFTInfoInput
    {
        Symbol = symbol,
        TokenId = 100
    });
    nftInfo.Quantity.ShouldBe(0); // All copies burned
    
    // But no component was returned for the second disassembly
    // This proves the vulnerability: unbacked assembled NFTs can exist and be burned without returning assets
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L12-19)
```csharp
    public override Hash Mint(MintInput input)
    {
        if (input.Metadata != null && input.Metadata.Value.Any())
            AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var nftMinted = PerformMint(input);
        return nftMinted.TokenHash;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L87-88)
```csharp
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L175-176)
```csharp
        var nftMinted = PerformMint(mingInput, true);
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L203-210)
```csharp
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-353)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-437)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-32)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L48-48)
```csharp
            IsTokenIdReuse = input.IsTokenIdReuse,
```
