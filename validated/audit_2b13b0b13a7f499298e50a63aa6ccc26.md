# Audit Report

## Title
Unvalidated SupposedOrderOfNextRound Enables Consensus Denial of Service

## Summary
The AEDPoS consensus contract accepts `SupposedOrderOfNextRound` and `TuneOrderInformation` values from miner-submitted `UpdateValueInput` without validation. A malicious miner can inject invalid order values that corrupt the round state, causing `BreakContinuousMining()` to throw exceptions during next round generation, resulting in complete consensus halt.

## Finding Description

The vulnerability exists in the consensus update value processing flow where order information for the next round is accepted from miner input without proper validation.

**Missing Validation in UpdateValueValidationProvider:**

The validation provider for UpdateValue behavior only checks cryptographic fields but does not validate the `SupposedOrderOfNextRound` field or `TuneOrderInformation` map. [1](#0-0) 

The validation only verifies that OutValue and Signature are non-null, and that PreviousInValue matches the previous OutValue. No bounds checking or range validation is performed on order-related fields.

**Direct Acceptance of Unvalidated Values:**

The `ProcessUpdateValue()` method directly assigns `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` from the input without any bounds checking or validity verification. [2](#0-1) 

Additionally, the method processes `TuneOrderInformation` to modify other miners' `FinalOrderOfNextRound` values without validation: [3](#0-2) 

**Correct Calculation in Normal Flow:**

The system correctly calculates `SupposedOrderOfNextRound` using the formula `GetAbsModulus(sigNum, minersCount) + 1` to ensure values are in the valid range [1, minersCount]: [4](#0-3) 

However, malicious miners can bypass this calculation by providing arbitrary values in their consensus extra data through the UpdateValue RPC method.

**Consensus Failure Mechanism:**

When `GenerateNextRoundInformation` constructs the next round, it relies on `FinalOrderOfNextRound` values to assign miner positions: [5](#0-4) 

Miners with `SupposedOrderOfNextRound == 0` are excluded from the "mined" list: [6](#0-5) 

The `BreakContinuousMining()` function then expects specific order positions to exist and uses `.First()` which throws `InvalidOperationException` if no matching element is found: [7](#0-6) [8](#0-7) 

If invalid order values result in missing Order == 1 or Order == 2 positions, the exception halts next round generation.

## Impact Explanation

**Severity: High** - Complete Consensus Denial of Service

This vulnerability enables a malicious miner to cause permanent consensus failure:

1. **Immediate Impact**: When invalid order values cause exceptions in `BreakContinuousMining()`, the next round cannot be generated, halting all block production
2. **Network-Wide Effect**: All nodes attempting to generate the next round will encounter the same exception due to corrupted state
3. **Persistence**: The corrupted round state persists in the blockchain state, requiring manual intervention or chain rollback to recover
4. **No Automatic Recovery**: Unlike temporary network issues, this corruption cannot self-heal as the invalid values are part of the consensus state

The attack compromises the fundamental availability guarantee of the blockchain - the ability to produce new blocks and process transactions.

## Likelihood Explanation

**Likelihood: Medium** - Requires Miner Access but Single-Actor Attack

While the attack requires the adversary to be an active block producer, it has relatively low complexity:

**Attacker Requirements:**
- Must be selected as an active miner in the current term (significant but achievable barrier)
- Ability to modify node software to inject malicious consensus data (moderate technical skill)
- No need for majority control or coordination with other miners

**Attack Execution:**

A malicious miner can craft an UpdateValue transaction with invalid `SupposedOrderOfNextRound` values when producing their block. The UpdateValue method is publicly accessible: [9](#0-8) 

The validation logic is insufficient to prevent malicious order values: [10](#0-9) 

**Success Probability:**

Once a malicious miner submits a block with corrupted order data that passes validation, the attack succeeds deterministically. The corrupted state propagates to all nodes, and the next round generation will fail consistently across the network.

## Recommendation

Add validation to ensure `SupposedOrderOfNextRound` and `TuneOrderInformation` values are within valid bounds:

1. **Enhance UpdateValueValidationProvider**: Add range checks to verify that:
   - `SupposedOrderOfNextRound` is in range [1, minersCount]
   - All values in `TuneOrderInformation` are in range [1, minersCount]
   - No duplicate order values exist

2. **Add Defensive Checks in ProcessUpdateValue**: Validate input values before assignment:
   ```csharp
   var minersCount = currentRound.RealTimeMinersInformation.Count;
   Assert(updateValueInput.SupposedOrderOfNextRound >= 1 && 
          updateValueInput.SupposedOrderOfNextRound <= minersCount,
          "Invalid SupposedOrderOfNextRound value");
   
   foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
   {
       Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount,
              "Invalid FinalOrderOfNextRound value in TuneOrderInformation");
   }
   ```

3. **Defensive Programming in BreakContinuousMining**: Replace `.First()` with `.FirstOrDefault()` and handle null cases gracefully, though this is a secondary mitigation as the root cause should be fixed via validation.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task MaliciousOrderValues_CausesConsensusHalt()
{
    // Setup: Initialize consensus with multiple miners
    var miners = await InitializeConsensusWithMultipleMiners();
    
    // Malicious miner crafts UpdateValueInput with invalid order values
    var maliciousInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("valid_out_value"),
        Signature = HashHelper.ComputeFrom("valid_signature"),
        PreviousInValue = Hash.Empty,
        SupposedOrderOfNextRound = 0, // INVALID: should be [1, minersCount]
        TuneOrderInformation = 
        {
            { miners[0].PublicKey, 0 }, // INVALID: corrupting other miners' orders
            { miners[1].PublicKey, 0 }
        },
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        ImpliedIrreversibleBlockHeight = 1,
        RandomNumber = ByteString.CopyFromUtf8("random")
    };
    
    // Execute UpdateValue - should pass validation (BUG: no order validation)
    await ConsensusContract.UpdateValue.SendAsync(maliciousInput);
    
    // Attempt to generate next round - should throw InvalidOperationException
    var exception = await Assert.ThrowsAsync<InvalidOperationException>(async () =>
    {
        var currentRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
        currentRound.GenerateNextRoundInformation(
            TimestampHelper.GetUtcNow(),
            blockchainStartTimestamp,
            out var nextRound
        );
    });
    
    // Verify consensus is halted
    Assert.Contains("Sequence contains no matching element", exception.Message);
}
```

## Notes

This vulnerability represents a critical flaw in the consensus validation layer where the protocol assumes honest behavior from miners regarding order assignments, but provides insufficient validation to enforce this assumption. The use of LINQ's `.First()` method without ensuring the existence of required order positions creates a deterministic failure point that can be exploited by any active miner to halt the entire network's consensus mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-32)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L83-84)
```csharp
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```
