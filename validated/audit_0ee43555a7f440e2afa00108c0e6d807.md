# Audit Report

## Title
Missing Consensus Behavior Validation Allows Malicious Miner to Force Premature Term Change

## Summary
A malicious miner can force premature term transitions by claiming `NextTerm` behavior when consensus rules require `NextRound`. The on-chain validation only verifies formal properties (term number increment) but fails to re-verify the semantic condition (`NeedToChangeTerm`) that enforces the 2/3 miner consensus threshold for term changes.

## Finding Description

The vulnerability exists due to a critical gap between off-chain behavior determination and on-chain behavior validation:

**Off-chain Behavior Determination:**
The `MainChainConsensusBehaviourProvider` correctly determines whether to use `NextTerm` or `NextRound` by calling `NeedToChangeTerm()`, which checks if at least 2/3 of miners have `ActualMiningTimes` indicating a term change is warranted. [1](#0-0) [2](#0-1) 

**Missing On-chain Validation:**
During block validation, `ValidationForNextTerm()` only checks that the term number increments by 1 and delegates to `ValidationForNextRound()` for round number checking. It does NOT re-verify the `NeedToChangeTerm()` condition. [3](#0-2) 

**Exploitable Entry Point:**
The `GetConsensusBlockExtraData` method accepts a miner-provided `Behaviour` field and switches on it to generate consensus data without verifying that the behavior is appropriate for the current consensus state. [4](#0-3) 

Both `GetConsensusExtraData` and `GenerateConsensusTransactions` are view methods with no authorization, allowing any caller to generate consensus data for any behavior. [5](#0-4) 

**Attack Sequence:**
1. Malicious miner modifies their node software to bypass `GetConsensusCommand` 
2. Directly calls `GetConsensusExtraData` with `Behaviour = NEXT_TERM` in the trigger information
3. Calls `GenerateConsensusTransactions` with the same trigger information
4. Includes the resulting consensus header and NextTerm transaction in their block
5. The `PreCheck()` authorization only verifies miner list membership, not behavior validity [6](#0-5) 

6. Validation passes because `ValidationForNextTerm` doesn't check `NeedToChangeTerm`
7. `ProcessNextTerm` executes, updating term number and triggering economic/governance side effects [7](#0-6) 

## Impact Explanation

**Consensus Integrity Violation:**
The attack breaks the fundamental consensus rule that term transitions require 2/3 miner agreement. This allows a single miner to unilaterally change the term, violating the Byzantine fault tolerance guarantees of the AEDPoS protocol.

**Economic Impact:**
Term transitions trigger treasury release tied to term boundaries, allowing manipulation of when mining rewards are distributed and treasury funds are released. [8](#0-7) 

Election snapshots are taken at term boundaries, allowing manipulation of vote-weight calculations and miner selection timing. [9](#0-8) 

**Operational Impact:**
Miner statistics are reset prematurely, miner list updates occur at incorrect times, and the round/term state machine becomes desynchronized from protocol expectations. [10](#0-9) 

## Likelihood Explanation

**High Feasibility:**
- Attacker only needs to be an elected miner (achievable through normal voting)
- Attack requires simple node software modification to bypass `GetConsensusCommand` and directly call view methods
- No cryptographic breaks, timing windows, or race conditions required

**Low Complexity:**
- Single malicious block with incorrect behavior triggers the state corruption
- The validation gap is deterministic and always exploitable
- No economic costs beyond normal miner operation

**Difficult Detection:**
- Validation passes successfully from external perspective
- Term number increment is formally valid, only the timing violates protocol semantics
- Requires deep protocol knowledge to detect the premature transition

## Recommendation

Add a check in `ValidationForNextTerm()` to re-verify that `NeedToChangeTerm()` returns true:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Check term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // NEW: Re-verify that term change conditions are met
    var blockchainStartTimestamp = GetBlockchainStartTimestamp();
    var periodSeconds = GetPeriodSeconds();
    if (!validationContext.BaseRound.NeedToChangeTerm(blockchainStartTimestamp, 
        validationContext.CurrentTermNumber, periodSeconds))
        return new ValidationResult { Message = "Term change conditions not met (2/3 threshold)." };
    
    return new ValidationResult { Success = true };
}
```

This ensures on-chain validation enforces the same 2/3 consensus requirement that off-chain behavior determination uses.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanForcePrematureTermChange()
{
    // Setup: Initialize chain with multiple miners
    await InitializeConsensus();
    var maliciousMiner = GetCurrentMiners()[0];
    
    // Verify less than 2/3 miners have met term change threshold
    var currentRound = await GetCurrentRound();
    var needsTermChange = currentRound.NeedToChangeTerm(
        BlockchainStartTimestamp, CurrentTerm, PeriodSeconds);
    Assert.False(needsTermChange); // Not yet time for term change
    
    // Attack: Malicious miner creates NextTerm trigger information
    var triggerInfo = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(maliciousMiner.PublicKey),
        Behaviour = AElfConsensusBehaviour.NextTerm // WRONG - should be NextRound
    };
    
    // Generate consensus data with malicious behavior
    var consensusData = await ConsensusContract.GetConsensusExtraData
        .CallAsync(triggerInfo.ToBytesValue());
    var transaction = await ConsensusContract.GenerateConsensusTransactions
        .CallAsync(triggerInfo.ToBytesValue());
    
    // Execute the malicious NextTerm transaction
    var result = await ConsensusContract.NextTerm
        .SendAsync(NextTermInput.Parser.ParseFrom(
            transaction.Transactions[0].Params));
    
    // Verify: Term changed prematurely without 2/3 consensus
    var newRound = await GetCurrentRound();
    Assert.True(newRound.TermNumber == currentRound.TermNumber + 1);
    Assert.False(needsTermChange); // Condition was never met
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-35)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L13-53)
```csharp
    private BytesValue GetConsensusBlockExtraData(BytesValue input, bool isGeneratingTransactions = false)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);

        Assert(triggerInformation.Pubkey.Any(), "Invalid pubkey.");

        TryToGetCurrentRoundInformation(out var currentRound);

        var publicKeyBytes = triggerInformation.Pubkey;
        var pubkey = publicKeyBytes.ToHex();

        var information = new AElfConsensusHeaderInformation();
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
        }

        if (!isGeneratingTransactions) information.Round.DeleteSecretSharingInformation();

        return information.ToBytesValue();
    }
```

**File:** protobuf/acs4.proto (L24-34)
```text
    // Generate consensus extra data when a block is generated. 
    rpc GetConsensusExtraData (google.protobuf.BytesValue) returns (google.protobuf.BytesValue) {
        option (aelf.is_view) = true;
    }
    
    // Generate consensus system transactions when a block is generated. 
    // Each block will contain only one consensus transaction, which is used to write the latest consensus information 
    // to the State database.
    rpc GenerateConsensusTransactions (google.protobuf.BytesValue) returns (TransactionList) {
        option (aelf.is_view) = true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```
