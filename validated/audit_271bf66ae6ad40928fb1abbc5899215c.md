# Audit Report

## Title
Continuous Block Limit Bypass via Public Key Replacement

## Summary
A miner can bypass the AEDPoS consensus continuous block production limit (8 blocks) by strategically replacing their public key. The `RecordCandidateReplacement` method updates round information but fails to update `State.LatestPubkeyToTinyBlocksCount`, causing validation checks to be skipped and the block counter to reset instead of decrement. This allows a malicious miner to produce significantly more continuous blocks than intended by using a series of fresh keypairs.

## Finding Description

The vulnerability exists in the interaction between three key components of the AEDPoS consensus mechanism:

**1. Entry Point - Key Replacement**

The `ReplaceCandidatePubkey` method in the Election contract allows any candidate admin to replace their public key: [1](#0-0) 

This method calls `RecordCandidateReplacement` in the consensus contract: [2](#0-1) 

**2. Core Issue - Missing State Update**

The `RecordCandidateReplacement` method updates the round's `RealTimeMinersInformation` by replacing the old pubkey with the new one, but critically **does NOT update** `State.LatestPubkeyToTinyBlocksCount`: [3](#0-2) 

After this method executes, `State.LatestPubkeyToTinyBlocksCount` still references the old public key, while the miner's identity in the current round has been updated to the new key.

**3. Validation Bypass**

The `ContinuousBlocksValidationProvider` checks if a miner has exceeded the continuous block limit by comparing the stored pubkey with the current block producer's pubkey: [4](#0-3) 

When the pubkeys don't match (old key in state vs. new key producing block), the `BlocksCount < 0` check is skipped, allowing the miner to bypass the limit.

The `SenderPubkey` in the validation context comes from consensus extra data and must match the actual block signer: [5](#0-4) [6](#0-5) 

**4. Counter Reset Instead of Decrement**

After validation, `ResetLatestProviderToTinyBlocksCount` is called during consensus processing: [7](#0-6) 

When the stored pubkey doesn't match the current block producer (line 352), the else branch executes (lines 358-363), resetting the counter to `minersCountInTheory.Sub(1)` (typically 7) instead of decrementing it. This gives the miner a fresh counter.

**5. Maximum Block Limit**

The continuous block limit is defined as: [8](#0-7) 

**Attack Flow:**
1. Miner produces blocks with key_1, counter decrements: 7→6→5...→1
2. Before reaching 0, call `ReplaceCandidatePubkey(key_1, key_2)`
3. Produce next block with key_2: validation bypassed, counter resets to 7
4. Repeat with key_3, key_4, etc.

**Constraints Verified:**
- Old keys are banned after replacement (preventing reuse): [9](#0-8) 

- No rate limiting or cooldown on replacements (verified by code inspection)
- Fresh keys are unlimited and unbanned

## Impact Explanation

**Consensus Integrity Violation**: The continuous block limit exists to prevent centralization and ensure fair block production rotation among miners. By bypassing this limit, the vulnerability breaks a core consensus security guarantee.

**Quantified Impact**:
- Normal limit: 8 continuous blocks per miner
- With N prepared keypairs: attacker can produce approximately 8 + 7*(N-1) continuous blocks
- Example: 10 keypairs = ~71 continuous blocks vs. intended 8 blocks (787% increase)

**Concrete Harms**:
1. **Unfair Mining Advantage**: Attacker gains disproportionate block production opportunities
2. **Reward Misallocation**: More blocks = more mining rewards, directly extracting value from honest miners
3. **Centralization Risk**: Single miner can dominate block production, defeating the decentralization purpose of the limit
4. **Network Security Degradation**: The continuous block limit was designed to reduce fork risks and improve network resilience

**Affected Parties**: All honest miners suffer reduced mining opportunities and rewards. The entire network's decentralization and consensus security guarantees are weakened.

## Likelihood Explanation

**Reachable Entry Point**: `ReplaceCandidatePubkey` is a public method requiring only candidate admin authorization: [10](#0-9) 

Every miner controls their own candidate admin by default, making this a standard permission.

**Attacker Requirements**:
- Control of a candidate admin address (standard for any participating miner)
- Preparation of multiple fresh keypairs (cryptographically trivial, zero marginal cost)
- Timing of replacements during their mining time slots (straightforward with known consensus schedule)

**Execution Feasibility**:
- No technical barriers beyond standard miner capabilities
- No rate limiting or protective constraints in the code
- Replacements are legitimate operations that may not trigger immediate scrutiny
- Economic incentive is clear: additional block rewards

**Detection Difficulty**: While replacements are on-chain events (`CandidatePubkeyReplaced`), they are designed as legitimate maintenance operations: [11](#0-10) 

Multiple rapid replacements might appear suspicious but could be attributed to security key rotation.

**Probability Assessment**: Medium-High likelihood. The attack is technically straightforward with clear financial incentive (additional mining rewards), but requires premeditation and preparation of multiple keypairs.

## Recommendation

Update `RecordCandidateReplacement` to also update `State.LatestPubkeyToTinyBlocksCount` when a replacement occurs:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

    // If this candidate is current miner, need to modify current round information.
    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
    realTimeMinerInformation.Pubkey = input.NewPubkey;
    currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
    currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
    if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    // FIX: Update LatestPubkeyToTinyBlocksCount to reflect the new pubkey
    var latestCount = State.LatestPubkeyToTinyBlocksCount.Value;
    if (latestCount != null && latestCount.Pubkey == input.OldPubkey)
    {
        State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
        {
            Pubkey = input.NewPubkey,
            BlocksCount = latestCount.BlocksCount
        };
    }

    // Notify Treasury Contract to update replacement information.
    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = input.OldPubkey,
        NewPubkey = input.NewPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

Additionally, consider implementing rate limiting on key replacements to prevent rapid successive replacements within a short time period.

## Proof of Concept

```csharp
[Fact]
public async Task ContinuousBlockLimit_Bypass_Via_KeyReplacement_Test()
{
    // Setup: Initialize consensus with multiple miners
    await InitializeChainsAsync();
    await InitialAElfConsensusContract();
    
    // Get a miner and prepare multiple fresh keypairs
    var attackerMiner = ValidationDataCenterKeyPairs.First();
    var attackerAdmin = ValidationDataCenterKeyPairs.Last();
    var freshKey1 = SampleECKeyPairs.KeyPairs[10];
    var freshKey2 = SampleECKeyPairs.KeyPairs[11];
    
    // Track block production count
    var blocksProducedWithOriginalKey = 0;
    var blocksProducedWithFreshKey1 = 0;
    
    // Produce blocks until near limit (7 blocks)
    for (int i = 0; i < 7; i++)
    {
        await ProduceBlockWithKeyPairAsync(attackerMiner);
        blocksProducedWithOriginalKey++;
        
        var latestCount = await AEDPoSContractStub.GetLatestPubkeyToTinyBlocksCount.CallAsync(new Empty());
        latestCount.BlocksCount.ShouldBe(7 - i - 1);
    }
    
    // At this point, counter should be 0, next block would trigger limit
    var countBeforeReplacement = await AEDPoSContractStub.GetLatestPubkeyToTinyBlocksCount.CallAsync(new Empty());
    countBeforeReplacement.BlocksCount.ShouldBe(0);
    countBeforeReplacement.Pubkey.ShouldBe(attackerMiner.PublicKey.ToHex());
    
    // Perform key replacement
    var adminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, attackerAdmin);
    await adminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = attackerMiner.PublicKey.ToHex(),
        NewPubkey = freshKey1.PublicKey.ToHex()
    });
    
    // EXPLOIT: Produce blocks with new key - should reset counter instead of hitting limit
    for (int i = 0; i < 7; i++)
    {
        // This should succeed, bypassing the continuous block limit
        await ProduceBlockWithKeyPairAsync(freshKey1);
        blocksProducedWithFreshKey1++;
    }
    
    // Verify: Attacker produced 14 blocks continuously (7 + 7) instead of limit of 8
    var totalContinuousBlocks = blocksProducedWithOriginalKey + blocksProducedWithFreshKey1;
    totalContinuousBlocks.ShouldBe(14);
    
    // This violates the consensus invariant: MaximumTinyBlocksCount = 8
    totalContinuousBlocks.ShouldBeGreaterThan(AEDPoSContractConstants.MaximumTinyBlocksCount);
    
    // Can repeat with freshKey2 for another 7 blocks, etc.
}
```

## Notes

This vulnerability represents a fundamental flaw in the synchronization between the Election contract's key replacement mechanism and the Consensus contract's continuous block tracking. The issue arises because these two state variables (`RealTimeMinersInformation` and `LatestPubkeyToTinyBlocksCount`) are updated independently, creating a window for exploitation.

The attack is economically rational for miners seeking to maximize block production and rewards, and the lack of rate limiting makes it practically exploitable. The fix requires careful coordination between the Election and Consensus contracts to maintain state consistency across key replacements.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L246-246)
```csharp
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L250-254)
```csharp
        Context.Fire(new CandidatePubkeyReplaced
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L13-17)
```csharp
    /// <summary>
    ///     We can trust this because we already validated the pubkey
    ///     during `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`
    /// </summary>
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L29-32)
```csharp
        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-363)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
