# Audit Report

## Title
Incorrect Factorial Indexing in Exponential Function Causes Systematic Token Pricing Errors

## Summary
The production implementation of `Exp()` in BancorHelper contains an off-by-one indexing error in the Taylor series expansion, using (k-1)! instead of k! for each term. This mathematical error affects all token conversion operations, causing systematically incorrect Bancor pricing for every Buy and Sell transaction.

## Finding Description

The vulnerability exists in the factorial array indexing within the exponential helper function that computes token conversion prices.

**Factorial Array Initialization:**
The production code initializes the factorial array using `DynFact()` to compute factorials for indices 0-19, creating an array where `Fact[k] = k!`. [1](#0-0) 

**Incorrect Exponential Implementation:**
The `Exp()` function implements a Taylor series but uses incorrect factorial indexing. The loop iterates from 20 down to 1, and at each iteration k, it accesses `Fact[iteration - 1]`, which retrieves (k-1)! instead of the required k!. [2](#0-1) 

This causes:
- iteration=20: uses Fact[19] = 19! instead of 20!
- iteration=2: uses Fact[1] = 1! instead of 2!
- iteration=1: uses Fact[0] = 0! = 1 (correct by coincidence since 0! = 1! = 1)

**Test Version Masking the Bug:**
The test implementation hardcodes factorials with an intentional offset where `Fact[k] = (k+1)!`, which makes the same indexing logic `Fact[iteration - 1]` work correctly, thereby masking the production bug. [3](#0-2) 

**Propagation to Public Methods:**
The incorrect `Exp()` is called by both `GetReturnFromPaid()` and `GetAmountToPayFromReturn()` pricing functions. [4](#0-3) [5](#0-4) 

These pricing functions are invoked by the public `Buy()` and `Sell()` methods in the TokenConverterContract. [6](#0-5) [7](#0-6) 

## Impact Explanation

This vulnerability has **Medium** severity with the following impacts:

1. **Systematic Mispricing**: Every token conversion calculates prices using an incorrect exponential function. The correct Taylor series exp(y) = Σ(y^k/k!) is computed as Σ(y^k/(k-1)!), causing each term (except the linear term) to be k times larger than mathematically correct.

2. **Cumulative Mathematical Error**: 
   - y^2 term: 2× too large
   - y^3 term: 3× too large  
   - y^10 term: 10× too large
   - y^20 term: 20× too large

3. **Economic Integrity Violation**: The Bancor algorithm's fundamental guarantee of deterministic, mathematically fair pricing based on reserve ratios is violated. This undermines protocol trustworthiness and could enable arbitrage opportunities if users discover the discrepancy between intended and actual pricing curves.

4. **Universal Scope**: Affects 100% of token conversion transactions across all connector pairs since contract deployment.

While this doesn't enable unlimited exploitation or direct theft, it causes measurable and systematic value misallocation in the core economic functionality.

## Likelihood Explanation

**Likelihood: High (100% occurrence rate)**

- **Trigger Mechanism**: The bug executes automatically on every normal Buy/Sell operation
- **Required Privileges**: None - any user can call public transaction methods
- **Preconditions**: Only requires initialized token pairs (standard operating state)
- **Reproducibility**: Deterministic - occurs on every single transaction without exception
- **Detection Difficulty**: High, as users lack visibility into the "correct" baseline prices to compare against

This is not an exploitable attack vector but an inherent mathematical implementation error that executes continuously during normal protocol operation.

## Recommendation

Fix the factorial indexing in the `Exp()` function by changing line 159 to access the correct factorial:

**Current (Incorrect):**
```csharp
var fatorial = Fact[iteration - 1];  // Uses (k-1)!
```

**Fixed (Correct):**
```csharp
var fatorial = Fact[iteration];  // Uses k!
```

Additionally, update the factorial array initialization to include index 20:
```csharp
Fact = Array.AsReadOnly(Enumerable.Range(0, 21).Select(x => DynFact(x)).ToArray());
```

This ensures that when iteration=20, `Fact[20]` is available and equals 20!.

## Proof of Concept

The mathematical error can be demonstrated by comparing the production implementation's output with the correct Taylor series calculation. For any input value y:

**Correct Formula:** exp(y) = 1 + y/1! + y²/2! + y³/3! + ... + y^k/k!

**Production Implementation:** exp(y) = 1 + y/0! + y²/1! + y³/2! + ... + y^k/(k-1)!

Which simplifies to: exp(y) = 1 + y + y² + y³/1! + ... (with each term k times too large)

This causes every Buy and Sell transaction to use incorrect pricing, with the error magnitude increasing for higher-order terms in the Taylor expansion.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L11-21)
```csharp
    static BancorHelper()
    {
        Fact = Array.AsReadOnly(Enumerable.Range(0, 20).Select(x => DynFact(x)).ToArray());
    }

    private static long DynFact(long number)
    {
        var fact = number == 0 ? 1 : number;
        for (var i = number - 1; i >= 1; i--) fact *= i;
        return fact;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-94)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/BancorHelper.cs (L78-102)
```csharp
    private static readonly long[] Fact =
    {
        1L,
        1L * 2,
        1L * 2 * 3,
        1L * 2 * 3 * 4,
        1L * 2 * 3 * 4 * 5,
        1L * 2 * 3 * 4 * 5 * 6,
        1L * 2 * 3 * 4 * 5 * 6 * 7,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20
        //14197454024290336768L, //1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20 * 21,        // NOTE: Overflow during compilation
        //17196083355034583040L, //1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20 * 21 * 22    // NOTE: Overflow during compilation
    };
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-123)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-172)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```
