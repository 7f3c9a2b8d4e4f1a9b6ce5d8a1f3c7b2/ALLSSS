# Audit Report

## Title
TokenHolder RemoveBeneficiary Permanent DOS via Single() Exception on Multiple ProfitDetails

## Summary
The `RemoveBeneficiary()` and `AddBeneficiary()` functions in TokenHolderContract use `.Details.Single()` which throws an `InvalidOperationException` when a beneficiary has multiple ProfitDetail entries. Since the Profit contract allows multiple details per beneficiary through normal withdrawal/re-registration flows, this causes permanent DOS of beneficiary management functions.

## Finding Description

The vulnerability exists in `TokenHolderContract.RemoveBeneficiary()` where it retrieves profit details using `.Single()`: [1](#0-0) 

The same issue exists in `TokenHolderContract.AddBeneficiary()`: [2](#0-1) 

Both calls assume exactly one ProfitDetail exists per beneficiary, but this invariant is not enforced by the underlying Profit contract.

**Root Cause**: Multiple ProfitDetails can exist for a single beneficiary because:

1. **ProfitContract.AddBeneficiary appends without deduplication**: When adding a beneficiary, the code simply appends a new detail to the existing collection: [3](#0-2) 

2. **Withdrawal preserves details with unclaimed profits**: When `RemoveBeneficiary` is called during withdrawal, the `RemoveProfitDetails` method does not always physically remove details. If unclaimed profits exist (`LastProfitPeriod < CurrentPeriod`), the detail is kept with a shortened `EndPeriod`: [4](#0-3) 

**Trigger Scenario**:
1. User calls `RegisterForProfits` → Detail A created
2. Profits distributed but user doesn't claim → `LastProfitPeriod` remains less than `CurrentPeriod`
3. User calls `Withdraw` → Detail A persists with shortened `EndPeriod` (line 355)
4. User calls `RegisterForProfits` again → Detail B added to collection (line 201)
5. Manager calls `RemoveBeneficiary` → `.Single()` throws exception with 2 details

The authorization checks allow scheme managers to directly call ProfitContract.AddBeneficiary: [5](#0-4) 

TokenHolderContract creates schemes where the creator becomes the manager: [6](#0-5) 

## Impact Explanation

**Severity: HIGH** - This is a permanent DOS of critical scheme management functionality:

- **RemoveBeneficiary**: Cannot remove beneficiaries stuck with multiple details, function always throws
- **AddBeneficiary**: Cannot update beneficiary shares, function also throws on `.Single()`
- **Scheme Managers**: Lose complete control over beneficiary management
- **Recovery**: Impossible without contract upgrade

While this doesn't directly steal funds, it breaks the operational integrity of the TokenHolder profit distribution system. Beneficiaries become permanently locked in schemes with incorrect share allocations, and managers cannot fix the situation.

## Likelihood Explanation

**Likelihood: HIGH**

The most realistic trigger (Scenario B) occurs through normal user operations:

1. **Withdraw/Re-register Flow**: Natural user behavior - users may withdraw when lock expires, then re-register later. If profits weren't claimed before withdrawal, this creates multiple details.

2. **No Special Permissions**: Any registered user can trigger this through `RegisterForProfits` → `Withdraw` → `RegisterForProfits`

3. **Silent Accumulation**: The issue accumulates silently until manager attempts `RemoveBeneficiary`, at which point it's already unfixable.

Alternative scenario (Manager direct call) is also feasible since any scheme creator is a manager with authorization to call `ProfitContract.AddBeneficiary` directly.

## Recommendation

Replace `.Details.Single()` with logic that handles multiple details gracefully:

**For RemoveBeneficiary**:
```csharp
var details = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
{
    Beneficiary = input.Beneficiary,
    SchemeId = scheme.SchemeId
});

// Handle all details, not just one
var totalShares = details.Details.Sum(d => d.Shares);
```

**For AddBeneficiary**:
```csharp
var detail = State.ProfitContract.GetProfitDetails.Call(...);
var shares = input.Shares;
if (detail.Details.Any())
{
    State.ProfitContract.RemoveBeneficiary.Send(...);
    // Sum all existing shares instead of assuming Single()
    shares.Add(detail.Details.Sum(d => d.Shares));
}
```

Alternatively, ensure ProfitContract enforces the one-detail-per-beneficiary invariant by deduplicating or consolidating existing details in `AddBeneficiary`.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveBeneficiary_DOS_MultipleDetails()
{
    // Setup: Create scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    // User registers
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = DefaultSender,
        Amount = 1000
    });
    
    // Distribute profits (user doesn't claim)
    await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeManager = DefaultSender,
        AmountsMap = { {"ELF", 100} }
    });
    
    // Time passes, user withdraws (detail persists with unclaimed profits)
    await TokenHolderContractStub.Withdraw.SendAsync(DefaultSender);
    
    // User re-registers (2nd detail created)
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = DefaultSender,
        Amount = 500
    });
    
    // Manager attempts to remove - throws InvalidOperationException
    var result = await TokenHolderContractStub.RemoveBeneficiary.SendWithExceptionAsync(
        new RemoveTokenHolderBeneficiaryInput
        {
            Beneficiary = User,
            Amount = 100
        });
    
    result.TransactionResult.Error.ShouldContain("Sequence contains more than one element");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L55-55)
```csharp
            shares.Add(detail.Details.Single().Shares);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L74-78)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L346-356)
```csharp
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }
```
