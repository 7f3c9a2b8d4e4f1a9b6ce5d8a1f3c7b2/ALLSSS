# Audit Report

## Title
Missing Validation for Empty Public Keys in Miner List Causes Consensus DoS

## Summary
The `MinerList.GenerateFirstRoundOfNewTerm` method accesses the first byte of miner public keys without validating that ByteStrings are non-empty. When an empty public key is present, the code throws an `IndexOutOfRangeException`, causing consensus failure. This can be exploited through malicious genesis configuration or by calling `ReplaceCandidatePubkey` with an empty string.

## Finding Description

The root cause lies in the public key sorting logic that accesses the first byte without validation. [1](#0-0) 

**Attack Vector 1: Genesis Configuration Bypass**

The genesis configuration validation only checks the first element of `InitialMinerList`, allowing empty strings at subsequent positions to bypass validation. [2](#0-1) 

Empty strings are converted to empty ByteStrings through the hex conversion utility, which returns a zero-length byte array for empty input. [3](#0-2) 

During initialization, these empty strings are passed through without length validation. [4](#0-3) 

**Attack Vector 2: Candidate Replacement**

The `ReplaceCandidatePubkey` method validates candidate status, ban status, permissions, and duplicate candidates, but critically does NOT validate that the new public key is non-empty. [5](#0-4) 

The method proceeds to call `PerformReplacement`, which notifies the consensus contract. [6](#0-5) 

The consensus contract's `RecordCandidateReplacement` method updates the current round information without validating the new pubkey length. [7](#0-6) 

**Propagation Through Term Transitions**

During term transitions when no new election victories exist, the system uses existing miners from the current round and converts their string public keys to ByteStrings. [8](#0-7) 

This conversion of an empty string produces an empty ByteString, which then triggers the exception when `GenerateFirstRoundOfNewTerm` attempts to access the first byte.

## Impact Explanation

This vulnerability causes complete consensus failure with catastrophic impact:

1. **Chain Initialization Failure**: If exploited during genesis through malicious configuration at positions [1], [2], etc., the chain cannot complete initialization
2. **Runtime Consensus DoS**: If exploited through candidate replacement while a candidate is an active miner, the chain cannot transition to new terms
3. **No Automatic Recovery**: The `IndexOutOfRangeException` prevents round generation, requiring emergency manual intervention
4. **Network-Wide Impact**: All validators cannot produce blocks, all users cannot submit transactions, and the entire network halts

The severity is **HIGH** as it represents complete operational failure of the consensus mechanism.

## Likelihood Explanation

**Genesis Attack Path (MEDIUM likelihood):**
- Requires: Access to chain configuration before deployment
- Complexity: LOW - simply add empty string at position [1] or higher in `InitialMinerList`
- Detection: None - validation only checks first element

**Runtime Attack Path (MEDIUM likelihood):**
- Requires: Candidate admin role for an active miner
- Complexity: LOW - call `ReplaceCandidatePubkey` with empty `new_pubkey` parameter
- Scenario: Malicious insider, compromised admin account, or accidental misconfiguration
- Detection: None - no validation prevents empty pubkey

The overall probability is **MEDIUM** because while genesis configuration is typically controlled, the runtime attack path is feasible through legitimate but malicious or compromised admin accounts.

## Recommendation

Add validation to prevent empty public keys at all entry points:

**1. Fix MinerList.GenerateFirstRoundOfNewTerm with bounds checking:**
```csharp
internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
    Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
{
    var sortedMiners =
        (from obj in Pubkeys
                .Where(miner => miner != null && miner.Length > 0) // Add validation
                .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
            orderby obj.Value descending
            select obj.Key).ToList();
    
    Assert(sortedMiners.Count == Pubkeys.Count, "Invalid empty public keys detected.");
    // ... rest of method
}
```

**2. Fix genesis configuration validation to check ALL elements:**
```csharp
if (option.InitialMinerList == null || option.InitialMinerList.Count == 0 ||
    option.InitialMinerList.Any(string.IsNullOrWhiteSpace)) // Check all elements
```

**3. Add validation to ReplaceCandidatePubkey:**
```csharp
public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
{
    Assert(!string.IsNullOrWhiteSpace(input.NewPubkey), "New pubkey cannot be empty.");
    Assert(input.NewPubkey.Length >= 66, "Invalid public key length."); // Typical hex pubkey length
    // ... rest of validations
}
```

## Proof of Concept

```csharp
// Test: Empty pubkey in candidate replacement causes consensus DoS
[Fact]
public async Task ReplaceCandidatePubkey_WithEmptyString_CausesConsensusFailure()
{
    // Setup: Create candidate that becomes a miner
    var candidateKeyPair = SampleAccount.Accounts[0].KeyPair;
    var candidatePubkey = candidateKeyPair.PublicKey.ToHex();
    
    // Announce and elect candidate
    await ElectionContractStub.AnnounceElection.SendAsync(candidatePubkey);
    await ElectionContractStub.Vote.SendAsync(new VoteMinerInput { 
        CandidatePubkey = candidatePubkey,
        Amount = 100000,
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(90)
    });
    
    // Transition to new term making candidate an active miner
    await ConsensusContractStub.NextTerm.SendAsync(new NextTermInput());
    
    // Set candidate admin
    await ElectionContractStub.SetCandidateAdmin.SendAsync(new SetCandidateAdminInput {
        Pubkey = candidatePubkey,
        Admin = DefaultSender
    });
    
    // Execute attack: Replace with empty pubkey
    var result = await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(
        new ReplaceCandidatePubkeyInput {
            OldPubkey = candidatePubkey,
            NewPubkey = "" // Empty string bypasses all validation
        });
    
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Attempt term transition - this should fail with IndexOutOfRangeException
    var termTransition = await ConsensusContractStub.NextTerm.SendWithExceptionAsync(
        new NextTermInput());
    
    termTransition.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    termTransition.TransactionResult.Error.ShouldContain("IndexOutOfRangeException");
    
    // Consensus is now permanently broken - cannot transition to new terms
}
```

## Notes

This vulnerability is particularly dangerous because:
1. It affects a critical system contract (AEDPoS consensus)
2. The exception prevents any recovery path within the consensus protocol
3. Both attack vectors (genesis and runtime) lack appropriate input validation
4. The impact is immediate and total (complete chain halt)
5. Detection is only possible after the exception occurs, not preventatively

The fix requires defense-in-depth: validation at genesis configuration, at the Election contract entry point, and defensive bounds checking in the consensus logic itself.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/AEDPoSAElfModule.cs (L60-61)
```csharp
            if (option.InitialMinerList == null || option.InitialMinerList.Count == 0 ||
                string.IsNullOrWhiteSpace(option.InitialMinerList[0]))
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-18)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/AEDPoSContractInitializationProvider.cs (L43-50)
```csharp
                Params = new MinerList
                {
                    Pubkeys =
                    {
                        initializationData.InitialMinerList.Select(ByteStringHelper.FromHexString)
                    }
                }.GenerateFirstRoundOfNewTerm(initializationData.MiningInterval,
                    initializationData.StartTimestamp.ToDateTime()).ToByteString()
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-191)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-146)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L236-241)
```csharp
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
```
