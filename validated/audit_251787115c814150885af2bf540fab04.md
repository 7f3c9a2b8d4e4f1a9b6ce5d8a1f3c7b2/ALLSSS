# Audit Report

## Title
Non-Member Proposers Can Create Unreleased Proposals, Causing Governance Release Deadlock

## Summary
The Association contract fails to validate that proposers must be organization members during organization creation. This allows non-member proposers to create proposals that members can approve but cannot release, causing permanent governance deadlock when the non-member proposer is unavailable or uncooperative.

## Finding Description

The vulnerability exists in the organization validation logic, which fails to enforce a critical governance invariant: **proposers must be organization members**.

**Validation Gap**: The `Validate` method checks that both `ProposerWhiteList` and `OrganizationMemberList` are non-empty and contain no duplicates, but does NOT verify that proposer addresses must also be organization members. [1](#0-0) 

**Organization Creation**: This insufficient validation is enforced when creating organizations. [2](#0-1) 

**Proposal Creation**: When creating proposals, the contract only verifies the sender is in the `ProposerWhiteList`, not that they are a member. [3](#0-2) [4](#0-3) 

**Voting Mechanism**: Members can vote on any proposal by verifying membership, regardless of who created it. [5](#0-4) [6](#0-5) 

**Release Restriction**: The critical flaw is in the `Release` function, which enforces that ONLY the original proposer can release a proposal. [7](#0-6) 

**No Recovery Mechanism**: There is no alternative method to execute proposals. The `ClearProposal` method only removes expired proposals without executing them. [8](#0-7) 

**Attack Path:**
1. Organization is created with `ProposerWhiteList = {NonMemberX}` and `OrganizationMemberList = {MemberA, MemberB, MemberC}`
2. NonMemberX creates a critical governance proposal
3. Members vote and approve the proposal, meeting the release threshold
4. NonMemberX becomes unavailable or refuses to call `Release()`
5. The approved proposal can never be executed

## Impact Explanation

**HIGH Severity - Governance DoS:**

- **Critical approved governance actions cannot be executed** if the non-member proposer is unavailable or uncooperative
- **Members lose effective control** over their organization despite having voting power to approve proposals
- Can **permanently block critical operations** like threshold changes, member management, fund transfers, or any other governance action
- **Time-sensitive proposals may expire** before resolution, causing operational delays
- **Malicious proposers can hold organizations hostage** for extortion or to prevent competitive actions

This breaks the fundamental governance invariant that organizations should be able to execute their approved proposals. The contract design assumes that proposers will always be available to release approved proposals, but this assumption is not enforced by validation logic, creating a critical availability vulnerability.

## Likelihood Explanation

**HIGH Likelihood:**

- The `CreateOrganization` method is **publicly accessible** with no special authorization requirements
- The validation logic **explicitly allows** non-member proposers by not checking the intersection of the two lists
- Can occur through **accidental misconfiguration** (administrator error) or **intentional malicious setup**
- **No special privileges required** beyond being included in the proposer whitelist at organization creation
- **Zero-cost to exploit** once the vulnerable configuration exists
- **Economically rational** for extortion scenarios where proposers can demand payment to release approved proposals
- **High practical likelihood** in decentralized governance scenarios where proposer availability cannot be guaranteed

## Recommendation

Add validation during organization creation to ensure all proposers are also members:

```csharp
private bool Validate(Organization organization)
{
    if (organization.ProposerWhiteList.Empty() ||
        organization.ProposerWhiteList.AnyDuplicate() ||
        organization.OrganizationMemberList.Empty() ||
        organization.OrganizationMemberList.AnyDuplicate())
        return false;
    
    // NEW: Ensure all proposers are also members
    foreach (var proposer in organization.ProposerWhiteList.Proposers)
    {
        if (!organization.OrganizationMemberList.Contains(proposer))
            return false;
    }
    
    if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
        return false;
    
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    var organizationMemberCount = organization.OrganizationMemberList.Count();
    return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
}
```

Additionally, enforce this constraint in `ChangeOrganizationProposerWhiteList` to prevent introduction of non-member proposers after organization creation.

## Proof of Concept

```csharp
[Fact]
public async Task NonMemberProposer_CausesGovernanceDeadlock_Test()
{
    // Step 1: Create organization with non-member proposer
    var nonMemberProposer = Accounts[4].Address; // Not in member list
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { Reviewer1, Reviewer2, Reviewer3 } // Non-member NOT included
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 2,
            MinimalVoteThreshold = 2,
            MaximalAbstentionThreshold = 0,
            MaximalRejectionThreshold = 0
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { nonMemberProposer } // Non-member as proposer
        }
    };
    
    var orgResult = await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    orgResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // SUCCEEDS despite non-member proposer
    var organizationAddress = orgResult.Output;
    
    // Step 2: Non-member creates proposal
    var nonMemberStub = GetAssociationContractTester(Accounts[4].KeyPair);
    var proposalInput = new CreateProposalInput
    {
        ContractMethodName = nameof(TokenContractStub.Transfer),
        ToAddress = TokenContractAddress,
        Params = new TransferInput { Symbol = "ELF", Amount = 100, To = Reviewer1 }.ToByteString(),
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(2),
        OrganizationAddress = organizationAddress
    };
    
    var proposalResult = await nonMemberStub.CreateProposal.SendAsync(proposalInput);
    proposalResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var proposalId = proposalResult.Output;
    
    // Step 3: Members approve the proposal (reaches threshold)
    await GetAssociationContractTester(Reviewer1KeyPair).Approve.SendAsync(proposalId);
    await GetAssociationContractTester(Reviewer2KeyPair).Approve.SendAsync(proposalId);
    
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeTrue(); // Approval threshold reached
    
    // Step 4: Members CANNOT release the proposal
    var memberReleaseResult = await GetAssociationContractTester(Reviewer1KeyPair).Release
        .SendWithExceptionAsync(proposalId);
    memberReleaseResult.TransactionResult.Error.ShouldContain("No permission"); // DEADLOCK: Members cannot release
    
    // Step 5: Only non-member proposer can release (governance deadlock if unavailable)
    var nonMemberReleaseResult = await nonMemberStub.Release.SendAsync(proposalId);
    nonMemberReleaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Only proposer can release
}
```

This test demonstrates that:
1. Organizations can be created with non-member proposers (validation gap)
2. Non-members can create proposals that members approve
3. Members cannot release their own approved proposals
4. Only the non-member proposer can release, creating a governance deadlock scenario

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```
