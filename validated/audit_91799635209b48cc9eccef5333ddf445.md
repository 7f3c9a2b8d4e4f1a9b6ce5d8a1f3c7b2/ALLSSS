# Audit Report

## Title
Association Organization DOS Attack via Unbounded Member List Size

## Summary
The Association contract allows creation of organizations with arbitrarily large member lists (up to 128KB state size limit), enabling approximately 3,000-3,700 members per organization. This causes O(n) and O(m×n) complexity in voting authorization checks and proposal threshold validation operations, resulting in execution observer branch count violations that render the organization completely unusable for governance operations.

## Finding Description

The vulnerability stems from missing upper bound validation on organization member list size. The `OrganizationMemberList` structure uses a protobuf repeated field that performs linear search operations via the `Contains()` method. [1](#0-0) 

This O(n) operation is invoked in multiple critical execution paths:

**Voting Authorization Path**: Every vote operation (Approve/Reject/Abstain) checks membership by calling `AssertIsAuthorizedOrganizationMember()`, which performs a linear search through all organization members. [2](#0-1)  This is invoked during each voting transaction at: [3](#0-2) [4](#0-3) [5](#0-4) 

**Proposal Threshold Validation Path (O(m×n) complexity)**: The threshold checking logic uses LINQ `Count()` with the `Contains()` predicate, creating nested loops. For rejections: [6](#0-5) 

For abstentions: [7](#0-6) 

For approvals: [8](#0-7) 

Each `Count(organization.OrganizationMemberList.Contains)` operation iterates through all votes (m) and performs an O(n) member lookup for each vote, resulting in O(m×n) total complexity.

**Root Cause**: The validation function checks for empty lists and duplicates but imposes NO maximum size constraint. [9](#0-8) 

Organizations can be created by anyone via the public `CreateOrganization()` method with arbitrary member counts up to the state size limit. [10](#0-9) 

**Size Constraints**: The only limiting factor is the 128KB state size constraint [11](#0-10)  allowing approximately 3,000-3,700 members per organization (given ~35 bytes per address including protobuf overhead).

## Impact Explanation

AElf enforces a 15,000 branch count limit per transaction to prevent infinite loops. [12](#0-11) [13](#0-12) 

With an organization containing 3,000 members:
- A single `Approve()` call performs ~3,000 comparisons in `Contains()`, approaching the branch limit
- `IsReleaseThresholdReached()` with just 10 votes performs 30,000 iterations (10 votes × 3,000 members), exceeding the branch limit
- Transactions fail with `RuntimeBranchThresholdExceededException` [14](#0-13) 

**Complete Governance DOS**: Once an attacker creates such an organization:
1. Legitimate members **cannot vote** - all Approve/Reject/Abstain transactions fail due to branch limit violations
2. **Cannot check proposal status** - GetProposal() fails when computing ToBeReleased due to O(m×n) complexity [15](#0-14) 
3. **Cannot modify membership** - AddMember/RemoveMember operations using `AnyDuplicate()` [16](#0-15)  become computationally prohibitive
4. **Organization becomes permanently unusable** for all governance purposes

All legitimate members of the attacked organization lose their governance rights, and proposals cannot be executed even if logically approved.

## Likelihood Explanation

**Attack Feasibility: HIGH**

1. **Entry Point**: The `CreateOrganization()` method is public and accessible to any caller with no authorization checks
2. **Attack Cost**: One-time transaction to create an organization with maximum members. While storing 3,000+ addresses incurs state write fees, this is a single upfront cost that permanently disables the organization
3. **No Preconditions**: Attacker needs no special permissions or existing state
4. **Execution Simplicity**: Single transaction with a large `OrganizationMemberList` in `CreateOrganizationInput`
5. **Detection Difficulty**: No validation prevents this during organization creation. The DOS only manifests when legitimate users attempt to interact with the organization

The attacker pays once to create the organization, but all subsequent users either pay excessive costs or fail entirely. This is a classic griefing attack with asymmetric cost structure favoring the attacker.

## Recommendation

Add a maximum member list size constant and enforce it in the `Validate()` method:

```csharp
// In AssociationConstants.cs
public const int MaxOrganizationMemberCount = 100; // or appropriate limit

// In Association_Helper.cs, Validate() method
private bool Validate(Organization organization)
{
    if (organization.ProposerWhiteList.Empty() ||
        organization.ProposerWhiteList.AnyDuplicate() ||
        organization.OrganizationMemberList.Empty() ||
        organization.OrganizationMemberList.AnyDuplicate() ||
        organization.OrganizationMemberList.Count() > AssociationConstants.MaxOrganizationMemberCount)
        return false;
    // ... rest of validation
}
```

Consider using a more efficient data structure (e.g., hash set) for member lookups if larger organizations are needed, though this would require careful consideration of deterministic serialization for consensus.

## Proof of Concept

```csharp
[Fact]
public async Task CreateOrganization_WithLargeMembers_CausesVotingDOS()
{
    // Create organization with 3000 members
    var memberList = new OrganizationMemberList();
    for (int i = 0; i < 3000; i++)
    {
        memberList.OrganizationMembers.Add(SampleAddress.AddressList[i % SampleAddress.AddressList.Count]);
    }
    
    var createInput = new CreateOrganizationInput
    {
        OrganizationMemberList = memberList,
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1,
            MinimalVoteThreshold = 1,
            MaximalAbstentionThreshold = 0,
            MaximalRejectionThreshold = 0
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { DefaultSender }
        }
    };
    
    var orgAddress = await AssociationContractStub.CreateOrganization.SendAsync(createInput);
    
    // Create proposal
    var proposalId = await CreateProposalAsync(orgAddress.Output);
    
    // Attempt to vote - should fail with branch threshold exceeded
    var approveResult = await AssociationContractStub.Approve.SendWithExceptionAsync(proposalId);
    approveResult.TransactionResult.Error.ShouldContain("branch threshold");
    
    // Attempt to get proposal - should fail with branch threshold exceeded
    var getProposalResult = await AssociationContractStub.GetProposal.CallWithExceptionAsync(proposalId);
    getProposalResult.Value.ShouldContain("branch threshold");
}
```

### Citations

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L24-24)
```csharp
        var readyToRelease = IsReleaseThresholdReached(proposal, organization);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L128-128)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L148-148)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L168-168)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L29-33)
```csharp
    public void BranchCount()
    {
        if (_branchThreshold != -1 && _branchCount == _branchThreshold)
            throw new RuntimeBranchThresholdExceededException(
                $"Contract branch threshold {_branchThreshold} exceeded.");
```

**File:** src/AElf.Sdk.CSharp/Exceptions.cs (L77-86)
```csharp
public class RuntimeBranchThresholdExceededException : BaseAElfException
{
    public RuntimeBranchThresholdExceededException()
    {
    }

    public RuntimeBranchThresholdExceededException(string message) : base(message)
    {
    }
}
```

**File:** contract/AElf.Contracts.Association/Association_Extensions.cs (L24-27)
```csharp
    public static bool AnyDuplicate(this OrganizationMemberList organizationMemberList)
    {
        return organizationMemberList.OrganizationMembers.GroupBy(m => m).Any(g => g.Count() > 1);
    }
```
