# Audit Report

## Title
Stale Admin Privileges After Parliament-Initiated Admin Change Allows Unauthorized Governance Voting

## Summary
When Parliament changes a candidate's admin via `SetCandidateAdmin`, the function fails to remove the candidate from the old admin's `ManagedCandidatePubkeysMap` entry. This creates a state inconsistency where the old admin retains the ability to vote on Parliament proposals on behalf of the candidate, effectively creating a governance authorization bypass.

## Finding Description

The vulnerability exists in the `SetCandidateAdmin` method which manages the bidirectional mapping between candidates and their admins. [1](#0-0) 

When Parliament calls `SetCandidateAdmin` to change a candidate's admin from A to B, the permission check is bypassed for Parliament: [2](#0-1) 

The function correctly updates `CandidateAdmins[pubkey]` to point to the new admin and adds the pubkey to the new admin's managed list: [3](#0-2) 

However, the critical bug occurs in the cleanup logic which attempts to remove the pubkey from the old admin's list but instead removes it from `Context.Sender` (Parliament's address): [4](#0-3) 

Since Parliament's `ManagedCandidatePubkeysMap` is empty or doesn't contain this pubkey, no removal occurs from the actual old admin A's list. This creates an inconsistent state where:
- `CandidateAdmins[X] = B` (correct)
- `ManagedCandidatePubkeysMap[A] = [X]` (stale!)
- `ManagedCandidatePubkeysMap[B] = [X]` (correct)

The Parliament contract's authorization mechanism relies on `GetManagedPubkeys` to allow admins to vote on behalf of their managed candidates: [5](#0-4) 

This method queries the Election contract's `GetManagedPubkeys` view function: [6](#0-5) 

This authorization check is used in all critical governance voting methods: [7](#0-6) 

Because the old admin A still has the stale entry in `ManagedCandidatePubkeysMap[A]`, when A calls Parliament voting methods, the authorization check returns the candidate's pubkey, allowing A to vote on proposals as if they were still the legitimate admin.

## Impact Explanation

**Governance Authorization Bypass:** The revoked admin retains the ability to vote (Approve/Reject/Abstain) on Parliament proposals on behalf of a miner they should no longer control. This means both the old admin A and new admin B can simultaneously vote on behalf of the same miner, effectively giving one miner two votes in Parliament decisions.

**Affected Parties:**
- **Protocol Governance:** Admin changes intended to revoke compromised access fail, allowing potentially malicious former admins to continue participating in critical governance decisions
- **New Admins:** The intended admin transfer is undermined as the old admin retains full voting privileges
- **Parliament Members:** Proposal outcomes can be manipulated by unauthorized voters, compromising the integrity of the governance process

**Concrete Harm:**
- Unauthorized approval/rejection of system contract upgrades
- Manipulation of economic parameters (mining rewards, transaction fees, inflation rates)
- Unauthorized cross-chain management decisions
- Compromise of any governance-controlled protocol parameters
- Dual voting power for a single miner position, skewing vote thresholds

**Severity Justification:** HIGH - This is a direct governance authorization bypass affecting the core decision-making mechanism of the AElf protocol. While it requires Parliament to trigger the bug (a trusted role), the scenario of changing a compromised or organizationally reassigned admin is a legitimate operational requirement, making this vulnerability exploitable in real-world situations.

## Likelihood Explanation

**Attacker Profile:** The "attacker" is a former admin (A) whose privileges were supposed to be revoked through a Parliament-initiated admin change. They only need to control their original admin address and have basic knowledge of calling Parliament contract methods.

**Attack Complexity:** Very low. The vulnerability is triggered automatically whenever Parliament changes an admin via `SetCandidateAdmin`. The exploitation requires no sophisticated techniques - the old admin simply calls `Parliament.Approve`, `Parliament.Reject`, or `Parliament.Abstain` as they normally would.

**Feasibility Conditions:**
1. Parliament must change a candidate's admin (standard operational scenario for compromised keys or organizational restructuring)
2. The candidate must be a current miner/parliament member (the exact scenario where admin changes matter most)
3. The old admin must still control their address (likely if keys weren't compromised, just organizationally reassigned)

**Precondition Realism:** All preconditions are realistic and expected during normal protocol operations. Admin changes due to:
- Security incidents (compromised keys requiring admin rotation)
- Organizational restructuring (transferring miner operations between entities)
- Governance policy changes
These are standard governance operations in any blockchain protocol.

**Detection Constraints:** The bug executes silently with no error thrown. The inconsistent state is not easily detectable without explicitly querying both `GetCandidateAdmin` and `GetManagedPubkeys` for cross-validation, which is not part of standard operational procedures.

**Probability Assessment:** High likelihood. Every admin change initiated by Parliament automatically creates this vulnerability. Former admins may not even realize their access should have been revoked, leading to accidental exploitation, or they may intentionally exploit it knowing the bug exists.

## Recommendation

Modify the `SetCandidateAdmin` method to remove the pubkey from the **old admin's** managed list instead of from `Context.Sender`. The fix should retrieve the old admin address from `CandidateAdmins[pubkey]` before updating it:

```csharp
public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
{
    // ... existing validation code ...
    
    var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
    
    // ... existing permission check code ...
    
    // Store old admin BEFORE updating
    var oldAdmin = State.CandidateAdmins[pubkey];
    
    // Update to new admin
    State.CandidateAdmins[pubkey] = input.Admin;
    
    var pubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey));
    
    // Add to new admin's managed list
    var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
    if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
        newAdminManagedPubkeys.Value.Add(pubkeyByteString);
    State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;
    
    // Remove from OLD ADMIN's managed list (not Context.Sender)
    if (oldAdmin != null)
    {
        var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[oldAdmin] ?? new PubkeyList();
        if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[oldAdmin] = oldAdminManagedPubkeys;
    }
    
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task StaleAdminPrivileges_UnauthorizedParliamentVoting_Test()
{
    // Setup: Create a candidate with admin A
    var candidateKeyPair = SampleKeyPairs.KeyPairs[0];
    var oldAdminKeyPair = SampleKeyPairs.KeyPairs[1];
    var newAdminKeyPair = SampleKeyPairs.KeyPairs[2];
    
    var candidatePubkey = candidateKeyPair.PublicKey.ToHex();
    var oldAdminAddress = Address.FromPublicKey(oldAdminKeyPair.PublicKey);
    var newAdminAddress = Address.FromPublicKey(newAdminKeyPair.PublicKey);
    
    // Candidate announces election with admin A
    await ElectionContractStub.AnnounceElection.SendAsync(oldAdminAddress);
    
    // Verify initial state: admin A manages candidate
    var initialManagedPubkeys = await ElectionContractStub.GetManagedPubkeys.CallAsync(oldAdminAddress);
    Assert.Contains(ByteString.CopyFrom(candidateKeyPair.PublicKey), initialManagedPubkeys.Value);
    
    // Create a Parliament proposal
    var proposalId = await CreateParliamentProposal();
    
    // Parliament changes admin from A to B
    await ParliamentContractStub.SetCandidateAdmin.SendAsync(new SetCandidateAdminInput
    {
        Pubkey = candidatePubkey,
        Admin = newAdminAddress
    });
    
    // Verify CandidateAdmins updated correctly
    var currentAdmin = await ElectionContractStub.GetCandidateAdmin.CallAsync(new StringValue { Value = candidatePubkey });
    Assert.Equal(newAdminAddress, currentAdmin);
    
    // Verify new admin B has the candidate in their managed list
    var newAdminManagedPubkeys = await ElectionContractStub.GetManagedPubkeys.CallAsync(newAdminAddress);
    Assert.Contains(ByteString.CopyFrom(candidateKeyPair.PublicKey), newAdminManagedPubkeys.Value);
    
    // BUG: Old admin A still has stale entry in ManagedCandidatePubkeysMap
    var oldAdminManagedPubkeys = await ElectionContractStub.GetManagedPubkeys.CallAsync(oldAdminAddress);
    Assert.Contains(ByteString.CopyFrom(candidateKeyPair.PublicKey), oldAdminManagedPubkeys.Value); // Should be empty!
    
    // EXPLOIT: Old admin A can still vote on behalf of candidate
    var parliamentStubAsOldAdmin = GetParliamentContractTester(oldAdminKeyPair);
    var result = await parliamentStubAsOldAdmin.Approve.SendAsync(proposalId);
    
    // Verify the unauthorized vote was recorded
    var proposal = await ParliamentContractStub.GetProposal.CallAsync(proposalId);
    Assert.Contains(Address.FromPublicKey(candidateKeyPair.PublicKey), proposal.Approvals);
    
    // Both old admin A and new admin B can now vote on behalf of the same miner!
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L68-73)
```csharp
    public MappedState<string, Address> CandidateAdmins { get; set; }

    /// <summary>
    ///     Admin address -> Pubkey
    /// </summary>
    public MappedState<Address, PubkeyList> ManagedCandidatePubkeysMap { get; set; }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L27-40)
```csharp
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L42-49)
```csharp
        State.CandidateAdmins[pubkey] = input.Admin;

        var pubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey));

        var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
        if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            newAdminManagedPubkeys.Value.Add(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L51-54)
```csharp
        var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender] ?? new PubkeyList();
        if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[Context.Sender] = oldAdminManagedPubkeys;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L112-140)
```csharp
    private Address GetAndCheckActualParliamentMemberAddress()
    {
        var currentParliament = GetCurrentMinerList();

        if (currentParliament.Any(r => r.Equals(Context.Sender))) return Context.Sender;

        if (State.ElectionContract.Value == null)
        {
            var electionContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName);
            if (electionContractAddress == null)
                // Election Contract not deployed - only possible in test environment.
                throw new AssertionException("Unauthorized sender.");

            State.ElectionContract.Value = electionContractAddress;
        }

        var managedPubkey = State.ElectionContract.GetManagedPubkeys.Call(Context.Sender);
        if (!managedPubkey.Value.Any()) throw new AssertionException("Unauthorized sender.");

        if (managedPubkey.Value.Count > 1)
            throw new AssertionException("Admin with multiple managed pubkeys cannot handle proposal.");

        var actualMemberAddress = Address.FromPublicKey(managedPubkey.Value.Single().ToByteArray());
        if (!currentParliament.Any(r => r.Equals(actualMemberAddress)))
            throw new AssertionException("Unauthorized sender.");

        return actualMemberAddress;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L427-430)
```csharp
    public override PubkeyList GetManagedPubkeys(Address input)
    {
        return State.ManagedCandidatePubkeysMap[input];
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L78-94)
```csharp
    public override Empty Approve(Hash input)
    {
        var parliamentMemberAddress = GetAndCheckActualParliamentMemberAddress();
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedByMember(proposal, parliamentMemberAddress);
        proposal.Approvals.Add(parliamentMemberAddress);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = parliamentMemberAddress,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```
