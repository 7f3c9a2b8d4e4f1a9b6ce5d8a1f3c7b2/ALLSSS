# Audit Report

## Title
Parliament Proposal Vote Count Miscalculation Due to Dynamic Miner List Retrieval

## Summary
The Parliament contract's `IsReleaseThresholdReached()` function retrieves the current miner list at validation time rather than using the miner list from when votes were cast. When parliament members change during term transitions, votes from former members are silently discarded, causing legitimate proposals to fail threshold validation despite having sufficient votes when cast.

## Finding Description

The Parliament contract uses the current block producer (miner) set as voting members. The vulnerability occurs because vote validation retrieves the **current** miner list dynamically on each call, rather than using the miner list that was active when votes were cast.

**Root Cause:**

The `IsReleaseThresholdReached()` function calls `GetCurrentMinerList()` to fetch parliament members: [1](#0-0) 

This function makes a cross-contract call to the consensus contract to retrieve the **current** miner list: [2](#0-1) 

The retrieved current member list is then used to filter stored votes. Only votes from current members are counted in rejection validation: [3](#0-2) 

The same filtering applies to abstentions: [4](#0-3) 

And to approvals: [5](#0-4) 

**Why This Is Exploitable:**

The consensus contract returns the current miner list from the active round: [6](#0-5) 

Term transitions update the miner list, which changes the set of valid voters: [7](#0-6) 

When `Release()` is called, it invokes the validation function which uses this new member list: [8](#0-7) 

The ProposalInfo structure stores voter addresses but not which term they voted in: [9](#0-8) 

**Exploitation Scenario:**
1. Proposal created with miner set M1 [Alice, Bob, Charlie] during Term N
2. Alice and Bob approve (2/3 = 66.7% approval)
3. Term transition occurs after 7 days, miner set changes to M2 [Charlie, Dave, Eve] for Term N+1
4. When Release() is called, only votes from current members [Charlie, Dave, Eve] are counted
5. Alice and Bob's votes are silently discarded
6. Proposal fails threshold despite having 66.7% approval when votes were cast

## Impact Explanation

**High Severity** - This vulnerability directly compromises governance integrity:

1. **Legitimate Proposals Blocked**: Valid proposals that met approval thresholds at voting time can be prevented from execution simply by delaying release until after a term change removes supporting voters.

2. **Governance Timing Attacks**: Adversaries can manipulate proposal outcomes by coordinating release timing with term transitions, making governance decisions dependent on timing rather than vote merit.

3. **Vote Invalidation**: Parliament members who cast valid votes have their votes silently discarded without notification, violating the fundamental governance principle that votes should be counted.

4. **Critical System Impact**: Parliament governs critical operations including contract upgrades, parameter changes, and treasury management. Compromising this governance layer affects the entire protocol.

The severity is high rather than critical because exploitation requires specific timing windows and does not directly steal funds, but it fundamentally undermines the governance security model.

## Likelihood Explanation

**Medium-High Likelihood** - This vulnerability will occur naturally and can be deliberately exploited:

**Natural Occurrence:**
- Terms change every 604,800 seconds (7 days) in production [10](#0-9) 
- Proposals typically expire in 259,200 seconds (72 hours) [11](#0-10) 
- Any proposal created within 3 days of a term transition can span term boundaries
- This represents approximately 43% of all proposals (3/7 days)

**Exploitation Requirements:**
- No special privileges needed beyond proposer authorization
- Term transition schedule is deterministic and publicly observable
- Only requires timing coordination (creating proposals near term boundaries)
- No technical sophistication required

**Detection Difficulty:**
- Vote discarding is silent with no events or error messages
- Appears as legitimate threshold validation failure
- Cannot be distinguished from genuine vote insufficiency without detailed analysis

The combination of high natural occurrence rate and low exploitation barrier makes this a realistic and probable attack vector.

## Recommendation

**Store the miner list snapshot with each proposal** to preserve vote validity across term transitions:

1. **Add term number field to ProposalInfo**: Store the term number when the proposal is created
2. **Retrieve historical miner list**: Use `State.MinerListMap[termNumber]` from the consensus contract instead of `GetCurrentMinerList()`
3. **Validate against snapshot**: Count votes only from members who were valid at proposal creation time

Alternatively, **implement a grace period mechanism** that allows proposals to complete within their expiration window regardless of term transitions, or **automatically release approved proposals** before term changes occur.

## Proof of Concept

```csharp
// Test scenario demonstrating the vulnerability
public async Task Parliament_Vote_Discarded_After_Term_Transition()
{
    // 1. Create proposal with 3 miners [Alice, Bob, Charlie]
    var proposalId = await ParliamentContract.CreateProposal(input);
    
    // 2. Alice and Bob approve (2/3 = 67% approval)
    await ParliamentContract.Approve(proposalId, alice);
    await ParliamentContract.Approve(proposalId, bob);
    
    // 3. Verify proposal is releasable before term transition
    var canRelease = await ParliamentContract.IsReleaseThresholdReached(proposalId);
    Assert.True(canRelease); // Passes with 2/3 approval
    
    // 4. Simulate term transition - miner list changes to [Charlie, Dave, Eve]
    await ConsensusContract.NextTerm(newMinerList);
    
    // 5. Attempt to release - Alice and Bob's votes now ignored
    var result = await ParliamentContract.Release(proposalId);
    
    // Expected: Release succeeds (had 67% approval when voted)
    // Actual: Release fails "Not approved" (Alice/Bob votes discarded)
    Assert.True(result.Failed); // Vulnerability confirmed
}
```

**Notes**

This is a **design flaw** in how the Parliament contract handles vote validation across term boundaries. Unlike the Association contract where the member list is static unless explicitly changed, Parliament's member list changes automatically every 7 days through consensus term transitions. The lack of term-aware vote counting creates a governance integrity issue where approximately 43% of proposals are naturally vulnerable to having their votes invalidated through no fault of the participants.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L13-20)
```csharp
    private List<Address> GetCurrentMinerList()
    {
        RequireConsensusContractStateSet();
        var miner = State.ConsensusContract.GetCurrentMinerList.Call(new Empty());
        var members = miner.Pubkeys.Select(publicKey =>
            Address.FromPublicKey(publicKey.ToByteArray())).ToList();
        return members;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L38-38)
```csharp
        var parliamentMembers = GetCurrentMinerList();
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-70)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L72-78)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(parliamentMembers.Contains);
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L31-42)
```csharp
    public override MinerList GetCurrentMinerList(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var round)
            ? new MinerList
            {
                Pubkeys =
                {
                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))
                }
            }
            : new MinerList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** protobuf/parliament_contract.proto (L116-143)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/ConsensusOptions.cs (L12-12)
```csharp
    public long PeriodSeconds { get; set; } = 604800;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-5)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
```
