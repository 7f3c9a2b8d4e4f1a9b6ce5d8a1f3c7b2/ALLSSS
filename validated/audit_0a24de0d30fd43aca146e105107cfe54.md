# Audit Report

## Title
Consensus DoS via Missing Validation of Extra Block Producer Uniqueness in Round Data

## Summary
The AEDPoS consensus contract fails to validate that exactly one miner has the `IsExtraBlockProducer` flag set to true when processing NextRound transitions. A malicious miner can inject round data with multiple miners marked as extra block producers, which passes all validation checks but causes system transactions to fail with a fatal exception in subsequent rounds, permanently halting the blockchain.

## Finding Description

The consensus system correctly generates round data with exactly one extra block producer. [1](#0-0)  However, when miners submit `NextRound` transactions, the validation logic does not enforce this critical invariant.

**Attack Execution Path:**

1. A malicious miner designated as extra block producer submits a `NextRound` transaction with modified `NextRoundInput` where multiple miners have `IsExtraBlockProducer = true`. The `NextRoundInput` structure contains a map of miners, each with their own `IsExtraBlockProducer` boolean field. [2](#0-1) 

2. The `NextRound` method accepts this input and processes it. [3](#0-2) 

3. The validation providers applied for NextRound behavior do not check `IsExtraBlockProducer` uniqueness: [4](#0-3) 
   - `MiningPermissionValidationProvider` only verifies miner list membership [5](#0-4) 
   - `TimeSlotValidationProvider` only validates timing
   - `NextRoundMiningOrderValidationProvider` only checks mining order [6](#0-5) 
   - `RoundTerminateValidationProvider` only validates round number increments [7](#0-6) 

4. The corrupted round data is stored in state via `ProcessNextRound` â†’ `AddRoundInformation`. [8](#0-7) 

5. In subsequent blocks, the system automatically generates `ClaimTransactionFees` transactions for the current miner. [9](#0-8) 

6. The `ClaimTransactionFees` method calls `AssertSenderIsCurrentMiner`, which invokes the consensus contract's `IsCurrentMiner` method. [10](#0-9) 

7. The `IsCurrentMiner` method uses `.Single()` to retrieve the extra block producer, which throws `InvalidOperationException` when multiple miners have `IsExtraBlockProducer = true`. [11](#0-10) 

8. The exception causes transaction execution to fail with `ExecutionStatus.ContractError`, and the exception is re-thrown. [12](#0-11) 

9. The system transaction failure causes block validation to fail, and all subsequent blocks are rejected, permanently halting the chain.

## Impact Explanation

**Severity: CRITICAL**

This vulnerability causes a complete and permanent blockchain halt:

- **Unrecoverable Consensus Failure**: All miners are unable to produce valid blocks because the automatically generated `ClaimTransactionFees` system transaction fails with an unhandled exception in every block attempt.

- **Permanent State Corruption**: The corrupted round data is permanently stored in the blockchain state. No on-chain mechanism exists to correct it, as the system cannot process any blocks once the corrupted round becomes active.

- **Network-Wide Impact**: All network participants are affected simultaneously. Users cannot submit transactions, validators cannot produce blocks, and all dependent services become unavailable.

- **Manual Recovery Required**: Recovery requires either a hard fork to a state before the corruption, or manual state surgery through privileged node operations, both requiring coordinated off-chain intervention from all network participants.

The severity is critical because the attack achieves permanent denial of service of the entire blockchain with no possibility of on-chain recovery.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The attack is highly feasible once the attacker achieves the required position:

**Attacker Requirements:**
- Must become a miner through normal election/staking mechanisms (achievable by any actor with sufficient stake)
- Must wait to be designated as extra block producer (happens through deterministic rotation, giving every miner periodic opportunity)

**Attack Characteristics:**
- **Low Technical Complexity**: The attacker simply modifies the `NextRoundInput` protobuf structure before submitting their `NextRound` transaction, setting multiple miners' `is_extra_block_producer` field to true.
- **Guaranteed Success**: If executed correctly, the attack deterministically causes chain halt. There is no randomness or race condition.
- **Undetectable Until Too Late**: The corrupted round passes all validation checks. The vulnerability only manifests in the next round when system transactions begin failing.
- **No Cryptographic Barriers**: The round data itself is not cryptographically signed or integrity-protected beyond basic transaction signing.

**Feasibility Factors:**
- The extra block producer role rotates among all miners every round
- A single malicious or compromised miner can execute this attack
- No special infrastructure or resources are required beyond normal mining operations
- The attack is repeatable and can be executed by any miner in their designated slot

The likelihood is medium-high rather than high only because it requires the attacker to first become a miner and wait for their extra block producer designation, but these are normal protocol participation requirements with no additional security barriers.

## Recommendation

Add a validation provider that enforces the extra block producer uniqueness invariant:

```csharp
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        
        if (validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextRound &&
            validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextTerm)
        {
            validationResult.Success = true;
            return validationResult;
        }
        
        var extraBlockProducerCount = validationContext.ExtraData.Round.RealTimeMinersInformation.Values
            .Count(m => m.IsExtraBlockProducer);
            
        if (extraBlockProducerCount != 1)
        {
            validationResult.Message = $"Invalid extra block producer count: {extraBlockProducerCount}. Expected exactly 1.";
            return validationResult;
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Register this provider in `ValidateBeforeExecution` for NextRound and NextTerm behaviors:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new ExtraBlockProducerValidationProvider()); // Add this
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new ExtraBlockProducerValidationProvider()); // Add this
    break;
```

## Proof of Concept

```csharp
[Fact]
public async Task ExtraBlockProducerUniquenessAttack_CausesChainHalt()
{
    // Setup: Initialize chain with multiple miners
    var miners = await InitializeChainWithMinersAsync();
    var maliciousMiner = miners[0];
    
    // Wait until malicious miner is designated as extra block producer
    await AdvanceToExtraBlockProducerSlotAsync(maliciousMiner);
    
    // Generate legitimate NextRound data
    var nextRoundData = await GenerateNextRoundDataAsync();
    
    // Attack: Modify the NextRoundInput to have multiple extra block producers
    var corruptedInput = nextRoundData.Clone();
    foreach (var miner in corruptedInput.RealTimeMinersInformation.Values)
    {
        miner.IsExtraBlockProducer = true; // Set ALL miners as extra block producers
    }
    
    // Submit the corrupted NextRound transaction
    var result = await ExecuteNextRoundAsync(maliciousMiner, corruptedInput);
    result.Status.ShouldBe(TransactionResultStatus.Mined); // Passes validation
    
    // Move to next round where corruption manifests
    await AdvanceToNextRoundAsync();
    
    // Attempt to mine a block - ClaimTransactionFees system transaction will fail
    var blockMiningResult = await AttemptBlockProductionAsync(miners[1]);
    
    // Verify chain halt: block production fails due to system transaction exception
    blockMiningResult.Status.ShouldBe(BlockProductionStatus.Failed);
    blockMiningResult.Error.ShouldContain("InvalidOperationException");
    blockMiningResult.Error.ShouldContain("Sequence contains more than one matching element");
    
    // Verify permanent halt: no miner can produce blocks
    foreach (var miner in miners)
    {
        var attemptResult = await AttemptBlockProductionAsync(miner);
        attemptResult.Status.ShouldBe(BlockProductionStatus.Failed);
    }
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** protobuf/aedpos_contract.proto (L458-475)
```text
message NextRoundInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-92)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/ClaimFeeTransactionGenerator.cs (L28-73)
```csharp
    public async Task<List<Transaction>> GenerateTransactionsAsync(Address from, long preBlockHeight,
        Hash preBlockHash)
    {
        var generatedTransactions = new List<Transaction>();

        if (preBlockHeight < AElfConstants.GenesisBlockHeight)
            return generatedTransactions;

        var chainContext = new ChainContext
        {
            BlockHash = preBlockHash,
            BlockHeight = preBlockHeight
        };

        var tokenContractAddress = await _smartContractAddressService.GetAddressByContractNameAsync(chainContext,
            TokenSmartContractAddressNameProvider.StringName);

        if (tokenContractAddress == null)
            return generatedTransactions;

        var totalTxFeesMap = await _totalTransactionFeesMapProvider.GetTotalTransactionFeesMapAsync(chainContext);
        if (totalTxFeesMap == null || !totalTxFeesMap.Value.Any() || totalTxFeesMap.BlockHeight != preBlockHeight ||
            totalTxFeesMap.BlockHash != preBlockHash)
        {
            Logger.LogDebug(
                "Won't generate ClaimTransactionFees because no tx fee charged in previous block.");
            // If previous block doesn't contain logEvent named TransactionFeeCharged, won't generate this tx.
            return new List<Transaction>();
        }

        generatedTransactions.AddRange(new List<Transaction>
        {
            new()
            {
                From = from,
                MethodName = nameof(TokenContractImplContainer.TokenContractImplStub.ClaimTransactionFees),
                To = tokenContractAddress,
                RefBlockNumber = preBlockHeight,
                RefBlockPrefix = BlockHelper.GetRefBlockPrefix(preBlockHash),
                Params = totalTxFeesMap.ToByteString()
            }
        });

        Logger.LogTrace("Tx ClaimTransactionFees generated.");
        return generatedTransactions;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-906)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
        var claimTransactionExecuteHeight = State.ClaimTransactionFeeExecuteHeight.Value;

        Assert(claimTransactionExecuteHeight < Context.CurrentHeight,
            $"This method already executed in height {State.ClaimTransactionFeeExecuteHeight.Value}");
        State.ClaimTransactionFeeExecuteHeight.Value = Context.CurrentHeight;
        Context.LogDebug(() => $"Claim transaction fee. {input}");
        State.LatestTotalTransactionFeesMapHash.Value = HashHelper.ComputeFrom(input);
        foreach (var bill in input.Value)
        {
            var symbol = bill.Key;
            var amount = bill.Value;
            ModifyBalance(Context.Self, symbol, amount);
            Context.Fire(new TransactionFeeClaimed
            {
                Symbol = symbol,
                Amount = amount,
                Receiver = Context.Self
            });
            
            TransferTransactionFeesToFeeReceiver(symbol, amount);
        }

        Context.LogDebug(() => "Finish claim transaction fee.");

        return new Empty();
    }

    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L200-206)
```csharp
        catch (Exception ex)
        {
            Logger.LogError(ex, "Transaction execution failed");
            txContext.Trace.ExecutionStatus = ExecutionStatus.ContractError;
            txContext.Trace.Error += ex + "\n";
            throw;
        }
```
