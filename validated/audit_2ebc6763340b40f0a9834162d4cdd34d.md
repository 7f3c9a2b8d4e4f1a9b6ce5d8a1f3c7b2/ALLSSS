# Audit Report

## Title
Stale Continuous Block Counter Bypasses Severe Status Emergency Limit

## Summary
During Severe emergency status, the AEDPoS consensus contract's validation system uses a stale `LatestPubkeyToTinyBlocksCount` counter from state that was set before the emergency status was detected. This allows miners to continue producing blocks based on their pre-emergency allowance (up to 8 blocks) instead of being immediately limited to 1 block, completely undermining the emergency safety mechanism designed to prevent the chain from advancing too far ahead of the Last Irreversible Block (LIB).

## Finding Description

The AEDPoS consensus implements an emergency brake mechanism where `GetMaximumBlocksCount()` returns 1 when the blockchain enters Severe status (when current round number is at least 8 rounds ahead of the LIB round). [1](#0-0) 

However, the validation logic creates a Time-Of-Check-Time-Of-Use (TOCTOU) vulnerability through the following execution flow:

**Validation Phase (BEFORE Execution):**

When `ValidateConsensusBeforeExecution` is called, it invokes `ValidateBeforeExecution` which creates a `ConsensusValidationContext` containing the **stale** `LatestPubkeyToTinyBlocksCount` value from state. [2](#0-1) 

The `ContinuousBlocksValidationProvider` validates this counter, but only rejects blocks when `BlocksCount < 0`. [3](#0-2) 

**Execution Phase (AFTER Validation):**

After validation passes, the consensus transaction (UpdateValue, UpdateTinyBlockInformation, or NextRound) calls `ProcessConsensusInformation`. [4](#0-3) 

Inside `ProcessConsensusInformation`, the system calls `GetMaximumBlocksCount()` which NOW evaluates the current blockchain status and returns 1 for Severe status, then calls `ResetLatestProviderToTinyBlocksCount(1)`. [5](#0-4) 

**The Critical Flaw:**

When `ResetLatestProviderToTinyBlocksCount` is called with the new emergency limit (1), it only **decrements** the existing counter if the same miner continues producing blocks. [6](#0-5) 

The new limit is only applied when a **different** miner takes over. [7](#0-6) 

**Concrete Attack Scenario:**

1. Normal operation: Miner A has been producing consecutive blocks, with `LatestPubkeyToTinyBlocksCount = {Pubkey: A, BlocksCount: 7}` (maximum normal value, since `MaximumTinyBlocksCount = 8`). [8](#0-7) 

2. System enters Severe status due to LIB lag (R >= R_LIB + 8). [9](#0-8) 

3. Miner A produces Block N:
   - Validation reads stale `BlocksCount = 7` from state (passes validation since 7 >= 0)
   - Block executes, `GetMaximumBlocksCount()` returns 1 (Severe limit)
   - `ResetLatestProviderToTinyBlocksCount(1)` decrements: `BlocksCount = 7 - 1 = 6`

4. Miner A produces Block N+1:
   - Validation reads `BlocksCount = 6` (passes)
   - Block executes, decrements to 5

5. This continues until Block N+7:
   - Validation reads `BlocksCount = 0` (still passes)
   - Block executes, decrements to -1

6. Block N+8:
   - Validation reads `BlocksCount = -1` (FINALLY FAILS)

**Result:** Miner A produces 8 blocks during Severe emergency status instead of the intended 1 block limit.

## Impact Explanation

The Severe status is a critical safety mechanism triggered when the blockchain mining status becomes dangerous - specifically when the current round number is at least `SevereStatusRoundsThreshold` (Math.Max(8, MaximumTinyBlocksCount) = 8) rounds ahead of the Last Irreversible Block round. [10](#0-9) 

The system fires an `IrreversibleBlockHeightUnacceptable` event to notify miners not to package normal transactions, and sets `IsPreviousBlockInSevereStatus` to true, clearly indicating this is an emergency condition. [11](#0-10) 

**Concrete Harm:**

1. **Chain Safety Compromised:** The emergency limit exists to prevent the chain from advancing too far ahead of the LIB. When bypassed, the chain can continue advancing 8x faster than intended during this critical period, increasing fork risk and chain reorganization vulnerability.

2. **Emergency Response Ineffective:** The system detects the dangerous condition and attempts to limit block production to 1, but the stale counter allows miners to ignore this limit, making the emergency brake mechanism ineffective.

3. **Quantified Violation:** With maximum pre-emergency `BlocksCount = 7`, a miner can produce 8 blocks instead of 1 block during Severe status - an **8x violation** of the emergency safety limit.

4. **Affects All Participants:** Chain instability affects finality guarantees and transaction irreversibility for all network participants, not just the miner producing the blocks.

## Likelihood Explanation

**Preconditions (All Realistic):**

1. **Miner Producing Consecutive Blocks:** This is normal behavior during consensus operation. Any miner can naturally accumulate a non-zero `BlocksCount` value (up to 7) by producing consecutive blocks during normal operation.

2. **System Enters Severe Status:** This occurs when network conditions cause LIB to lag behind the current round by 8+ rounds. Common causes include:
   - Network partitions or connectivity issues
   - Consensus delays where miners fail to produce blocks in their time slots
   - Chain fork scenarios being resolved

3. **Same Miner Continues:** The miner who was producing blocks when Severe status triggers naturally continues attempting to produce blocks - this is expected consensus behavior.

**No Special Permissions Required:**

The vulnerability affects legitimate miners operating normally within consensus rules. No malicious intent or special manipulation is needed - the issue triggers automatically during normal consensus operation when the timing conditions align.

**Probability: HIGH**

This vulnerability will trigger naturally whenever:
- A miner happens to be producing consecutive blocks (common)
- Network conditions cause LIB lag triggering Severe status (occurs during network issues)
- The same miner continues mining (natural behavior)

The issue is architectural and cannot be avoided through operational procedures or external monitoring.

## Recommendation

Fix the TOCTOU vulnerability by ensuring the emergency limit is enforced immediately when Severe status is detected. The validation should use the **current** emergency limit rather than a stale counter value.

**Option 1: Immediate Reset on Status Change**

Modify `ResetLatestProviderToTinyBlocksCount` to detect when the blockchain has entered Severe status and immediately reset the counter to 0 (allowing only 1 more block) instead of decrementing:

```csharp
private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
{
    LatestPubkeyToTinyBlocksCount currentValue;
    if (State.LatestPubkeyToTinyBlocksCount.Value == null)
    {
        currentValue = new LatestPubkeyToTinyBlocksCount
        {
            Pubkey = _processingBlockMinerPubkey,
            BlocksCount = minersCountInTheory.Sub(1)
        };
        State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
    }
    else
    {
        currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
        if (currentValue.Pubkey == _processingBlockMinerPubkey)
        {
            // NEW: If in Severe status, reset to emergency limit instead of decrementing
            var newCount = State.IsPreviousBlockInSevereStatus.Value 
                ? minersCountInTheory.Sub(1)  // Use current emergency limit
                : currentValue.BlocksCount.Sub(1);  // Normal decrement
                
            State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = newCount
            };
        }
        else
        {
            State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = minersCountInTheory.Sub(1)
            };
        }
    }
}
```

**Option 2: Validation Uses Current Status**

Alternatively, modify the validation to evaluate the current blockchain status and compare against the current limit rather than just checking if the stored counter is negative. This would require passing blockchain status information to the validation context.

## Proof of Concept

```csharp
[Fact]
public async Task StaleCounterBypassesSevereStatusLimit()
{
    // Setup: Initialize consensus with normal miners
    await InitializeAElfConsensus();
    var firstMiner = InitialCoreDataCenterKeyPairs[0];
    var firstMinerStub = GetAEDPoSContractStub(firstMiner);
    
    // Step 1: Have miner produce consecutive blocks to build up BlocksCount
    for (int i = 0; i < 7; i++)
    {
        var blockTime = BlockchainStartTimestamp.AddSeconds(i * 4000);
        await ProduceBlock(firstMiner, blockTime);
    }
    
    // Verify miner has accumulated BlocksCount = 7
    var latestCount = await firstMinerStub.GetLatestPubkeyToTinyBlocksCount.CallAsync(new Empty());
    latestCount.BlocksCount.ShouldBe(6); // Should be 6 after 7 blocks (starts at 7, decremented each time)
    
    // Step 2: Simulate Severe status by manipulating round/LIB to be 8+ rounds apart
    // Force CurrentRound to be 10 and LIB round to be 1 (difference = 9 > 8)
    await ForceRoundAndLibDistance(currentRound: 10, libRound: 1);
    
    // Step 3: Verify GetMaximumBlocksCount returns 1 (Severe limit)
    var maxBlocks = await firstMinerStub.GetMaximumBlocksCount.CallAsync(new Empty());
    maxBlocks.Value.ShouldBe(1); // Should be 1 in Severe status
    
    // Step 4: EXPLOIT - Same miner continues producing blocks
    int blocksProduced = 0;
    var currentBlocksCount = 6;
    
    while (currentBlocksCount >= 0)
    {
        var blockTime = BlockchainStartTimestamp.AddSeconds((7 + blocksProduced) * 4000);
        var result = await ProduceBlock(firstMiner, blockTime);
        result.Status.ShouldBe(TransactionResultStatus.Mined); // Should succeed
        
        blocksProduced++;
        currentBlocksCount--;
    }
    
    // VULNERABILITY CONFIRMED: Miner produced 7 more blocks (total 8 including first one after Severe)
    // when emergency limit should have allowed only 1 block
    blocksProduced.ShouldBe(7); // Produced 7 additional blocks
    
    // Next block should finally fail
    var finalBlockTime = BlockchainStartTimestamp.AddSeconds((7 + blocksProduced) * 4000);
    var finalResult = await ProduceBlock(firstMiner, finalBlockTime);
    finalResult.Status.ShouldBe(TransactionResultStatus.Failed);
    finalResult.Error.ShouldContain("Sender produced too many continuous blocks");
}
```

This test demonstrates that a miner can produce 8 blocks during Severe emergency status instead of being limited to 1 block, confirming the stale counter bypass vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L117-128)
```csharp
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-112)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }

    #endregion

    #region UpdateTinyBlockInformation

    public override Empty UpdateTinyBlockInformation(TinyBlockInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L67-69)
```csharp
        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-357)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L358-363)
```csharp
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
