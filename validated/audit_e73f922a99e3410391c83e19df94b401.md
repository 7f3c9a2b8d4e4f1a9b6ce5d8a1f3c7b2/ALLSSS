# Audit Report

## Title
Retroactive Threshold Changes Allow Invalidation of Already-Approved Proposals

## Summary
The Parliament, Association, and Referendum governance contracts evaluate proposal approval status dynamically against current organization thresholds rather than snapshotting thresholds at proposal creation time. This allows threshold changes to retroactively invalidate already-approved proposals, breaking the fundamental governance invariant that approved proposals remain approved and executable.

## Finding Description

The vulnerability exists because proposals do not snapshot approval thresholds at creation time. The `ProposalInfo` structure stores only vote counts (approvals, rejections, abstentions) without any threshold snapshot fields. [1](#0-0) 

When a proposal is created via `CreateNewProposal`, only the organization address is stored as a reference, with no threshold values captured at creation time: [2](#0-1) 

The `ChangeOrganizationThreshold` function directly updates the organization's threshold in storage without any consideration for existing proposals: [3](#0-2) 

When `Release` is called, it retrieves the organization from storage and checks approval status using the **current** threshold, not the threshold that was active when votes were cast: [4](#0-3) 

The `IsReleaseThresholdReached` function dynamically evaluates approval by comparing vote counts against the organization's current threshold values: [5](#0-4) 

The actual threshold comparison happens in `CheckEnoughVoteAndApprovals` which uses the current `organization.ProposalReleaseThreshold`: [6](#0-5) 

The `GetProposal` view function also calculates `ToBeReleased` dynamically using current organization state, meaning the same proposal's approval status can change over time: [7](#0-6) 

This identical pattern exists in Association and Referendum contracts: [8](#0-7) [9](#0-8) [10](#0-9) [11](#0-10) 

**Attack Flow:**
1. Organization has 50% approval threshold (MinimalApprovalThreshold = 5000)
2. Proposal P1 receives 60% approval (6000 votes) and shows `ToBeReleased = true`
3. Attacker creates proposal P2 to call `ChangeOrganizationThreshold` with 70% threshold (7000)
4. P2 gets approved under current 50% threshold and is released
5. P2 execution updates threshold to 70%
6. Now P1 only has 60% but needs 70% - `Release(P1)` reverts with "Not approved"
7. P1 is permanently blocked despite having legitimate approval under original rules

## Impact Explanation

This vulnerability breaks a fundamental governance security invariant: **once a proposal reaches the required approval threshold, it should remain approved and executable**.

The impact is **HIGH** because:

1. **Governance Manipulation**: Malicious actors can strategically increase thresholds to block specific approved proposals from executing, enabling censorship of legitimate governance actions

2. **Predictability Loss**: Governance participants cannot rely on approval status - a proposal showing `ToBeReleased = true` may become unreleasable moments later

3. **Accidental Invalidation**: Legitimate threshold adjustments can unintentionally block approved proposals, even without malicious intent

4. **Protocol-Wide Impact**: This affects all three governance contracts (Parliament, Association, Referendum) with identical implementations

5. **Governance Deadlock**: Critical proposals (emergency responses, system upgrades) approved under current rules can be retroactively blocked, potentially causing protocol-level issues

## Likelihood Explanation

The likelihood is **MEDIUM-HIGH** because:

**Attacker Requirements:**
- Must be an authorized proposer (common for organization members)
- Must convince enough members to approve a threshold change (achievable with influence or during legitimate threshold discussions)

**Attack Complexity: LOW**
- Uses only standard governance operations (CreateProposal, Approve, Release)
- No special privileges or exploit techniques required
- Can be executed through normal governance workflow
- The `ChangeOrganizationThreshold` is callable by the organization itself via virtual inline call during proposal release

**Feasibility:**
- Threshold changes are normal operations as shown in test suite
- Can occur accidentally during legitimate governance threshold adjustments
- No technical barriers prevent this attack
- No validation checks for impact on existing proposals

**Detection: DIFFICULT**
- Threshold changes appear as legitimate governance actions
- The retroactive effect on existing proposals is not immediately obvious
- No events or warnings indicate affected proposals

## Recommendation

Implement threshold snapshotting at proposal creation time:

1. **Add threshold snapshot fields to ProposalInfo:**
```protobuf
message ProposalInfo {
    // ... existing fields ...
    ProposalReleaseThreshold creation_threshold = 14; // Snapshot at creation
}
```

2. **Capture thresholds in CreateNewProposal:**
```csharp
var proposal = new ProposalInfo
{
    // ... existing fields ...
    CreationThreshold = organization.ProposalReleaseThreshold // Snapshot
};
```

3. **Use snapshotted thresholds in IsReleaseThresholdReached:**
```csharp
private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
{
    // Use proposal.CreationThreshold instead of organization.ProposalReleaseThreshold
    var threshold = proposal.CreationThreshold;
    // ... rest of validation logic using snapshot
}
```

Alternatively, implement a check in `ChangeOrganizationThreshold` to prevent threshold increases when pending approved proposals exist, or emit warnings about affected proposals.

## Proof of Concept

```csharp
[Fact]
public async Task RetroactiveThresholdChange_BlocksApprovedProposal_Test()
{
    // Setup: Create organization with 50% threshold
    var minimalApprovalThreshold = 5000; // 50%
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold, 2000, 2000, 5000);
    
    // Step 1: Create and approve proposal P1 with 60% votes
    var proposalP1 = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
    await ApproveAsync(InitialMinersKeyPairs[0], proposalP1); // 3 miners = 60% approval
    await ApproveAsync(InitialMinersKeyPairs[1], proposalP1);
    
    // Verify P1 is releasable under current 50% threshold
    var proposal = await ParliamentContractStub.GetProposal.CallAsync(proposalP1);
    proposal.ToBeReleased.ShouldBeTrue(); // 60% >= 50%
    
    // Step 2: Create threshold change proposal to 70%
    var newThreshold = new ProposalReleaseThreshold
    {
        MinimalApprovalThreshold = 7000, // 70%
        MinimalVoteThreshold = 7000,
        MaximalAbstentionThreshold = 2000,
        MaximalRejectionThreshold = 2000
    };
    
    var thresholdChangeProposal = await ParliamentContractStub.CreateProposal.SendAsync(
        new CreateProposalInput
        {
            ContractMethodName = nameof(ParliamentContractStub.ChangeOrganizationThreshold),
            ToAddress = ParliamentContractAddress,
            Params = newThreshold.ToByteString(),
            ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(2),
            OrganizationAddress = organizationAddress
        });
    
    // Step 3: Approve and release threshold change under current 50% threshold
    await ApproveAsync(InitialMinersKeyPairs[0], thresholdChangeProposal.Output);
    await ApproveAsync(InitialMinersKeyPairs[1], thresholdChangeProposal.Output);
    await ParliamentContractStub.Release.SendAsync(thresholdChangeProposal.Output);
    
    // Step 4: Verify P1 is now blocked despite having been approved
    var proposalAfterChange = await ParliamentContractStub.GetProposal.CallAsync(proposalP1);
    proposalAfterChange.ToBeReleased.ShouldBeFalse(); // 60% < 70% - RETROACTIVELY BLOCKED
    
    // Attempting to release P1 now fails
    var releaseResult = await ParliamentContractStub.Release.SendWithExceptionAsync(proposalP1);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // VULNERABILITY CONFIRMED: Previously approved proposal is now unreleasable
}
```

## Notes

This vulnerability represents a critical design flaw in the governance system where the approval status of proposals is not immutable once reached. The dynamic threshold evaluation against current state instead of creation-time snapshots allows governance participants to retroactively change the rules, undermining the predictability and integrity of the governance process. This affects all three governance contract types (Parliament, Association, Referendum) identically.

### Citations

**File:** protobuf/parliament_contract.proto (L116-143)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L225-253)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L147-160)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L225-248)
```csharp
    public override ProposalOutput GetProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        if (proposal == null) return new ProposalOutput();

        var organization = State.Organizations[proposal.OrganizationAddress];

        return new ProposalOutput
        {
            ProposalId = proposalId,
            ContractMethodName = proposal.ContractMethodName,
            ExpiredTime = proposal.ExpiredTime,
            OrganizationAddress = proposal.OrganizationAddress,
            Params = proposal.Params,
            Proposer = proposal.Proposer,
            ToAddress = proposal.ToAddress,
            ToBeReleased = Validate(proposal) && IsReleaseThresholdReached(proposal, organization),
            ApprovalCount = proposal.Approvals.Count,
            RejectionCount = proposal.Rejections.Count,
            AbstentionCount = proposal.Abstentions.Count,
            Title = proposal.Title,
            Description = proposal.Description
        };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```
