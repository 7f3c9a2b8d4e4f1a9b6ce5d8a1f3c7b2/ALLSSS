# Audit Report

## Title
Multiple UpdateValue Submissions Allow Miners to Manipulate Next Round Position Order

## Summary
A miner who has already submitted consensus data via `UpdateValue` can call it again within the same round across different blocks to recalculate their `FinalOrderOfNextRound` position. This allows malicious miners to manipulate their position in the next round's mining order, violating consensus fairness guarantees.

## Finding Description

The `UpdateValue` method allows miners to submit consensus information for the current round. However, the protection mechanism only prevents multiple calls within the same block, not across different blocks within the same round.

**Entry Point**: The `UpdateValue` method invokes `ProcessConsensusInformation` [1](#0-0) 

**Insufficient Guard**: The `EnsureTransactionOnlyExecutedOnceInOneBlock` method only checks if `State.LatestExecutedHeight.Value != Context.CurrentHeight`, preventing execution within the SAME block but not across different blocks in the same round [2](#0-1) 

If a miner calls `UpdateValue` in block 10 (sets `LatestExecutedHeight = 10`), they can call it again in block 15 of the same round (where `CurrentHeight = 15 != 10`), and the check passes.

**Unconditional Overwrite**: The `ProcessUpdateValue` method unconditionally overwrites critical consensus fields without checking if they were already set [3](#0-2) 

This includes `Signature`, `OutValue`, `SupposedOrderOfNextRound`, and `FinalOrderOfNextRound`, plus application of `TuneOrderInformation` to adjust other miners' positions.

**Validation Bypass**: The validation flow calls `RecoverFromUpdateValue` BEFORE running validation providers, modifying `baseRound` with provided data [4](#0-3) 

The `RecoverFromUpdateValue` method unconditionally overwrites the miner's consensus data [5](#0-4) 

When `UpdateValueValidationProvider` validates, it sees the already-modified state rather than the original on-chain state [6](#0-5) 

The validation only checks that `OutValue` and `Signature` are filled (not null), but does NOT check if they were already set in the original on-chain state.

**Position Manipulation**: The next round position is deterministically calculated from the signature hash using `GetAbsModulus(sigNum, minersCount) + 1` [7](#0-6) 

An attacker can compute offline which signature will yield position 1.

**Next Round Generation**: The manipulated `FinalOrderOfNextRound` values are directly used to determine actual mining positions in the next round [8](#0-7) 

**No On-Chain Prevention**: The off-chain command generation checks `if (_minerInRound.OutValue == null)` before suggesting `UpdateValue` behavior [9](#0-8) 

However, this is NOT enforced on-chain. A malicious actor can bypass this by manually crafting `UpdateValue` transactions even after their `OutValue` is already set.

## Impact Explanation

**Consensus Integrity Violation**: This vulnerability directly compromises the fairness of the AEDPoS consensus mechanism. The deterministic position assignment based on unpredictable signatures is a fundamental security property. This vulnerability completely undermines that guarantee.

**Mining Order Manipulation**: An attacker can choose their position in the next round by:
1. First call: Submit UpdateValue with signature S1, get position N
2. Offline: Compute which signature S2 yields position 1
3. Second call: Submit UpdateValue with signature S2 in a different block
4. Result: Secure position 1 in next round

**Honest Miner Displacement**: When the attacker changes their position, conflict resolution forces honest miners to different positions, affecting the entire round's fairness.

**Severity: HIGH** - Direct attack on consensus mechanism integrity, violating fundamental fairness assumptions and potentially leading to mining power centralization.

## Likelihood Explanation

**Attacker Requirements**:
- Authorized miner in current miner list (normal operational state)
- Ability to compute signature hashes offline (trivial)
- Ability to produce multiple blocks within one round (standard miner capability)

**Attack Complexity: LOW**
1. Miner produces first block with signature S1, gets position 5
2. Compute offline: find S2 that yields position 1
3. Produce another block within same round with signature S2
4. Second `UpdateValue` overwrites previous data, secures position 1

**Feasibility**: Fully feasible under normal conditions:
- Rounds span multiple blocks
- No rate limiting beyond per-block check
- No detection mechanism
- Transaction pool accepts second `UpdateValue` as valid

**Probability: HIGH** - Any miner can execute with minimal effort. The only barrier is being in the active miner set, which is the normal operational state.

## Recommendation

Add a check in `ProcessUpdateValue` or `UpdateValueValidationProvider` to reject updates when `OutValue` is already set:

```csharp
// In UpdateValueValidationProvider.cs
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    // Check if OutValue is already set in the ORIGINAL on-chain state
    var originalMinerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    if (originalMinerInRound.OutValue != null)
        return false; // Already submitted consensus data this round
    
    return minerInRound.OutValue != null && minerInRound.Signature != null &&
           minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
}
```

However, this requires accessing the original unmodified state. A better fix is to check BEFORE calling `RecoverFromUpdateValue` in `ValidateBeforeExecution`:

```csharp
// In AEDPoSContract_Validation.cs
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
{
    // Check if this miner has already submitted UpdateValue this round
    var minerInRound = baseRound.RealTimeMinersInformation[extraData.SenderPubkey.ToHex()];
    if (minerInRound.OutValue != null)
        return new ValidationResult { Success = false, Message = "UpdateValue already submitted this round." };
    
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MultipleUpdateValueSubmissions_ShouldManipulatePosition()
{
    // Setup: Initialize consensus with multiple miners
    var initialMiners = GenerateInitialMiners(5);
    await InitializeConsensus(initialMiners);
    
    var attackerKeyPair = initialMiners.First();
    var attackerPubkey = attackerKeyPair.PublicKey.ToHex();
    
    // Round 1: Attacker submits first UpdateValue
    var firstSignature = GenerateSignature(attackerKeyPair, round: 1, attempt: 1);
    await SubmitUpdateValue(attackerKeyPair, firstSignature);
    
    var roundAfterFirst = await GetCurrentRound();
    var firstPosition = roundAfterFirst.RealTimeMinersInformation[attackerPubkey].FinalOrderOfNextRound;
    
    // Attacker computes offline which signature gives position 1
    var targetSignature = ComputeSignatureForPosition(attackerKeyPair, targetPosition: 1, minersCount: 5);
    
    // Attacker submits second UpdateValue in same round, different block
    await ProduceBlock(); // Move to next block
    await SubmitUpdateValue(attackerKeyPair, targetSignature);
    
    var roundAfterSecond = await GetCurrentRound();
    var secondPosition = roundAfterSecond.RealTimeMinersInformation[attackerPubkey].FinalOrderOfNextRound;
    
    // Assert: Position changed from first to target position
    Assert.NotEqual(firstPosition, secondPosition);
    Assert.Equal(1, secondPosition); // Attacker secured position 1
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-260)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-56)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```
