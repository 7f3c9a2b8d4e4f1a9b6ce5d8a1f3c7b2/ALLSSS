# Audit Report

## Title
Fee Atomicity Violation: Partial Charge Applied on Transaction Failure

## Summary
The AElf transaction fee charging mechanism violates atomicity by deducting users' available balance even when transactions fail due to insufficient fees. When users lack sufficient funds, the system charges their existing balance despite returning `Success = false` and preventing the main transaction from executing, resulting in permanent fund loss without service.

## Finding Description

The vulnerability exists in the fee charging flow where partial balances are charged even when fee charging fails.

**Root Cause - Partial Balance Added to Bill on Failure:**
In `ChargeBaseFee`, when `ChargeFirstSufficientToken` returns false due to insufficient funds, the code still adds the user's existing balance to the transaction bill. [1](#0-0) 

**Unconditional Bill Processing:**
The `TryToChargeTransactionFee` method calls `ModifyBalance` unconditionally at line 118, regardless of whether `chargingResult` is true or false, processing whatever amounts exist in the bill. [2](#0-1) 

**Balance Deduction Execution:**
The `ModifyBalance` function iterates through all positive amounts in the bill and deducts them from the user's balance, firing `TransactionFeeCharged` events for each deduction. [3](#0-2) 

**State Commitment Despite Failure:**
The transaction execution service commits pre-transaction state changes to the state cache even when the pre-transaction fails, as explicitly documented in the comment "If pre-tx fails, still commit the changes, but return false to notice outside to stop the execution." [4](#0-3) 

**Execution Stopped by Pre-Plugin:**
The `IsStopExecuting` method checks the `ChargeTransactionFeesOutput.Success` field and returns true to stop execution when it's false, preventing the main transaction from running. [5](#0-4) 

**Execution Flow:**
1. User with 5 ELF balance attempts transaction requiring 10 ELF fee
2. `ChargeBaseFee` fails but adds 5 ELF to bill
3. `ModifyBalance` deducts the 5 ELF
4. Function returns `Success = false` with "Transaction fee not enough"
5. Pre-execution plugin stops main transaction via `IsStopExecuting`
6. **Result: User loses 5 ELF but transaction never executes**

**Test Verification:**
Existing test cases confirm this behavior. The `ChargeFee_TxFee_FailedTest` shows a user with 99,999 balance attempting a transaction requiring 100,000 fee results in balance becoming 0, with transaction status Failed and error "Pre-Error: Transaction fee not enough." [6](#0-5) 

Additional test cases demonstrate partial charging: when a user has 9 ELF but needs 10 ELF, all 9 ELF is charged despite charging being marked unsuccessful. [7](#0-6) 

## Impact Explanation

This breaks the fundamental atomicity principle of blockchain transactions: fees should only be charged when transactions successfully execute.

**Direct Fund Loss:**
- Users with balance B and required fee F where B < F lose min(B, F) tokens permanently
- These tokens are deducted with no service provided
- No recovery mechanism exists in the protocol

**Affected Users:**
- Any user with insufficient transaction fees
- Occurs naturally when balances deplete, fees increase, or users miscalculate
- No malicious actor required - this is a systemic protocol flaw

**Severity Justification:**
- **Critical Impact**: Direct, permanent fund loss from all affected users
- **Core Mechanism**: Affects the fundamental transaction fee charging system
- **Invariant Violation**: Breaks the atomic fee charging guarantee
- **High Frequency**: Triggered on every insufficient-balance transaction attempt

## Likelihood Explanation

**Directly Reachable:**
The `ChargeTransactionFees` method is automatically invoked by the ACS1 pre-execution plugin for every transaction that implements the ACS1 standard. [8](#0-7) 

**No Special Preconditions:**
- Users simply need insufficient balance for transaction fees
- No malicious intent, special permissions, or complex setup required
- Natural occurrence in normal blockchain operation

**Automatic Trigger:**
The vulnerability activates automatically in the transaction execution flow without any explicit exploitation attempt.

**High Probability:**
Given the frequency of blockchain transactions and inevitable cases of users having insufficient balances (balance depletion, fee changes, multiple concurrent transactions), this affects users regularly in production environments.

## Recommendation

Modify the `ChargeBaseFee` function to NOT add existing balance to the bill when charging fails. The bill should remain empty when insufficient funds are detected, preventing any balance deduction:

```csharp
private bool ChargeBaseFee(...)
{
    if (!ChargeFirstSufficientToken(...))
    {
        Context.LogDebug(() => "Failed to charge first sufficient token.");
        // DO NOT add existingBalance to bill on failure
        // Remove lines 349-353 that add partial balance
        return false;
    }
    // ... rest of successful charging logic
}
```

Alternatively, implement an all-or-nothing approach: only call `ModifyBalance` if `chargingResult` is true in `TryToChargeTransactionFee`.

## Proof of Concept

The existing test case `ChargeFee_TxFee_FailedTest` demonstrates the vulnerability: [6](#0-5) 

This test shows:
1. User receives 99,999 tokens (line 310)
2. Fee is set to 100,000 tokens (line 322)
3. Transaction is attempted via `DummyMethod` (line 328-329)
4. Transaction fails with "Transaction fee not enough" (line 331)
5. **User's balance becomes 0** - all 99,999 tokens charged (line 340)
6. Transaction fee charged equals the entire original balance (line 341)

This confirms users lose their entire balance despite transaction failure, violating the atomicity principle of transaction fees.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L84-126)
```csharp
    private ChargeTransactionFeesOutput TryToChargeTransactionFee(ChargeTransactionFeesInput input, Address fromAddress,
        TransactionFeeBill bill, TransactionFreeFeeAllowanceBill allowanceBill, Dictionary<string, long> fee,
        bool isSizeFeeFree)
    {
        Context.LogDebug(() => "TryToChargeTransactionFee Start");
        var chargingResult =
            ChargeTransactionFeesToBill(input, fromAddress, ref bill, ref allowanceBill, fee, isSizeFeeFree);
        if (!chargingResult)
        {
            var delegatorAddress = fromAddress;
            chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                isSizeFeeFree, delegatorAddress);
        }

        if (!chargingResult)
        {
            var transactionFeeDelegatees =
                State.TransactionFeeDelegateInfoMap[fromAddress][input.ContractAddress][input.MethodName] ??
                State.TransactionFeeDelegateesMap[fromAddress];
            if (transactionFeeDelegatees != null)
            {
                var delegateeAddress = transactionFeeDelegatees.Delegatees;
                foreach (var (delegatee, _) in delegateeAddress)
                {
                    chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                        isSizeFeeFree, Address.FromBase58(delegatee));
                    if (chargingResult)
                    {
                        break;
                    }
                }
            }
        }

        ModifyBalance(fromAddress, bill, allowanceBill);
        var chargingOutput = new ChargeTransactionFeesOutput { Success = chargingResult };
        if (!chargingResult)
            chargingOutput.ChargingInformation = "Transaction fee not enough.";
        
        Context.LogDebug(() => "TryToChargeTransactionFee End");
        Context.LogDebug(() => "ChargeTransactionFees End");
        return chargingOutput;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L237-266)
```csharp
    private void ModifyBalance(Address fromAddress, TransactionFeeBill bill,
        TransactionFreeFeeAllowanceBill allowanceBill)
    {
        Assert(!IsInTransferBlackListInternal(fromAddress), "Charge fee address is in transfer blacklist.");
        SetOrRefreshTransactionFeeFreeAllowances(fromAddress);
        var freeAllowancesMap = CalculateTransactionFeeFreeAllowances(fromAddress);

        // Update balances and allowances
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            ModifyBalance(fromAddress, symbol, -amount);
            Context.Fire(new TransactionFeeCharged
            {
                Symbol = symbol,
                Amount = amount,
                ChargingAddress = fromAddress
            });
        }

        if (freeAllowancesMap.Map == null || freeAllowancesMap.Map.Count == 0) return;

        foreach (var (symbol, amount) in allowanceBill.FreeFeeAllowancesMap)
        {
            if (amount > 0)
            {
                ModifyFreeFeeAllowanceAmount(fromAddress, freeAllowancesMap, symbol, -amount);
            }
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L343-353)
```csharp
        if (!ChargeFirstSufficientToken(methodFeeMap, fromAddress, out var symbolToChargeBaseFee,
                out var amountToChargeBaseFee, out var existingBalance, out var existingAllowance,
                transactionFeeFreeAllowancesMap,
                delegations))
        {
            Context.LogDebug(() => "Failed to charge first sufficient token.");
            if (symbolToChargeBaseFee != null)
            {
                bill.FeesMap.Add(symbolToChargeBaseFee, existingBalance);
                allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);
            } // If symbol == 
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L283-293)
```csharp
                var stateSets = preTrace.GetStateSets().ToList();
                internalStateCache.Update(stateSets);
                var parentStateCache = txContext.StateCache as TieredStateCache;
                parentStateCache?.Update(stateSets);

                if (!plugin.IsStopExecuting(preTrace.ReturnValue, out var error)) continue;

                // If pre-tx fails, still commit the changes, but return false to notice outside to stop the execution.
                preTrace.Error = error;
                preTrace.ExecutionStatus = ExecutionStatus.Executed;
                return false;
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L58-121)
```csharp
    public async Task<IEnumerable<Transaction>> GetPreTransactionsAsync(IReadOnlyList<ServiceDescriptor> descriptors,
        ITransactionContext transactionContext)
    {
        try
        {
            var chainContext = new ChainContext
            {
                BlockHash = transactionContext.PreviousBlockHash,
                BlockHeight = transactionContext.BlockHeight - 1
            };

            var tokenContractAddress = await _smartContractAddressService.GetAddressByContractNameAsync(
                chainContext,
                TokenSmartContractAddressNameProvider.StringName);

            if (transactionContext.BlockHeight < AElfConstants.GenesisBlockHeight + 1 ||
                tokenContractAddress == null)
                return new List<Transaction>();

            if (!IsApplicableToTransaction(descriptors, transactionContext.Transaction, tokenContractAddress))
                return new List<Transaction>();

            var tokenStub = _contractReaderFactory.Create(new ContractReaderContext
            {
                Sender = transactionContext.Transaction.From,
                ContractAddress = tokenContractAddress,
                RefBlockNumber = transactionContext.Transaction.RefBlockNumber
            });

            if (IsExemptedTransaction(transactionContext.Transaction, tokenContractAddress, tokenStub))
                return new List<Transaction>();

            var txCost = await _txFeeService.CalculateFeeAsync(transactionContext, chainContext);
            var chargeTransactionFeesInput = new ChargeTransactionFeesInput
            {
                MethodName = transactionContext.Transaction.MethodName,
                ContractAddress = transactionContext.Transaction.To,
                TransactionSizeFee = txCost
            };

            var transactionSizeFeeSymbols =
                await _transactionSizeFeeSymbolsProvider.GetTransactionSizeFeeSymbolsAsync(chainContext);
            if (transactionSizeFeeSymbols != null)
                foreach (var transactionSizeFeeSymbol in transactionSizeFeeSymbols.TransactionSizeFeeSymbolList)
                    chargeTransactionFeesInput.SymbolsToPayTxSizeFee.Add(new SymbolToPayTxSizeFee
                    {
                        TokenSymbol = transactionSizeFeeSymbol.TokenSymbol,
                        BaseTokenWeight = transactionSizeFeeSymbol.BaseTokenWeight,
                        AddedTokenWeight = transactionSizeFeeSymbol.AddedTokenWeight
                    });

            var chargeFeeTransaction = GetTransaction(tokenStub, chargeTransactionFeesInput);
            return new List<Transaction>
            {
                chargeFeeTransaction
            };
        }
        catch (Exception e)
        {
            Logger.LogError(
                $"Failed to generate ChargeTransactionFees tx.Transaction to: {transactionContext.Transaction.To},transation method name: {transactionContext.Transaction.MethodName}. Error message: {e.Message}");
            throw;
        }
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L123-129)
```csharp
    public bool IsStopExecuting(ByteString txReturnValue, out string preExecutionInformation)
    {
        var chargeTransactionFeesOutput = new ChargeTransactionFeesOutput();
        chargeTransactionFeesOutput.MergeFrom(txReturnValue);
        preExecutionInformation = chargeTransactionFeesOutput.ChargingInformation;
        return !chargeTransactionFeesOutput.Success;
    }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutionPluginForMethodFeeTest.cs (L306-342)
```csharp
    public async Task ChargeFee_TxFee_FailedTest()
    {
        await DeployTestContractAsync();

        var issueAmount = 99999;
        var tokenContractStub = await GetTokenContractStubAsync();
        await SetPrimaryTokenSymbolAsync(tokenContractStub);

        await tokenContractStub.Transfer.SendAsync(new TransferInput
        {
            Symbol = "ELF",
            Amount = issueAmount,
            To = Accounts[1].Address,
            Memo = "Set for token converter."
        });

        var feeAmount = 100000;
        await SetMethodFee_Successful(feeAmount);

        var userTestContractStub =
            GetTester<ContractContainer.ContractStub>(_testContractAddress,
                Accounts[1].KeyPair);
        var dummy = await userTestContractStub.DummyMethod
            .SendWithExceptionAsync(new Empty()); // This will deduct the fee
        dummy.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        dummy.TransactionResult.Error.ShouldBe("Pre-Error: Transaction fee not enough.");
        var transactionFeeDic = dummy.TransactionResult.GetChargedTransactionFees();
        await CheckTransactionFeesMapAsync(Accounts[1].Address,transactionFeeDic);

        var afterFee = (await tokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = Accounts[1].Address,
            Symbol = "ELF"
        })).Balance;
        afterFee.ShouldBe(0);
        transactionFeeDic[Accounts[1].Address]["ELF"].ShouldBe(issueAmount);
    }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutionPluginForMethodFeeTest.cs (L344-424)
```csharp
    [Theory]
    [InlineData(100000000, 0, 3, 10, 1, 2, "ELF", 20260010, true)]
    [InlineData(9, 0, 1, 10, 1, 2, "ELF", 9, false)]
    [InlineData(100000000, 2, 2, 0, 1, 2, "TSA", 1, true)]
    [InlineData(100000000, 2, 2, 0, 13, 2, "TSB", 2, true)]
    [InlineData(100000000, 2, 2, 0, 20, 20, "TSA", 2, false)]
    [InlineData(1, 0, 1, 0, 1, 2, "TSB", 1, false)]
    [InlineData(10, 0, 0, 0, 1, 2, "ELF", 10, false)] // Charge 10 ELFs tx size fee.
    public async Task ChargeFee_Set_Method_Fees_Tests(long balance1, long balance2, long balance3, long fee1, long fee2,
        long fee3, string chargedSymbol, long chargedAmount, bool isChargingSuccessful)
    {
        await DeployTestContractAsync();

        var tokenContractStub = await GetTokenContractStubAsync();
        await SetPrimaryTokenSymbolAsync(tokenContractStub);
        await tokenContractStub.Transfer.SendAsync(new TransferInput
        {
            Symbol = "ELF",
            Amount = balance1,
            To = Accounts[1].Address,
            Memo = "Set for token converter."
        });
        await CreateAndIssueTokenAsync("TSA", balance2, Accounts[1].Address);
        await CreateAndIssueTokenAsync("TSB", balance3, Accounts[1].Address);

        var methodFee = new MethodFees
        {
            MethodName = nameof(_testContractStub.DummyMethod)
        };
        if (fee1 > 0)
            methodFee.Fees.Add(new MethodFee { Symbol = "ELF", BasicFee = fee1 });
        if (fee2 > 0)
            methodFee.Fees.Add(new MethodFee { Symbol = "TSA", BasicFee = fee2 });
        if (fee3 > 0)
            methodFee.Fees.Add(new MethodFee { Symbol = "TSB", BasicFee = fee3 });
        await _testContractStub.SetMethodFee.SendAsync(methodFee);

        var originBalance = (await tokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = Accounts[1].Address,
            Symbol = chargedSymbol ?? "ELF"
        })).Balance;

        Dictionary<Address,Dictionary<string, long>> transactionFeeDic;
        var userTestContractStub =
            GetTester<ContractContainer.ContractStub>(_testContractAddress, Accounts[1].KeyPair);
        if (isChargingSuccessful)
        {
            var dummyResult = await userTestContractStub.DummyMethod.SendAsync(new Empty());
            dummyResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
            if (chargedSymbol != null)
            {
                dummyResult.TransactionResult.GetChargedTransactionFees().Keys.ShouldContain(Accounts[1].Address);
                dummyResult.TransactionResult.GetChargedTransactionFees()[Accounts[1].Address].Keys.ShouldContain(chargedSymbol);
                dummyResult.TransactionResult.GetChargedTransactionFees()[Accounts[1].Address].Values.ShouldContain(chargedAmount);
            }

            transactionFeeDic = dummyResult.TransactionResult.GetChargedTransactionFees();
        }
        else
        {
            var dummyResult = await userTestContractStub.DummyMethod.SendWithExceptionAsync(new Empty());
            dummyResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
            dummyResult.TransactionResult.Error.ShouldBe("Pre-Error: Transaction fee not enough.");
            if (chargedSymbol != null)
                dummyResult.TransactionResult.GetChargedTransactionFees()[Accounts[1].Address].Keys.ShouldContain(chargedSymbol);
            transactionFeeDic = dummyResult.TransactionResult.GetChargedTransactionFees();
        }

        await CheckTransactionFeesMapAsync(Accounts[1].Address,transactionFeeDic);
        if (chargedSymbol != null)
            transactionFeeDic[Accounts[1].Address][chargedSymbol].ShouldBe(chargedAmount);

        var finalBalance = (await tokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = Accounts[1].Address,
            Symbol = chargedSymbol ?? "ELF"
        })).Balance;

        (originBalance - finalBalance).ShouldBe(chargedAmount);
    }
```
