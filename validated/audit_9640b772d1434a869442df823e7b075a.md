# Audit Report

## Title
Term Transition Bypass via Behavior Selection Manipulation

## Summary
The AEDPoS consensus contract fails to enforce that the correct consensus behavior (NextRound vs NextTerm) is used when terminating rounds. Miners can bypass term transitions by submitting NextRound transactions instead of NextTerm, permanently blocking treasury profit releases, election snapshots, and miner rotations.

## Finding Description

The root cause is that on-chain validation does not enforce behavior appropriateness—only data consistency. The validation system adds `RoundTerminateValidationProvider` for both NextRound and NextTerm behaviors [1](#0-0) , but this provider only validates that round/term numbers increment correctly [2](#0-1) . It does not check whether NextTerm should have been used instead of NextRound based on consensus state.

The decision logic for when to use NextTerm exists in `MainChainConsensusBehaviourProvider`, which calls `NeedToChangeTerm()` to determine if two-thirds of miners have reached the term change threshold [3](#0-2) . However, this is purely client-side logic in the `ConsensusCommandGeneration` folder and has no on-chain enforcement.

Both `NextRound` [4](#0-3)  and `NextTerm` [5](#0-4)  are public methods callable by any miner. The only access control is `PreCheck()`, which merely validates the sender is in the current or previous round's miner list [6](#0-5) .

When a miner submits NextRound instead of NextTerm, `ProcessNextRound` is executed, which only updates the round number [7](#0-6) . This completely bypasses `ProcessNextTerm` logic, which includes treasury profit releases, election snapshots, miner statistics resets, and miner list updates [8](#0-7) .

## Impact Explanation

**Critical Economic Impact:**
- Treasury profit releases are permanently blocked, preventing the protocol's economic distribution mechanism from functioning [9](#0-8) 
- Election snapshots are never taken, breaking delegation and reward distribution [10](#0-9) 
- Miner statistics (missed time slots, produced blocks) are never reset, causing indefinite accumulation [11](#0-10) 

**Consensus Governance Impact:**
- Term number remains frozen while rounds continue incrementing, breaking the consensus governance cycle
- Miner list updates for new terms never occur, preventing validator set rotation [12](#0-11) 

This permanently breaks core protocol functions. The severity is CRITICAL as it affects all token holders, delegators, and the protocol's long-term sustainability.

## Likelihood Explanation

**Attacker Requirements:**
- Must be a miner in the current or previous round's miner list
- This is a privileged but attainable position (1 out of ~17 miners typically)

**Attack Complexity:**
LOW - The attacker simply calls `NextRound()` instead of `NextTerm()` when terminating a round. No complex timing, multi-step setup, or coordination required.

**Feasibility:**
- Both methods are public and callable [13](#0-12) 
- The only validation is that the sender is in the miner list [14](#0-13) 
- No on-chain check exists to enforce using NextTerm when `NeedToChangeTerm()` would return true [15](#0-14) 

**Detection & Recovery:**
Observable but not preventable—term number stops incrementing while rounds continue. No automatic recovery mechanism exists in the codebase.

The probability is HIGH given the straightforward attack path and potential incentives for malicious miners to disrupt governance or maintain the current validator set.

## Recommendation

Add a validation provider that enforces correct behavior selection based on consensus state:

```csharp
public class BehaviorAppropriateness ValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var baseRound = validationContext.BaseRound;
        
        // Check if term should change based on NeedToChangeTerm logic
        var shouldChangeTerm = baseRound.NeedToChangeTerm(
            GetBlockchainStartTimestamp(),
            validationContext.CurrentTermNumber,
            GetPeriodSeconds());
        
        // Enforce NextTerm when term change is required
        if (shouldChangeTerm && extraData.Behaviour == AElfConsensusBehaviour.NextRound)
        {
            return new ValidationResult 
            { 
                Message = "NextTerm behavior required but NextRound provided." 
            };
        }
        
        // Forbid NextTerm when term change is not required
        if (!shouldChangeTerm && extraData.Behaviour == AElfConsensusBehaviour.NextTerm)
        {
            return new ValidationResult 
            { 
                Message = "NextRound behavior required but NextTerm provided." 
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Add this provider to the validation pipeline in `ValidateBeforeExecution` for both NextRound and NextTerm behaviors, before or after `RoundTerminateValidationProvider`.

## Proof of Concept

A test demonstrating the vulnerability would:

1. Initialize an AEDPoS contract with miners and advance to a state where `NeedToChangeTerm()` returns true
2. Have a miner call `NextRound()` instead of `NextTerm()` 
3. Verify the transaction succeeds (passes validation)
4. Assert that term number remains unchanged while round number increments
5. Confirm treasury release and election snapshot operations were never executed

The test would prove that miners can bypass term transitions by choosing the wrong consensus behavior, with no on-chain enforcement preventing this attack.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-46)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L203-211)
```csharp

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L213-218)
```csharp

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-24)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```
