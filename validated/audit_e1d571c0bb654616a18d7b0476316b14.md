# Audit Report

## Title
NextRound Validation Checks Wrong Round Allowing Consensus Manipulation

## Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` validates the provided next round instead of the current round, making the validation check always pass since newly generated rounds have `FinalOrderOfNextRound = 0` and `OutValue = null`. This allows a malicious miner to provide arbitrary next round data with manipulated mining order that gets stored directly to blockchain state without proper validation, breaking consensus integrity.

## Finding Description

The validation logic in `NextRoundMiningOrderValidationProvider` incorrectly checks `providedRound` (the proposed next round from block header) instead of `baseRound` (the current round from state). [1](#0-0) 

The validation context distinguishes between `BaseRound` (fetched from StateDb representing current round) and `ProvidedRound` (included in consensus header extra data representing proposed round): [2](#0-1) 

For NextRound behavior, `RecoverFromUpdateValue` is NOT called, so `baseRound` remains the current round unchanged: [3](#0-2) 

When `GenerateNextRoundInformation` creates a next round, it only sets specific fields (`Pubkey`, `Order`, `ExpectedMiningTime`, `ProducedBlocks`, `MissedTimeSlots`) and does NOT set `FinalOrderOfNextRound` or `OutValue`: [4](#0-3) 

During normal operation, miners set `OutValue` and `FinalOrderOfNextRound` in the CURRENT round via `ProcessUpdateValue`: [5](#0-4) 

The `FinalOrderOfNextRound` is calculated cryptographically from signatures via `ApplyNormalConsensusData`: [6](#0-5) 

However, the malicious round bypasses this cryptographic order determination because the validator checks the NEXT round (where both fields are unset) instead of the CURRENT round (where these fields should be validated). The malicious round is then stored directly to state: [7](#0-6) 

## Impact Explanation

This vulnerability breaks the core consensus integrity of AEDPoS by allowing arbitrary manipulation of the mining order, which is supposed to be determined cryptographically based on miner signatures. An attacker can:

1. **Position themselves advantageously**: Place themselves as the first miner or extra block producer to maximize block production rewards
2. **Disadvantage competitors**: Assign unfavorable mining positions or timeslots to competing miners
3. **Manipulate timing**: Set arbitrary `ExpectedMiningTime` values to create unfair advantages
4. **Break fairness guarantees**: Bypass the cryptographic randomness that ensures fair mining order distribution

The consensus mechanism's security relies on the mining order being unpredictable and fairly determined by cryptographic operations on miner signatures. This vulnerability completely undermines that invariant, allowing direct manipulation of consensus-critical state.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a miner in the current miner set (standard requirement)
- Must be selected as extra block producer (happens regularly in round-robin fashion)

**Attack Execution:**
The attacker simply crafts a malicious `NextRoundInput` with arbitrary `Order` values instead of using the honest `GenerateNextRoundInformation` method: [8](#0-7) 

The malicious input passes validation because the validator checks `providedRound` where both `FinalOrderOfNextRound` (count = 0) and `OutValue` (count = 0) are unset, making the check `0 == 0` evaluate to true (validation passes).

**Feasibility:** Every miner eventually becomes the extra block producer, providing repeated opportunities to execute this attack. No special permissions or compromised keys are required beyond normal miner status.

**Detection:** The malicious round appears valid to all validators since the broken validation passes. Only forensic analysis comparing cryptographically expected mining orders against actual stored orders would reveal the manipulation.

## Recommendation

The validation should check the `baseRound` (current round from state) instead of `providedRound` (proposed next round). The corrected validation logic should verify that all miners who mined blocks in the current round have properly set their `FinalOrderOfNextRound` and `OutValue` fields:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound; // Check current round, not provided round
    var distinctCount = baseRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
        .Distinct().Count();
    if (distinctCount != baseRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound.";
        return validationResult;
    }

    validationResult.Success = true;
    return validationResult;
}
```

## Proof of Concept

A malicious miner selected as extra block producer can execute the following attack:

1. Wait until selected as extra block producer in the current round
2. Instead of calling the honest consensus command generation that uses `GenerateNextRoundInformation`, craft a malicious `NextRoundInput`:
   - Set arbitrary `Order` values for all miners (e.g., position themselves first)
   - Set arbitrary `ExpectedMiningTime` values
   - Maintain valid `RoundNumber` (current + 1) to pass `RoundTerminateValidationProvider`
3. Include this malicious `NextRoundInput` in the block's consensus extra data with `AElfConsensusBehaviour.NextRound`
4. The `NextRoundMiningOrderValidationProvider` checks the `providedRound` where both `FinalOrderOfNextRound` and `OutValue` counts are 0, so validation passes (0 == 0)
5. `ProcessNextRound` converts the input to a `Round` object and stores it via `AddRoundInformation`
6. The manipulated mining order is now the active consensus state for the next round

The attack succeeds because the validation logic checks the wrong round object, allowing the cryptographic order determination to be completely bypassed.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-21)
```csharp
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L19-27)
```csharp
    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L242-247)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L12-44)
```csharp
        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```
