# Audit Report

## Title
Invalid Profit Detail Creation When EndPeriod Equals CurrentPeriod with Delayed Distribution

## Summary
The `AddBeneficiary` function in the Profit contract fails to validate that `EndPeriod` is sufficient when `DelayDistributePeriodCount > 0`. When a manager adds a beneficiary with `EndPeriod = CurrentPeriod`, the calculated `StartPeriod` exceeds `EndPeriod`, creating an invalid profit detail. The beneficiary's shares are permanently added to `TotalShares` but can never be claimed, causing permanent dilution of all future profit distributions for legitimate beneficiaries.

## Finding Description

The vulnerability exists in the `AddBeneficiary` method where insufficient validation allows creation of invalid profit details. The validation only checks that `EndPeriod >= CurrentPeriod` [1](#0-0)  but does not account for the scheme's `DelayDistributePeriodCount`.

The `StartPeriod` calculation adds this delay [2](#0-1) , meaning when `EndPeriod = CurrentPeriod` and `DelayDistributePeriodCount > 0`, this creates `StartPeriod > EndPeriod` (e.g., StartPeriod=101, EndPeriod=100).

The shares are immediately added to the scheme's total [3](#0-2) , inflating `TotalShares` permanently.

During profit claiming, invalid details are filtered out by the condition at [4](#0-3) . For a detail with `LastProfitPeriod = 0`, the check `d.EndPeriod >= d.StartPeriod` fails when `StartPeriod > EndPeriod`, preventing any claims.

The cleanup mechanism fails to remove these details [5](#0-4)  as it only removes details where `LastProfitPeriod >= EndPeriod`, which never occurs for unclaimed invalid details since `LastProfitPeriod` remains 0.

This vulnerability affects production systems. The Treasury Welfare scheme uses `DelayDistributePeriodCount = 1` [6](#0-5) , making it vulnerable to this issue.

## Impact Explanation

**Permanent Profit Dilution:** When invalid beneficiaries with shares S are added to a scheme with existing shares T, all future distributions use the inflated `totalShares` value (T+S) [7](#0-6) . The profit calculation [8](#0-7)  divides by this inflated total, meaning legitimate beneficiaries receive `(their_shares)/(T+S)` instead of `(their_shares)/T`, a permanent reduction.

**Fund Locking:** The portion allocated to invalid beneficiaries (S/(T+S) of each distribution) remains locked in period virtual addresses indefinitely with no recovery mechanism, as these funds are transferred during distribution [9](#0-8)  but never claimed.

**Production Impact:** The Treasury Welfare scheme in production has `DelayDistributePeriodCount = 1`, making it vulnerable. Any manager mistake or malicious action creating invalid beneficiaries permanently damages all future welfare distributions to voters.

**Scale:** If invalid shares equal 20% of total shares, legitimate beneficiaries permanently lose 20% of all future distributions. Over hundreds of periods, this compounds to significant cumulative loss.

## Likelihood Explanation

**Reachable Entry Point:** `AddBeneficiary` is callable by scheme managers [10](#0-9) , which are not trusted roles in the AElf threat model.

**Realistic Preconditions:**
- Schemes with `DelayDistributePeriodCount > 0` exist in production (Treasury Welfare)
- Manager calls `AddBeneficiary` with `EndPeriod = CurrentPeriod`
- This could happen accidentally (user not understanding delay semantics) or maliciously (manager intentionally locking funds)

**Execution Simplicity:** Single transaction with standard parameters - no complex state manipulation required.

**Probability:** Medium - requires privileged manager action, but represents a straightforward mistake during scheme management operations like beneficiary migration or period-limited reward grants.

## Recommendation

Add validation in `AddBeneficiary` to ensure `EndPeriod` accounts for the delay period:

```csharp
Assert(input.EndPeriod >= scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
    $"Invalid end period. End Period: {input.EndPeriod}, must be at least {scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount)} (CurrentPeriod + DelayDistributePeriodCount)");
```

This ensures that `EndPeriod >= StartPeriod` at the time of creation, preventing invalid profit details.

## Proof of Concept

```csharp
[Fact]
public async Task AddBeneficiary_WithDelayedScheme_InvalidEndPeriod_CausesDilution()
{
    // Setup: Create scheme with DelayDistributePeriodCount = 1
    var creator = Creators[0];
    await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true,
        DelayDistributePeriodCount = 1,
        ProfitReceivingDuePeriodCount = 100
    });
    
    var schemeIds = (await creator.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = Address.FromPublicKey(CreatorKeyPair[0].PublicKey) })).SchemeIds;
    var schemeId = schemeIds.First();
    
    var scheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    var currentPeriod = scheme.CurrentPeriod; // Period 1
    
    // Add valid beneficiary with 1000 shares
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = Normal[0].GetCallOwnerAddress(), Shares = 1000 },
        EndPeriod = long.MaxValue
    });
    
    // Add INVALID beneficiary: EndPeriod = CurrentPeriod with DelayDistributePeriodCount > 0
    // This creates StartPeriod = 1 + 1 = 2, EndPeriod = 1 (StartPeriod > EndPeriod - INVALID!)
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = Normal[1].GetCallOwnerAddress(), Shares = 500 },
        EndPeriod = currentPeriod  // BUG: Setting EndPeriod = CurrentPeriod
    });
    
    // Verify TotalShares includes invalid shares (1000 + 500 = 1500)
    scheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    scheme.TotalShares.ShouldBe(1500);
    
    // Distribute profits
    await ProfitContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Symbol = "ELF",
        Amount = 1500
    });
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = currentPeriod,
        AmountsMap = { { "ELF", 0 } }
    });
    
    // Valid beneficiary can claim, but gets diluted amount
    var balanceBefore = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = Normal[0].GetCallOwnerAddress(), Symbol = "ELF" })).Balance;
    await Normal[0].ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });
    var balanceAfter = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = Normal[0].GetCallOwnerAddress(), Symbol = "ELF" })).Balance;
    
    var received = balanceAfter - balanceBefore;
    // Should receive 1500, but receives 1000 due to dilution (1000/1500 * 1500 = 1000)
    received.ShouldBe(1000);  // Lost 500 tokens (33% dilution)
    
    // Invalid beneficiary CANNOT claim (filtered out)
    var exception = await Assert.ThrowsAsync<Exception>(() => 
        Normal[1].ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId }));
    exception.Message.ShouldContain("Profit details not found");
    
    // Shares remain in TotalShares permanently - no cleanup
    scheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    scheme.TotalShares.ShouldBe(1500);  // Invalid 500 shares still counted
}
```

This test demonstrates that when `EndPeriod = CurrentPeriod` with `DelayDistributePeriodCount = 1`, the invalid beneficiary's shares dilute legitimate beneficiaries' rewards while remaining unclaimable and permanent.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L179-180)
```csharp
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-182)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-207)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L462-462)
```csharp
        var totalShares = scheme.TotalShares;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L595-603)
```csharp
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-766)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L64-64)
```csharp
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
```
