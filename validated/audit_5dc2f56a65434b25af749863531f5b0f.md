# Audit Report

## Title
Unvalidated Revealed PreviousInValues Allow Malicious Miners to Cause Consensus DoS

## Summary
A malicious miner can inject incorrect `PreviousInValue` data for other miners through the `RevealedInValues` mechanism without cryptographic validation. These unvalidated values are written to consensus state via `UpdateLatestSecretPieces` and persist due to "only-if-empty" checks, causing targeted miners' blocks to fail validation and resulting in denial-of-service against specific miners.

## Finding Description

The AEDPoS consensus protocol requires miners to commit to their `InValue` in round N by publishing `OutValue = hash(InValue)`, then reveal it as `PreviousInValue` in round N+1. The vulnerability exists in how revealed values for OTHER miners are processed:

**Unvalidated Write Path:**

When a miner produces a block, off-chain trigger information includes `RevealedInValues` for other miners (reconstructed via secret sharing). These values are written to state in `UpdateLatestSecretPieces` without any cryptographic validation: [1](#0-0) 

**Critical Issue:** No validation that `hash(revealedInValue) == previousOutValue` for other miners.

**Insufficient Validation:**

The `UpdateValueValidationProvider` only validates the SENDER's own `PreviousInValue`: [2](#0-1) 

The validation checks `publicKey = validationContext.SenderPubkey`, validating only the block producer's value, not other miners' revealed values.

**Cannot Overwrite Once Set:**

Both protection mechanisms have "only if empty or null" checks: [3](#0-2) 

Once a malicious value is set, the victim cannot correct it.

**State Persistence:**

The unvalidated data is extracted and persisted to state: [4](#0-3) [5](#0-4) 

**Attack Scenario:**

1. Malicious miner B modifies off-chain `AEDPoSTriggerInformationProvider` to return `RevealedInValues["A"] = IncorrectValue`
2. B produces block, `UpdateLatestSecretPieces` writes incorrect value for miner A
3. When victim A produces block, `ApplyNormalConsensusData` fails to update (not empty)
4. A's block includes incorrect PreviousInValue from state
5. Validation fails: `hash(IncorrectValue) != A.OutValue` from previous round
6. A's block is rejected by network

## Impact Explanation

**Consensus Integrity Breach:** This violates the fundamental consensus security guarantee that miners control only their own consensus data. A malicious miner can corrupt other miners' state.

**Targeted DoS:** The attacker can selectively prevent specific miners from producing valid blocks, causing:
- Loss of mining rewards for targeted miners
- Reduced consensus liveness if multiple miners are targeted
- Potential consensus stall if enough miners are affected

**Severity: Medium** because:
- Requires compromised miner (reduces severity from High)
- But affects consensus integrity (critical system)
- DoS only, no fund theft
- Recoverable through round transitions (attacker must repeat each round)
- Detectable through off-chain monitoring

## Likelihood Explanation

**Attacker Requirements:**
- Must be an active miner in the consensus round
- Can modify their node's off-chain trigger information provider

**Attack Complexity:** Low - straightforward modification of `RevealedInValues` dictionary in trigger information before block production.

**Feasibility:** High - once a miner is compromised, the attack is reliable and repeatable.

**Detection:** The attack creates observable discrepancies between expected and actual PreviousInValues, but lacks on-chain validation to prevent it.

**Probability: Medium** - requires miner compromise but execution is simple.

## Recommendation

Add cryptographic validation of revealed PreviousInValues in `UpdateLatestSecretPieces`:

```csharp
foreach (var revealedInValue in triggerInformation.RevealedInValues)
{
    if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
        (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
         updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
    {
        // ADD VALIDATION: Verify hash matches previous OutValue
        if (TryToGetPreviousRoundInformation(out var prevRound) &&
            prevRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
        {
            var expectedOutValue = prevRound.RealTimeMinersInformation[revealedInValue.Key].OutValue;
            if (HashHelper.ComputeFrom(revealedInValue.Value) != expectedOutValue)
            {
                Context.LogDebug(() => $"Invalid revealed InValue for {revealedInValue.Key}");
                continue; // Skip invalid revealed value
            }
        }
        
        updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
    }
}
```

Similarly validate in `PerformSecretSharing` before writing `MinersPreviousInValues` to state.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanCorrupt_OtherMinersPreviousInValue()
{
    // Setup: Initialize consensus with 3 miners (A, B, C)
    var miners = await InitializeConsensusWithMiners(3);
    var minerA = miners[0];
    var minerB = miners[1]; // Malicious
    
    // Round N: Miner A produces block and commits OutValue
    var inValueA = HashHelper.ComputeFrom("correct_value");
    var outValueA = HashHelper.ComputeFrom(inValueA);
    await ProduceBlock(minerA, inValueA, outValueA);
    
    // Round N+1: Malicious miner B produces block FIRST
    // B crafts trigger info with INCORRECT RevealedInValue for A
    var incorrectValue = HashHelper.ComputeFrom("malicious_value");
    var triggerInfo = new AElfConsensusTriggerInformation
    {
        RevealedInValues = { { minerA.PublicKey, incorrectValue } }
    };
    
    await ProduceBlockWithTriggerInfo(minerB, triggerInfo);
    
    // Verify: A's PreviousInValue in state is now incorrect
    var currentRound = await GetCurrentRound();
    var aPreviousInValue = currentRound.RealTimeMinersInformation[minerA.PublicKey].PreviousInValue;
    Assert.Equal(incorrectValue, aPreviousInValue); // Corrupted!
    
    // Round N+1: Miner A tries to produce block
    var result = await ProduceBlock(minerA, inValueA, HashHelper.ComputeFrom("new_value"));
    
    // Assert: A's block FAILS validation
    Assert.False(result.Success);
    Assert.Contains("Incorrect previous in value", result.ValidationMessage);
    
    // Verify: hash(incorrect) != outValueA from round N
    Assert.NotEqual(HashHelper.ComputeFrom(incorrectValue), outValueA);
    
    // Impact: Miner A cannot produce valid blocks, DoS achieved
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```
