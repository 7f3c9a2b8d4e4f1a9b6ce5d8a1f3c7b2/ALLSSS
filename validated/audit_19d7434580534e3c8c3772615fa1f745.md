# Audit Report

## Title
Inconsistent Vote Counting Allows Non-Member Votes to Inflate Participation Threshold

## Summary
The Association contract's release threshold calculation contains a critical inconsistency where votes from removed members are excluded from approval/rejection/abstention counts but included in the total vote participation count, allowing proposals to be released with fewer actual member votes than required by the MinimalVoteThreshold governance parameter.

## Finding Description

The vulnerability exists in the threshold calculation logic within the Association contract's release mechanism. During voting, the `Approve`, `Reject`, and `Abstain` functions validate that the sender is a current member before recording their vote. [1](#0-0) [2](#0-1) [3](#0-2) 

However, when members are removed via `RemoveMember`, only the organization's member list is updated - the proposal's vote lists remain unchanged. [4](#0-3) 

The critical flaw occurs in the `CheckEnoughVoteAndApprovals` function. The approval count filters by current membership. [5](#0-4) 

Similarly, rejection and abstention counts also filter by current membership. [6](#0-5) [7](#0-6) 

But the MinimalVoteThreshold check counts ALL votes without any membership filter. [8](#0-7) 

This inconsistency means votes from removed members contribute to meeting the MinimalVoteThreshold requirement while not affecting approval/rejection/abstention thresholds, breaking the governance invariant that MinimalVoteThreshold represents required participation from actual current members.

## Impact Explanation

This vulnerability enables governance bypass through vote count inflation:

**Concrete Harm:**
- Proposals can be released with fewer actual member votes than intended by the MinimalVoteThreshold parameter
- Organizations can manipulate membership (either maliciously or through natural turnover) to artificially inflate participation counts
- The fundamental governance invariant is violated: MinimalVoteThreshold no longer guarantees minimum current member participation

**Quantified Scenario:**
Consider an organization with 10 permanent members, MinimalVoteThreshold=7, and MinimalApprovalThreshold=5:
1. 5 permanent members approve a proposal (meets MinimalApprovalThreshold)
2. Organization adds 3 temporary members via governance proposal
3. Temporary members vote (approval/rejection/abstention doesn't matter)
4. Organization removes the 3 temporary members
5. Proposal now has 8 total votes (meets MinimalVoteThreshold â‰¥ 7) but only 5 from actual members
6. Proposal can be released despite only 50% actual member participation instead of the required 70%

**Severity: HIGH** - This directly violates governance security by allowing proposals to pass with insufficient actual member participation, potentially enabling unauthorized contract calls through the organization's authority.

## Likelihood Explanation

**Attack Complexity: LOW** - Requires only standard organization operations that the organization is authorized to perform:
1. Create proposals to add/remove members (standard governance)
2. Have temporary members vote during their membership period  
3. Remove those members through another proposal

**Feasibility:** Organizations naturally add and remove members for legitimate reasons, meaning this can occur both intentionally (malicious manipulation by controlling members) and unintentionally (natural member turnover where members vote and later leave).

**Detection Constraints:** Vote histories are visible on-chain, but the inconsistent counting logic is not immediately obvious. Organizations may not realize their participation thresholds are being bypassed.

**Probability: HIGH** - This can occur in two scenarios:
1. Intentional: Malicious organization controllers can deliberately manipulate membership
2. Accidental: Natural member turnover causes historical votes to inflate participation counts

## Recommendation

Modify the `CheckEnoughVoteAndApprovals` function to filter the MinimalVoteThreshold check by current membership, ensuring consistency with approval/rejection/abstention counting:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter all vote types by current membership
    var currentMemberVotes = proposal.Abstentions
        .Concat(proposal.Approvals)
        .Concat(proposal.Rejections)
        .Where(organization.OrganizationMemberList.Contains)
        .Count();
    
    var isVoteThresholdReached = currentMemberVotes >= 
        organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

This ensures that only votes from current members count toward all thresholds, maintaining the governance invariant that MinimalVoteThreshold represents actual current member participation.

## Proof of Concept

```csharp
[Fact]
public async Task InconsistentVoteCountingVulnerability_Test()
{
    // Create organization with 10 members, MinimalVoteThreshold=7, MinimalApprovalThreshold=5
    var organizationAddress = await CreateOrganizationAsync(
        members: new[] { Reviewer1, Reviewer2, Reviewer3, Member4, Member5, Member6, Member7, Member8, Member9, Member10 },
        minimalApprovalThreshold: 5,
        minimalVoteThreshold: 7);

    // Create a proposal
    var proposalId = await CreateProposalAsync(organizationAddress, Reviewer1);

    // 5 permanent members approve (meets MinimalApprovalThreshold)
    await ApproveAsync(proposalId, Reviewer1);
    await ApproveAsync(proposalId, Reviewer2);
    await ApproveAsync(proposalId, Reviewer3);
    await ApproveAsync(proposalId, Member4);
    await ApproveAsync(proposalId, Member5);

    // Add 3 temporary members
    await AddMemberAsync(organizationAddress, TempMember1);
    await AddMemberAsync(organizationAddress, TempMember2);
    await AddMemberAsync(organizationAddress, TempMember3);

    // Temporary members vote
    await ApproveAsync(proposalId, TempMember1);
    await AbstainAsync(proposalId, TempMember2);
    await RejectAsync(proposalId, TempMember3);

    // Remove temporary members
    await RemoveMemberAsync(organizationAddress, TempMember1);
    await RemoveMemberAsync(organizationAddress, TempMember2);
    await RemoveMemberAsync(organizationAddress, TempMember3);

    // Proposal should NOT be releasable (only 5/10 current members voted)
    // But it IS releasable due to vulnerability (8 total votes >= 7 threshold)
    var result = await ReleaseAsync(proposalId, Reviewer1);
    
    result.Status.ShouldBe(TransactionResultStatus.Mined); // Incorrectly passes
    // Expected: Should fail with "Not approved" because only 5/10 current members voted (< 70% required)
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L128-128)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L148-148)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L168-168)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L270-270)
```csharp
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```
