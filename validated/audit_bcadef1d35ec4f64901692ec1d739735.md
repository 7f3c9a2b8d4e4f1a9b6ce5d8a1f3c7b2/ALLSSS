# Audit Report

## Title
Token Alias Resolution Mismatch in ACS2 Resource Path Declaration Enables Parallel Execution Race Conditions

## Summary
The `TransferFrom` method's ACS2 resource path provider declares state paths using unresolved input symbols (including aliases), while actual execution resolves aliases and modifies different state paths. This mismatch allows the parallel execution scheduler to incorrectly classify conflicting transactions as non-conflicting, enabling allowance double-spending and balance corruption for NFT tokens with aliases.

## Finding Description

The vulnerability arises from a fundamental disconnect between resource path declaration and actual state modification when token aliases are used.

**Path Declaration Phase:**

When `GetResourceInfo` is invoked for `TransferFrom`, it parses the transaction parameters and uses `args.Symbol` directly without alias resolution [1](#0-0) . The balance paths at lines 47-48 and allowance paths via `AddPathForAllowance` at line 58 all use this unresolved symbol.

The `AddPathForAllowance` method declares write paths using the raw symbol parameter [2](#0-1) . Critically, at line 76, it calls `GetSymbolType(symbol)` on the unresolved alias. The `GetSymbolType` implementation splits symbols by the NFT separator '-' [3](#0-2) . For an alias like "TP" (representing NFT "TP-31175"), it returns `SymbolType.Token` instead of `SymbolType.Nft`, causing the code to skip adding NFT collection allowance paths ("TP-*") at lines 77-81.

**Actual Execution Phase:**

During execution, `TransferFrom` calls `AssertValidToken` which resolves aliases [4](#0-3) . The `GetTokenInfo` method performs this resolution by checking `State.SymbolAliasMap` [5](#0-4) , returning the actual symbol (e.g., "TP-31175" for alias "TP").

The resolved symbol is then passed to `DoTransferFrom` [6](#0-5) . This method calls `GetAllowance` at line 75, which determines the symbol type using the resolved actual symbol. For "TP-31175", `GetSymbolType` correctly returns `SymbolType.Nft` [7](#0-6) , causing it to check NFT collection allowances ("TP-*") at line 110. Balance modifications via `DoTransfer` at line 91 and allowance updates at line 94 all use the resolved symbol.

**Root Cause:**

ACS2 path declaration occurs at transaction scheduling time using raw input, while execution occurs later using resolved symbols. Token aliases are a supported feature for NFT items, as evidenced by test coverage [8](#0-7)  showing `TransferFrom` working with aliases.

## Impact Explanation

**Allowance Double-Spending:**
An attacker with an approved allowance can submit two `TransferFrom` transactions: one using the alias ("TP") and one using the actual symbol ("TP-31175"). The ACS2 path provider declares different resource paths for each transaction, allowing parallel execution. Both transactions can read the same allowance value before either deducts it, enabling transfer of double the approved amount. This directly violates the allowance enforcement invariant.

**Balance Corruption:**
Similarly, balance state paths are declared differently but modified identically, allowing concurrent modifications that can lead to incorrect final balances through lost updates.

**Affected Assets:**
All NFT tokens with aliases are vulnerable. The `SetSymbolAlias` functionality is specifically designed for NFT items [9](#0-8)  and actively tested. NFT assets often have high individual value, making this economically significant.

## Likelihood Explanation

**Entry Point:**
`TransferFrom` is a public method accessible to any user with approved allowances.

**Preconditions:**
1. NFT token has an alias set (supported feature per implementation at lines 738-779)
2. Token owner has approved an allowance 
3. Spender submits two transactions in the same block using different symbol representations

**Execution Feasibility:**
The test suite demonstrates aliases working with transfers and approvals [10](#0-9) . No special privileges are requiredâ€”any approved spender can exploit this. The parallel execution system will classify these as non-conflicting due to the path mismatch.

**Economic Viability:**
Attack cost is minimal (two transaction fees), while benefit is stealing tokens beyond approved amounts. For valuable NFTs, this is highly attractive.

## Recommendation

Resolve aliases in the ACS2 resource path provider before declaring paths. Modify `GetResourceInfo` to call `GetTokenInfo` for symbol resolution:

```csharp
case nameof(TransferFrom):
{
    var args = TransferFromInput.Parser.ParseFrom(txn.Params);
    // Resolve alias to actual symbol
    var actualSymbol = GetActualTokenSymbol(args.Symbol);
    var resourceInfo = new ResourceInfo
    {
        WritePaths =
        {
            GetPath(nameof(TokenContractState.Balances), args.From.ToString(), actualSymbol),
            GetPath(nameof(TokenContractState.Balances), args.To.ToString(), actualSymbol),
            GetPath(nameof(TokenContractState.LockWhiteLists), actualSymbol, txn.From.ToString())
        },
        // ... rest of paths using actualSymbol
    };
    AddPathForAllowance(resourceInfo, args.From.ToString(), txn.From.ToString(), actualSymbol);
    // ... rest of method
}
```

Apply the same fix to `Transfer` and any other methods that accept symbol parameters.

## Proof of Concept

```csharp
[Fact]
public async Task AliasParallelExecutionRaceCondition_Test()
{
    // Setup: Create NFT with alias
    await CreateTokenWithAlias_Test(); // Creates "TP-31175" with alias "TP"
    
    // Issue 100 NFT tokens to owner
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "TP-31175",
        Amount = 100,
        To = DefaultAddress
    });
    
    // Owner approves spender for 100 tokens
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Symbol = "TP-31175",
        Amount = 100,
        Spender = User1Address
    });
    
    // Attacker submits two TransferFrom transactions:
    // TX-A: Using alias "TP"
    var tx1 = TokenContractStubUser.TransferFrom.SendAsync(new TransferFromInput
    {
        Symbol = "TP", // alias
        Amount = 100,
        From = DefaultAddress,
        To = User2Address,
    });
    
    // TX-B: Using actual symbol "TP-31175"
    var tx2 = TokenContractStubUser.TransferFrom.SendAsync(new TransferFromInput
    {
        Symbol = "TP-31175", // actual
        Amount = 100,
        From = DefaultAddress,
        To = User3Address,
    });
    
    await Task.WhenAll(tx1, tx2);
    
    // Result: Both transfers succeed if scheduled in parallel
    // Total transferred: 200 tokens with only 100 approved
    var balance2 = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = User2Address,
        Symbol = "TP-31175"
    });
    
    var balance3 = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = User3Address,
        Symbol = "TP-31175"
    });
    
    // Vulnerability: balance2.Balance + balance3.Balance can equal 200
    // when only 100 was approved (allowance double-spend)
}
```

## Notes

This vulnerability demonstrates a critical flaw in the interaction between AElf's alias system and parallel execution scheduler. The ACS2 resource path provider must resolve all symbolic references (including aliases) to their canonical forms before declaring paths to ensure accurate conflict detection. The fix requires modification at the ACS2 layer, not just execution logic, as the parallel scheduler depends on accurate path declarations for correctness.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L40-64)
```csharp
            case nameof(TransferFrom):
            {
                var args = TransferFromInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), args.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.LockWhiteLists), args.Symbol, txn.From.ToString())
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };
                AddPathForAllowance(resourceInfo, args.From.ToString(), txn.From.ToString(), args.Symbol);
                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L71-82)
```csharp
    private void AddPathForAllowance(ResourceInfo resourceInfo, string from, string spender, string symbol)
    {
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender, symbol));
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
            GetAllSymbolIdentifier()));
        var symbolType = GetSymbolType(symbol);
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
        {
            resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
                GetNftCollectionAllSymbolIdentifier(symbol)));
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L254-259)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransferFrom(input.From, input.To, Context.Sender, tokenInfo.Symbol, input.Amount, input.Memo);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L738-779)
```csharp
    public override Empty SetSymbolAlias(SetSymbolAliasInput input)
    {
        // Alias setting can only work for NFT Item for now.
        // And the setting exists on the TokenInfo of the NFT Collection.

        // Can only happen on Main Chain.
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "Symbol alias setting only works on MainChain.");

        var collectionSymbol = GetNftCollectionSymbol(input.Symbol, true);

        // For now, token alias can only be set once.
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");

        CheckTokenAlias(input.Alias, collectionSymbol);

        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");

        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);

        State.SymbolAliasMap[input.Alias] = input.Symbol;

        Context.LogDebug(() => $"Token alias added: {input.Symbol} -> {input.Alias}");

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = input.Symbol,
            Alias = input.Alias
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L97-116)
```csharp
    private long GetAllowance(Address from, Address spender, string sourceSymbol, long amount,
        out string allowanceSymbol)
    {
        allowanceSymbol = sourceSymbol;
        var allowance = State.Allowances[from][spender][sourceSymbol];
        if (allowance >= amount) return allowance;
        var tokenType = GetSymbolType(sourceSymbol);
        if (tokenType == SymbolType.Token)
        {
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }
        else
        {
            allowance = GetNftCollectionAllSymbolAllowance(from, spender, sourceSymbol, out allowanceSymbol);
            if (allowance >= amount) return allowance;
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }

        return allowance;
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenAliasTests.cs (L165-201)
```csharp
    public async Task TransferViaAlias_Test()
    {
        await CreateTokenWithAlias_Test();

        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = "TP-31175",
            Amount = 1,
            To = DefaultAddress
        });

        {
            var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = DefaultAddress,
                Symbol = "TP"
            });
            balance.Balance.ShouldBe(1);
        }

        await TokenContractStub.Transfer.SendAsync(new TransferInput
        {
            // Transfer via alias.
            Symbol = "TP",
            Amount = 1,
            To = User1Address
        });

        {
            var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = User1Address,
                Symbol = "TP"
            });
            balance.Balance.ShouldBe(1);
        }
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenAliasTests.cs (L204-238)
```csharp
    public async Task ApproveAndTransferFromViaAlias_Test()
    {
        await CreateTokenWithAlias_Test();

        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = "TP-31175",
            Amount = 1,
            To = DefaultAddress
        });

        await TokenContractStub.Approve.SendAsync(new ApproveInput
        {
            Symbol = "TP",
            Amount = 1,
            Spender = User1Address
        });

        await TokenContractStubUser.TransferFrom.SendAsync(new TransferFromInput
        {
            Symbol = "TP",
            Amount = 1,
            From = DefaultAddress,
            To = User2Address,
        });

        {
            var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = User2Address,
                Symbol = "TP"
            });
            balance.Balance.ShouldBe(1);
        }
    }
```
