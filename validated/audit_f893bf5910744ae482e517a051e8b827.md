# Audit Report

## Title
Unauthorized Admin Takeover via AnnounceElectionFor Allows Arbitrary Public Key Hijacking

## Summary
The `AnnounceElectionFor` function in the Election contract lacks authorization checks, allowing any caller to announce election for arbitrary public keys and assign themselves as admin. This enables attackers to gain permanent administrative control over candidates they don't own, manipulate elections, and prevent legitimate owners from registering their public keys.

## Finding Description

The vulnerability exists in the `AnnounceElectionFor` method which accepts an arbitrary `pubkey` string and `admin` address without verifying that the caller has permission to announce election for that public key. [1](#0-0) 

The function directly assigns the provided admin parameter (defaulting to `Context.Sender`) as the candidate admin without any consent mechanism. The admin assignment occurs unconditionally without verifying the caller owns the specified public key. [2](#0-1) 

The internal validation in the private `AnnounceElection` method only checks pubkey eligibility status (not initial miner, not already announced, not banned) but never validates caller authorization: [3](#0-2) 

**Contrast with Secure Implementation:**

The alternative `AnnounceElection(Address input)` method uses cryptographic signature verification to ensure only the private key owner can announce: [4](#0-3) 

Specifically, line 95 uses `Context.RecoverPublicKey()` to cryptographically recover the caller's public key from the transaction signature, ensuring only the private key owner can register their own candidacy. This secure pattern is completely missing from `AnnounceElectionFor`, creating the authorization bypass.

**Why Existing Protections Fail:**

The `SetCandidateAdmin` method has authorization checks, but they cannot prevent this attack: [5](#0-4) 

Once an attacker sets themselves as admin via `AnnounceElectionFor`, the legitimate owner cannot reclaim control because the checks require either Parliament authority or being the current admin. The victim is neither.

## Impact Explanation

**1. Unauthorized Administrative Control**

An attacker gains full admin privileges over candidates they don't own. Admin control includes:

- **Ability to quit election**: Only the admin can quit, as enforced by: [6](#0-5) 

- **Ability to replace the candidate's public key**: The `ReplaceCandidatePubkey` method requires admin permission: [7](#0-6) 

- **Control over profit receivers**: Admin controls profit distribution settings through the Treasury contract integration.

**2. Permanent Registration DoS**

Once a pubkey is announced as a candidate, the legitimate owner cannot register it because the re-announcement check prevents it. The check prevents re-announcing while `IsCurrentCandidate` is true. While the attacker can quit and the victim could theoretically re-register, the attacker can immediately re-announce creating a persistent race condition and griefing attack.

**3. Election Manipulation**

- Attacker can strategically quit elections to manipulate the miner selection process during term changes
- Voters may vote for hijacked candidates believing they're legitimate, locking tokens for candidates controlled by attackers  
- The data center ranking system can be manipulated by controlling when candidates participate

**4. Economic Cost is Minimal**

The attacker locks 100,000 ELF but retrieves it when quitting. The sponsor receives the refund: [8](#0-7) 

The attacker's net cost is zero plus transaction fees.

## Likelihood Explanation

**Attacker Capabilities Required:**
- 100,000 ELF for the candidate lock (returned when they quit)
- Ability to call a public contract method  
- Knowledge of target public key hex strings

**Attack Complexity:** TRIVIAL
- Single transaction call with two parameters: arbitrary pubkey and attacker's address as admin
- No special timing, race conditions, or complex state setup required
- The method is publicly accessible as defined in the contract interface: [9](#0-8) 

**Detection Difficulty:** HIGH  
The hijacked registration appears legitimate on-chain. Users cannot easily distinguish between legitimate candidate registrations and malicious hijackings without off-chain verification of ownership.

**Probability:** HIGH - The vulnerability is easily discoverable, trivial to exploit, and economically rational for attackers seeking to manipulate elections or grief legitimate candidates.

## Recommendation

Add authorization verification to `AnnounceElectionFor` to ensure the caller has permission from the public key owner. The recommended fix is to require a signature proof or alternatively restrict this method to only allow the legitimate owner (derived from the pubkey) to set themselves as admin:

```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkey = input.Pubkey;
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    var address = Address.FromPublicKey(pubkeyBytes);
    
    // FIX: Ensure admin can only be set to the pubkey owner by default
    var admin = input.Admin ?? Context.Sender;
    Assert(admin == address || Context.Sender == address, 
        "Only the public key owner can announce election or set admin.");
    
    AnnounceElection(pubkeyBytes);
    State.CandidateAdmins[pubkey] = admin;
    // ... rest of implementation
}
```

Alternatively, require the pubkey owner's signature to authorize the admin assignment, similar to how `AnnounceElection(Address input)` uses `Context.RecoverPublicKey()`.

## Proof of Concept

```csharp
[Fact]
public async Task AnnounceElectionFor_UnauthorizedAdminTakeover_Test()
{
    // Victim's keypair
    var victimKeyPair = ValidationDataCenterKeyPairs.First();
    var victimPubkey = victimKeyPair.PublicKey.ToHex();
    
    // Attacker's keypair  
    var attackerKeyPair = ValidationDataCenterKeyPairs.Last();
    var attackerAddress = Address.FromPublicKey(attackerKeyPair.PublicKey);
    
    // Attacker calls AnnounceElectionFor with victim's pubkey and attacker as admin
    var attackerElectionStub = GetElectionContractTester(attackerKeyPair);
    await attackerElectionStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = victimPubkey,
        Admin = attackerAddress  // Attacker sets themselves as admin
    });
    
    // Verify attacker is now the admin of victim's candidacy
    var admin = await ElectionContractStub.GetCandidateAdmin.CallAsync(new StringValue { Value = victimPubkey });
    admin.ShouldBe(attackerAddress);
    
    // Verify victim cannot reclaim control via SetCandidateAdmin
    var victimAddress = Address.FromPublicKey(victimKeyPair.PublicKey);
    var victimElectionStub = GetElectionContractTester(victimKeyPair);
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await victimElectionStub.SetCandidateAdmin.SendAsync(new SetCandidateAdminInput
        {
            Pubkey = victimPubkey,
            Admin = victimAddress  // Victim tries to set themselves as admin
        });
    });
    exception.Message.ShouldContain("No permission");
    
    // Verify victim cannot re-announce because pubkey already announced
    var announceException = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await victimElectionStub.AnnounceElection.SendAsync(victimAddress);
    });
    announceException.Message.ShouldContain("already announced election");
}
```

This proof of concept demonstrates:
1. Attacker successfully announces election for victim's pubkey with themselves as admin
2. Admin is set to attacker's address
3. Victim cannot reclaim control via `SetCandidateAdmin` (fails with "No permission")
4. Victim cannot re-announce their own candidacy (fails with "already announced")

The vulnerability allows permanent unauthorized control over arbitrary public keys' candidacy rights.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-57)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;

        var pubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey));

        var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
        if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            newAdminManagedPubkeys.Value.Add(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;

        var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender] ?? new PubkeyList();
        if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[Context.Sender] = oldAdminManagedPubkeys;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-280)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });

        // Update candidate information.
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;

        // Remove candidate public key from the Voting Item options.
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(pubkey))
        {
            dataCenterList.DataCenters[pubkey] = 0;
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
            State.DataCentersRankingList.Value = dataCenterList;
        }

        var managedCandidatePubkey = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedCandidatePubkey.Value.Remove(ByteString.CopyFrom(pubkeyBytes));
        if (managedCandidatePubkey.Value.Any())
            State.ManagedCandidatePubkeysMap[Context.Sender] = managedCandidatePubkey;
        else
            State.ManagedCandidatePubkeysMap.Remove(Context.Sender);

        State.CandidateSponsorMap.Remove(pubkey);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-257)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }

        var rankingList = State.DataCentersRankingList.Value;
        //the profit receiver is not exist but candidate in the data center ranking list
        if (rankingList.DataCenters.ContainsKey(input.OldPubkey))
        {
            rankingList.DataCenters.Add(input.NewPubkey, rankingList.DataCenters[input.OldPubkey]);
            rankingList.DataCenters.Remove(input.OldPubkey);
            State.DataCentersRankingList.Value = rankingList;

            // Notify Profit Contract to update backup subsidy profiting item.
            if (State.ProfitContract.Value == null)
                State.ProfitContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            
            var oldProfitReceiver = GetProfitsReceiverOrDefault(input.OldPubkey);
            var profitReceiver = oldProfitReceiver.Value.Any()
                ? oldProfitReceiver
                : null;
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
        }

        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }

        //     For CandidateVotes and CandidateInformation, just replace value of origin pubkey.
        var candidateVotes = State.CandidateVotes[input.OldPubkey];
        if (candidateVotes != null)
        {
            candidateVotes.Pubkey = newPubkeyBytes;
            State.CandidateVotes[input.NewPubkey] = candidateVotes;
            State.CandidateVotes.Remove(input.OldPubkey);
        }

        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }

        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;

        ReplaceCandidateProfitsReceiver(input.OldPubkey, input.NewPubkey);
        
        Context.Fire(new CandidatePubkeyReplaced
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey
        });

        return new Empty();
    }
```

**File:** protobuf/election_contract.proto (L38-39)
```text
    rpc AnnounceElectionFor (AnnounceElectionForInput) returns (google.protobuf.Empty) {
    }
```
