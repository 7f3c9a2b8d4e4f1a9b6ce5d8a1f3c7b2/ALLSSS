# Audit Report

## Title
Insufficient Alternative Candidates Allows Banned Miners to Remain in Consensus

## Summary
The miner replacement mechanism fails to ensure complete removal of banned miners when the alternative candidate pool is exhausted. The replacement loop iterates only based on the count of available alternatives, leaving unreplaced banned miners in the consensus round who can continue producing blocks and earning rewards.

## Finding Description

The vulnerability exists in the consensus contract's miner replacement logic during round generation. When the system detects evil miners that need replacement through `TryToDetectEvilMiners`, it calls `GetMinerReplacementInformation` to obtain both the list of banned miners and available alternatives. [1](#0-0) 

The critical flaw occurs in the replacement loop, which iterates based solely on `AlternativeCandidatePubkeys.Count` and accesses both lists by index without verifying equal lengths. [2](#0-1) 

In `GetMinerReplacementInformation`, the Election contract can legitimately return fewer alternatives than evil miners. It first attempts to select candidates from the election snapshot, taking only the minimum between evil miner count and available candidates. [3](#0-2) 

It then tries to fill the gap with initial miners, but these are filtered to exclude banned and currently active miners. [4](#0-3) 

The returned `MinerReplacementInformation` structure contains `EvilMinerPubkeys` with all banned miners but `AlternativeCandidatePubkeys` with potentially fewer alternatives. [5](#0-4) 

**Root Cause:** When the alternative count is less than the evil miner count, only the first N evil miners are removed and replaced. [6](#0-5)  The remaining evil miners at indices N through end are never accessed and remain in `currentRound.RealTimeMinersInformation`.

Subsequently, `Round.GenerateNextRoundInformation` generates the next round using all miners present in `RealTimeMinersInformation` without any filtering for banned status. [7](#0-6) 

The mining permission validation only checks whether a pubkey exists in `RealTimeMinersInformation`, not whether it's banned. [8](#0-7) 

## Impact Explanation

**Consensus Integrity Compromise:** This vulnerability breaks the fundamental security invariant that miners marked as evil must be excluded from consensus participation. When evil miners are detected, they are marked in `State.BannedPubkeyMap`, [9](#0-8)  but the incomplete replacement allows them to continue producing blocks, participating in consensus rounds, and validating transactions despite being penalized for violating consensus rules.

**Reward Misallocation:** Unreplaced evil miners continue earning block production rewards and mining dividends, directly undermining the economic security model designed to discourage malicious behavior through punishment.

**Attack Amplification:** Multiple malicious miners can coordinate simultaneous misbehavior. When the alternative candidate pool is shallow (common during low election participation or when most initial miners are already active), several evil miners remain operational, enabling sustained malicious activity against chain security.

**Severity: Critical** - This vulnerability compromises the core consensus mechanism's ability to maintain network integrity by removing misbehaving nodes.

## Likelihood Explanation

**Automatic Trigger:** The vulnerability is triggered automatically during normal consensus round generation when evil miners are detected. [10](#0-9)  No special permissions or external intervention is required.

**Realistic Preconditions:**
1. Multiple miners marked as evil in the same term through detection of excessive missed time slots as defined by `TolerableMissedTimeSlotsCount`. [11](#0-10) [12](#0-11) 
2. Limited alternative candidates in the election snapshot due to low voter participation or few announced candidates
3. Most initial miners already active or also banned

**Execution Practicality:** These conditions naturally occur during periods of low election participation, network-wide issues causing multiple simultaneous failures, or coordinated attacks where multiple malicious nodes deliberately trigger evil node detection.

**Likelihood: High** - The preconditions are realistic in production environments, especially during early network stages or low-participation periods.

## Recommendation

The replacement loop should verify that all evil miners are either replaced or explicitly handled when alternatives are exhausted. The fix should:

1. **Add length validation**: Before the replacement loop, check if there are sufficient alternatives. If not, log a warning and either:
   - Remove unreplaced evil miners from `RealTimeMinersInformation` entirely
   - Trigger emergency governance procedures
   - Reduce the miner set size temporarily

2. **Add banned status check**: In `GenerateNextRoundInformation`, filter out any miners present in `BannedPubkeyMap` before generating the next round.

3. **Enhance mining permission validation**: Add a check in `MiningPermissionValidationProvider` to verify the miner is not banned.

## Proof of Concept

```csharp
// Test scenario demonstrating the vulnerability
[Fact]
public async Task EvilMiners_RemainsActive_WhenInsufficientAlternatives()
{
    // Setup: 7 miners, 3 become evil, only 2 alternatives available
    var currentMiners = new[] {"A", "B", "C", "D", "E", "F", "G"};
    var evilMiners = new[] {"D", "E", "F"}; // 3 evil miners
    var alternatives = new[] {"H", "I"}; // Only 2 alternatives
    
    // Mark D, E, F as evil (set BannedPubkeyMap[pubkey] = true)
    foreach (var evil in evilMiners)
    {
        await ElectionContract.UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = evil,
            IsEvilNode = true
        });
    }
    
    // Call GenerateNextRoundInformation which triggers replacement
    var currentRound = await ConsensusContract.GetCurrentRoundInformation();
    
    // Expected: All evil miners removed
    // Actual: Only D and E replaced, F remains
    var nextRound = await ConsensusContract.GetNextRoundInformation();
    
    // Vulnerability: F is still in RealTimeMinersInformation
    Assert.False(nextRound.RealTimeMinersInformation.ContainsKey("F")); // FAILS - F still present
    
    // F can still mine and pass validation
    var canMine = await ConsensusContract.IsCurrentMiner(Address.FromPublicKey("F"));
    Assert.False(canMine.Value); // FAILS - F can still mine
}
```

## Notes

This vulnerability represents a critical failure in the consensus security model. The incomplete replacement mechanism allows banned miners to persist in the active miner set, compromising the network's ability to self-heal from malicious behavior. The issue is particularly severe because it occurs automatically without any external trigger, and becomes more likely during periods when the network needs security enforcement most (during low participation or coordinated attacks).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-305)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-314)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L337-338)
```csharp
                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L368-377)
```csharp
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L383-392)
```csharp
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L394-398)
```csharp
        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-56)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```
