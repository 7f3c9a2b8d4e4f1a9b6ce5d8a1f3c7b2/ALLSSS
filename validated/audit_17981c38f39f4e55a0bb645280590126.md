# Audit Report

## Title
BurnProfits Unconditionally Overwrites DistributedProfitsMap Causing Loss of Pre-Contributed Profits

## Summary
The `BurnProfits` function creates a new `DistributedProfitsInfo` object and unconditionally overwrites any existing `DistributedProfitsMap` entry without preserving pre-contributed profits. When users contribute tokens to future periods and the scheme later has zero beneficiaries (totalShares = 0), calling `DistributeProfits` triggers `BurnProfits` which destroys the accounting record while contributed tokens remain permanently locked in the period-specific virtual address.

## Finding Description

The vulnerability arises from the interaction between three functions in the Profit contract:

**1. ContributeProfits allows future period contributions**

Users can contribute tokens to future periods (period > currentPeriod), which are deposited into period-specific virtual addresses. [1](#0-0) 

The contribution creates or updates a `DistributedProfitsInfo` entry that tracks the deposited amounts.

**2. DistributeProfits invokes BurnProfits when totalShares â‰¤ 0**

When `DistributeProfits` is called for a period where the scheme has zero beneficiaries, it invokes `BurnProfits` instead of normal distribution. [2](#0-1) 

**3. BurnProfits destroys pre-contribution accounting**

The critical flaw is in `BurnProfits` implementation: it creates a **new** `DistributedProfitsInfo` object without reading existing state, burns tokens from the scheme's general ledger (not the period-specific address where pre-contributions were deposited), and then unconditionally overwrites the `DistributedProfitsMap` entry, destroying all records of previously contributed profits. [3](#0-2) 

The period-specific virtual address is consistently generated using `GetDistributedPeriodProfitsVirtualAddress`. [4](#0-3) 

After `BurnProfits` executes with `IsReleased=true`, future contributions to that period are blocked by an assertion check. [5](#0-4) 

The `DistributedProfitsMap` state stores the accounting for each period's distributions. [6](#0-5) 

## Impact Explanation

**Direct Fund Loss - Permanent and Unrecoverable:**

This vulnerability causes complete and permanent loss of user funds:

1. **Permanent Lock:** Tokens contributed to future periods become permanently locked in the period-specific virtual address with no recovery mechanism. The tokens exist on-chain but are inaccessible because the accounting in `DistributedProfitsMap` that tracks them has been overwritten.

2. **Quantified Damage:** The impact scales linearly with contribution amounts. If a user contributes 10,000 ELF tokens to period 5, and the scheme has zero beneficiaries when period 5 arrives, all 10,000 ELF become permanently unrecoverable.

3. **Affected Parties:**
   - Users who contribute profits to future periods expecting eventual distribution
   - Scheme managers who may inadvertently trigger this when legitimately winding down schemes
   - The protocol itself, as tokens become permanently stuck, reducing circulating supply

4. **No Mitigation Available:** Once `BurnProfits` executes, the `IsReleased` flag prevents any future contributions to recover the state, and `ClaimProfits` relies on the now-corrupted `DistributedProfitsMap` to calculate claimable amounts, making recovery impossible through normal contract operations.

## Likelihood Explanation

**Likelihood: MEDIUM - Feasible Through Normal Operations**

This vulnerability can be triggered through legitimate contract operations without requiring special privileges:

1. **Publicly Accessible Entry Point:** `ContributeProfits` is a public method callable by any user who has token allowance. No special permissions are required to contribute to future periods.

2. **Realistic Preconditions:**
   - A profit scheme exists and accepts contributions
   - A user contributes to a future period (e.g., period 5 when current period is 1) - a common pattern for scheduled distributions
   - Between contribution time and the target period, all beneficiaries are removed via `RemoveBeneficiary`, resulting in `totalShares = 0` - a legitimate operation when winding down schemes
   - The scheme manager calls `DistributeProfits` for the target period

3. **Natural Occurrence Scenarios:**
   - Schemes being discontinued or restructured after users have made forward-looking contributions
   - Gradual removal of beneficiaries during scheme wind-down overlapping with existing future-period commitments
   - Users optimistically contributing to future periods of schemes that later become inactive

4. **Low Detection Difficulty:** Both `ContributeProfits` and `RemoveBeneficiary` are legitimate operations that emit no warnings. The fund loss only becomes apparent when users attempt to claim profits and discover the accounting has been destroyed.

5. **No Economic Barriers:** Beyond the contribution amount itself (which the attacker may be willing to sacrifice for griefing), there are no additional costs or constraints preventing this scenario.

## Recommendation

**Fix: Preserve Existing DistributedProfitsInfo Before Overwriting**

Modify `BurnProfits` to read and preserve any existing `DistributedProfitsInfo` before overwriting, and burn tokens from both the general ledger AND period-specific addresses where pre-contributions exist:

```csharp
private Empty BurnProfits(long period, Dictionary<string, long> profitsMap, Scheme scheme,
    Address profitsReceivingVirtualAddress)
{
    scheme.CurrentPeriod = period.Add(1);

    // READ existing state instead of creating new
    var distributedProfitsInfo = State.DistributedProfitsMap[profitsReceivingVirtualAddress] 
        ?? new DistributedProfitsInfo();
    
    distributedProfitsInfo.IsReleased = true;
    
    foreach (var profits in profitsMap)
    {
        var symbol = profits.Key;
        var amount = profits.Value;
        if (amount > 0)
        {
            // Burn from general ledger
            var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = scheme.VirtualAddress,
                Symbol = symbol
            });
            if (balanceOfToken.Balance >= amount)
            {
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
            }
            
            // Update with negative amount for burned tokens
            var currentAmount = distributedProfitsInfo.AmountsMap.ContainsKey(symbol) 
                ? distributedProfitsInfo.AmountsMap[symbol] 
                : 0;
            distributedProfitsInfo.AmountsMap[symbol] = currentAmount - amount;
        }
    }
    
    // ALSO burn any pre-contributed tokens from the period-specific address
    foreach (var preContribution in distributedProfitsInfo.AmountsMap)
    {
        if (preContribution.Value > 0)
        {
            var balanceInPeriodAddress = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = preContribution.Key
            }).Balance;
            
            if (balanceInPeriodAddress > 0)
            {
                Context.SendVirtualInline(
                    GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                    State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), 
                    new TransferInput
                    {
                        To = Context.Self,
                        Amount = balanceInPeriodAddress,
                        Symbol = preContribution.Key
                    }.ToByteString());
                    
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = balanceInPeriodAddress,
                    Symbol = preContribution.Key
                });
                
                // Mark as burned
                distributedProfitsInfo.AmountsMap[preContribution.Key] = -balanceInPeriodAddress;
            }
        }
    }

    State.SchemeInfos[scheme.SchemeId] = scheme;
    State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
    return new Empty();
}
```

This fix ensures that:
1. Existing `DistributedProfitsInfo` is read and preserved
2. Pre-contributed tokens in period-specific addresses are actually burned
3. The accounting correctly reflects all burned amounts
4. No tokens are permanently locked

## Proof of Concept

```csharp
[Fact]
public async Task BurnProfits_OverwritesPreContributedProfits_CausingPermanentLoss()
{
    const long contributionAmount = 10000;
    const long targetPeriod = 5;
    
    var creator = Creators[0];
    var contributor = Normal[0];
    
    // Step 1: Create scheme
    var schemeId = await CreateSchemeAsync();
    
    // Step 2: User contributes to future period 5
    await contributor.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Amount = contributionAmount,
        Period = targetPeriod,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    });
    
    // Verify contribution was recorded
    var periodAddress = await creator.GetSchemeAddress.CallAsync(new SchemePeriod
    {
        SchemeId = schemeId,
        Period = targetPeriod
    });
    
    var balanceBeforeBurn = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = periodAddress,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    })).Balance;
    balanceBeforeBurn.ShouldBe(contributionAmount);
    
    var profitsInfoBefore = await creator.GetDistributedProfitsInfo.CallAsync(new SchemePeriod
    {
        SchemeId = schemeId,
        Period = targetPeriod
    });
    profitsInfoBefore.AmountsMap[ProfitContractTestConstants.NativeTokenSymbol].ShouldBe(contributionAmount);
    profitsInfoBefore.IsReleased.ShouldBe(false);
    
    // Step 3: Add then remove beneficiary to make totalShares = 0
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = Accounts[0].Address, Shares = 100 }
    });
    
    await creator.RemoveBeneficiary.SendAsync(new RemoveBeneficiaryInput
    {
        SchemeId = schemeId,
        Beneficiary = Accounts[0].Address
    });
    
    var scheme = await creator.GetScheme.CallAsync(schemeId);
    scheme.TotalShares.ShouldBe(0);
    
    // Step 4: Advance to target period and call DistributeProfits
    // This triggers BurnProfits because totalShares = 0
    for (long i = 1; i < targetPeriod; i++)
    {
        await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeId = schemeId,
            Period = i
        });
    }
    
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = targetPeriod
    });
    
    // Step 5: Verify the vulnerability - accounting destroyed but tokens still locked
    var profitsInfoAfter = await creator.GetDistributedProfitsInfo.CallAsync(new SchemePeriod
    {
        SchemeId = schemeId,
        Period = targetPeriod
    });
    
    // IsReleased is set, preventing future contributions
    profitsInfoAfter.IsReleased.ShouldBe(true);
    
    // AmountsMap was overwritten - the 10,000 ELF contribution record is GONE
    // It either shows 0 or negative value from burning general ledger (which had 0 balance)
    profitsInfoAfter.AmountsMap.ContainsKey(ProfitContractTestConstants.NativeTokenSymbol).ShouldBeFalse();
    
    // BUT the tokens are STILL LOCKED in the period-specific address!
    var balanceAfterBurn = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = periodAddress,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    })).Balance;
    
    // VULNERABILITY CONFIRMED: 10,000 ELF permanently locked
    balanceAfterBurn.ShouldBe(contributionAmount); // Tokens still there
    
    // No way to recover - IsReleased=true blocks future ContributeProfits
    var exception = await Assert.ThrowsAsync<Exception>(() => 
        contributor.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeId = schemeId,
            Amount = 1,
            Period = targetPeriod,
            Symbol = ProfitContractTestConstants.NativeTokenSymbol
        }));
    exception.Message.ShouldContain("already released");
}
```

## Notes

This vulnerability demonstrates a critical accounting inconsistency in the Profit contract where state destruction does not correspond to actual token movement. The root cause is `BurnProfits` treating all periods uniformly without checking for pre-existing contributions. The fix must ensure that reading existing state and burning from all relevant addresses (both general ledger and period-specific) happens atomically before updating the map.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L517-558)
```csharp
    private Empty BurnProfits(long period, Dictionary<string, long> profitsMap, Scheme scheme,
        Address profitsReceivingVirtualAddress)
    {
        scheme.CurrentPeriod = period.Add(1);

        var distributedProfitsInfo = new DistributedProfitsInfo
        {
            IsReleased = true
        };
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            if (amount > 0)
            {
                var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = symbol
                });
                if (balanceOfToken.Balance < amount)
                    continue;
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
                distributedProfitsInfo.AmountsMap.Add(symbol, -amount);
            }
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;
        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L682-712)
```csharp
        else
        {
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L51-60)
```csharp
    private Address GetDistributedPeriodProfitsVirtualAddress(Hash schemeId, long period)
    {
        return Context.ConvertVirtualAddressToContractAddress(
            GeneratePeriodVirtualAddressFromHash(schemeId, period));
    }

    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L11-11)
```csharp
    public MappedState<Address, DistributedProfitsInfo> DistributedProfitsMap { get; set; }
```
