# Audit Report

## Title
Incorrect LIB Index Calculation Violates 2/3 Consensus Threshold in AEDPoS

## Summary
The Last Irreversible Block (LIB) height calculation uses an incorrect index formula that fails to ensure 2/3 consensus when exactly `MinersCountOfConsent` miners have mined. This allows blocks to be finalized with as low as 57% miner agreement instead of the required 67%, violating Byzantine Fault Tolerance guarantees.

## Finding Description

The vulnerability exists in the LIB calculation algorithm. [1](#0-0)  The algorithm collects implied irreversible heights from miners who mined in the current round, checks if the count meets the minimum threshold, then selects a height using the index formula `(Count - 1) / 3`.

The `MinersCountOfConsent` property is defined as `(TotalMiners * 2 / 3) + 1`. [2](#0-1) 

**Root Cause:**

For a sorted list of heights [H₀, H₁, ..., Hₙ₋₁], selecting index `i` means that `(n - i)` miners have reported heights ≥ Hᵢ. When using index `(n-1)/3`:

- **For 7 total miners**: MinersCountOfConsent = 5
  - When Count = 5: index = 1, agreeing miners = 4 (57% of 7)
  - Required: 5 miners (71% of 7)
  - **Violation**: 4 < 5

- **For 10 total miners**: MinersCountOfConsent = 7  
  - When Count = 7: index = 2, agreeing miners = 5 (50% of 10)
  - Required: 7 miners (70% of 10)
  - **Violation**: 5 < 7

The check at line 26 only ensures sufficient miners have mined, but doesn't validate that the selected index provides 2/3 consensus. The index formula `(Count - 1) / 3` has no mathematical relationship to `MinersCountOfConsent`.

## Impact Explanation

This vulnerability compromises the fundamental security guarantees of the consensus system:

1. **Byzantine Fault Tolerance Breakdown**: Blocks can be finalized with only ~57% agreement, breaking the BFT assumption that up to 1/3 malicious nodes can be tolerated.

2. **Irreversible Block Compromise**: The incorrectly calculated LIB triggers the `IrreversibleBlockFound` event [3](#0-2)  which updates the chain state system-wide.

3. **Cross-Chain Impact**: The LIB is processed and propagated throughout the system via the event processor [4](#0-3)  affecting cross-chain verification and state finalization.

4. **No Additional Validation**: The existing validation provider only checks that LIB doesn't decrease, not that it has sufficient consensus. [5](#0-4) 

The entire security model of Byzantine Fault Tolerance is violated, allowing consensus with insufficient agreement.

## Likelihood Explanation

This vulnerability occurs naturally during normal protocol operation:

1. **Reachable Entry Point**: Triggered when miners call `UpdateValue` during consensus, which invokes the LIB calculation. [6](#0-5) 

2. **Natural Occurrence**: The vulnerable condition manifests when exactly `MinersCountOfConsent` miners have mined in the current round. Miners who have mined are identified by having `SupposedOrderOfNextRound != 0`. [7](#0-6) 

3. **No Attack Required**: This is a logic bug in the consensus algorithm itself, not requiring any malicious actor.

4. **Frequency**: With 7 miners, the probability that exactly 5 have mined when a miner processes `UpdateValue` is substantial during each consensus round.

5. **Detection Difficulty**: The miscalculation produces a valid block height, making it undetectable without analyzing the consensus mathematics.

## Recommendation

Replace the incorrect index formula with one that ensures proper 2/3 consensus:

**Current (incorrect):**
```csharp
libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**Fixed (correct):**
```csharp
libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(_currentRound.MinersCountOfConsent)];
```

This ensures that when selecting a height at index `i`, at least `(Count - i) >= MinersCountOfConsent` miners have reported heights at or above that value, maintaining the 2/3 consensus requirement.

## Proof of Concept

```csharp
[Fact]
public void LIB_Calculation_Violates_TwoThirds_Consensus()
{
    // Setup: 7 miners, MinersCountOfConsent = 5
    var previousRound = new Round
    {
        RoundNumber = 1,
        RealTimeMinersInformation =
        {
            ["miner1"] = new MinerInRound { Pubkey = "miner1", ImpliedIrreversibleBlockHeight = 100 },
            ["miner2"] = new MinerInRound { Pubkey = "miner2", ImpliedIrreversibleBlockHeight = 120 },
            ["miner3"] = new MinerInRound { Pubkey = "miner3", ImpliedIrreversibleBlockHeight = 150 },
            ["miner4"] = new MinerInRound { Pubkey = "miner4", ImpliedIrreversibleBlockHeight = 180 },
            ["miner5"] = new MinerInRound { Pubkey = "miner5", ImpliedIrreversibleBlockHeight = 200 },
            ["miner6"] = new MinerInRound { Pubkey = "miner6", ImpliedIrreversibleBlockHeight = 0 },
            ["miner7"] = new MinerInRound { Pubkey = "miner7", ImpliedIrreversibleBlockHeight = 0 }
        }
    };
    
    var currentRound = new Round
    {
        RoundNumber = 2,
        RealTimeMinersInformation =
        {
            ["miner1"] = new MinerInRound { Pubkey = "miner1", SupposedOrderOfNextRound = 1 },
            ["miner2"] = new MinerInRound { Pubkey = "miner2", SupposedOrderOfNextRound = 2 },
            ["miner3"] = new MinerInRound { Pubkey = "miner3", SupposedOrderOfNextRound = 3 },
            ["miner4"] = new MinerInRound { Pubkey = "miner4", SupposedOrderOfNextRound = 4 },
            ["miner5"] = new MinerInRound { Pubkey = "miner5", SupposedOrderOfNextRound = 5 },
            ["miner6"] = new MinerInRound { Pubkey = "miner6", SupposedOrderOfNextRound = 0 },
            ["miner7"] = new MinerInRound { Pubkey = "miner7", SupposedOrderOfNextRound = 0 }
        }
    };

    // Get mined miners (exactly 5 = MinersCountOfConsent)
    var minedMiners = currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
    minedMiners.Count.ShouldBe(5);
    
    // Get sorted heights [100, 120, 150, 180, 200]
    var heights = previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
    heights.Count.ShouldBe(5);
    
    // Current algorithm uses index = (5-1)/3 = 1
    var currentIndex = (heights.Count - 1) / 3; // = 1
    var selectedHeight = heights[currentIndex]; // = 120
    
    // Miners agreeing (heights >= 120): 4 miners at indices [1,2,3,4]
    var agreeingMiners = heights.Count - currentIndex; // = 4
    
    // Required for 2/3 consensus: 5 miners
    var minersCountOfConsent = currentRound.MinersCountOfConsent; // = 5
    
    // VULNERABILITY: 4 < 5 (57% < 71%)
    agreeingMiners.ShouldBeLessThan(minersCountOfConsent);
    
    // Correct index should be: Count - MinersCountOfConsent = 0
    var correctIndex = heights.Count - minersCountOfConsent; // = 0
    var correctHeight = heights[correctIndex]; // = 100
    var correctAgreeingMiners = heights.Count - correctIndex; // = 5
    correctAgreeingMiners.ShouldBeGreaterThanOrEqualTo(minersCountOfConsent);
}
```

**Notes:**
This vulnerability is a critical flaw in the core consensus mechanism that violates the fundamental Byzantine Fault Tolerance property. The index formula has no correlation with the defined `MinersCountOfConsent` threshold, resulting in blocks being finalized with insufficient miner agreement. The correct formula must ensure that at least `MinersCountOfConsent` miners agree on the selected LIB height.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockFoundLogEventProcessor.cs (L54-87)
```csharp
    private async Task ProcessLogEventAsync(Block block, IrreversibleBlockFound irreversibleBlockFound)
    {
        try
        {
            var chain = await _blockchainService.GetChainAsync();

            if (chain.LastIrreversibleBlockHeight > irreversibleBlockFound.IrreversibleBlockHeight)
                return;

            var libBlockHash = await _blockchainService.GetBlockHashByHeightAsync(chain,
                irreversibleBlockFound.IrreversibleBlockHeight, block.GetHash());
            if (libBlockHash == null) return;

            if (chain.LastIrreversibleBlockHeight == irreversibleBlockFound.IrreversibleBlockHeight) return;

            var blockIndex = new BlockIndex(libBlockHash, irreversibleBlockFound.IrreversibleBlockHeight);
            Logger.LogDebug($"About to set new lib height: {blockIndex.BlockHeight} " +
                            $"Event: {irreversibleBlockFound} " +
                            $"BlockIndex: {blockIndex.BlockHash} - {blockIndex.BlockHeight}");
            _taskQueueManager.Enqueue(
                async () =>
                {
                    var currentChain = await _blockchainService.GetChainAsync();
                    if (currentChain.LastIrreversibleBlockHeight < blockIndex.BlockHeight)
                        await _blockchainService.SetIrreversibleBlockAsync(currentChain, blockIndex.BlockHeight,
                            blockIndex.BlockHash);
                }, KernelConstants.UpdateChainQueueName);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Failed to resolve IrreversibleBlockFound event.");
            throw;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```
