# Audit Report

## Title
NextRound Validation Fails to Detect Duplicate Mining Orders Due to Incorrect Distinct() Usage

## Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` function incorrectly validates uniqueness of `FinalOrderOfNextRound` values by calling `.Distinct()` on `MinerInRound` objects instead of the order values themselves. This allows a malicious extra block producer to submit a round with duplicate mining orders, breaking the consensus schedule and potentially causing chain halt.

## Finding Description

The validation logic contains a critical bug where it attempts to verify that miners who mined blocks have distinct `FinalOrderOfNextRound` values, but the implementation is flawed. [1](#0-0) 

The code calls `.Distinct()` on a collection of `MinerInRound` objects. Since `MinerInRound` is a protobuf-generated message [2](#0-1) , its equality comparison includes all fields (pubkey, signature, order, in_value, out_value, etc.). Different miners will always be considered distinct objects even if they share the same `FinalOrderOfNextRound` value.

**Attack Scenario:**
1. Attacker becomes extra block producer (role rotates among miners)
2. Crafts malicious `NextRoundInput` where multiple miners have identical `FinalOrderOfNextRound` (e.g., all set to 1)
3. Sets `OutValue != null` for those miners
4. Validation counts: `distinctCount = 3` (three distinct miner objects) vs `OutValue count = 3`
5. Validation incorrectly passes (3 == 3)

This validation is invoked during NextRound behavior processing [3](#0-2) , and the validated round is then stored [4](#0-3) .

When the next round transition occurs, the generation logic uses these duplicate orders. [5](#0-4) 

The `occupiedOrders` list will contain duplicates, but `.Contains()` only excludes each value once. This results in multiple miners being assigned the same `Order` value in the next round [6](#0-5) , while some valid order slots remain empty, creating an invalid consensus schedule.

## Impact Explanation

**Severity: HIGH** - This directly violates the critical consensus invariant that each miner must have a unique mining order within a round.

When multiple miners have the same `Order` value:
- Multiple miners have identical `ExpectedMiningTime` values (calculated from their order)
- The consensus protocol cannot handle overlapping mining times
- Block production fails or creates competing blocks at the same height
- Chain may halt due to inability to reach consensus
- All network participants experience disruption
- Miners lose block rewards during failed rounds
- Chain liveness and safety guarantees are violated

This breaks the fundamental "one miner per time slot" invariant that the AEDPoS consensus depends on for proper operation.

## Likelihood Explanation

**Probability: HIGH** - This vulnerability is easily exploitable with standard miner privileges.

**Attacker Requirements:**
- Must be selected as extra block producer (rotates regularly among all miners)
- No special privileges beyond being a legitimate miner
- Can call the public `NextRound` method [7](#0-6) 

**Attack Complexity:**
- Low - simply craft a `NextRoundInput` with duplicate `FinalOrderOfNextRound` values
- No economic cost beyond normal mining operations
- The validation bypass is guaranteed due to the `.Distinct()` bug
- Detection is difficult as it appears as a normal round transition

**Feasibility:**
- Extra block producer role rotates regularly among miners [8](#0-7) 
- Any malicious miner can exploit this during their turn
- The attack is reproducible and reliable
- No other validations check for duplicate orders in the NextRound flow

## Recommendation

Fix the validation to check for distinct order values, not distinct miner objects:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Select the order values
    .Distinct()
    .Count();
```

This ensures the validation actually checks for duplicate order values rather than duplicate miner objects.

## Proof of Concept

The POC would demonstrate:
1. Create a NextRoundInput with 3 miners who all have `FinalOrderOfNextRound = 1`
2. Set `OutValue != null` for all 3 miners
3. Call NextRound() with this input
4. Validation passes (distinctCount = 3 distinct MinerInRound objects)
5. Round is stored with duplicate orders
6. Next round generation assigns multiple miners Order = 1
7. Consensus schedule becomes invalid with overlapping time slots

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-86)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-38)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
```
