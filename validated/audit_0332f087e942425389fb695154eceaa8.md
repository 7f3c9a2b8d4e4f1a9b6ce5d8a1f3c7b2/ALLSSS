# Audit Report

## Title
Malicious Miner Can Halt Blockchain by Calling NextTerm with Empty Miner List

## Summary
A malicious authorized miner can permanently halt the AElf blockchain by submitting a `NextTerm` transaction with an empty `RealTimeMinersInformation` dictionary. This bypasses all validation checks and sets an empty miner list, preventing all miners from producing subsequent blocks because consensus command generation fails when no miners exist in the round.

## Finding Description

The vulnerability exists in the term transition logic of the AEDPoS consensus contract. The security guarantee that should be maintained is: **the miner list for any term must contain at least one miner to enable block production**.

### Attack Vector

1. **Entry Point**: The `NextTerm` method is a public RPC method that accepts `NextTermInput` from any transaction sender. [1](#0-0) 

2. **Insufficient Authorization**: The `PreCheck()` method only validates that the transaction sender is in the current or previous miner list, but does NOT validate the content of the `NextTermInput` parameter. [2](#0-1) 

3. **Validation Gap**: The `RoundTerminateValidationProvider` validates round and term number increments, but the critical check `extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)` returns false when the dictionary is empty, allowing validation to pass with success. [3](#0-2) 

4. **Unchecked State Corruption**: In `ProcessNextTerm`, the miner list is created from `nextRound.RealTimeMinersInformation.Keys` without validation. An empty dictionary produces an empty `MinerList`. [4](#0-3) 

5. **No Bounds Check**: The `SetMinerList` method directly sets the state variables without any validation that the list contains at least one miner. [5](#0-4) 

6. **Consensus Failure**: When miners attempt to get a consensus command, `GetConsensusCommand` checks `currentRound.IsInMinerList(_processingBlockMinerPubkey)` and returns `InvalidConsensusCommand` if false. [6](#0-5) 

The `IsInMinerList` method returns `RealTimeMinersInformation.Keys.Contains(pubkey)`. With an empty dictionary, this always returns false for any miner, causing all miners to receive `InvalidConsensusCommand`. [7](#0-6) 

7. **Additional Failures**: Multiple code paths will fail with empty miner lists, including calls to `.Single(m => m.Value.IsExtraBlockProducer)` on an empty collection which will throw exceptions. [8](#0-7) 

## Impact Explanation

**Severity: CRITICAL**

This vulnerability achieves complete and permanent denial of service of the entire blockchain:

- **Consensus Breakdown**: Once the empty miner list is set, `GetConsensusCommand` returns `InvalidConsensusCommand` for ALL miners, meaning no miner can produce any blocks.
- **Permanent Halt**: There is no recovery mechanism in the contract code. The blockchain remains halted until extraordinary measures (hard fork or manual state intervention) are taken.
- **Network-Wide Impact**: All network participants lose access. Token holders cannot transfer assets, DApps become inoperable, cross-chain bridges halt, and all governance operations cease.
- **Economic Damage**: Complete loss of network functionality affects all stakeholders and could result in massive economic losses.

The impact is maximal because it breaks the fundamental consensus invariant (non-empty miner list) and has no programmatic recovery path.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is easily executable with minimal barriers:

- **Attacker Requirements**: Must be an authorized miner (in current or previous round). Since miners are elected through the Election contract and multiple miners exist in the network, this is a realistic constraint.
- **Attack Complexity**: VERY LOW. The attacker simply crafts a `NextTermInput` with correct round/term numbers but an empty `real_time_miners_information` dictionary, then submits it via a transaction.
- **No Special Conditions**: No timing requirements, race conditions, or coordination needed. The attack can be executed at any time during normal operation.
- **Low Cost**: Only requires a normal transaction fee.
- **Undetectable**: The malicious transaction appears as a normal term transition until after execution when the chain halts.

Any disgruntled or compromised miner can execute this attack instantly with minimal effort and cost.

## Recommendation

Add explicit validation in the `RoundTerminateValidationProvider` to reject empty miner lists:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Add validation for non-empty miner list
    if (extraData.Round.RealTimeMinersInformation.Count == 0)
        return new ValidationResult { Message = "Miner list cannot be empty for next term." };

    // Is next term number correct?
    return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
        ? new ValidationResult { Message = "Incorrect term number for next round." }
        : new ValidationResult { Success = true };
}
```

Additionally, add a defensive check in `SetMinerList`:

```csharp
private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
{
    Assert(minerList != null && minerList.Pubkeys.Count > 0, "Miner list cannot be empty.");
    
    var minerListFromState = State.MinerListMap[termNumber];
    if (gonnaReplaceSomeone || minerListFromState == null)
    {
        State.MainChainCurrentMinerList.Value = minerList;
        State.MinerListMap[termNumber] = minerList;
        return true;
    }
    return false;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task EmptyMinerList_ShouldHaltBlockchain()
{
    // Setup: Initialize consensus with valid miners
    var initialMiners = GenerateInitialMiners(3);
    await InitializeConsensus(initialMiners);
    
    // Attacker (current miner) crafts malicious NextTermInput with empty miner list
    var maliciousInput = new NextTermInput
    {
        RoundNumber = 2,
        TermNumber = 2,
        RealTimeMinersInformation = {}, // Empty dictionary - the attack payload
        RandomNumber = GenerateRandomNumber()
    };
    
    // Execute attack - this should fail but doesn't due to validation bug
    var result = await ConsensusContract.NextTerm(maliciousInput);
    result.Should().NotBeNull(); // Transaction succeeds
    
    // Verify blockchain is now halted
    var currentMinerList = await ConsensusContract.GetCurrentMinerList();
    currentMinerList.Pubkeys.Count.Should().Be(0); // Miner list is empty
    
    // Verify no miner can produce blocks
    foreach (var miner in initialMiners)
    {
        var command = await ConsensusContract.GetConsensusCommand(miner.PublicKey);
        command.Should().Be(ConsensusCommandProvider.InvalidConsensusCommand); // All miners receive invalid command
    }
    
    // Blockchain is permanently halted - no programmatic recovery possible
}
```

## Notes

The root cause is a logic error in the validation provider where `Any(m => m.InValue != null)` returns `false` for an empty collection, which counterintuitively causes the validation to **pass**. The ternary operator returns success when the condition is false, allowing empty miner lists through validation. This creates a permanent blockchain halt with no recovery mechanism in the contract code.

### Citations

**File:** protobuf/aedpos_contract.proto (L37-39)
```text
    // Update consensus information, create a new term.
    rpc NextTerm (NextTermInput) returns (google.protobuf.Empty) {
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L32-34)
```csharp
        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-170)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;
```
