# Audit Report

## Title
NFT Burn Function Allows Negative Amounts to Inflate Balances and Bypass Supply Limits

## Summary
The NFT contract's `Burn` function accepts negative amounts without validation, allowing authorized minters to arbitrarily inflate token balances and supply counters by calling burn with negative values. This completely breaks the token supply invariant and enables unlimited token creation beyond the protocol's `TotalSupply` limit.

## Finding Description

The vulnerability exists in the `Burn` method where `input.Amount` is a signed `int64` field that can accept negative values. [1](#0-0) 

The method performs a balance check that only verifies the current balance is greater than or equal to the input amount. When the amount is negative (e.g., -100), this check passes because any non-negative balance is greater than a negative number (e.g., `0 >= -100` evaluates to true). [2](#0-1) 

Subsequently, three critical state updates use the `Sub` extension method which performs simple arithmetic subtraction. [3](#0-2)  The `Sub` method is implemented as `return a - b` in a checked context. [4](#0-3) 

When subtracting a negative value, this actually increases the balance: `balance.Sub(-100)` = `balance - (-100)` = `balance + 100`. This applies to the caller's balance, the protocol's supply counter, and the NFT's quantity counter.

The vulnerability is evident when comparing to the `DoTransfer` method, which explicitly validates against negative amounts. [5](#0-4)  Additionally, the MultiToken contract's Burn implementation validates amounts using `AssertValidToken` which internally checks for positive amounts. [6](#0-5) [7](#0-6)  The NFT Burn method lacks both of these critical validations.

## Impact Explanation

This represents **HIGH severity** with direct impact to protocol integrity:

1. **Unlimited Token Creation**: A minter can inflate their balance arbitrarily by calling Burn with large negative amounts (e.g., -1,000,000), effectively minting unlimited tokens without going through the legitimate mint process

2. **Bypass Supply Caps**: The `nftProtocolInfo.Supply` counter is inflated alongside balances, allowing token creation beyond the protocol's `TotalSupply` limit set during creation [8](#0-7) 

3. **Broken Accounting Invariants**: The fundamental invariant that `Supply = sum of all balances` is violated, corrupting the protocol's token economics and making supply tracking unreliable

4. **Privilege Escalation**: While minters are semi-trusted roles authorized to mint tokens through the legitimate `Mint` function with supply cap checks, they are NOT intended to have unlimited minting power or the ability to bypass supply caps - this violates the expected privilege boundaries

The minter role is a common authorization in NFT systems (for legitimate minting operations), making this a practical vulnerability in the trust model, not merely a theoretical concern.

## Likelihood Explanation

**HIGH likelihood** due to:

**Minimal Prerequisites:**
- Must be in the minter list for the NFT protocol (common role that protocol creators routinely grant)
- NFT protocol must have `IsBurnable` set to true (standard feature for NFT protocols)

**Trivial Execution:**
- Requires only a single transaction: `Burn(symbol, tokenId, -1000000)`
- No complex setup or timing requirements
- No need for multiple transactions or state manipulation

**Fully Practical:**
- The protobuf message definition accepts signed `int64`, so negative values are valid input at the protocol level
- No runtime or contract-level validation prevents negative amounts from reaching the arithmetic operations
- Transaction costs are negligible compared to the value of minting unlimited tokens

**Detection Limitations:**
- While the `Burned` event would emit a negative amount (making it theoretically detectable), the state corruption occurs immediately and irreversibly before any monitoring can respond

## Recommendation

Add explicit validation to reject negative amounts in the `Burn` method, consistent with the validation pattern used in `DoTransfer` and the MultiToken contract's `Burn` method:

```csharp
public override Empty Burn(BurnInput input)
{
    // Add validation at the start
    Assert(input.Amount > 0, "Invalid burn amount.");
    
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    var nftInfo = GetNFTInfoByTokenHash(tokenHash);
    var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
    Assert(nftProtocolInfo.IsBurnable,
        $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
    var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
    Assert(
        State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
        minterList.Value.Contains(Context.Sender),
        "No permission.");
    // ... rest of the method
}
```

This follows the same pattern as the MultiToken contract's `AssertValidSymbolAndAmount` validation.

## Proof of Concept

```csharp
[Fact]
public async Task BurnWithNegativeAmount_InflatesBalance()
{
    // Setup: Create NFT protocol and mint one token
    var symbol = await CreateTest(); // Creates burnable NFT protocol
    await AddMinterAsync(symbol);
    
    var tokenHash = (await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        Alias = "test",
        Owner = MinterAddress,
        Quantity = 1
    })).Output;
    
    // Verify initial balance is 1
    var initialBalance = (await MinterNFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = MinterAddress,
        Symbol = symbol,
        TokenId = 1
    })).Balance;
    initialBalance.ShouldBe(1);
    
    // Get initial protocol supply
    var initialProtocol = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = symbol });
    var initialSupply = initialProtocol.Supply;
    initialSupply.ShouldBe(1);
    
    // Exploit: Call Burn with negative amount
    await MinterNFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        TokenId = 1,
        Amount = -1000000  // Negative amount!
    });
    
    // Verify balance INCREASED instead of decreased
    var finalBalance = (await MinterNFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = MinterAddress,
        Symbol = symbol,
        TokenId = 1
    })).Balance;
    finalBalance.ShouldBe(1000001); // 1 + 1000000
    
    // Verify supply INCREASED beyond TotalSupply cap
    var finalProtocol = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = symbol });
    finalProtocol.Supply.ShouldBe(1000001); // Bypassed TotalSupply limit!
}
```

## Notes

This vulnerability demonstrates a critical gap in input validation where the NFT contract's `Burn` function lacks the same protective checks present in similar methods (`DoTransfer` in the same contract and `Burn` in MultiToken). The signed integer type combined with arithmetic subtraction creates an exploitable condition that allows privilege escalation for semi-trusted minters, enabling them to bypass the fundamental supply cap enforcement mechanism.

### Citations

**File:** protobuf/nft_contract.proto (L182-186)
```text
message BurnInput {
    string symbol = 1;
    int64 token_id = 2;
    int64 amount = 3;
}
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-48)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L91-93)
```csharp
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L94-96)
```csharp
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L323-327)
```csharp
    private Empty Burn(Address address, string symbol, long amount)
    {
        var tokenInfo = AssertValidToken(symbol, amount);
        Assert(tokenInfo.IsBurnable, "The token is not burnable.");
        ModifyBalance(address, symbol, -amount);
```
