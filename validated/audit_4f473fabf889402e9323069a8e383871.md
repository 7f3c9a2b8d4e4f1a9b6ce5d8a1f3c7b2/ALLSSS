# Audit Report

## Title
Consensus Round Data Pollution via Unvalidated Cross-Miner State Injection

## Summary
A malicious miner can inject arbitrary mining order and VRF chain values for ALL miners in a consensus round, bypassing validation due to a critical same-object comparison bug in `ValidateConsensusAfterExecution` and the absence of cross-miner data validation in `UpdateValueValidationProvider`. This vulnerability enables mining schedule manipulation and VRF random number corruption, directly violating consensus integrity.

## Finding Description

The AEDPoS consensus contract contains a critical vulnerability where malicious miners can inject arbitrary consensus-critical data for all miners without validation, enabling them to manipulate mining schedules and corrupt VRF random number chains.

**Root Cause 1: Same-Object Comparison Bug**

The `ValidateConsensusAfterExecution` method has a critical implementation flaw. When validating UpdateValue behavior, it calls `RecoverFromUpdateValue` which modifies the state Round object in-place and returns the same reference: [1](#0-0) 

The method modifies `this` and returns `this` (line 32), creating a same-object reference issue in the validation logic: [2](#0-1) 

After line 92, both `currentRound` and `headerInformation.Round` reference the SAME object. The hash comparison on line 100-101 compares the object to itself, making validation always pass regardless of whether the recovered Round matches the expected state.

**Root Cause 2: Missing Cross-Miner Validation**

The `UpdateValueValidationProvider` only validates the sender's own data, not cross-miner data: [3](#0-2) 

The provider validates only the sender's `OutValue`, `Signature`, and `PreviousInValue`. It does NOT validate `TuneOrderInformation` or `MinersPreviousInValues` which affect ALL miners.

**Root Cause 3: Unconditional Application of Cross-Miner Data**

The `ProcessUpdateValue` function directly applies attacker-controlled data to ALL miners without validation: [4](#0-3) [5](#0-4) 

The `TuneOrderInformation` (line 259-260) and `MinersPreviousInValues` (line 295-296) from the attacker's input are applied directly to all miners' state.

**Attack Execution Flow**

1. Malicious miner modifies their node software to intercept the Round object after `ApplyNormalConsensusData` generates legitimate consensus data: [6](#0-5) 

2. The attacker tampers with ALL miners' `FinalOrderOfNextRound` and `PreviousInValue` fields before the Round is simplified for the block header: [7](#0-6) 

3. The simplified Round containing corrupted data for ALL miners is included in the block header.

4. Transaction generation extracts the corrupted data into `UpdateValueInput`: [8](#0-7) 

5. The before-execution validation passes because it only checks the sender's data, not cross-miner fields: [9](#0-8) 

6. Execution applies the corrupted data to all miners' state without validation.

7. The after-execution validation passes due to the same-object comparison bug, completing the attack.

## Impact Explanation

**Critical Consensus Integrity Violation:**

1. **Mining Schedule Manipulation**: By controlling `FinalOrderOfNextRound` values, the attacker can:
   - Assign themselves the first mining slot (maximum block rewards)
   - Demote competitors to later or invalid positions
   - Violate the deterministic VRF-based order resolution specified in: [10](#0-9) 

2. **VRF Random Number Chain Corruption**: By controlling `PreviousInValue` for other miners, the attacker:
   - Breaks the cryptographic VRF chain used for consensus randomness
   - Causes legitimate miners to fail validation when their actual `PreviousInValue` doesn't match the corrupted stored value
   - Potentially enables prediction or manipulation of future random numbers
   - Compromises the randomness guarantees of the consensus mechanism

3. **Systemic Consensus Failure**: Every malicious miner can corrupt ALL other miners' state in each block they produce, leading to cascading failures across the network.

**Severity: CRITICAL** - Directly violates the fundamental consensus invariant that miners cannot unilaterally modify other miners' consensus state.

## Likelihood Explanation

**High Exploitability:**

1. **Low Attack Barrier**: Any elected miner can execute this attack by modifying their node software. No special cryptographic knowledge or additional privileges required.

2. **Guaranteed Execution Opportunity**: Elected miners have guaranteed time slots to produce blocks, providing reliable attack windows.

3. **No Economic Cost**: Beyond normal staking requirements to become an elected miner, the attack has no additional cost and offers immediate benefits through mining reward manipulation.

4. **Failed Detection Mechanisms**: 
   - The same-object comparison bug makes post-execution validation ineffective
   - Cross-miner data validation is completely absent
   - Corrupted state appears valid to all nodes

5. **Economic Incentive**: Attackers can gain unfair mining rewards by manipulating their position in the mining order, while simultaneously disrupting competitors.

**Probability: HIGH** - The attack is practically executable by any malicious elected miner with minimal technical modification to their node software.

## Recommendation

**Fix 1: Correct the Same-Object Comparison Bug**

Modify `ValidateConsensusAfterExecution` to create a separate recovered Round object instead of modifying the state Round in-place:

```csharp
public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
{
    var headerInformation = new AElfConsensusHeaderInformation();
    headerInformation.MergeFrom(input.Value);
    if (TryToGetCurrentRoundInformation(out var currentRound))
    {
        // Create a clone to avoid same-object comparison
        var recoveredRound = currentRound.Clone();
        
        if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
            recoveredRound = recoveredRound.RecoverFromUpdateValue(headerInformation.Round,
                headerInformation.SenderPubkey.ToHex());

        if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
            recoveredRound = recoveredRound.RecoverFromTinyBlock(headerInformation.Round,
                headerInformation.SenderPubkey.ToHex());

        var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
        if (recoveredRound.GetHash(isContainPreviousInValue) !=
            currentRound.GetHash(isContainPreviousInValue))
        {
            // ... existing mismatch handling ...
        }
    }
    return new ValidationResult { Success = true };
}
```

**Fix 2: Add Cross-Miner Data Validation**

Extend `UpdateValueValidationProvider` to validate that `TuneOrderInformation` and `MinersPreviousInValues` match expected consensus-derived values:

```csharp
private bool ValidateTuneOrderInformation(ConsensusValidationContext validationContext)
{
    // Verify each tuned order matches the expected conflict resolution
    foreach (var tuneOrder in validationContext.ProvidedRound.TuneOrderInformation)
    {
        if (tuneOrder.Key == validationContext.SenderPubkey) continue; // Sender can tune their own
        
        // Other miners' orders should only be tuned for legitimate conflict resolution
        var expectedOrder = CalculateExpectedOrder(tuneOrder.Key, validationContext.BaseRound);
        if (tuneOrder.Value != expectedOrder)
            return false;
    }
    return true;
}

private bool ValidateMinersPreviousInValues(ConsensusValidationContext validationContext)
{
    // Only the sender's PreviousInValue should be updated
    foreach (var previousInValue in validationContext.ProvidedRound.MinersPreviousInValues)
    {
        if (previousInValue.Key != validationContext.SenderPubkey)
            return false; // Other miners' PreviousInValue should not be modified
    }
    return true;
}
```

**Fix 3: Restrict Cross-Miner Data Updates**

Modify `ProcessUpdateValue` to reject or ignore cross-miner data updates from `TuneOrderInformation` and `MinersPreviousInValues` for miners other than the sender.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanInjectCrossMinerData()
{
    // Setup: Create a round with multiple miners
    var miners = new[] { "miner1", "miner2", "miner3" };
    var round = await SetupRoundWithMiners(miners);
    
    // Malicious miner1 produces a block with corrupted cross-miner data
    var maliciousUpdateInput = new UpdateValueInput
    {
        // Legitimate data for miner1
        OutValue = Hash.FromString("miner1_out"),
        Signature = Hash.FromString("miner1_sig"),
        PreviousInValue = Hash.FromString("miner1_prev"),
        
        // ATTACK: Inject arbitrary order for ALL miners
        TuneOrderInformation = 
        {
            { "miner1", 1 },  // Attacker assigns themselves first slot
            { "miner2", 99 }, // Demote competitor to invalid position
            { "miner3", 98 }
        },
        
        // ATTACK: Inject arbitrary PreviousInValue for other miners
        MinersPreviousInValues = 
        {
            { "miner2", Hash.FromString("corrupted_value") },
            { "miner3", Hash.FromString("corrupted_value") }
        }
    };
    
    // Execute the attack
    await MinerStub.UpdateValue(maliciousUpdateInput);
    
    // Verify the attack succeeded
    var updatedRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // CRITICAL: All miners' data was corrupted
    Assert.Equal(1, updatedRound.RealTimeMinersInformation["miner1"].FinalOrderOfNextRound);
    Assert.Equal(99, updatedRound.RealTimeMinersInformation["miner2"].FinalOrderOfNextRound);
    Assert.Equal(98, updatedRound.RealTimeMinersInformation["miner3"].FinalOrderOfNextRound);
    
    Assert.Equal(Hash.FromString("corrupted_value"), 
        updatedRound.RealTimeMinersInformation["miner2"].PreviousInValue);
    Assert.Equal(Hash.FromString("corrupted_value"), 
        updatedRound.RealTimeMinersInformation["miner3"].PreviousInValue);
    
    // CRITICAL: Validation passed despite corruption
    // This proves the same-object comparison bug and missing validation
}
```

## Notes

This vulnerability represents a fundamental break in the consensus security model. The combination of the same-object comparison bug and missing cross-miner validation creates a complete bypass of integrity checks, allowing any elected miner to arbitrarily manipulate consensus-critical state for all participants. The impact extends beyond individual block rewards to the core randomness and fairness guarantees of the AEDPoS consensus mechanism.

The attack requires only elected miner status (achievable through normal staking) and basic node software modification, making it highly accessible to motivated attackers. The economic incentive is immediate (manipulate mining order for rewards) while detection is effectively impossible due to the broken validation logic.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L87-101)
```csharp
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L35-53)
```csharp
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-47)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);

        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```
