# Audit Report

## Title
Missing Cross-Chain Verification in NFT Protocol Creation Allows Unauthorized Protocol Registration

## Summary
The `CrossChainCreate()` function in the NFT contract lacks cryptographic cross-chain verification and authorization checks, allowing any address to create NFT protocols for existing tokens without proper merkle proof validation required by AElf's cross-chain security model.

## Finding Description

The vulnerability exists in the `CrossChainCreate()` method which only accepts a symbol parameter and performs no cryptographic verification. [1](#0-0) 

The input message structure only requires a symbol string, with no merkle path or transaction verification data: [2](#0-1) 

This contrasts sharply with the secure implementation in MultiToken's `CrossChainCreateToken()`, which properly implements cross-chain verification by accepting comprehensive parameters including merkle paths and transaction bytes: [3](#0-2) 

The MultiToken contract calls the `CrossChainVerify` helper method that performs cryptographic merkle proof validation through the CrossChain contract: [4](#0-3) [5](#0-4) 

Additionally, while the `Create()` function enforces mainchain-only creation with chain ID validation, the `CrossChainCreate()` function has no such validation: [6](#0-5) 

The method is publicly exposed as an RPC endpoint: [7](#0-6) 

## Impact Explanation

**Critical Security Violations**:

1. **Unauthorized Protocol Creation**: Any address can create NFT protocols for any token in the local TokenContract without authorization from the token creator or proper cross-chain validation

2. **Bypass Mainchain-Only Invariant**: The system enforces that NFT protocols should only be created on the AELF mainchain through the `Create()` method, but `CrossChainCreate()` allows this security boundary to be bypassed on sidechains

3. **Front-Running Attacks**: Attackers can monitor pending legitimate cross-chain NFT protocol registrations and front-run them by calling `CrossChainCreate()` first. The legitimate transaction will then fail due to the "already created" assertion

4. **Cross-Chain Integrity Violation**: This completely defeats AElf's cross-chain security model which requires cryptographic merkle proof verification for all cross-chain operations, as demonstrated by the MultiToken contract's proper implementation

The severity is **CRITICAL** because it breaks fundamental cross-chain security guarantees that the AElf blockchain relies upon for secure multi-chain operations.

## Likelihood Explanation

**Attacker Requirements**:
- Any address can call the function - it has no authorization checks
- Only requires ability to send a transaction (standard capability)
- Function is publicly accessible as a standard RPC method

**Attack Complexity**: 
- Extremely Low - single function call with one parameter
- Precondition: A token with the target symbol must exist in the local TokenContract (very common on sidechains where tokens are cross-chain transferred)

**Feasibility**:
- Standard gas costs only
- No timing requirements
- Easily reproducible
- Difficult to prevent or detect before execution

The probability is **HIGH** - the attack is trivial to execute and economically rational for griefing, front-running, or exploiting protocol assumptions.

## Recommendation

Implement proper cross-chain verification similar to MultiToken's `CrossChainCreateToken()`:

1. **Update the input message** to include cross-chain verification parameters (from_chain_id, parent_chain_height, transaction_bytes, merkle_path)

2. **Add cryptographic verification** by calling the `CrossChainVerify` helper method to validate the merkle proof

3. **Add authorization checks** to ensure only the token issuer or authorized parties can create NFT protocols

4. **Add chain ID validation** to enforce mainchain-only creation or properly validate cross-chain sources

The implementation should follow the pattern established in `CrossChainCreateToken()` which properly verifies cross-chain transactions through merkle proofs before allowing token registration.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreate_Unauthorized_Frontrun_Attack_Test()
{
    // Setup: Create a token on the chain (simulating cross-chain token transfer)
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "TESTNFT",
        TokenName = "Test NFT Token",
        TotalSupply = 1000000,
        Decimals = 0,
        Issuer = DefaultAddress,
        IsBurnable = true,
        IssueChainId = ChainHelper.ConvertBase58ToChainId("AELF"),
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                { "aelf_nft_type", "Art" },
                { "aelf_nft_base_uri", "ipfs://test/" },
                { "aelf_nft_token_id_reuse", "false" }
            }
        }
    });
    
    // Add NFT type mapping
    await NFTContractStub.AddNFTType.SendAsync(new AddNFTTypeInput
    {
        ShortName = "TE",
        FullName = "Art"
    });
    
    // Attack: Unauthorized attacker calls CrossChainCreate before legitimate creator
    var attackerStub = GetNFTContractStub(Accounts[1].KeyPair); // Different account
    var attackResult = await attackerStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
    {
        Symbol = "TESTNFT"
    });
    
    // Verify: Attack succeeded - protocol was created by unauthorized party
    attackResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Legitimate creator's subsequent attempt fails
    var legitimateResult = await NFTContractStub.CrossChainCreate.SendWithExceptionAsync(
        new CrossChainCreateInput { Symbol = "TESTNFT" });
    legitimateResult.TransactionResult.Error.ShouldContain("Protocol TESTNFT already created");
    
    // Verify: NFT protocol exists but was created without authorization
    var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(
        new StringValue { Value = "TESTNFT" });
    protocolInfo.Symbol.ShouldBe("TESTNFT");
    // Protocol was created without any cross-chain verification or authorization
}
```

**Notes**

The vulnerability is confirmed through comprehensive code analysis showing that the NFT contract's `CrossChainCreate()` method completely lacks the cross-chain verification mechanisms that are standard in AElf's cross-chain operations. The absence of merkle proof validation, authorization checks, and chain ID verification creates a critical security gap that enables unauthorized protocol creation and front-running attacks. The comparison with the properly-implemented `CrossChainCreateToken()` method in the MultiToken contract clearly demonstrates what security measures are missing.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-17)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** protobuf/nft_contract.proto (L25-26)
```text
    rpc CrossChainCreate (CrossChainCreateInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/nft_contract.proto (L132-134)
```text
message CrossChainCreateInput {
    string symbol = 1;
}
```

**File:** protobuf/token_contract.proto (L571-580)
```text
message CrossChainCreateTokenInput {
    // The chain id of the chain on which the token was created.
    int32 from_chain_id = 1;
    // The height of the transaction that created the token.
    int64 parent_chain_height = 2;
    // The transaction that created the token.
    bytes transaction_bytes = 3;
    // The merkle path created from the transaction that created the transaction.
    aelf.MerklePath merkle_path = 4;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-534)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```
