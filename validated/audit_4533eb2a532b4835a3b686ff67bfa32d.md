# Audit Report

## Title
VotersCount Permanent Inflation Due to Asymmetric Increment/Decrement Logic in Withdraw Function

## Summary
The Vote contract contains a critical logic inconsistency where `VotersCount` is incremented for every vote transaction but only decremented when a voter has no remaining active votes. This asymmetry allows any voter casting multiple votes to permanently inflate the `VotersCount` metric, corrupting voting statistics used throughout the governance system.

## Finding Description

The vulnerability stems from fundamentally different accounting logic between voting and withdrawal operations:

**Vote Operation - Per-Transaction Increment:**

When a vote is cast through the `Vote()` function, it calls `UpdateVotingResult()` which unconditionally increments `VotersCount` by 1 for every individual vote transaction, regardless of whether the voter has already voted on the same voting item. [1](#0-0) 

**Withdraw Operation - Per-Voter Decrement:**

When withdrawing a vote through the `Withdraw()` function, the code only decrements `VotersCount` if the voter has NO remaining active votes for that voting item. The withdrawal first removes the vote from `ActiveVotes`, then conditionally decrements only when `ActiveVotes.Any()` returns false. [2](#0-1) 

**Mathematical Imbalance:**
- A voter casts N votes → `VotersCount` increases by N
- The voter withdraws N-1 votes → `VotersCount` unchanged (still has 1 active vote)
- The voter withdraws the last vote → `VotersCount` decreases by 1
- **Net effect:** `VotersCount` inflated by (N-1)

**Test Evidence:**

The test suite confirms this behavior. When two voters each cast two votes, `VotersCount` reaches 4, not 2, demonstrating that it tracks total vote transactions rather than unique voters. [3](#0-2) 

Another test shows multiple users voting multiple times in phase 2, with user3 voting twice contributing +2 to the count. [4](#0-3) 

**Persistence Across Snapshots:**

When taking a snapshot to transition between voting periods using `TakeSnapshot()`, the inflated `VotersCount` is directly copied from the previous snapshot to the new one, making the corruption permanent across voting periods. [5](#0-4) 

**Exposure to Governance Systems:**

The Election contract's `GetVotersCount()` method directly exposes this corrupted metric through a public view method, allowing the inflated count to propagate into governance decisions and analytics. [6](#0-5) 

## Impact Explanation

**Direct Governance Impact:**

The `VotersCount` metric serves as a key indicator of voter participation in governance systems. Its permanent inflation corrupts:
- Voter participation statistics displayed to users
- Governance analytics used for decision-making  
- Election contract metrics consumed by other systems
- Historical voting records across snapshot transitions

**Severity Assessment - Medium:**

While this vulnerability does not directly result in fund theft or unauthorized privilege escalation, it corrupts critical governance state that is:
1. **Permanent**: The inflation accumulates indefinitely and persists across snapshots
2. **Public**: The metric is exposed via view methods to all consumers
3. **Governance-Critical**: Used by the Election contract and potentially other governance systems
4. **Cumulative**: Each multi-vote scenario adds to the inflation

The corrupted data undermines the integrity of the voting system and can mislead governance participants about actual voter engagement levels.

## Likelihood Explanation

**Attack Feasibility - High:**

- **No Special Privileges**: Any address with sufficient token balance can trigger this behavior
- **Trivial Execution**: Simply vote multiple times, then withdraw votes incrementally
- **No Economic Barrier**: Tokens are returned on withdrawal, making the operation cost-neutral
- **Natural Occurrence**: This happens automatically whenever any user legitimately votes multiple times and withdraws incrementally, whether malicious or not

**Technical Constraints - None:**

- Voting items accept multiple votes from the same voter (confirmed by tests)
- No rate limiting or duplicate vote prevention exists
- Withdrawal is publicly accessible with only voter ownership checks [7](#0-6) 
- The behavior is inherent to the contract logic, not requiring special timing or state manipulation

**Detection Difficulty:**

The inflation is subtle and accumulates gradually without triggering any transaction failures or errors, making it difficult to detect until significantly inflated.

## Recommendation

Modify the `UpdateVotingResult()` and `Withdraw()` functions to track unique voters rather than vote transactions. Implement one of these approaches:

**Option 1: Track First Vote Only**
- Only increment `VotersCount` when a voter casts their first vote on a voting item
- Only decrement `VotersCount` when a voter withdraws all active votes
- Check if `ActiveVotes` is empty before the vote to determine if this is the first vote

**Option 2: Rename the Metric**
- Rename `VotersCount` to `VotesCount` to accurately reflect that it counts total votes, not unique voters
- Add a separate `UniqueVotersCount` field that properly tracks unique voters

**Option 3: Per-Voter Tracking**
- Maintain a separate set/mapping of unique voter addresses per voting item
- Increment/decrement `VotersCount` based on additions/removals from this set

## Proof of Concept

```csharp
[Fact]
public async Task VotersCount_Inflation_POC()
{
    // Register a voting item
    var votingItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
    var voter = Accounts[1].KeyPair;
    
    // Initial state: VotersCount = 0
    var initialResult = await GetLatestVotingResult(votingItem.VotingItemId);
    initialResult.VotersCount.ShouldBe(0);
    
    // Voter casts 3 votes
    var voteId1 = await Vote(voter, votingItem.VotingItemId, votingItem.Options.First(), 100L);
    var voteId2 = await Vote(voter, votingItem.VotingItemId, votingItem.Options.First(), 100L);
    var voteId3 = await Vote(voter, votingItem.VotingItemId, votingItem.Options.First(), 100L);
    
    // After 3 votes: VotersCount = 3 (not 1!)
    var afterVotesResult = await GetLatestVotingResult(votingItem.VotingItemId);
    afterVotesResult.VotersCount.ShouldBe(3);
    
    // Withdraw first two votes
    await Withdraw(voter, voteId1);
    await Withdraw(voter, voteId2);
    
    // VotersCount still 3 (because voter still has 1 active vote)
    var afterPartialWithdraw = await GetLatestVotingResult(votingItem.VotingItemId);
    afterPartialWithdraw.VotersCount.ShouldBe(3);
    
    // Withdraw last vote
    await Withdraw(voter, voteId3);
    
    // VotersCount = 2 (should be 0!)
    // Net inflation: +3 increments, -1 decrement = +2
    var finalResult = await GetLatestVotingResult(votingItem.VotingItemId);
    finalResult.VotersCount.ShouldBe(2); // VULNERABILITY: Should be 0, but is 2
}
```

## Notes

This vulnerability demonstrates a fundamental accounting inconsistency in the Vote contract. The asymmetric logic between increment (per-transaction) and decrement (per-voter) operations creates permanent state corruption that:

1. Persists across snapshot transitions
2. Is exposed to external consumers via the Election contract
3. Occurs naturally during legitimate user interactions
4. Has no protective mechanisms or validation checks

The issue affects the `VotersCount` field in the `VotingResult` state object, which is intended to track voter participation but instead tracks cumulative vote transactions with improper decrements.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L197-200)
```csharp
        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L209-218)
```csharp
        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L264-271)
```csharp
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L610-624)
```csharp
        var voteUser2 = Accounts[3].KeyPair;
        var votingItem = await RegisterVotingItemAsync(10, 3, true, DefaultSender, 2);

        await Vote(voteUser1, votingItem.VotingItemId, votingItem.Options.First(), 100L);
        await Vote(voteUser1, votingItem.VotingItemId, votingItem.Options.First(), 200L);
        var votingResult = await GetLatestVotingResult(votingItem.VotingItemId);
        votingResult.VotersCount.ShouldBe(2);
        votingResult.VotesAmount.ShouldBe(300L);

        await Vote(voteUser2, votingItem.VotingItemId, votingItem.Options.Last(), 100L);
        await Vote(voteUser2, votingItem.VotingItemId, votingItem.Options.Last(), 200L);
        votingResult = await GetLatestVotingResult(votingItem.VotingItemId);
        votingResult.VotersCount.ShouldBe(4);
        votingResult.VotesAmount.ShouldBe(600L);
    }
```

**File:** test/AElf.Contracts.Vote.Tests/Full/VoteForBestLanguageTests.cs (L87-94)
```csharp
            //user3 vote new option 3 twice
            var transactionResult3 = await Vote(user3.KeyPair, registerItem.VotingItemId, options[2], 100);
            transactionResult3.Status.ShouldBe(TransactionResultStatus.Mined);
            transactionResult3 = await Vote(user3.KeyPair, registerItem.VotingItemId, options[2], 100);
            transactionResult3.Status.ShouldBe(TransactionResultStatus.Mined);

            var votingResult = await GetVotingResult(registerItem.VotingItemId, 2);
            votingResult.VotersCount.ShouldBe(7);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L224-230)
```csharp
    public override Int64Value GetVotersCount(Empty input)
    {
        return new Int64Value
        {
            Value = State.VoteContract.GetLatestVotingResult.Call(State.MinerElectionVotingItemId.Value).VotersCount
        };
    }
```
