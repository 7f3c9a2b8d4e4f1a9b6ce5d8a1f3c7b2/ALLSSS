# Audit Report

## Title
LockTimeMap Entries Not Removed After Withdrawal Causing Storage Bloat and Vote ID Reuse Denial of Service

## Summary
The Election contract's `Vote` method uses `LockTimeMap[voteId] == 0` as an existence check, but the `Withdraw` method never removes entries from this map. This causes permanent denial of service for users who provide custom tokens for deterministic vote ID generation, as they cannot reuse those tokens after withdrawal. Additionally, it causes unbounded storage accumulation.

## Finding Description

The vulnerability exists in the lifecycle management of the `LockTimeMap` state variable in the Election contract.

**Vote Creation Flow**: The `Vote` method generates a vote ID and checks if `LockTimeMap[voteId] == 0` to determine if a vote already exists. If zero (uninitialized), the vote is created and the lock time is stored in the map. [1](#0-0) 

**Vote ID Generation**: When users provide a custom `token` parameter in `VoteMinerInput`, it generates a deterministic vote ID using `Context.GenerateId(Context.Self, voteMinerInput.Token)`. [2](#0-1)  This is documented as an intended feature in the proto definition. [3](#0-2) 

**Vote Withdrawal Flow**: The `Withdraw` method reads from `LockTimeMap` to validate the lock period has expired, but critically never removes the entry. [4](#0-3)  While it removes the `WeightsAlreadyFixedMap` entry, [5](#0-4)  the `LockTimeMap` entry persists indefinitely.

**State Inconsistency**: The underlying Vote contract correctly tracks withdrawn votes by setting `IsWithdrawn = true`, [6](#0-5)  but the Election contract's `LockTimeMap` does not reflect this state change, creating a semantic mismatch.

**Attack Scenario**:
1. User votes with custom token "X" generating deterministic voteId
2. `LockTimeMap[voteId]` is set to the lock duration (e.g., 100 days)
3. After lock period expires, user successfully withdraws
4. `LockTimeMap[voteId]` still contains the lock duration (not removed)
5. User attempts to vote again with same token "X"
6. Same voteId is generated due to deterministic generation
7. Existence check `LockTimeMap[voteId] == 0` fails (value is old lock time)
8. Transaction reverts with "Vote already exists"
9. User permanently blocked from reusing token "X"

## Impact Explanation

**Primary Impact - Denial of Service**: Users who utilize the documented custom token feature for deterministic vote ID generation are permanently prevented from reusing those tokens after withdrawal. This breaks the expected functionality where users should be able to vote again after withdrawing. The custom token feature is explicitly documented with the comment "Used to generate vote id" and tested in the codebase, [7](#0-6)  confirming it as intended functionality for tracking, accounting, or automation purposes.

**Secondary Impact - Storage Bloat**: Every vote creates a permanent `LockTimeMap` entry that is never cleaned up. [8](#0-7)  Over the lifetime of the chain with continuous voting activity, this leads to unbounded storage growth.

**Tertiary Impact - State Integrity**: The contract uses `LockTimeMap` as an existence indicator, but withdrawn votes (which have `IsWithdrawn = true` in the Vote contract) incorrectly appear as "existing" in the Election contract's logic, violating state consistency principles.

## Likelihood Explanation

This issue has **HIGH** likelihood:

**No Special Privileges Required**: The vulnerability affects the public `Vote` and `Withdraw` methods accessible to all users. No governance approval, special roles, or elevated permissions are needed.

**Expected Usage Pattern**: Custom tokens are an explicitly documented feature in the protocol buffer definition with the field comment "Used to generate vote id". The test suite demonstrates this usage, confirming it as intended functionality rather than an edge case.

**Deterministic Occurrence**: Every withdrawal when using custom tokens results in the inability to reuse that token. The issue triggers automatically through normal contract usage without requiring special conditions or timing.

**Detection Difficulty**: Users only discover the problem when attempting to reuse a token post-withdrawal. The storage bloat occurs silently in the background.

## Recommendation

Add cleanup logic to the `Withdraw` method to remove the `LockTimeMap` entry after successful withdrawal:

```csharp
public override Empty Withdraw(Hash input)
{
    // ... existing validation and withdrawal logic ...
    
    // Add cleanup at the end before returning
    State.LockTimeMap.Remove(input);
    
    return new Empty();
}
```

This ensures that:
1. Users can reuse custom tokens after withdrawal
2. Storage does not grow unboundedly
3. The `LockTimeMap` accurately reflects active votes only

## Proof of Concept

```csharp
[Fact]
public async Task Vote_Withdraw_ReVote_WithSameToken_Should_Fail()
{
    // Setup: Announce election and get candidate
    var candidatesKeyPairs = await ElectionContract_AnnounceElection_Test();
    var candidateKeyPair = candidatesKeyPairs[0];
    
    var amount = 100;
    const int lockTime = 100 * 60 * 60 * 24; // 100 days
    var customToken = HashHelper.ComputeFrom("reusable_token");
    
    // Step 1: Vote with custom token
    var voteResult = await ElectionContractStub.Vote.SendAsync(new VoteMinerInput
    {
        CandidatePubkey = candidateKeyPair.PublicKey.ToHex(),
        Amount = amount,
        EndTimestamp = TimestampHelper.GetUtcNow().AddSeconds(lockTime),
        Token = customToken
    });
    voteResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var voteId = voteResult.Output;
    
    // Step 2: Fast forward past lock time and withdraw
    BlockTimeProvider.SetBlockTime(TimestampHelper.GetUtcNow().AddSeconds(lockTime + 1));
    var withdrawResult = await ElectionContractStub.Withdraw.SendAsync(voteId);
    withdrawResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 3: Attempt to vote again with same custom token - THIS SHOULD SUCCEED BUT FAILS
    var reVoteResult = await ElectionContractStub.Vote.SendAsync(new VoteMinerInput
    {
        CandidatePubkey = candidateKeyPair.PublicKey.ToHex(),
        Amount = amount,
        EndTimestamp = TimestampHelper.GetUtcNow().AddSeconds(lockTime),
        Token = customToken // Same token reused
    });
    
    // Vulnerability: Transaction reverts with "Vote already exists"
    // because LockTimeMap entry was never removed during withdrawal
    reVoteResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    reVoteResult.TransactionResult.Error.ShouldContain("Vote already exists");
}
```

## Notes

This vulnerability demonstrates a critical lifecycle management flaw where cleanup operations are incomplete. The Election contract maintains its own state map (`LockTimeMap`) for existence checking but fails to synchronize it with the withdrawal lifecycle tracked by the underlying Vote contract. This creates a permanent denial of service condition for users leveraging the documented custom token feature, which is an intended mechanism for deterministic vote ID generation as evidenced by both the proto documentation and test usage.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L402-412)
```csharp
    private Hash GenerateVoteId(VoteMinerInput voteMinerInput)
    {
        if (voteMinerInput.Token != null)
            return Context.GenerateId(Context.Self, voteMinerInput.Token);

        var candidateVotesCount =
            State.CandidateVotes[voteMinerInput.CandidatePubkey]?.ObtainedActiveVotedVotesAmount ?? 0;
        return Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(voteMinerInput.CandidatePubkey.GetBytes(),
                candidateVotesCount.ToBytes(false)));
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L432-434)
```csharp
        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L629-679)
```csharp
    public override Empty Withdraw(Hash input)
    {
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input);

        var actualLockedTime = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockDays = State.LockTimeMap[input];
        Assert(actualLockedTime >= claimedLockDays,
            $"Still need {claimedLockDays.Sub(actualLockedTime).Div(86400)} days to unlock your token.");

        var voterPublicKey = Context.RecoverPublicKey();

        var voterVotes = GetElectorVote(voterPublicKey);

        Assert(voterVotes != null, $"Voter {Context.Sender.ToBase58()} never votes before");

        voterVotes.ActiveVotingRecordIds.Remove(input);
        voterVotes.WithdrawnVotingRecordIds.Add(input);
        voterVotes.ActiveVotedVotesAmount = voterVotes.ActiveVotedVotesAmount.Sub(votingRecord.Amount);

        State.ElectorVotes[Context.Sender.ToBase58()] = voterVotes;

        // Update Candidate's Votes information.
        var newestPubkey = GetNewestPubkey(votingRecord.Option);
        var candidateVotes = State.CandidateVotes[newestPubkey];

        Assert(candidateVotes != null, $"Newest pubkey {newestPubkey} is invalid. Old pubkey is {votingRecord.Option}");

        candidateVotes.ObtainedActiveVotingRecordIds.Remove(input);
        candidateVotes.ObtainedWithdrawnVotingRecordIds.Add(input);
        candidateVotes.ObtainedActiveVotedVotesAmount =
            candidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[newestPubkey] = candidateVotes;

        UnlockTokensOfVoter(input, votingRecord.Amount);
        RetrieveTokensFromVoter(votingRecord.Amount);
        WithdrawTokensOfVoter(input);
        if (!State.WeightsAlreadyFixedMap[input])
        {
            RemoveBeneficiaryOfVoter();
            State.WeightsAlreadyFixedMap.Remove(input);
        }

        var rankingList = State.DataCentersRankingList.Value;
        if (!rankingList.DataCenters.ContainsKey(newestPubkey)) return new Empty();
        rankingList.DataCenters[newestPubkey] =
            rankingList.DataCenters[newestPubkey].Sub(votingRecord.Amount);
        UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, newestPubkey);
        State.DataCentersRankingList.Value = rankingList;

        return new Empty();
    }
```

**File:** protobuf/election_contract.proto (L297-298)
```text
    // Used to generate vote id.
    aelf.Hash token = 4;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L203-205)
```csharp
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ElectionTests.cs (L247-247)
```csharp
            Token = HashHelper.ComputeFrom("token A")
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L35-38)
```csharp
    /// <summary>
    ///     Vote Id -> Lock Time (seconds)
    /// </summary>
    public MappedState<Hash, long> LockTimeMap { get; set; }
```
