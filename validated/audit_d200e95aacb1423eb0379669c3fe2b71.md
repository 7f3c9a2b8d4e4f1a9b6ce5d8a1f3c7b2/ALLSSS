# Audit Report

## Title
Critical Miner List Manipulation Vulnerability in NextRound Validation Allows Consensus Takeover

## Summary
The `ValidationForNextRound()` function in `RoundTerminateValidationProvider` fails to validate that the miner list in the provided next round matches the current round's miner list. An attacker who is a valid miner in the current round can craft a malicious `NextRound` transaction with an arbitrary set of miners, completely bypassing all validation checks and taking over the consensus mechanism.

## Finding Description

**Root Cause:**

The `ValidationForNextRound()` method performs only two validation checks on the provided next round information: [1](#0-0) 

This validation only ensures: (1) the round number increments by 1, and (2) all InValues are null in the new round. **Critically missing** is any validation that the miner set in `extraData.Round.RealTimeMinersInformation` matches or is derived from `validationContext.BaseRound.RealTimeMinersInformation`.

**Why Other Protections Fail:**

1. **MiningPermissionValidationProvider** only validates that the transaction sender is in the current BaseRound, not whether the provided next round's miner list is valid: [2](#0-1) 

2. **NextRoundMiningOrderValidationProvider** checks internal consistency within the provided round itself, but does not compare the miner list against BaseRound: [3](#0-2) 

For a freshly generated NextRound with all `FinalOrderOfNextRound = 0` and all `OutValue = null`, this check passes as `0 == 0`.

3. **TimeSlotValidationProvider** only validates time slot consistency and mining intervals, not miner list membership: [4](#0-3) 

4. The validation pipeline in `ValidateBeforeExecution` applies these providers for NextRound behavior, but none verify miner list consistency: [5](#0-4) 

5. After validation passes, `ProcessNextRound` directly stores the malicious round without additional miner list checks: [6](#0-5) 

6. The `AddRoundInformation` method simply stores the round in state without any validation: [7](#0-6) 

**Contrast with Legitimate Behavior:**

The legitimate `GenerateNextRoundInformation` method derives the next round's miner list exclusively from the current round's miners: [8](#0-7) 

The legitimate flow ensures miner list continuity. However, an attacker can bypass this by directly submitting a crafted `NextRoundInput` with arbitrary miners via the public `NextRound` method: [9](#0-8) 

The `NextRoundInput.ToRound()` conversion simply transfers all provided fields including the arbitrary miner list: [10](#0-9) 

## Impact Explanation

**Consensus Integrity Breach:**

Once the malicious round is stored and the round number is updated, the arbitrary miner list becomes the active consensus miner list. This results in:

- **Complete consensus takeover**: The attacker can replace all legitimate miners with arbitrary public keys (including non-candidate, non-validated entities)
- **Permanent control**: The malicious miner set can perpetuate itself by controlling all future round transitions
- **Governance bypass**: The election contract and vote mechanisms become irrelevant as consensus is no longer bound to elected candidates
- **Chain integrity compromise**: The attacker controls which entities can produce blocks, enabling censorship, transaction manipulation, and potential collusion attacks

**Quantified Damage:**

- **100% miner displacement**: All legitimate miners can be excluded in a single malicious NextRound transaction
- **Irreversible state corruption**: Once stored in `State.Rounds[roundNumber]`, the malicious round becomes the authoritative source for mining permission validation
- **Total decentralization failure**: The blockchain becomes effectively centralized under attacker control
- **Reward theft**: Legitimate miners lose all block production rewards
- **Voter disenfranchisement**: Token holders who voted for candidates have their governance participation nullified

## Likelihood Explanation

**Attacker Capabilities Required:**

The attacker must only be a valid miner in the current round. This is verified by `MiningPermissionValidationProvider` which checks if the sender is in `BaseRound.RealTimeMinersInformation.Keys`. No special privileges beyond current miner status are needed.

**Attack Complexity:**

**Low complexity**. The attacker crafts a `NextRoundInput` with:
- `RoundNumber = BaseRound.RoundNumber + 1` (passes round number validation)
- `RealTimeMinersInformation` containing arbitrary miners with properly structured `Order` and `ExpectedMiningTime` values (passes time slot validation)
- All `InValue`, `OutValue`, `FinalOrderOfNextRound` fields set to null/0 (passes InValue validation and mining order validation)

The attack requires no cryptographic breaks, race conditions, or complex state manipulation.

**Feasibility Conditions:**

- **Trigger opportunity**: The attacker executes the attack during their designated extra block time slot, which occurs regularly in round-robin fashion
- **Economic barrier**: None - only normal transaction fees required
- **Detection avoidance**: The malicious transaction passes all on-chain validation checks, generating no errors or alerts

**Probability Assessment:**

**High**. Any of the current miners (typically 17-21 on mainnet) can execute this attack. The attack is:
- **Immediately executable** once the attacker's extra block slot arrives
- **Repeatable** in any round where the attacker is a miner
- **Undetectable by contract** - no on-chain protections exist

## Recommendation

Add miner list validation to `ValidationForNextRound()` in `RoundTerminateValidationProvider`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing checks
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };

    // NEW: Validate miner list consistency
    var baseMiners = new HashSet<string>(validationContext.BaseRound.RealTimeMinersInformation.Keys);
    var nextMiners = new HashSet<string>(extraData.Round.RealTimeMinersInformation.Keys);
    
    if (!baseMiners.SetEquals(nextMiners))
        return new ValidationResult { Message = "Next round miner list does not match current round." };

    return new ValidationResult { Success = true };
}
```

This ensures that the miner list in the next round must exactly match the current round's miner list, preventing arbitrary miner injection. For term transitions (NextTerm), the miner list is legitimately updated through a separate, properly validated flow.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMinerListInjection_ConsensusCompromise()
{
    // Setup: Initialize consensus with legitimate miners
    var initialMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusWithMiners(initialMiners);
    
    // Attacker is miner1 (valid current miner)
    var attacker = "miner1";
    SetCurrentSender(attacker);
    
    var currentRound = await GetCurrentRoundInformation();
    
    // Craft malicious NextRoundInput with arbitrary miners (attacker-controlled keys)
    var maliciousMiners = new[] { "attacker_key_1", "attacker_key_2", "attacker_key_3" };
    var maliciousNextRound = CreateNextRoundInput(
        roundNumber: currentRound.RoundNumber + 1,
        minerPubkeys: maliciousMiners,
        allInValuesNull: true,  // Pass InValue validation
        allOutValuesNull: true,  // Pass mining order validation
        allFinalOrdersZero: true  // Pass mining order validation
    );
    
    // Execute attack
    await ConsensusContract.NextRound(maliciousNextRound);
    
    // Verify: Malicious round is stored and active
    var newRound = await GetCurrentRoundInformation();
    Assert.Equal(currentRound.RoundNumber + 1, newRound.RoundNumber);
    
    // VULNERABILITY CONFIRMED: Arbitrary miners now control consensus
    var activeMiners = newRound.RealTimeMinersInformation.Keys.ToList();
    Assert.Contains("attacker_key_1", activeMiners);
    Assert.Contains("attacker_key_2", activeMiners);
    Assert.Contains("attacker_key_3", activeMiners);
    
    // Original legitimate miners are excluded
    Assert.DoesNotContain("miner2", activeMiners);
    Assert.DoesNotContain("miner3", activeMiners);
    
    // Consensus is now permanently compromised
    // Only attacker-controlled keys can produce blocks in subsequent rounds
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L99-124)
```csharp
    /// <summary>
    ///     Will force to generate a `Change` to tx executing result.
    /// </summary>
    /// <param name="round"></param>
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```
