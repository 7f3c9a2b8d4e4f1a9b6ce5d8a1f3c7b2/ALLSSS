# Audit Report

## Title
Missing LIB Validation in NextRound/NextTerm Allows Future Irreversible Block Heights to Persist in Consensus State

## Summary
The AEDPoS consensus contract fails to validate Last Irreversible Block (LIB) fields during `NextRound` and `NextTerm` round transitions. A malicious miner can inject arbitrary future LIB heights, permanently corrupting consensus state and disabling critical block production throttling mechanisms.

## Finding Description

The consensus validation system applies behavior-specific validation providers. The `LibInformationValidationProvider`, which prevents LIB values from moving backwards, is only applied to `UpdateValue` behavior: [1](#0-0) 

For `NextRound` and `NextTerm` behaviors, only `RoundTerminateValidationProvider` is registered, which validates round/term number increments and InValue fields but ignores LIB fields entirely: [2](#0-1) [3](#0-2) 

The `ValidateAfterExecution` round hash comparison cannot detect LIB manipulation because `GetCheckableRound` creates a sanitized Round containing only `RoundNumber`, `TermNumber`, `RealTimeMinersInformation`, and `BlockchainAge` - explicitly excluding the LIB fields: [4](#0-3) 

The `NextRoundInput` and `NextTermInput` protobuf structures include `confirmed_irreversible_block_height` and `confirmed_irreversible_block_round_number` fields: [5](#0-4) [6](#0-5) 

When converting to Round objects, these LIB fields are copied without validation: [7](#0-6) 

The corrupted round is stored directly via `AddRoundInformation` without any LIB recalculation or bounds checking: [8](#0-7) [9](#0-8) 

## Impact Explanation

**Block Production Throttling Bypass**: The `GetMaximumBlocksCount` method retrieves the LIB round number from consensus state to evaluate blockchain health: [10](#0-9) 

The `BlockchainMiningStatusEvaluator` uses this LIB round number to determine if the blockchain is experiencing excessive forking and should throttle block production: [11](#0-10) 

With a corrupted future LIB round number (e.g., `libRoundNumber = 200` when `currentRoundNumber = 101`), the status evaluator incorrectly returns "Normal" status, completely bypassing throttling mechanisms designed to prevent excessive forking during chain instability.

**Permanent State Corruption**: The `ProcessUpdateValue` method only updates LIB if the newly calculated value exceeds the stored value: [12](#0-11) 

A maliciously injected future LIB height (e.g., 1,000,000) will never be exceeded by legitimate calculations, making the corruption permanent. Furthermore, `GenerateNextRoundInformation` copies LIB values forward to each new round: [13](#0-12) 

This propagates the corrupted state across all subsequent rounds indefinitely.

**Consensus Integrity Violation**: The core consensus invariant that LIB height accurately reflects actual blockchain finality is permanently broken, potentially affecting cross-chain operations and other systems that rely on LIB for finality guarantees.

## Likelihood Explanation

**Attacker Prerequisites**:
- Must be an elected validator in the active miner set - achievable through the standard election process
- Must be scheduled to produce a NextRound or NextTerm block - occurs naturally in rotation

**Attack Execution**:
When producing a NextRound/NextTerm block, the miner generates consensus extra data containing legitimate LIB values via `GetConsensusExtraData`. Before submitting the transaction, the attacker simply modifies the `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields in the `NextRoundInput`/`NextTermInput` to arbitrary future values. The modified data passes all validations since LibInformationValidationProvider is not applied, and the round hash excludes LIB fields.

**Frequency**: NextRound blocks occur every round during normal chain operation, providing regular opportunities. NextTerm blocks occur at term boundaries, less frequent but still predictable.

**Detection Difficulty**: The attack produces no validation failures, no events, and no logs. Detection requires manual inspection of on-chain consensus state and comparison with actual blockchain height - essentially invisible to automated monitoring.

## Recommendation

Apply `LibInformationValidationProvider` to `NextRound` and `NextTerm` behaviors by adding it to the validation provider list:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

Additionally, consider including LIB fields in the `GetCheckableRound` hash computation or adding explicit bounds checking in `ProcessNextRound`/`ProcessNextTerm` to validate that LIB values are reasonable (e.g., not exceeding current block height, not moving backwards).

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMinerCanCorruptLIBInNextRound()
{
    // Setup: Initialize consensus with legitimate miners
    await InitializeConsensusContract();
    var maliciousMiner = ValidMiners[0];
    
    // Get current round info
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var currentHeight = BlockHeight;
    
    // Attacker generates legitimate NextRoundInput
    var nextRoundInput = GenerateNextRoundInput(currentRound);
    
    // ATTACK: Modify LIB fields to future values
    nextRoundInput.ConfirmedIrreversibleBlockHeight = 1000000; // Far future
    nextRoundInput.ConfirmedIrreversibleBlockRoundNumber = 200; // When current is ~10
    
    // Submit malicious NextRound transaction - should fail but doesn't
    var result = await ConsensusStub.NextRound.SendAsync(nextRoundInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Passes!
    
    // Verify corruption persists
    var corruptedRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    corruptedRound.ConfirmedIrreversibleBlockHeight.ShouldBe(1000000); // Corrupted
    corruptedRound.ConfirmedIrreversibleBlockRoundNumber.ShouldBe(200); // Corrupted
    
    // Verify throttling bypass
    var maxBlocks = await ConsensusStub.GetMaximumBlocksCount.CallAsync(new Empty());
    maxBlocks.Value.ShouldBe(MaximumTinyBlocksCount); // Should be throttled but isn't
    
    // Verify persistence across multiple rounds
    await ProduceNextRound();
    var nextRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    nextRound.ConfirmedIrreversibleBlockHeight.ShouldBe(1000000); // Still corrupted!
}
```

## Notes

This vulnerability exploits a fundamental gap in the consensus validation architecture where different validation rules apply based on behavior type, but the LIB validation was only implemented for `UpdateValue` while being omitted for round transition behaviors. The attack is particularly insidious because it produces no observable errors while permanently corrupting a critical consensus invariant, and the corruption mechanism (only updating LIB when new > old) inadvertently creates a one-way door that prevents self-correction.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L199-206)
```csharp
        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
```

**File:** protobuf/aedpos_contract.proto (L471-474)
```text
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
```

**File:** protobuf/aedpos_contract.proto (L497-500)
```text
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-26)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L106-129)
```csharp
        public BlockchainMiningStatusEvaluator(long currentConfirmedIrreversibleBlockRoundNumber,
            long currentRoundNumber, int maximumTinyBlocksCount)
        {
            _libRoundNumber = currentConfirmedIrreversibleBlockRoundNumber;
            _currentRoundNumber = currentRoundNumber;
            _maximumTinyBlocksCount = maximumTinyBlocksCount;
        }

        /// <summary>
        ///     Stands for CB1
        /// </summary>
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```
