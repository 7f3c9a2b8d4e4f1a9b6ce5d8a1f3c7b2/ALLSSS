# Audit Report

## Title
Front-Running Attack on ProposeNewContract Enables Contract Deployment Denial-of-Service

## Summary
An attacker can front-run legitimate contract deployment proposals by predicting the `proposedContractInputHash` and submitting an identical proposal first, causing the legitimate deployer's transaction to revert for up to 72 hours. The vulnerability arises from: (1) commented-out authorization checks allowing anyone to propose contracts, (2) deterministic hash computation from public parameters, (3) duplicate prevention logic that blocks subsequent identical proposals, and (4) proposer-locked release rights that give exclusive control to the first proposer.

## Finding Description

The Genesis Contract (BasicContractZero) implements a governance workflow for deploying smart contracts through proposals. This workflow contains a critical front-running vulnerability affecting deployments that don't use the optional `ContractOperation` signature mechanism.

**Vulnerable Workflow:**

When `ProposeNewContract()` is called [1](#0-0) , the authorization check is commented out, allowing any address to submit proposals. The function computes a deterministic hash from the `ContractDeploymentInput` (category, bytecode, and optional ContractOperation) [2](#0-1) .

The `RegisterContractProposingData()` function stores this proposal in state [3](#0-2) , but it enforces a critical constraint: it reverts with "Already proposed." if an unexpired proposal with the same hash already exists. This prevents duplicate proposals but doesn't verify the caller's legitimacy.

The release mechanism further compounds the issue by restricting `ReleaseApprovedContract()` to only the original proposer [4](#0-3) . Even if the deployment controller approves the proposal, only the first proposer can execute the release.

The default expiration period is 259,200 seconds (72 hours) [5](#0-4) , creating a substantial DoS window.

**Attack Execution:**

1. Attacker monitors mempool or predicts public contract deployments (e.g., standard token implementations, protocol upgrades)
2. Attacker front-runs by calling `ProposeNewContract()` with identical `ContractDeploymentInput` (same category and bytecode)
3. Attacker's proposal is registered with `Proposer = Attacker`, `Status = PROPOSED`, `ExpiredTime = now + 72 hours`
4. Legitimate deployer's subsequent identical transaction reverts at the duplicate check
5. Only the attacker can call `ReleaseApprovedContract()` due to the proposer lock
6. If the attacker abandons the proposal, deployment is blocked for the full 72-hour expiration period

**Mitigation Exists But Not Enforced:**

The `ContractOperation` field in `ContractDeploymentInput` [6](#0-5)  provides signature-based protection when used. The validation logic [7](#0-6)  ensures only the holder of the deployer's private key can provide valid signatures, making each deployment unique to the legitimate deployer. However, this mechanism is **optional** and not enforced by the protocol, leaving deployers who don't use it vulnerable to griefing attacks.

## Impact Explanation

**Primary Impact:** 72-hour operational DoS on contract deployment for each attack iteration.

**Affected Parties:**
- Deployers of public/standard contracts without `ContractOperation` signatures
- Protocol teams with predictable upgrade schedules
- Open-source projects where bytecode is publicly available

**Business Disruption:** This vulnerability enables competitors to delay protocol launches, governance upgrades, or critical contract deployments at minimal cost (only gas fees). While it doesn't result in direct fund theft or supply manipulation, it can cause:
- Delayed product launches with associated revenue loss
- Missed time-sensitive governance decisions
- Disrupted cross-chain operations requiring coordinated deployments
- Reputational damage from failed deployment attempts

**Severity Assessment:** Medium severity is appropriate because:
- No direct financial loss or fund theft (excludes High/Critical)
- Significant operational availability impact (excludes Low/Informational)
- Low attack complexity and economically feasible for griefing
- Affects real-world use cases with legitimate deployers

## Likelihood Explanation

**Attack Feasibility:** High for public contracts without `ContractOperation`, Low for deployments using signature protection.

**Attacker Requirements:**
- Front-running capability (standard MEV technique on any blockchain)
- Knowledge of target bytecode (available for standard implementations, public protocols, or through mempool monitoring)
- Gas fees for proposal submission (economically trivial cost)

**Attack Complexity:** Low
- Single transaction execution
- No sophisticated state manipulation required  
- Deterministic hash makes prediction trivial for known bytecode
- No coordination or multi-step setup needed

**Economic Rationality:** The attack is economically viable for:
- Competitors delaying rival protocol launches
- Griefing attacks against specific deployers
- Ransom scenarios (pay attacker to withdraw proposal, though this requires additional coordination)

**Detection/Prevention Constraints:**
- No on-chain mechanism to cancel malicious proposals before expiration
- Legitimate deployer cannot override or reclaim the proposal
- Must wait full 72-hour period or modify deployment parameters (changing bytecode may not be feasible for standard contracts)

## Recommendation

**Immediate Fix:** Uncomment and enforce the authorization check in `ProposeNewContract()` to restrict proposal submission to authorized addresses only, similar to how `ProposeUpdateContract()` enforces author verification.

**Long-term Solutions:**

1. **Enforce ContractOperation:** Make the `ContractOperation` field mandatory for all contract deployments, ensuring signature-based uniqueness prevents front-running.

2. **Add Proposal Cancellation:** Implement a mechanism for the deployment controller to cancel proposals that appear malicious or abandoned before their expiration.

3. **Shorten Expiration Period:** Reduce the default 72-hour expiration to a more reasonable timeframe (e.g., 24 hours) to minimize DoS duration.

4. **Proposer Reputation:** Track and penalize addresses that submit proposals but never release them, discouraging griefing behavior.

**Code Fix Example:**
```csharp
public override Hash ProposeNewContract(ContractDeploymentInput input)
{
    AssertDeploymentProposerAuthority(Context.Sender); // Uncomment this line
    // ... rest of function
}
```

Or enforce ContractOperation:
```csharp
public override Hash ProposeNewContract(ContractDeploymentInput input)
{
    Assert(input.ContractOperation != null, "ContractOperation required to prevent front-running.");
    ValidateContractOperation(input.ContractOperation, 0, HashHelper.ComputeFrom(input.Code.ToByteArray()));
    // ... rest of function
}
```

## Proof of Concept

```csharp
[Fact]
public async Task FrontRunning_ProposeNewContract_CausesDoS()
{
    // Setup: Standard token bytecode (publicly known)
    var standardTokenCode = LoadStandardTokenBytecode();
    var deploymentInput = new ContractDeploymentInput
    {
        Category = 0,
        Code = ByteString.CopyFrom(standardTokenCode)
        // No ContractOperation - vulnerable to front-running
    };
    
    // Step 1: Attacker front-runs and proposes first
    var attackerAddress = SampleAddress.AddressList[0];
    var attackerStub = GetGenesisContractStub(attackerAddress);
    var attackerProposalHash = await attackerStub.ProposeNewContract.SendAsync(deploymentInput);
    attackerProposalHash.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 2: Legitimate deployer tries to propose identical contract
    var legitimateDeployerAddress = SampleAddress.AddressList[1];
    var legitimateStub = GetGenesisContractStub(legitimateDeployerAddress);
    var result = await legitimateStub.ProposeNewContract.SendWithExceptionAsync(deploymentInput);
    
    // Verify: Legitimate deployer is blocked with "Already proposed."
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Already proposed.");
    
    // Step 3: Verify legitimate deployer cannot release even if approved
    var proposalHash = attackerProposalHash.Output;
    
    // Simulate approval by deployment controller (would happen through governance)
    // ... approval logic ...
    
    var releaseInput = new ReleaseContractInput
    {
        ProposedContractInputHash = proposalHash,
        ProposalId = Hash.Empty // Would be set by governance
    };
    
    var releaseResult = await legitimateStub.ReleaseApprovedContract.SendWithExceptionAsync(releaseInput);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Invalid contract proposing status.");
    
    // Step 4: Verify DoS persists for 72 hours
    var proposalInfo = await attackerStub.GetContractProposingInput.CallAsync(proposalHash);
    var dosDuration = proposalInfo.ExpiredTime.Seconds - BlockTimeProvider.GetBlockTime().Seconds;
    dosDuration.ShouldBe(259200); // 72 hours in seconds
}
```

---

**Notes:**
- This vulnerability is confirmed through direct code analysis of the Genesis Contract implementation
- The optional `ContractOperation` mitigation exists but is not enforced, leaving uninformed deployers vulnerable
- The attack requires no special privileges beyond standard front-running capabilities available to any blockchain participant
- The 72-hour DoS window represents significant operational disruption for time-sensitive deployments

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L122-128)
```csharp
    public override Hash ProposeNewContract(ContractDeploymentInput input)
    {
        // AssertDeploymentProposerAuthority(Context.Sender);
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L277-283)
```csharp
    public override Empty ReleaseApprovedContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];
        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.Proposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L175-178)
```csharp
    private Hash CalculateHashFromInput(IMessage input)
    {
        return HashHelper.ComputeFrom(input);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L395-413)
```csharp
    private void ValidateContractOperation(ContractOperation contractOperation, int currentVersion, Hash codeHash)
    {
        Assert(contractOperation.Deployer != null && !contractOperation.Deployer.Value.IsNullOrEmpty(),
            "Invalid input deploying address.");
        Assert(contractOperation.Salt != null && !contractOperation.Salt.Value.IsNullOrEmpty(), "Invalid input salt.");
        Assert(contractOperation.CodeHash != null && !contractOperation.CodeHash.Value.IsNullOrEmpty(),
            "Invalid input code hash.");
        Assert(!contractOperation.Signature.IsNullOrEmpty(), "Invalid input signature.");

        Assert(contractOperation.Version == currentVersion + 1, "Invalid input version.");
        Assert(contractOperation.ChainId == Context.ChainId, "Invalid input chain id.");
        Assert(contractOperation.CodeHash == codeHash, "Invalid input code hash.");

        var recoveredAddress = RecoverAddressFromSignature(contractOperation);

        Assert(
            recoveredAddress == contractOperation.Deployer ||
            State.SignerMap[contractOperation.Deployer] == recoveredAddress, "Invalid signature.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-5)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
```

**File:** protobuf/acs0.proto (L156-162)
```text
message ContractDeploymentInput {
    // The category of contract code(0: C#).
    sint32 category = 1;
    // The byte array of the contract code.
    bytes code = 2;
    ContractOperation contract_operation = 3;
}
```
