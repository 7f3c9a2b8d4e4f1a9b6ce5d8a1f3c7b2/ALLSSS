# Audit Report

## Title
Race Condition in TokenHolder RemoveBeneficiary Causing DoS via ClaimProfits Front-Running

## Summary
The `RemoveBeneficiary` function in TokenHolderContract unconditionally calls `.Single()` on the beneficiary's profit details list without checking if the list is empty or contains multiple elements. A beneficiary can front-run the manager's RemoveBeneficiary transaction by calling ClaimProfits, which removes expired profit details and may leave an empty list, causing RemoveBeneficiary to revert with an `InvalidOperationException` and permanently blocking the administrative removal action.

## Finding Description

The vulnerability exists in the TokenHolderContract's `RemoveBeneficiary` function where it unconditionally calls `.Single()` on the profit details list retrieved from the ProfitContract. [1](#0-0) 

The LINQ `.Single()` method throws an `InvalidOperationException` when the collection is empty ("Sequence contains no elements") or contains more than one element ("Sequence contains more than one element").

The race condition occurs because the ProfitContract's `ClaimProfits` function actively removes expired profit details from state. When ClaimProfits identifies expired details where `LastProfitPeriod > EndPeriod`, [2](#0-1)  it removes them from the available details list [3](#0-2)  and updates the state with the remaining details, which can be an empty list. [4](#0-3) 

**Attack Execution Path:**
1. A beneficiary exists with profit details where all periods have been claimed (`LastProfitPeriod > EndPeriod`)
2. Scheme manager submits `RemoveBeneficiary` transaction to the mempool
3. Beneficiary monitors the mempool and front-runs with a `ClaimProfits` transaction with higher gas
4. `ClaimProfits` executes first, removing all expired details and setting the Details list to empty
5. `RemoveBeneficiary` then executes and retrieves the empty Details list via `GetProfitDetails` [5](#0-4) 
6. The `.Single()` call throws `InvalidOperationException: Sequence contains no elements`
7. The RemoveBeneficiary transaction reverts

Notably, the same codebase shows awareness of this pattern - the `AddBeneficiary` function properly checks `if (detail.Details.Any())` before calling `.Single()`, [6](#0-5)  but this defensive check is missing in `RemoveBeneficiary`.

Additionally, the ProfitContract's AddBeneficiary function demonstrates that multiple details can legitimately exist in the system, [7](#0-6)  which would also cause `.Single()` to throw an exception.

## Impact Explanation

**Operational Denial of Service:**
- The scheme manager loses the ability to remove beneficiaries through the TokenHolder contract's administrative functions
- Schemes cannot perform proper beneficiary lifecycle management or clean up inactive entries
- The beneficiary remains in the `ProfitDetailsMap` state (though with empty details and no effective voting shares)
- Multiple failed transaction attempts waste gas for legitimate administrative operations
- Accumulation of stale beneficiary entries degrades scheme state hygiene

**Affected Parties:**
- Scheme managers requiring legitimate beneficiary removal for administrative reasons
- TokenHolder schemes that depend on proper beneficiary lifecycle management
- Protocol governance needing clean scheme state maintenance

**Severity Assessment - Medium:**
This vulnerability creates a reliable DoS vector for an important administrative function. While it does not result in direct fund theft or loss (the beneficiary with empty details has no effective shares), it prevents proper scheme management and administrative control. The impact is operational rather than financial - the protocol's financial integrity remains intact, but administrative functionality is compromised.

## Likelihood Explanation

**Attack Feasibility:**
- **Attacker Capabilities:** Requires only mempool monitoring (standard for any blockchain) and ability to submit transactions with higher gas priority
- **Required Privileges:** Must be a registered beneficiary with expired profit details (`LastProfitPeriod > EndPeriod`)
- **Attack Complexity:** Low - requires only calling the public `ClaimProfits` function, a standard front-running technique

**Precondition Naturalness:**
- Profit details naturally expire in normal protocol operation when all periods are claimed
- Common scenario in long-running schemes where beneficiaries have participated across multiple periods
- `ClaimProfits` is a legitimate operation that beneficiaries regularly perform, making the attack indistinguishable from normal behavior

**Economic Rationality:**
- Attack cost is minimal: only the gas cost for one `ClaimProfits` transaction
- No economic penalty or downside for the attacker
- May be executed defensively when a beneficiary anticipates or detects an imminent removal attempt

**Detection and Prevention:**
- Difficult to detect: `ClaimProfits` is legitimate user behavior
- No transaction ordering guarantees exist to prevent front-running
- Cannot be mitigated without modifying the contract logic

**Probability Assessment - High:**
The combination of low attack cost, simple execution via public methods, naturally occurring preconditions, and the legitimate appearance of attack transactions makes this vulnerability highly exploitable in production environments.

## Recommendation

Add a defensive check before calling `.Single()` in the `RemoveBeneficiary` function, similar to the pattern already used in `AddBeneficiary`:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);

    var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
    {
        Beneficiary = input.Beneficiary,
        SchemeId = scheme.SchemeId
    });
    
    // Add defensive check
    if (profitDetails == null || !profitDetails.Details.Any())
    {
        // Beneficiary already has no details, removal is effectively complete
        return new Empty();
    }
    
    var detail = profitDetails.Details.Single();
    var lockedAmount = detail.Shares;
    
    State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = input.Beneficiary
    });
    
    if (lockedAmount > input.Amount && input.Amount != 0)
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = lockedAmount.Sub(input.Amount)
            }
        });

    return new Empty();
}
```

Alternatively, if multiple details are expected, use `.FirstOrDefault()` or iterate through all details appropriately.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveBeneficiary_FrontRunWithClaimProfits_CausesDoS()
{
    // Setup: Create scheme and add beneficiary
    var schemeManager = Accounts[0].Address;
    var beneficiary = Accounts[1].Address;
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });
    
    // Add beneficiary with shares
    await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = beneficiary,
        Shares = 100
    });
    
    // Distribute profits and advance periods so details expire
    // (Simulate natural expiration where LastProfitPeriod > EndPeriod)
    var scheme = await TokenHolderContractStub.GetScheme.CallAsync(schemeManager);
    
    // Beneficiary claims profits, causing all expired details to be removed
    await TokenHolderContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeManager = schemeManager,
        Beneficiary = beneficiary
    });
    
    // Manager attempts to remove beneficiary - this should fail with InvalidOperationException
    var removeResult = await TokenHolderContractStub.RemoveBeneficiary.SendWithExceptionAsync(
        new RemoveTokenHolderBeneficiaryInput
        {
            Beneficiary = beneficiary,
            Amount = 0
        });
    
    // Assert that the transaction reverted due to .Single() on empty collection
    removeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    removeResult.TransactionResult.Error.ShouldContain("Sequence contains no elements");
}
```

## Notes

The vulnerability demonstrates a classic TOCTOU (Time-of-Check-Time-of-Use) race condition where the state checked by `GetProfitDetails` can change between the view call and the subsequent `RemoveBeneficiary` execution. The defensive pattern already exists in `AddBeneficiary`, confirming that the developers were aware of this potential issue but failed to apply it consistently across the codebase.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L46-55)
```csharp
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L74-78)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L200-201)
```csharp
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-789)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L801-804)
```csharp
        foreach (var profitDetail in profitDetailsToRemove)
        {
            availableDetails.Remove(profitDetail);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L806-806)
```csharp
        State.ProfitDetailsMap[input.SchemeId][beneficiary] = new ProfitDetails { Details = { availableDetails } };
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L46-49)
```csharp
    public override ProfitDetails GetProfitDetails(GetProfitDetailsInput input)
    {
        return State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];
    }
```
