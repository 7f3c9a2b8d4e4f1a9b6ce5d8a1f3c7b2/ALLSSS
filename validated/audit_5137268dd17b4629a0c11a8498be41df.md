# Audit Report

## Title
State Inconsistency Between Consensus and Election Contracts Causes Incorrect Miner Selection During Term Transitions

## Summary
A state synchronization bug in the AEDPoS consensus contract causes the Election contract to select the wrong number of miners during term transitions. When `SetMinerIncreaseInterval()` is called to decrease the miner increase interval, it updates the consensus contract's calculation parameters but fails to synchronize this change with the Election contract's stored `MinersCount` value. During the next term transition, `GetVictories()` uses the stale `MinersCount` value to select miners, resulting in an incorrect miner set that persists for the entire term duration.

## Finding Description

The vulnerability stems from inconsistent state synchronization between the Consensus and Election contracts during miner count parameter updates.

**Root Cause - Missing Synchronization:**

The `SetMinerIncreaseInterval()` method updates `State.MinerIncreaseInterval.Value` without calling `UpdateMinersCount()` on the Election contract [1](#0-0) . This contrasts with `SetMaximumMinersCount()`, which properly synchronizes by calling `State.ElectionContract.UpdateMinersCount.Send()` [2](#0-1) .

The consensus contract's `GetMinersCount()` calculates the effective miner count using a formula that incorporates `MinerIncreaseInterval` [3](#0-2) . When the interval is decreased, this calculation immediately returns a higher miner count, but the Election contract remains unaware of this change.

**Exploitation Path:**

During term transitions, the consensus contract generates the first round of the new term by calling `GenerateFirstRoundOfNextTerm()` [4](#0-3) , which invokes `TryToGetVictories()` [5](#0-4)  to retrieve the elected miners from the Election contract.

The Election contract's `GetVictories()` method relies on its stored `State.MinersCount.Value` to determine how many candidates to select [6](#0-5) . Since `SetMinerIncreaseInterval()` did not update this value, `GetVictories()` selects miners based on the outdated count.

**Critical Timing Issue:**

The miner list is determined during block production (when generating consensus extra data) BEFORE the `NextTerm` transaction executes. Only after the term has started with the incorrect miner set does `ProcessNextTerm()` call `UpdateMinersCountToElectionContract()` [7](#0-6) , which synchronizes the Election contract's `MinersCount` [8](#0-7) . By this point, the damage is done - the term is already running with the wrong miners.

The Election contract's `UpdateMinersCount()` can only be called by the Consensus contract [9](#0-8) , confirming this is the proper synchronization channel that `SetMinerIncreaseInterval()` fails to use.

## Impact Explanation

**Consensus Integrity Violation:**
- The term begins with an incorrect number of miners (e.g., if the interval is halved, the calculation might return 11 miners but GetVictories selects only 7)
- Top-voted candidates who should be mining are completely excluded from the term
- These excluded candidates lose all mining opportunities and block rewards for the entire term duration
- Voters who staked tokens for excluded candidates receive no mining reward distributions

**Network Security Impact:**
- Reduced miner diversity weakens consensus security
- Fewer active miners increase centralization risk
- The decentralization guarantee of the AEDPoS consensus mechanism is compromised

**Duration and Persistence:**
- The issue persists for the full term duration (potentially multiple days to weeks depending on the configured `PeriodSeconds`)
- Cannot self-correct until the next term transition occurs
- Each subsequent term transition after the initial `SetMinerIncreaseInterval()` call will correctly synchronize, but the damage from the first transition is permanent for that term

**Severity Justification (Medium):**
This violates critical consensus invariants requiring miner schedule integrity and causes invalid state in the election system. While it requires governance action (not an arbitrary attacker), the unintended consequences affect protocol correctness and economic fairness.

## Likelihood Explanation

**Trigger Mechanism:**
- Requires governance authority via the `MaximumMinersCountController` (typically Parliament)
- NOT a malicious attack - occurs through legitimate governance operations
- The governance change itself (decreasing `MinerIncreaseInterval` to allow faster miner growth) is a realistic protocol evolution action

**Feasibility:**
- Low complexity: Single governance proposal execution followed by natural term transition
- No special timing manipulation needed - the vulnerability triggers automatically at the next term boundary
- The validation in `SetMinerIncreaseInterval()` only allows decreasing the interval, making the scenario realistic [1](#0-0) 

**Probability Assessment (Medium):**
While miner parameter changes are infrequent, they are realistic for protocol maturation. Governance might legitimately want to accelerate miner growth to increase decentralization, and this change would naturally be implemented via `SetMinerIncreaseInterval()`. The vulnerability automatically triggers at the next term transition without any further action required.

## Recommendation

Add state synchronization to `SetMinerIncreaseInterval()` to match the behavior of `SetMaximumMinersCount()`:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    
    State.MinerIncreaseInterval.Value = input.Value;
    
    // ADD THIS SYNCHRONIZATION:
    TryToGetCurrentRoundInformation(out var round);
    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
    {
        MinersCount = GetMinersCount(round)
    });
    
    return new Empty();
}
```

This ensures the Election contract's `MinersCount` is immediately synchronized whenever the interval changes, preventing the state inconsistency that causes incorrect miner selection.

## Proof of Concept

A complete proof-of-concept test would:

1. Initialize consensus and election contracts with synchronized state
2. Advance blockchain time to establish a baseline miner count
3. Call `SetMinerIncreaseInterval()` with a decreased value through governance
4. Query both contracts to verify the state inconsistency:
   - Consensus contract's `GetMinersCount()` returns the new calculated value
   - Election contract's `GetMinersCount()` still returns the old value
5. Trigger a term transition
6. Verify that `GetVictories()` selected miners based on the old count
7. Confirm the term started with the wrong number of miners
8. Verify `UpdateMinersCount()` was called too late (after term started)

The test would demonstrate that the miner count discrepancy persists from step 3 through step 6, proving that `GetVictories()` operates on stale data during the critical miner selection phase of term transitions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```
