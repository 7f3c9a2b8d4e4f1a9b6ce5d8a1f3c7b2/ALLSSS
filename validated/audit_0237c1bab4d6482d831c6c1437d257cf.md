# Audit Report

## Title
Protocol Impersonation via Unvalidated Cross-Chain Token Creation in NFT Contract

## Summary
The NFT contract's `CrossChainCreate` function retrieves token information from local MultiToken contract state without performing cross-chain verification, unlike the properly secured `CrossChainCreateToken` method. An attacker can create a malicious token on mainchain, sync it via legitimate cross-chain mechanisms, then call `CrossChainCreate` to gain complete control over an NFT protocol on sidechains, including exclusive minting rights and creator privileges.

## Finding Description

The vulnerability exists in the NFT contract's `CrossChainCreate` method, which is intended to synchronize NFT protocols from mainchain to sidechains.

**Root Cause:**

The function retrieves token information by directly calling the local MultiToken contract's `GetTokenInfo` method without any cross-chain verification: [1](#0-0) 

It unconditionally trusts the `tokenInfo.Issuer` field as the NFT protocol Creator: [2](#0-1) 

This Creator is immediately set as the sole minter for the NFT protocol: [3](#0-2) 

**Why Existing Protections Fail:**

The function only checks that the NFT protocol doesn't already exist locally, not whether it was legitimately created on mainchain: [4](#0-3) 

Unlike the MultiToken contract's `CrossChainCreateToken` method which requires transaction bytes and merkle path verification, the NFT's `CrossChainCreate` performs no cryptographic verification. The proper cross-chain flow in MultiToken includes calling `CrossChainVerify` to cryptographically validate that the transaction occurred on the source chain: [5](#0-4) 

The verification method validates merkle paths to ensure cross-chain integrity: [6](#0-5) 

The NFT contract's `Create` method correctly restricts creation to mainchain only: [7](#0-6) 

However, `CrossChainCreate` bypasses this by not validating the token origin.

When creating tokens via MultiToken, arbitrary ExternalInfo metadata can be set without validation of its contents: [8](#0-7) 

The required NFT metadata keys are publicly visible constants: [9](#0-8) 

## Impact Explanation

**Direct Authority Takeover:**

The Creator role grants exclusive rights to add and remove minters from the NFT protocol: [10](#0-9) [11](#0-10) 

**Minting Control:**

The attacker becomes the sole minter and can mint NFTs without restriction. Only addresses in the minter list have permission to mint: [12](#0-11) 

**Concrete Harm:**
- **Protocol Impersonation**: An attacker can create NFT protocols on sidechains that impersonate legitimate brands or projects
- **Economic Fraud**: Minted NFTs appear as legitimate protocol NFTs, potentially defrauding users who purchase or trade them
- **Irreversible Control**: No mechanism exists for legitimate creators to reclaim control once the malicious protocol is created
- **Race Condition Exploitation**: Attackers can front-run legitimate protocol deployments to sidechains

**Affected Parties:**
- Users who trust and purchase NFTs from the fake protocol
- Legitimate protocol creators who lose the ability to deploy to that sidechain
- Ecosystem reputation and trust

## Likelihood Explanation

**Attacker Capabilities Required:**

1. Ability to create a token on mainchain - requires Seed NFT or being whitelisted, which is publicly accessible through market mechanisms: [13](#0-12) 

2. Knowledge of required NFT metadata keys, which are publicly visible constants (as shown above)

3. Ability to execute `CrossChainCreateToken` with valid merkle proofs (standard cross-chain operation, publicly documented)

4. Ability to call the public `CrossChainCreate` function on sidechain

**Attack Complexity:** Low to Medium
- All required steps use public interfaces
- No special privileges needed beyond initial token creation capability
- Merkle proof generation is standard cross-chain functionality

**Feasibility Conditions:**
- NFT type must be registered via governance (but common types like "Art", "Game" etc. are likely pre-registered)
- Target protocol symbol must not already exist on sidechain
- All conditions are easily met for new protocols or race conditions

**Economic Rationality:**
- Cost: Minimal (seed NFT purchase + transaction fees)
- Potential gain: Unlimited through fraudulent NFT sales
- Risk/Reward ratio strongly favors the attacker

## Recommendation

The `CrossChainCreate` method should be redesigned to require and validate cross-chain proof, similar to `CrossChainCreateToken`. The fix should:

1. Modify the `CrossChainCreateInput` message to include `TransactionBytes`, `ParentChainHeight`, `FromChainId`, and `MerklePath` fields
2. Parse the original transaction and verify it's a legitimate NFT protocol `Create` call from mainchain
3. Call `CrossChainVerify` to cryptographically validate the merkle path
4. Only after verification succeeds, proceed with creating the NFT protocol using the validated data

Example fix pattern (following MultiToken's approach):
```
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    // Parse and validate the original transaction
    var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);
    AssertCrossChainTransaction(originalTransaction, nftContractAddress, nameof(Create));
    
    // Verify merkle path
    var originalTransactionId = originalTransaction.GetHash();
    CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
    
    // Parse the validated Create input
    var createInput = CreateInput.Parser.ParseFrom(originalTransaction.Params);
    
    // Proceed with creation using validated data
    // ... rest of the logic
}
```

## Proof of Concept

The vulnerability can be demonstrated through the following attack sequence:

1. **On Mainchain**: Attacker creates a token with NFT metadata:
   - Call `MultiToken.Create` with `ExternalInfo` containing `aelf_nft_type`, `aelf_nft_base_uri`, `aelf_nft_token_id_reuse`
   - Set `Issuer` to attacker's address
   
2. **Cross-chain sync**: Use legitimate `CrossChainCreateToken` to sync the token to sidechain with valid merkle proofs

3. **On Sidechain**: Call `NFT.CrossChainCreate` with just the symbol
   - No verification occurs
   - Attacker becomes Creator and sole minter
   - Can now mint unlimited NFTs

The test would verify that:
- The attacker-controlled address becomes the Creator
- The attacker is set as the sole minter
- The attacker can successfully mint NFTs
- No legitimate Creator from mainchain can reclaim control

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L16-17)
```csharp
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L79-79)
```csharp
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L80-83)
```csharp
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L100-100)
```csharp
            Creator = tokenInfo.Issuer,
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L110-113)
```csharp
        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L484-488)
```csharp
        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L7-9)
```csharp
    private const string NftTypeMetadataKey = "aelf_nft_type";
    private const string NftBaseUriMetadataKey = "aelf_nft_base_uri";
    private const string NftTokenIdReuseMetadataKey = "aelf_nft_token_id_reuse";
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-338)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L355-358)
```csharp
    public override Empty RemoveMinters(RemoveMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-399)
```csharp
        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
```
