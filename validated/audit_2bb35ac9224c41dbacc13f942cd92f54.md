# Audit Report

## Title
Byzantine Miner Can Replay Another Miner's OutValue/Signature Due to Missing Cryptographic Binding Validation

## Summary
The AEDPoS consensus validation mechanism fails to cryptographically verify that a miner's submitted `OutValue` and `Signature` values were actually computed by that specific miner. The validation only checks that these fields are non-null and non-empty, allowing a Byzantine miner to copy another miner's consensus data and bypass all validation checks, compromising consensus randomness and ordering guarantees.

## Finding Description

The vulnerability exists in the consensus validation flow for UpdateValue operations during block production. When a miner produces a block, they include consensus extra data containing their `OutValue` and `Signature` values. These values should be unique to each miner and cryptographically derived from their private `InValue`. However, the validation does not enforce this cryptographic binding.

**Root Cause - Insufficient Validation:**

The `NewConsensusInformationFilled()` method only verifies existence, not authenticity: [1](#0-0) 

This validation does NOT verify:
1. Whether `OutValue` was derived from THIS miner's `InValue` 
2. Whether `Signature` is cryptographically bound to THIS miner's secret
3. Whether these values are unique across miners

**Missing InValue Submission:**

The `UpdateValueInput` structure does not include the current round's `InValue`, only `PreviousInValue`: [2](#0-1) 

Without the current `InValue`, there is no way to verify that `OutValue = Hash(InValue)` or that the `InValue` was generated by this specific miner.

**Direct Assignment Without Verification:**

The `ProcessUpdateValue` function directly assigns the submitted values without cryptographic verification: [3](#0-2) 

**Block-Level Protections Are Insufficient:**

While the system validates that `SenderPubkey` matches the block's `SignerPubkey`: [4](#0-3) 

This only proves the miner signed the block and claims to be themselves. It does NOT prove that the `OutValue`/`Signature` in the consensus data belong to that miner.

**Attack Execution:**

1. Byzantine miner M1 observes honest miner M2's block containing M2's consensus data
2. M1 extracts M2's `OutValue` and `Signature` from the publicly available block header
3. When M1's mining turn arrives, M1 constructs a block with:
   - `SignerPubkey = M1` (M1 signs the block with their private key)
   - `SenderPubkey = M1` (required to match SignerPubkey)
   - `Round[M1].OutValue = M2's copied OutValue`
   - `Round[M1].Signature = M2's copied Signature`
4. The validation checks pass because:
   - Block signature is valid (M1 signed it) ✓
   - `SenderPubkey == SignerPubkey` ✓
   - M1 is in authorized miner list ✓
   - `OutValue` and `Signature` are non-null/non-empty ✓
   - No check exists to verify these values are M1-specific ✗

**Impact on Consensus Ordering:**

The `SupposedOrderOfNextRound` is calculated directly from the signature: [5](#0-4) 

When M1 copies M2's signature, both miners receive the same supposed order, violating the consensus randomness guarantee.

## Impact Explanation

**Critical Consensus Security Breach:**
- The cryptographic foundation of AEDPoS consensus is undermined. The protocol assumes each miner generates unique `InValue` using their private key, ensuring unpredictable and fair ordering
- Multiple miners can have identical signatures, breaking the randomness assumptions
- The supposed order calculation becomes predictable and manipulable

**Order Conflict and Manipulation:**
- When multiple miners have the same signature, they receive identical `SupposedOrderOfNextRound` values
- While conflict resolution logic exists, it's deterministic and can be gamed by coordinated Byzantine miners
- Attackers can strategically choose which miner's values to copy to influence their position in the next round

**Randomness Compromise:**
- Consensus-derived random numbers (used for various protocol functions) lose their unpredictability [6](#0-5) 
- Any downstream systems depending on consensus randomness are affected

**Chain-Wide Impact:**
- All honest miners participating in consensus
- Security and liveness guarantees of the blockchain
- Applications and contracts relying on consensus randomness for fair ordering or random number generation

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a registered miner in the current miner list (achievable through election/selection process)
- Ability to observe network blocks (trivial - blocks are public)
- Standard block production capabilities

**Attack Simplicity:**
The attack is straightforward:
1. Read block headers from the blockchain (public data)
2. Extract target miner's `OutValue` and `Signature` from the Round data
3. Construct malicious block with copied values during attacker's time slot
4. Submit normally through the consensus mechanism

No advanced cryptographic operations or special privileges beyond being a miner are required.

**Feasibility:**
- Block headers are publicly broadcast and stored
- Consensus extra data is not encrypted or obfuscated
- Miners have legitimate reasons to observe other miners' blocks
- The attack is undetectable since validation accepts the copied values

**Detection Gap:**
- The validation only adds `UpdateValueValidationProvider` for UpdateValue behavior: [7](#0-6) 
- No uniqueness checks on `OutValue`/`Signature` across miners
- No monitoring for duplicate consensus values
- No slashing or penalty mechanism for this behavior

**Economic Rationality:**
- Attack cost: Negligible (normal mining operation + value copying)
- Benefit: Consensus manipulation, potential ordering advantage
- Risk: Currently undetectable with no penalties

## Recommendation

Implement cryptographic binding validation by including the current round's `InValue` in the validation flow:

1. **Include Current InValue in UpdateValueInput:** Modify the protobuf definition to include `in_value` field in `UpdateValueInput` message

2. **Verify OutValue Derivation:** In `UpdateValueValidationProvider`, add validation:
   ```csharp
   // Verify OutValue = Hash(InValue)
   if (HashHelper.ComputeFrom(providedInValue) != minerInRound.OutValue)
       return new ValidationResult { Message = "OutValue does not match InValue hash." };
   ```

3. **Verify Signature Calculation:** Validate that the signature was correctly calculated:
   ```csharp
   // Verify Signature = CalculateSignature(PreviousInValue)
   var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
   if (minerInRound.Signature != expectedSignature)
       return new ValidationResult { Message = "Signature validation failed." };
   ```

4. **Add Uniqueness Checks:** Implement validation to ensure OutValue and Signature are unique across all miners in the current round

5. **Store InValue:** Update `ProcessUpdateValue` to store the current `InValue` so it can be verified in the next round as `PreviousInValue`

## Proof of Concept

A proof of concept would require:

1. Deploy a test AEDPoS network with multiple miners
2. Have honest miner M2 produce a block with legitimate `OutValue` and `Signature`
3. Extract M2's consensus values from the block header
4. When Byzantine miner M1's turn arrives, construct a block where:
   - M1 signs the block (valid `SignerPubkey`)
   - M1 sets `SenderPubkey = M1`
   - M1 copies `Round[M1].OutValue = Round[M2].OutValue`
   - M1 copies `Round[M1].Signature = Round[M2].Signature`
5. Submit M1's block and observe that it passes all validation
6. Verify that both M1 and M2 have identical `SupposedOrderOfNextRound` values
7. Demonstrate that consensus randomness is compromised

The test would show that the validation does not detect the copied values and both miners end up with the same supposed order, proving the vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** protobuf/aedpos_contract.proto (L194-221)
```text
message UpdateValueInput {
    // Calculated from current in value.
    aelf.Hash out_value = 1;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 2;
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
    // Publish previous in value for validation previous signature and previous out value.
    aelf.Hash previous_in_value = 4;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    google.protobuf.Timestamp actual_mining_time = 5;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 8;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
    // The amount of produced blocks.
    int64 produced_blocks = 10;
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
    // The random number.
    bytes random_number = 13;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-245)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L32-32)
```csharp
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```
