# Audit Report

## Title
Insufficient Validation of ImpliedIrreversibleBlockHeight Enables Consensus Halt via LIB Manipulation

## Summary
The AEDPoS consensus contract fails to validate that miners report their current block height as `ImpliedIrreversibleBlockHeight`, only checking that values don't decrease. This allows colluding Byzantine miners (>1/3) to prevent Last Irreversible Block (LIB) progression, triggering automatic chain rollbacks and causing complete loss of liveness—violating fundamental Byzantine Fault Tolerance guarantees.

## Finding Description

The consensus protocol expects honest miners to set `ImpliedIrreversibleBlockHeight = Context.CurrentHeight` when producing blocks: [1](#0-0) 

However, the `LibInformationValidationProvider` only validates non-decreasing values, not correctness against the current block height: [2](#0-1) 

The `UpdateValueValidationProvider` performs no validation of `ImpliedIrreversibleBlockHeight` at all: [3](#0-2) 

Malicious miners can exploit this by modifying their node software to report stale `ImpliedIrreversibleBlockHeight` values in their `UpdateValue` transactions. The value is stored without proper validation: [4](#0-3) 

The LIB calculation sorts implied heights from all miners and selects the value at position `(count-1)/3`: [5](#0-4) [6](#0-5) 

If more than 1/3 of miners report stale values, the element at the 1/3 position remains low, preventing LIB progression. The system detects this condition after `max(8, MaximumTinyBlocksCount)` rounds and enters "Severe" status: [7](#0-6) 

This fires the `IrreversibleBlockHeightUnacceptable` event: [8](#0-7) 

The event processor triggers an automatic rollback to the stale LIB height: [9](#0-8) 

After rollback, malicious miners continue their behavior, creating an infinite rollback loop that prevents any forward progress.

The existing evil miner detection mechanism only penalizes missed time slots, not incorrect LIB reporting: [10](#0-9) 

Malicious miners producing blocks normally are never flagged as evil, despite reporting incorrect consensus data.

## Impact Explanation

This vulnerability causes **complete loss of blockchain liveness**:

1. **Blockchain Halt**: The infinite rollback loop prevents the chain from making forward progress. After each rollback to the stale LIB height, the malicious miners continue reporting stale values, retriggering the rollback mechanism.

2. **Transaction Loss**: All transactions included in blocks after the stale LIB are orphaned during each rollback, making it impossible to finalize any new transactions.

3. **Service Unavailability**: Users cannot execute transactions, smart contracts become unusable, dApps stop functioning, and the entire blockchain ecosystem becomes non-functional.

4. **BFT Property Violation**: The system uses 2/3 consensus thresholds (`MinersCountOfConsent = count * 2/3 + 1`), indicating BFT design: [11](#0-10) 

However, it fails to maintain liveness under 1/3 Byzantine miners—violating the fundamental guarantee that BFT systems must provide.

This is worse than storage DoS or transaction censorship—it's a complete consensus halt that makes the blockchain unusable for all participants.

## Likelihood Explanation

**Attack Requirements:**
- Control of >1/3 elected miners (approximately 7 out of 21 typical miners)
- Ability to modify node software to report stale values
- No need to compromise cryptographic keys or break protocol rules

**Attack Complexity:**
- Medium-low: Requires coordination among multiple miners and software modifications
- Technically straightforward: Miners simply provide stale but monotonically non-decreasing values
- No detection mechanism specifically identifies this behavior

**Economic Considerations:**
- Miners risk reputation and potential slashing if governance intervenes
- However, no immediate automated penalty exists for incorrect LIB reporting
- Evil miner detection only targets missed blocks, not consensus data integrity

**Probability Assessment:**
Medium-low in practice due to collusion requirements, but **HIGH from a protocol design perspective** because BFT consensus systems must tolerate up to f < n/3 Byzantine nodes without losing liveness. This vulnerability demonstrates the protocol fails to meet its own BFT security guarantees.

## Recommendation

Add validation in `LibInformationValidationProvider` to enforce that `ImpliedIrreversibleBlockHeight` matches or is reasonably close to `Context.CurrentHeight`:

```csharp
// In LibInformationValidationProvider.ValidateHeaderInformation()
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0)
{
    var impliedHeight = providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    var baseImpliedHeight = baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    
    // Check non-decrease (existing check)
    if (baseImpliedHeight > impliedHeight)
    {
        validationResult.Message = "Incorrect implied lib height.";
        return validationResult;
    }
    
    // NEW: Check against context height with reasonable tolerance
    var contextHeight = validationContext.CurrentHeight; // Need to add to context
    var maxAllowedLag = 10; // Allow small lag for network delays
    
    if (impliedHeight < contextHeight - maxAllowedLag)
    {
        validationResult.Message = "Implied lib height too far behind current height.";
        return validationResult;
    }
}
```

Additionally, extend evil miner detection to identify miners consistently reporting stale LIB values.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMinersPreventsLIBProgressionCausingHalt()
{
    // Setup: 21 miners, 7 malicious (exactly 1/3)
    const int totalMiners = 21;
    const int maliciousMiners = 7;
    
    // Initialize consensus with 21 miners
    await InitializeConsensusWithMiners(totalMiners);
    
    long staleLIBHeight = 100;
    long currentHeight = 100;
    
    // Simulate multiple rounds where malicious miners report stale LIB
    for (int round = 0; round < 10; round++)
    {
        currentHeight += totalMiners; // Each round adds blocks
        
        // Honest miners report current height
        for (int i = 0; i < totalMiners - maliciousMiners; i++)
        {
            await SubmitUpdateValueWithImpliedHeight(i, currentHeight);
        }
        
        // Malicious miners report stale height
        for (int i = totalMiners - maliciousMiners; i < totalMiners; i++)
        {
            await SubmitUpdateValueWithImpliedHeight(i, staleLIBHeight);
        }
        
        // Verify LIB does not progress beyond stale height
        var libHeight = await GetCurrentLIBHeight();
        libHeight.ShouldBe(staleLIBHeight);
    }
    
    // After max(8, MaximumTinyBlocksCount) rounds, verify Severe status
    var status = await GetBlockchainMiningStatus();
    status.ShouldBe(BlockchainMiningStatus.Severe);
    
    // Verify IrreversibleBlockHeightUnacceptable event was fired
    var events = await GetFiredEvents();
    events.ShouldContain(e => e.Name == "IrreversibleBlockHeightUnacceptable");
    
    // This would trigger automatic rollback, causing halt
}
```

**Notes:**

The vulnerability is confirmed through code analysis showing:
1. No validation enforces `ImpliedIrreversibleBlockHeight == Context.CurrentHeight`
2. The LIB calculation at position `(count-1)/3` is vulnerable to manipulation by >1/3 miners
3. The rollback mechanism creates an infinite loop when malicious miners persist
4. The system violates its BFT liveness guarantee under 1/3 Byzantine participants

This represents a critical consensus layer vulnerability that undermines the blockchain's fundamental availability guarantees.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-33)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L117-128)
```csharp
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockHeightUnacceptableLogEventProcessor.cs (L49-65)
```csharp
    protected override async Task ProcessLogEventAsync(Block block, LogEvent logEvent)
    {
        var distanceToLib = new IrreversibleBlockHeightUnacceptable();
        distanceToLib.MergeFrom(logEvent);

        if (distanceToLib.DistanceToIrreversibleBlockHeight > 0)
        {
            Logger.LogDebug($"Distance to lib height: {distanceToLib.DistanceToIrreversibleBlockHeight}");
            Logger.LogDebug("Will rollback to lib height.");
            _taskQueueManager.Enqueue(
                async () =>
                {
                    var chain = await _blockchainService.GetChainAsync();
                    await _blockchainService.ResetChainToLibAsync(chain);
                }, KernelConstants.UpdateChainQueueName);
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```
