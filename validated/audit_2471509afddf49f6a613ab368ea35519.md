# Audit Report

## Title
NFT Alias Symbol Collision Causes Incorrect Balance Reporting

## Summary
The MultiToken contract's NFT alias system contains a validation gap where `SetSymbolAlias` and `CreateToken` operate on independent storage mappings without cross-validation. This allows regular tokens and NFT aliases to share the same symbol, causing balance queries to return incorrect data when the resolution logic prioritizes regular tokens over alias lookups.

## Finding Description

The vulnerability stems from missing cross-validation between two independent symbol storage mappings: `TokenInfos` (stores regular token metadata) and `SymbolAliasMap` (maps aliases to actual NFT symbols).

**The SetSymbolAlias Validation Gap:**

The `SetSymbolAlias` method validates that an alias doesn't exist in `SymbolAliasMap`, but never checks if a regular token with that symbol already exists in `TokenInfos`. [1](#0-0) 

**The CreateToken Validation Gap:**

The `CheckTokenExists` method (called during token creation) validates symbol uniqueness only against `TokenInfos` and `InsensitiveTokenExisting`, never checking `SymbolAliasMap` for existing aliases. [2](#0-1) 

**The Alias Constraint:**

The `CheckTokenAlias` validation enforces that NFT aliases MUST equal the collection prefix. For a collection "TP-0", the alias MUST be "TP". [3](#0-2)  This design constraint makes collisions inevitable for popular symbol names.

**The Resolution Prioritization:**

When `GetBalance` queries a symbol, it calls `GetActualTokenSymbol`, which checks if the symbol exists in `TokenInfos` first. If found, it returns that symbol immediately without checking `SymbolAliasMap`. Only when `TokenInfos` returns null does it check the alias mapping. [4](#0-3) 

This prioritization causes `GetBalance` to return the wrong balance when a regular token shadows an NFT alias. [5](#0-4) 

**Attack Flow:**
1. User creates NFT collection "TP-0" with item "TP-31175"
2. User sets alias "TP" â†’ "TP-31175" (succeeds because line 750 only checks `SymbolAliasMap`)
3. Attacker creates regular token "TP" with a seed NFT (succeeds because `CheckTokenExists` only checks `TokenInfos`)
4. User queries balance with alias "TP"
5. `GetActualTokenSymbol` finds "TP" in `TokenInfos` and returns it directly
6. System returns balance of regular token "TP" instead of NFT "TP-31175"

## Impact Explanation

**Medium Severity** - This vulnerability causes:

1. **Data Integrity Violation**: Balance queries return incorrect information, violating the protocol's core guarantee that `GetBalance` provides accurate token balance data
2. **Broken Functionality**: The NFT alias system becomes unreliable and unusable when collisions occur
3. **Operational Confusion**: NFT holders querying with aliases receive balance information for the wrong token
4. **Griefing Vector**: Attackers can intentionally create regular tokens to shadow NFT aliases, disrupting alias functionality for legitimate NFT projects
5. **Forced Workaround**: Users must use full NFT symbols instead of aliases, eliminating the intended usability benefit

While this doesn't directly enable fund theft or supply manipulation, it breaks a fundamental protocol invariant (accurate balance reporting) and enables denial-of-service attacks against the alias system.

## Likelihood Explanation

**High Likelihood** due to:

1. **Low Attack Complexity**: Only requires two standard operations (create token, set alias) available through public methods
2. **Inevitable Collisions**: The `CheckTokenAlias` constraint that forces alias = collection prefix makes collisions predictable for popular symbol names like "TP", "NFT", or common acronyms
3. **Standard Permissions**: Token creation requires a seed NFT (obtainable by any user), and alias setting requires being the collection owner/issuer (legitimate permission)
4. **Both Orderings Work**: The attack succeeds whether the alias or regular token is created first
5. **Difficult Detection**: Both operations are legitimate and succeed independently; the collision only manifests during balance queries
6. **Natural Occurrence**: Popular prefix names will collide either accidentally or through intentional griefing

## Recommendation

Implement bidirectional validation between `TokenInfos` and `SymbolAliasMap`:

**In SetSymbolAlias:**
```csharp
// Add this check after line 750
Assert(State.TokenInfos[input.Alias] == null, 
    $"Cannot use alias {input.Alias} - a token with this symbol already exists.");
```

**In CheckTokenExists:**
```csharp
// Add this check after line 302
Assert(State.SymbolAliasMap[symbol] == null, 
    "Token symbol already exists as an NFT alias.");
```

This ensures the two symbol namespaces remain disjoint and collision-free.

## Proof of Concept

```csharp
[Fact]
public async Task NFT_Alias_Collision_With_Regular_Token_Test()
{
    // Step 1: Create NFT collection and item
    var symbols = await CreateNftCollectionAndNft();
    var collectionSymbol = symbols[0]; // "TP-0"
    var nftSymbol = symbols[1];        // "TP-31175"
    
    // Step 2: Set alias for NFT
    await TokenContractStub.SetSymbolAlias.SendAsync(new SetSymbolAliasInput
    {
        Symbol = nftSymbol,
        Alias = "TP"
    });
    
    // Step 3: Issue NFT to user
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = nftSymbol,
        Amount = 1,
        To = DefaultAddress
    });
    
    // Verify NFT balance via alias works correctly before collision
    var nftBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = "TP"
    });
    nftBalance.Balance.ShouldBe(1);
    
    // Step 4: Create regular token with same symbol as alias
    var createInput = new CreateInput
    {
        Symbol = "TP",
        TokenName = "Regular TP Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAddress,
        IsBurnable = true
    };
    await CreateSeedNftAsync(TokenContractStub, createInput);
    await TokenContractStub.Create.SendAsync(createInput);
    
    // Step 5: Issue regular token to different address
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "TP",
        Amount = 500,
        To = User1Address
    });
    
    // Step 6: Query balance using alias "TP" - should return NFT balance but returns regular token balance
    var balanceResult = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = "TP"
    });
    
    // Bug: Returns 0 (regular token balance for DefaultAddress) instead of 1 (NFT balance)
    balanceResult.Balance.ShouldBe(0); // This proves the collision issue
    
    // Verify regular token balance for User1Address shows incorrect NFT balance lookup fails
    var user1Balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = User1Address,
        Symbol = "TP"
    });
    user1Balance.Balance.ShouldBe(500); // Returns regular token balance, not NFT balance
}
```

This test demonstrates that once a regular token "TP" is created after an NFT alias "TP" exists, balance queries using "TP" resolve to the regular token instead of the NFT, proving the data integrity violation.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L750-750)
```csharp
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L840-852)
```csharp
    private void CheckTokenAlias(string alias, string collectionSymbol)
    {
        if (collectionSymbol == null)
        {
            throw new AssertionException("Token alias can only be set for NFT Item.");
        }

        // Current Rule: Alias must be the seed name.
        var parts = collectionSymbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(parts.Length == 2, $"Incorrect collection symbol: {collectionSymbol}.");
        Assert(parts.Last() == TokenContractConstants.CollectionSymbolSuffix, "Incorrect collection symbol suffix.");
        Assert(alias == parts.First(), $"Alias for an item of {collectionSymbol} cannot be {alias}.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L39-47)
```csharp
    public override GetBalanceOutput GetBalance(GetBalanceInput input)
    {
        var symbol = GetActualTokenSymbol(input.Symbol);
        return new GetBalanceOutput
        {
            Symbol = input.Symbol,
            Owner = input.Owner,
            Balance = GetBalance(input.Owner, symbol)
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L286-294)
```csharp
    private string GetActualTokenSymbol(string aliasOrSymbol)
    {
        if (State.TokenInfos[aliasOrSymbol] == null)
        {
            return State.SymbolAliasMap[aliasOrSymbol] ?? aliasOrSymbol;
        }

        return aliasOrSymbol;
    }
```
