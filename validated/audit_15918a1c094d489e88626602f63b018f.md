# Audit Report

## Title
Malicious Miner Can Halt Blockchain by Setting Empty Miner List Through Unvalidated NextTerm Input

## Summary
A current miner can directly call the `NextTerm` method with a crafted `NextTermInput` containing an empty `RealTimeMinersInformation` dictionary. The consensus contract lacks validation to prevent empty miner lists when NextTerm is called as a direct transaction, allowing the attacker to set a term with zero miners and permanently halt block production.

## Finding Description

The vulnerability exploits a critical difference between two execution paths for the `NextTerm` method:

**Path 1 (Block Validation - SAFE)**: When NextTerm is executed as part of consensus block production, `ValidateConsensusBeforeExecution` is called [1](#0-0) , which invokes `ValidateBeforeExecution` [2](#0-1) . This validation includes `TimeSlotValidationProvider` [3](#0-2) , which calls `CheckRoundTimeSlots()` [4](#0-3) . The `CheckRoundTimeSlots()` method would throw an `IndexOutOfRangeException` when attempting to access array indices on an empty miner list [5](#0-4) .

**Path 2 (Direct Transaction - VULNERABLE)**: When NextTerm is called directly as a transaction (it's a public RPC method [6](#0-5) ), it bypasses block validation [7](#0-6)  and only goes through `ProcessConsensusInformation` [8](#0-7) , which only performs a `PreCheck()` authorization that validates the sender is in the current or previous miner list [9](#0-8) . No validation checks if the input contains an empty miner list.

The `RoundTerminateValidationProvider` used during header validation only checks that round and term numbers increment correctly and that InValues are null [10](#0-9) , but does NOT validate that `RealTimeMinersInformation` is non-empty.

In `ProcessNextTerm`, the empty `RealTimeMinersInformation` dictionary is used to create an empty `MinerList` [11](#0-10) , which is then set in state via `SetMinerList` without any validation [12](#0-11) .

**Attack Execution**:
1. Malicious miner crafts `NextTermInput` with `RoundNumber = current + 1`, `TermNumber = current + 1`, empty `RealTimeMinersInformation`, and valid `RandomNumber`
2. Calls `NextTerm(input)` directly as a transaction (not through consensus mechanism)
3. Passes `PreCheck()` since attacker is in current miner list
4. Empty miner list gets set in state for the new term
5. All subsequent `GetConsensusCommand` calls return `InvalidConsensusCommand` because no public key exists in the empty miner list [13](#0-12) [14](#0-13) 
6. Blockchain permanently halts

## Impact Explanation

**CRITICAL** - This vulnerability causes complete, irreversible blockchain denial of service:

- **Complete Halt**: Once the empty miner list is set, no validator can produce blocks because `GetConsensusCommand` returns `InvalidConsensusCommand` for all nodes since their public key cannot be found in the empty miner list
- **Permanent Damage**: The attack cannot be undone through normal consensus mechanisms. Since no miner can pass authorization checks with an empty miner list, no recovery transactions can be executed on-chain
- **Total Network Failure**: All blockchain operations cease - users cannot submit transactions, smart contracts become inaccessible, validators lose rewards, and the entire network becomes non-functional
- **Recovery Requires Hard Fork**: Only off-chain intervention (hard fork with chain state rollback) can restore operations

The severity is CRITICAL because it violates the fundamental blockchain availability guarantee and has no on-chain recovery path.

## Likelihood Explanation

**MEDIUM-HIGH** likelihood:

- **Attacker Prerequisites**: Must be a current or previous miner to pass `PreCheck()`, requiring the attacker to be an elected validator. While this is a privileged position, any single compromised validator can execute the attack
- **Attack Simplicity**: Requires only crafting a single transaction with correct round/term numbers and an empty miner list - no complex timing or coordination needed
- **No Detection Window**: The attack executes in a single block, leaving no time for intervention
- **Economic Irrationality Not a Barrier**: Despite destroying the blockchain (including the attacker's stake), motivations include griefing by disgruntled validators, competitor-sponsored attacks, exit scams after extracting value, or exploiting before coordinated security patches

The attack is technically straightforward for any current miner, making it a realistic threat despite requiring validator privileges.

## Recommendation

Add validation in `ProcessNextTerm` to ensure the miner list is non-empty before calling `SetMinerList`:

```csharp
// In ProcessNextTerm method, after line 188
var miners = new MinerList();
miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));

// Add this validation
Assert(miners.Pubkeys.Count > 0, "Miner list cannot be empty.");

if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

Alternatively, add validation in `SetMinerList` itself to reject empty miner lists, or add a check in `PreCheck()` to validate the input structure when the behavior is NextTerm.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanHaltBlockchain_WithEmptyMinerList()
{
    // Setup: Initialize consensus with valid miners
    var initialMiners = GenerateInitialMiners(5);
    await InitializeConsensus(initialMiners);
    
    // Attacker is current miner
    var attackerKeyPair = initialMiners[0];
    
    // Get current term and round info
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var currentTermNumber = await ConsensusStub.GetCurrentTermNumber.CallAsync(new Empty());
    
    // Craft malicious NextTermInput with empty RealTimeMinersInformation
    var maliciousInput = new NextTermInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentTermNumber.Value + 1,
        RealTimeMinersInformation = { }, // EMPTY - this is the attack
        RandomNumber = GenerateRandomNumber(),
        BlockchainAge = currentRound.BlockchainAge + 1
    };
    
    // Execute attack: Call NextTerm directly as transaction (not through block validation)
    var attackTx = await ConsensusStub.NextTerm.SendAsync(maliciousInput);
    attackTx.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify blockchain is halted
    var newMinerList = await ConsensusStub.GetCurrentMinerList.CallAsync(new Empty());
    newMinerList.Pubkeys.Count.ShouldBe(0); // Miner list is now empty
    
    // Verify all GetConsensusCommand calls now fail
    foreach (var miner in initialMiners)
    {
        var command = await ConsensusStub.GetConsensusCommand.CallAsync(
            new BytesValue { Value = miner.PublicKey });
        command.ShouldBe(ConsensusCommandProvider.InvalidConsensusCommand);
    }
    
    // Blockchain is permanently halted - no miner can produce blocks
}
```

## Notes

This vulnerability demonstrates a critical gap between the validation performed during normal consensus block production versus direct transaction execution. The `NextTerm` method is exposed as a public RPC endpoint but lacks the necessary input validation when called outside the consensus flow. The attack is particularly severe because it results in a permanent, unrecoverable blockchain halt requiring off-chain intervention.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-104)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }

        var service = new HeaderInformationValidationService(validationProviders);

        Context.LogDebug(() => $"Validating behaviour: {extraData.Behaviour.ToString()}");

        var validationResult = service.ValidateInformation(validationContext);

        if (validationResult.Success == false)
            Context.LogDebug(() => $"Consensus Validation before execution failed : {validationResult.Message}");

        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** protobuf/aedpos_contract.proto (L37-39)
```text
    // Update consensus information, create a new term.
    rpc NextTerm (NextTermInput) returns (google.protobuf.Empty) {
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-87)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();

        Context.LogDebug(() => $"Processing {callerMethodName}");

        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");

        State.RoundBeforeLatestExecution.Value = GetCurrentRoundInformation(new Empty());

        ByteString randomNumber = null;

        // The only difference.
        switch (input)
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
                break;
            case TinyBlockInput tinyBlockInput:
                randomNumber = tinyBlockInput.RandomNumber;
                ProcessTinyBlock(tinyBlockInput);
                break;
        }

        var miningInformationUpdated = new MiningInformationUpdated
        {
            // _processingBlockMinerPubkey is set during PreCheck.
            Pubkey = _processingBlockMinerPubkey,
            Behaviour = callerMethodName,
            MiningTime = Context.CurrentBlockTime,
            BlockHeight = Context.CurrentHeight,
            PreviousBlockHash = Context.PreviousBlockHash
        };
        Context.Fire(miningInformationUpdated);
        Context.LogDebug(() => $"Synced mining information: {miningInformationUpdated}");

        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);

        if (TryToGetCurrentRoundInformation(out var currentRound))
            Context.LogDebug(() =>
                $"Current round information:\n{currentRound.ToString(_processingBlockMinerPubkey)}");

        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");

        if (!State.IsMainChain.Value && currentRound.RoundNumber > 1) Release();

        // Clear cache.
        _processingBlockMinerPubkey = null;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```
