# Audit Report

## Title
Missing Symbol Validation in TokenHolder CreateScheme Allows Creation of Unusable Profit Schemes

## Summary
The `CreateScheme` function in TokenHolderContract accepts and stores an unvalidated symbol parameter, allowing creation of profit schemes with invalid or non-existent token symbols. When users attempt to participate in these schemes via `RegisterForProfits`, their transactions fail during token locking, resulting in wasted gas fees and rendering the entire scheme permanently unusable.

## Finding Description

The `CreateScheme` function directly stores the user-provided symbol without performing any validation checks. [1](#0-0) 

The function accepts `input.Symbol` and stores it directly in the state mapping at line 29, with no verification that the symbol is:
- Non-empty or non-whitespace
- Properly formatted according to token naming conventions
- Associated with an existing token in the system

When users later call `RegisterForProfits` to participate in a profit scheme, the function retrieves the scheme and attempts to lock tokens using the stored symbol. [2](#0-1) 

The locking operation at lines 159-165 sends the scheme's symbol to the MultiToken contract's `Lock` method, which performs strict validation.

The MultiToken `Lock` method enforces multiple validation checks on the symbol. [3](#0-2) 

At line 197, it checks for non-empty/non-whitespace symbols, and at line 207, it calls `AssertValidToken` which validates both symbol format and token existence.

The `AssertValidToken` helper method performs comprehensive validation. [4](#0-3) 

This validation includes checking that the symbol matches the required regex pattern and that a corresponding token exists in state at line 37.

The symbol format validation uses a strict regex pattern. [5](#0-4) 

The pattern `^[a-zA-Z0-9]+(-[0-9]+)?$` only accepts alphanumeric characters with an optional numeric suffix after a dash, rejecting empty strings, special characters, or improperly formatted symbols.

The same issue affects the `Withdraw` function, which also relies on the scheme's symbol for token operations. [6](#0-5) 

## Impact Explanation

**Medium Severity Operational Impact:**

1. **Denial of Service**: Any scheme created with an invalid symbol becomes permanently unusable. All `RegisterForProfits` calls will fail, preventing legitimate users from participating in profit distribution.

2. **Gas Fee Wastage**: Users attempting to register for profits will have their transactions rejected by the MultiToken Lock validation, but only after consuming gas fees for transaction execution. These fees cannot be recovered.

3. **No Pre-validation Mechanism**: The contract provides no view function or validation method for users to verify a scheme's symbol validity before attempting registration, forcing trial-and-error interaction.

4. **Griefing Attack Vector**: Malicious actors can deliberately create schemes with invalid symbols and promote them through off-chain channels, causing legitimate users to waste resources attempting to participate.

The impact extends beyond the scheme creator's self-harm, as unsuspecting third-party users attempting to interact with these schemes suffer operational DoS and financial loss through wasted gas fees.

## Likelihood Explanation

**High Likelihood:**

1. **Unrestricted Access**: `CreateScheme` is a public function with no authorization requirements - any address can create profit schemes without permission checks.

2. **Trivial Execution**: An attacker (or careless user) needs only a single transaction with an invalid symbol parameter (empty string `""`, special characters like `"INVALID@#$"`, or a non-existent token name like `"FAKE123"`).

3. **Accidental Occurrence**: Beyond malicious intent, honest users or developers may inadvertently create broken schemes through typos, configuration errors, or misunderstanding of token symbols, with no validation to catch these mistakes.

4. **No Detection Capability**: Users cannot validate a scheme's usability without attempting registration and observing transaction failure, creating an information asymmetry that enables both accidental and malicious creation of unusable schemes.

5. **Real-World Scenarios**:
   - User mistypes symbol during scheme creation (e.g., "EFL" instead of "ELF")
   - Attacker creates scheme with gibberish symbol and promotes it as legitimate
   - Developer creates scheme for a token that doesn't exist yet, forgetting to create it first

## Recommendation

Add symbol validation in the `CreateScheme` function before storing the scheme. The validation should verify:

1. The symbol is non-empty and non-whitespace
2. The symbol matches the valid token format regex `^[a-zA-Z0-9]+(-[0-9]+)?$`
3. A token with the given symbol exists in the system

Recommended implementation:

Add validation at the beginning of `CreateScheme`:
```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Validate symbol is not empty
    Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid symbol: symbol cannot be empty.");
    
    // Initialize token contract reference if needed
    if (State.TokenContract.Value == null)
        State.TokenContract.Value = 
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
    
    // Verify token exists by attempting to get token info
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput 
    { 
        Symbol = input.Symbol 
    });
    Assert(tokenInfo != null && !string.IsNullOrEmpty(tokenInfo.Symbol), 
        $"Token not found: {input.Symbol}");
    
    // Rest of existing logic...
}
```

This ensures only valid, existing tokens can be used in profit schemes, preventing the creation of unusable schemes.

## Proof of Concept

```csharp
[Fact]
public async Task CreateScheme_WithInvalidSymbol_CausesRegisterForProfits_ToFail()
{
    // Step 1: Create a scheme with an INVALID symbol (empty string)
    var createResult = await TokenHolderContractStub.CreateScheme.SendAsync(
        new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "", // Invalid: empty symbol
            MinimumLockMinutes = 100
        });
    
    // Scheme creation succeeds (vulnerability: no validation)
    createResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify scheme was created with invalid symbol
    var scheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    scheme.Symbol.ShouldBe("");
    
    // Step 2: User attempts to register for profits with this scheme
    var registerResult = await TokenHolderContractStub.RegisterForProfits.SendWithExceptionAsync(
        new RegisterForProfitsInput
        {
            SchemeManager = Starter,
            Amount = 100
        });
    
    // Transaction fails due to invalid symbol in Lock validation
    registerResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    registerResult.TransactionResult.Error.ShouldContain("Invalid input symbol");
    
    // User wasted gas fees, scheme is permanently unusable
}

[Fact]
public async Task CreateScheme_WithNonExistentToken_CausesRegisterForProfits_ToFail()
{
    // Create scheme with symbol for non-existent token
    await TokenHolderContractStub.CreateScheme.SendAsync(
        new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "NOTEXIST", // Token doesn't exist
            MinimumLockMinutes = 100
        });
    
    // Attempt to register fails
    var registerResult = await TokenHolderContractStub.RegisterForProfits.SendWithExceptionAsync(
        new RegisterForProfitsInput
        {
            SchemeManager = Starter,
            Amount = 100
        });
    
    registerResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    registerResult.TransactionResult.Error.ShouldContain("Token is not found");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-209)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

        // Check auto-distribute threshold.
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-245)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L195-220)
```csharp
    public override Empty Lock(LockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");

        var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
        if (allowance >= input.Amount)
            State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
        DealWithExternalInfoDuringLocking(new TransferFromInput
        {
            From = input.Address,
            To = virtualAddress,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L33-39)
```csharp
    private TokenInfo AssertValidToken(string symbol, long amount)
    {
        AssertValidSymbolAndAmount(symbol, amount);
        var tokenInfo = GetTokenInfo(symbol);
        Assert(tokenInfo != null && !string.IsNullOrEmpty(tokenInfo.Symbol), $"Token is not found. {symbol}");
        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```
