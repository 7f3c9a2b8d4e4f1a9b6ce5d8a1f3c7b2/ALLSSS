# Audit Report

## Title
Incomplete Dataset in LIB Calculation Due to Current Round Miner Filtering

## Summary
The Last Irreversible Block (LIB) calculation in the AEDPoS consensus contract filters previous round miner data using only current round participants, violating the BFT consensus guarantee that requires 2/3+1 agreement from all previous round participants on block finality.

## Finding Description

The vulnerability exists in the `LastIrreversibleBlockHeightCalculator.Deconstruct()` method where the LIB is calculated based on miners' implied irreversible block heights. [1](#0-0) 

The critical flaw occurs in the filtering logic: the algorithm retrieves miners who successfully mined in the **current** round and uses their public keys to filter the **previous** round's implied irreversible block heights. [2](#0-1) 

The `GetMinedMiners()` method specifically returns only miners where `SupposedOrderOfNextRound != 0`, which identifies miners who have already produced blocks in the current round. [3](#0-2) 

The filtered heights are validated against `MinersCountOfConsent`, calculated as `(minerCount * 2 / 3) + 1` based on the current round's **total** miner count. [4](#0-3) 

**Why This Breaks Consensus:**

When a system has 10 total miners, `MinersCountOfConsent = 7`. If exactly 7 miners produce blocks in the current round while all 10 mined in the previous round:
- The validation check passes (7 >= 7)
- However, 3 miners who participated in the previous round are excluded from LIB calculation
- The LIB selection uses index `(7-1)/3 = 2` from the filtered 7 heights instead of index `(10-1)/3 = 3` from all 10 heights
- If excluded miners had lower implied heights, the calculated LIB is artificially inflated

The system explicitly handles missed mining slots by incrementing the `MissedTimeSlots` counter, confirming this is an expected operational scenario. [5](#0-4) 

## Impact Explanation

**HIGH severity** - This vulnerability violates the Byzantine Fault Tolerance consensus invariant requiring 2/3+1 agreement on finality.

**Concrete Harms:**

1. **Premature Block Finalization**: Blocks can be marked as irreversible without achieving true 2/3+1 consensus from all miners who participated in the previous round, violating the fundamental safety guarantee of BFT consensus.

2. **Cross-Chain Security Compromise**: The calculated LIB directly triggers the `IrreversibleBlockFound` event during block production. [6](#0-5)  This event propagates to cross-chain operations, potentially allowing premature cross-chain state transitions based on blocks that lack true finality consensus.

3. **Finality Violations**: If the broader network doesn't agree on the irreversibility of prematurely finalized blocks, it creates a risk of consensus divergence and potential chain reorganizations affecting finalized state.

**Quantified Example:**
- Previous round: 10 miners with implied heights [100, 101, 102, 103, 104, 105, 106, 107, 108, 109]
- Current round: 7 miners produce blocks (3 are offline/delayed)
- If the 7 active miners correspond to heights [104-109] plus one new entry
- Excluded miners have heights [100, 101, 102]
- **Incorrect LIB**: Index 2 from 7 heights = 105 or higher
- **Correct LIB**: Index 3 from 10 heights = 103
- **Result**: Blocks 104-105+ prematurely marked as irreversible without true supermajority agreement

## Likelihood Explanation

**MEDIUM-HIGH probability** - This vulnerability can be triggered through natural network conditions or coordinated action.

**No Special Permissions Required:**
- Any miner can miss their time slot due to network latency, node downtime, or intentional inaction
- The consensus mechanism explicitly handles missed time slots as normal operation

**Attack Complexity: LOW**
- Requires only that approximately 30% of miners don't produce blocks in the current round while having produced blocks in the previous round
- No sophisticated cryptographic attacks or precise timing coordination needed
- Can occur naturally when miners experience connectivity issues, perform maintenance, or are temporarily offline
- Malicious scenario: Miners with lower implied heights coordinate to skip their current round time slots

**Feasibility Conditions:**
- Production networks typically have â‰¥10 miners
- System requires exactly `MinersCountOfConsent` miners to mine in current round (common threshold)
- Previous round had broader participation
- Statistical likelihood that excluded miners have different height distributions

**Detection Difficulty:**
- No way to distinguish legitimate network issues from intentional non-mining
- The calculated LIB passes all validation checks
- No error messages or alerts are generated
- Appears as normal consensus operation

## Recommendation

Modify the LIB calculation to consider all miners who participated in the **previous** round, not just those who have mined in the current round. The algorithm should:

1. Use `_previousRound.GetMinedMiners()` instead of `_currentRound.GetMinedMiners()` to identify which miners actually participated in the previous round
2. Calculate `MinersCountOfConsent` based on the previous round's miner count
3. Ensure the threshold check validates against the complete previous round dataset

**Corrected logic:**
```csharp
public void Deconstruct(out long libHeight)
{
    if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;
    
    // Use previous round's mined miners, not current round's
    var previousMinedMiners = _previousRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
    var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(previousMinedMiners);
    
    // Use previous round's consensus threshold
    if (impliedIrreversibleHeights.Count < _previousRound.MinersCountOfConsent)
    {
        libHeight = 0;
        return;
    }
    
    libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
}
```

This ensures the LIB calculation reflects true 2/3+1 consensus from all miners who actually participated in determining the implied irreversible heights during the previous round.

## Proof of Concept

```csharp
[Fact]
public async Task LIB_Calculation_With_Incomplete_Dataset_Test()
{
    // Setup: 10 miners in the system
    const int totalMiners = 10;
    const int minersCountOfConsent = 7; // (10 * 2 / 3) + 1
    
    // Previous round: All 10 miners produced blocks with varying implied heights
    var previousRound = GenerateRoundWithMiners(totalMiners, roundNumber: 1);
    SetImpliedHeightsForMiners(previousRound, new[] { 100L, 101L, 102L, 103L, 104L, 105L, 106L, 107L, 108L, 109L });
    
    // Current round: Only 7 miners have produced blocks so far
    var currentRound = GenerateRoundWithMiners(totalMiners, roundNumber: 2);
    SetMinersWhoMined(currentRound, minerIndices: new[] { 3, 4, 5, 6, 7, 8, 9 }); // Excludes first 3 miners
    
    // Calculate LIB using the vulnerable algorithm
    var calculator = new LastIrreversibleBlockHeightCalculator(currentRound, previousRound);
    calculator.Deconstruct(out var calculatedLib);
    
    // With vulnerable code: Uses only 7 miners' heights from previous round
    // Filtered heights would be [103, 104, 105, 106, 107, 108, 109]
    // Index (7-1)/3 = 2, so LIB = 105
    
    // Expected correct LIB: Should use all 10 miners from previous round
    // All heights [100, 101, 102, 103, 104, 105, 106, 107, 108, 109]
    // Index (10-1)/3 = 3, so LIB should be 103
    
    var expectedCorrectLib = 103L;
    var vulnerableLib = 105L;
    
    Assert.Equal(vulnerableLib, calculatedLib); // Demonstrates the vulnerability
    Assert.NotEqual(expectedCorrectLib, calculatedLib); // Shows LIB is inflated
    
    // Blocks 104 and 105 are prematurely marked as irreversible
    // without true 2/3+1 consensus from all previous round participants
}
```

**Notes:**

This vulnerability represents a fundamental flaw in the consensus finality mechanism. The core issue is the semantic mismatch: the algorithm queries "who has mined in the current round" but should query "who mined in the previous round" to properly calculate which blocks those miners consider irreversible. The current implementation allows the LIB to advance based on an incomplete view of previous round consensus, particularly when some miners experience temporary network issues or intentionally skip mining slots. This breaks the BFT safety guarantee and can affect cross-chain operations that rely on finalized blocks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L52-55)
```csharp
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```
