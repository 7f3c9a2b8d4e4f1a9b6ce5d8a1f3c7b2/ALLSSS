# Audit Report

## Title
Stale Continuous Block Counter Bypasses Severe Status Emergency Limit

## Summary
During Severe emergency status, the AEDPoS consensus system intends to limit block production to 1 block per miner. However, due to a timing mismatch between validation and state updates, combined with a counter update logic that only decrements when the same miner continues, a miner can produce up to 8 blocks during emergency status instead of the intended 1 block, completely undermining the emergency safety mechanism.

## Finding Description

The AEDPoS consensus contract implements an emergency brake mechanism that activates when the current round number is dangerously ahead of the Last Irreversible Block (LIB) round number. The vulnerability arises from three architectural flaws working together:

**1. Severe Status Sets Emergency Limit to 1:**

When the blockchain enters Severe status (current round ≥ LIB round + 8), the system correctly identifies the emergency and returns a limit of 1 block: [1](#0-0) 

The severity threshold is defined as 8 rounds ahead of LIB: [2](#0-1) 

**2. Validation Uses Stale Counter from Previous Block:**

The validation phase occurs BEFORE block execution and reads the counter value from the previous block's state. The validation context is populated with the stale value: [3](#0-2) 

The validation provider only rejects blocks when the counter is already negative: [4](#0-3) 

**3. Counter Update Only Decrements for Same Miner:**

After block execution, the counter is updated. The critical flaw is that when the same miner continues producing blocks, the counter is merely decremented rather than being reset to the new emergency limit: [5](#0-4) 

The new emergency limit (`minersCountInTheory = 1`) is only applied when a DIFFERENT miner takes over: [6](#0-5) 

**Execution Flow:**

The validation entry point delegates to the internal validation logic: [7](#0-6) 

After block execution, `ProcessConsensusInformation` retrieves the current maximum blocks count and updates the counter: [8](#0-7) 

**Concrete Attack Scenario:**

Assume Miner A has been producing blocks normally and has `BlocksCount = 7` before Severe status triggers:

1. System enters Severe status: `GetMaximumBlocksCount()` returns 1
2. Block N: Validation sees 7 (≥ 0, passes) → Execution decrements to 6
3. Block N+1: Validation sees 6 (≥ 0, passes) → Execution decrements to 5
4. Block N+2: Validation sees 5 (≥ 0, passes) → Execution decrements to 4
5. Block N+3: Validation sees 4 (≥ 0, passes) → Execution decrements to 3
6. Block N+4: Validation sees 3 (≥ 0, passes) → Execution decrements to 2
7. Block N+5: Validation sees 2 (≥ 0, passes) → Execution decrements to 1
8. Block N+6: Validation sees 1 (≥ 0, passes) → Execution decrements to 0
9. Block N+7: Validation sees 0 (≥ 0, passes) → Execution decrements to -1
10. Block N+8: Validation sees -1 (< 0, FAILS)

**Result:** 8 blocks produced during Severe status instead of the intended 1 block.

The maximum normal limit is defined as: [9](#0-8) 

## Impact Explanation

The Severe status emergency mechanism is a critical safety feature designed to prevent chain instability when the Last Irreversible Block falls dangerously behind. When bypassed, the chain continues advancing rapidly despite being 8+ rounds ahead of LIB, which:

- **Increases fork risk:** More blocks produced ahead of LIB means higher probability of chain reorganization if network issues persist
- **Undermines finality guarantees:** Transaction irreversibility becomes less reliable when the gap between current height and LIB grows larger
- **Defeats emergency response:** The emergency brake becomes 87.5% ineffective (8 blocks actual vs 1 block intended = 7 extra blocks allowed)

This directly violates the security invariant that emergency status must immediately constrain block production to prevent dangerous chain divergence from finalized state.

## Likelihood Explanation

This vulnerability triggers automatically during normal consensus operations without requiring any malicious behavior:

**Preconditions (All Realistic):**
1. A miner produces consecutive blocks - common during normal mining rotation
2. Network conditions cause LIB to lag 8+ rounds behind - occurs during network partitions, consensus delays, or validator downtime
3. The same miner continues producing blocks after Severe status begins - natural consensus behavior when a miner holds consecutive time slots

**No Special Capabilities Required:**
- No privileged access needed
- No transaction manipulation required
- No coordination with other miners necessary
- Happens through legitimate mining operations following consensus rules

**Probability: HIGH** - This occurs whenever network issues cause Severe status while a miner is naturally producing consecutive blocks. The vulnerability is architectural and cannot be avoided without code changes.

## Recommendation

The counter update logic should immediately apply the emergency limit when Severe status is detected, regardless of whether the same miner continues. The fix should modify `ResetLatestProviderToTinyBlocksCount` to check if the new limit is lower than the current counter and apply it:

```csharp
private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
{
    LatestPubkeyToTinyBlocksCount currentValue;
    if (State.LatestPubkeyToTinyBlocksCount.Value == null)
    {
        currentValue = new LatestPubkeyToTinyBlocksCount
        {
            Pubkey = _processingBlockMinerPubkey,
            BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
        };
        State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
    }
    else
    {
        currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
        if (currentValue.Pubkey == _processingBlockMinerPubkey)
        {
            // Apply emergency limit immediately if it's lower
            var newCount = currentValue.BlocksCount.Sub(1);
            if (minersCountInTheory.Sub(1) < newCount)
                newCount = minersCountInTheory.Sub(1);
            
            State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = newCount
            };
        }
        else
            State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = minersCountInTheory.Sub(1)
            };
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task SevereStatus_ShouldLimit_To_OneBlock_Not_Eight()
{
    // Setup: Create a scenario where miner has produced 7 blocks normally
    var miner = SampleAccount.Accounts.First().KeyPair;
    
    // Initialize consensus with miner having BlocksCount = 7
    await InitializeConsensusWithMinerCount(miner, 7);
    
    // Trigger Severe status by advancing rounds far ahead of LIB
    await AdvanceRoundsToTriggerSevereStatus();
    
    // Verify GetMaximumBlocksCount returns 1 during Severe status
    var maxBlocks = await AEDPoSContractStub.GetMaximumBlocksCount.CallAsync(new Empty());
    maxBlocks.Value.ShouldBe(1); // Emergency limit is 1
    
    // Attempt to produce blocks as same miner
    int blocksProduced = 0;
    for (int i = 0; i < 10; i++)
    {
        var result = await ProduceBlockAsMiner(miner);
        if (result.Success)
            blocksProduced++;
        else
            break; // Validation failed
    }
    
    // VULNERABILITY: Should allow only 1 block, but actually allows 8
    blocksProduced.ShouldBe(1); // This will FAIL - actual value is 8
    // Proving the emergency brake is bypassed
}
```

## Notes

The vulnerability exists because the counter update logic (`ResetLatestProviderToTinyBlocksCount`) was designed assuming the maximum blocks count doesn't change dramatically mid-sequence. However, when Severe status triggers, the limit drops from 8 to 1, but this new limit is only enforced when a different miner takes over. The same miner can continue consuming their "budget" from before the emergency state began, defeating the purpose of the emergency mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L117-128)
```csharp
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-24)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L67-69)
```csharp
        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-357)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L358-363)
```csharp
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
