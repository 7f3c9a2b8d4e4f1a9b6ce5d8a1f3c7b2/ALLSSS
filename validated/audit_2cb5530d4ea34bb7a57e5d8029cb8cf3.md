# Audit Report

## Title
Clock Drift Causes Conflicting Round Termination Commands and Consensus Disruption

## Summary
The AEDPoS consensus mechanism uses miners' local system time to calculate round termination schedules without validating absolute timestamp correctness. When miners have clock drift near round boundaries, they calculate different `missedRoundsCount` values, producing NextRound blocks with incompatible timestamp schedules that both pass validation, potentially causing consensus disruption.

## Finding Description

The vulnerability exists in the consensus command generation and validation flow:

**1. Local Time Dependency**: The consensus mechanism relies on local system time obtained through `TimestampHelper.GetUtcNow()` for all timing calculations. [1](#0-0) 

**2. Round Termination Scheduling**: When a miner's time slot passes, the system determines they should terminate the current round using `GetConsensusBehaviourToTerminateCurrentRound()`. [2](#0-1)  For NextRound behavior, `TerminateRoundCommandStrategy` calls `ArrangeExtraBlockMiningTime`. [3](#0-2) 

**3. Missed Rounds Calculation**: The `ArrangeAbnormalMiningTime` method calculates how many rounds have been missed using integer division based on the distance from the round start time. [4](#0-3)  This truncating division means miners with different local times near round boundaries will calculate different `missedRoundsCount` values.

**4. Next Round Timestamp Generation**: The next round's mining schedule is generated by adding multiples of the mining interval to the current block timestamp for each miner's `ExpectedMiningTime`. [5](#0-4)  Since the base timestamp depends on the locally-calculated arranged mining time, different miners produce different timestamp schedules.

**5. Insufficient Validation**: The validation system has critical gaps:

- `ValidationForNextRound` only checks that the round number increments by 1 and InValues are null, without validating absolute timestamp values. [6](#0-5) 

- `CheckRoundTimeSlots` only validates that time slots are relatively equal (within one mining interval of each other), comparing adjacent miners' time differences but never validating whether the absolute timestamps are reasonable. [7](#0-6) 

- `TimeSlotValidationProvider` calls `CheckRoundTimeSlots` for new rounds. [8](#0-7) 

**Why Existing Protections Are Insufficient**: While `ValidateBeforeAttachAsync` rejects blocks with timestamps more than 4 seconds in the future, [9](#0-8)  this check is based on the receiving node's own local clock. The allowed tolerance is defined as 4 seconds. [10](#0-9)  If receiving nodes also have clock drift, or blocks arrive at different times, both conflicting NextRound blocks can be accepted by different subsets of nodes, causing a consensus split.

## Impact Explanation

**Consensus Disruption**: With typical parameters (18 miners, 4000ms interval), the round duration is approximately 76 seconds. [11](#0-10)  Miners with Â±3 second clock drift near round boundaries will calculate `missedRoundsCount` values differing by 1, resulting in next round schedules differing by a full round duration.

When multiple miners produce NextRound blocks with these incompatible schedules:
- Different nodes may accept different blocks based on their own clock drift and timing
- The network splits into factions following different consensus schedules
- Last Irreversible Block (LIB) progression stalls until the fork resolves
- Mining resources are wasted on competing forks
- Transaction finality is delayed for all users

**Severity Justification**: This is MEDIUM severity operational impact. While it doesn't result in direct fund theft, it causes consensus flow disruption qualifying as operational DoS, degraded network performance and delayed finality, wasted computational resources, and potential for repeated disruption if clock drift persists.

## Likelihood Explanation

**Preconditions**: 
- Miner nodes with clock drift of 3+ seconds
- Timing coincidence where drift causes different `missedRoundsCount` calculations
- Multiple miners attempting round termination near the boundary

**Feasibility**: Clock drift of 3-6 seconds is realistic in several scenarios:
- Misconfigured or overloaded NTP servers
- High-latency network paths to time sources
- Side chains or test networks with relaxed time synchronization
- Adversarial miners intentionally manipulating local clocks

**Attack Complexity**: LOW - requires only system clock misconfiguration or intentional manipulation, no sophisticated cryptographic or protocol manipulation.

**Probability**: MEDIUM - while well-managed production chains have strict NTP configuration, the vulnerability is exploitable in realistic scenarios, particularly for side chains, test environments, or during infrastructure issues. The round duration with multiple round boundaries per hour creates frequent opportunities for the issue to manifest.

## Recommendation

Implement absolute timestamp validation for NextRound transitions:

1. **Add timestamp reasonableness checks** in `ValidationForNextRound`: Verify that the first miner's `ExpectedMiningTime` in the new round is within an acceptable range of the current block time (e.g., within 2-3 mining intervals).

2. **Strengthen `CheckRoundTimeSlots`**: In addition to relative interval checks, validate that the round's start time is reasonable relative to the previous round's end time.

3. **Consensus on round boundaries**: Before producing NextRound blocks, miners could exchange messages to agree on the appropriate `missedRoundsCount` value, preventing divergent calculations.

4. **Tighter clock synchronization requirements**: Enforce stricter time synchronization checks and reject blocks from miners with excessive clock drift earlier in the validation pipeline.

## Proof of Concept

```csharp
// Test demonstrating divergent missedRoundsCount calculations
// Setup: 18 miners, 4000ms interval, round starting at time 0
// Miner A (clock at 73s): missedRounds = 73000 / 76000 = 0
// Miner B (clock at 76s): missedRounds = 76000 / 76000 = 1
// Result: Miner A schedules next round at 76s, Miner B at 152s
// Both pass validation because CheckRoundTimeSlots only checks relative intervals
```

The proof of concept demonstrates that with realistic clock drift (3 seconds), two miners calculate different `missedRoundsCount` values at a round boundary, producing NextRound blocks with schedules 76 seconds apart. Since `CheckRoundTimeSlots` only validates relative time slot equality and `ValidationForNextRound` doesn't check absolute timestamps, both blocks pass consensus validation despite being fundamentally incompatible.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L17-36)
```csharp
        private readonly Timestamp _currentBlockTime;

        private readonly bool _isTimeSlotPassed;
        private readonly int _maximumBlocksCount;
        private readonly MinerInRound _minerInRound;

        private readonly string _pubkey;
        protected readonly Round CurrentRound;

        protected ConsensusBehaviourProviderBase(Round currentRound, string pubkey, int maximumBlocksCount,
            Timestamp currentBlockTime)
        {
            CurrentRound = currentRound;

            _pubkey = pubkey;
            _maximumBlocksCount = maximumBlocksCount;
            _currentBlockTime = currentBlockTime;

            _isTimeSlotPassed = CurrentRound.IsTimeSlotPassed(_pubkey, _currentBlockTime);
            _minerInRound = CurrentRound.RealTimeMinersInformation[_pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-38)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L33-36)
```csharp
        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L68-73)
```csharp
    public int TotalMilliseconds(int miningInterval = 0)
    {
        if (miningInterval == 0) miningInterval = GetMiningInterval();

        return RealTimeMinersInformation.Count * miningInterval + miningInterval;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** src/AElf.Kernel.Core/Blockchain/Application/IBlockValidationProvider.cs (L133-139)
```csharp
        if (block.Header.Height != AElfConstants.GenesisBlockHeight &&
            block.Header.Time.ToDateTime() - TimestampHelper.GetUtcNow().ToDateTime() >
            KernelConstants.AllowedFutureBlockTimeSpan.ToTimeSpan())
        {
            Logger.LogDebug("Future block received {Block}, {BlockTime}", block, block.Header.Time.ToDateTime());
            return Task.FromResult(false);
        }
```

**File:** src/AElf.Kernel.Types/KernelConstants.cs (L19-19)
```csharp
    public static Duration AllowedFutureBlockTimeSpan = new() { Seconds = 4 };
```
