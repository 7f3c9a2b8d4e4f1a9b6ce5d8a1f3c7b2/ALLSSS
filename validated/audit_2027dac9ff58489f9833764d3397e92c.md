# Audit Report

## Title
Missing Miner List Validation in NextTerm Allows Consensus Manipulation

## Summary
The `ValidationForNextTerm()` function fails to verify that the proposed miner list matches actual election results from the Election Contract. A malicious block producer in the current term can propose a `NextTerm` transaction with an arbitrary miner list during their extra block time slot, bypassing consensus integrity checks and achieving complete control over the next term's consensus.

## Finding Description

The AEDPoS consensus contract has a critical validation gap when processing NextTerm transitions. The validation logic only verifies structural correctness (round/term number increments, null InValues) but completely omits verification of the most critical component - the miner list itself.

**Validation Gap:**

When a NextTerm transaction is validated, only the `RoundTerminateValidationProvider` is applied for the NextTerm behavior. [1](#0-0) 

This validator only checks that round and term numbers increment correctly and that InValues are null, with no verification of the miner list content. [2](#0-1) 

**Missing Election Verification:**

In the honest path, `GenerateFirstRoundOfNextTerm()` correctly retrieves election winners via `TryToGetVictories()`. [3](#0-2) 

The `TryToGetVictories()` method specifically queries election results from the Election Contract. [4](#0-3) 

**Exploitation Mechanism:**

Once validation passes, `ProcessNextTerm()` directly extracts the miner list from the input and stores it in state without any verification against election results. [5](#0-4) 

The miner list is permanently stored for the term through `SetMinerList()`. [6](#0-5) 

**Insufficient Access Control:**

The `PreCheck()` function only verifies that the sender is in the current or previous miner list, but does not validate the content of the proposed new miner list. [7](#0-6) 

**Attack Flow:**
1. A malicious miner in the current term waits for their extra block time slot
2. Instead of using the honest `GenerateFirstRoundOfNextTerm()`, they craft a malicious `NextTermInput` with arbitrary miners
3. They set correct round/term numbers and null InValues to pass validation
4. The malicious miner list includes only themselves or colluding nodes
5. Validation passes as no election result check exists
6. The fraudulent miner list is stored and becomes authoritative for the entire next term

## Impact Explanation

**Critical Consensus Compromise:**
- The attacker achieves complete control over consensus for the entire next term (7 days by default based on typical `PeriodSeconds` configuration)
- Legitimately elected miners are excluded from block production and lose all associated rewards
- The democratic election mechanism is completely nullified - token holders' votes become meaningless
- Network security is compromised as the attacker controls which transactions are included/excluded

**Quantified Damage:**
- All mining rewards for the compromised term flow to unauthorized miners
- The attacker can censor specific transactions, manipulate contract states, or halt chain progress
- Election snapshots record the fraudulent miner list, corrupting historical consensus records [8](#0-7) 
- Recovery requires emergency governance intervention or potentially a chain fork

**Affected Parties:**
- Legitimately elected miners lose block production rights and income
- Token holders who voted have their democratic participation nullified
- dApp users face potential censorship or service unavailability
- The entire AElf network's security and decentralization guarantees are violated

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a miner in the current term (achievable through prior legitimate election)
- No special privileges required beyond being a current block producer
- Attack executes during the extra block time slot, which is part of normal consensus flow

**Attack Complexity:**
- Very low - attacker simply crafts a `NextTermInput` with their desired miner list
- Setting correct round/term numbers is trivial (just increment by 1)
- Setting InValues to null is trivial
- No cryptographic attacks, timing manipulation, or race conditions required

**Execution Certainty:**
- Validation is guaranteed to pass as demonstrated by code analysis
- No randomness or external dependencies that could cause failure
- Single transaction execution - no multi-step coordination needed
- Detection is difficult as the transaction appears structurally valid

**Practical Feasibility:**
- Any miner who becomes malicious can execute this attack
- The extra block producer for term transition has guaranteed opportunity
- No off-chain coordination or infrastructure beyond normal mining required

**Overall Probability:** High - The attack is straightforward, requires minimal sophistication, and has guaranteed success if the attacker is the designated extra block producer during term transition.

## Recommendation

Add miner list validation in `ValidationForNextTerm()` to verify that the proposed miner list matches the Election Contract results:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Is next term number correct?
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // NEW: Verify miner list matches election results
    if (State.IsMainChain.Value)
    {
        var victories = State.ElectionContract.GetVictories.Call(new Empty());
        var proposedMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var electedMiners = victories.Value.Select(v => v.ToHex()).OrderBy(k => k).ToList();
        
        if (!proposedMiners.SequenceEqual(electedMiners))
            return new ValidationResult { Message = "Proposed miner list does not match election results." };
    }
    
    return new ValidationResult { Success = true };
}
```

## Proof of Concept

```csharp
[Fact]
public async Task NextTerm_ArbitraryMinerList_ShouldFail()
{
    // Setup: Get current state
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var currentMiner = InitialCoreDataCenterKeyPairs[0];
    
    // Get legitimate election results
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    
    // Create malicious miner list with only the attacker
    var maliciousMinerList = new MinerList();
    maliciousMinerList.Pubkeys.Add(ByteString.CopyFrom(currentMiner.PublicKey));
    
    // Generate NextTermInput with malicious miner list (bypassing GenerateFirstRoundOfNextTerm)
    var randomNumber = await GenerateRandomProofAsync(currentMiner);
    var maliciousNextTerm = maliciousMinerList.GenerateFirstRoundOfNewTerm(
        EconomicContractsTestConstants.MiningInterval,
        randomNumber,
        BlockTimeProvider.GetBlockTime(),
        currentRound.RoundNumber,
        currentRound.TermNumber);
    
    // Attack: Submit NextTerm with arbitrary miner list
    var miner = GetConsensusContractTester(currentMiner);
    var result = await miner.NextTerm.SendAsync(maliciousNextTerm);
    
    // Vulnerability: This should fail but succeeds
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: The fraudulent miner list was stored
    var newRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    newRound.RealTimeMinersInformation.Keys.Count.ShouldBe(1); // Only attacker
    newRound.TermNumber.ShouldBe(currentRound.TermNumber.Add(1));
    
    // Verify: Legitimate miners were excluded despite winning election
    victories.Value.Count.ShouldBeGreaterThan(1); // Multiple winners
    // But only attacker is in the new miner list - consensus is compromised!
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L74-78)
```csharp
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
```
