# Audit Report

## Title 
Arithmetic Overflow in PayRental Calculation Causes Permanent DoS of Side Chain Resource Fee Collection

## Summary
The `PayRental()` method performs uncapped multiplication of unbounded `duration` with `ResourceAmount` and `Rental` parameters. With moderate rental parameters, side chains experiencing extended downtime trigger checked arithmetic overflow, causing permanent DoS of the resource rental collection mechanism until governance intervention.

## Finding Description

The vulnerability exists in the rental fee calculation logic that executes automatically on every block for side chains. The `PayRental()` method calculates rental charges where duration is the unbounded time difference in minutes since the last payment. [1](#0-0) 

The multiplication operation calculates: `rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol])` [2](#0-1) 

These multiplication operations use the SafeMath library's `Mul` method, which employs checked arithmetic that throws `OverflowException` on overflow: [3](#0-2) 

The root cause is that governance-controlled rental parameters lack upper bound validation. The `UpdateRental` method only validates non-negativity: [4](#0-3) 

Similarly, `UpdateRentedResources` has the same insufficient validation: [5](#0-4) 

The execution path is automatic and unavoidable. `PayRental()` is called from `DonateResourceToken()` on all side chains: [6](#0-5) 

And `DonateResourceToken()` is automatically invoked by miners each block via the system transaction generator: [7](#0-6) 

When overflow occurs, the entire system transaction fails with `OverflowException`, preventing all subsequent rental collection attempts until governance reduces the parameters.

## Impact Explanation

**Severity: HIGH**

The impact is complete operational failure of a critical side chain economic mechanism. When the overflow occurs, it causes:

1. **Permanent DoS**: `DonateResourceToken()` fails on every block attempt, completely breaking the resource rental collection system
2. **Economic disruption**: Side chain creators stop paying rental fees for resources (CPU, RAM, DISK, NET), violating the economic model  
3. **Consensus impact**: The consensus contract stops receiving rental payments that should fund validator rewards

Based on realistic parameter ranges (where `long.MaxValue = 9,223,372,036,854,775,807`):
- **Moderate parameters** (ResourceAmount=1000, Rental=10 billion): Overflow after ~640 days downtime
- **High parameters** (ResourceAmount=10000, Rental=100 billion): Overflow after ~6.4 days downtime
- **Very high parameters** (ResourceAmount=100000, Rental=1 trillion): Overflow after ~1.5 hours downtime

The only recovery path is emergency governance intervention to reduce `Rental` or `ResourceAmount` values, which requires proposal creation, approval, and execution—a multi-step, time-consuming process during which the DoS persists.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The vulnerability has high likelihood because:

1. **No attacker required**: The vulnerability triggers automatically based on time passage—no malicious action needed
2. **Realistic preconditions**: Side chains can experience extended downtime due to network partitions, validator outages, critical bugs, or economic attacks
3. **Legitimate parameter values**: Governance may legitimately set moderate-to-high rental rates for resource pricing, unknowingly creating overflow risk
4. **Automatic trigger**: Once the threshold is reached, the next miner's automatic `DonateResourceToken()` call immediately triggers the overflow
5. **Observable in production**: The overflow manifests as clear `OverflowException` in transaction results, making it detectable but not preventable once triggered

The combination of realistic downtime scenarios, legitimate parameter choices, and automatic triggering makes this vulnerability highly likely to occur in production side chains.

## Recommendation

Add upper bound validation to both `UpdateRental` and `UpdateRentedResources` methods to prevent parameter values that could cause overflow within reasonable time periods.

For example, add validation to ensure that `ResourceAmount * Rental * MaxExpectedDowntimeInMinutes < long.MaxValue`:

```csharp
public override Empty UpdateRental(UpdateRentalInput input)
{
    AssertControllerForSideChainRental();
    const long maxSafeValue = 1_000_000_000_000; // Example: 1 trillion
    foreach (var pair in input.Rental)
    {
        Assert(
            Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
            "Invalid symbol.");
        Assert(pair.Value >= 0, "Invalid amount.");
        Assert(pair.Value <= maxSafeValue, "Rental value exceeds maximum safe limit.");
        State.Rental[pair.Key] = pair.Value;
    }
    return new Empty();
}
```

Apply similar validation to `UpdateRentedResources`. Additionally, consider implementing a maximum duration cap in `PayRental()` to prevent unbounded accumulation.

## Proof of Concept

```csharp
[Fact]
public async Task PayRental_Overflow_Test()
{
    await InitialTokenContractAsync();
    
    // Set high rental parameters that will cause overflow quickly
    var updateRentalInput = new UpdateRentalInput
    {
        Rental = 
        {
            {"CPU", 100_000_000_000_000} // 100 trillion per unit
        }
    };
    
    var updateResourceInput = new UpdateRentedResourcesInput
    {
        ResourceAmount = 
        {
            {"CPU", 100_000} // 100k units
        }
    };
    
    // Update parameters through governance
    await UpdateRentalThroughGovernanceAsync(updateRentalInput);
    await UpdateRentedResourcesThroughGovernanceAsync(updateResourceInput);
    
    // Wait sufficient time to trigger overflow
    // duration * 100_000 * 100_000_000_000_000 > long.MaxValue
    // duration > 922 minutes (~15 hours)
    await DelayAsync(TimeSpan.FromHours(16));
    
    // Attempt DonateResourceToken - should fail with OverflowException
    var result = await TokenContractStub.DonateResourceToken.SendWithExceptionAsync(
        new TotalResourceTokensMaps());
    
    result.TransactionResult.Error.ShouldContain("System.OverflowException");
}
```

## Notes

This vulnerability demonstrates insufficient input validation on governance-controlled parameters that can lead to arithmetic overflow in time-dependent calculations. The checked arithmetic in AElf's SafeMath library correctly throws exceptions on overflow, but the lack of upper bound validation on rental parameters allows governance to unknowingly create conditions where normal time passage causes permanent DoS. The automatic execution via system transactions means there is no way to avoid triggering the vulnerability once the parameters and time conditions align.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L947-950)
```csharp
        if (!isMainChain)
        {
            PayRental();
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1031-1031)
```csharp
        var duration = (Context.CurrentBlockTime - State.LastPayRentTime.Value).Seconds.Div(60);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1061-1061)
```csharp
            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1099-1112)
```csharp
    public override Empty UpdateRental(UpdateRentalInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.Rental)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.Rental[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1114-1127)
```csharp
    public override Empty UpdateRentedResources(UpdateRentedResourcesInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.ResourceAmount)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.ResourceAmount[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L79-85)
```csharp
    public static long Mul(this long a, long b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee/DonateResourceTransactionGenerator.cs (L60-71)
```csharp
        generatedTransactions.AddRange(new List<Transaction>
        {
            new()
            {
                From = from,
                MethodName = nameof(TokenContractImplContainer.TokenContractImplStub.DonateResourceToken),
                To = tokenContractAddress,
                RefBlockNumber = preBlockHeight,
                RefBlockPrefix = BlockHelper.GetRefBlockPrefix(preBlockHash),
                Params = input
            }
        });
```
