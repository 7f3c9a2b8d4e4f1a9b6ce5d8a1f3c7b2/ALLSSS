# Audit Report

## Title
Miner List Manipulation in NextRound Transition Bypasses Consensus Validation

## Summary
The AEDPoS consensus contract fails to validate that the miner list in a NextRound transition matches the current round's miner list. An attacker who becomes the extra block producer can craft a malicious `NextRoundInput` with an arbitrary miner list (adding, removing, or reordering miners) that passes all validation checks, permanently corrupting the consensus miner schedule and gaining control over block production.

## Finding Description

The root cause lies in the incomplete validation performed by `RoundTerminateValidationProvider.ValidationForNextRound()`. This method only validates two properties when transitioning to the next round: [1](#0-0) 

The validation checks:
1. Round number increments by exactly 1
2. All `InValue` fields in the next round are null

**Critical Missing Validation:** The method does NOT verify that the set of miners in `extraData.Round.RealTimeMinersInformation.Keys` matches the miners in `validationContext.BaseRound.RealTimeMinersInformation.Keys`.

When `ValidateBeforeExecution` processes a NextRound behavior, it adds the following validation providers: [2](#0-1) 

However, none of these providers validate the miner list:

- `NextRoundMiningOrderValidationProvider` only validates internal consistency (miners with `FinalOrderOfNextRound > 0` must equal miners with `OutValue != null`), which trivially passes for a fresh next round: [3](#0-2) 

- `MiningPermissionValidationProvider` only checks that the sender is in the **current** round's miner list: [4](#0-3) 

When a next round is **properly** generated, it preserves the current round's miner list by iterating over the current round's `RealTimeMinersInformation`: [5](#0-4) 

However, the `ProcessNextRound` method accepts the provided next round and stores it without validating the miner list: [6](#0-5) 

The `AddRoundInformation` method simply stores the round to state: [7](#0-6) 

**Attack Flow:**
1. Attacker is an elected miner who becomes the extra block producer (happens deterministically based on signature randomness)
2. Attacker crafts a malicious `NextRoundInput` using `NextRoundInput.ToRound()`: [8](#0-7) 

3. The malicious input contains arbitrary `RealTimeMinersInformation` keys (e.g., attacker's pubkey twice, or excluding honest miners)
4. Attacker calls the public `NextRound` method during their extra block time slot: [9](#0-8) 

5. All validation passes because no provider checks the miner list
6. The malicious round is stored permanently

## Impact Explanation

**Consensus Integrity Compromise (Critical):**
- The attacker gains complete control over the consensus miner schedule by manipulating who can produce blocks in subsequent rounds
- Can add unauthorized miners, including adding themselves multiple times to gain additional mining slots and double/triple their block rewards
- Can remove legitimate miners, effectively performing a Denial-of-Service attack on honest validators who lose their ability to produce blocks
- Can reorder miners strategically to maximize their own mining opportunities

**Quantified Damage:**
- Complete breakdown of the DPoS consensus mechanism's security guarantees
- Attacker can produce consecutive blocks indefinitely by controlling the miner composition
- Transaction censorship becomes possible by excluding honest miners who would include certain transactions
- If attacker adds themselves twice to the miner list, they effectively double their mining rewards without additional stake
- Permanent state corruption requiring emergency chain halt and rollback to before the attack

**Affected Parties:**
- All network participants lose consensus security and decentralization guarantees
- Legitimate miners lose their allocated mining slots and associated block rewards
- Users face potential transaction censorship and delayed finality
- Chain governance is compromised as block production control enables control over consensus-driven decisions

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a legitimate miner in the current round (achievable through the normal election process by staking tokens and receiving votes)
- Must become the extra block producer for at least one round (happens deterministically based on the first miner's signature from the previous round - every miner eventually gets this role)
- No special privileges beyond being an elected miner are required

**Attack Complexity:**
- **Low**: Only requires constructing a `NextRoundInput` message with modified `RealTimeMinersInformation.Keys` and calling the public `NextRound` method
- The attacker has full control over the miner list structure they provide
- No cryptographic commitments or signatures bind the miner list to prevent manipulation

**Feasibility Conditions:**
- The extra block producer role rotates among all miners, so any elected miner will eventually have the opportunity to execute this attack
- The validation gap is deterministic and reproducible - if the basic checks (round number, InValue) pass, the attack succeeds
- Detection only occurs when legitimate miners discover they've been unexpectedly excluded from the miner schedule

**Probability Assessment:**
- **High**: Every elected miner becomes the extra block producer periodically (typically once per epoch of rounds)
- **Guaranteed Success**: No randomness or guessing involved; the validation gap ensures success if the attacker constructs the input correctly
- **Reproducible**: Can be executed multiple times whenever the attacker (or any colluding miner) becomes the extra block producer

## Recommendation

Add explicit validation in `RoundTerminateValidationProvider.ValidationForNextRound()` to verify that the miner list in the next round matches the current round's miner list:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing validation: round number
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    // Existing validation: InValue should be null
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };

    // NEW VALIDATION: Verify miner list matches current round
    var currentMiners = validationContext.BaseRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    var nextMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    
    if (currentMiners.Count != nextMiners.Count || !currentMiners.SequenceEqual(nextMiners))
        return new ValidationResult { Message = "Next round miner list must match current round miner list." };

    return new ValidationResult { Success = true };
}
```

This ensures that the miner list can only change during `NextTerm` transitions (where miner election results are applied), not during `NextRound` transitions (which should only re-arrange existing miners).

## Proof of Concept

```csharp
[Fact]
public async Task MinerListManipulation_NextRound_ShouldFail()
{
    // Setup: Initialize consensus with 3 miners
    var initialMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusWithMiners(initialMiners);
    
    // Get current round
    var currentRound = await GetCurrentRound();
    
    // Attacker (miner1) becomes extra block producer and crafts malicious NextRoundInput
    // Adding miner1 twice and removing miner3
    var maliciousNextRound = new Round
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RealTimeMinersInformation =
        {
            { "miner1", new MinerInRound { Pubkey = "miner1", Order = 1 } },
            { "miner1_duplicate", new MinerInRound { Pubkey = "miner1", Order = 2 } }, // Duplicate!
            { "miner2", new MinerInRound { Pubkey = "miner2", Order = 3 } }
            // miner3 excluded!
        }
    };
    
    var maliciousInput = NextRoundInput.Create(maliciousNextRound, GenerateRandomNumber());
    
    // Execute attack: Call NextRound with malicious input
    var result = await ConsensusContract.NextRound(maliciousInput);
    
    // VULNERABILITY: This should fail but currently succeeds
    // After fix, this transaction should revert with "Next round miner list must match current round miner list"
    
    // Verify corruption: Check that miner list was changed
    var newRound = await GetCurrentRound();
    
    // PROOF: Miner list is now corrupted
    Assert.Equal(3, newRound.RealTimeMinersInformation.Count); // Should be 3 original miners
    Assert.True(newRound.RealTimeMinersInformation.ContainsKey("miner1_duplicate")); // Attacker added themselves twice
    Assert.False(newRound.RealTimeMinersInformation.ContainsKey("miner3")); // Honest miner excluded
}
```

**Notes:**
- The vulnerability exploits the fact that NextRound transitions are meant to re-order existing miners within the same term, not change the miner set composition
- Miner list changes should only occur during NextTerm transitions after a new election
- The missing validation allows any extra block producer to arbitrarily rewrite the consensus miner schedule
- This breaks the fundamental security assumption of DPoS that the miner set is determined by election/voting, not by individual miners

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-56)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
