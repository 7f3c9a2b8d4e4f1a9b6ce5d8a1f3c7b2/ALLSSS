# Audit Report

## Title
Treasury Accepts Unfavorable Prices Due to Missing Slippage Protection on Token Conversion

## Summary
The Treasury contract lacks slippage protection when converting donated non-native tokens to native tokens, causing the protocol to accept any exchange rate returned by the Bancor formula. This allows value extraction through price manipulation or exploitation of natural market volatility.

## Finding Description

When users donate non-native tokens to Treasury via the `Donate` method, the contract checks if conversion to native tokens is needed and calls the internal `ConvertToNativeToken` helper function. [1](#0-0) 

The `ConvertToNativeToken` method creates a `SellInput` message with only the `Symbol` and `Amount` parameters, completely omitting the `ReceiveLimit` parameter: [2](#0-1) 

The `SellInput` protobuf message defines `receive_limit` as an optional field (field #3) specifically designed for slippage protection, with documentation stating "Limits on tokens obtained by selling. If the token obtained is less than this value, the sale will be abandoned. And 0 is no limit." [3](#0-2) 

In the TokenConverter's `Sell` method, the price validation logic explicitly bypasses the check when `ReceiveLimit` equals zero (the default value for unset fields): [4](#0-3) 

Since Treasury never sets `ReceiveLimit`, the condition `input.ReceiveLimit == 0` evaluates to true, causing the price check to always pass regardless of the actual exchange rate received.

The TokenConverter uses the Bancor pricing formula which is deterministic and directly depends on connector balance ratios. [5](#0-4) 

Anyone can manipulate these connector balances by executing normal Buy/Sell operations on the TokenConverter contract, as these are public methods without special access controls.

## Impact Explanation

This vulnerability causes **direct financial loss to the AElf Treasury**, which is the protocol's main profit distribution scheme. [6](#0-5) 

While Treasury is exempt from conversion fees [7](#0-6) , this fee exemption does not prevent price manipulation attacks.

Each time a non-native token donation is converted, the Treasury receives whatever amount the current Bancor formula calculates, with no validation that this represents fair value. The magnitude of loss depends on:
- The donation amount (larger donations = larger absolute losses)
- Connector liquidity depth (lower liquidity = higher slippage)
- Market conditions or intentional manipulation at time of conversion

Since donations fund miner rewards, voter welfare, and other ecosystem incentives through Treasury's sub-schemes, cumulative value leakage directly harms protocol sustainability and reduces benefits for all stakeholders.

## Likelihood Explanation

This vulnerability has **high likelihood** because:

1. **Public Entry Point**: The `Donate` method is public and can be invoked by anyone without special privileges. [8](#0-7) 

2. **Deterministic Exploitation**: The Bancor formula is fully deterministic and publicly known, allowing precise calculation of price impact. Anyone can manipulate connector balances through the public `Buy` and `Sell` methods on TokenConverter.

3. **No Access Controls**: The TokenConverter's Buy/Sell operations are public methods - the only barriers are transaction fees and capital requirements.

4. **Multiple Attack Vectors**: Exploitation doesn't require sophisticated front-running. Value loss occurs through:
   - Natural market volatility during conversions
   - Intentional price manipulation before donations
   - Large donations causing high slippage in shallow liquidity pools
   - Sandwich attacks if transaction ordering allows

5. **Repeatable**: The vulnerability can be exploited on every non-native token donation, making it a persistent systemic risk.

## Recommendation

The Treasury contract should set an appropriate `ReceiveLimit` parameter when calling TokenConverter.Sell to enforce minimum acceptable exchange rates:

```csharp
private void ConvertToNativeToken(string symbol, long amount)
{
    State.TokenContract.Approve.Send(new ApproveInput
    {
        Spender = State.TokenConverterContract.Value,
        Symbol = symbol,
        Amount = amount
    });

    // Calculate expected minimum return with acceptable slippage tolerance
    var expectedReturn = CalculateExpectedReturn(symbol, amount);
    var minAcceptableReturn = expectedReturn.Mul(95).Div(100); // 5% slippage tolerance
    
    State.TokenConverterContract.Sell.Send(new SellInput
    {
        Symbol = symbol,
        Amount = amount,
        ReceiveLimit = minAcceptableReturn  // Add slippage protection
    });

    Context.SendInline(Context.Self, nameof(DonateAll), new DonateAllInput
    {
        Symbol = Context.Variables.NativeSymbol
    });
}
```

Implement a `CalculateExpectedReturn` helper that queries current connector balances and calculates the expected return using the Bancor formula, then applies an acceptable slippage tolerance (e.g., 5%).

## Proof of Concept

The vulnerability is demonstrated through code analysis showing the complete execution path:

1. User calls `Donate(symbol, amount)` with non-native token
2. Treasury determines conversion is needed and calls `ConvertToNativeToken`
3. `ConvertToNativeToken` creates `SellInput` with NO `ReceiveLimit` (defaults to 0)
4. TokenConverter.Sell receives `input.ReceiveLimit == 0`
5. Price check `Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.")` always passes because first condition is true
6. Treasury receives whatever amount Bancor formula returns, regardless of whether it represents fair value

This can be verified by inspecting the three key code locations:
- Treasury omits the parameter: [2](#0-1) 
- TokenConverter bypasses validation: [4](#0-3) 
- Protobuf defines the field: [9](#0-8) 

## Notes

This vulnerability is valid regardless of whether front-running is feasible in AElf's transaction ordering model. Even without front-running capabilities, the fundamental issue remains: Treasury lacks price validation when converting tokens, exposing it to value loss through market volatility, low liquidity scenarios, or intentional pre-manipulation of Bancor pools. The `ReceiveLimit` parameter exists specifically for this protection but is never utilized by Treasury.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L18-39)
```csharp
/// <summary>
///     The Treasury is the largest profit scheme in AElf main chain.
///     Actually the Treasury is our Dividends Pool.
///     Income of the Treasury is mining rewards
///     (AEDPoS Contract will:
///     1. transfer ELF tokens to general ledger of Treasury every time we change term (7 days),
///     the amount of ELF should be based on blocks produced during last term. 1,000,000 * 1250000 ELF,
///     then release the Treasury;
///     2. Release Treasury)
///     3 sub profit schemes:
///     (Mining Reward for Miners) - 3
///     (Subsidy for Candidates / Backups) - 1
///     (Welfare for Electors / Voters / Citizens) - 1
///     3 sub profit schemes for Mining Rewards:
///     (Basic Rewards) - 4
///     (Welcome Rewards) - 1
///     (Flexible Rewards) - 1
///     3 incomes:
///     1. 20% total supply of elf, from consensus contract
///     2. tx fees.
///     3. resource consumption of developer's contracts.
/// </summary>
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L174-174)
```csharp
    public override Empty Donate(DonateInput input)
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L204-208)
```csharp
        var needToConvert = !isNativeSymbol && canExchangeWithNativeSymbol;
        if (needToConvert)
        {
            ConvertToNativeToken(input.Symbol, input.Amount);
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L676-680)
```csharp
        State.TokenConverterContract.Sell.Send(new SellInput
        {
            Symbol = symbol,
            Amount = amount
        });
```

**File:** protobuf/token_converter_contract.proto (L135-143)
```text
message SellInput {
    // The token symbol you want to sell.
    string symbol = 1;
    // The amount you want to sell.
    int64 amount = 2;
    // Limits on tokens obtained by selling. If the token obtained is less than this value, the sale will be abandoned.
    // And 0 is no limit.
    int64 receive_limit = 3;
}
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L176-177)
```csharp
        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L180-180)
```csharp
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```
