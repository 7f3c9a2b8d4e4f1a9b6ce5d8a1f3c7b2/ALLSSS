# Audit Report

## Title
Fixed Candidate Registration Cost Enables Predictable Candidate Pool Monopolization Attack

## Summary
The Election contract's fixed 100,000 ELF deposit combined with the Vote contract's hard 64-option limit allows an attacker with 6.4M ELF to monopolize all candidate slots, creating a complete denial-of-service condition for new candidate registrations.

## Finding Description

The vulnerability stems from three immutable architectural constraints:

**Root Cause 1 - Fixed Lock Amount:**
The candidate registration deposit is hardcoded as a compile-time constant. [1](#0-0) 

**Root Cause 2 - Hard Candidate Limit:**
The Vote contract enforces a maximum of 64 options per voting item as a hardcoded constant. [2](#0-1) 

**Root Cause 3 - Strict Enforcement:**
The `AddOption` method strictly enforces this limit by reverting any transaction that would exceed 64 options. [3](#0-2) 

**Execution Path:**

When a user calls `AnnounceElection`, the system locks exactly 100,000 ELF tokens from the sender. [4](#0-3) 

The Election contract then adds the candidate as a voting option by calling the Vote contract. [5](#0-4) 

The code explicitly acknowledges that candidate capacity is limited by voting options. [6](#0-5) 

**Why Existing Protections Fail:**

The only protection is the 100,000 ELF deposit requirement. However, tokens are fully recoverable via `QuitElection`, which returns the exact deposit amount. [7](#0-6) 

No rate limiting, progressive pricing, cooldown mechanisms, or governance adjustment capabilities exist to prevent this attack.

## Impact Explanation

**Operational Impact - Denial of Service:**
Once all 64 candidate slots are occupied, any attempt to register a new candidate will revert at the Vote contract's strict limit enforcement. This creates a complete DoS of the candidate registration system. Legitimate node operators cannot enter the candidate pool until an existing candidate quits.

**Consensus Decentralization Impact:**
The attacker controls which 64 public keys occupy all available candidate slots. While existing candidates can still receive votes and become miners, no new competition can emerge. This undermines the open and permissionless nature of the AEDPoS consensus mechanism. The attacker can maintain this monopoly indefinitely by immediately re-registering whenever slots open.

**Quantified Damage:**
- Total attack cost: 6,400,000 ELF (64 candidates × 100,000 ELF)
- All tokens are fully recoverable, making the effective cost only the opportunity cost
- Complete blockage of new candidate registrations until attacker releases slots
- Prevents any prospective validator from joining the candidate pool

## Likelihood Explanation

**Attacker Capabilities:**
The attack requires control of 6.4M ELF tokens and the ability to execute 64 transaction calls to `AnnounceElection` or `AnnounceElectionFor`. No special privileges or insider access are required - these are public methods callable by any address with sufficient balance.

**Attack Complexity:**
The attack has low complexity: a straightforward sequence of 64 identical transactions with deterministic outcome. There are no timing dependencies, race conditions, or complex state manipulations to coordinate.

**Economic Rationality:**
For actors with existing consensus positions or governance interests, the strategic value of preventing new competition may exceed the opportunity cost of locking 6.4M ELF. Since tokens are fully recoverable via `QuitElection`, this represents a reversible capital allocation rather than a permanent loss, reducing the economic risk for the attacker.

**Feasibility Conditions:**
The attack succeeds if fewer than 64 candidates are currently registered and the attacker has sufficient ELF balance. Even partial attacks (e.g., filling 50 of 64 slots) create significant disruption to new candidate onboarding.

## Recommendation

Implement one or more of the following mitigations:

1. **Governance-Adjustable Deposit:** Replace the hardcoded constant with a state variable that can be updated via Parliament governance, allowing the deposit to be increased as ELF value changes.

2. **Progressive Pricing:** Implement exponentially increasing deposit requirements as more candidates register (e.g., deposit = base_amount × 2^(current_candidates/threshold)).

3. **Rate Limiting:** Add a cooldown period between candidate registrations from the same address or admin.

4. **Higher Fixed Deposit:** Increase the deposit to a level where the total cost becomes prohibitive (e.g., 1M ELF per candidate = 64M ELF total).

5. **Increase Maximum Options:** Work with governance to increase the Vote contract's maximum options limit through a contract upgrade if architecturally feasible.

## Proof of Concept

```csharp
// Test demonstrating the DoS attack
[Fact]
public async Task CandidatePool_Monopolization_Attack()
{
    // Setup: Attacker has 6.4M ELF
    const long depositPerCandidate = 100_000_00000000; // 100k ELF
    const int maxCandidates = 64;
    long attackerBalance = depositPerCandidate * maxCandidates;
    
    // Fund attacker
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = AttackerAddress,
        Symbol = "ELF",
        Amount = attackerBalance
    });
    
    // Attack: Register 64 candidates
    for (int i = 0; i < maxCandidates; i++)
    {
        var keypair = CryptoHelper.GenerateKeyPair();
        await ElectionContractStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
        {
            Pubkey = keypair.PublicKey.ToHex(),
            Admin = AttackerAddress
        });
    }
    
    // Verify: Legitimate candidate cannot register
    var legitimateKeypair = CryptoHelper.GenerateKeyPair();
    var result = await ElectionContractStub.AnnounceElectionFor.SendWithExceptionAsync(
        new AnnounceElectionForInput
        {
            Pubkey = legitimateKeypair.PublicKey.ToHex()
        });
    
    // Assert: Transaction reverts with "can't greater than 64" error
    result.TransactionResult.Error.ShouldContain("can't greater than");
    
    // Verify: Attacker can recover all funds
    var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
    foreach (var candidate in candidates.Value.Take(maxCandidates))
    {
        await ElectionContractStub.QuitElection.SendAsync(new StringValue
        {
            Value = candidate.ToHex()
        });
    }
    
    // Assert: All tokens recovered
    var finalBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = AttackerAddress,
        Symbol = "ELF"
    });
    finalBalance.Balance.ShouldBe(attackerBalance);
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-5)
```csharp
    public const int MaximumOptionsCount = 64;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L285-286)
```csharp
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L86-89)
```csharp
    /// <summary>
    ///     Actually this method is for adding an option of the Voting Item.
    ///     Thus the limitation of candidates will be limited by the capacity of voting options.
    ///     The input is candidate admin, better be an organization address of Association Contract.
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L197-209)
```csharp
    private void AddCandidateAsOption(string publicKey)
    {
        if (State.VoteContract.Value == null)
            State.VoteContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.VoteContractSystemName);

        // Add this candidate as an option for the the Voting Item.
        State.VoteContract.AddOption.Send(new AddOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = publicKey
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L239-249)
```csharp
        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```
