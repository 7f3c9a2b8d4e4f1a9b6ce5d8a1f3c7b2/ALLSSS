# Audit Report

## Title
Self-Modification Deadlock in Referendum Contract Due to Insufficient Threshold and Whitelist Validation

## Summary
The Referendum contract's `ChangeOrganizationThreshold` and `ChangeOrganizationProposerWhiteList` functions lack validation to ensure thresholds are achievable against token supply or that whitelists are accessible. This allows organizations to permanently lock themselves into unmodifiable configurations, creating irrecoverable governance deadlocks.

## Finding Description

The Referendum contract allows organizations to modify their own governance parameters through proposal execution. However, the validation logic has critical gaps that enable permanent governance deadlock scenarios.

**Authorization Requirement**: Both `ChangeOrganizationThreshold` and `ChangeOrganizationProposerWhiteList` require `Context.Sender` to equal the organization address, meaning only the organization itself can modify its parameters. [1](#0-0) [2](#0-1) 

**Proposal Release Mechanism**: These functions are invoked when the `Release` method executes a proposal using `SendVirtualInlineBySystemContract`, which sets the transaction sender to the organization's virtual address. [3](#0-2) 

**Insufficient Validation**: The `Validate` function only checks basic constraints but does NOT verify that thresholds are achievable given actual token supply, nor that whitelist addresses are accessible. [4](#0-3) 

**Rejection Check Logic**: The threshold release check uses strict inequality for rejections, meaning if `MaximalRejectionThreshold = 0`, any proposal with one or more rejection votes will fail. [5](#0-4) 

**Comparison with Other Governance Contracts**: The Association contract validates thresholds against `organizationMemberCount` to ensure achievability. [6](#0-5)  Similarly, Parliament validates against `AbstractVoteTotal`. [7](#0-6)  The Referendum contract lacks equivalent supply-based validation.

**Attack Scenarios**:

1. **Impossible Vote Threshold**: Setting `MinimalVoteThreshold` or `MinimalApprovalThreshold` higher than the token's total supply makes all future proposals unapprovable, including recovery proposals.

2. **Zero Rejection Threshold**: Setting `MaximalRejectionThreshold = 0` causes any proposal with â‰¥1 rejection vote to fail. In democratic governance, achieving zero dissent is practically impossible, so all future proposals (including recovery attempts) will be rejected.

3. **Inaccessible Whitelist**: Setting the proposer whitelist to contain only addresses with lost private keys or non-functional contract addresses prevents anyone from creating proposals, making governance impossible.

## Impact Explanation

**HIGH Severity** - This vulnerability causes complete and permanent loss of governance functionality for affected Referendum organizations:

- **Irrecoverable State**: Once problematic parameters are set, there is no recovery mechanism. The organization cannot create or approve corrective proposals.

- **Governance Paralysis**: Any protocol decisions requiring the affected organization become permanently blocked. If critical protocol governance paths depend on such an organization, entire protocol subsystems may become frozen.

- **Cascading Effects**: If a Referendum organization controls important protocol parameters (like fee structures, token emissions, or cross-chain configurations), its paralysis can have system-wide impact.

- **No Fund Loss but Critical Availability Impact**: While this doesn't directly steal funds, permanently disabling governance is a critical security failure equivalent to protocol availability DoS.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood**:

- **Attacker Requirements**: Only requires being an authorized proposer (normal governance participant) and ability to get a malicious proposal approved. No elevated privileges needed.

- **Attack Complexity**: LOW - The attack is straightforward:
  1. Create proposal calling `ChangeOrganizationThreshold` with extreme values
  2. Get proposal approved under current (still reasonable) thresholds  
  3. Release proposal - deadlock is immediate and permanent

- **Accidental Occurrence**: Legitimate governance participants might accidentally misconfigure thresholds during routine updates, especially if they don't understand the token supply constraints or the implications of zero rejection thresholds.

- **No Detection/Prevention**: No warnings or validation prevent setting problematic values. Once parameters are committed, the deadlock is irreversible.

- **Social Engineering**: Malicious actors could craft confusing proposal descriptions to trick legitimate voters into approving destructive threshold changes.

## Recommendation

Add token supply validation to the Referendum contract's `Validate` function, similar to Association's member count validation:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    var tokenInfo = GetTokenInfo(organization.TokenSymbol);
    Assert(!string.IsNullOrEmpty(tokenInfo.Symbol), "Token not exists.");
    
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    var tokenSupply = tokenInfo.Supply; // or TotalSupply depending on requirements
    
    return proposalReleaseThreshold.MinimalVoteThreshold <= tokenSupply &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold + 
           proposalReleaseThreshold.MinimalApprovalThreshold <= tokenSupply &&
           proposalReleaseThreshold.MaximalRejectionThreshold + 
           proposalReleaseThreshold.MinimalApprovalThreshold <= tokenSupply;
}
```

Additionally, consider:
1. Enforcing a minimum non-zero value for `MaximalRejectionThreshold` to prevent impossible rejection constraints
2. Validating that whitelist addresses are accessible (though this is harder to verify on-chain)
3. Adding an emergency recovery mechanism controlled by a trusted governance body for extreme cases

## Proof of Concept

```csharp
[Fact]
public async Task ReferendumDeadlock_ImpossibleThreshold_Test()
{
    // Setup: Create organization with reasonable initial thresholds
    var minimalApproveThreshold = 5000;
    var minimalVoteThreshold = 5000;
    var organizationAddress = await CreateOrganizationAsync(
        minimalApproveThreshold, minimalVoteThreshold, 10000, 10000, 
        new[] { DefaultSender });
    
    // Attacker creates proposal to set impossible threshold (exceeds token supply)
    var deadlockThreshold = new ProposalReleaseThreshold
    {
        MinimalVoteThreshold = 1_000_000_000_000, // Far exceeds any realistic token supply
        MinimalApprovalThreshold = 1_000_000_000_000
    };
    
    var proposalId = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair,
        deadlockThreshold,
        nameof(ReferendumContractStub.ChangeOrganizationThreshold),
        organizationAddress,
        ReferendumContractAddress);
    
    // Proposal gets approved under current (still achievable) thresholds
    await ApproveWithMinimalThresholdAsync(proposalId, minimalApproveThreshold);
    
    // Release proposal - deadlock is now active
    var releaseResult = await ReferendumContractStub.Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify deadlock: Try to create recovery proposal
    var recoveryThreshold = new ProposalReleaseThreshold
    {
        MinimalVoteThreshold = minimalVoteThreshold,
        MinimalApprovalThreshold = minimalApproveThreshold
    };
    
    var recoveryProposalId = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair,
        recoveryThreshold,
        nameof(ReferendumContractStub.ChangeOrganizationThreshold),
        organizationAddress,
        ReferendumContractAddress);
    
    // Attempt to approve recovery proposal with all available tokens
    await ApproveWithMinimalThresholdAsync(recoveryProposalId, minimalApproveThreshold);
    
    // Recovery proposal cannot be released - threshold is impossible to reach
    var proposal = await ReferendumContractStub.GetProposal.CallAsync(recoveryProposalId);
    proposal.ToBeReleased.ShouldBeFalse(); // Proves permanent deadlock
    
    // Organization is now permanently locked with impossible thresholds
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```
