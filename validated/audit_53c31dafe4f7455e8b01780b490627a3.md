# Audit Report

## Title
Continuous Block Limit Bypass via Public Key Replacement

## Summary
A miner can bypass the continuous block production limit (8 blocks) by strategically replacing their public key. The `RecordCandidateReplacement` method updates round miner information but fails to update `State.LatestPubkeyToTinyBlocksCount`, creating a pubkey mismatch that causes the counter to reset instead of decrement, allowing production of significantly more consecutive blocks than intended.

## Finding Description

The vulnerability exists in the interaction between candidate key replacement and continuous block tracking in the AEDPoS consensus system.

**Normal Operation**: The consensus contract tracks continuous block production using `State.LatestPubkeyToTinyBlocksCount` to prevent any miner from dominating block production. The counter starts at 7 and decrements with each block. When it reaches -1, validation fails. [1](#0-0) [2](#0-1) 

**The Vulnerability Chain**:

1. **Missing State Update**: When `ReplaceCandidatePubkey` is called in the Election contract, it triggers `RecordCandidateReplacement` in the consensus contract. This method updates `currentRound.RealTimeMinersInformation` with the new pubkey but critically fails to update `State.LatestPubkeyToTinyBlocksCount`: [3](#0-2) 

2. **Counter Reset Logic**: In `ResetLatestProviderToTinyBlocksCount`, when the stored pubkey doesn't match the current block producer's pubkey (recovered from signature), the system resets the counter to 7 instead of decrementing: [4](#0-3) [5](#0-4) 

3. **Entry Point**: The attack uses `ReplaceCandidatePubkey` which requires candidate admin permission that miners typically control: [6](#0-5) 

**Attack Execution**:
- Miner produces blocks with key_1: counter goes 7→6→5→4→3→2→1→0
- Before next block (would fail at -1), miner includes transaction calling `ReplaceCandidatePubkey(key_1, key_2)` in their block
- Consensus contract updates round info but not counter state
- Miner produces next block with key_2
- Counter resets to 7 instead of going to -1
- Repeat with fresh keys for ~70 blocks instead of intended 8

## Impact Explanation

This vulnerability breaks a fundamental consensus rule designed to prevent centralization and reduce fork risk. The continuous block limit was specifically implemented to address these concerns: [7](#0-6) 

**Quantified Harm**:
- **Unfair Economic Advantage**: With 10 prepared keypairs, attacker produces ~70 continuous blocks vs intended 8 blocks, capturing ~9x more mining rewards
- **Centralization Risk**: Single miner dominates block production during their time slot, defeating distributed consensus
- **Network Fork Risk**: Bypassing the limit increases network instability that the limit was designed to prevent
- **Affected Parties**: All honest miners lose mining opportunities and rewards proportional to attacker's excess production

## Likelihood Explanation

**Entry Point Accessibility**: Miners typically control their own candidate admin addresses (set during `AnnounceElection`), making this readily accessible. Old keys are banned after replacement, but there's no limit on using fresh keys: [8](#0-7) 

**Attacker Requirements**:
1. Candidate admin control (standard for miners)
2. Multiple fresh keypairs (trivial to generate)
3. Transaction timing (miner can include own transactions in blocks they produce)

**Execution Feasibility**:
- No rate limiting on `ReplaceCandidatePubkey` calls detected
- Transaction fees negligible compared to additional mining rewards
- Key replacements are legitimate operations that may not trigger immediate scrutiny
- Clear economic incentive with no technical barriers

**Probability Assessment**: High likelihood - technically straightforward with significant financial incentive, no cooldowns, and attacker controls all required resources.

## Recommendation

Update `RecordCandidateReplacement` to also update `State.LatestPubkeyToTinyBlocksCount` when a candidate replacement occurs:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

    // If this candidate is current miner, need to modify current round information.
    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
    realTimeMinerInformation.Pubkey = input.NewPubkey;
    currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
    currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
    if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    // FIX: Update LatestPubkeyToTinyBlocksCount to maintain counter continuity
    var latestCount = State.LatestPubkeyToTinyBlocksCount.Value;
    if (latestCount != null && latestCount.Pubkey == input.OldPubkey)
    {
        State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
        {
            Pubkey = input.NewPubkey,
            BlocksCount = latestCount.BlocksCount
        };
    }

    // Notify Treasury Contract to update replacement information.
    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = input.OldPubkey,
        NewPubkey = input.NewPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ContinuousBlockLimitBypass_ViaPubkeyReplacement_Test()
{
    // Setup: Initialize with test miner and produce blocks until counter reaches 0
    const int maxBlocks = 8;
    var testMinerKeyPair1 = SampleAccount.Accounts[0].KeyPair;
    var testMinerKeyPair2 = SampleAccount.Accounts[1].KeyPair;
    
    // Produce 8 blocks with key1 (counter: 7→6→5→4→3→2→1→0)
    for (int i = 0; i < maxBlocks; i++)
    {
        await ProduceBlockWithKeyPair(testMinerKeyPair1);
    }
    
    // At this point, next block with key1 should fail (counter would go to -1)
    // But call ReplaceCandidatePubkey before that
    var replaceResult = await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(
        new ReplaceCandidatePubkeyInput
        {
            OldPubkey = testMinerKeyPair1.PublicKey.ToHex(),
            NewPubkey = testMinerKeyPair2.PublicKey.ToHex()
        });
    replaceResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Produce next block with key2 - should reset counter to 7 instead of failing
    var blockResult = await ProduceBlockWithKeyPair(testMinerKeyPair2);
    blockResult.Status.ShouldBe(TransactionResultStatus.Mined); // This succeeds (vulnerability)
    
    // Verify we can produce 7 more blocks (total 16 instead of intended 8)
    for (int i = 0; i < 7; i++)
    {
        var result = await ProduceBlockWithKeyPair(testMinerKeyPair2);
        result.Status.ShouldBe(TransactionResultStatus.Mined);
    }
    
    // Total: 16 continuous blocks produced instead of maximum 8
}
```

**Notes**: 
- The vulnerability stems from state inconsistency between round miner information and the continuous block counter
- Each key replacement allows bypassing the limit by resetting the counter
- No rate limiting or cooldown prevents repeated exploitation
- The fix must maintain counter continuity across pubkey replacements to preserve the intended consensus constraint

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-24)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L321-321)
```csharp
        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L246-246)
```csharp
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L17-20)
```csharp
    /// <summary>
    ///     Implemented GitHub PR #1952.
    ///     Adjust (mainly reduce) the count of tiny blocks produced by a miner each time to avoid too many forks.
    /// </summary>
```
