# Audit Report

## Title
Insufficient Validation of ImpliedIrreversibleBlockHeight Enables Consensus Halt via LIB Manipulation

## Summary
The AEDPoS consensus contract fails to validate that `ImpliedIrreversibleBlockHeight` reported by miners is reasonably close to the current block height. This allows colluding miners (>1/3) to prevent Last Irreversible Block (LIB) progression by reporting stale values, triggering automatic chain rollbacks that effectively halt the blockchain.

## Finding Description

The consensus contract expects honest miners to set `ImpliedIrreversibleBlockHeight` equal to `Context.CurrentHeight` when producing blocks: [1](#0-0) 

However, the validation in `LibInformationValidationProvider` only checks that this value does not decrease compared to the previous round: [2](#0-1) 

There is no validation enforcing that `ImpliedIrreversibleBlockHeight` must equal or be within a reasonable range of `Context.CurrentHeight`. Malicious miners can report arbitrarily stale values as long as they don't decrease from their previous submission.

During block processing, the contract stores whatever value miners provide without further verification: [3](#0-2) 

The LIB calculation uses `LastIrreversibleBlockHeightCalculator`, which takes the value at position `(count-1)/3` of sorted implied heights from miners who have mined: [4](#0-3) 

For 21 miners, position 6 (7th element) is used. If 7 or more miners (≥1/3) report stale values, the LIB calculation returns a stale height, preventing LIB progression.

After `max(8, MaximumTinyBlocksCount)` rounds without LIB advancement, the blockchain enters "Severe" status: [5](#0-4) 

This triggers the `IrreversibleBlockHeightUnacceptable` event: [6](#0-5) 

The event processor then enqueues a rollback to the stale LIB height: [7](#0-6) 

Critically, the evil miner detection mechanism only checks for missed time slots, not incorrect LIB reporting: [8](#0-7) 

Malicious miners who continue producing blocks normally while reporting stale `ImpliedIrreversibleBlockHeight` values are not flagged as evil miners and face no penalty.

## Impact Explanation

This vulnerability enables a complete blockchain halt through repeated rollbacks:

1. **Chain Rollback**: When Severe status is reached, the chain automatically rolls back to the stale LIB height, discarding all blocks and transactions produced since then.

2. **Rollback Loop**: Since malicious miners continue reporting stale values, the chain immediately re-enters Severe status after rollback, triggering another rollback. This creates a cycle where the chain cannot make forward progress.

3. **Loss of Liveness**: All network participants lose the ability to execute transactions, deploy contracts, or interact with the blockchain. Economic value is frozen, and the entire blockchain ecosystem becomes non-functional.

4. **Undetected Attack**: Unlike miners who miss time slots, malicious miners reporting incorrect LIB values are not detected or penalized, allowing the attack to continue indefinitely.

This is worse than a storage DoS—it's a complete consensus halt that destroys blockchain availability.

## Likelihood Explanation

**Attacker Requirements:**
- Control of more than 1/3 of elected miners (approximately 7 out of 21 based on typical configurations)
- Ability to modify node software to submit manipulated `ImpliedIrreversibleBlockHeight` values
- Coordination among colluding miners

**Attack Complexity:**
The attack is technically straightforward. Miners simply modify their node software to report stale `ImpliedIrreversibleBlockHeight` values (e.g., a fixed low value or slowly incrementing) while continuing to produce blocks normally. The validation passes because it only checks non-decrease, not reasonableness.

**Economic Considerations:**
Miners must lock significant stakes (typically 100,000 ELF) and risk their reputation. However, the current penalty mechanism only applies to missed time slots. Malicious miners producing blocks with incorrect LIB values face no explicit penalty.

**Likelihood Assessment:**
Medium-Low due to the requirement for >1/3 miner collusion. However, the lack of detection and penalty mechanisms, combined with insufficient validation, makes this a realistic attack vector. Byzantine Fault Tolerance systems should tolerate up to 1/3 Byzantine participants, but this vulnerability violates that guarantee.

## Recommendation

Add validation to enforce that `ImpliedIrreversibleBlockHeight` is within a reasonable range of `Context.CurrentHeight`:

```csharp
// In LibInformationValidationProvider.ValidateHeaderInformation
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0)
{
    var impliedHeight = providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    var currentHeight = validationContext.CurrentHeight; // Need to add to context
    
    // Check non-decrease
    if (baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight > impliedHeight)
    {
        validationResult.Message = "Implied lib height decreased.";
        return validationResult;
    }
    
    // NEW: Check reasonableness - must be within tolerance of current height
    const long maxLagBehindCurrentHeight = 100; // Configurable tolerance
    if (impliedHeight < currentHeight - maxLagBehindCurrentHeight)
    {
        validationResult.Message = "Implied lib height too far behind current height.";
        return validationResult;
    }
}
```

Additionally, extend the evil miner detection mechanism to identify and penalize miners reporting unreasonable `ImpliedIrreversibleBlockHeight` values.

## Proof of Concept

The following test demonstrates the vulnerability by simulating malicious miners reporting stale LIB values:

```csharp
[Fact]
public async Task MaliciousMinersStaleLIB_CausesChainHalt()
{
    // Setup: Initialize consensus with 21 miners
    var miners = GenerateMiners(21);
    await InitializeConsensus(miners);
    
    // Advance to a reasonable block height
    for (int i = 0; i < 100; i++)
    {
        await ProduceNormalBlock(miners[i % 21]);
    }
    var currentHeight = 100;
    
    // Attack: 8 miners (>1/3) report stale ImpliedIrreversibleBlockHeight
    var maliciousCount = 8;
    var staleHeight = 10L; // Far behind current height
    
    for (int round = 0; round < 10; round++)
    {
        for (int i = 0; i < 21; i++)
        {
            var miner = miners[i];
            var impliedHeight = i < maliciousCount ? staleHeight : currentHeight + round * 21 + i;
            
            var updateInput = new UpdateValueInput
            {
                ImpliedIrreversibleBlockHeight = impliedHeight,
                // ... other required fields
            };
            
            // Validation passes despite stale value
            var result = await ConsensusContract.UpdateValue(updateInput);
            result.Status.ShouldBe(TransactionResultStatus.Mined);
        }
        currentHeight += 21;
    }
    
    // Verify: LIB remains stale due to malicious miners
    var currentRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    var libHeight = currentRound.ConfirmedIrreversibleBlockHeight;
    libHeight.ShouldBeLessThan(20L); // LIB stuck at stale height
    
    // After MaximumTinyBlocksCount rounds, chain enters Severe status
    // and IrreversibleBlockHeightUnacceptable event is fired
    var logs = GetLogs<IrreversibleBlockHeightUnacceptable>();
    logs.Count.ShouldBeGreaterThan(0);
    logs[0].DistanceToIrreversibleBlockHeight.ShouldBeGreaterThan(0);
    
    // This triggers automatic rollback, effectively halting the chain
}
```

## Notes

The vulnerability exists because the validation layer trusts miners to report accurate `ImpliedIrreversibleBlockHeight` values without verification. While Byzantine Fault Tolerance systems may fail when ≥1/3 participants are malicious, proper validation would prevent this specific attack vector by rejecting unreasonable values before they enter the LIB calculation. The automatic rollback mechanism, designed to protect against fork scenarios, becomes a weapon for causing chain halt when LIB progression is prevented through validation gaps.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L127-128)
```csharp
            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockHeightUnacceptableLogEventProcessor.cs (L54-64)
```csharp
        if (distanceToLib.DistanceToIrreversibleBlockHeight > 0)
        {
            Logger.LogDebug($"Distance to lib height: {distanceToLib.DistanceToIrreversibleBlockHeight}");
            Logger.LogDebug("Will rollback to lib height.");
            _taskQueueManager.Enqueue(
                async () =>
                {
                    var chain = await _blockchainService.GetChainAsync();
                    await _blockchainService.ResetChainToLibAsync(chain);
                }, KernelConstants.UpdateChainQueueName);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```
