# Audit Report

## Title
Negative LIB Height Bypasses Validation in NextRound, Causing Consensus DoS

## Summary
The AEDPoS consensus contract fails to validate that `ConfirmedIrreversibleBlockHeight` is non-negative during `NextRound` transitions. A malicious miner can inject a negative LIB height into the consensus state, causing all miners to be immediately limited to producing only 1 block at a time, effectively performing a denial-of-service attack on blockchain consensus.

## Finding Description

The vulnerability exists due to a missing validation step in the consensus validation framework. When a miner produces a block with `NextRound` behavior, the consensus extra data undergoes validation before execution, but the validation logic treats different consensus behaviors differently.

**Root Cause**: The `NextRoundInput.Create()` method directly copies `ConfirmedIrreversibleBlockHeight` from the current round without any validation to ensure the value is non-negative. [1](#0-0)  The protobuf schema defines this field as `int64` (signed integer), which permits negative values. [2](#0-1) 

**Validation Gap**: The `ValidateBeforeExecution` method applies different validators based on the consensus behavior type. For `NextRound` behavior, it only adds `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider`, explicitly excluding `LibInformationValidationProvider`. [3](#0-2) 

In contrast, `UpdateValue` behavior correctly receives LIB validation through `LibInformationValidationProvider`. [4](#0-3) 

The `LibInformationValidationProvider` would catch negative LIB values by comparing them against the base round's LIB, but it is not applied to NextRound behavior. [5](#0-4) 

The `RoundTerminateValidationProvider` only validates that the round number increments correctly and that InValues are null, without checking LIB height validity. [6](#0-5) 

**Execution Path**: When a malicious miner produces a block with `NextRound` behavior containing a negative `ConfirmedIrreversibleBlockHeight`, the validation is called through the ACS4 interface. [7](#0-6) 

The validation passes because `LibInformationValidationProvider` is not applied. The `NextRound` transaction then executes via `ProcessConsensusInformation`, which converts the malicious input to a Round object. [8](#0-7) 

The corrupted round is stored to state without validation. [9](#0-8) 

State storage occurs via `AddRoundInformation`. [10](#0-9) 

## Impact Explanation

The negative LIB height causes critical malfunction in the consensus mechanism's block production throttling system.

**Direct Impact**: The `GetMaximumBlocksCount()` method reads the corrupted LIB height from the current round. [11](#0-10) 

When calculating the distance to the last irreversible block, a negative `libBlockHeight` (e.g., -1) combined with a positive `currentHeight` (e.g., 1000) produces an artificially huge distance. [12](#0-11) 

This triggers the `Severe` mining status condition, which forces the method to return 1, limiting ALL miners to producing only 1 block at a time. [13](#0-12) 

**Persistence**: The negative value can propagate to subsequent rounds because `GenerateNextRoundInformation` copies the LIB height forward without validation. [14](#0-13) 

This represents a severe denial-of-service attack on consensus. The blockchain's throughput is drastically reduced as miners are artificially limited to producing 1 block per time slot instead of the normal maximum (typically 8+ blocks).

## Likelihood Explanation

**Attacker Prerequisites**: The attacker must be an active miner in the current miner list, which is verified by the `PreCheck` method. [15](#0-14) 

**Attack Feasibility**: The attack is straightforward to execute:
1. The attacker (who is an elected miner) waits for their turn to produce a block with `NextRound` behavior
2. They craft malicious consensus extra data with `ConfirmedIrreversibleBlockHeight` set to -1
3. The block is validated using `ValidateBeforeExecution`, which does not apply LIB validation for NextRound
4. The validation passes, and the malicious round data is stored to state
5. Immediately, `GetMaximumBlocksCount` is called and returns 1, triggering the DoS

**Realistic Scenario**: Any elected miner can perform this attack. There are no economic costs beyond normal block production. The attack does not require special state setup or coordination. Detection would occur through `IrreversibleBlockHeightUnacceptable` events and drastically reduced block production rate.

## Recommendation

Add `LibInformationValidationProvider` to the validation chain for `NextRound` behavior:

```csharp
case AElfConsensusBehaviour.NextRound:
    // Is sender's order of next round correct?
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    // Add LIB validation to prevent negative or regressing values
    validationProviders.Add(new LibInformationValidationProvider());
    break;
```

This ensures that negative LIB heights are rejected during NextRound transitions, maintaining the consensus invariant that LIB heights are always non-negative and monotonically increasing.

## Proof of Concept

```csharp
[Fact]
public async Task NegativeLIBHeight_BypassesValidation_InNextRound()
{
    // Setup: Initialize consensus with valid round
    var initialRound = GenerateValidRound(1);
    await InitializeConsensus(initialRound);
    
    // Attacker crafts NextRound input with negative LIB
    var maliciousNextRound = new Round
    {
        RoundNumber = 2,
        ConfirmedIrreversibleBlockHeight = -1,  // Negative value
        ConfirmedIrreversibleBlockRoundNumber = 1,
        RealTimeMinersInformation = { initialRound.RealTimeMinersInformation }
    };
    
    var maliciousInput = NextRoundInput.Create(maliciousNextRound, GenerateRandomHash());
    
    // Validation should fail but doesn't due to missing LibInformationValidationProvider
    var validationResult = await ConsensusContract.ValidateConsensusBeforeExecution(
        new AElfConsensusHeaderInformation
        {
            Behaviour = AElfConsensusBehaviour.NextRound,
            Round = maliciousNextRound,
            SenderPubkey = InitialMiners[0]
        }.ToByteString());
    
    // Assertion: Validation incorrectly passes
    Assert.True(validationResult.Success);
    
    // Execute the malicious NextRound transaction
    await ConsensusContract.NextRound(maliciousInput);
    
    // Verify impact: GetMaximumBlocksCount returns 1 (Severe status)
    var maxBlocksCount = await ConsensusContract.GetMaximumBlocksCount(new Empty());
    Assert.Equal(1, maxBlocksCount.Value);
    
    // Verify: Negative LIB stored in state
    var currentRound = await ConsensusContract.GetCurrentRoundInformation(new Empty());
    Assert.Equal(-1, currentRound.ConfirmedIrreversibleBlockHeight);
}
```

## Notes

The vulnerability allows elected miners to violate the fundamental consensus invariant that LIB heights are non-negative. While the impact may be temporary (subsequent `UpdateValue` transactions recalculate LIB from positive implied heights and would restore proper values), the ability to inject invalid consensus state and trigger immediate throughput degradation represents a serious security flaw. The attack is repeatable by any elected miner on every NextRound they produce.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L16-16)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
```

**File:** protobuf/aedpos_contract.proto (L257-257)
```text
    int64 confirmed_irreversible_block_height = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-20)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-34)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-330)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L24-26)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```
