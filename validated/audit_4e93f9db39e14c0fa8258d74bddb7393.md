# Audit Report

## Title
Missing LIB Monotonicity Validation in NextRound Allows Consensus State Corruption

## Summary
The AEDPoS consensus contract fails to validate that `ConfirmedIrreversibleBlockHeight` (LIB) maintains its monotonically increasing invariant when processing `NextRound` transitions. A malicious miner can submit a `NextRound` transaction with decreased LIB values, bypassing validation and corrupting the consensus state stored on-chain.

## Finding Description

The vulnerability exists in the consensus validation pipeline where different validation providers are conditionally applied based on the consensus behavior type.

**Root Cause:**

The `ValidateBeforeExecution` method applies different validation providers based on consensus behavior. [1](#0-0) 

For `UpdateValue` behavior, the validation includes `LibInformationValidationProvider` which enforces LIB monotonicity. However, for `NextRound` behavior, only `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` are applied - the critical `LibInformationValidationProvider` is omitted.

The `LibInformationValidationProvider` contains the only check that prevents LIB from decreasing. [2](#0-1) 

**Attack Path:**

1. A miner with active mining rights calls the public `NextRound` method. [3](#0-2) 

2. The attacker crafts a `NextRoundInput` with `ConfirmedIrreversibleBlockHeight` set to a value lower than the current consensus state's LIB.

3. Validation occurs via `ValidateConsensusBeforeExecution`. [4](#0-3) 

4. Since `LibInformationValidationProvider` is not in the validation pipeline for `NextRound`, the malicious LIB values pass validation.

5. The `RoundTerminateValidationProvider` that IS applied only checks round number and InValue fields. [5](#0-4) 

6. Execution proceeds through `ProcessNextRound`. [6](#0-5) 

7. The input is converted to a Round object via `ToRound()`, which preserves the malicious LIB values. [7](#0-6) 

8. The corrupted round is stored to state via `AddRoundInformation`. [8](#0-7) 

9. The consensus state now contains a decreased LIB value, violating the monotonicity invariant.

## Impact Explanation

**Critical Severity** - This vulnerability breaks a fundamental consensus invariant with protocol-wide implications:

**Consensus Integrity Violation:**
- The Last Irreversible Block (LIB) height is a core finality indicator - once a block reaches LIB status, it should never become reversible
- Decreasing the LIB effectively reverts finality decisions, creating uncertainty about transaction permanence
- All nodes rely on consensus state for block confirmation and chain progression

**Cross-Chain Impact:**
- Cross-chain operations depend on LIB for indexing parent-chain blocks and validating cross-chain proofs
- A corrupted LIB can cause cross-chain transfer verification failures between main chain and side chains
- Side chain synchronization with main chain relies on accurate LIB values

**Protocol-Wide State Corruption:**
- When generating the next round, the corrupted LIB is propagated forward to future rounds. [9](#0-8) [10](#0-9) 
- Other system contracts may query the consensus LIB for critical operations
- Election contract snapshots and treasury releases may execute based on corrupted round information

## Likelihood Explanation

**High Likelihood** - The attack is straightforward and accessible to any active miner:

**Attacker Prerequisites:**
- Must be an active miner in the current miner list (obtainable through election)
- No special privileges beyond standard mining rights required. [11](#0-10) 
- No economic cost beyond normal block production

**Attack Complexity:**
- Low complexity - attacker simply modifies `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields in the `NextRoundInput` parameter
- The transaction generation flow shows how miners create NextRound transactions. [12](#0-11) 
- Miners control the transaction parameters when producing their NextRound block

**Detection Difficulty:**
- The malicious transaction passes all validation checks normally
- No validation after execution catches the discrepancy. [13](#0-12) 
- State corruption manifests only when dependent systems query the corrupted LIB values

## Recommendation

Add `LibInformationValidationProvider` to the validation pipeline for `NextRound` behavior to enforce LIB monotonicity:

In `AEDPoSContract_Validation.cs`, modify the validation provider selection:

```csharp
case AElfConsensusBehaviour.NextRound:
    // Is sender's order of next round correct?
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    // Add LIB validation to prevent state corruption
    validationProviders.Add(new LibInformationValidationProvider());
    break;
```

This ensures that any attempt to decrease LIB values in NextRound transactions will be rejected during validation, maintaining the critical monotonicity invariant.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Setting up a consensus round with `ConfirmedIrreversibleBlockHeight = 100`
2. Having an active miner call `NextRound` with `ConfirmedIrreversibleBlockHeight = 50` (decreased)
3. Observing that the transaction succeeds without validation failure
4. Verifying that the stored consensus state now contains LIB = 50, violating monotonicity

The core issue is that the validation logic at lines 84-88 in `AEDPoSContract_Validation.cs` does not include `LibInformationValidationProvider` for NextRound behavior, while lines 14-21 in `LibInformationValidationProvider.cs` contain the ONLY check preventing LIB decrease. This creates an exploitable gap where NextRound transactions bypass LIB monotonicity validation entirely.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L164-171)
```csharp
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L244-245)
```csharp
        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L292-293)
```csharp
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
```
