# Audit Report

## Title
Retroactive Vote Manipulation Through Dynamic Membership Changes in Association Contract

## Summary
The Association contract's vote counting mechanism evaluates votes based on current membership status rather than membership status at the time of voting, enabling retroactive invalidation of votes through membership changes.

## Finding Description

The vulnerability exists in a temporal inconsistency between vote recording and vote counting in the Association contract.

**Vote Recording Phase:**
When members cast votes via `Approve()`, `Reject()`, or `Abstain()`, the contract verifies membership at vote time and records the vote permanently in the proposal's lists. [1](#0-0) 

**Vote Counting Phase:**
When `Release()` is called, it invokes `IsReleaseThresholdReached()` to verify if the proposal can be executed. [2](#0-1) 

The critical flaw lies in the vote counting functions that filter votes against the **current** membership list. The `CheckEnoughVoteAndApprovals()` method counts approvals only from current members. [3](#0-2) 

Similarly, rejection and abstention counts are filtered through current membership. [4](#0-3) 

The `Contains()` method checks against the organization's current member list. [5](#0-4) 

**Membership Manipulation:**
Organizations can modify membership through `AddMember()` and `RemoveMember()` methods callable by the organization address itself (via governance proposals). [6](#0-5) [7](#0-6) 

**Attack Scenario:**
1. Organization with 7 members (A, B, C, D, E, F, G) has MinimalApprovalThreshold=4
2. Proposal P1 receives 4 approvals from members A, B, C, D
3. Organization passes separate proposal P2 to remove member B
4. When Release(P1) is attempted, only 3 approvals count (A, C, D remain members)
5. P1 cannot be released despite legitimately meeting the threshold when votes were cast

## Impact Explanation

**Governance Integrity Compromise:**
- Proposals that legitimately reached approval thresholds can be prevented from passing by removing approving members
- Proposals that should fail can be made to pass by removing rejecting members
- Organization members' votes are retroactively invalidated without their knowledge or consent

**Affected Parties:**
- Organization members whose votes are nullified after casting them
- Proposers whose proposals fail due to manipulation
- The entire governance process integrity for Association organizations

**Severity: Medium** - While it requires passing a membership change proposal first (which itself requires threshold votes), such changes are legitimate operations that mask the manipulation. The impact is governance integrity compromise rather than direct fund loss.

## Likelihood Explanation

**Attacker Capabilities:**
An attacker with majority control can pass membership change proposals and systematically manipulate pending proposals through strategic member removal/addition.

**Attack Complexity:**
Low - only requires calling standard `AddMember`/`RemoveMember` through governance proposals. No complex transaction sequences or external dependencies required.

**Detection Constraints:**
- Membership changes appear as legitimate governance actions
- The connection between membership changes and vote invalidation is not transparent
- No events or warnings indicate that existing votes are being invalidated

**Likelihood: Medium-High** - Once an attacker gains governance majority, membership changes are expected operations, making the attack vector unobvious. The lack of vote immutability protection makes this exploitable whenever membership changes occur during active proposal voting periods.

## Recommendation

Implement vote snapshot mechanism that captures membership status at vote time rather than at counting time. Two approaches:

**Approach 1: Record voter membership at vote time**
Store a mapping of voters who were valid members when they voted, and count only those votes during release without re-validating current membership.

**Approach 2: Add proposal-level membership snapshot**
When a proposal is created, store the current member list hash. During vote counting, verify votes only against members who were present at proposal creation time.

**Approach 3: Add timestamp-based validation**
Record when each vote was cast and when membership changes occurred, ensuring votes cast before membership changes remain valid.

The recommended fix is Approach 1 as it preserves the intent that only legitimate members at voting time should have their votes counted, while preventing retroactive invalidation.

## Proof of Concept

```csharp
[Fact]
public async Task VoteManipulation_ThroughMembershipChange_Test()
{
    // Setup: Create organization with 7 members, threshold = 4
    var createInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { Member1, Member2, Member3, Member4, Member5, Member6, Member7 }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 4,
            MinimalVoteThreshold = 4,
            MaximalAbstentionThreshold = 0,
            MaximalRejectionThreshold = 0
        },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { Member1 } }
    };
    var orgAddress = await AssociationContractStub.CreateOrganization.SendAsync(createInput);
    
    // Step 1: Create and vote on Proposal P1
    var proposalId = await CreateProposalAsync(orgAddress.Output, "TestMethod", new Empty());
    await ApproveAsync(Member1Stub, proposalId);
    await ApproveAsync(Member2Stub, proposalId);
    await ApproveAsync(Member3Stub, proposalId);
    await ApproveAsync(Member4Stub, proposalId); // 4 approvals - meets threshold
    
    // Verify proposal can be released
    var proposal1 = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal1.ToBeReleased.ShouldBeTrue(); // Proposal is ready
    
    // Step 2: Pass membership removal proposal to remove Member2
    var removeProposalId = await CreateProposalAsync(orgAddress.Output, "RemoveMember", Member2);
    await ApproveAsync(Member1Stub, removeProposalId);
    await ApproveAsync(Member5Stub, removeProposalId);
    await ApproveAsync(Member6Stub, removeProposalId);
    await ApproveAsync(Member7Stub, removeProposalId);
    await ReleaseProposalAsync(Member1Stub, removeProposalId);
    
    // Step 3: Verify P1 can no longer be released
    var proposal2 = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal2.ToBeReleased.ShouldBeFalse(); // VULNERABILITY: Now only 3 valid approvals
    
    // Attempting to release P1 should fail
    var releaseResult = await Member1Stub.Release.SendWithExceptionAsync(proposalId);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
}
```

## Notes

This vulnerability demonstrates a fundamental design flaw in temporal consistency of the voting system. The core issue is that the contract treats membership as a static property when it should be treated as a time-dependent property. This creates a window where legitimate governance decisions can be manipulated through seemingly unrelated membership management actions.

The vulnerability is particularly insidious because:
1. Membership changes are legitimate governance operations
2. The connection between membership changes and vote invalidation is not obvious
3. No warnings or protections exist to prevent this behavior
4. The attack requires no special privileges beyond normal governance majority

This affects all Association-based governance organizations in the AElf ecosystem and should be addressed as a priority governance integrity issue.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-188)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-45)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```
