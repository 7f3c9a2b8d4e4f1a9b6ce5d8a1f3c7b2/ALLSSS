# Audit Report

## Title
Non-Retroactive Vote Weight Updates Allow Early Voters to Maintain Permanently Inflated Profit Shares After Interest Rate Decreases

## Summary
The Election contract's `SetVoteWeightInterest()` function updates global interest rate parameters but fails to retroactively recalculate existing vote weights. When governance decreases interest rates, voters who locked tokens under higher rates permanently maintain inflated profit shares compared to new voters with identical stakes and lock periods, creating systemic unfairness in welfare profit distribution.

## Finding Description

The vulnerability exists at the intersection of three contract mechanisms:

**1. Non-Retroactive Interest Rate Updates**

The `SetVoteWeightInterest()` function updates only the global `State.VoteWeightInterestList.Value` configuration without any logic to recalculate existing vote weights stored as profit shares. [1](#0-0) 

**2. One-Time Weight Calculation**

When users call `Vote()`, the function calculates weight once using the current interest rates by calling `GetVotesWeight()` at line 443, then permanently stores this calculated weight as "shares" in the profit scheme via `AddBeneficiaryToVoter()`. [2](#0-1) 

The `GetVotesWeight()` function reads the current `State.VoteWeightInterestList.Value` and applies a compound interest formula that exponentially increases weight based on lock duration. [3](#0-2) 

These calculated weights become immutable profit shares through `AddBeneficiaryToVoter()`, which sets `Shares = votesWeight` in the welfare profit scheme. [4](#0-3) 

**3. Shares Preservation in Profit Details**

Vote weights stored as profit shares persist unchanged throughout the vote's lifetime. Even when `ExtendVoterWelfareProfits()` is called during vote target changes, it calls `FixProfitDetail` which only updates period boundaries while explicitly preserving the original shares. [5](#0-4) 

The Profit contract's `FixProfitDetail()` method at line 297 explicitly clones the existing detail, then at lines 299-301 only updates `StartPeriod` and `EndPeriod` - the `Shares` field is never modified. [6](#0-5) 

**Evidence of Abandoned Implementation**

A `FixTotalWeightsInput` message is defined in the protocol but has no corresponding implementation method in the codebase. [7](#0-6) 

The `WeightsAlreadyFixedMap` state variable exists but is never set to `true` anywhere in the codebase - it's only checked and removed in withdrawal logic at lines 665-669, indicating an abandoned feature. [8](#0-7) 

## Impact Explanation

**Severity: High**

This creates measurable unfair profit distribution:

**Concrete Example:**
- Governance decreases 365-day interest from `Interest=1, Capital=1000` to `Interest=1, Capital=10000`
- Early voter: Locked 1M tokens for 365 days under old rates → Weight = (1.001)^365 × 1,000,000 ≈ 1,440,000 shares
- New voter: Locks identical 1M tokens for 365 days under new rates → Weight = (1.0001)^365 × 1,000,000 ≈ 1,037,000 shares
- **Result**: Early voter receives ~39% more welfare profits for identical economic commitment

**Protocol Impact:**
- Violates economic fairness invariant: identical stakes should receive identical rewards
- Creates permanent two-tier voter system until old votes naturally expire (can be years)
- Undermines governance authority - interest rate policy changes fail to apply uniformly
- Enables rational actors to front-run governance proposals for permanent advantage

**Who Is Affected:**
- All new voters receive proportionally less profit than legacy voters
- The welfare profit distribution scheme becomes systematically inequitable
- This affects multiple voters across any rate decrease event

## Likelihood Explanation

**Likelihood: High**

**Preconditions:**
- Governance decides to decrease interest rates (realistic economic policy adjustment)
- Voters have active votes under old rates (common scenario)

**Attack Complexity: Low**
1. Monitor public governance proposals for interest rate decreases
2. Call `Vote()` with maximum amount and longest lock before proposal execution
3. Maintain inflated weight throughout lock period with no further action required

**Economic Rationality: High**
- Clear financial incentive with quantifiable ~39% advantage
- No risk beyond opportunity cost of locked capital (which is returned after lock period)
- Rational economic actors will naturally maximize returns under available rules

**Feasibility:**
- `Vote()` is a public, unrestricted function
- Front-running governance execution is trivial on public blockchains
- Single transaction execution
- Issue persists across all future rate decreases until fixed

## Recommendation

Implement a mechanism to retroactively update vote weights when interest rates change:

1. **Complete the `FixTotalWeights` implementation**: Implement the abandoned `FixTotalWeightsInput` functionality to allow governance to trigger weight recalculation for existing votes.

2. **Add retroactive recalculation to `SetVoteWeightInterest`**: After updating interest rates, iterate through active votes and recalculate their weights using the new rates, then update the corresponding profit shares via the Profit contract.

3. **Implement gradual migration**: For gas efficiency, allow batch processing of vote weight updates rather than recalculating all votes in a single transaction.

4. **Add transition period**: Consider implementing a grace period where both old and new rates are honored before full transition, reducing front-running incentives.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task VoteWeightNotRetroactivelyUpdated_CausesUnfairDistribution()
{
    // Setup: Initial interest rate configuration
    var initialInterestList = new VoteWeightInterestList
    {
        VoteWeightInterestInfos = { new VoteWeightInterest { Day = 365, Interest = 1, Capital = 1000 } }
    };
    await ElectionContractStub.SetVoteWeightInterest.SendAsync(initialInterestList);
    
    // Early voter locks 1M tokens for 365 days under high interest
    var earlyVoteResult = await ElectionContractStub.Vote.SendAsync(new VoteMinerInput
    {
        CandidatePubkey = "candidate1",
        Amount = 1_000_000,
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(365)
    });
    var earlyVoteId = earlyVoteResult.Output;
    
    // Get early voter's profit shares
    var earlyVoterShares = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = WelfareHash,
        Beneficiary = DefaultSender
    });
    var earlyShares = earlyVoterShares.Details[0].Shares; // Should be ~1,440,000
    
    // Governance decreases interest rates
    var newInterestList = new VoteWeightInterestList
    {
        VoteWeightInterestInfos = { new VoteWeightInterest { Day = 365, Interest = 1, Capital = 10000 } }
    };
    await ElectionContractStub.SetVoteWeightInterest.SendAsync(newInterestList);
    
    // New voter locks identical stake under low interest
    var newVoteResult = await ElectionContractStub.Vote.SendAsync(new VoteMinerInput
    {
        CandidatePubkey = "candidate1",
        Amount = 1_000_000,
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(365)
    });
    
    // Get new voter's profit shares
    var newVoterShares = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = WelfareHash,
        Beneficiary = NewVoterAddress
    });
    var newShares = newVoterShares.Details[0].Shares; // Should be ~1,037,000
    
    // Verify unfair distribution: early voter has ~39% more shares for identical commitment
    var advantageRatio = (decimal)earlyShares / newShares;
    Assert.True(advantageRatio > 1.35m); // Early voter has >35% advantage
    
    // Verify early voter's shares were NOT updated retroactively
    var earlyVoterSharesAfter = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = WelfareHash,
        Beneficiary = DefaultSender
    });
    Assert.Equal(earlyShares, earlyVoterSharesAfter.Details[0].Shares); // Unchanged
}
```

**Notes:**
- This vulnerability represents a genuine economic fairness issue in the profit distribution mechanism
- The abandoned `FixTotalWeightsInput` and unused `WeightsAlreadyFixedMap` indicate the developers were aware of this issue but did not complete the implementation
- The issue compounds over time as more votes are created under different rate regimes
- While governance controls rate changes (trusted), the inequality affects regular untrusted users who vote at different times

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-160)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }

        var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L189-208)
```csharp
    public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
        // ReSharper disable once PossibleNullReferenceException
        foreach (var info in input.VoteWeightInterestInfos)
        {
            Assert(info.Capital > 0, "invalid input");
            Assert(info.Day > 0, "invalid input");
            Assert(info.Interest > 0, "invalid input");
        }

        Assert(input.VoteWeightInterestInfos.GroupBy(x => x.Day).Count() == input.VoteWeightInterestInfos.Count,
            "repeat day input");
        var orderList = input.VoteWeightInterestInfos.OrderBy(x => x.Day).ToArray();
        input.VoteWeightInterestInfos.Clear();
        input.VoteWeightInterestInfos.AddRange(orderList);
        State.VoteWeightInterestList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L421-443)
```csharp
    public override Hash Vote(VoteMinerInput input)
    {
        // Check candidate information map instead of candidates. 
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);

        var electorPubkey = Context.RecoverPublicKey();

        var lockSeconds = (input.EndTimestamp - Context.CurrentBlockTime).Seconds;
        AssertValidLockSeconds(lockSeconds);

        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;

        UpdateElectorInformation(electorPubkey, input.Amount, voteId);

        var candidateVotesAmount = UpdateCandidateInformation(input.CandidatePubkey, input.Amount, voteId);

        LockTokensOfVoter(input.Amount, voteId);
        TransferTokensToVoter(input.Amount);
        CallVoteContractVote(input.Amount, input.CandidatePubkey, voteId);
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```

**File:** protobuf/election_contract.proto (L530-533)
```text
message FixTotalWeightsInput {
    repeated aelf.Hash vote_ids = 1;
    
}
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L99-99)
```csharp
    public MappedState<Hash, bool> WeightsAlreadyFixedMap { get; set; }
```
