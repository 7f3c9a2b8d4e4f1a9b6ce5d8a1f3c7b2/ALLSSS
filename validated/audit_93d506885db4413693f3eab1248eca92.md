# Audit Report

## Title
Last Irreversible Block (LIB) Progression Can Be Prevented Through Insufficient Miner Overlap Between Consecutive Rounds

## Summary
The AEDPoS consensus contract's LIB calculation mechanism can freeze when fewer than MinersCountOfConsent (2/3+1) miners who produced blocks in the current round also produced blocks in the previous round. This causes the Last Irreversible Block height to stop advancing while block production continues normally, breaking finality guarantees, cross-chain operations, and degrading blockchain performance.

## Finding Description

The vulnerability exists in the `LastIrreversibleBlockHeightCalculator.Deconstruct()` method which calculates the Last Irreversible Block (LIB) height during consensus operations. [1](#0-0) 

The LIB calculation process:

1. **Retrieves miners who produced blocks in the current round** - The method calls `GetMinedMiners()` to identify active miners in the current round [2](#0-1) 

2. **Fetches `ImpliedIrreversibleBlockHeight` values from previous round** - The filtering mechanism only includes miners with `ImpliedIrreversibleBlockHeight > 0` [3](#0-2) 

3. **Checks consensus threshold** - `MinersCountOfConsent` is calculated as `RealTimeMinersInformation.Count * 2 / 3 + 1` [4](#0-3) 

4. **Returns libHeight = 0 if insufficient overlap exists** - When the filtered count is below the threshold, the method returns 0 [5](#0-4) 

**Critical Issue**: When new rounds are generated, `MinerInRound` instances are created without explicitly initializing `ImpliedIrreversibleBlockHeight`, which defaults to 0 [6](#0-5) 

When a miner produces a block, their `ImpliedIrreversibleBlockHeight` is set to the current height [7](#0-6) 

The LIB update check prevents updates when `libHeight = 0` or when it's not greater than the current LIB [8](#0-7) 

**Trigger Conditions**: This occurs when fewer than 2/3+1 of the miners producing blocks in round N+1 also produced blocks in round N through:

1. **Network Recovery Scenarios**: After network partitions, when >1/3 of miners were offline in round N and recover to produce blocks in round N+1
2. **Byzantine Coordination**: >1/3 of miners deliberately alternate their participation across rounds  
3. **Evil Miner Replacements**: When miners are replaced at term boundaries after exceeding the tolerable missed time slots threshold [9](#0-8) [10](#0-9) 

## Impact Explanation

This vulnerability has **HIGH severity** due to multiple critical impacts:

**1. Cross-Chain Operations Failure**: When LIB freezes, the `IrreversibleBlockFound` event stops firing, breaking cross-chain synchronization mechanisms that depend on it for safety guarantees [11](#0-10) 

**2. Finality Guarantees Compromised**: No new blocks become irreversible while the LIB is frozen, leaving all recent transactions in an unfinalized state indefinitely.

**3. Blockchain Performance Degradation**: The frozen LIB causes mining status degradation tracked by the gap between current round and LIB round [12](#0-11) 

The blockchain transitions from Normal → Abnormal → Severe status. In Severe status, the maximum blocks count is reduced to 1, severely crippling block production [13](#0-12) [14](#0-13) 

**4. Operational Deception**: The chain continues producing blocks normally, making the LIB freeze difficult to detect until cross-chain operations fail or performance degrades significantly.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

**Legitimate Trigger Scenarios**:
- Network disruptions causing >1/3 of miners to miss round N while recovering for round N+1 (common in distributed systems)
- System recovery after outages where miner participation patterns are disrupted
- Term changes involving evil miner replacements where new miners lack overlap with the previous term

**Byzantine Attack Scenario**:
- Requires coordination of >1/3 of miners to alternate participation
- Economic cost includes mining reward loss during skipped rounds
- Miners can sustain the attack for up to 3 days (4320 missed slots) before being marked as evil [9](#0-8) 

**Detection Difficulty**: The vulnerability is difficult to detect because block production continues normally. The LIB freeze only becomes apparent when cross-chain operations fail, applications check LIB height, or the blockchain enters Severe mining status.

**Recovery**: No explicit recovery mechanism exists. Recovery relies on natural stabilization when miner participation normalizes to restore sufficient overlap between consecutive rounds.

## Recommendation

Implement one or more of the following mitigations:

1. **Carry Forward ImpliedIrreversibleBlockHeight**: When generating new rounds, copy the `ImpliedIrreversibleBlockHeight` from the previous round for miners who continue to the next round, ensuring continuity of LIB progression.

2. **LIB Fallback Mechanism**: If insufficient overlap exists, use an alternative calculation method such as taking the minimum `ImpliedIrreversibleBlockHeight` from miners who did produce blocks in the current round, or maintain the previous LIB value explicitly rather than returning 0.

3. **Circuit Breaker**: Add monitoring that detects when LIB hasn't advanced for a threshold number of rounds and triggers automatic recovery procedures or alerts.

4. **Minimum Overlap Requirement**: Enforce stricter miner participation requirements at the protocol level to ensure minimum overlap between consecutive rounds, preventing the condition from occurring.

## Proof of Concept

```csharp
// Test demonstrating LIB freeze with insufficient miner overlap
[Fact]
public async Task LIB_Freezes_With_Insufficient_Miner_Overlap()
{
    // Setup: Initialize consensus with 5 miners
    await InitializeCandidates(5);
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Round 1: Miners 1, 2, 3 produce blocks (3/5 = 60%)
    foreach (var miner in new[] { 0, 1, 2 })
    {
        var keyPair = InitialCoreDataCenterKeyPairs[miner];
        var tester = GetAEDPoSContractStub(keyPair);
        var minerInfo = firstRound.RealTimeMinersInformation.Values.First(m => m.Pubkey == keyPair.PublicKey.ToHex());
        BlockTimeProvider.SetBlockTime(minerInfo.ExpectedMiningTime);
        
        var input = CreateUpdateValueInput(keyPair);
        await tester.UpdateValue.SendAsync(input);
    }
    
    var libAfterRound1 = (await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty())).ConfirmedIrreversibleBlockHeight;
    
    // Advance to Round 2
    await AdvanceToNextRound();
    var secondRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Round 2: Different miners 3, 4 produce blocks (only miner 3 overlaps)
    // Overlap = 1/5 = 20% < MinersCountOfConsent (2/3+1 = 4/5 = 80%)
    foreach (var miner in new[] { 2, 3, 4 })
    {
        var keyPair = InitialCoreDataCenterKeyPairs[miner];
        var tester = GetAEDPoSContractStub(keyPair);
        var minerInfo = secondRound.RealTimeMinersInformation.Values.First(m => m.Pubkey == keyPair.PublicKey.ToHex());
        BlockTimeProvider.SetBlockTime(minerInfo.ExpectedMiningTime);
        
        var input = CreateUpdateValueInput(keyPair);
        await tester.UpdateValue.SendAsync(input);
    }
    
    var libAfterRound2 = (await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty())).ConfirmedIrreversibleBlockHeight;
    
    // Assert: LIB should be frozen (not advanced)
    libAfterRound2.ShouldBe(libAfterRound1); // LIB did not advance
    
    // Additional rounds will show continued freeze and eventual Severe status
    await AdvanceToNextRound();
    var maxBlocksCount = await AEDPoSContractStub.GetMaximumBlocksCount.CallAsync(new Empty());
    maxBlocksCount.Value.ShouldBeLessThan(8); // Degraded from normal maximum
}
```

## Notes

The vulnerability is particularly insidious because:

1. **Silent Failure**: Block production continues normally, masking the underlying LIB freeze until downstream systems fail
2. **Cascading Effects**: As LIB freezes, mining status degrades, which can further disrupt miner participation, potentially extending the freeze
3. **Cross-Chain Impact**: Any dependent chains or cross-chain operations relying on finality will stall
4. **No Automatic Recovery**: The system has no built-in mechanism to detect and recover from this state, relying entirely on miners naturally restoring overlap patterns

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L9-34)
```csharp
    private class LastIrreversibleBlockHeightCalculator
    {
        private readonly Round _currentRound;
        private readonly Round _previousRound;

        public LastIrreversibleBlockHeightCalculator(Round currentRound, Round previousRound)
        {
            _currentRound = currentRound;
            _previousRound = previousRound;
        }

        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L24-28)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-66)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L119-129)
```csharp
        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
```
