# Audit Report

## Title
Scheme Manager Can DOS Profit Claiming Through Unlimited Empty Period Creation

## Summary
A malicious scheme manager can repeatedly call `DistributeProfits` with an empty `AmountsMap`, causing period counters to increment indefinitely without distributing actual profits. This creates a permanent denial-of-service condition where beneficiaries become unable to claim their legitimate profits due to an infinite loop in the claiming mechanism.

## Finding Description

The vulnerability exists in the TokenHolder and Profit contracts' period management logic. The `DistributeProfits` function unconditionally increments period counters regardless of whether profits were actually distributed. [1](#0-0) 

In TokenHolder's `DistributeProfits`, the authorization check explicitly allows the scheme manager to call this function. The function conditionally adds `AmountsMap` only if non-empty (line 141), but unconditionally increments the period counter (line 144). [2](#0-1) 

The underlying Profit contract has the same flaw. It only burns profits if the period is negative OR totalShares is zero or less, but when totalShares > 0 (normal operation with beneficiaries), the CurrentPeriod increments unconditionally even when no profits are distributed. [3](#0-2) 

The critical issue emerges during profit claiming. The `ProfitAllPeriods` function iterates through periods from `LastProfitPeriod` to `maxProfitPeriod`. Empty periods are skipped via `continue` statements, but crucially, `lastProfitPeriod` is only updated (line 908) when a profitable period is found. [4](#0-3) 

The update to `lastProfitPeriod` only occurs inside the non-view conditional block after finding a period with actual profits. [5](#0-4) 

**Attack Scenario:**
1. Attacker creates a scheme by calling `CreateScheme`, becoming the scheme manager (anyone can do this) [6](#0-5) 
2. Legitimate users register for profits via `RegisterForProfits`
3. Attacker distributes actual profits once (e.g., Period 1 with 1000 ELF)
4. Attacker calls `DistributeProfits` with empty `AmountsMap` millions of times, creating Periods 2-1,000,001 with no profits
5. When beneficiaries claim:
   - First claim processes Period 1 successfully, sets `LastProfitPeriod` = 2
   - Second claim attempts Periods 2-102 (limited by `maxProfitReceivingPeriodCount`), finds all empty, `LastProfitPeriod` remains at 2 [7](#0-6) 
   - All subsequent claims repeat this, creating an **infinite loop** - beneficiaries are permanently stuck

## Impact Explanation

**Severity: CRITICAL**

This vulnerability creates a permanent denial-of-service that is actually worse than initially claimed:

1. **Permanent profit loss**: Once trapped in the empty period loop, beneficiaries cannot progress their `LastProfitPeriod` and are permanently locked out of their profits
2. **No recovery mechanism**: There is no function to skip empty periods or reset the period counter
3. **All scheme beneficiaries affected**: Every user who registered for profits becomes a victim
4. **Asymmetric attack cost**: Attacker pays minimal transaction fees for creating empty periods, while victims pay for failed claim attempts
5. **Protocol integrity damage**: Users losing access to legitimate profits severely undermines trust in the profit distribution system

The maximum periods processable per transaction is calculated dynamically but typically around 100 periods total, divided among profitable details. [8](#0-7) 

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivially executable:

1. **No privilege escalation required**: Anyone can create a scheme and become its manager - this is intended functionality
2. **Zero attack complexity**: Simply call `DistributeProfits` repeatedly with empty input
3. **Minimal preconditions**: Only requires the scheme has beneficiaries (totalShares > 0), which is the normal operational state
4. **No rate limits or validation**: There are no checks preventing empty period creation
5. **Undetectable until damage is done**: While visible on-chain, detection doesn't prevent the permanent damage

## Recommendation

Add validation in both TokenHolder and Profit `DistributeProfits` functions to prevent period increments when no profits are actually distributed:

```csharp
// In TokenHolder DistributeProfits
public override Empty DistributeProfits(DistributeProfitsInput input)
{
    var scheme = GetValidScheme(input.SchemeManager, true);
    Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
           Context.Sender == input.SchemeManager, "No permission to distribute profits.");
    
    // ADD THIS CHECK
    Assert(input.AmountsMap != null && input.AmountsMap.Any(), 
           "Cannot distribute empty profits.");
    
    var distributeProfitsInput = new Profit.DistributeProfitsInput
    {
        SchemeId = scheme.SchemeId,
        Period = scheme.Period,
        AmountsMap = { input.AmountsMap }
    };

    State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
    scheme.Period = scheme.Period.Add(1);
    State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
    return new Empty();
}
```

Additionally, in the Profit contract's `DistributeProfits`, add validation that actual token amounts are being distributed before incrementing the period.

## Proof of Concept

```csharp
// Test demonstrating the permanent DOS vulnerability
[Fact]
public async Task EmptyPeriodDOS_BeneficiaryStuckInInfiniteLoop()
{
    // Setup: Create scheme and register beneficiary
    var schemeManager = Accounts[0].Address;
    var beneficiary = Accounts[1].Address;
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });
    
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = schemeManager,
        Amount = 1000
    });
    
    // Distribute actual profits once (Period 1)
    await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeManager = schemeManager,
        AmountsMap = { { "ELF", 1000 } }
    });
    
    // Attack: Create 1000 empty periods (Periods 2-1001)
    for (int i = 0; i < 1000; i++)
    {
        await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeManager = schemeManager,
            AmountsMap = { } // Empty map
        });
    }
    
    // First claim succeeds (processes Period 1)
    await TokenHolderContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeManager = schemeManager,
        Beneficiary = beneficiary
    });
    
    var profitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiary
    });
    
    var lastProfitPeriod1 = profitDetails.Details.First().LastProfitPeriod;
    // LastProfitPeriod is now 2
    
    // Second claim attempts Periods 2-102, all empty, LastProfitPeriod stays at 2
    await TokenHolderContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeManager = schemeManager,
        Beneficiary = beneficiary
    });
    
    profitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiary
    });
    
    var lastProfitPeriod2 = profitDetails.Details.First().LastProfitPeriod;
    
    // VULNERABILITY PROOF: LastProfitPeriod did not advance
    lastProfitPeriod1.ShouldBe(lastProfitPeriod2); // Both equal 2
    
    // Beneficiary is now permanently stuck, unable to claim any future profits
}
```

**Notes:**
The vulnerability is confirmed valid through code analysis. The actual severity is **CRITICAL** rather than HIGH because beneficiaries become permanently stuck in an infinite loop once trapped in a range of consecutive empty periods, rather than just needing many transactions as originally claimed. The `lastProfitPeriod` variable is only updated when a profitable period is found, so if all periods in the processable range (typically ~100) are empty, the beneficiary can never progress and is permanently locked out of their profits.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L131-147)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager, true);
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
        var distributeProfitsInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-494)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);

        Context.LogDebug(() => $"Receiving virtual address: {profitsReceivingVirtualAddress}");

        UpdateDistributedProfits(profitsMap, profitsReceivingVirtualAddress, totalShares);

        PerformDistributeProfits(profitsMap, scheme, totalShares, profitsReceivingVirtualAddress);

        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L822-833)
```csharp
    private int GetMaximumPeriodCountForProfitableDetail(int profitableDetailCount)
    {
        // Get the maximum profit receiving period count
        var maxPeriodCount = GetMaximumProfitReceivingPeriodCount();
        // Check if the maximum period count is greater than the profitable detail count
        // and if the profitable detail count is greater than 0
        return maxPeriodCount > profitableDetailCount && profitableDetailCount > 0
            // Divide the maximum period count by the profitable detail count
            ? maxPeriodCount.Div(profitableDetailCount)
            // If the conditions are not met, return 1 as the maximum period count
            : 1;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-871)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L876-909)
```csharp
                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L9-9)
```csharp
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
```
