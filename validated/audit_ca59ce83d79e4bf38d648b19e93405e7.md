# Audit Report

## Title
ImpliedIrreversibleBlockHeight Validation Bypass Allows Malicious Miners to Prevent LIB Advancement

## Summary
The `LibInformationValidationProvider` contains a validation bypass that allows miners to skip monotonicity checks by setting `ImpliedIrreversibleBlockHeight` to 0 in their block's consensus extra data. If more than 1/3 of miners collude to exploit this bypass, the Last Irreversible Block (LIB) calculation fails to meet the consensus threshold, causing the LIB to stop advancing and breaking blockchain finality guarantees.

## Finding Description

The vulnerability exists in the validation logic that verifies miner-reported implied irreversible block heights. The validation provider explicitly skips validation when the provided height is zero: [1](#0-0) 

This guard condition creates an exploitable bypass. During normal block production, the consensus contract automatically sets this value to the current block height: [2](#0-1) 

However, a malicious block producer can modify the consensus extra data in the block header before submitting the block. The AElf validation framework validates business logic constraints but does not cryptographically verify that the consensus extra data matches what the contract generated. When a miner provides zero, validation is skipped and the zero value gets stored in state: [3](#0-2) 

During LIB calculation, zero values are explicitly filtered out: [4](#0-3) 

The LIB calculation requires a minimum number of valid (non-zero) values equal to the consensus threshold `MinersCountOfConsent = (N * 2/3) + 1`. If the count falls below this threshold due to filtered zero values, the calculation returns 0: [5](#0-4) 

The protection logic prevents updating the LIB if the calculated value is not higher than the current value, effectively causing the LIB to stall: [6](#0-5) 

## Impact Explanation

**Consensus Impact:** This vulnerability breaks the Byzantine fault tolerance guarantee of the AEDPoS consensus mechanism. The system is designed to tolerate up to 1/3 malicious miners, but this bypass allows exactly that threshold to completely halt LIB progression. For example, with 7 miners requiring 5 valid values (MinersCountOfConsent = 5), if 3 miners provide zero values, only 4 valid values remain, causing the LIB calculation to return 0 and preventing any LIB updates.

**Cross-Chain Impact:** Cross-chain verification mechanisms rely on the LIB to determine which blocks are irreversible and safe to index. A stalled LIB breaks cross-chain indexing, preventing cross-chain transactions and state verification.

**Finality Impact:** Without an advancing LIB, blocks never achieve true finality. This undermines fundamental security guarantees of the blockchain, breaking applications and protocols that depend on transaction irreversibility, including exchanges, DeFi protocols, and any system requiring settlement guarantees.

**Severity:** HIGH - This directly violates the critical invariant that LIB must advance with block production, compromising consensus integrity, cross-chain functionality, and the security guarantees that applications depend on.

## Likelihood Explanation

**Attacker Capabilities:** The attack requires controlling more than 1/3 of miner nodes. In a typical AElf deployment with 7-21 miners, this translates to 3-7 colluding miners. Miners must coordinate to provide zero values in their blocks persistently.

**Technical Feasibility:** The technical execution is straightforward. Miners control block production and can modify block header data before signing and submitting blocks. The node software normally calls the consensus contract to get proper values, but malicious miners running modified software can override this. The validation framework only verifies business logic constraints, not data integrity against what the contract would have generated.

**Detection and Response:** The attack is immediately observable through blockchain monitoringâ€”the LIB would visibly stop advancing. However, identifying which specific miners are providing zero values requires inspecting individual block headers, and there are limited mitigation options once the threshold is reached.

**Economic Considerations:** While miners generally have economic stake in network health, scenarios that make this attack economically rational include: compromised miner nodes (security breach), miners with short positions on the token, coordinated attacks during critical cross-chain operations for exploit opportunities, or attempts to manipulate DeFi protocols that depend on finality.

**Probability:** MODERATE - Requires significant miner collusion (>1/3), which is a substantial coordination barrier, but the technical execution is simple and the bypass condition explicitly enables the attack.

## Recommendation

**Fix the validation bypass** by enforcing that `ImpliedIrreversibleBlockHeight` must be non-zero during normal block production:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound;
    var providedRound = validationContext.ProvidedRound;
    var pubkey = validationContext.SenderPubkey;
    
    if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
        providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
        (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
         baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
    {
        validationResult.Message = "Incorrect lib information.";
        return validationResult;
    }

    if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
    {
        var providedHeight = providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
        
        // FIX: Reject zero values in normal operation
        if (providedHeight == 0)
        {
            validationResult.Message = "ImpliedIrreversibleBlockHeight cannot be zero.";
            return validationResult;
        }
        
        if (baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight > providedHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
    }

    validationResult.Success = true;
    return validationResult;
}
```

## Proof of Concept

```csharp
// Test scenario: 7 miners, 3 malicious miners provide zero ImpliedIrreversibleBlockHeight
// Expected: LIB calculation fails threshold check and returns 0, preventing LIB advancement

[Fact]
public void Test_LIB_Stalls_When_Malicious_Miners_Provide_Zero_Values()
{
    // Setup: 7 miners
    var round = new Round
    {
        RealTimeMinersInformation = new Dictionary<string, MinerInRound>
        {
            ["miner1"] = new MinerInRound { Pubkey = "miner1", ImpliedIrreversibleBlockHeight = 0 }, // malicious
            ["miner2"] = new MinerInRound { Pubkey = "miner2", ImpliedIrreversibleBlockHeight = 0 }, // malicious
            ["miner3"] = new MinerInRound { Pubkey = "miner3", ImpliedIrreversibleBlockHeight = 0 }, // malicious
            ["miner4"] = new MinerInRound { Pubkey = "miner4", ImpliedIrreversibleBlockHeight = 1000 }, // honest
            ["miner5"] = new MinerInRound { Pubkey = "miner5", ImpliedIrreversibleBlockHeight = 1001 }, // honest
            ["miner6"] = new MinerInRound { Pubkey = "miner6", ImpliedIrreversibleBlockHeight = 1002 }, // honest
            ["miner7"] = new MinerInRound { Pubkey = "miner7", ImpliedIrreversibleBlockHeight = 1003 }  // honest
        }
    };
    
    // MinersCountOfConsent = (7 * 2/3) + 1 = 5
    var minersCountOfConsent = round.MinersCountOfConsent;
    Assert.Equal(5, minersCountOfConsent);
    
    // Get sorted heights (filters out zeros)
    var specificPublicKeys = new List<string> { "miner1", "miner2", "miner3", "miner4", "miner5", "miner6", "miner7" };
    var sortedHeights = round.GetSortedImpliedIrreversibleBlockHeights(specificPublicKeys);
    
    // Only 4 non-zero values remain: [1000, 1001, 1002, 1003]
    Assert.Equal(4, sortedHeights.Count);
    
    // Threshold check: 4 < 5 (MinersCountOfConsent)
    Assert.True(sortedHeights.Count < minersCountOfConsent);
    
    // LIB calculation would return 0, preventing LIB update
    // This demonstrates the vulnerability: 3 malicious miners (>1/3) can halt LIB progression
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-281)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L14-16)
```csharp
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L26-30)
```csharp
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }
```
