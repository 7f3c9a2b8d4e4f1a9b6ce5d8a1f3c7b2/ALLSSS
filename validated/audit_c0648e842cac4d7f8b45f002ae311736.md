# Audit Report

## Title
Consensus Permanent DoS via Unconstrained LIB Injection in NextTerm/NextRound Transactions

## Summary
The `NextTerm` and `NextRound` transaction validation paths lack `LibInformationValidationProvider` checks, allowing a malicious miner to inject arbitrarily high `ConfirmedIrreversibleBlockHeight` values into consensus state. Once corrupted, all subsequent `UpdateValue` transactions fail validation, permanently halting block production.

## Finding Description

The consensus validation framework applies different validation providers based on the transaction behavior type. While `UpdateValue` transactions receive comprehensive validation including LIB (Last Irreversible Block) checks, `NextTerm` and `NextRound` transactions bypass this critical validation. [1](#0-0) 

The `LibInformationValidationProvider` specifically validates that LIB values cannot move backward, rejecting any round where `baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight`: [2](#0-1) 

However, `RoundTerminateValidationProvider` (the only validator applied to `NextTerm`) only checks round/term number increments and InValue nullness, completely ignoring LIB values: [3](#0-2) 

When processing `NextTerm`, the transaction input's LIB values are directly copied to the new round without any validation: [4](#0-3) 

This malicious round is then persisted to state: [5](#0-4) [6](#0-5) 

Once the corrupted LIB is in state, subsequent `UpdateValue` transactions calculate the real LIB (e.g., 15,000) but fail validation because the loaded `baseRound` contains the corrupted high value (e.g., Int64.MaxValue - 1000), causing the backward movement check to fail.

The critical impact occurs because when a miner's `OutValue` is null (first block in time slot), the consensus behavior logic mandates `UpdateValue`: [7](#0-6) [8](#0-7) 

Without successful `UpdateValue` execution, `OutValue` remains null. TinyBlock production requires `OutValue != null`: [9](#0-8) 

This creates a deadlock where no blocks can be produced.

## Impact Explanation

**CRITICAL** - Complete consensus halt with catastrophic consequences:

1. **Blockchain Freeze**: Once LIB is corrupted, miners cannot produce any blocks because UpdateValue (required for first block) fails validation, and TinyBlock (requires OutValue != null) cannot be produced.

2. **Permanent State Corruption**: The corrupted LIB value persists in blockchain state and cannot be corrected through normal consensus operations.

3. **Network-Wide Impact**: All validators are affected simultaneously - no subset of honest miners can recover the chain.

4. **Recovery Cost**: Requires emergency hard fork coordinating all network participants, with significant downtime and coordination overhead.

5. **Transaction Blackout**: All pending user transactions remain unprocessed indefinitely during the halt period.

## Likelihood Explanation

**HIGH** likelihood due to:

1. **Attacker Requirements**: Only requires being an elected miner, which is achievable through the governance election mechanism. Multiple miners exist in typical deployments.

2. **Attack Complexity**: LOW - The attacker:
   - Waits for legitimate term transition period
   - Calls `GenerateConsensusTransactions` to obtain valid NextTermInput
   - Modifies the `ConfirmedIrreversibleBlockHeight` field to an extremely high value
   - Submits the modified transaction during their mining slot

3. **Technical Feasibility**: No cryptographic challenges, no race conditions, no complex timing requirements. Miners have full control over transactions they include in blocks they produce.

4. **Detection Difficulty**: The malicious transaction appears valid during submission and only manifests as a problem in subsequent rounds when other miners attempt UpdateValue transactions.

5. **Economic Cost**: Minimal - only standard transaction gas fees required.

## Recommendation

Add `LibInformationValidationProvider` to the validation providers list for both `NextTerm` and `NextRound` behaviors in `ValidateBeforeExecution`:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
}
```

This ensures LIB values cannot move backward during any consensus state transition, not just UpdateValue operations.

## Proof of Concept

Due to the complexity of the consensus contract testing environment and the need to simulate term transitions with multiple miners, a complete executable PoC would require extensive test infrastructure setup. However, the vulnerability can be demonstrated through the following logical flow:

1. **Setup**: Deploy consensus contract with elected miners, advance to term transition point
2. **Attack**: Malicious miner M1 intercepts legitimate NextTerm generation
3. **Corruption**: M1 modifies `NextTermInput.ConfirmedIrreversibleBlockHeight = Int64.MaxValue - 1000`
4. **Execution**: M1's NextTerm transaction passes validation (only RoundTerminateValidationProvider applied)
5. **Persistence**: Corrupted LIB saved to `State.Rounds[roundNumber]`
6. **DoS Trigger**: Next miner M2 attempts UpdateValue with correctly calculated LIB (e.g., 15,000)
7. **Validation Failure**: LibInformationValidationProvider rejects: `(Int64.MaxValue - 1000) > 15000 == true`
8. **Consensus Halt**: M2 cannot produce UpdateValue, OutValue remains null, no TinyBlocks possible, chain halts

The key validation gap is architecturally evident from the code structure and represents a systematic vulnerability in the validation framework design.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-56)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L57-62)
```csharp
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L114-114)
```csharp
            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```
