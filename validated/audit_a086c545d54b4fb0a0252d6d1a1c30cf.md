# Audit Report

## Title
NextRound Validation Fails to Detect Duplicate Mining Orders Due to Incorrect Distinct() Usage on Protobuf Objects

## Summary
The `NextRoundMiningOrderValidationProvider` validation logic incorrectly applies `Distinct()` to `MinerInRound` protobuf objects instead of their `FinalOrderOfNextRound` values. Since protobuf-generated classes implement field-based equality across ALL properties, miners with duplicate `FinalOrderOfNextRound` values pass validation as distinct objects due to differing `pubkey` and other fields. This allows malicious miners to inject duplicate mining orders that break the consensus invariant requiring unique order assignments.

## Finding Description

The root cause lies in the validation implementation that checks for duplicate mining orders: [1](#0-0) 

The code applies `.Distinct()` to `MinerInRound` objects rather than extracting and deduplicating their `FinalOrderOfNextRound` values. However, `MinerInRound` is a protobuf-generated message type with 17+ fields: [2](#0-1) 

Protobuf-generated C# classes implement `Equals()` and `GetHashCode()` by comparing ALL fields. Since each miner has unique values for `pubkey`, `order`, `out_value`, `signature`, etc., two `MinerInRound` objects will NEVER be considered equal by `Distinct()` even if they have identical `final_order_of_next_round` values.

**Attack Scenario:**

A malicious miner crafts a `NextRoundInput` where multiple miners have duplicate `FinalOrderOfNextRound` values (e.g., Alice=1, Bob=2, Charlie=2). The validation provider is registered for NextRound behavior: [3](#0-2) 

The validation compares distinct object count against miners who mined. With 3 miners having different pubkeys, `Distinct()` returns 3 distinct objects, matching the count of miners who mined (3). The validation incorrectly passes despite the duplicate order values.

After passing validation, the malicious round data is saved to state: [4](#0-3) 

When generating the next round, `FinalOrderOfNextRound` values are directly used as `Order` assignments: [5](#0-4) 

Both Bob and Charlie receive `Order = 2` in the next round, violating the uniqueness invariant.

## Impact Explanation

**CRITICAL - Consensus Integrity Breach**

The vulnerability directly breaks the fundamental consensus invariant that each miner must have a unique mining order. The consequences include:

1. **Mining Time Conflicts**: Multiple miners are scheduled to mine at the same time slot, calculated from their order: [6](#0-5) 

2. **Available Order Miscalculation**: The `occupiedOrders` list used to assign orders to non-mining miners contains duplicate values: [7](#0-6) 

This causes insufficient available orders for miners who didn't mine, potentially leading to array out-of-bounds or incorrect assignments.

3. **Double Block Production**: Multiple miners with identical orders attempt simultaneous block production, creating fork risks and consensus failures.

4. **Persistent Corruption**: The corrupted round data is saved to state and propagates to subsequent rounds, causing sustained network instability.

This directly undermines the AEDPoS consensus mechanism's ability to maintain a deterministic mining schedule and proper round transitions.

## Likelihood Explanation

**HIGH**

The attack is highly feasible:

**Attacker Requirements**: Must be a valid miner in the current round, which rotates among participants in AEDPoS.

**Entry Point**: The `NextRound` method is a public RPC endpoint: [8](#0-7) 

**Attack Complexity**: Straightforward - during their scheduled `NextRound` turn, the attacker crafts input with duplicate `FinalOrderOfNextRound` values. The flawed validation logic cannot detect this because it checks object distinctness rather than value distinctness.

**Detection**: The malicious data passes all validation checks and appears structurally valid, making detection difficult.

**Cost**: No additional economic cost beyond normal block production.

Any malicious miner can exploit this vulnerability during their scheduled turn to propose the next round transition.

## Recommendation

Fix the validation logic to check distinctness of `FinalOrderOfNextRound` VALUES rather than `MinerInRound` OBJECTS:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Extract values first
    .Distinct()
    .Count();
```

This ensures the validation detects duplicate order values regardless of differing miner properties.

Additionally, consider adding a secondary check that verifies no two miners in the provided round have the same `FinalOrderOfNextRound` value explicitly:

```csharp
var orders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
    
if (orders.Count != orders.Distinct().Count())
{
    validationResult.Message = "Duplicate FinalOrderOfNextRound detected.";
    return validationResult;
}
```

## Proof of Concept

```csharp
[Fact]
public void NextRound_DuplicateFinalOrderOfNextRound_ShouldFailValidation()
{
    // Setup: Create a round with 3 miners who all mined
    var providedRound = new Round
    {
        RoundNumber = 2,
        RealTimeMinersInformation =
        {
            ["Alice"] = new MinerInRound
            {
                Pubkey = "Alice",
                OutValue = Hash.FromString("alice_out"),
                FinalOrderOfNextRound = 1
            },
            ["Bob"] = new MinerInRound
            {
                Pubkey = "Bob",
                OutValue = Hash.FromString("bob_out"),
                FinalOrderOfNextRound = 2
            },
            ["Charlie"] = new MinerInRound
            {
                Pubkey = "Charlie",
                OutValue = Hash.FromString("charlie_out"),
                FinalOrderOfNextRound = 2  // DUPLICATE with Bob
            }
        }
    };

    var context = new ConsensusValidationContext
    {
        ProvidedRound = providedRound
    };

    var provider = new NextRoundMiningOrderValidationProvider();
    var result = provider.ValidateHeaderInformation(context);

    // Expected: Validation should FAIL due to duplicate orders
    // Actual: Validation PASSES incorrectly (3 distinct objects == 3 miners who mined)
    Assert.False(result.Success, "Validation should fail with duplicate FinalOrderOfNextRound");
}
```

The test demonstrates that the current implementation incorrectly passes validation when duplicate `FinalOrderOfNextRound` values exist, confirming the vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L34-34)
```text
    rpc NextRound (NextRoundInput) returns (google.protobuf.Empty) {
```

**File:** protobuf/aedpos_contract.proto (L266-295)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-86)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```
