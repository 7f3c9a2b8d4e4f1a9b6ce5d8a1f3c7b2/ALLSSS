# Audit Report

## Title
Missing Validation of ExtraBlockProducerOfPreviousRound in NextTermInput Allows Reward Manipulation

## Summary
The AEDPoS consensus system fails to validate the `ExtraBlockProducerOfPreviousRound` field during NextTerm block production. A malicious miner producing a NextTerm block can arbitrarily set this field to grant extra mining privileges and rewards to any miner, breaking the consensus reward distribution mechanism and causing fund misallocation from the Treasury.

## Finding Description

The vulnerability exists due to a complete absence of validation for the `ExtraBlockProducerOfPreviousRound` field in the NextTerm consensus flow:

**1. No validation in input creation:** The `NextTermInput.Create()` method blindly copies `ExtraBlockProducerOfPreviousRound` from the provided Round object without any validation. [1](#0-0) 

**2. Validation gap in RoundTerminateValidationProvider:** The NextTerm validation only checks round number and term number increments, completely ignoring the `ExtraBlockProducerOfPreviousRound` field. [2](#0-1) 

**3. Field excluded from hash calculation:** The `GetCheckableRound()` method used for hash-based validation only includes `RoundNumber`, `TermNumber`, `RealTimeMinersInformation`, and `BlockchainAge`, explicitly excluding `ExtraBlockProducerOfPreviousRound`. [3](#0-2) 

**4. No validation during NextTerm processing:** The validation pipeline for NextTerm behavior only includes basic providers and `RoundTerminateValidationProvider`, with no check on this critical field. [4](#0-3) 

**5. Direct storage without verification:** The `ProcessNextTerm` method converts the input to Round and stores it directly in state without any validation of the `ExtraBlockProducerOfPreviousRound` value. [5](#0-4) 

**Attack execution path:**
1. Attacker is selected to produce the NextTerm block (normal consensus rotation)
2. Attacker generates the honest Round object where `ExtraBlockProducerOfPreviousRound` would be their own pubkey [6](#0-5) 
3. Before signing the block, attacker modifies the field to a colluding miner's pubkey (or their own if in the new term)
4. Block passes all validation since no validator checks this field
5. The manipulated Round is stored in state
6. Beneficiary miner gains unauthorized extra mining privileges

**The field grants critical privileges:** A miner matching `ExtraBlockProducerOfPreviousRound` can produce tiny blocks before the round officially starts and produce more blocks than normal miners during their time slot. [7](#0-6) [8](#0-7) 

**Direct reward impact:** Each tiny block increments the miner's `ProducedBlocks` counter, and mining rewards are calculated as total mined blocks multiplied by reward per block. [9](#0-8) [10](#0-9) [11](#0-10) 

## Impact Explanation

**Direct Financial Impact - Treasury Fund Misallocation:**

The vulnerability causes concrete fund misallocation from the Treasury contract:

1. **Extra Mining Privileges:** The beneficiary miner can produce additional tiny blocks before round start time and beyond normal block limits, which legitimate miners cannot do.

2. **Inflated Block Production:** Each extra tiny block increments the beneficiary's `ProducedBlocks` counter, artificially inflating their contribution.

3. **Disproportionate Rewards:** Mining rewards donated to Treasury are calculated as `minedBlocks * miningRewardPerBlock`. The beneficiary receives a higher proportional share of rewards during Treasury distribution due to their inflated `ProducedBlocks` count.

**Attack Scenarios:**
- **Collusion:** NextTerm producer sets the field to a colluding miner's pubkey, sharing increased rewards
- **Self-enrichment:** If the producer is in the new term's miner list, they set it to their own pubkey
- **Griefing:** Setting it to a non-existent pubkey denies the legitimate producer their rightful privileges

**Affected Parties:**
- Legitimate extra block producer loses rightful mining privileges and proportional rewards
- All honest miners receive reduced proportional rewards when a beneficiary gains extra blocks
- Protocol integrity is violated as rewards no longer reflect actual work performed

## Likelihood Explanation

**Highly Likely - Exploitable by Any Miner:**

**Entry Point:** The `NextTerm` method is a standard consensus operation, not a privileged call. [12](#0-11) 

**Attacker Capability:** The attacker must be a miner selected to produce the NextTerm block. This is not a special privilege but a routine occurrence in consensus rotation - every miner will eventually be selected to produce various consensus blocks including NextTerm blocks.

**Technical Feasibility:** Block producers have full control over the consensus extra data and transactions they include in their blocks. There are no cryptographic or technical barriers preventing modification of the `ExtraBlockProducerOfPreviousRound` field before signing.

**Detection Difficulty:** The manipulation is undetectable because:
- The field is not included in hash-based validation
- No validator regenerates the expected value for comparison
- The manipulated block appears valid to all validation layers

**Economic Incentive:** The attack has minimal cost (modifying one field) but provides direct economic benefit through increased reward allocation. For a rational economic actor, the potential reward gain significantly outweighs any reputational risk.

## Recommendation

Add validation in the `RoundTerminateValidationProvider.ValidationForNextTerm()` method to verify that `ExtraBlockProducerOfPreviousRound` matches the actual sender of the NextTerm transaction:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Is next term number correct?
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // Validate ExtraBlockProducerOfPreviousRound matches sender
    if (extraData.Round.ExtraBlockProducerOfPreviousRound != extraData.SenderPubkey.ToHex())
        return new ValidationResult { Message = "ExtraBlockProducerOfPreviousRound must match the NextTerm block producer." };
    
    return new ValidationResult { Success = true };
}
```

Alternatively, include `ExtraBlockProducerOfPreviousRound` in the `GetCheckableRound()` method to enable hash-based validation:

```csharp
var checkableRound = new Round
{
    RoundNumber = RoundNumber,
    TermNumber = TermNumber,
    RealTimeMinersInformation = { minersInformation },
    BlockchainAge = BlockchainAge,
    ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound
};
```

## Proof of Concept

A valid test demonstrating the vulnerability would:

1. Set up a consensus scenario with multiple miners in term T
2. Have a malicious miner produce the NextTerm block to start term T+1
3. In the block production, modify `ExtraBlockProducerOfPreviousRound` to a different miner's pubkey
4. Verify the block passes validation
5. Verify the beneficiary miner can produce extra tiny blocks using `GetConsensusCommand`
6. Verify the beneficiary's `ProducedBlocks` counter increases beyond what legitimate miners can achieve
7. Calculate and verify the disproportionate reward allocation to the beneficiary from `DonateMiningReward`

The test would confirm that no validation prevents this manipulation and that it directly leads to reward misallocation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L124-127)
```csharp
    public long GetMinedBlocks()
    {
        return RealTimeMinersInformation.Values.Sum(minerInRound => minerInRound.ProducedBlocks);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L254-254)
```csharp
        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L118-120)
```csharp
        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
```
