# Audit Report

## Title
RoundId Manipulation Bypasses Time Slot Validation in NextRound Consensus Transitions

## Summary
A malicious miner can craft a `NextRound` transaction with manipulated `ExpectedMiningTime` values that sum to equal `BaseRound.RoundId`, causing the validation logic to skip critical time slot equality checks. This allows acceptance of consensus rounds with arbitrary, unequal time slots, breaking the core AEDPoS scheduling invariant and potentially disrupting block production across the network.

## Finding Description

The vulnerability exists in the consensus validation flow where the `RoundId` property is deterministically computed as the sum of all miners' `ExpectedMiningTime.Seconds` values: [1](#0-0) 

The `TimeSlotValidationProvider` uses `RoundId` equality to determine whether to validate time slot intervals for a new round: [2](#0-1) 

**Root Cause:** The validation logic incorrectly assumes that equal `RoundId` values indicate the same round (just updating values within the current round). However, an attacker can craft a **new round** with an incremented `RoundNumber` but manipulated `ExpectedMiningTime` values that sum to the same `RoundId` as the previous round.

**Attack Mechanism:**

1. The attacker (a current miner) reads the current `BaseRound.RoundId` (e.g., 28,900,000,000)
2. During their time slot to produce the `NextRound` block, they craft a malicious `NextRoundInput` with:
   - `RoundNumber = BaseRound.RoundNumber + 1` (satisfies increment check)
   - 16 miners with `ExpectedMiningTime.Seconds = 1`
   - 1 miner with `ExpectedMiningTime.Seconds = 28,899,999,984`
   - Result: `ProvidedRound.RoundId = 28,900,000,000 = BaseRound.RoundId`

3. During validation via `ValidateBeforeExecution`, the `RoundTerminateValidationProvider` only checks `RoundNumber` increment and `InValue` nullity: [3](#0-2) 

4. The `TimeSlotValidationProvider` sees equal `RoundId` values and skips `CheckRoundTimeSlots()`, only checking the individual miner's time slot

5. The `CheckRoundTimeSlots()` method would normally reject unequal intervals: [4](#0-3) 

However, this validation **never executes** due to the bypassed condition (line 14 in `TimeSlotValidationProvider.cs`).

6. After validation passes, the malicious round is stored directly without regeneration: [5](#0-4) 

The legitimate round generation occurs in `GenerateNextRoundInformation`, which properly assigns equal intervals: [6](#0-5) 

However, miners can bypass this by directly providing malicious consensus data.

## Impact Explanation

**Consensus Integrity Violation:**
The accepted malicious round violates the fundamental AEDPoS invariant of equal time slot distribution among miners. This breaks the consensus scheduling mechanism that all miners depend on for determining when to produce blocks.

**Concrete Harms:**

1. **Consensus Disruption:** Miners assigned compressed time slots (e.g., 1-second intervals) cannot physically produce blocks within their slots, while the attacker with an extended slot monopolizes block production

2. **Chain Halt Risk:** If a supermajority of miners receive invalid time slots, consensus may fail to progress through rounds, potentially halting the chain

3. **Reward Manipulation:** Unequal time slots enable unfair distribution of block production opportunities and mining rewards

4. **Cascading Failures:** Subsequent rounds built on the malicious round inherit broken timing assumptions, compounding the consensus disruption

**Affected Parties:**
- All network participants experience consensus breakdown
- Honest miners cannot produce blocks in their assigned slots  
- Users face degraded or halted transaction finality

**Severity Justification:** HIGH - This directly compromises a core consensus protocol invariant with practical exploitation requiring only current miner privileges, no cryptographic breaks, and a single transaction.

## Likelihood Explanation

**Attacker Requirements:**
- Must be a current miner (validated by standard consensus participation rules)
- Must produce a block during their valid time slot to trigger `NextRound` behavior

**Attack Complexity:** LOW
- Simple arithmetic to calculate target `RoundId` sum
- No cryptographic breaking required
- No race conditions or precise timing needed beyond normal miner duties
- Single transaction execution via the public `NextRound` method: [7](#0-6) 

**Feasibility:**
- Miners control block production and can include arbitrary transactions with crafted consensus data
- `BaseRound.RoundId` is publicly readable state
- The legitimate round generation happens in `GetConsensusExtraDataForNextRound`: [8](#0-7) 

However, miners can bypass this legitimate generation and directly submit malicious `NextRoundInput` data.

- No additional validators check `ExpectedMiningTime` value reasonableness

**Probability Assessment:** HIGH - Any malicious miner can execute this attack during their time slot with near certainty, limited only by normal consensus flow constraints.

## Recommendation

Implement independent validation of `ExpectedMiningTime` values that does not rely on `RoundId` equality:

1. **Always validate time slot equality for NextRound:** Modify `TimeSlotValidationProvider` to call `CheckRoundTimeSlots()` for any `NextRound` behavior, regardless of `RoundId` equality

2. **Add RoundId change validation:** For `NextRound` behavior, assert that `ProvidedRound.RoundId != BaseRound.RoundId` to prevent collision attacks

3. **Validate ExpectedMiningTime generation:** Verify that `ExpectedMiningTime` values follow the expected pattern: `currentBlockTimestamp + (miningInterval * order)` for each miner

4. **Add maximum deviation check:** Ensure the difference between maximum and minimum `ExpectedMiningTime.Seconds` values matches expected round duration

Example fix for `TimeSlotValidationProvider.cs`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    // For NextRound behavior, ALWAYS validate time slots
    if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.NextRound)
    {
        // Verify RoundId changes for new round
        if (validationContext.ProvidedRound.RoundId == validationContext.BaseRound.RoundId)
            return new ValidationResult { Message = "RoundId must change for NextRound" };
            
        validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
        if (!validationResult.Success) return validationResult;
    }
    else if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
    {
        validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
        if (!validationResult.Success) return validationResult;
    }
    else
    {
        if (!CheckMinerTimeSlot(validationContext))
        {
            validationResult.Message = $"Time slot already passed before execution.{validationContext.SenderPubkey}";
            validationResult.IsReTrigger = true;
            return validationResult;
        }
    }

    validationResult.Success = true;
    return validationResult;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task RoundIdManipulation_BypassesTimeSlotValidation()
{
    // Setup: Initialize consensus with legitimate miners
    var initialMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensus(initialMiners);
    
    // Advance to a normal round
    await ProduceNormalRound();
    
    // Get current round to calculate its RoundId
    var currentRound = await GetCurrentRound();
    var targetRoundId = currentRound.RoundId;
    
    // Craft malicious NextRound with manipulated ExpectedMiningTime values
    // that sum to the same RoundId but have unequal intervals
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RealTimeMinersInformation = 
        {
            ["miner1"] = new MinerInRound 
            { 
                Pubkey = "miner1", 
                Order = 1,
                ExpectedMiningTime = Timestamp.FromSeconds(1), // Compressed
                FinalOrderOfNextRound = 1
            },
            ["miner2"] = new MinerInRound 
            { 
                Pubkey = "miner2", 
                Order = 2,
                ExpectedMiningTime = Timestamp.FromSeconds(1), // Compressed
                FinalOrderOfNextRound = 2
            },
            ["miner3"] = new MinerInRound 
            { 
                Pubkey = "miner3", 
                Order = 3,
                // Manipulated to make sum equal targetRoundId
                ExpectedMiningTime = Timestamp.FromSeconds(targetRoundId - 2),
                FinalOrderOfNextRound = 3
            }
        }
    };
    
    // Verify the RoundId collision
    var maliciousRound = maliciousNextRound.ToRound();
    Assert.Equal(targetRoundId, maliciousRound.RoundId);
    
    // Attempt to submit malicious NextRound
    var result = await ConsensusContract.NextRound.SendAsync(maliciousNextRound);
    
    // BUG: This should fail but succeeds due to bypassed validation
    Assert.True(result.TransactionResult.Status == TransactionResultStatus.Mined);
    
    // Verify malicious round was stored
    var storedRound = await GetCurrentRound();
    Assert.Equal(maliciousNextRound.RoundNumber, storedRound.RoundNumber);
    
    // Verify unequal time slots were accepted (vulnerability confirmed)
    var interval1 = storedRound.RealTimeMinersInformation["miner2"].ExpectedMiningTime.Seconds -
                    storedRound.RealTimeMinersInformation["miner1"].ExpectedMiningTime.Seconds;
    var interval2 = storedRound.RealTimeMinersInformation["miner3"].ExpectedMiningTime.Seconds -
                    storedRound.RealTimeMinersInformation["miner2"].ExpectedMiningTime.Seconds;
    
    // These should be equal but are drastically different
    Assert.NotEqual(interval1, interval2);
    Assert.True(Math.Abs(interval2 - interval1) > 1000); // Massive difference
}
```

## Notes

The vulnerability stems from a design assumption that `RoundId` uniqueness implies round uniqueness. While this holds for legitimately generated rounds (where `ExpectedMiningTime` values are computed from mining intervals), it does not hold when miners can provide arbitrary input. The fix requires either:
1. Independent validation of time slot equality regardless of `RoundId`
2. Enforcement that `RoundId` must change for `NextRound` behavior
3. Validation that `ExpectedMiningTime` values follow the expected generation pattern

The attack is practical for any current miner and requires no special resources beyond normal mining capabilities.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-19)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-34)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```
