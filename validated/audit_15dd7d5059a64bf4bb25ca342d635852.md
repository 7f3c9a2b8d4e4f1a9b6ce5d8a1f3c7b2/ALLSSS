# Audit Report

## Title
Predictable NFT Symbol Number Generation Enables Miner Front-Running and Selective Symbol Claiming

## Summary
The NFT contract's `GenerateSymbolNumber()` function uses randomness from the previous block height, which is already finalized and publicly known when miners build blocks. Combined with the attacker-controllable sender address parameter, this allows miners to predict symbol numbers offline, test multiple addresses, and selectively claim desirable NFT protocol symbols, creating systematic unfair advantages over regular users.

## Finding Description

The vulnerability exists in the symbol number generation mechanism used during NFT protocol creation. The entry point is the public `Create()` method [1](#0-0) , which calls `GetSymbol()` that invokes `GenerateSymbolNumber()` [2](#0-1) .

The core issue is in `GenerateSymbolNumber()` which retrieves random bytes using the previous block's height [3](#0-2) . This calls the consensus contract's `GetRandomBytes()` method [4](#0-3) , which returns `State.RandomHashes[height]` [5](#0-4) .

These random hashes are stored during consensus processing [6](#0-5) . While VRF ensures miners cannot manipulate the base random hash, when a miner produces block H, the value `RandomHashes[H-1]` is already finalized and publicly accessible on-chain.

**Attack Mechanism:**

When a miner produces block H:
1. They observe `State.RandomHashes[H-1]` is already stored (finalized in the previous block)
2. They control transaction inclusion and ordering for block H
3. They can compute `Hash(Hash(Address_i) || Hash(RandomHashes[H-1]))` offline for multiple controlled addresses
4. They determine which address yields the most desirable symbol number (e.g., "AR100000001" vs "AR987654321")
5. They submit the Create transaction from the optimal address
6. They can exclude or delay competing user transactions

The symbol numbers start with minimum length 9 digits [7](#0-6)  and get combined with NFT type short names [8](#0-7)  like "AR" for Art, "MU" for Music, etc., to form the final protocol symbol. Lower numbers or memorable patterns may have higher perceived market value.

**Why Existing Protections Fail:**

The do-while loop in `GenerateSymbolNumber()` [9](#0-8)  only prevents duplicate symbol reuse but does not prevent prediction. There is no commit-reveal mechanism, no use of future block randomness, and no protection against selective transaction inclusion by miners.

## Impact Explanation

This vulnerability creates **systematic unfair advantages** in NFT protocol symbol allocation:

1. **Fairness Violation**: The protocol implicitly guarantees random, unbiased symbol allocation, but miners can systematically claim desirable numbers while regular users receive whatever random allocation they get.

2. **Market Manipulation**: If symbol numbers have market value (e.g., lower sequential numbers like "AR100000001", memorable patterns, or early numbers in new NFT categories), miners control access to these valuable identifiers during critical launch periods.

3. **Protocol Integrity**: Undermines user trust in the NFT ecosystem if miners are seen to consistently obtain desirable symbols through privileged access.

**Severity Assessment: MEDIUM**

This is not a critical vulnerability because:
- No direct fund theft or loss
- No token supply manipulation
- No protocol breakdown or consensus failure
- Impact depends on whether symbol numbers actually command market premiums

However, it is significant because:
- Creates systematic rather than one-time advantages
- Affects fairness guarantees in a potentially valuable asset allocation mechanism
- Is easily exploitable by all miners/validators
- Hard to detect without statistical analysis

## Likelihood Explanation

**Attacker Profile:**
- Must be a current miner/validator in the AEDPoS consensus set
- This is a realistic attacker profile as validators are elected participants in the protocol

**Attack Complexity: LOW**
1. Monitor `State.RandomHashes[H-1]` when producing block H (publicly available on-chain)
2. Compute hash outputs for controlled addresses offline
3. Select address yielding desirable symbol number
4. Submit Create transaction and control transaction ordering

**Prerequisites:**
- Block production rights (validators have this legitimately)
- Technical ability to compute hashes (straightforward)
- Multiple controlled addresses (trivial to create)
- No special permissions beyond standard mining

**Detection Difficulty:**
- Appears as normal NFT protocol creation on-chain
- No cryptographic evidence of malicious intent
- Can be disguised as "fortunate" random allocation
- Only statistical analysis showing miners' abnormal clustering at desirable numbers would reveal the pattern

**Economic Rationality:**
- Attack cost: Minimal (only transaction fees)
- Potential benefit: Market premium on desirable symbols (if any)
- Risk: Low technical/financial risk; only reputation damage if detected statistically

**Probability: HIGH** if symbol numbers have perceived market value and validators have economic incentive in NFT markets.

## Recommendation

Implement a commit-reveal scheme for NFT protocol creation:

1. **Commit Phase**: User submits a commitment hash containing their intended NFT parameters and a secret nonce, along with a deposit
2. **Waiting Period**: Enforce a minimum delay (e.g., 10 blocks) to ensure future randomness is unpredictable at commit time
3. **Reveal Phase**: User reveals the original parameters and nonce. The contract verifies the commitment and uses randomness from a block height that was unpredictable during the commit phase
4. **Symbol Generation**: Combine the revealed nonce, sender address, and unpredictable future randomness to generate the symbol number

Alternatively, use `Context.CurrentHeight` (current block) or `Context.CurrentHeight.Add(1)` (next block) instead of `Context.CurrentHeight.Sub(1)`, though this requires VRF proof generation to happen at commitment time, which may be infeasible without protocol changes.

The simplest fix is to add user-provided entropy (a random nonce) to the hash computation that must be committed before symbol generation, preventing miners from grinding through multiple addresses.

## Proof of Concept

```csharp
// Test demonstrating predictable symbol number generation
[Fact]
public void MinerCanPredictSymbolNumbers()
{
    // Setup: Deploy contracts and initialize
    var keyPair1 = SampleECKeyPairs.KeyPairs[0];
    var keyPair2 = SampleECKeyPairs.KeyPairs[1];
    var keyPair3 = SampleECKeyPairs.KeyPairs[2];
    
    // Simulate miner producing block H, where RandomHashes[H-1] is already known
    var blockHeight = 100L;
    var previousRandomHash = HashHelper.ComputeFrom("known_random_hash");
    
    // Miner can compute offline what symbol each address would yield
    var results = new Dictionary<Address, long>();
    
    foreach (var keyPair in new[] { keyPair1, keyPair2, keyPair3 })
    {
        var address = Address.FromPublicKey(keyPair.PublicKey);
        var randomHash = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(address),
            HashHelper.ComputeFrom(previousRandomHash.ToByteArray())
        );
        
        // Convert to symbol number (minimum 9 digits)
        var from = 100000000L;
        var symbolNumber = ConvertHashToInt64(randomHash, from, from * 10);
        results[address] = symbolNumber;
    }
    
    // Miner selects the address with the lowest (most desirable) symbol number
    var bestAddress = results.OrderBy(x => x.Value).First().Key;
    var bestSymbolNumber = results[bestAddress];
    
    // Verify miner can achieve systematic advantage
    var averageSymbol = results.Values.Average();
    Assert.True(bestSymbolNumber < averageSymbol, 
        "Miner can systematically select addresses yielding lower symbol numbers");
}
```

**Notes:**
- This vulnerability relies on the economic assumption that certain symbol numbers (lower, memorable patterns) have higher perceived market value in NFT markets
- The attack is systemic and affects fairness rather than causing direct financial loss
- Detection requires statistical analysis of symbol allocation patterns across miner-created vs. user-created NFT protocols
- The vulnerability exists at the intersection of consensus (block production) and NFT protocol design, making it a valid concern for protocol integrity

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-27)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L43-53)
```csharp
        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L71-77)
```csharp
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L79-82)
```csharp
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L117-122)
```csharp
    public override Hash GetRandomHash(Int64Value input)
    {
        Assert(input.Value > 1, "Invalid block height.");
        Assert(Context.CurrentHeight >= input.Value, "Block height not reached.");
        return State.RandomHashes[input.Value] ?? Hash.Empty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L124-129)
```csharp
    public override BytesValue GetRandomBytes(BytesValue input)
    {
        var height = new Int64Value();
        height.MergeFrom(input.Value);
        return GetRandomHash(height).ToBytesValue();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```
