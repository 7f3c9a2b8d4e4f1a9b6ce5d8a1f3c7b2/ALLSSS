# Audit Report

## Title
TokenHash Collision Vulnerability Enables Cross-Protocol State Corruption and Allowance Theft

## Summary
The NFT contract's `CalculateTokenHash()` function concatenates symbol and tokenId without a delimiter, enabling hash collisions between different NFT protocols. When protocol symbols grow from N-digit to (N+1)-digit numbers, the string "PREFIX + N-digit + tokenId" can equal "PREFIX + (N+1)-digit + tokenId", creating identical hashes. This allows attackers to exploit shared state mappings (AllowanceMap, BalanceMap, NftInfoMap) to steal allowances, corrupt NFT metadata, and manipulate balances across unrelated protocols.

## Finding Description

The core vulnerability exists in the token hash calculation mechanism. [1](#0-0) 

NFT protocol symbols are generated as 2-character prefix plus N-digit random numbers, where N starts at 9. [2](#0-1) [3](#0-2) 

The number length dynamically increases as more protocols are created. [4](#0-3) 

This creates collision scenarios where:
- Protocol A: "AR123456789" (9-digit) + tokenId=123 → hash("AR123456789123")  
- Protocol B: "AR1234567891" (10-digit) + tokenId=23 → hash("AR123456789123")

Users can specify custom tokenIds when minting. [5](#0-4) 

All critical state mappings are keyed solely by tokenHash. [6](#0-5) 

The vulnerability is exploitable when Protocol B has `IsTokenIdReuse=true`, which bypasses uniqueness validation. [7](#0-6) 

When a collision occurs, the existing NFTInfo from Protocol A is retrieved and updated without changing its Symbol field, causing state corruption. [8](#0-7) 

The allowance system queries state using only the tokenHash, enabling cross-protocol allowance abuse. [9](#0-8) [10](#0-9) 

## Impact Explanation

**Critical Severity** - This vulnerability enables multiple attack vectors with direct fund impact:

1. **Allowance Theft**: An attacker who controls or compromises an approved spender can spend allowances granted for a different protocol's NFT. If Alice approves Bob for Protocol A's NFT and an attacker creates Protocol B with a colliding tokenHash (IsTokenIdReuse=true), the attacker (as Bob) can call TransferFrom using Protocol B's symbol/tokenId to drain Alice's Protocol A balance.

2. **Balance Corruption**: Since BalanceMap is keyed only by tokenHash, transfers on one protocol's NFT affect balances for the colliding protocol's NFT. This allows artificial balance inflation or drainage across unrelated protocols.

3. **NFT Metadata Corruption**: When minting with a colliding tokenHash, the NFTInfo's Symbol field retains the original protocol's symbol while quantities and minter lists get mixed. This breaks the fundamental invariant that each NFT has a unique, consistent identity.

The vulnerability breaks the security guarantee that each (symbol, tokenId) pair represents a distinct, isolated NFT with its own allowances and state.

## Likelihood Explanation

**Medium to High Likelihood**:

1. **Natural Collision Emergence**: For every 9-digit protocol (e.g., "AR123456789"), there are 10 possible colliding 10-digit protocols ("AR1234567890" through "AR1234567899"). With thousands of protocols across different number length tiers, collisions become statistically likely through normal protocol creation.

2. **Attacker Requirements**: 
   - Ability to create NFT protocols (public function)
   - Ability to mint NFTs with custom tokenIds (standard feature)
   - Protocol B must have IsTokenIdReuse=true (attacker-controlled during creation)
   - For allowance theft: requires an approved spender who is malicious or compromised

3. **Attack Complexity**: Low - attackers can monitor on-chain protocol creations, calculate collision pairs using simple string matching, and execute standard minting/transfer operations.

4. **Detection Difficulty**: Extremely difficult - collisions appear as legitimate state updates and the corrupted state persists silently.

## Recommendation

Add a delimiter to the hash calculation to ensure unique inputs for different (symbol, tokenId) pairs:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}#{tokenId}");
}
```

Or use a structured hashing approach:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol),
        HashHelper.ComputeFrom(tokenId)
    );
}
```

Additionally, add collision detection in PerformMint to verify that the NFTInfo.Symbol matches the input symbol when nftInfo already exists.

## Proof of Concept

```csharp
[Fact]
public async Task TokenHashCollision_AllowanceTheft()
{
    // Setup: Create Protocol A with 9-digit symbol
    var protocolA = await CreateNFTProtocol("Art"); // Gets symbol like "AR123456789"
    var aliceAddress = Address.FromPublicKey(SampleAddress.PublicKeys[0]);
    var bobAddress = Address.FromPublicKey(SampleAddress.PublicKeys[1]);
    
    // Alice mints NFT in Protocol A with tokenId=123
    await MintNFT(protocolA.Symbol, tokenId: 123, owner: aliceAddress);
    var tokenHashA = CalculateHash(protocolA.Symbol, 123); // "AR123456789123"
    
    // Alice approves Bob for 10 units
    await ApproveNFT(protocolA.Symbol, 123, bobAddress, 10);
    
    // Attacker creates Protocol B with IsTokenIdReuse=true
    // Waits for symbol "AR1234567891" (10-digit, starts with Protocol A's prefix)
    var protocolB = await CreateNFTProtocol("Art", isTokenIdReuse: true);
    Assert.Equal("AR1234567891", protocolB.Symbol);
    
    // Calculate collision: "AR1234567891" + "23" = "AR123456789123"
    var tokenHashB = CalculateHash(protocolB.Symbol, 23);
    Assert.Equal(tokenHashA, tokenHashB); // COLLISION
    
    // Bob (or attacker controlling Bob) transfers using Protocol B
    var result = await TransferFrom(
        symbol: protocolB.Symbol, 
        tokenId: 23,
        from: aliceAddress,
        to: bobAddress,
        amount: 10
    );
    
    // VULNERABILITY: Alice's Protocol A balance decreased via Protocol B operation
    var aliceBalanceA = await GetBalance(protocolA.Symbol, 123, aliceAddress);
    Assert.Equal(0, aliceBalanceA); // Alice lost her Protocol A NFT
    
    var bobBalanceB = await GetBalance(protocolB.Symbol, 23, bobAddress);
    Assert.Equal(10, bobBalanceB); // Bob gained Protocol B balance using Protocol A allowance
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L64-66)
```csharp
            var allowance = State.AllowanceMap[tokenHash][input.From][Context.Sender];
            Assert(allowance >= input.Amount, "Not approved.");
            State.AllowanceMap[tokenHash][input.From][Context.Sender] = allowance.Sub(input.Amount);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L392-392)
```csharp
        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L432-437)
```csharp
        }
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-30)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L54-64)
```csharp
    public override GetAllowanceOutput GetAllowance(GetAllowanceInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        return new GetAllowanceOutput
        {
            Owner = input.Owner,
            Spender = input.Spender,
            TokenHash = tokenHash,
            Allowance = State.AllowanceMap[tokenHash][input.Owner][input.Spender]
        };
    }
```
