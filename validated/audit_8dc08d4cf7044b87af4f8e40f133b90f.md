# Audit Report

## Title
Negative DepositBalance Due to Missing Validation in Sell Operation Allows Cross-Connector Balance Contamination

## Summary
The `Sell` function in TokenConverterContract calculates `amountToReceive` using the Bancor formula with combined `VirtualBalance + DepositBalance`, but only decrements `DepositBalance` without validating that `amountToReceive <= DepositBalance`. Since multiple connector pairs share the same base token pool, a sell operation can succeed by draining tokens allocated to other connectors, causing the affected connector's `DepositBalance` to become negative and breaking accounting integrity.

## Finding Description

The vulnerability exists in the `Sell` function where Bancor pricing and balance accounting are critically misaligned. 

When calculating the amount to receive, the function calls `GetSelfBalance(toConnector)` which returns the sum of virtual and deposit balances for deposit account connectors with virtual balance enabled: [1](#0-0) 

The Sell function then uses this combined balance in the Bancor formula to calculate `amountToReceive`: [2](#0-1) 

After transferring base tokens to the seller, the contract decrements only `DepositBalance` without any validation: [3](#0-2) 

**Root Cause**: There is no assertion ensuring `amountToReceive <= State.DepositBalance[toConnector.Symbol]` before the subtraction. The `SafeMath.Sub()` operation uses checked arithmetic, but for signed types like `long`, it only prevents overflow/underflow at type boundaries, not negative values within the valid range: [4](#0-3) 

The `DepositBalance` state variable is defined as `MappedState<string, long>`, which is a signed 64-bit integer: [5](#0-4) 

**Why Existing Protections Fail**: The base token transfer checks the contract's **total** base token balance across all connectors, not the per-connector `DepositBalance`. Multiple connector pairs are initialized with the same base token in production: [6](#0-5) 

This initialization creates multiple deposit account connectors (NTREAD, NTWRITE, NTSTORAGE, NTTRAFFIC, NTCPU, NTRAM, NTDISK, NTNET) with large virtual balances (10,000,000 ELF each) that all share the same base token pool: [7](#0-6) 

A sell operation on one connector can succeed by using tokens from another connector's `DepositBalance`, leaving the first connector with a negative `DepositBalance`.

## Impact Explanation

**Broken Accounting Invariants**:
- `DepositBalance` can become negative, violating the critical invariant that deposit balances must be non-negative
- The system's accounting diverges from actual token holdings, corrupting all subsequent pricing calculations

**Cross-Connector Contamination**:
- Users can extract more base tokens from a specific connector than actually allocated to it
- One connector's reserves can be drained through sells on another connector
- Connectors become insolvent while appearing to have positive virtual balances

**Corrupted Pricing**:
The `GetDepositConnectorBalance` view function returns incorrect values when `DepositBalance` is negative: [8](#0-7) 

When `State.DepositBalance[ntSymbol]` is negative, the returned balance appears lower than `VirtualBalance` alone, and all subsequent Bancor calculations use this corrupted balance data, leading to systematically incorrect pricing for all users.

**Affected Parties**:
- Users trading on connectors with negative `DepositBalance` receive systematically incorrect prices
- Liquidity providers suffer fund misallocation as their deposits are used to cover other connectors' deficits
- The entire TokenConverter system's integrity is compromised

## Likelihood Explanation

**Reachable Entry Point**: The `Sell` function is a public method callable by any user: [9](#0-8) 

**Attacker Capabilities**:
- No privileged access required
- Attacker must acquire resource tokens (READ, WRITE, STORAGE, TRAFFIC, CPU, RAM, DISK, NET) through normal buying or transfers
- Sufficient capital needed to create the imbalance scenario

**Feasible Preconditions**:
- Multiple connector pairs exist in production (8 resource tokens as verified in initialization)
- Through normal trading activity, connectors can reach states where one has large VirtualBalance but small DepositBalance
- Other connectors have sufficient DepositBalance to cover the total contract transfer
- The Bancor formula calculates returns based on virtual+deposit but only deposit gets decremented

**Execution Scenario**:
After normal trading activity creates the conditions:
- Connector NTREAD: VirtualBalance = 10,000,000, DepositBalance = 100
- Connector NTWRITE: VirtualBalance = 10,000,000, DepositBalance = 10,000
- Total contract ELF balance: 10,100

Attacker sells READ tokens:
1. `GetSelfBalance(NTREAD)` returns 10,000,000 + 100 = 10,000,100
2. Bancor calculates `amountToReceive` = 500 (< 10,000,100 but > 100)
3. Transfer of 500 ELF succeeds (contract has 10,100 total)
4. `DepositBalance[NTREAD] = 100.Sub(500) = -400` (no exception thrown, as SafeMath.Sub only prevents type overflow)

The vulnerability is exploitable under realistic market conditions without requiring sophisticated manipulation.

## Recommendation

Add validation before decrementing `DepositBalance` to ensure the connector has sufficient actual reserves:

```csharp
public override Empty Sell(SellInput input)
{
    var fromConnector = State.Connectors[input.Symbol];
    Assert(fromConnector != null, "[Sell]Can't find from connector.");
    Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[Sell]Can't find to connector.");
    
    var amountToReceive = BancorHelper.GetReturnFromPaid(
        GetSelfBalance(fromConnector), GetWeight(fromConnector),
        GetSelfBalance(toConnector), GetWeight(toConnector),
        input.Amount
    );

    var fee = Convert.ToInt64(amountToReceive * GetFeeRate());
    if (Context.Sender ==
        Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

    var amountToReceiveLessFee = amountToReceive.Sub(fee);
    Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

    // ADD THIS VALIDATION
    if (toConnector.IsDepositAccount)
    {
        var currentDepositBalance = State.DepositBalance[toConnector.Symbol];
        Assert(amountToReceive <= currentDepositBalance, 
            "Insufficient deposit balance in connector.");
    }

    // Pay fee
    if (fee > 0) HandleFee(fee);

    // Transfer base token
    State.TokenContract.Transfer.Send(
        new TransferInput
        {
            Symbol = State.BaseTokenSymbol.Value,
            To = Context.Sender,
            Amount = amountToReceive
        });
    State.DepositBalance[toConnector.Symbol] =
        State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
    
    // Transfer sold token
    State.TokenContract.TransferFrom.Send(
        new TransferFromInput
        {
            Symbol = input.Symbol,
            From = Context.Sender,
            To = Context.Self,
            Amount = input.Amount
        });
    Context.Fire(new TokenSold
    {
        Symbol = input.Symbol,
        SoldAmount = input.Amount,
        BaseAmount = amountToReceive,
        FeeAmount = fee
    });
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task Test_NegativeDepositBalance_CrossConnectorContamination()
{
    // Setup: Initialize two connector pairs with shared base token
    await InitializeTreasuryContractAsync();
    
    // Create READ token
    await ExecuteProposalForParliamentTransaction(TokenContractAddress, 
        nameof(TokenContractStub.Create),
        new CreateInput
        {
            Symbol = "READ",
            Decimals = 2,
            IsBurnable = true,
            Issuer = DefaultSender,
            Owner = DefaultSender,
            TokenName = "Read Resource",
            TotalSupply = 100_0000L,
            LockWhiteList = { TokenContractAddress, TokenConverterContractAddress }
        });
    
    // Create WRITE token
    await ExecuteProposalForParliamentTransaction(TokenContractAddress, 
        nameof(TokenContractStub.Create),
        new CreateInput
        {
            Symbol = "WRITE",
            Decimals = 2,
            IsBurnable = true,
            Issuer = DefaultSender,
            Owner = DefaultSender,
            TokenName = "Write Resource",
            TotalSupply = 100_0000L,
            LockWhiteList = { TokenContractAddress, TokenConverterContractAddress }
        });
    
    // Initialize TokenConverter with two deposit account connectors
    var ntReadConnector = new Connector
    {
        Symbol = "NTREAD",
        VirtualBalance = 10_000_000_00L, // 10 million (with 2 decimals)
        Weight = "0.5",
        IsPurchaseEnabled = true,
        IsVirtualBalanceEnabled = true,
        RelatedSymbol = "READ",
        IsDepositAccount = true
    };
    
    var readConnector = new Connector
    {
        Symbol = "READ",
        VirtualBalance = 0,
        Weight = "0.5",
        IsPurchaseEnabled = true,
        IsVirtualBalanceEnabled = false,
        RelatedSymbol = "NTREAD",
        IsDepositAccount = false
    };
    
    var ntWriteConnector = new Connector
    {
        Symbol = "NTWRITE",
        VirtualBalance = 10_000_000_00L,
        Weight = "0.5",
        IsPurchaseEnabled = true,
        IsVirtualBalanceEnabled = true,
        RelatedSymbol = "WRITE",
        IsDepositAccount = true
    };
    
    var writeConnector = new Connector
    {
        Symbol = "WRITE",
        VirtualBalance = 0,
        Weight = "0.5",
        IsPurchaseEnabled = true,
        IsVirtualBalanceEnabled = false,
        RelatedSymbol = "NTWRITE",
        IsDepositAccount = false
    };
    
    await DefaultStub.Initialize.SendAsync(new InitializeInput
    {
        BaseTokenSymbol = "ELF",
        FeeRate = "0.005",
        Connectors = { readConnector, ntReadConnector, writeConnector, ntWriteConnector }
    });
    
    // Issue tokens to converter
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "READ",
        Amount = 100_0000L,
        To = TokenConverterContractAddress,
        Memo = "Issue READ"
    });
    
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "WRITE",
        Amount = 100_0000L,
        To = TokenConverterContractAddress,
        Memo = "Issue WRITE"
    });
    
    // Setup: Buy some READ tokens to have them for selling
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenConverterContractAddress,
        Symbol = "ELF",
        Amount = 1000L
    });
    
    await DefaultStub.Buy.SendAsync(new BuyInput
    {
        Symbol = "READ",
        Amount = 100L,
        PayLimit = 1000L
    });
    
    // At this point: NTREAD has small DepositBalance, NTWRITE has larger DepositBalance
    var ntReadBalanceBefore = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = "READ" });
    
    // Approve READ tokens for selling
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenConverterContractAddress,
        Symbol = "READ",
        Amount = 100L
    });
    
    // Exploit: Sell READ tokens which calculates return based on VirtualBalance + DepositBalance
    // but only decrements DepositBalance, potentially making it negative
    var sellResult = await DefaultStub.Sell.SendAsync(new SellInput
    {
        Symbol = "READ",
        Amount = 100L,
        ReceiveLimit = 0L
    });
    
    sellResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: NTREAD now has negative DepositBalance
    var ntReadBalanceAfter = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = "READ" });
    
    // The balance decreased by more than the actual DepositBalance, proving negative value
    (ntReadBalanceBefore.Value - ntReadBalanceAfter.Value).ShouldBeGreaterThan(ntReadBalanceBefore.Value);
}
```

## Notes

This vulnerability represents a fundamental accounting flaw in the TokenConverter contract where the pricing mechanism (Bancor formula using combined virtual + deposit balances) is disconnected from the accounting mechanism (only tracking deposit balances). The C# `checked` arithmetic in SafeMath.Sub prevents type-level overflow but does not prevent negative values within the valid range of `long`, allowing `DepositBalance` to become negative. This breaks the critical invariant that connector reserves must be non-negative and enables cross-connector balance contamination since all deposit account connectors share the same base token pool.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-172)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L186-194)
```csharp
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs (L19-19)
```csharp
    public MappedState<string, long> DepositBalance { get; set; }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L226-259)
```csharp
        foreach (var resourceTokenSymbol in Context.Variables
                     .GetStringArray(EconomicContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(EconomicContractConstants.PayRentalSymbolListName)))
        {
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.ResourceTokenInitialVirtualBalance,
                RelatedSymbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsDepositAccount = false
            };
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
            connectors.Add(resourceTokenConnector);
            connectors.Add(nativeTokenConnector);
        }

        State.TokenConverterContract.Initialize.Send(new InitializeInput
        {
            FeeRate = EconomicContractConstants.TokenConverterFeeRate,
            Connectors = { connectors },
            BaseTokenSymbol = Context.Variables.NativeSymbol
        });
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L20-20)
```csharp
    public const long NativeTokenToResourceBalance = 10_000_000_00000000;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L93-102)
```csharp
    public override Int64Value GetDepositConnectorBalance(StringValue symbolInput)
    {
        var connector = State.Connectors[symbolInput.Value];
        Assert(connector != null && !connector.IsDepositAccount, "token symbol is invalid");
        var ntSymbol = connector.RelatedSymbol;
        return new Int64Value
        {
            Value = State.Connectors[ntSymbol].VirtualBalance + State.DepositBalance[ntSymbol]
        };
    }
```
