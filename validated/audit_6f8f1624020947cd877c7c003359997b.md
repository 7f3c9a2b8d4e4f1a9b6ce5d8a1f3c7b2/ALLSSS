# Audit Report

## Title
Scheme Manager Can Modify Critical Parameters After User Registration, Breaking Withdrawal and Lock Period Expectations

## Summary
The TokenHolder contract's `CreateScheme` method lacks protection against repeated invocation, allowing scheme managers to overwrite critical parameters (Symbol, MinimumLockMinutes) after users have locked tokens. This causes permanent fund lockup when withdrawal operations query for the wrong token symbol or validate against extended lock periods that users never agreed to.

## Finding Description

The `CreateScheme` method unconditionally overwrites scheme parameters without validating whether users have already registered or tokens have been locked. [1](#0-0) 

The method creates a new profit scheme in the underlying Profit contract (which permits multiple schemes per manager) and then directly assigns a new `TokenHolderProfitScheme` to `State.TokenHolderProfitSchemes[Context.Sender]`, overwriting any existing scheme data stored at that key. [2](#0-1) 

When users register via `RegisterForProfits`, they lock tokens using the current scheme's Symbol parameter and the lock timestamp is recorded: [3](#0-2) 

The Profit contract allows managers to create multiple schemes, adding each new schemeId to the manager's list: [4](#0-3) 

However, when users attempt to withdraw, the code retrieves the CURRENT scheme parameters from `State.TokenHolderProfitSchemes[manager]` (which have been overwritten) and uses them to query locked amounts and validate lock durations: [5](#0-4) 

The `UpdateTokenHolderProfitScheme` helper retrieves the first profit scheme ID from the manager's list but does NOT update the Symbol or MinimumLockMinutes - those remain as stored in the overwritten TokenHolder state: [6](#0-5) 

The MultiToken contract's `GetLockedAmount` queries balance by symbol - tokens locked with "ELF" will return 0 when queried with "BTC": [7](#0-6) 

Similarly, `Unlock` operations are symbol-specific and cannot unlock tokens locked under a different symbol: [8](#0-7) 

**Attack Scenario:**
1. Manager calls `CreateScheme(Symbol="ELF", MinimumLockMinutes=1440)`
2. User registers and locks 100 ELF tokens with lockId, expecting 1-day lock period
3. Manager calls `CreateScheme(Symbol="USDT", MinimumLockMinutes=43200)` - overwrites state
4. User attempts withdrawal after 1440 minutes:
   - `GetLockedAmount` queries for "USDT" symbol → returns 0 (user locked "ELF")
   - Time validation checks against 43200 minutes → fails (only 1440 passed)
   - Even after 43200 minutes, `Unlock` attempts to unlock 0 "USDT" tokens, leaving "ELF" tokens permanently locked

## Impact Explanation

This vulnerability enables **permanent theft of user funds** through parameter manipulation:

**Symbol Modification Attack**: Changing the Symbol after users lock tokens causes `GetLockedAmount` to query the wrong symbol (returning 0) and `Unlock` to attempt unlocking the wrong token type, leaving the originally locked tokens permanently inaccessible in the virtual address. Users lose 100% of their locked funds with no recovery mechanism.

**MinimumLockMinutes Extension Attack**: Increasing MinimumLockMinutes from 1440 to 43200 (or any arbitrary value) prevents users from withdrawing for 30 days instead of the agreed 1 day. This can be repeated indefinitely to trap funds permanently, as each new `CreateScheme` call resets the minimum lock period to an arbitrarily high value.

**Combined Attack**: Both attacks can occur simultaneously, maximizing impact - users face both extended lock periods AND symbol mismatches that make withdrawal impossible even after the lock period.

All users who registered before the second `CreateScheme` call are affected. This violates the core security invariant that locked tokens must be unlockable after the lock period expires using the same parameters they were locked with.

## Likelihood Explanation

This attack is **trivially executable** with high likelihood:

**No Authorization Barriers**: `CreateScheme` is a public method with no access controls preventing repeated calls. Any address can be a scheme manager by simply calling `CreateScheme` once.

**Minimal Preconditions**: The attacker only needs to:
- Call `CreateScheme` once to become a manager
- Wait for users to register (economically incentivized by profit-sharing schemes)
- Call `CreateScheme` again with malicious parameters

**Simple Execution**: The attack requires exactly two standard transactions with no complex timing, no need to manipulate other contracts, and no cryptographic operations. Gas costs are negligible compared to the value of trapped funds.

**Economic Incentive**: Malicious scheme managers can:
- Continue collecting profit contributions while preventing withdrawals
- Force users to forfeit their stake to exit
- Extend lock periods indefinitely to maintain control over user capital

**No Detection/Protection**: The codebase contains no validation preventing multiple `CreateScheme` calls, no events alerting users to parameter changes, and no mechanism for users to verify scheme immutability before locking tokens.

## Recommendation

Implement one of the following fixes:

**Option 1 - Prevent Scheme Modification (Recommended)**:
Add a check at the start of `CreateScheme` to prevent overwriting existing schemes:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    var existingScheme = State.TokenHolderProfitSchemes[Context.Sender];
    Assert(existingScheme == null, "Scheme already exists. Cannot modify existing scheme.");
    
    // ... rest of implementation
}
```

**Option 2 - Explicit Scheme Updates with Restrictions**:
Create a separate `UpdateScheme` method that validates no users are registered and no tokens are locked:

```csharp
public override Empty UpdateScheme(CreateTokenHolderProfitSchemeInput input)
{
    var scheme = State.TokenHolderProfitSchemes[Context.Sender];
    Assert(scheme != null, "Scheme does not exist.");
    
    // Verify no beneficiaries exist in profit scheme
    var profitScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
    Assert(profitScheme.TotalShares == 0, "Cannot update scheme with active beneficiaries.");
    
    // Update parameters
    scheme.Symbol = input.Symbol;
    scheme.MinimumLockMinutes = input.MinimumLockMinutes;
    State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    return new Empty();
}
```

**Option 3 - Store Parameters Per Registration**:
Record Symbol and MinimumLockMinutes in the lock record at registration time, not in the scheme object, ensuring withdrawal uses the parameters the user agreed to.

## Proof of Concept

```csharp
[Fact]
public async Task ManagerCanTrapUserFundsByModifyingSchemeParameters()
{
    // Step 1: Manager creates initial scheme with Symbol="ELF", MinimumLockMinutes=1 day
    var manager = Accounts[0].Address;
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1440 // 1 day
    });

    // Step 2: User registers and locks 100 ELF tokens
    var user = Accounts[1].Address;
    var lockAmount = 100_00000000; // 100 ELF
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = TokenHolderContractAddress,
        Symbol = "ELF",
        Amount = lockAmount
    });
    
    await UserTokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = manager,
        Amount = lockAmount
    });

    // Verify tokens are locked
    var lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = user,
        Symbol = "ELF",
        LockId = /* lockId from State.LockIds[manager][user] */
    });
    lockedAmount.Amount.ShouldBe(lockAmount);

    // Step 3: Manager maliciously calls CreateScheme again with different parameters
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT", // Changed symbol!
        MinimumLockMinutes = 43200 // 30 days instead of 1 day!
    });

    // Step 4: User tries to withdraw after 1440 minutes (1 day) - FAILS
    // Time validation will fail because scheme now requires 43200 minutes
    var withdrawResult = await UserTokenHolderContractStub.Withdraw.SendWithExceptionAsync(manager);
    withdrawResult.TransactionResult.Error.ShouldContain("Cannot withdraw");

    // Step 5: Even after 43200 minutes pass, GetLockedAmount returns 0 for "USDT"
    // Unlock will attempt to unlock 0 USDT tokens, leaving ELF locked forever
    // User's 100 ELF tokens are permanently trapped
}
```

This test demonstrates that a scheme manager can trap user funds by calling `CreateScheme` multiple times, causing withdrawal to fail due to symbol mismatches and extended lock periods that users never consented to.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-167)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-244)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L10-10)
```csharp
    public MappedState<Address, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-116)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L224-252)
```csharp
    public override Empty Unlock(UnlockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");

        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        Context.SendVirtualInline(fromVirtualAddress, Context.Self, nameof(Transfer), new TransferInput
        {
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        DealWithExternalInfoDuringUnlock(new TransferFromInput
        {
            From = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress),
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```
