# Audit Report

## Title
Unfair Extra Block Producer Selection Due to Unvalidated TuneOrderInformation Manipulation

## Summary
Miners can manipulate extra block producer selection by providing arbitrary `TuneOrderInformation` values in `UpdateValue` calls, creating duplicate `FinalOrderOfNextRound` values that cause gaps in the mining order sequence. When the calculated extra block producer order falls in a gap, the system falls back to `.First()`, systematically favoring miners with the lowest `FinalOrderOfNextRound` and resulting in unfair consensus reward distribution.

## Finding Description

The AEDPoS consensus mechanism allows miners to unfairly manipulate extra block producer selection through unvalidated `TuneOrderInformation` in `UpdateValue` transactions.

**Attack Mechanism:**

1. When miners call `UpdateValue`, they provide a `TuneOrderInformation` dictionary that directly modifies `FinalOrderOfNextRound` values for all miners without any validation. [1](#0-0) 

2. The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue` fields, completely ignoring `TuneOrderInformation` content. [2](#0-1) 

3. A malicious miner can set multiple miners to have the same `FinalOrderOfNextRound` value (e.g., setting both Miner A and Miner B to order 3), creating duplicate orders.

4. When `GenerateNextRoundInformation` creates the next round, miners are inserted in ascending `FinalOrderOfNextRound` order. [3](#0-2) 

5. Duplicate orders cause gaps in the order sequence (if orders 1, 3, 3, 4 exist, order 2 becomes a gap).

6. When `CalculateNextExtraBlockProducerOrder` returns an order that falls in a gap, no miner matches that order, triggering the `.First()` fallback. [4](#0-3) 

7. The `.First()` call returns the first inserted miner, which is always the miner with the **lowest** `FinalOrderOfNextRound` value, creating deterministic bias.

**Why Validation Fails:**

The `NextRoundMiningOrderValidationProvider` attempts to detect issues by calling `.Distinct()` on `MinerInRound` objects, but this uses reference equality (comparing entire objects), not value equality on the `FinalOrderOfNextRound` field specifically. [5](#0-4) 

Therefore, two different `MinerInRound` objects with the same `FinalOrderOfNextRound` but different public keys are not detected as duplicates, and the validation passes despite the duplicate orders.

## Impact Explanation

**High Severity - Consensus Reward Manipulation**

- **Direct Financial Impact**: Extra block producers receive additional block production rewards. By manipulating the fallback mechanism, attackers can ensure specific miners (those with lowest `FinalOrderOfNextRound`) are systematically selected more often, creating unfair reward accumulation.

- **Consensus Integrity Violation**: The extra block producer role is designed to be fairly distributed based on cryptographic randomness from miner signatures. This vulnerability allows deterministic bias, undermining the fairness guarantees of the AEDPoS consensus mechanism.

- **Cumulative Advantage**: Over many rounds, the biased selection creates significant reward imbalances. Miners who can maintain low `FinalOrderOfNextRound` values through manipulation gain persistent advantage.

- **Network Decentralization Risk**: If certain miners consistently receive more rewards than intended by the protocol, it concentrates rewards and can weaken the blockchain's decentralization properties.

## Likelihood Explanation

**High Likelihood**

- **Easy Execution**: Any elected miner can execute this attack simply by calling `UpdateValue` with crafted `TuneOrderInformation`. No special privileges beyond being a miner are required.

- **No Validation Barrier**: The complete absence of `TuneOrderInformation` validation in `UpdateValueValidationProvider` means the attack succeeds on first attempt.

- **Stealthy Operation**: The manipulation appears as normal consensus behavior. No explicit validation catches duplicate `FinalOrderOfNextRound` values, making detection difficult without analyzing multiple rounds.

- **Repeatable**: The attack can be executed in every round, creating persistent bias over time.

- **Low Risk to Attacker**: The malicious miner faces no immediate penalty or detection, as the behavior looks like legitimate order tuning.

## Recommendation

**Immediate Fixes:**

1. **Add TuneOrderInformation Validation**: Implement strict validation in `UpdateValueValidationProvider` to verify that:
   - All `FinalOrderOfNextRound` values are unique (no duplicates)
   - All values are within valid range [1, minersCount]
   - `TuneOrderInformation` only contains miners who legitimately need order reassignment

2. **Fix NextRoundMiningOrderValidationProvider**: Replace `.Distinct()` on entire objects with a check specifically for duplicate `FinalOrderOfNextRound` values:
```csharp
var ordersWithDuplicates = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .GroupBy(m => m.FinalOrderOfNextRound)
    .Where(g => g.Count() > 1)
    .Any();
    
if (ordersWithDuplicates)
{
    validationResult.Message = "Duplicate FinalOrderOfNextRound detected.";
    return validationResult;
}
```

3. **Verify TuneOrderInformation Authority**: Ensure miners can only tune their own order or orders of miners they have legitimate authority over based on the conflict resolution logic in `ApplyNormalConsensusData`. [6](#0-5) 

4. **Improve Fallback Logic**: Instead of using `.First()` which creates deterministic bias, implement a deterministic but fair fallback (e.g., use round number or block hash to select among all miners).

## Proof of Concept

Due to the complexity of setting up a full AElf consensus test environment with multiple miners, a simplified proof of concept would involve:

1. Deploy AEDPoS contract in test environment with multiple miners
2. Have Miner A produce a block and call `UpdateValue` with legitimate data
3. Have Miner B produce a block and call `UpdateValue` with `TuneOrderInformation` containing:
   - Miner A: `FinalOrderOfNextRound = 3`
   - Miner B: `FinalOrderOfNextRound = 3` (duplicate)
4. Have the last miner call `NextRound` to trigger round transition
5. Verify that `GenerateNextRoundInformation` has gaps in order sequence
6. Verify that if `CalculateNextExtraBlockProducerOrder` returns the gap order, `.First()` is called
7. Verify that the miner with lowest `FinalOrderOfNextRound` is selected as extra block producer
8. Repeat across multiple rounds to demonstrate systematic bias

The test would confirm that:
- `UpdateValueValidationProvider` does not reject the crafted `TuneOrderInformation`
- `NextRoundMiningOrderValidationProvider` does not detect duplicate orders
- The `.First()` fallback systematically favors specific miners

**Notes:**

This vulnerability requires the attacker to be an elected miner, which requires staking tokens and winning election votes. However, once elected, the attack is trivial to execute and highly profitable over time. The lack of validation on `TuneOrderInformation` represents a critical gap in the consensus security model, as it allows miners to arbitrarily manipulate the next round's mining order without cryptographic or protocol constraints.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-40)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```
