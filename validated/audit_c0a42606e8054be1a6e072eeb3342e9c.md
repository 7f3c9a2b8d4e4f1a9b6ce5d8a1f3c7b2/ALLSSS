# Audit Report

## Title
Unreleased Periods Can Permanently Lock Beneficiary Profits

## Summary
The Profit contract contains a critical vulnerability where profits contributed to future periods become permanently inaccessible when the scheme manager stops calling `DistributeProfits` before reaching those periods. The root cause is that `LastProfitPeriod` is incremented during claims even when tokens are not transferred due to `IsReleased=false`, causing beneficiaries to permanently skip unreleased periods and lose access to contributed funds.

## Finding Description

The vulnerability stems from a logic flaw in the interaction between three core functions:

**1. Unrestricted Future Period Contributions**

The `ContributeProfits` method allows anyone to contribute profits to any future period, enforcing only that the period is greater than or equal to the current period. [1](#0-0) 

When contributing to a future period, a `DistributedProfitsInfo` entry is created with `IsReleased` defaulting to `false`. [2](#0-1) 

**2. Sequential Period Release Enforcement**

The `DistributeProfits` method enforces strict sequential period releases by asserting the input period exactly equals the scheme's current period. [3](#0-2) 

After distribution, the current period is incremented by exactly 1. [4](#0-3) 

The `IsReleased` flag is set to `true` only when `DistributeProfits` is called (via `UpdateDistributedProfits`). [5](#0-4) 

There is no mechanism to skip periods or directly release specific future periods.

**3. Unconditional LastProfitPeriod Update**

The critical flaw occurs in the `ProfitAllPeriods` method. When processing periods, the method loops through each period from `LastProfitPeriod` to `maxProfitPeriod`. [6](#0-5) 

If `distributedProfitsInformation` is null, the loop continues without updating `LastProfitPeriod`. [7](#0-6) 

However, if `distributedProfitsInformation` exists (because someone contributed to that period), the method only transfers tokens when `IsReleased` is `true`. [8](#0-7) 

**The bug**: The `lastProfitPeriod` is updated to `period + 1` regardless of whether the transfer occurred. [9](#0-8) 

This updated value is then saved back to the beneficiary's profit detail. [10](#0-9) 

**Attack Scenario:**
1. Current period is 5, beneficiaries exist with shares
2. User contributes 10,000 tokens to period 10 via `ContributeProfits`
3. Manager distributes periods 5, 6, 7 then abandons the scheme (lost keys, death, deliberate)
4. Scheme's `CurrentPeriod` is now 8
5. Beneficiary calls `ClaimProfits`:
   - Loop processes available periods
   - When reaching period 10: `DistributedProfitsInfo` exists with tokens but `IsReleased=false`
   - Transfer is skipped (line 881 check fails)
   - But `lastProfitPeriod` is set to 11 (line 908)
   - This is saved to state (line 917, then line 806 in `ClaimProfits`)
6. Next `ClaimProfits` call starts from period 11, permanently skipping period 10
7. The 10,000 tokens remain locked in period 10's virtual address with no recovery mechanism

## Impact Explanation

**Direct Fund Loss - HIGH Severity:**

- **Permanent Loss**: Tokens contributed to unreleased periods become permanently inaccessible with no recovery mechanism
- **Proportional Impact**: All beneficiaries lose their proportional share - if 10,000 tokens are locked with 100 total shares, each beneficiary with 10 shares loses 1,000 tokens permanently
- **Multiple Periods**: Can affect multiple periods simultaneously if contributions were made to periods 10, 15, 20, etc.

**Protocol Integrity Violation:**

The contract breaks the fundamental guarantee that contributed profits will be distributable. The `ResetManager` function only changes scheme ownership but provides no mechanism to skip periods or release specific unreleased periods. [11](#0-10) 

**Economic Damage:**

Contributed funds are effectively burned from beneficiaries' perspective. The tokens remain in the period's virtual address but become inaccessible to all parties, undermining trust in the profit distribution mechanism.

## Likelihood Explanation

**HIGH Likelihood** due to multiple realistic scenarios:

**1. Accidental User Error (High Probability):**
- User mistypes period 50 instead of 5
- Manager eventually stops managing scheme (abandonment, lost keys, death)
- Period 50's profits become permanently locked

**2. Manager Abandonment (Medium-High Probability):**
- Manager loses private keys (common in blockchain)
- Manager dies without key transfer
- Manager intentionally abandons scheme after collecting early period benefits
- Project discontinuation or scheme becomes obsolete

**3. Malicious Griefing (Medium Probability):**
- Attacker contributes small amounts to distant periods (e.g., period 1000)
- Creates complexity and guaranteed fund loss when scheme is inevitably abandoned

**Preconditions (All Easily Met):**
- Profit scheme exists (common in AElf ecosystem)
- Anyone can call `ContributeProfits` with any future period (verified in code)
- Manager stops calling `DistributeProfits` before reaching contributed periods

**Execution Complexity:** None - uses standard public contract methods with no special permissions or timing requirements.

## Recommendation

**Fix the LastProfitPeriod update logic** to only increment when tokens are actually transferred:

In the `ProfitAllPeriods` method, move the `lastProfitPeriod = period + 1` statement inside the `IsReleased` check:

```csharp
if (!isView)
{
    Context.LogDebug(() => ...);
    if (distributedProfitsInformation.IsReleased && amount > 0)
    {
        // Transfer tokens
        Context.SendVirtualInline(...);
        Context.Fire(new ProfitsClaimed {...});
        
        // Only update LastProfitPeriod after successful transfer
        lastProfitPeriod = period + 1;
    }
}
```

**Alternative: Add period skip mechanism** for the manager to mark unreleased periods as "void" when tokens weren't distributed, allowing beneficiaries to skip them without updating `LastProfitPeriod`.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task UnreleasedPeriod_LocksFunds_Test()
{
    // Setup: Create scheme with beneficiary holding 100 shares
    var schemeId = await CreateSchemeAsync();
    await AddBeneficiaryAsync(schemeId, beneficiary, 100);
    
    // Step 1: Distribute periods 1, 2, 3 normally
    await DistributeProfitsAsync(schemeId, period: 1, amount: 1000);
    await DistributeProfitsAsync(schemeId, period: 2, amount: 1000);
    await DistributeProfitsAsync(schemeId, period: 3, amount: 1000);
    // CurrentPeriod is now 4
    
    // Step 2: User contributes 10,000 tokens to future period 10
    await ContributeProfitsAsync(schemeId, period: 10, amount: 10000);
    
    // Step 3: Manager stops (simulated by not distributing further)
    // CurrentPeriod remains 4, period 10 has IsReleased=false
    
    // Step 4: Beneficiary claims profits
    var balanceBefore = await GetBalanceAsync(beneficiary);
    await ClaimProfitsAsync(schemeId, beneficiary);
    var balanceAfter = await GetBalanceAsync(beneficiary);
    
    // Expected: Should receive 3000 (periods 1-3) + 10000 (period 10) = 13000
    // Actual: Only receives 3000, period 10 is permanently skipped
    balanceAfter.ShouldBe(balanceBefore + 3000); // Only gets periods 1-3
    
    // Step 5: Verify LastProfitPeriod was updated past period 10
    var profitDetails = await GetProfitDetailsAsync(schemeId, beneficiary);
    profitDetails.LastProfitPeriod.ShouldBe(11); // Skipped period 10!
    
    // Step 6: Try claiming again - no additional funds received
    await ClaimProfitsAsync(schemeId, beneficiary);
    var finalBalance = await GetBalanceAsync(beneficiary);
    finalBalance.ShouldBe(balanceAfter); // No change - funds permanently lost
    
    // Verify 10,000 tokens are stuck in period 10's virtual address
    var period10Address = GetPeriodVirtualAddress(schemeId, 10);
    var lockedBalance = await GetBalanceAsync(period10Address);
    lockedBalance.ShouldBe(10000); // Tokens permanently locked
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L479-480)
```csharp
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L568-568)
```csharp
        distributedProfitsInformation.IsReleased = true;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L684-684)
```csharp
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L689-694)
```csharp
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L723-743)
```csharp
    public override Empty ResetManager(ResetManagerInput input)
    {
        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only scheme manager can reset manager.");
        Assert(input.NewManager.Value.Any(), "Invalid new sponsor.");

        // Transfer managing scheme id.
        var oldManagerSchemeIds = State.ManagingSchemeIds[scheme.Manager];
        oldManagerSchemeIds.SchemeIds.Remove(input.SchemeId);
        State.ManagingSchemeIds[scheme.Manager] = oldManagerSchemeIds;
        var newManagerSchemeIds = State.ManagingSchemeIds[input.NewManager] ?? new CreatedSchemeIds();
        newManagerSchemeIds.SchemeIds.Add(input.SchemeId);
        State.ManagingSchemeIds[input.NewManager] = newManagerSchemeIds;

        scheme.Manager = input.NewManager;
        State.SchemeInfos[input.SchemeId] = scheme;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-860)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L868-871)
```csharp
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L881-881)
```csharp
                    if (distributedProfitsInformation.IsReleased && amount > 0)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L908-908)
```csharp
                    lastProfitPeriod = period + 1;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L917-917)
```csharp
        profitDetail.LastProfitPeriod = lastProfitPeriod;
```
