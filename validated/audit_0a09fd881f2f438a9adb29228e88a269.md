# Audit Report

## Title
Hash Collision Vulnerability in NFT Contract Allows Cross-Protocol Data Corruption and Asset Theft

## Summary
The NFT contract's `CalculateTokenHash` function uses naive string concatenation to generate token hashes, enabling attackers to create malicious NFT protocols with symbols that collide with legitimate NFTs. This leads to state corruption across critical storage maps, allowing asset theft through the Disassemble function and denial-of-service attacks preventing legitimate NFT minting.

## Finding Description

The vulnerability stems from the `CalculateTokenHash` implementation which concatenates symbol and tokenId as strings before hashing: [1](#0-0) 

This creates ambiguous hash inputs where different (symbol, tokenId) pairs produce identical strings before hashing. For example:
- Protocol "XX12345678" with TokenId 91 → "XX1234567891"
- Protocol "XX123456789" with TokenId 1 → "XX1234567891"

The NFT contract's `Create` method generates symbols following the format `{2-char-prefix}{9-digit-number}` with minimum 11 characters: [2](#0-1) [3](#0-2) 

However, the TokenContract allows regular tokens with symbols up to 10 characters: [4](#0-3) 

The `CrossChainCreate` method accepts any symbol existing in TokenContract without length validation and is publicly callable with no authorization checks: [5](#0-4) 

During minting, the contract checks if tokenId exists but this check can be bypassed when `IsTokenIdReuse=true`: [6](#0-5) 

When a collision occurs with `IsTokenIdReuse=true`, the existing NFT's data is modified rather than rejected: [7](#0-6) 

The collision affects multiple critical state maps indexed by the same tokenHash: [8](#0-7) [9](#0-8) [10](#0-9) [11](#0-10) 

## Impact Explanation

**Critical Impact - Asset Theft via Disassemble:**

The most severe impact occurs through the Disassemble function. When a hash collision exists, an attacker can call Disassemble with their colliding (symbol, tokenId) pair to steal the victim's assembled NFT/FT components: [12](#0-11) 

The function calculates the tokenHash from the attacker's input, retrieves the victim's assembled assets from state maps indexed by that hash, and transfers them to the attacker.

**Secondary Impacts:**

1. **NFT Metadata Corruption**: When the attacker mints with `IsTokenIdReuse=true`, the victim's NFTInfo quantity and minters list are modified, corrupting protocol integrity.

2. **Balance Map Sharing**: Multiple protocols share the same balance entry, allowing unauthorized balance manipulation through transfers.

3. **Allowance Map Exploitation**: Allowances set for one protocol affect another protocol sharing the hash.

4. **Denial of Service**: If the attacker mints first, legitimate protocols with `IsTokenIdReuse=false` (the default for NFTs) cannot mint their intended tokenIds, as the check will fail.

## Likelihood Explanation

**High Likelihood:**

1. **Public Attack Surface**: The `CrossChainCreate` method has no authorization checks, making it callable by anyone.

2. **Low Attack Cost**: Attackers only need to acquire a SEED NFT (available through market purchase) to create tokens: [13](#0-12) 

3. **Attacker Control**: The attacker controls the token's ExternalInfo during creation. The TokenContract does not validate or restrict NFT-specific keys: [14](#0-13) 

This allows them to set `IsTokenIdReuse=true` to bypass collision detection.

4. **Deterministic Exploitation**: Hash calculation is deterministic, enabling precise targeting of victim NFT protocols by calculating which (symbol, tokenId) pairs produce desired collisions.

5. **No On-Chain Detection**: Hash collisions appear as normal NFT operations with no obvious indicators, making detection difficult.

## Recommendation

**Immediate Fix:**

Modify `CalculateTokenHash` to use a delimiter or structured encoding that prevents ambiguity:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol),
        HashHelper.ComputeFrom(tokenId)
    );
}
```

**Additional Hardening:**

1. Add symbol length validation to `CrossChainCreate` to enforce minimum 11 characters
2. Add authorization checks to `CrossChainCreate` or validate that the symbol follows NFT format conventions
3. Prevent regular tokens from using NFT-specific ExternalInfo keys in TokenContract

## Proof of Concept

```csharp
[Fact]
public async Task HashCollision_AssetTheft_Test()
{
    // Victim creates NFT protocol "XX123456789" (11 chars) and mints tokenId=1
    var victimSymbol = "XX123456789";
    var victimTokenId = 1L;
    // Victim assembles valuable assets...
    
    // Attacker creates token "XX12345678" (10 chars) with NFT ExternalInfo
    var attackerSymbol = "XX12345678";
    var attackerTokenId = 91L;
    
    // Calculate hashes - they collide!
    var victimHash = CalculateTokenHash(victimSymbol, victimTokenId);
    var attackerHash = CalculateTokenHash(attackerSymbol, attackerTokenId);
    victimHash.ShouldBe(attackerHash); // Collision!
    
    // Attacker calls CrossChainCreate to register as NFT protocol
    await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
    {
        Symbol = attackerSymbol
    });
    
    // Attacker mints with IsTokenIdReuse=true to bypass uniqueness check
    await NFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = attackerSymbol,
        TokenId = attackerTokenId,
        Quantity = 1
    });
    
    // Attacker calls Disassemble to steal victim's assembled assets
    await NFTContractStub.Disassemble.SendAsync(new DisassembleInput
    {
        Symbol = attackerSymbol,
        TokenId = attackerTokenId
    });
    
    // Victim's assets are now transferred to attacker
}

private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}{tokenId}");
}
```

## Notes

This vulnerability breaks the fundamental security guarantee that each (symbol, tokenId) pair uniquely identifies an NFT with isolated state. The naive string concatenation in hash calculation allows attackers to deliberately craft symbols that collide with existing NFTs, enabling cross-protocol state corruption and asset theft. The attack is practical because TokenContract's symbol length limit (10 chars) is shorter than NFT's minimum symbol length (11 chars), and CrossChainCreate lacks proper validation to prevent this mismatch from being exploited.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-236)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }

        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
        }

        Context.Fire(new Disassembled
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            DisassembledNfts = assembledNfts ?? new AssembledNfts(),
            DisassembledFts = assembledFts ?? new AssembledFts()
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-437)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L7-7)
```csharp
    public const int SymbolMaxLength = 10;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-17)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L22-22)
```csharp
    public MappedState<Hash, Address, long> BalanceMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L30-30)
```csharp
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-33)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```
