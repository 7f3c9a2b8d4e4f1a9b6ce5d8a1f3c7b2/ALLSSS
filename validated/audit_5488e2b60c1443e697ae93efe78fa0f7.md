# Audit Report

## Title
Replacement Miners Unfairly Penalized in Reward Distribution Due to Missing Treasury Notification

## Summary
When evil miners are detected and replaced during consensus round generation, the Consensus contract fails to notify the Treasury contract via `RecordMinerReplacement`. This causes replacement miners to be incorrectly penalized by the standard `CalculateShares()` formula during reward distribution, despite joining mid-term to maintain network consensus.

## Finding Description

The vulnerability exists in the evil miner replacement flow spanning the Consensus (AEDPoS) and Treasury contracts:

**Missing Treasury Notification:**
When the Consensus contract's `GenerateNextRoundInformation` method detects evil miners via `GetMinerReplacementInformation`, it updates the round information and fires events but never calls `TreasuryContract.RecordMinerReplacement`. [1](#0-0) 

The replacement happens at the consensus layer (evil miner removed, replacement miner added to the current round), but the Treasury contract is never informed.

**Only Call Site is Wrong Context:**
The ONLY call to `RecordMinerReplacement` in the entire codebase occurs within the `RecordCandidateReplacement` method, which handles voluntary pubkey changes initiated by the Election contract, NOT evil miner detection. [2](#0-1) 

This call does not set the `IsOldPubkeyEvil` parameter in the message, meaning it defaults to `false`.

**Flag Design Intent:**
The Treasury contract's `RecordMinerReplacement` method sets the `IsReplacedEvilMiner` flag for the new pubkey. [3](#0-2) 

When `IsOldPubkeyEvil` is true, the new miner is also added to `ReplaceCandidateMap` for special handling during reward release. [4](#0-3) 

Since this method is never called during evil miner replacement, the flag remains unset for actual replacement miners.

**Unfair Reward Penalty:**
During reward distribution in `UpdateBasicMinerRewardWeights`, the presence of the `IsReplacedEvilMiner` flag determines whether a miner receives full shares based on their actual produced blocks or goes through the penalty formula. [5](#0-4) 

With the flag set, miners receive `shares = i.ProducedBlocks` (full shares). Without the flag, they are processed through `CalculateShares()`, which applies penalties for below-average production.

**The Penalty Formula:**
The `CalculateShares()` function penalizes miners with below-average block production: [6](#0-5) 
- Returns 0 shares if blocks < average/2
- Returns blocks²/average if blocks < 4*average/5  
- Returns blocks only if blocks >= 4*average/5

Since replacement miners join mid-term by definition, they have inherently fewer produced blocks and are severely penalized despite not being at fault.

## Impact Explanation

**Direct Financial Harm:**
Replacement miners who step in to replace evil miners receive unfair reward distribution:
- **Zero rewards** if joining late enough that their blocks < average/2
- **Quadratically reduced rewards** if blocks < 4*average/5 (e.g., 400 blocks with 1000 average = 160 shares instead of 400)
- **Example**: Joining halfway through a term means producing ~50% of average blocks, resulting in (0.5×average)²/average = 0.25×average shares, losing 75% of fair rewards

**Affected Parties:**
1. Replacement miners providing critical consensus service
2. Their voters/supporters expecting reasonable returns
3. Protocol security - disincentivizes candidates from serving as replacement miners

**Severity:** Medium - Direct financial impact, automatic trigger, undermines the effectiveness of the evil miner replacement mechanism.

## Likelihood Explanation

**Automatic Trigger:**
This vulnerability triggers automatically whenever the consensus contract detects evil miners during normal operation. Evil miners are identified via the Election contract's `GetMinerReplacementInformation`, which checks the `BannedPubkeyMap`. [7](#0-6) 

**No Attacker Required:**
This is a bug in the legitimate evil miner replacement flow. The issue manifests during:
- Normal consensus operation where miners miss time slots
- Malicious miners being banned via emergency response
- Any scenario triggering `GenerateNextRoundInformation` with banned miners

**Feasibility:**
- Occurs automatically during consensus round generation
- No special permissions or state manipulation needed
- Happens every time an evil miner is replaced mid-term
- Affects ALL replacement miners in such scenarios

## Recommendation

Add a call to `TreasuryContract.RecordMinerReplacement` in the evil miner replacement section of `GenerateNextRoundInformation`:

```csharp
// After line 324 in AEDPoSContract_ViewMethods.cs
Context.Fire(new MinerReplaced
{
    NewMinerPubkey = alternativeCandidatePubkey
});

// Add this:
State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
{
    OldPubkey = evilMinerPubkey,
    NewPubkey = alternativeCandidatePubkey,
    CurrentTermNumber = State.CurrentTermNumber.Value,
    IsOldPubkeyEvil = true
});
```

This ensures the Treasury contract is properly notified and can set the `IsReplacedEvilMiner` flag, preventing unfair penalties.

## Proof of Concept

```csharp
[Fact]
public async Task ReplacementMinerPenalizedDueToMissingFlag()
{
    // Setup: Initialize contracts and elect initial miners
    await InitializeContracts();
    await ElectInitialMiners();
    
    // Get current miner list
    var currentMiners = await ConsensusContract.GetCurrentMinerList.CallAsync(new Empty());
    var evilMinerPubkey = currentMiners.Pubkeys[0].ToHex();
    
    // Mark one miner as evil through emergency response
    await MarkMinerAsEvil(evilMinerPubkey);
    
    // Mine blocks to trigger evil miner replacement in GenerateNextRoundInformation
    await BlockMiningService.MineBlockToNextRoundAsync();
    
    // Verify replacement happened at consensus level
    var newRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.DoesNotContain(evilMinerPubkey, newRound.RealTimeMinersInformation.Keys);
    
    var replacementMinerPubkey = newRound.RealTimeMinersInformation.Keys
        .First(k => !currentMiners.Pubkeys.Select(p => p.ToHex()).Contains(k));
    
    // Check Treasury state - IsReplacedEvilMiner flag should be set but isn't
    var isReplacedEvil = await TreasuryContract.Call<BoolValue>(
        "IsReplacedEvilMiner", 
        new StringValue { Value = replacementMinerPubkey });
    
    // BUG: Flag is false because RecordMinerReplacement was never called
    Assert.False(isReplacedEvil.Value); // This exposes the bug
    
    // Mine through the term
    await BlockMiningService.MineBlockToNextTermAsync();
    
    // Trigger reward distribution
    await ConsensusContract.NextTerm.SendAsync(new Int64Value { Value = 2 });
    
    // Check rewards - replacement miner gets penalized
    var replacementShares = await GetMinerShares(replacementMinerPubkey);
    var expectedFairShares = newRound.RealTimeMinersInformation[replacementMinerPubkey].ProducedBlocks;
    
    // BUG: Replacement miner receives reduced shares due to CalculateShares penalty
    Assert.True(replacementShares < expectedFairShares);
}
```

## Notes

The vulnerability stems from incomplete integration between the Consensus and Treasury contracts. While the voluntary pubkey replacement flow (via `ReplaceCandidatePubkey`) properly notifies the Treasury contract, the automatic evil miner replacement flow (via `GenerateNextRoundInformation`) does not. This architectural gap creates unfair economic consequences for replacement miners who provide a critical consensus service.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-342)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L573-599)
```csharp
    public override Empty RecordMinerReplacement(RecordMinerReplacementInput input)
    {
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only AEDPoS Contract can record miner replacement.");

        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        if (!input.IsOldPubkeyEvil)
        {
            var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
            State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
            State.LatestMinedTerm.Remove(input.OldPubkey);
        }
        else
        {
            var replaceCandidates = State.ReplaceCandidateMap[input.CurrentTermNumber] ?? new StringList();
            replaceCandidates.Value.Add(input.NewPubkey);
            State.ReplaceCandidateMap[input.CurrentTermNumber] = replaceCandidates;
        }

        State.IsReplacedEvilMiner[input.NewPubkey] = true;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L802-812)
```csharp
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-404)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
    }

    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```
