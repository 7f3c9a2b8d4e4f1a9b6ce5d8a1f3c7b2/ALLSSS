# Audit Report

## Title
Unvalidated MinersPreviousInValues Allows Consensus DoS via PreviousInValue Poisoning

## Summary
The AEDPoS consensus contract's secret sharing mechanism unconditionally accepts attacker-supplied `MinersPreviousInValues` without cryptographic or logical validation, allowing malicious miners to poison other miners' `PreviousInValue` fields in on-chain state. This causes victim miners' blocks to fail validation and be rejected, resulting in targeted denial-of-service attacks on consensus participants.

## Finding Description

The vulnerability exists in the interaction between three contract components that creates an exploitable state poisoning attack:

**Root Cause 1: Unconditional Overwrite Without Validation**

The `PerformSecretSharing()` function unconditionally overwrites any miner's `PreviousInValue` with attacker-controlled values from `input.MinersPreviousInValues` without validating correctness. [1](#0-0) 

The function accepts arbitrary hash values for any miner's `PreviousInValue` and directly assigns them to the round state with no verification that these values are correctly reconstructed from secret shares or that they hash to the miners' previous `OutValue`.

**Root Cause 2: Conditional Set Prevents Victim Override**

The `ApplyNormalConsensusData()` function only sets `PreviousInValue` if it is currently empty or null, preventing victims from correcting poisoned values during block generation. [2](#0-1) 

When a victim miner generates their block, they load the poisoned round state from storage. Even though they have the correct `previousInValue` from trigger information [3](#0-2) , this conditional check prevents overwriting the already-set poisoned value.

**Root Cause 3: Validation Only Checks Sender's Own Value**

The `UpdateValueValidationProvider` validates that the sender's own `PreviousInValue` matches their previous `OutValue`, but does not validate the `MinersPreviousInValues` map being submitted for other miners. [4](#0-3) 

The validation logic only checks `validationContext.SenderPubkey` and ignores all other entries in the `MinersPreviousInValues` dictionary, allowing attackers to submit arbitrary values for victim miners without triggering validation failures.

**Attack Execution:**

1. **Poisoning Phase**: Attacker produces an `UpdateValue` block before victim with malicious `MinersPreviousInValues[VictimPubkey] = WrongHash` where `Hash(WrongHash) != Victim's previous OutValue`

2. **State Corruption**: `ProcessUpdateValue()` calls `PerformSecretSharing()` which unconditionally stores the wrong value on-chain [5](#0-4) 

3. **Victim Block Generation Failure**: When victim loads the round state and calls `GetConsensusExtraDataToPublishOutValue()`, the poisoned value is included in the simplified round [6](#0-5)  and the conditional check in `ApplyNormalConsensusData` prevents overriding it [7](#0-6) 

4. **Validation Rejection**: The victim's block undergoes validation where `UpdateValueValidationProvider` is invoked [8](#0-7) 

The validation fails because `Hash(PoisonedValue) != Victim's previous OutValue` [9](#0-8) , causing block rejection.

**Extended Impact - Propagation to Next Round:**

If the victim fails to produce a block in the current round, `SupplyCurrentRoundInformation()` retrieves the poisoned `PreviousInValue` and uses it to calculate the victim's `InValue` and `Signature` for the next round. [10](#0-9) 

This propagates the attack's impact beyond the current round, corrupting the victim's consensus participation in subsequent rounds.

## Impact Explanation

**Severity: HIGH** - This vulnerability enables targeted denial-of-service attacks against consensus participants with direct protocol impact:

**Consensus Disruption:**
- Any active miner can prevent specific miners from producing valid blocks within the current round
- Multiple miners can be targeted simultaneously via a single malicious `UpdateValue` transaction
- If sufficient miners are targeted, the network cannot reach consensus and block production halts

**Direct Harm to Victims:**
- **Revenue Loss**: Targeted miners lose block rewards and transaction fees for missed blocks
- **Reputation Damage**: Missed time slots increment the victim's `MissedTimeSlots` counter, potentially triggering penalties
- **Extended Disruption**: Via `SupplyCurrentRoundInformation()`, the poisoned value propagates to next round calculations, extending the attack's duration

**Network-Wide Impact:**
- **Availability**: Sustained attacks reduce overall network liveness and transaction processing capacity
- **Trust**: Observable consensus manipulation undermines blockchain security guarantees
- **Economics**: Reduced block production affects token emission schedules and network economics

The impact is immediate, deterministic, and affects core consensus integrityâ€”the most critical security property of any blockchain system.

## Likelihood Explanation

**Likelihood: HIGH** - The attack is highly feasible with minimal barriers:

**Attacker Prerequisites:**
- Must be an active miner in the current round (achievable through standard staking/election process)
- Requires no special privileges beyond normal miner status
- Does not require compromising cryptographic keys or consensus contracts

**Attack Complexity:**
- **Simple Execution**: Attacker only needs to modify the `MinersPreviousInValues` field in their `UpdateValue` transaction input
- **No Timing Constraints**: Can be executed during any `UpdateValue` block when attacker's mining slot occurs before victim's
- **Deterministic Success**: No probabilistic factors; if attacker mines first, attack succeeds with 100% certainty

**Economic Feasibility:**
- **Minimal Cost**: Only requires normal transaction fees for `UpdateValue`
- **High Reward**: Can eliminate competition from other miners or extort victims for ransom
- **Low Risk**: Attack is visible on-chain but may not be immediately recognized as malicious

**Detection Difficulty:**
- No built-in monitoring for malicious `MinersPreviousInValues` values
- Requires manual inspection of transaction inputs to detect
- By the time detection occurs, victim blocks are already rejected

The attack requires only standard miner capabilities with no specialized knowledge or resources, making it highly likely to occur in adversarial environments.

## Recommendation

Implement validation of `MinersPreviousInValues` entries before applying them to on-chain state. The fix should verify that each `PreviousInValue` is cryptographically valid:

**Option 1: Cryptographic Verification (Preferred)**
Before accepting `MinersPreviousInValues`, verify that each value was correctly reconstructed from secret shares by checking the decrypted pieces match the provided hash.

**Option 2: Hash Relationship Validation (Minimum)**
In `PerformSecretSharing()`, validate that `Hash(PreviousInValue) == PreviousRound[MinerPubkey].OutValue` before storing:

```csharp
foreach (var previousInValue in input.MinersPreviousInValues)
{
    // Validate the hash relationship before accepting
    if (TryToGetPreviousRoundInformation(out var previousRound) &&
        previousRound.RealTimeMinersInformation.ContainsKey(previousInValue.Key))
    {
        var expectedOutValue = previousRound.RealTimeMinersInformation[previousInValue.Key].OutValue;
        if (HashHelper.ComputeFrom(previousInValue.Value) != expectedOutValue)
        {
            // Skip invalid entries or revert
            continue;
        }
    }
    round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
}
```

**Option 3: Conditional Application**
Apply the same conditional logic used in `ApplyNormalConsensusData` to prevent overwriting already-set values:

```csharp
foreach (var previousInValue in input.MinersPreviousInValues)
{
    if (round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue == Hash.Empty ||
        round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue == null)
    {
        round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MinersPreviousInValuesPoisoning_BlocksVictimMiner()
{
    // Setup: Initialize consensus with two miners - attacker and victim
    var minerKeyPairs = GenerateKeyPairs(2);
    var attackerKeyPair = minerKeyPairs[0];
    var victimKeyPair = minerKeyPairs[1];
    
    await InitializeConsensusAsync(minerKeyPairs);
    await ProduceFirstRoundBlocks(minerKeyPairs);
    
    // Victim produces block in round 1, establishing OutValue
    var victimBlock1 = await ProduceBlockAsync(victimKeyPair);
    var victimOutValue = victimBlock1.Round.RealTimeMinersInformation[victimKeyPair.PublicKey.ToHex()].OutValue;
    
    // Move to round 2
    await MoveToNextRound();
    
    // Attacker's turn comes before victim's in round 2
    var attackerInput = PrepareUpdateValueInput(attackerKeyPair);
    
    // ATTACK: Attacker poisons victim's PreviousInValue with wrong hash
    var wrongHash = HashHelper.ComputeFrom("malicious_value");
    attackerInput.MinersPreviousInValues.Add(victimKeyPair.PublicKey.ToHex(), wrongHash);
    
    // Attacker produces block with poisoned MinersPreviousInValues
    var attackerResult = await ConsensusContractStub.UpdateValue.SendAsync(attackerInput);
    attackerResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify state is poisoned
    var currentRound = await GetCurrentRoundAsync();
    var victimPreviousInValue = currentRound.RealTimeMinersInformation[victimKeyPair.PublicKey.ToHex()].PreviousInValue;
    victimPreviousInValue.ShouldBe(wrongHash); // Poisoned!
    
    // Victim attempts to produce block
    var victimInput = PrepareUpdateValueInput(victimKeyPair);
    
    // EXPLOIT: Victim's block will fail validation
    var victimResult = await ConsensusContractStub.UpdateValue.SendAsync(victimInput);
    
    // Assert: Victim's block is rejected due to validation failure
    victimResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    victimResult.TransactionResult.Error.ShouldContain("Incorrect previous in value");
    
    // Verify the hash relationship check fails
    HashHelper.ComputeFrom(wrongHash).ShouldNotBe(victimOutValue);
}
```

## Notes

This vulnerability represents a critical flaw in the AEDPoS consensus mechanism's secret sharing implementation. The `MinersPreviousInValues` field was intended to facilitate the revelation of previous InValues through the secret sharing mechanism, but the lack of validation allows it to be weaponized for targeted denial-of-service attacks.

The attack is particularly severe because:
1. It requires only standard miner privileges
2. It is deterministic and reproducible
3. It affects core consensus integrity
4. It can target multiple miners simultaneously
5. The poisoned state propagates to subsequent rounds

The recommended fix should implement cryptographic verification to ensure that `PreviousInValue` entries in the `MinersPreviousInValues` dictionary are either correctly reconstructed from secret shares or at minimum satisfy the hash relationship `Hash(PreviousInValue) == PreviousRound[MinerPubkey].OutValue`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L89-89)
```csharp
                    previousInValue = triggerInformation.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L27-27)
```csharp
                    PreviousInValue = minerInRound.PreviousInValue,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L80-80)
```csharp
                validationProviders.Add(new UpdateValueValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L189-214)
```csharp
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }

            // Fill this two fields at last.
            miner.InValue = previousInValue;
            miner.Signature = signature;
```
