# Audit Report

## Title
Silent Failure in Continuous Mining Prevention Due to Unvalidated Order Assignments

## Summary
The `BreakContinuousMining()` function silently returns when no miner has `Order == minersCount`, bypassing the critical check that prevents consecutive block production. Malicious miners can exploit this by providing arbitrary `tune_order_information` values through `UpdateValue` transactions, which are applied without validation, allowing them to produce consecutive blocks and violate consensus fairness guarantees.

## Finding Description

The vulnerability chain consists of multiple validation gaps in the AEDPoS consensus order assignment mechanism:

**1. Silent Return in BreakContinuousMining**

The `BreakContinuousMining()` function returns early without error when it cannot find a miner with `Order == minersCount`, skipping the check that prevents the last miner from being the extra block producer. [1](#0-0) 

**2. Unvalidated TuneOrderInformation in UpdateValue**

The `UpdateValueInput` message includes a `tune_order_information` field that maps miner public keys to order values: [2](#0-1) 

These values are directly applied to `FinalOrderOfNextRound` without any range or uniqueness validation: [3](#0-2) 

The `PreCheck()` function only verifies that the sender is in the miner list, not the validity of the order values: [4](#0-3) 

The `UpdateValueValidationProvider` validates only `OutValue`, `Signature`, and `PreviousInValue`, completely ignoring `tune_order_information`: [5](#0-4) 

**3. Ineffective NextRound Validation**

The `NextRoundMiningOrderValidationProvider` checks `ProvidedRound` (the newly generated next round) where all miners have default `FinalOrderOfNextRound = 0` and `OutValue = null`, making the validation trivially pass with `0 == 0`: [6](#0-5) 

Furthermore, this validator is only applied for NextRound behavior, not for UpdateValue: [7](#0-6) 

**4. Direct Order Propagation**

During next round generation, corrupted `FinalOrderOfNextRound` values are directly assigned as `Order` values: [8](#0-7) 

**Attack Flow:**

1. Malicious miner (e.g., Miner A) calls `UpdateValue` with crafted `UpdateValueInput`
2. Sets `tune_order_information["MinerB"] = 100` (invalid for a 5-miner network)
3. `PreCheck()` passes since Miner A is in the miner list
4. `ProcessUpdateValue` applies the value without validation
5. When next round is generated, Miner B gets `Order = 100`
6. No miner has `Order = 5` (minersCount)
7. `BreakContinuousMining` looks for `Order == 5`, finds nothing, returns early
8. The check preventing the last miner from being extra block producer is skipped (lines 97-107 never execute)
9. A miner can be both the last miner and extra block producer, producing consecutive blocks

## Impact Explanation

**Consensus Integrity Violation**: This vulnerability breaks the fundamental consensus safety invariant that no single miner should produce consecutive blocks (the last regular block and the extra block of the next round).

**Consequences:**

1. **Unfair Block Production**: The exploiting miner can produce two consecutive blocks, gaining double block rewards

2. **Enhanced Attack Surface**: Consecutive block production enables:
   - Selective transaction inclusion/exclusion across two blocks
   - Greater control over transaction ordering
   - Time manipulation within consensus-allowed bounds
   - Increased probability of successful chain reorganization

3. **Consensus Fairness Degradation**: The "last miner â‰  extra block producer" rule exists to fairly distribute block production rights and prevent centralization. Bypassing this fundamentally undermines the decentralization guarantees of the AEDPoS consensus mechanism.

All network participants are affected as consensus fairness is compromised. Honest miners are particularly disadvantaged as they lose potential block production opportunities to the exploiting miner.

## Likelihood Explanation

**Attacker Requirements:**
- Must be part of the active miner list (has mining rights)
- Can call the public `UpdateValue` RPC method [9](#0-8) 

**Attack Complexity**: Low to Medium
- No cryptographic breaking required
- Direct exploitation through public RPC interface
- Only requires crafting `UpdateValueInput` with arbitrary `tune_order_information` values
- No race conditions or timing requirements

**Feasibility**: High
- Any miner in the active list can execute this attack
- The validation gaps are deterministic, not probabilistic
- No detection mechanisms are in place (silent failure leaves no error logs)
- Can be executed repeatedly across multiple rounds

**Detection**: Difficult
- No events or logs are emitted when invalid orders are applied
- Only observable through analyzing block production patterns over time
- Requires correlating which miners produced consecutive blocks

## Recommendation

Implement validation for `tune_order_information` in `ProcessUpdateValue`:

1. **Range Validation**: Ensure all order values are within `[1, minersCount]`
2. **Uniqueness Validation**: Ensure no duplicate order assignments
3. **Authority Validation**: Verify the sender has authority to modify other miners' orders
4. **Add to UpdateValueValidationProvider**: Move validation to the appropriate validation provider

Example fix in `ProcessUpdateValue`:

```csharp
// Validate tune_order_information before applying
var minersCount = currentRound.RealTimeMinersInformation.Count;
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount, 
        $"Invalid order value: {tuneOrder.Value}. Must be between 1 and {minersCount}");
    Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key),
        $"Invalid miner pubkey in tune_order_information");
}

// Check for duplicate orders
var ordersSet = new HashSet<int>(updateValueInput.TuneOrderInformation.Values);
Assert(ordersSet.Count == updateValueInput.TuneOrderInformation.Count,
    "Duplicate order values in tune_order_information");

foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

## Proof of Concept

A PoC test would:
1. Set up a 5-miner consensus network
2. Have Miner A call `UpdateValue` with `tune_order_information["MinerB"] = 100`
3. Verify the value is applied to state without validation failure
4. Call `NextRound` to generate the next round
5. Verify Miner B has `Order = 100` in the next round
6. Verify no miner has `Order = 5`
7. Confirm `BreakContinuousMining` returns early
8. Demonstrate that a miner can be both last regular producer and extra block producer

The test would prove that arbitrary order values bypass all validation and corrupt the consensus schedule, enabling consecutive block production.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L92-95)
```csharp
        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-88)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
