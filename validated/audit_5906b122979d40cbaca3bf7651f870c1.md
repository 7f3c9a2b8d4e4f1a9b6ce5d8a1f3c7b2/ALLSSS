# Audit Report

## Title
Integer Overflow in RoundId Calculation Enables Consensus Denial of Service

## Summary
The `RoundId` property in the AEDPoS consensus contract computes the sum of all miners' `ExpectedMiningTime.Seconds` values without bounds validation. A malicious miner can submit a `NextRound` transaction with `ExpectedMiningTime` values near `long.MaxValue`, causing an `OverflowException` during pre-execution validation, which results in block rejection and consensus disruption.

## Finding Description

The vulnerability exists in the `RoundId` property getter that calculates a sum without validating individual input values: [1](#0-0) 

When a `NextRound` transaction is submitted, the consensus validation framework calls `ValidateConsensusBeforeExecution` as part of the ACS4 interface: [2](#0-1) 

This triggers `ValidateBeforeExecution` which uses multiple validation providers including `TimeSlotValidationProvider`: [3](#0-2) 

The `TimeSlotValidationProvider` accesses the `RoundId` property to determine if a new round is being proposed: [4](#0-3) 

The `CheckRoundTimeSlots()` validation method only verifies that mining intervals between consecutive miners are consistent and positive, but does NOT validate that `ExpectedMiningTime` values themselves are reasonable or bounded: [5](#0-4) 

The AEDPoS contract has overflow checking explicitly enabled in both Debug and Release configurations: [6](#0-5) 

When `CheckForOverflowUnderflow=true`, LINQ's `Sum()` operation throws an `OverflowException` if the result exceeds `long.MaxValue`. With 17 miners each having `ExpectedMiningTime.Seconds = long.MaxValue - 1000`, the sum would be approximately `1.57E20`, which massively exceeds `long.MaxValue` (9.22E18).

The access control check allows any miner in the current or previous round to submit `NextRound` transactions: [7](#0-6) 

## Impact Explanation

**Consensus Denial of Service**: A malicious miner can craft a `NextRoundInput` with `ExpectedMiningTime.Seconds` values set to extremely large numbers (near `long.MaxValue`). When other nodes attempt to validate the block containing this transaction:

1. The pre-execution validation accesses the `RoundId` property
2. The `Sum()` operation attempts to add values exceeding `long.MaxValue`
3. An `OverflowException` is thrown due to enabled overflow checking
4. Block validation fails catastrophically (exception rather than clean rejection)
5. All nodes reject the block

This creates a consensus disruption where the malicious miner can repeatedly produce invalid blocks, blocking round progression until a valid NextRound transaction is accepted. If the attacker is the designated extra block producer or in a critical position for round transition, they can significantly delay or halt consensus progression.

The severity is High because it's a critical consensus layer vulnerability that any miner can trigger with minimal cost (only transaction fees), breaking the availability guarantee of the consensus system.

## Likelihood Explanation

**Attack Feasibility**: HIGH

The attack is highly feasible because:

1. **Reachable Entry Point**: The `NextRound` method is a public consensus method accessible to any miner in the current or previous round

2. **Attacker Capabilities**: Becoming a miner is achievable through the normal election process, and once elected, the attacker can construct arbitrary `NextRoundInput` messages with malicious `ExpectedMiningTime` values

3. **Validation Bypass**: The time slot validation logic only checks relative intervals between miners, not absolute timestamp values, allowing malicious values to pass initial validation until the overflow occurs during `RoundId` calculation

4. **No Input Bounds Checking**: There is no validation that `ExpectedMiningTime.Seconds` values are reasonable, within expected ranges, or based on actual current time

5. **Economic Rationality**: The attack cost is negligible (only transaction fees), while the impact is significant consensus disruption

## Recommendation

Add validation to ensure `ExpectedMiningTime` values are within reasonable bounds before computing `RoundId`. Specifically:

1. **Add bounds checking in `CheckRoundTimeSlots()`**: Validate that each miner's `ExpectedMiningTime` is within a reasonable range relative to the current blockchain time (e.g., not more than a few hours in the future)

2. **Use checked arithmetic with try-catch**: Wrap the `Sum()` operation in a try-catch block to handle potential overflows gracefully and return a validation error instead of throwing an unhandled exception

3. **Validate against current time**: Add a check that `ExpectedMiningTime` values are not absurdly far in the future (e.g., `ExpectedMiningTime.Seconds < currentTime.Seconds + maxReasonableFutureOffset`)

## Proof of Concept

A proof of concept would involve:

1. Setting up an AEDPoS test environment with multiple miners
2. Electing a malicious miner through the normal election process
3. Having the malicious miner create a `NextRoundInput` where all `ExpectedMiningTime.Seconds` values are set to `long.MaxValue - 5000` with consistent 4-second intervals between them
4. Submitting this as a NextRound transaction in a block
5. Observing that when other nodes attempt to validate the block, the `TimeSlotValidationProvider` accesses `ProvidedRound.RoundId`, triggering the overflow
6. Verifying that an `OverflowException` is thrown during validation, causing block rejection

The test would demonstrate that the overflow occurs during the `Sum()` operation in the `RoundId` getter, causing catastrophic validation failure rather than clean rejection.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-75)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElf.Contracts.Consensus.AEDPoS.csproj (L11-17)
```text
    <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>

    <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```
