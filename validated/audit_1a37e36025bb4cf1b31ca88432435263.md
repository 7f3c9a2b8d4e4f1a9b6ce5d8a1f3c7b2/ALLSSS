# Audit Report

## Title
Original SEED Creator Can Sabotage Transferred SEEDs by Setting Expiration to Past

## Summary
The `ExtendSeedExpirationTime()` function uses `tokenInfo.Owner` for authorization, which is never updated when SEED NFTs are transferred. This allows the original creator to set the expiration time to the past even after selling the SEED, permanently destroying its utility and causing direct financial loss to the buyer.

## Finding Description
The vulnerability stems from a critical disconnect between **balance ownership** (who holds the tokens) and **metadata ownership** (the `tokenInfo.Owner` field) in the MultiToken contract's SEED NFT system.

When a SEED NFT is created, the `tokenInfo.Owner` field is set to the creator's address. [1](#0-0) 

When the SEED is transferred via `Transfer()`, only the balance mappings are modified through `DoTransfer()` and `ModifyBalance()`. [2](#0-1) 

The `tokenInfo.Owner` field is **never updated** during transfers - it can only be changed through `ModifyTokenIssuerAndOwner()`, which has strict conditions and is not called during normal transfers. [3](#0-2) 

The `ExtendSeedExpirationTime()` function authorizes callers by checking `tokenInfo.Owner == Context.Sender`, not the current balance holder. [4](#0-3) 

Critically, this function **imposes no validation** that the new expiration time must be in the future - it directly sets whatever timestamp is provided.

When the SEED is later used to create a token, the validation checks if the expiration time has passed. [5](#0-4) 

If the expiration has been set to the past (e.g., timestamp 1), the check at line 130 fails, making the SEED permanently unusable despite the new owner having valid balance.

**Attack Flow:**
1. Alice creates SEED-1 NFT (`tokenInfo.Owner` = Alice, `State.Balances[Alice][SEED-1]` = 1)
2. Alice transfers SEED-1 to Bob (balances update, but `tokenInfo.Owner` still = Alice)
3. Alice calls `ExtendSeedExpirationTime({Symbol: "SEED-1", ExpirationTime: 1})`
4. Authorization passes because Alice == `tokenInfo.Owner`
5. Bob's SEED is now expired and unusable, causing complete financial loss

## Impact Explanation
**Direct Financial Loss:** SEED NFTs are valuable assets that grant exclusive rights to create tokens with specific symbols. They are tradeable on secondary markets. By setting the expiration to the past, the original creator permanently destroys the SEED's utility, making the buyer's purchase worthless.

**Who is Affected:** Any user who purchases or receives a SEED NFT from its original creator through legitimate transfers, marketplace transactions, or OTC trades.

**Severity: HIGH** - This enables theft-equivalent damage where Alice can destroy the value of assets she no longer possesses, with zero cost to execute (single transaction), no technical barriers, and no recovery mechanism. The attack is undetectable until Bob attempts to use the SEED.

## Likelihood Explanation
**Entry Point:** `ExtendSeedExpirationTime()` is a public method directly accessible via transaction submission.

**Attacker Prerequisites:** The attacker must be the original creator (or designated `tokenInfo.Owner`) of a SEED NFT that has been transferred to another party. This is a **common scenario** in NFT marketplaces and secondary sales.

**Attack Complexity:** Trivial - requires only a single transaction with `ExpirationTime = 1` or any past timestamp.

**Economic Rationality:**
- **Griefing attacks:** Malicious sellers sabotage buyers post-sale
- **Market manipulation:** Devalue competitor SEEDs or manipulate prices
- **Front-running:** Seller lists SEED, observes incoming purchase, front-runs with expiration modification
- **Exit scams:** Large-scale SEED creator sells inventory then destroys all sold SEEDs

**Likelihood: HIGH** - The vulnerability is directly reachable, requires only common preconditions (SEED transfer), and has multiple rational attack motivations.

## Recommendation
The authorization logic must verify that the caller is the **current balance holder**, not the metadata owner. Two approaches:

**Option 1 (Recommended):** Check balance instead of tokenInfo.Owner:
```csharp
Assert(State.Balances[Context.Sender][input.Symbol] > 0, 
    "Sender must hold the SEED NFT to extend its expiration time.");
```

**Option 2:** Update `tokenInfo.Owner` during SEED transfers to track the current holder, though this adds complexity and gas costs.

**Additional Fix:** Add validation that the new expiration time must be:
```csharp
Assert(input.ExpirationTime > Context.CurrentBlockTime.Seconds,
    "Expiration time must be in the future.");
Assert(input.ExpirationTime > oldExpireTimeLong,
    "Can only extend expiration time, not reduce it.");
```

## Proof of Concept
```csharp
[Fact]
public async Task SeedExpirationSabotageAttack_Test()
{
    // Step 1: Alice creates a SEED NFT
    var aliceStub = TokenContractStub; // Alice (DefaultAddress)
    var bobStub = TokenContractStubUser; // Bob (User1Address)
    
    var seedInput = new CreateInput
    {
        Symbol = "SEED-1",
        Decimals = 0,
        IsBurnable = true,
        TokenName = "Test SEED",
        TotalSupply = 1,
        Issuer = DefaultAddress,
        Owner = DefaultAddress,
        ExternalInfo = new ExternalInfo()
    };
    seedInput.ExternalInfo.Value["__seed_owned_symbol"] = "NEWTOKEN";
    seedInput.ExternalInfo.Value["__seed_exp_time"] = 
        TimestampHelper.GetUtcNow().AddDays(365).Seconds.ToString();
    
    await aliceStub.Create.SendAsync(seedInput);
    await aliceStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "SEED-1",
        Amount = 1,
        To = DefaultAddress
    });
    
    // Step 2: Alice transfers SEED to Bob
    await aliceStub.Transfer.SendAsync(new TransferInput
    {
        Symbol = "SEED-1",
        Amount = 1,
        To = User1Address,
        Memo = "Sale"
    });
    
    // Verify Bob has the SEED
    var bobBalance = await bobStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = "SEED-1",
        Owner = User1Address
    });
    Assert.Equal(1, bobBalance.Balance);
    
    // Step 3: Alice (original creator) sabotages the SEED by setting expiration to past
    await aliceStub.ExtendSeedExpirationTime.SendAsync(new ExtendSeedExpirationTimeInput
    {
        Symbol = "SEED-1",
        ExpirationTime = 1 // January 1, 1970 - clearly in the past
    });
    
    // Step 4: Bob tries to use the SEED to create a token - should fail
    var createTokenInput = new CreateInput
    {
        Symbol = "NEWTOKEN",
        TokenName = "New Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = User1Address,
        IsBurnable = true
    };
    
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await bobStub.Create.SendAsync(createTokenInput);
    });
    
    // Verify the SEED is now unusable due to expiration
    Assert.Contains("expired", exception.Message.ToLower());
    
    // Bob lost the entire value of the SEED despite holding valid balance
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L118-131)
```csharp
    private void CheckSeedNFT(string symbolSeed, String symbol)
    {
        Assert(!string.IsNullOrEmpty(symbolSeed), "Seed NFT does not exist.");
        var tokenInfo = GetTokenInfo(symbolSeed);
        Assert(tokenInfo != null, "Seed NFT does not exist.");
        Assert(State.Balances[Context.Sender][symbolSeed] > 0, "Seed NFT balance is not enough.");
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L642-659)
```csharp
    public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
    {
        Assert(!State.TokenIssuerAndOwnerModificationDisabled.Value, "Set token issuer and owner disabled.");
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
        Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");

        var tokenInfo = GetTokenInfo(input.Symbol);

        Assert(tokenInfo != null, "Token is not found.");
        Assert(tokenInfo.Issuer == Context.Sender, "Only token issuer can set token issuer and owner.");
        Assert(tokenInfo.Owner == null, "Can only set token which does not have owner.");
        
        tokenInfo.Issuer = input.Issuer;
        tokenInfo.Owner = input.Owner;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L695-722)
```csharp
    public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo == null)
        {
            throw new AssertionException("Seed NFT does not exist.");
        }

        Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
        var oldExpireTimeLong = 0L;
        if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                out var oldExpireTime))
        {
            long.TryParse(oldExpireTime, out oldExpireTimeLong);
        }

        tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
            input.ExpirationTime.ToString();
        State.TokenInfos[input.Symbol] = tokenInfo;
        Context.Fire(new SeedExpirationTimeUpdated
        {
            ChainId = tokenInfo.IssueChainId,
            Symbol = input.Symbol,
            OldExpirationTime = oldExpireTimeLong,
            NewExpirationTime = input.ExpirationTime
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L99-125)
```csharp
    private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
    {
        Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
        Assert(from != to, "Can't do transfer to sender itself.");
        AssertValidMemo(memo);
        ModifyBalance(from, symbol, -amount);
        ModifyBalance(to, symbol, amount);
        Context.Fire(new Transferred
        {
            From = from,
            To = to,
            Symbol = symbol,
            Amount = amount,
            Memo = memo ?? string.Empty
        });
    }

    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```
