# Audit Report

## Title
Missing Dictionary Key Validation in CrossChainCreate Causes KeyNotFoundException and DoS

## Summary
The `CrossChainCreate` function in the NFT contract directly accesses `ExternalInfo.Value` dictionary keys without validation, causing unhandled `KeyNotFoundException` when tokens lack required NFT metadata. This enables permanent DoS of cross-chain NFT protocol creation through pre-creation of malformed tokens.

## Finding Description

The vulnerability exists in the `CrossChainCreate` method where dictionary keys are accessed without checking if they exist: [1](#0-0) 

The method is publicly accessible with no authorization checks: [2](#0-1) 

**Root Cause:**

The legitimate NFT creation flow through `NFTContract.Create()` guarantees these keys are added: [3](#0-2) 

However, the `MultiToken.Create` method accepts arbitrary `ExternalInfo` without validating NFT-specific metadata requirements: [4](#0-3) 

An attacker with seed NFT ownership can create tokens with NFT collection symbol formats (e.g., "ABART-0") determined by: [5](#0-4) 

Where the NFT collection suffix is defined as: [6](#0-5) 

When tokens are synced cross-chain via `CrossChainCreateToken`, the incomplete `ExternalInfo` is preserved: [7](#0-6) 

**Why Existing Protections Fail:**

The `MultiToken` contract uses defensive patterns with `TryGetValue` for dictionary access: [8](#0-7) 

But the NFT contract does not follow this pattern, directly accessing dictionary keys that may not exist.

The required metadata keys are: [9](#0-8) 

## Impact Explanation

**Concrete Harm:**
- **Permanent DoS**: Attackers can irreversibly block legitimate NFT protocols from being created on sidechains by pre-creating tokens with matching symbols but incomplete metadata
- **Cross-Chain Disruption**: All calls to `CrossChainCreate` for affected symbols throw unhandled exceptions, completely breaking cross-chain NFT synchronization
- **No Recovery**: Once a malformed token exists, there is no mechanism to fix or override it - the DoS is permanent
- **Ecosystem Impact**: Affects NFT protocol creators, sidechain users, and the broader AElf cross-chain NFT functionality

**Severity Justification:**
High severity due to permanent, irrecoverable DoS with low attack complexity and broad ecosystem impact.

## Likelihood Explanation

**Attacker Requirements:**
- Seed NFT ownership (obtainable through normal protocol mechanisms) OR whitelist access, as enforced by: [10](#0-9) 

**Attack Complexity:**
Low - requires only:
1. One `TokenContract.Create()` call with NFT collection symbol format and empty/incomplete `ExternalInfo`
2. Automatic cross-chain synchronization propagates the malformed token
3. Any user calling `CrossChainCreate()` triggers the exception

**Probability:**
Medium-High because seed NFTs are obtainable through normal protocol operations, the attack is straightforward with clear griefing motivation, and no technical sophistication is required.

## Recommendation

Add defensive dictionary key validation in `CrossChainCreate`:

```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    MakeSureTokenContractAddressSet();
    InitialNFTTypeNameMap();
    Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
    {
        Symbol = input.Symbol
    });
    if (string.IsNullOrEmpty(tokenInfo.Symbol))
        throw new AssertionException($"Token info {input.Symbol} not exists.");

    // Add defensive validation
    if (!tokenInfo.ExternalInfo.Value.TryGetValue(NftBaseUriMetadataKey, out var baseUri))
        throw new AssertionException($"Required NFT metadata key '{NftBaseUriMetadataKey}' not found.");
    
    if (!tokenInfo.ExternalInfo.Value.TryGetValue(NftTokenIdReuseMetadataKey, out var tokenIdReuseStr) ||
        !bool.TryParse(tokenIdReuseStr, out var isTokenIdReuse))
        throw new AssertionException($"Required NFT metadata key '{NftTokenIdReuseMetadataKey}' not found or invalid.");

    // Continue with rest of method...
}
```

Additionally, consider adding validation in `MultiToken.Create` to enforce NFT metadata requirements for NFT collection symbols.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreate_MissingMetadata_ThrowsKeyNotFoundException()
{
    // Setup: Attacker obtains seed NFT for symbol "ABART"
    var attacker = Accounts[1].Address;
    var seedSymbol = "SEED-1";
    await CreateSeedNFT(seedSymbol, "ABART");
    await TransferSeedToAttacker(seedSymbol, attacker);
    
    // Attack: Create token with NFT collection format but incomplete ExternalInfo
    var maliciousInput = new CreateInput
    {
        Symbol = "ABART-0", // NFT collection format
        TokenName = "Malicious Art Collection",
        TotalSupply = 10000,
        Decimals = 0,
        Issuer = attacker,
        IsBurnable = true,
        IssueChainId = MainChainId,
        ExternalInfo = new ExternalInfo(), // Empty - missing NFT metadata keys!
        Owner = attacker
    };
    
    // This succeeds because MultiToken.Create accepts arbitrary ExternalInfo
    await TokenContractStub.Create.SendAsync(maliciousInput);
    
    // Sync to sidechain via CrossChainCreateToken (preserves incomplete ExternalInfo)
    await SyncTokenToSideChain("ABART-0");
    
    // Victim attempts legitimate CrossChainCreate on sidechain
    var victimInput = new CrossChainCreateInput { Symbol = "ABART-0" };
    
    // This throws KeyNotFoundException due to missing metadata keys
    var exception = await Assert.ThrowsAsync<KeyNotFoundException>(async () =>
    {
        await SideChainNFTContractStub.CrossChainCreate.SendAsync(victimInput);
    });
    
    Assert.Contains("aelf_nft_base_uri", exception.Message);
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-79)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L87-88)
```csharp
        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L196-199)
```csharp
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L124-127)
```csharp
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L492-503)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L19-22)
```csharp
    public const char NFTSymbolSeparator = '-';
    public const int NFTSymbolMaxLength = 30;
    public const string UserContractMethodFeeKey = "UserContractMethodFee";
    public const string CollectionSymbolSuffix = "0";
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L8-9)
```csharp
    private const string NftBaseUriMetadataKey = "aelf_nft_base_uri";
    private const string NftTokenIdReuseMetadataKey = "aelf_nft_token_id_reuse";
```
