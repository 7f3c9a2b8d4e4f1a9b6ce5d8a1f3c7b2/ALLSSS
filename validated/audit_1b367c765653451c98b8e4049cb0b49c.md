# Audit Report

## Title
Time Slot Validation Bypass Through Behavior-RoundId Mismatch in AEDPoS Consensus

## Summary
The `TimeSlotValidationProvider` incorrectly assumes that differing RoundIds between ProvidedRound and BaseRound always indicates a legitimate round transition (NextRound/NextTerm), without validating consistency with the declared Behaviour field. Malicious miners can exploit this by crafting UpdateValue or TinyBlock consensus extra data with arbitrary ExpectedMiningTime values to produce a different RoundId, bypassing the critical `CheckMinerTimeSlot()` validation and enabling block production outside their assigned time slots.

## Finding Description

The vulnerability exists in the time slot validation logic that determines which checks to apply based on RoundId comparison. [1](#0-0) 

When `ProvidedRound.RoundId != BaseRound.RoundId`, the validator assumes this represents a new round and only calls `CheckRoundTimeSlots()` on the ProvidedRound, completely skipping the `CheckMinerTimeSlot()` validation. [2](#0-1) 

The `CheckRoundTimeSlots()` method only validates that ExpectedMiningTime values are set and relatively equal, but does not verify miner legitimacy, timestamp correctness, or behavioral consistency. [3](#0-2) 

The root cause is that RoundId is calculated from the sum of all miners' ExpectedMiningTime.Seconds when they are all set. [4](#0-3) 

For legitimate UpdateValue and TinyBlock behaviors, the consensus extra data generation sets RoundIdForValidation to match the current round's RoundId. [5](#0-4) [6](#0-5) 

However, an attacker can craft a ProvidedRound with all miners having arbitrary ExpectedMiningTime values, causing RoundId to be calculated differently from BaseRound. The validation pipeline applies `RecoverFromUpdateValue` or `RecoverFromTinyBlock` to BaseRound, but these methods don't modify ExpectedMiningTime, so BaseRound.RoundId remains unchanged. [7](#0-6) [8](#0-7) 

The `RoundTerminateValidationProvider` only validates round number increments for NextRound and NextTerm behaviors, allowing UpdateValue and TinyBlock to bypass this check. [9](#0-8) 

During validation, BaseRound is loaded from state with correct ExpectedMiningTime values, and the recovery methods are applied before validation providers run. [10](#0-9) 

## Impact Explanation

**Critical Consensus Integrity Compromise**: This vulnerability fundamentally breaks the AEDPoS consensus scheduling mechanism. The `CheckMinerTimeSlot()` method enforces that miners produce blocks only within their assigned time windows. [11](#0-10)  By bypassing this check, miners can produce blocks outside their designated time slots, completely undermining the deterministic time slot assignment that ensures fair block production and prevents continuous mining by single parties. The ExpectedMiningTime values are calculated during round generation to create a fair schedule. [12](#0-11) 

**Chain Reorganization Risk**: Attackers mining outside their assigned time slots can create competing chain branches with valid-looking blocks, potentially forcing chain reorganizations and undermining finality guarantees. This directly violates the consensus invariant of correct round transitions and time-slot validation.

**Consensus Fairness Violation**: Honest miners following their assigned time slots are disadvantaged as malicious miners can opportunistically produce blocks whenever advantageous, capturing more block rewards and transaction fees than their fair share.

**Network-Wide Impact**: All network participants are affected - honest validators lose block production opportunities, and users may experience transaction reversals during reorganizations. The consensus mechanism's ability to maintain a single canonical chain is compromised.

## Likelihood Explanation

**High Likelihood - Any Elected Miner Can Execute**:

**Attacker Capabilities**: The attacker only needs to be a legitimate miner in the current round's miner list, which is a standard precondition in any proof-of-stake consensus system. No special privileges beyond being an elected validator are required.

**Low Attack Complexity**: The attacker simply crafts consensus extra data with:
1. UpdateValue or TinyBlock behavior declared
2. ProvidedRound containing all miners with arbitrary ExpectedMiningTime values (e.g., all set to 1000 seconds)
3. ExpectedMiningTime values spaced relatively equally to pass `CheckRoundTimeSlots()`
4. Attacker's OutValue, Signature, and ActualMiningTime properly filled

**All Validation Checks Pass**:
- `MiningPermissionValidationProvider` checks BaseRound miner list membership - attacker passes as legitimate miner [13](#0-12) 
- `UpdateValueValidationProvider` only validates OutValue and Signature are filled - attacker can satisfy [14](#0-13) 
- `ContinuousBlocksValidationProvider` checks continuous block count limits - attacker can avoid exceeding [15](#0-14) 
- The ProvidedRound comes from attacker-controlled consensus extra data [16](#0-15) 

**Difficult Detection**: The malicious block appears valid during all validation phases and is accepted by the network. Detection requires off-chain monitoring comparing actual mining times against scheduled time slots.

**Minimal Cost**: No economic cost beyond normal block production. Attack can be executed repeatedly at any time by any elected miner.

## Recommendation

Add validation to ensure that for UpdateValue and TinyBlock behaviors, the ProvidedRound's RoundId must match the BaseRound's RoundId. Specifically, in `TimeSlotValidationProvider.ValidateHeaderInformation()`, add a check:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    // For UpdateValue and TinyBlock, RoundId must match BaseRound
    if ((validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.UpdateValue ||
         validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.TinyBlock) &&
        validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
    {
        validationResult.Message = "UpdateValue/TinyBlock must have matching RoundId with current round.";
        return validationResult;
    }
    
    // If provided round is a new round (NextRound/NextTerm)
    if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
    {
        // Is new round information fits time slot rule?
        validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
        if (!validationResult.Success) return validationResult;
    }
    else
    {
        // Is sender respect his time slot?
        if (!CheckMinerTimeSlot(validationContext))
        {
            validationResult.Message =
                $"Time slot already passed before execution.{validationContext.SenderPubkey}";
            validationResult.IsReTrigger = true;
            return validationResult;
        }
    }

    validationResult.Success = true;
    return validationResult;
}
```

Alternatively, validate that ProvidedRound's ExpectedMiningTime values match BaseRound's for the same miners when the behavior is UpdateValue or TinyBlock.

## Proof of Concept

A proof of concept would involve:

1. Setting up a test environment with multiple miners in a round with properly assigned ExpectedMiningTime values
2. Crafting a malicious UpdateValue consensus extra data where:
   - All miners have ExpectedMiningTime set to arbitrary values (e.g., all = Timestamp(1000))
   - Values are evenly spaced to pass CheckRoundTimeSlots()
   - OutValue and Signature are properly filled
   - ActualMiningTime is set to a time outside the miner's legitimate time slot
3. Submitting this consensus extra data for block validation
4. Observing that validation passes even though the miner is producing a block outside their assigned time slot
5. Verifying that CheckMinerTimeSlot() was not called due to the RoundId mismatch

The test would demonstrate that the TimeSlotValidationProvider incorrectly branches to CheckRoundTimeSlots() instead of CheckMinerTimeSlot() when ProvidedRound contains manipulated ExpectedMiningTime values, allowing the time slot constraint bypass.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-17)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L58-64)
```csharp
    public Round GetTinyBlockRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-60)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L8-28)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```
