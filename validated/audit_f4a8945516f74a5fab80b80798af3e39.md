# Audit Report

## Title
Zero Deposit Allows Connector Enablement Without Base Token Reserves, Causing Permanent DoS of Both Buy and Sell Operations

## Summary
The `GetNeededDeposit()` function returns `needDeposit = 0` when `AmountToTokenConvert` equals all circulating tokens. [1](#0-0)  This allows `EnableConnector()` to activate a connector with zero base token reserves, [2](#0-1)  permanently breaking both `Buy` and `Sell` operations since `BancorHelper` requires positive connector balances. [3](#0-2) [4](#0-3) 

## Finding Description

The vulnerability occurs through the following execution path:

**1. Zero Deposit Calculation**

In `GetNeededDeposit()`, the calculation `amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert` becomes 0 when the caller transfers all circulating tokens. [5](#0-4)  Since the deposit calculation only proceeds when `amountOutOfTokenConvert > 0`, the function returns `needDeposit = 0`. [6](#0-5) 

**2. Connector Enabled with Zero Reserves**

The `EnableConnector()` function (which has NO access control) uses this zero deposit to set the base token reserve: `State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount`. [7](#0-6)  Once enabled, `IsPurchaseEnabled` is set to true and cannot be reverted, as `UpdateConnector()` explicitly prevents updates to activated connectors. [8](#0-7) 

**3. Buy Operation Fails**

When users attempt to `Buy()`, the function calls `BancorHelper.GetAmountToPayFromReturn()` with `GetSelfBalance(fromConnector)`. [9](#0-8)  For deposit account connectors, `GetSelfBalance()` returns `State.DepositBalance[connector.Symbol]` which is 0. [10](#0-9)  `BancorHelper` enforces that connector balances must be positive, throwing `InvalidValueException`. [4](#0-3) 

**4. Sell Operation Also Fails**

Similarly, `Sell()` calls `BancorHelper.GetReturnFromPaid()` which retrieves the deposit balance (0) and throws the same exception. [11](#0-10) [3](#0-2)  Additionally, even if the Bancor calculation somehow succeeded, the contract would lack base tokens to transfer to sellers, and the checked subtraction `State.DepositBalance[toConnector.Symbol].Sub(amountToReceive)` would throw an overflow exception. [12](#0-11) [13](#0-12) 

This breaks the fundamental Bancor invariant that connectors maintain positive reserves to provide continuous bidirectional liquidity.

## Impact Explanation

**Severity: HIGH** (not Medium as initially assessed)

**Complete Market Failure:**
- **BOTH Buy and Sell operations are permanently broken**, not just Sell as initially claimed
- The connector becomes completely non-functional for all trading operations
- Token holders experience permanent liquidity lock - they cannot exit positions
- New buyers cannot enter positions either

**Permanent and Irreversible:**
- Once `IsPurchaseEnabled = true`, the connector cannot be disabled or reconfigured
- No recovery mechanism exists in the contract
- The only remediation would be deploying a new connector contract

**Protocol Integrity Violation:**
- Violates Bancor's core promise of continuous liquidity
- Breaks the "Pricing & Reserves" critical invariant requiring reserve depletion protection
- Damages protocol reputation and user trust

**Economic Impact:**
- Existing token holders lose all liquidity
- The token becomes worthless due to inability to trade
- Affects all users who acquired tokens expecting bidirectional convertibility

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**No Access Control:**
The `EnableConnector()` function lacks any authorization check (no `AssertPerformedByConnectorController()` call), making it callable by any address. [14](#0-13)  While other administrative functions like `UpdateConnector()` and `AddPairConnector()` require controller privileges, [15](#0-14)  `EnableConnector()` does not.

**Realistic Trigger Scenarios:**

1. **Legitimate Misconfiguration**: A token issuer might genuinely believe that transferring all tokens to the converter provides "maximum liquidity" or is required for activation, not understanding the economic implications.

2. **Front-Running Attack**: A malicious actor could monitor the mempool for a legitimate `EnableConnector()` transaction and front-run it with `AmountToTokenConvert = totalSupply`, permanently breaking the market before the legitimate activation occurs.

3. **Testing Gap**: The existing test suite uses 99.9999% of supply, [16](#0-15)  which wouldn't catch the edge case of exactly 100%.

**No Validation:**
- No check prevents `AmountToTokenConvert >= (totalSupply - balance)`
- No minimum deposit requirement enforced
- No warning or error when `needDeposit = 0`

## Recommendation

**1. Add Minimum Deposit Validation**
```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
    
    var needDeposit = GetNeededDeposit(input);
    
    // NEW: Require minimum deposit
    Assert(needDeposit.NeedAmount > 0, 
        "Insufficient base token deposit. Cannot enable connector with zero reserves.");
    
    // ... rest of function
}
```

**2. Add Access Control**
Consider adding `AssertPerformedByConnectorController()` to `EnableConnector()` to prevent unauthorized activation.

**3. Add Maximum Token Conversion Limit**
In `GetNeededDeposit()`, validate that `AmountToTokenConvert` leaves sufficient tokens in circulation:
```csharp
var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
Assert(amountOutOfTokenConvert > 0, 
    "Must leave some tokens in circulation outside the converter.");
```

## Proof of Concept

```csharp
[Fact]
public async Task EnableConnector_ZeroDeposit_BreaksMarket()
{
    // Setup: Create token with 1,000,000 total supply
    const string tokenSymbol = "VULN";
    const long totalSupply = 1_000_000;
    
    await DefaultStub.Initialize.SendAsync(new InitializeInput { FeeRate = "0.005" });
    await CreateTokenAsync(tokenSymbol);
    await AddPairConnectorAsync(tokenSymbol);
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = totalSupply,
        To = DefaultSender,
        Symbol = tokenSymbol
    });
    
    // Exploit: Transfer ALL tokens when enabling (balance = 0, so AmountToTokenConvert = totalSupply)
    var toBeBuildConnectorInfo = new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = totalSupply // All tokens!
    };
    
    // Verify needDeposit is 0
    var deposit = await DefaultStub.GetNeededDeposit.CallAsync(toBeBuildConnectorInfo);
    deposit.NeedAmount.ShouldBe(0); // VULNERABILITY: Zero deposit required!
    
    // Enable connector with zero base token reserves
    await DefaultStub.EnableConnector.SendAsync(toBeBuildConnectorInfo);
    
    // Verify connector is enabled
    var connector = (await DefaultStub.GetPairConnector.CallAsync(
        new TokenSymbol { Symbol = tokenSymbol })).ResourceConnector;
    connector.IsPurchaseEnabled.ShouldBe(true);
    
    // IMPACT: Both Buy and Sell operations now fail permanently
    
    // Try to Buy - should fail with "Connector balance needs to be a positive number"
    var buyResult = await DefaultStub.Buy.SendWithExceptionAsync(new BuyInput
    {
        Symbol = tokenSymbol,
        Amount = 100,
        PayLimit = 1000
    });
    buyResult.TransactionResult.Error.ShouldContain("Connector balance needs to be a positive number");
    
    // Try to Sell - should also fail
    var sellResult = await DefaultStub.Sell.SendWithExceptionAsync(new SellInput
    {
        Symbol = tokenSymbol,
        Amount = 100,
        ReceiveLimit = 0
    });
    sellResult.TransactionResult.Error.ShouldContain("Connector balance needs to be a positive number");
    
    // Market is permanently broken - no way to recover
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-84)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L60-81)
```csharp
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }


    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L377-378)
```csharp
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L37-38)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L70-71)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-97)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L388-395)
```csharp
            Amount = 99_9999_0000,
            To = DefaultSender,
            Symbol = tokenSymbol
        });
        var toBeBuildConnectorInfo = new ToBeConnectedTokenInfo
        {
            TokenSymbol = tokenSymbol,
            AmountToTokenConvert = 99_9999_0000
```
