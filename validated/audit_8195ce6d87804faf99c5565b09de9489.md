# Audit Report

## Title
Negative DepositBalance Due to Missing Validation in Sell Operation Allows Cross-Connector Balance Contamination

## Summary
The `Sell` function in TokenConverterContract calculates the amount of base tokens to return using the Bancor formula with the sum of `VirtualBalance` and `DepositBalance`, but only decrements `DepositBalance` without validating that the amount to receive does not exceed the actual deposit balance. Since multiple connector pairs share the same base token pool in the contract, this allows sell operations to succeed by draining tokens allocated to other connectors, causing the affected connector's `DepositBalance` to become negative and breaking accounting integrity.

## Finding Description

The vulnerability exists in the `Sell` function where Bancor pricing calculation and balance accounting are misaligned. [1](#0-0) 

The `GetSelfBalance` helper function returns the sum of virtual and actual balances for deposit account connectors when virtual balance is enabled. [2](#0-1) 

After calculating `amountToReceive` using the Bancor formula with this combined balance, the contract transfers base tokens and then decrements only `DepositBalance` without validation. [3](#0-2) 

**Root Cause**: There is no validation ensuring `amountToReceive <= State.DepositBalance[toConnector.Symbol]` before the subtraction. The SafeMath `Sub()` operation uses checked arithmetic but only prevents overflow/underflow at type boundaries (below `long.MinValue`), not negative values within valid range. [4](#0-3) 

**Why Existing Protections Fail**: The base token transfer checks the contract's **total** base token balance across all connectors, not the per-connector `DepositBalance`. The system initializes multiple connector pairs that share the same base token through the `InitializeTokenConverterContract` method. [5](#0-4) 

A sell operation on one connector can succeed by using tokens allocated to another connector's `DepositBalance`, leaving the first connector with a negative `DepositBalance`. The `DepositBalance` state variable is defined as a simple mapped long value with no inherent non-negativity constraint. [6](#0-5) 

## Impact Explanation

**Direct Fund Impact**:
- `DepositBalance` can become negative, violating the critical invariant that deposit balances must be non-negative
- Users can extract more base tokens from a specific connector than actually allocated to it
- Cross-connector contamination allows draining one connector's reserves through sells on another connector

**Accounting Integrity Broken**:
- The `GetDepositConnectorBalance` view function returns incorrect values when `DepositBalance` is negative. [7](#0-6) 
- When `State.DepositBalance[ntSymbol]` is negative, the returned total balance appears lower than `VirtualBalance` alone
- All subsequent Bancor calculations for affected connectors use corrupted balance data, leading to incorrect pricing

**Affected Parties**:
- Users trading on connectors with negative `DepositBalance` receive incorrect prices
- Connectors whose reserves are drained become insolvent while showing positive virtual balances
- System-wide accounting diverges from actual token holdings over time

The severity is **Medium** due to broken accounting and fund misallocation, though exploitation requires accumulating significant resource tokens and depends on the relative sizes of virtual vs. deposit balances across connector pairs.

## Likelihood Explanation

**Reachable Entry Point**: The `Sell` function is a public method callable by any user with no special authorization requirements.

**Attacker Capabilities**:
1. Attacker must first acquire resource tokens (e.g., READ, WRITE) by buying them or receiving transfers
2. Attacker needs sufficient capital to buy enough tokens to trigger large sell returns
3. No privileged access required

**Feasible Preconditions**:
- Multiple connector pairs exist in production (verified in economic initialization with constants defining initial balances) [8](#0-7) 
- At least one connector has large `VirtualBalance` (10,000,000 tokens) but potentially small `DepositBalance`
- Other connectors have sufficient `DepositBalance` to cover the total contract transfer
- The Bancor formula calculates returns based on virtual+deposit but only deposit gets decremented

**Execution Practicality**: The attack is realistic because resource tokens can be purchased at market rates, and the system intentionally uses large virtual balances with potentially smaller deposit balances during initialization.

## Recommendation

Add validation before decrementing `DepositBalance` to ensure the amount to receive does not exceed the actual deposit balance:

```csharp
// In the Sell function, before line 193-194:
Assert(amountToReceive <= State.DepositBalance[toConnector.Symbol], 
    "Insufficient deposit balance for this connector.");
State.DepositBalance[toConnector.Symbol] = 
    State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

This ensures that each connector's deposit balance cannot be driven negative and prevents cross-connector balance contamination.

## Proof of Concept

```csharp
[Fact]
public async Task Sell_Should_Fail_When_AmountToReceive_Exceeds_DepositBalance()
{
    // Setup: Initialize token converter with connector having large virtual balance
    // but small deposit balance
    var initializeInput = new InitializeInput
    {
        BaseTokenSymbol = "ELF",
        FeeRate = "0.005",
        Connectors = 
        {
            new Connector
            {
                Symbol = "READ",
                Weight = "0.005",
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                VirtualBalance = 10_000_000_00000000, // 100 million ELF
                RelatedSymbol = "(NT)READ"
            },
            new Connector
            {
                Symbol = "(NT)READ",
                Weight = "0.005",
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                VirtualBalance = 10_000_000_00000000, // 100 million ELF
                IsDepositAccount = true,
                RelatedSymbol = "READ"
            }
        }
    };
    
    await TokenConverterContractStub.Initialize.SendAsync(initializeInput);
    
    // Setup small deposit balance for (NT)READ connector
    // (via EnableConnector with minimal deposit)
    await TokenConverterContractStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = "READ",
        AmountToTokenConvert = 0
    });
    
    // Attacker acquires READ tokens and attempts to sell
    // The Bancor formula will calculate return based on virtual+deposit balance
    // but actual deposit balance is much smaller
    var sellInput = new SellInput
    {
        Symbol = "READ",
        Amount = 1_000_00000000, // 10 READ tokens
        ReceiveLimit = 0
    };
    
    // This should fail with assertion but currently allows negative DepositBalance
    var result = await TokenConverterContractStub.Sell.SendAsync(sellInput);
    
    // Verify: DepositBalance[(NT)READ] should not be negative
    var balance = await TokenConverterContractStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = "READ" });
    
    // VULNERABILITY: This assertion would fail if deposit balance went negative
    Assert.True(balance.Value >= 0, "DepositBalance should never be negative");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-212)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
        // Transfer sold token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
        Context.Fire(new TokenSold
        {
            Symbol = input.Symbol,
            SoldAmount = input.Amount,
            BaseAmount = amountToReceive,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L211-260)
```csharp
    private void InitializeTokenConverterContract()
    {
        State.TokenConverterContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);
        var connectors = new List<Connector>
        {
            new()
            {
                Symbol = Context.Variables.NativeSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.5",
                VirtualBalance = EconomicContractConstants.NativeTokenConnectorInitialVirtualBalance
            }
        };
        foreach (var resourceTokenSymbol in Context.Variables
                     .GetStringArray(EconomicContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(EconomicContractConstants.PayRentalSymbolListName)))
        {
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.ResourceTokenInitialVirtualBalance,
                RelatedSymbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsDepositAccount = false
            };
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
            connectors.Add(resourceTokenConnector);
            connectors.Add(nativeTokenConnector);
        }

        State.TokenConverterContract.Initialize.Send(new InitializeInput
        {
            FeeRate = EconomicContractConstants.TokenConverterFeeRate,
            Connectors = { connectors },
            BaseTokenSymbol = Context.Variables.NativeSymbol
        });
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs (L19-19)
```csharp
    public MappedState<string, long> DepositBalance { get; set; }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L93-102)
```csharp
    public override Int64Value GetDepositConnectorBalance(StringValue symbolInput)
    {
        var connector = State.Connectors[symbolInput.Value];
        Assert(connector != null && !connector.IsDepositAccount, "token symbol is invalid");
        var ntSymbol = connector.RelatedSymbol;
        return new Int64Value
        {
            Value = State.Connectors[ntSymbol].VirtualBalance + State.DepositBalance[ntSymbol]
        };
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L20-20)
```csharp
    public const long NativeTokenToResourceBalance = 10_000_000_00000000;
```
