# Audit Report

## Title
Division by Zero Vulnerability in SetMinerIncreaseInterval Causes Permanent Consensus DoS

## Summary
The `SetMinerIncreaseInterval()` function in the AEDPoS consensus contract lacks validation to prevent setting the miner increase interval to zero. This allows governance to inadvertently or maliciously set the value to zero, causing `DivideByZeroException` in critical consensus operations. Once set to zero, the value cannot be increased due to the assertion logic, resulting in permanent blockchain halt during term transitions.

## Finding Description

The vulnerability exists in the validation logic of `SetMinerIncreaseInterval()`. [1](#0-0) 

The function only validates that the new value must be less than or equal to the current value, but fails to enforce a lower bound check. When the current value is the default 31,536,000 seconds, [2](#0-1)  zero passes the validation check.

This zero value causes division by zero in two critical locations:

1. In `GetAutoIncreasedMinersCount()`, which performs division to calculate auto-increased miner counts. [3](#0-2) 

2. In `GetMinersCount()`, which uses the same division operation. [4](#0-3) 

The `SafeMath.Div()` extension method performs simple division without exception handling, which will throw `DivideByZeroException` when the divisor is zero. [5](#0-4) 

The `GetMinersCount()` function is called during critical consensus operations including term transitions via `UpdateMinersCountToElectionContract()`. [6](#0-5) 

It is also called during initial term setup in consensus information processing. [7](#0-6) 

## Impact Explanation

**Critical Consensus Availability Breach:**
Once `MinerIncreaseInterval` is set to zero, any subsequent call to `GetMinersCount()` or `GetMaximumMinersCount()` during consensus operations will throw `DivideByZeroException`, causing transaction reversion. This prevents the blockchain from transitioning to new consensus terms, effectively halting block production.

**Irreversible State:**
The assertion logic only permits non-increasing values. Once set to zero, there is no mechanism through the same function to restore it to a positive value, making this a permanent denial of service with no built-in recovery path.

**Affected Critical Operations:**
- Public view method `GetMaximumMinersCount()` becomes unusable
- Consensus term transitions via `ProcessNextTerm()` fail completely  
- Miner count synchronization to the Election contract breaks
- All consensus miners lose the ability to produce blocks once the current term completes

This represents a complete breakdown of the consensus availability guarantee.

## Likelihood Explanation

**Permission Requirements:**
Execution requires the `MaximumMinersCountController` (defaulting to the Parliament contract's default organization) to approve and execute the call. [1](#0-0) 

**Attack Feasibility:**
- **Low Complexity:** Requires only a single governance proposal and approval through Parliament
- **Accidental Trigger:** Could occur through configuration errors or parameter mistakes during legitimate governance operations
- **Malicious Trigger:** Could be exploited by compromised governance or a malicious majority coalition
- **No Economic Barrier:** Only requires standard governance proposal fees

**Test Evidence:**
The existing test suite demonstrates that the function accepts decreasing values without any lower bound validation, confirming the vulnerability is exploitable. [8](#0-7) 

The vulnerability is fully executable under normal AElf contract semantics without requiring any extraordinary conditions.

## Recommendation

Add a lower bound validation to prevent setting the interval to zero:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

Alternatively, consider allowing both increases and decreases with appropriate bounds:

```csharp
Assert(input.Value > 0, "Miner increase interval must be positive.");
Assert(input.Value <= MaxAllowedInterval, "Interval exceeds maximum allowed value.");
```

## Proof of Concept

```csharp
[Fact]
public async Task DivisionByZero_ConsensusDoS_Test()
{
    // Setup: Initialize consensus and parliament
    InitialContracts();
    await BlockMiningService.MineBlockToNextTermAsync();
    InitialAcs3Stubs();
    await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput());
    
    var defaultOrganizationAddress = 
        await ParliamentStubs.First().GetDefaultOrganizationAddress.CallAsync(new Empty());
    
    // Exploit: Set MinerIncreaseInterval to zero through Parliament
    await ParliamentReachAnAgreementAsync(new CreateProposalInput
    {
        ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
        Params = new Int64Value { Value = 0 }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        OrganizationAddress = defaultOrganizationAddress
    });
    
    // Verify: Interval is now zero
    var interval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
    interval.Value.ShouldBe(0);
    
    // Impact: Any call to GetMaximumMinersCount now throws DivideByZeroException
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await ConsensusStub.GetMaximumMinersCount.CallAsync(new Empty());
    });
    
    // Verify exception is division by zero
    exception.Message.ShouldContain("Attempted to divide by zero");
    
    // Demonstrate consensus operations fail during term transition
    var termException = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await BlockMiningService.MineBlockToNextTermAsync();
    });
    
    termException.Message.ShouldContain("divide by zero");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/ConsensusOptions.cs (L13-13)
```csharp
    public long MinerIncreaseInterval { get; set; } = 31536000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L125-135)
```csharp
            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L133-146)
```csharp
        var newMinerIncreaseInterval = minerIncreaseInterval.Value - 1;
        await ParliamentReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = newMinerIncreaseInterval
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        minerIncreaseInterval.Value.ShouldBe(newMinerIncreaseInterval);
```
