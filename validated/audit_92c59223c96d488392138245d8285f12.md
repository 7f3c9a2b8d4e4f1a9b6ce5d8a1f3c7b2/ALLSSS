# Audit Report

## Title
Zero Threshold Values Enable Permanent Governance Deadlock in Referendum Contract

## Summary
The Referendum contract's validation logic permits `MaximalAbstentionThreshold` and `MaximalRejectionThreshold` to be set to 0, creating an unrecoverable governance state. When these thresholds are zero, any single rejection or abstention vote permanently blocks all proposals, including proposals to modify the thresholds themselves, resulting in irreversible governance deadlock.

## Finding Description

The vulnerability exists in the threshold validation logic which explicitly allows zero values for maximal thresholds: [1](#0-0) 

However, the proposal release logic uses strict greater-than comparison to determine if a proposal is blocked: [2](#0-1) 

When `MaximalRejectionThreshold = 0`, the condition `proposal.RejectionCount > 0` evaluates to true for any rejection, blocking the proposal. Similarly, when `MaximalAbstentionThreshold = 0`, any abstention blocks the proposal. This creates a unanimous approval requirement where a single dissenting vote vetoes any proposal.

The critical issue is that threshold modifications can only be executed by the organization itself through a released proposal: [3](#0-2) 

The method verifies `State.Organizations[Context.Sender]`, meaning only the organization address (acting as the transaction sender via a released proposal) can modify its thresholds. If thresholds are already zero, any proposal to change them requires unanimous approval, creating a permanent deadlock if any voter dissents, is malicious, or is offline.

Organizations are created via public method with no warnings about zero thresholds: [4](#0-3) 

## Impact Explanation

**Permanent Governance DoS:**
- Organizations with zero maximal thresholds become permanently dysfunctional
- All proposals require 100% approval with zero abstentions or rejections  
- A single uncooperative, malicious, or offline voter blocks all governance actions
- No admin override, emergency recovery, or alternative mechanism exists to restore functionality

**Attack Scenarios:**
1. **User Error**: Organization creator accidentally sets zero thresholds during creation
2. **Social Engineering**: Malicious proposer frames threshold change as "requiring maximum consensus for security" and convinces voters to approve, permanently locking the organization

**Protocol Impact:**
- Governance operations become unavailable permanently
- Token holders lose ability to execute critical configuration changes
- Protocols depending on these organizations for parameter updates are impacted

The severity is High because the impact is severe (permanent governance loss), irreversible (no recovery path), and affects protocol integrity.

## Likelihood Explanation

**Entry Points:**
- `CreateOrganization`: Any user can create organization with zero thresholds
- `ChangeOrganizationThreshold`: Proposers in whitelist can propose threshold changes to zero

**Attack Complexity:**
For active attack:
1. Attacker gains proposer whitelist membership
2. Creates proposal to change thresholds to zero  
3. Socially engineers voters to approve (framing as "enhanced security")
4. Once released, organization is permanently locked

**Likelihood Factors:**
- No validation warnings exist - zero is explicitly allowed
- Users may misunderstand threshold semantics (viewing unanimous consent as secure)
- The permanent nature makes even low-probability events catastrophic
- No safeguards prevent this configuration

**Practical Considerations:**
Existing tests confirm zero is the minimum allowed value (negative values are rejected), demonstrating this is a reachable state: [5](#0-4) 

## Recommendation

Implement minimum threshold values greater than zero to prevent unanimous-only voting requirements. Add validation to enforce this:

```csharp
private bool Validate(Organization organization)
{
    // ... existing validation ...
    
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold > 0 && // Changed from >= 0
           proposalReleaseThreshold.MaximalRejectionThreshold > 0;    // Changed from >= 0
}
```

Alternatively, if zero thresholds are intentional for specific use cases, add:
1. Explicit confirmation requirement during organization creation
2. Emergency recovery mechanism allowing organization creator to reset thresholds
3. Documentation warnings about the irreversible nature of zero thresholds

## Proof of Concept

```csharp
[Fact]
public async Task Zero_Threshold_Creates_Permanent_Deadlock_Test()
{
    // Step 1: Create organization with zero maximal thresholds
    var organizationAddress = await CreateOrganizationAsync(
        minimalApproveThreshold: 5000,
        minimalVoteThreshold: 5000, 
        maximalAbstentionThreshold: 0,  // Zero threshold
        maximalRejectionThreshold: 0,   // Zero threshold
        new[] { DefaultSender });

    // Step 2: Create a proposal to change thresholds back to normal
    var newThresholds = new ProposalReleaseThreshold
    {
        MinimalApprovalThreshold = 5000,
        MinimalVoteThreshold = 5000,
        MaximalAbstentionThreshold = 1000,  // Try to set to normal value
        MaximalRejectionThreshold = 1000
    };
    
    var changeProposalId = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair,
        newThresholds,
        nameof(ReferendumContractStub.ChangeOrganizationThreshold),
        organizationAddress,
        ReferendumContractAddress);

    // Step 3: Approve with sufficient votes
    var keyPair1 = Accounts[1].KeyPair;
    await ApproveAllowanceAsync(keyPair1, 5000, changeProposalId);
    await ApproveAsync(keyPair1, changeProposalId);
    
    // Step 4: Single abstention or rejection blocks the change
    var keyPair2 = Accounts[2].KeyPair;
    await ApproveAllowanceAsync(keyPair2, 1, changeProposalId);
    await AbstainAsync(keyPair2, changeProposalId);  // Just one abstention
    
    // Verify: Proposal cannot be released due to abstention count > 0
    var proposal = await ReferendumContractStub.GetProposal.CallAsync(changeProposalId);
    proposal.ToBeReleased.ShouldBeFalse();  // Deadlock confirmed
    
    // Verify: Cannot release the threshold change
    var releaseResult = await ReferendumContractStub.Release.SendWithExceptionAsync(changeProposalId);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // Organization is now permanently locked with zero thresholds
}
```

## Notes

This vulnerability also affects the Association contract which uses identical validation and release logic patterns: [6](#0-5) [7](#0-6) [8](#0-7) 

The Parliament contract uses different default values but has similar validation patterns. All three governance contracts should be reviewed for this issue.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L20-26)
```csharp
        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L100-101)
```csharp
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-28)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-130)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
```

**File:** test/AElf.Contracts.Referendum.Tests/ReferendumContractTest.cs (L1170-1176)
```csharp
        //MaximalRejectionThreshold < 0
        {
            var validInput = GetValidCreateOrganizationInput();
            validInput.ProposalReleaseThreshold.MaximalRejectionThreshold = -1;
            var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
            ret.TransactionResult.Error.ShouldContain("Invalid organization data");
        }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L38-44)
```csharp
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L75-76)
```csharp
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-209)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
```
