# Audit Report

## Title
Unauthorized Round Termination by Non-Designated Miners Bypassing Extra Block Producer Designation

## Summary
The AEDPoS consensus contract allows any miner who has missed their time slot to terminate a round without verifying they are the designated extra block producer. This violates the deterministic extra block producer mechanism, enabling miners to manipulate round termination for economic gain.

## Finding Description

The AEDPoS consensus system deterministically calculates which miner should produce the extra block and terminate each round. However, the implementation fails to enforce this designation, allowing any miner who has missed their time slot to terminate rounds.

**Root Cause**: The `SideChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` method unconditionally returns `NextRound` behavior without validating whether the calling miner is the designated extra block producer. [1](#0-0) 

**Attack Execution Path**:

1. A miner calls the public `GetConsensusCommand()` method [2](#0-1) 

2. For side chains, the system instantiates `SideChainConsensusBehaviourProvider` and calls `GetConsensusBehaviour()` [3](#0-2) 

3. If the miner hasn't produced a block (`OutValue == null`), the code calls `HandleMinerInNewRound()` [4](#0-3) 

4. When the miner's time slot has passed, `HandleMinerInNewRound()` returns `Nothing` [5](#0-4) 

5. Execution continues to `GetConsensusBehaviourToTerminateCurrentRound()` which returns `NextRound` without authorization checks [6](#0-5) 

**Why Protection Mechanisms Fail**:

The extra block producer is deterministically calculated using the signature of the first miner who produced a block [7](#0-6)  and designated with `IsExtraBlockProducer = true` [8](#0-7) 

However, the validation providers for `NextRound` behavior do NOT verify this designation:
- `MiningPermissionValidationProvider` only checks miner list membership [9](#0-8) 
- `NextRoundMiningOrderValidationProvider` validates mining order correctness [10](#0-9) 
- `RoundTerminateValidationProvider` checks round number and InValues [11](#0-10) 
- No validator checks the `IsExtraBlockProducer` flag [12](#0-11) 

The `IsCurrentMiner()` method does check extra block producer privileges [13](#0-12)  but is never invoked during consensus behavior determination or `NextRound` validation.

## Impact Explanation

**Consensus Integrity Violation**: The deterministic extra block producer calculation is a fundamental consensus mechanism designed to ensure fair rotation and prevent manipulation. Allowing arbitrary miners to bypass this breaks a critical invariant.

**Economic Benefits to Attacker**:

1. The terminating miner is recorded as `ExtraBlockProducerOfPreviousRound` in the next round [14](#0-13) 

2. Their `ProducedBlocks` count is incremented by 1 [15](#0-14) 

3. Mining rewards are calculated based on total produced blocks and donated to Treasury [16](#0-15) 

4. They gain privilege to mine during the extra block time slot at the start of the next round [17](#0-16) 

**Affected Parties**: All miners face unfair competition as the consensus mechanism's fairness and determinism are compromised. Honest designated extra block producers lose their rightful round termination opportunities and associated rewards.

## Likelihood Explanation

**Attacker Capabilities**: Any miner in the current round's miner list can execute this attack. The only requirement is membership in the miner list, which is verified [18](#0-17) 

**Attack Complexity**: Trivial
1. Miner intentionally skips producing a block during their assigned time slot
2. Wait for their time slot to pass
3. Call `GetConsensusCommand()` - a public ACS4 standard method
4. Receive `NextRound` behavior and produce the round-terminating block

**Economic Rationality**: The attack cost is zero (simply abstaining from mining during the assigned slot), while benefits include increased block production count, enhanced mining rewards, and priority mining position in the next round. Multiple miners can race to exploit this simultaneously.

**Feasibility**: The attack requires only being in the miner list (a given for any miner) and waiting for time progression (automatic). No other preconditions or special privileges are needed. The transaction fee for calling `GetConsensusCommand()` is the only cost.

## Recommendation

Add validation to enforce that only the designated extra block producer can terminate rounds:

1. In `SideChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()`, check if the calling miner has `IsExtraBlockProducer = true` before returning `NextRound`.

2. Add a new validation provider that verifies the sender's `IsExtraBlockProducer` flag when processing `NextRound` behavior:

```csharp
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.NextRound)
        {
            var nextRound = validationContext.ExtraData.Round;
            var senderPubkey = validationContext.SenderPubkey;
            var baseRound = validationContext.BaseRound;
            
            // Find the designated extra block producer
            var extraBlockProducer = baseRound.RealTimeMinersInformation.Values
                .FirstOrDefault(m => m.IsExtraBlockProducer);
            
            if (extraBlockProducer == null || extraBlockProducer.Pubkey != senderPubkey)
            {
                return new ValidationResult 
                { 
                    Message = "Only the designated extra block producer can terminate the round." 
                };
            }
        }
        return new ValidationResult { Success = true };
    }
}
```

3. Register this validator in the validation pipeline for `NextRound` behavior in `AEDPoSContract_Validation.cs`.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Initialize a side chain with multiple miners (A, B, C)
2. In round N, the consensus algorithm designates Miner C as the extra block producer (via `CalculateNextExtraBlockProducerOrder`)
3. Miner A intentionally skips their time slot  
4. After Miner A's time slot passes, Miner A calls `GetConsensusCommand()` and receives `NextRound` behavior
5. Miner A successfully produces a block terminating the round, even though Miner C was the designated extra block producer
6. In round N+1, Miner A is recorded as `ExtraBlockProducerOfPreviousRound` and receives the associated benefits
7. The vulnerability is confirmed when any non-designated miner can terminate rounds without restriction

**Notes**

This vulnerability affects both main chain and side chain implementations equally, as `MainChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` [19](#0-18)  also lacks validation of the extra block producer designation. The claim's focus on "side chains" is narrower than the actual scope of the issue.

The `PreCheck()` method only validates that the sender is in the current or previous round's miner list [20](#0-19)  and does not enforce extra block producer authorization for round termination.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-23)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-27)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L44-46)
```csharp
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L49-56)
```csharp
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L114-114)
```csharp
            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L178-178)
```csharp
        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L191-192)
```csharp
        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L118-129)
```csharp
        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```
