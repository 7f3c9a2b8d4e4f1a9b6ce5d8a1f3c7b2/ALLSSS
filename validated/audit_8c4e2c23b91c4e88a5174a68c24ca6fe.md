# Audit Report

## Title
Evil Nodes Bypass Punishment During Term Transitions Due to Missing Banned Pubkey Check in GetVictories Fallback Logic

## Summary
The Election contract's `GetVictories` method contains a critical flaw in its fallback logic that allows banned miners to be reselected during term transitions. When insufficient valid candidates exist, the method selects backup miners from current miners and initial miners without checking the `BannedPubkeyMap`, enabling evil nodes that should be permanently excluded to continue participating in consensus and earning rewards.

## Finding Description

**Vulnerability Root Cause**

The `GetVictories` method in the Election contract determines which miners will participate in the next consensus term. When there are insufficient valid candidates (those with votes > 0), it enters fallback logic to fill remaining slots with backup miners. [1](#0-0) 

The critical flaw occurs when valid candidates are insufficient. The fallback logic selects backups from current miners and initial miners **WITHOUT checking `State.BannedPubkeyMap`**, which tracks evil nodes that should be permanently excluded from mining. Specifically, the code adds initial miners to the backup list without any banned status verification. [2](#0-1) 

**Evil Node Marking Process**

When a node is marked as evil via `UpdateCandidateInformation`, the process sets `State.BannedPubkeyMap[pubkey] = true` and removes the node from `State.Candidates`. [3](#0-2) 

However, critically, the banned node is **NOT removed from `State.InitialMiners`**, making it eligible for reselection in the `GetVictories` fallback logic. The `InitialMiners` list is only set during contract initialization and never modified when nodes are banned. [4](#0-3) 

**Correct Implementation Exists**

The same file demonstrates the correct approach in `GetMinerReplacementInformation`, which properly filters banned pubkeys when selecting from initial miners using `.Where(k => !State.BannedPubkeyMap[k])`. [5](#0-4) 

This shows the developers were aware of the need to check banned status, but failed to apply this check in `GetVictories`.

**Term Transition Flow**

During term transitions, the consensus contract calls `TryToGetVictories` to obtain the new miner list, which internally calls the Election contract's `GetVictories` method. [6](#0-5) 

The returned miner list is then used directly in `GenerateFirstRoundOfNextTerm` to set the consensus miner list without additional banned checks. [7](#0-6) 

**Miner Replacement Limitation**

The miner replacement mechanism, which DOES check banned status via `GetMinerReplacementInformation`, only activates during same-term round transitions, NOT during term changes. The condition `previousRound.TermNumber == currentRound.TermNumber` ensures replacement only occurs within the same term. [8](#0-7) 

This leaves term transitions vulnerable to reselecting banned miners through the flawed `GetVictories` logic, as the replacement mechanism that performs banned checks is completely bypassed.

## Impact Explanation

**Consensus Integrity Violation**: This vulnerability completely bypasses the evil node punishment system, which is fundamental to AElf's consensus security model. Miners that were deliberately excluded for malicious behavior (missed blocks, consensus rule violations, etc.) can automatically rejoin consensus at the next term transition. The evil node detection system marks nodes as banned specifically to prevent them from participating in consensus. [9](#0-8) 

**Reward Misallocation**: Banned miners continue earning block production rewards and participating in profit distributions despite being marked as malicious actors. This creates perverse incentives where the punishment mechanism becomes meaningless.

**Severity - CRITICAL**: 
- Undermines the core security assumption that evil nodes can be permanently excluded
- No privileged access required - occurs automatically during normal term transitions
- Affects network integrity across multiple terms once triggered
- Silent failure with no error or event emission makes detection difficult
- Realistic trigger conditions (low candidate participation is common in early network stages)

## Likelihood Explanation

**Reachable Entry Point**: The vulnerability triggers through the normal term transition mechanism via `ProcessNextTerm`, which is a public, time-based process that occurs automatically. [10](#0-9) 

**Feasible Preconditions**:
1. At least one miner has been marked as evil (realistic - happens through consensus contract's automated detection or governance decisions)
2. Valid candidates with votes < required miners count at term transition (realistic during low voter participation periods, network bootstrap phases, or when many candidates are banned)
3. Term transition occurs (guaranteed by protocol design)

**Execution Practicality**:
- No attacker capabilities required beyond being previously marked as evil
- Triggered deterministically during automated term transitions
- Low candidate participation is a realistic scenario, especially during network launch phases, periods of low voter engagement, when multiple candidates are simultaneously banned, or in smaller side chains with limited validators

**Detection Difficulty**: The vulnerability executes silently without emitting error events or failing transactions, making it difficult to detect without explicit monitoring of the miner list composition across term transitions.

**Probability - HIGH**: Will occur deterministically whenever both conditions are met: (1) at least one banned node exists in current miners or initial miners, and (2) valid candidates < MinersCount at term transition time. Both conditions can easily occur simultaneously in production environments.

## Recommendation

Add banned pubkey filtering in the `GetVictories` fallback logic, similar to the implementation in `GetMinerReplacementInformation`. The fix should filter banned pubkeys from both current miners and initial miners before adding them to the backup list:

```csharp
// In ViewMethods.cs, GetVictories method (lines 66-69)
var backups = currentMiners.Where(k => !validCandidates.Contains(k) && !State.BannedPubkeyMap[k]).ToList();
if (State.InitialMiners.Value != null)
    backups.AddRange(
        State.InitialMiners.Value.Value.Select(k => k.ToHex())
            .Where(k => !backups.Contains(k) && !State.BannedPubkeyMap[k]));
```

This ensures that banned pubkeys are never selected as backup miners during term transitions, maintaining the integrity of the evil node punishment system.

## Proof of Concept

```csharp
// Test scenario demonstrating the vulnerability:
// 1. Mark a node as evil (sets BannedPubkeyMap[pubkey] = true)
// 2. Reduce valid candidates below MinersCount
// 3. Trigger term transition via GetVictories
// 4. Verify banned node is included in returned miner list

[Fact]
public async Task EvilNode_BypassesPunishment_DuringTermTransition()
{
    // Setup: Initialize with 3 initial miners
    await InitializeElectionContract(new[] { "pubkey1", "pubkey2", "pubkey3" });
    
    // Mark pubkey1 as evil (should be permanently excluded)
    await ElectionContractStub.UpdateCandidateInformation.SendAsync(
        new UpdateCandidateInformationInput 
        { 
            Pubkey = "pubkey1", 
            IsEvilNode = true 
        });
    
    // Verify pubkey1 is banned
    var isBanned = await ElectionContractStub.IsPubkeyBanned.CallAsync(new StringValue { Value = "pubkey1" });
    isBanned.Value.ShouldBeTrue();
    
    // Create scenario with insufficient valid candidates (0 candidates with votes)
    // MinersCount is 3, but no valid candidates exist
    
    // Call GetVictories (simulates term transition)
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    
    // VULNERABILITY: Banned pubkey1 is included in the returned miner list
    victories.Value.Select(v => v.ToHex()).ShouldContain("pubkey1");
    
    // This proves banned nodes can rejoin consensus during term transitions
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-391)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L32-38)
```csharp

        State.MinersCount.Value = input.MinerList.Count;
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-280)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-305)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L37-43)
```csharp
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```
