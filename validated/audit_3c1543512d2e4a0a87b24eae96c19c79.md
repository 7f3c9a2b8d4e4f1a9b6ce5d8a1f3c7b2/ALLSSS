# Audit Report

## Title
Proposer Whitelist Bypass - Removed Proposers Can Execute Approved Proposals

## Summary
The `Release` method in Association, Parliament, and Referendum governance contracts fails to re-validate whether the caller is still in the organization's proposer whitelist. This allows proposers who have been removed from the whitelist via `ChangeOrganizationProposerWhiteList` to retain execution authority for previously approved proposals, creating a critical authorization bypass.

## Finding Description

The vulnerability exists across all three governance contracts due to insufficient authorization validation in the `Release` method.

**Proposal Creation - Whitelist Validated:**
When a proposal is created, the system validates the proposer's whitelist membership. In Association, the `CreateProposal` method calls `AssertIsAuthorizedProposer`: [1](#0-0) 

This validation checks the proposer against the current whitelist: [2](#0-1) 

The same pattern exists in Parliament: [3](#0-2) [4](#0-3) 

And in Referendum: [5](#0-4) [6](#0-5) 

**Whitelist Updates Allowed:**
Organizations can update their proposer whitelist at any time using `ChangeOrganizationProposerWhiteList`: [7](#0-6) [8](#0-7) [9](#0-8) 

**Proposal Release - No Whitelist Re-Check:**
When releasing an approved proposal, only the original proposer identity is verified. In Association: [10](#0-9) 

The critical flaw is at line 186: the check `Context.Sender == proposalInfo.Proposer` verifies that the caller is the original proposer, but never re-validates whether this proposer is still in the current whitelist stored in `organization.ProposerWhiteList`.

Identical pattern in Parliament: [11](#0-10) 

Identical pattern in Referendum: [12](#0-11) 

The whitelist check method exists but is never called during Release: [13](#0-12) 

## Impact Explanation

**HIGH Severity** - This vulnerability represents a fundamental authorization bypass with severe consequences:

1. **Authorization Invariant Violation:** The proposer whitelist is a core security control mechanism. The expected invariant is: "Only addresses currently in the proposer whitelist can interact with governance proposals." This is completely violated for the Release operation.

2. **No Effective Revocation:** When organizations remove a proposer from the whitelist (due to compromise, discovered malicious intent, or changed trust model), they reasonably expect this revokes all governance authority. However, removed proposers retain full execution rights for any approved proposals.

3. **Arbitrary Contract Execution:** The `Release` method executes `Context.SendVirtualInlineBySystemContract` on behalf of the organization's virtual address, which can invoke any contract method including:
   - Token transfers from organization treasury
   - Contract upgrades and deployments  
   - Permission and configuration changes
   - Cross-chain operations
   - Other privileged governance actions

4. **Real Attack Scenarios:**
   - **Compromised Account:** Organization detects proposer account compromise and removes them from whitelist, but attacker can still execute approved proposals
   - **Malicious Proposer Discovery:** Proposer's malicious intent discovered after approval, but whitelist removal doesn't prevent execution
   - **Changed Trust Model:** Organization needs to reduce proposer set for security, but cannot revoke release rights for existing approved proposals

5. **No Mitigation Available:** The only defense is waiting for proposal expiration and using `ClearProposal`: [14](#0-13) 

This requires waiting the entire proposal lifetime (typically days) while the removed proposer can execute at will.

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability is highly feasible to exploit:

1. **Low Attacker Capabilities:** Attacker must only:
   - Initially be in proposer whitelist (normal operational state)
   - Create a proposal that gets approved (standard governance flow)
   - No special technical exploits, economic resources, or timing attacks required

2. **Low Attack Complexity:** The exploit is straightforward:
   - Step 1: Create proposal while whitelisted (verified by `AssertIsAuthorizedProposer`)
   - Step 2: Wait for organization member approval (normal operation)
   - Step 3: After being removed from whitelist via `ChangeOrganizationProposerWhiteList`, call `Release`
   - Step 4: Release succeeds because it only checks `Context.Sender == proposalInfo.Proposer`

3. **Realistic Triggering Conditions:**
   - Account compromise is a realistic operational risk requiring immediate whitelist removal
   - Discovering proposer malicious intent post-approval is common in governance
   - Organizations regularly need to update their trust model and proposer set
   - Extended attack window (approval to expiration, typically days)

4. **No Effective Detection/Prevention:**
   - Transactions are on-chain and visible, but prevention is impossible once proposal is approved
   - Organizations have no mechanism to revoke release authority
   - `ClearProposal` only works after expiration, leaving a long vulnerable window

## Recommendation

Add whitelist re-validation in the `Release` method for all three governance contracts:

**For Association:**
```csharp
public override Empty Release(Hash input)
{
    var proposalInfo = GetValidProposal(input);
    Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
    
    // Add whitelist re-check
    AssertIsAuthorizedProposer(proposalInfo.OrganizationAddress, Context.Sender);
    
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    // ... rest of the method
}
```

Apply the same fix to Parliament and Referendum contracts. This ensures that only proposers currently in the whitelist can release approved proposals, maintaining the authorization invariant throughout the proposal lifecycle.

## Proof of Concept

```csharp
[Fact]
public async Task RemovedProposer_CanStillReleaseApprovedProposal()
{
    // Setup: Create organization with proposer in whitelist
    var proposer = SampleAccount.Accounts[0];
    var members = new[] { SampleAccount.Accounts[1], SampleAccount.Accounts[2] };
    
    var createOrganizationInput = new CreateOrganizationInput
    {
        ProposerWhiteList = new ProposerWhiteList { Proposers = { proposer.Address } },
        OrganizationMemberList = new OrganizationMemberList { OrganizationMembers = { members.Select(m => m.Address) } },
        ProposalReleaseThreshold = new ProposalReleaseThreshold { MinimalApprovalThreshold = 2, MinimalVoteThreshold = 2 }
    };
    var organizationAddress = await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    
    // Step 1: Proposer creates proposal while whitelisted
    var proposalId = await CreateProposalAsync(proposer.KeyPair, organizationAddress);
    
    // Step 2: Get proposal approved by members
    await ApproveAsync(members[0].KeyPair, proposalId);
    await ApproveAsync(members[1].KeyPair, proposalId);
    
    // Step 3: Organization removes proposer from whitelist
    var organizationStub = GetAssociationContractTester(organizationAddress);
    await organizationStub.ChangeOrganizationProposerWhiteList.SendAsync(new ProposerWhiteList { Proposers = { } });
    
    // Step 4: Verify proposer is no longer in whitelist
    var validateResult = await AssociationContractStub.ValidateProposerInWhiteList.CallAsync(
        new ValidateProposerInWhiteListInput { OrganizationAddress = organizationAddress, Proposer = proposer.Address });
    Assert.False(validateResult.Value); // Proposer removed from whitelist
    
    // Step 5: Removed proposer can still release the approved proposal (VULNERABILITY)
    var releaseResult = await GetAssociationContractTester(proposer.KeyPair).Release.SendAsync(proposalId);
    Assert.True(releaseResult.TransactionResult.Status == TransactionResultStatus.Mined); // Release succeeds!
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L162-177)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var defaultOrganizationAddress = State.DefaultOrganizationAddress.Value;
        Assert(defaultOrganizationAddress == Context.Sender, "No permission.");
        var organization = State.Organizations[defaultOrganizationAddress];
        Assert(
            input.Proposers.Count > 0 || !organization.ProposerAuthorityRequired ||
            organization.ParliamentMemberProposingAllowed, "White list can't be empty.");
        State.ProposerWhiteList.Value = input;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Extensions.cs (L29-32)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```
