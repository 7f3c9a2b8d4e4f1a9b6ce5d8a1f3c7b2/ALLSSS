# Audit Report

## Title
Unbounded Candidate List Causes Consensus Failure via ExecutionBranchThreshold Breach

## Summary
The Election contract allows unlimited candidate registration without maximum bounds, enabling an attacker to register 15,001+ candidates that trigger a `RuntimeBranchThresholdExceededException` during term transitions. This causes the consensus-critical `TakeSnapshot` operation to fail, preventing the blockchain from transitioning to new consensus terms.

## Finding Description

The vulnerability exists in the interaction between unlimited candidate registration and the consensus term transition mechanism.

**Attack Vector:**

Any user can register as a candidate by calling `AnnounceElectionFor` with 100,000 ELF tokens locked per candidate. [1](#0-0) 

Each registration adds a public key to `State.Candidates.Value.Value` without checking total candidate count. [2](#0-1) 

The only protection is preventing the same public key from announcing twice, but an attacker can generate unlimited different public keys. [3](#0-2) 

**Critical Path:**

During term transitions, the consensus contract calls `TakeSnapshot` on the Election contract. [4](#0-3) 

`TakeSnapshot` internally calls `SavePreviousTermInformation`, which iterates through ALL candidates without pagination. [5](#0-4) 

**Threshold Breach:**

AElf enforces an ExecutionBranchThreshold of 15,000 to prevent infinite loops. [6](#0-5) 

When the branch counter reaches this threshold, a `RuntimeBranchThresholdExceededException` is thrown. [7](#0-6) 

Test evidence confirms that foreach loops with 15,000+ iterations trigger this exception. [8](#0-7) 

**Why Existing Protections Fail:**

The candidate count checks at lines 112 and 134 only control DataCenter subsidy eligibility, not total candidate registration. [9](#0-8) 

No maximum candidate limit exists in the codebase, and `GetPageableCandidateInformation` is a view method not used in the consensus path. [10](#0-9) 

## Impact Explanation

**Consensus Disruption:**

`ProcessNextTerm` is a critical consensus operation executed by validators to transition between governance terms. [11](#0-10) 

When this operation fails due to the threshold breach, the blockchain cannot rotate validator sets or update consensus parameters. While block production may continue with the current validator set, the inability to transition terms represents a fundamental breakdown of the AEDPoS consensus mechanism.

**Network-Wide Effects:**
- Validator rotation freezes indefinitely
- Term-based reward distributions cannot occur
- New validator elections cannot take effect
- Requires emergency governance intervention or hard fork to resolve

## Likelihood Explanation

**Economic Barrier:**

The attack requires locking 100,000 ELF per candidate. [12](#0-11) 

For 15,001 candidates: 100,000 Ã— 15,001 = 1,500,100,000 ELF (1.5 billion ELF)

**Recoverable Capital:**

The locked tokens are fully recoverable via `QuitElection`, making this a temporary capital requirement rather than a permanent cost. [13](#0-12) 

An attacker can recover all funds after the attack succeeds, significantly reducing the economic disincentive.

**Technical Feasibility:**
- Generating 15,001 keypairs is trivial
- Submitting 15,001 transactions is achievable within a single term period (typically days/weeks)
- No privileged access required
- Deterministic outcome once threshold is reached

**Mitigation Challenges:**

While the emergency response organization can remove candidates, removing 15,001 candidates one-by-one before the next term transition is impractical. [14](#0-13) 

## Recommendation

Implement a maximum candidate limit in the Election contract:

1. Add a constant `MaximumCandidatesCount` to `ElectionContractConstants.cs`
2. Check this limit in the `AnnounceElection` method before adding candidates:
   ```csharp
   Assert(State.Candidates.Value.Value.Count < ElectionContractConstants.MaximumCandidatesCount, 
          "Maximum candidate limit reached.");
   ```
3. Set the limit to a safe value below the ExecutionBranchThreshold (e.g., 10,000)

Alternatively, implement pagination in `SavePreviousTermInformation` to process candidates in batches, though this requires more extensive consensus contract modifications.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task UnboundedCandidates_Causes_BranchThresholdException()
{
    // Arrange: Register 15,001 candidates
    const int candidateCount = 15001;
    for (int i = 0; i < candidateCount; i++)
    {
        var keyPair = CryptoHelper.GenerateKeyPair();
        await AnnounceElectionForAsync(keyPair.PublicKey);
    }
    
    // Act: Attempt term transition via TakeSnapshot
    var result = await ElectionContractStub.TakeSnapshot.SendWithExceptionAsync(
        new TakeElectionSnapshotInput
        {
            TermNumber = 1,
            MinedBlocks = 100,
            RoundNumber = 1
        });
    
    // Assert: Verify RuntimeBranchThresholdExceededException is thrown
    result.TransactionResult.Error.ShouldContain("RuntimeBranchThresholdExceededException");
}
```

This test demonstrates that registering 15,001 candidates causes the `SavePreviousTermInformation` foreach loop to exceed the ExecutionBranchThreshold, resulting in a transaction failure that prevents term transitions.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L112-116)
```csharp
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-249)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-351)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L459-479)
```csharp
    private void SavePreviousTermInformation(TakeElectionSnapshotInput input)
    {
        var snapshot = new TermSnapshot
        {
            MinedBlocks = input.MinedBlocks,
            EndRoundNumber = input.RoundNumber
        };

        if (State.Candidates.Value == null) return;

        foreach (var pubkey in State.Candidates.Value.Value)
        {
            var votes = State.CandidateVotes[pubkey.ToHex()];
            var validObtainedVotesAmount = 0L;
            if (votes != null) validObtainedVotesAmount = votes.ObtainedActiveVotedVotesAmount;

            snapshot.ElectionResult.Add(pubkey.ToHex(), validObtainedVotesAmount);
        }

        State.Snapshots[input.TermNumber] = snapshot;
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L29-36)
```csharp
    public void BranchCount()
    {
        if (_branchThreshold != -1 && _branchCount == _branchThreshold)
            throw new RuntimeBranchThresholdExceededException(
                $"Contract branch threshold {_branchThreshold} exceeded.");

        _branchCount++;
    }
```

**File:** test/AElf.Contracts.TestContract.Tests/PatchedContractSecurityTests.cs (L427-434)
```csharp
        {
            await TestBasicSecurityContractStub.TestForeachInfiniteLoop.SendAsync(new ListInput
                { List = { new int[14999] } });
            var txResult =
                await TestBasicSecurityContractStub.TestForeachInfiniteLoop.SendWithExceptionAsync(
                    new ListInput { List = { new int[15000] } });
            txResult.TransactionResult.Error.ShouldContain(nameof(RuntimeBranchThresholdExceededException));
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L240-258)
```csharp
    public override GetPageableCandidateInformationOutput GetPageableCandidateInformation(PageInformation input)
    {
        var output = new GetPageableCandidateInformationOutput();
        var candidates = State.Candidates.Value;

        var count = candidates.Value.Count;
        if (count <= input.Start) return output;

        var length = Math.Min(Math.Min(input.Length, 20), candidates.Value.Count.Sub(input.Start));
        foreach (var candidate in candidates.Value.Skip(input.Start).Take(length))
            output.Value.Add(new CandidateDetail
            {
                CandidateInformation = State.CandidateInformationMap[candidate.ToHex()],
                ObtainedVotesAmount = GetCandidateVote(new StringValue { Value = candidate.ToHex() })
                    .ObtainedActiveVotedVotesAmount
            });

        return output;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```
