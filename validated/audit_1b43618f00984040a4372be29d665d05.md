# Audit Report

## Title
Sponsor Can DOS Voters by Rapidly Exhausting Snapshots Regardless of EndTimestamp

## Summary
The Vote contract's `TakeSnapshot` function lacks time-based restrictions, allowing sponsors to prematurely terminate voting by exhausting all snapshots in rapid succession. Voting eligibility depends solely on snapshot count rather than the declared `EndTimestamp`, enabling sponsors to deny voter participation despite the advertised voting period.

## Finding Description

The vulnerability stems from a fundamental mismatch between how voting periods are declared versus how they are enforced in the Vote contract.

The `TakeSnapshot` function only validates sponsor authorization and snapshot count limits, with no time-based restrictions whatsoever. [1](#0-0)  The function increments `CurrentSnapshotNumber` and sets the new snapshot's start time to the current block without validating against the voting item's `EndTimestamp`.

The critical flaw appears in `AssertValidVoteInput`, which determines voting eligibility based solely on snapshot count. [2](#0-1)  The check compares `CurrentSnapshotNumber <= TotalSnapshotNumber`, making no reference to time. Once snapshots are exhausted, voting immediately fails with "Current voting item already ended."

During registration, `EndTimestamp` is stored but only validated to exceed `StartTimestamp`. [3](#0-2)  The `EndTimestamp` field is never checked during subsequent voting or snapshot operations, rendering it purely informational rather than a security enforcement mechanism.

**Attack Scenario:**
1. Sponsor registers voting item with `EndTimestamp` 30 days in future and `TotalSnapshotNumber = 10`
2. Sponsor immediately calls `TakeSnapshot` 10 times in rapid succession (consecutive blocks or even same block if gas permits)
3. `CurrentSnapshotNumber` reaches 11, exceeding `TotalSnapshotNumber`
4. All voter attempts to participate fail, despite being well before the declared `EndTimestamp`
5. Governance outcome is determined only by votes cast in the brief window before snapshot exhaustion

## Impact Explanation

**Severity: High**

This vulnerability enables complete denial of the voting system's core functionality with severe governance implications:

1. **Operational DOS**: Voters are systematically denied their ability to participate in governance despite the declared voting period, violating the fundamental expectation that `EndTimestamp` defines when voting closes.

2. **Governance Manipulation**: Sponsors can strategically control voter participation windows to influence outcomes. By terminating voting prematurely, they can exclude late voters who might have different preferences, effectively rigging governance decisions.

3. **Trust Violation**: The voting system's inability to honor its time commitments undermines trust in the governance process. A 30-day voting period advertised to the community can be terminated in minutes.

4. **Unfair Advantage**: Early voters who manage to vote before snapshot exhaustion gain disproportionate influence, while late voters are completely excluded despite acting within the declared timeframe.

While no direct fund theft occurs, governance manipulation at this level can lead to protocol-level damage through unauthorized parameter changes, malicious proposals, or captured decision-making processes.

## Likelihood Explanation

**Likelihood: High**

This vulnerability has exceptionally high exploitability:

1. **Low Attack Complexity**: The entry point is the public `TakeSnapshot` method accessible to any sponsor. Execution requires only repeatedly calling `TakeSnapshot` with sequential snapshot numbers - no sophisticated techniques needed.

2. **No Special Privileges Required**: The sponsor role is part of normal operation, obtained simply by registering a voting item. This is not a compromised or privileged account scenario.

3. **Trivial Execution**: The attack can be executed in consecutive blocks or even within a single block (gas permitting). Test evidence demonstrates snapshots can be taken in rapid succession without any time delays. [4](#0-3)  The test takes 3 snapshots immediately in a for loop, proving no time-based restrictions exist.

4. **Difficult Detection**: Rapid snapshots appear as legitimate sponsor activity with no on-chain indicators to distinguish malicious from legitimate snapshot progression. Voters only discover the DOS when their transactions fail.

Test evidence confirms this behavior - when snapshots are exhausted, voting immediately fails. [5](#0-4) 

## Recommendation

Add time-based validation to prevent premature snapshot exhaustion. The fix should enforce that:

1. `TakeSnapshot` should check that `Context.CurrentBlockTime` has not exceeded the voting item's `EndTimestamp`
2. Consider adding a minimum time interval between snapshots to prevent rapid exhaustion
3. In `AssertValidVoteInput`, add a check that `Context.CurrentBlockTime <= votingItem.EndTimestamp` before allowing votes

Suggested fix for `TakeSnapshot`:

```csharp
public override Empty TakeSnapshot(TakeSnapshotInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");
    
    // Add time-based validation
    Assert(Context.CurrentBlockTime < votingItem.EndTimestamp, 
        "Cannot take snapshot after voting period has ended.");
    
    Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
        "Current voting item already ended.");
    
    // ... rest of implementation
}
```

Suggested fix for `AssertValidVoteInput`:

```csharp
private VotingItem AssertValidVoteInput(VoteInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    
    // Add time-based validation
    Assert(Context.CurrentBlockTime <= votingItem.EndTimestamp,
        "Voting period has ended.");
    
    Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
    Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
    Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
        "Current voting item already ended.");
    
    // ... rest of implementation
}
```

## Proof of Concept

```csharp
[Fact]
public async Task VoteContract_RapidSnapshotExhaustion_DOS_Test()
{
    // Register voting item with 10 snapshots and EndTimestamp 30 days in future
    var endTime = TimestampHelper.GetUtcNow().AddDays(30);
    var votingItem = await RegisterVotingItemAsync(10, 4, true, DefaultSender, 10, endTime);
    
    // Sponsor exhausts all 10 snapshots in rapid succession
    for (var i = 1; i <= 10; i++)
    {
        await VoteContractStub.TakeSnapshot.SendAsync(new TakeSnapshotInput
        {
            VotingItemId = votingItem.VotingItemId,
            SnapshotNumber = i
        });
    }
    
    // Verify CurrentSnapshotNumber is now 11 (exhausted)
    var updatedItem = await GetVoteItem(votingItem.VotingItemId);
    updatedItem.CurrentSnapshotNumber.ShouldBe(11);
    
    // Attempt to vote - should fail despite being well before EndTimestamp
    var voteResult = await VoteContractStub.Vote.SendWithExceptionAsync(new VoteInput
    {
        VotingItemId = votingItem.VotingItemId,
        Amount = 100,
        Option = "Option1"
    });
    
    // Voting fails even though we're before EndTimestamp
    voteResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    voteResult.TransactionResult.Error.ShouldContain("Current voting item already ended");
    
    // Verify we're still well before the declared EndTimestamp
    Context.CurrentBlockTime.ShouldBeLessThan(endTime);
}
```

## Notes

This vulnerability represents a critical design flaw where the voting system's temporal guarantees (`EndTimestamp`) are completely bypassed by snapshot-based termination logic. The sponsor's ability to unilaterally terminate voting early fundamentally breaks the trust model of the governance system, where participants expect voting periods to be honored as advertised.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L241-273)
```csharp
    public override Empty TakeSnapshot(TakeSnapshotInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);

        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");

        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");

        // Update previous voting going information.
        var previousVotingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
        var previousVotingResult = State.VotingResults[previousVotingResultHash];
        previousVotingResult.SnapshotEndTimestamp = Context.CurrentBlockTime;
        State.VotingResults[previousVotingResultHash] = previousVotingResult;

        Assert(votingItem.CurrentSnapshotNumber == input.SnapshotNumber,
            $"Can only take snapshot of current snapshot number: {votingItem.CurrentSnapshotNumber}, but {input.SnapshotNumber}");
        var nextSnapshotNumber = input.SnapshotNumber.Add(1);
        votingItem.CurrentSnapshotNumber = nextSnapshotNumber;
        State.VotingItems[votingItem.VotingItemId] = votingItem;

        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/SnapshotTests.cs (L42-60)
```csharp
    public async Task VoteContract_TakeSnapshot_Exceed_TotalSnapshotNumber_Test()
    {
        var totalSnapshotNumber = 1;
        var votingItem = await RegisterVotingItemAsync(10, 4, true, DefaultSender, totalSnapshotNumber);
        await VoteContractStub.TakeSnapshot.SendAsync(
            new TakeSnapshotInput
            {
                VotingItemId = votingItem.VotingItemId,
                SnapshotNumber = 1
            });
        var transactionResult = (await VoteContractStub.TakeSnapshot.SendWithExceptionAsync(
            new TakeSnapshotInput
            {
                VotingItemId = votingItem.VotingItemId,
                SnapshotNumber = 2
            })).TransactionResult;
        transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        transactionResult.Error.Contains("Current voting item already ended.").ShouldBeTrue();
    }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/SnapshotTests.cs (L78-101)
```csharp
    public async Task VoteContract_TakeSnapshot_Success_Test()
    {
        var registerItem = await RegisterVotingItemAsync(10, 4, true, DefaultSender, 3);
        for (var i = 0; i < 3; i++)
        {
            var transactionResult = (await VoteContractStub.TakeSnapshot.SendAsync(
                new TakeSnapshotInput
                {
                    VotingItemId = registerItem.VotingItemId,
                    SnapshotNumber = i + 1
                })).TransactionResult;

            transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            var votingItem = await GetVoteItem(registerItem.VotingItemId);
            votingItem.CurrentSnapshotNumber.ShouldBe(i + 2);
            var voteResult = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
            {
                VotingItemId = registerItem.VotingItemId,
                SnapshotNumber = i + 2
            });
            voteResult.SnapshotNumber.ShouldBe(i + 2);
        }
    }
```
