# Audit Report

## Title
Missing Contract Address Validation in Governance Proposal Creation Allows Governance DoS

## Summary
The Referendum, Parliament, and Association governance contracts fail to validate whether proposal target addresses correspond to deployed smart contracts. This allows whitelisted proposers to create proposals targeting non-existent contracts or EOA addresses, causing approved proposals to fail during release and temporarily locking voter resources until proposal expiration.

## Finding Description

All three governance contracts validate proposals using a `Validate(ProposalInfo)` method that only checks if `ToAddress != null` without verifying contract existence.

In Referendum, the validation only checks for non-null address: [1](#0-0) 

The same insufficient validation exists in Parliament: [2](#0-1) 

And in Association: [3](#0-2) 

When a proposal with an invalid address is approved and released, the system attempts to execute an inline transaction. The `Release` methods call `Context.SendVirtualInlineBySystemContract()` targeting the unvalidated address: [4](#0-3) 

During execution, when the system attempts to get an executive for a non-existent contract address, a `SmartContractFindRegistrationException` is caught and the inline transaction fails with status `ContractError`: [5](#0-4) 

When an inline transaction fails, execution stops and the parent transaction is marked as unsuccessful: [6](#0-5) 

Critically, when a transaction fails due to inline transaction failure, only pre/post plugin state changes are committed to the state cache, NOT the main transaction's state changes: [7](#0-6) 

This behavior is confirmed by test cases showing that when an inline transaction fails, the parent transaction status is `Failed` and no state changes are committed: [8](#0-7) 

Since the proposal removal operation (`State.Proposals.Remove(input)`) in the Release methods is not committed when the transaction fails, the proposal remains in storage in an approved but perpetually unreleasable state. The proposer can attempt release repeatedly, but it will fail each time until the proposal expires.

For Referendum contracts, voter tokens are locked via `TransferFrom` to the proposal virtual address during voting and can only be reclaimed after expiration: [9](#0-8) 

## Impact Explanation

**Governance Disruption (High):** Approved proposals cannot execute their intended governance actions (parameter changes, contract updates, resource allocations), breaking the governance process. This is particularly severe for time-sensitive or critical protocol updates.

**Resource Waste (Medium):** In Referendum contracts, voter tokens remain locked in the proposal virtual address until expiration. While tokens can eventually be reclaimed via `ReclaimVoteToken`, this represents a temporary denial of liquidity for voters and wastes governance participation effort.

**Availability Impact (High):** The proposal enters a deadlock state - it remains approved and cannot be executed, but also cannot be easily cleared until expiration. Repeated release attempts will consistently fail, consuming transaction fees without resolution.

**Scope:** This affects all three core governance contracts (Referendum, Parliament, Association), potentially impacting the entire protocol governance system.

## Likelihood Explanation

**Access Requirements (Medium Constraint):** The attacker must be a whitelisted proposer for the organization, verified by `AssertIsAuthorizedProposer`. While this limits the attack surface, proposers are a larger group than genesis/admin keys and may include:
- Multiple organization members in Association
- Parliament members in Parliament (when `ParliamentMemberProposingAllowed = true`)
- Whitelisted addresses in Referendum

**Execution Complexity (Low):** The attack requires only creating a proposal with a non-existent contract address. This can occur through:
- **Accidental**: Copy-paste errors, typos in addresses, or targeting not-yet-deployed contracts
- **Intentional**: Malicious proposer deliberately wasting governance resources

**Detection Difficulty (Medium):** While voters can inspect `ToAddress` before voting, they may not verify contract existence. The validation gap means the error is only discovered during release, after voting effort is expended.

**Overall Likelihood: MEDIUM** - Feasible for authorized proposers with low complexity, but requires proposer role.

## Recommendation

Add contract existence validation in the `Validate(ProposalInfo)` method for all three governance contracts. The Genesis contract provides `GetContractInfo` which returns contract metadata if deployed, or an empty `ContractInfo` if not: [10](#0-9) 

**Recommended Fix:**

1. Add a Genesis contract reference to the governance contract states (Referendum/Parliament/Association State files)

2. Update the `Validate(ProposalInfo)` method to check contract existence:

```csharp
private bool Validate(ProposalInfo proposal)
{
    var validDestinationAddress = proposal.ToAddress != null;
    var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
    var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    var hasOrganizationAddress = proposal.OrganizationAddress != null;
    var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
    
    // NEW: Validate contract exists at ToAddress
    var contractExists = false;
    if (validDestinationAddress)
    {
        var genesisAddress = Context.GetZeroSmartContractAddress();
        var contractInfo = Context.Call<ContractInfo>(
            genesisAddress, 
            "GetContractInfo", 
            proposal.ToAddress
        );
        contractExists = contractInfo != null && contractInfo.ContractAddress != null;
    }
    
    return validDestinationAddress && contractExists && validDestinationMethodName && 
           validExpiredTime && hasOrganizationAddress && validDescriptionUrl;
}
```

This ensures proposals can only target deployed contracts, preventing the governance DoS scenario.

## Proof of Concept

```csharp
[Fact]
public async Task CreateProposal_WithNonExistentContract_ShouldFailOnRelease()
{
    // 1. Create organization with proposer whitelist
    var organizationAddress = await ReferendumContractStub.CreateOrganization.SendAsync(
        new CreateOrganizationInput
        {
            TokenSymbol = "ELF",
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 1000,
                MinimalVoteThreshold = 1000,
                MaximalAbstentionThreshold = 0,
                MaximalRejectionThreshold = 0
            },
            ProposerWhiteList = new ProposerWhiteList
            {
                Proposers = { DefaultSender }
            }
        });

    // 2. Create proposal targeting non-existent contract address
    var nonExistentAddress = Address.FromBase58("2ZYyxEH6j8zAyJjef6Spa99Jx2zf5GbFktyAQEBPWLCvuSAn8D");
    var proposalId = await ReferendumContractStub.CreateProposal.SendAsync(
        new CreateProposalInput
        {
            OrganizationAddress = organizationAddress.Output,
            ToAddress = nonExistentAddress, // Non-existent contract
            ContractMethodName = "SomeMethod",
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            Params = ByteString.Empty
        });

    // 3. Approve proposal (simulate voting with sufficient tokens)
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = proposalId.Output,
        Symbol = "ELF",
        Amount = 2000
    });
    
    await ReferendumContractStub.Approve.SendAsync(proposalId.Output);

    // 4. Verify proposal is approved and ready for release
    var proposal = await ReferendumContractStub.GetProposal.CallAsync(proposalId.Output);
    proposal.ToBeReleased.ShouldBeTrue();

    // 5. Attempt to release - should fail with ContractError
    var releaseResult = await ReferendumContractStub.Release.SendWithExceptionAsync(proposalId.Output);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Invalid contract address");

    // 6. Verify proposal still exists (not removed due to state reversion)
    var proposalAfterFail = await ReferendumContractStub.GetProposal.CallAsync(proposalId.Output);
    proposalAfterFail.ProposalId.ShouldBe(proposalId.Output);
    proposalAfterFail.ToBeReleased.ShouldBeTrue(); // Still marked as ready for release

    // 7. Tokens remain locked until expiration
    var lockedTokens = await ReferendumContractStub.GetLockedTokenAmount.CallAsync(
        new GetLockedTokenAmountInput
        {
            ProposalId = proposalId.Output,
            Address = DefaultSender
        });
    lockedTokens.Amount.ShouldBe(2000); // Tokens still locked
}
```

This test demonstrates:
1. A proposer can create a proposal with a non-existent contract address (passes validation)
2. The proposal can be approved and marked ready for release
3. Release fails with "Invalid contract address" error
4. The proposal remains in storage (not removed)
5. Voter tokens remain locked until expiration

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L157-166)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = CheckProposalNotExpired(proposal);
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L115-122)
```csharp
    public override Empty ReclaimVoteToken(Hash input)
    {
        var proposal = State.Proposals[input];
        Assert(proposal == null ||
               Context.CurrentBlockTime >= proposal.ExpiredTime, "Unable to reclaim at this time.");
        UnlockToken(input, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L105-126)
```csharp
    private static bool TryUpdateStateCache(TransactionTrace trace, TieredStateCache groupStateCache)
    {
        if (trace == null)
            return false;

        if (!trace.IsSuccessful())
        {
            var transactionExecutingStateSets = new List<TransactionExecutingStateSet>();

            AddToTransactionStateSets(transactionExecutingStateSets, trace.PreTraces);
            AddToTransactionStateSets(transactionExecutingStateSets, trace.PostTraces);

            groupStateCache.Update(transactionExecutingStateSets);
            trace.SurfaceUpError();
        }
        else
        {
            groupStateCache.Update(trace.GetStateSets());
        }

        return true;
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L150-161)
```csharp
        try
        {
            executive = await _smartContractExecutiveService.GetExecutiveAsync(
                internalChainContext,
                singleTxExecutingDto.Transaction.To);
        }
        catch (SmartContractFindRegistrationException)
        {
            txContext.Trace.ExecutionStatus = ExecutionStatus.ContractError;
            txContext.Trace.Error += "Invalid contract address.\n";
            return trace;
        }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L236-246)
```csharp
            var inlineTrace = await ExecuteOneAsync(singleTxExecutingDto, cancellationToken);

            if (inlineTrace == null)
                break;
            trace.InlineTraces.Add(inlineTrace);
            if (!inlineTrace.IsSuccessful())
                // Already failed, no need to execute remaining inline transactions
                break;

            internalStateCache.Update(inlineTrace.GetStateSets());
        }
```

**File:** test/AElf.Parallel.Tests/DeleteDataFromStateDbTest.cs (L2127-2135)
```csharp
        var transactionResult = await GetTransactionResultAsync(transaction.GetHash(), block.Header);
        transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);

        value = await GetValueAsync(accountAddress, key, block.GetHash(), block.Height);
        CheckValueNotExisted(value);

        var blockStateSet = await _blockStateSetManger.GetBlockStateSetAsync(block.GetHash());
        blockStateSet.Changes.Count.ShouldBe(0);
        blockStateSet.Deletes.Count.ShouldBe(0);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L20-26)
```csharp
    public override ContractInfo GetContractInfo(Address input)
    {
        var info = State.ContractInfos[input];
        if (info == null) return new ContractInfo();

        return info;
    }
```
