# Audit Report

## Title
Referendum Organizations Can Become Permanently Locked Through Invalid Configuration Changes

## Summary
The Referendum contract's organization configuration change methods lack sufficient validation to prevent setting values that make future governance impossible. Organizations can become permanently locked through either malicious proposals or configuration errors, with no recovery mechanism available.

## Finding Description

The Referendum contract allows organizations to modify their configuration exclusively through self-executed proposals via `ChangeOrganizationThreshold` and `ChangeOrganizationProposerWhiteList` methods. Both methods enforce that only the organization itself can execute these changes by checking `Context.Sender` equals the organization address. [1](#0-0) [2](#0-1) 

The critical issue lies in the `Validate(Organization)` method which performs insufficient validation. [3](#0-2) 

**Three Locking Scenarios Exist:**

**1. Unreachable Whitelist Lock:** The validation only checks `ProposerWhiteList.Empty()` which verifies the count is not zero. [4](#0-3)  It does NOT validate whether addresses are reachable, valid, or controlled by anyone. An organization can set its whitelist to burn addresses, lost keys, or non-cooperative parties, making proposal creation impossible.

**2. Impossible Threshold Lock:** The validation checks `MinimalApprovalThreshold > 0` and `MinimalApprovalThreshold <= MinimalVoteThreshold` but imposes NO upper bounds on any threshold values. An organization can set `MinimalVoteThreshold` or `MinimalApprovalThreshold` to `long.MaxValue` (9,223,372,036,854,775,807) or any value exceeding practical voting capacity, making it mathematically impossible to pass proposals.

**3. Zero-Tolerance Lock:** The validation allows `MaximalRejectionThreshold` and `MaximalAbstentionThreshold` to be set to zero. When checking release conditions, the code evaluates `proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold` and `proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold`. [5](#0-4)  With zero thresholds, even a single rejection or abstention vote blocks release, creating impossible coordination requirements.

## Impact Explanation

Once an organization is locked through invalid configuration:

1. **Complete Governance DoS:** The organization can never create, approve, or execute proposals again. If the whitelist contains only unreachable addresses, no proposals can be created. If thresholds are impossible to reach, no proposals can pass. If rejection/abstention thresholds are zero, proposals cannot be released.

2. **Permanent Fund Lock:** Any tokens or assets held in the organization's virtual address become permanently unrecoverable since only successful proposals can execute transfers.

3. **No Recovery Mechanism:** The organization address is deterministically derived from the creation input. There is no admin override, no fallback governance, and no way to recover control once locked.

4. **External Dependency Failure:** Any contracts or systems relying on this organization's governance decisions become permanently blocked.

The severity is HIGH because this results in complete and permanent loss of governance functionality with irreversible fund lock and no recovery path.

## Likelihood Explanation

**Attack Vector:**
A malicious proposer (legitimate whitelist member) creates a proposal to change organization configuration with locking values, gathers enough votes to pass it within current thresholds, and releases it. The attack follows the normal proposal workflow using public methods. [6](#0-5) [7](#0-6) 

**Feasibility:**
- Entry point: Standard `CreateProposal` method (public, intended functionality)
- Required privileges: Proposer whitelist membership (legitimate role)
- Attack complexity: LOW - follows normal governance flow
- Can occur both maliciously AND accidentally (typos, copy-paste errors)

**No Safeguards:**
The contract provides no warnings about potentially locking configurations. Organizations must manually verify configuration changes before approval, but there are no automated checks or bounds to prevent dangerous values.

The likelihood is HIGH due to low attack complexity and high probability of accidental occurrence.

## Recommendation

Add comprehensive validation to the `Validate(Organization)` method:

1. **Validate Whitelist Addresses:** Check that proposer addresses are not burn addresses and are properly formatted
2. **Add Upper Bound Checks:** Enforce maximum reasonable values for all thresholds based on token supply or practical limits
3. **Prevent Zero Tolerance:** Require minimum non-zero values for `MaximalRejectionThreshold` and `MaximalAbstentionThreshold`
4. **Add Warning Events:** Emit warnings when configuration changes approach dangerous values
5. **Consider Time-Locked Recovery:** Implement a grace period where dangerous configurations can be reverted

Example validation additions:
```csharp
// Add upper bound checks
Assert(proposalReleaseThreshold.MinimalVoteThreshold <= practicalMaximum, "Vote threshold too high");
Assert(proposalReleaseThreshold.MinimalApprovalThreshold <= practicalMaximum, "Approval threshold too high");

// Prevent zero tolerance
Assert(proposalReleaseThreshold.MaximalRejectionThreshold > 0, "Rejection threshold cannot be zero");
Assert(proposalReleaseThreshold.MaximalAbstentionThreshold > 0, "Abstention threshold cannot be zero");

// Validate whitelist addresses are not burn addresses
foreach(var proposer in organization.ProposerWhiteList.Proposers)
{
    Assert(!IsBurnAddress(proposer), "Whitelist cannot contain burn addresses");
}
```

## Proof of Concept

```csharp
[Fact]
public async Task Organization_PermanentLock_Through_ImpossibleThreshold()
{
    // Create organization with reasonable initial thresholds
    var organizationAddress = await CreateOrganizationAsync(
        minimalApproveThreshold: 5000,
        minimalVoteThreshold: 5000,
        maximalAbstentionThreshold: 10000,
        maximalRejectionThreshold: 10000,
        proposerWhiteList: new[] { DefaultSender }
    );

    // Create malicious proposal to set impossible thresholds
    var lockingThreshold = new ProposalReleaseThreshold
    {
        MinimalVoteThreshold = long.MaxValue, // Impossible to reach
        MinimalApprovalThreshold = long.MaxValue / 2,
        MaximalAbstentionThreshold = 0, // Zero tolerance - any abstention blocks
        MaximalRejectionThreshold = 0  // Zero tolerance - any rejection blocks
    };

    var maliciousProposalId = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair,
        lockingThreshold,
        nameof(ReferendumContractStub.ChangeOrganizationThreshold),
        organizationAddress,
        ReferendumContractAddress
    );

    // Pass the malicious proposal (within current thresholds)
    await ApproveAllowanceAsync(Accounts[3].KeyPair, 5000, maliciousProposalId);
    await ApproveAsync(Accounts[3].KeyPair, maliciousProposalId);
    
    // Release the malicious configuration change
    var releaseResult = await ReferendumContractStub.Release.SendAsync(maliciousProposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

    // Verify organization is now permanently locked
    var org = await ReferendumContractStub.GetOrganization.CallAsync(organizationAddress);
    org.ProposalReleaseThreshold.MinimalVoteThreshold.ShouldBe(long.MaxValue);

    // Attempt to create new proposal - should work
    var newProposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);

    // Attempt to gather votes and release - will NEVER succeed
    // Even with all tokens voting, cannot reach long.MaxValue threshold
    // Organization is permanently locked with no recovery mechanism
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```
