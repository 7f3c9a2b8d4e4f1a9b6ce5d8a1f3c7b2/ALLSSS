# Audit Report

## Title
NFT Token Hash Collision via Ambiguous String Concatenation Enables Cross-Protocol Denial of Service and State Corruption

## Summary
The `CalculateTokenHash` function uses undelimited string concatenation to generate NFT identifiers from symbol and tokenId. Since NFT protocol symbols contain variable-length random numbers (9+ digits), different (symbol, tokenId) pairs from different protocols can produce identical tokenHash values, causing either denial of service when protocols attempt to mint, or state corruption when multiple protocols share the same storage slots.

## Finding Description

The root cause lies in the `CalculateTokenHash` implementation which performs simple string concatenation without any delimiter: [1](#0-0) 

NFT protocol symbols are generated with a 2-character prefix followed by random numbers. The minimum number length starts at 9 digits: [2](#0-1) 

The random number length dynamically increases as more protocols are created: [3](#0-2) 

This creates symbols like `"AR123456789"` (11 characters total: 2-char prefix + 9 digits) that later grow to `"AR1234567899"` (12 characters: 2-char prefix + 10 digits).

**Collision Example:**
- Protocol A: Symbol `"AR123456789"` + tokenId `999` → Hash(`"AR123456789999"`)
- Protocol B: Symbol `"AR1234567899"` + tokenId `99` → Hash(`"AR123456789999"`)

Both produce identical hash inputs despite representing completely different NFTs from different protocols.

The collision check during minting only verifies if the tokenHash already exists, but does NOT validate if it belongs to the same protocol: [4](#0-3) 

The check at line 395-396 only validates `nftInfo == null`, but never verifies `nftInfo.Symbol == input.Symbol`. This means cross-protocol collisions are not detected.

When `IsTokenIdReuse` is false, the assertion blocks the second protocol from minting (DoS). When `IsTokenIdReuse` is true, the assertion is bypassed and both protocols write to identical state locations.

All critical NFT state storage uses tokenHash as the direct key without protocol scoping: [5](#0-4) 

This means colliding tokenHashes share the same storage slots across:
- NFT metadata storage (`NftInfoMap[tokenHash]`)
- Balance tracking (`BalanceMap[tokenHash][owner]`)
- Allowance management (`AllowanceMap[tokenHash][owner][spender]`)

All NFT operations depend on this tokenHash for lookups: [6](#0-5) [7](#0-6) [8](#0-7) [9](#0-8) [10](#0-9) 

## Impact Explanation

**Denial of Service Impact:**
When Protocol A with symbol `"AR123456789"` mints tokenId=999 first, any subsequent protocol whose symbol creates a collision (e.g., `"AR1234567899"` with tokenId=99) is permanently blocked from using that tokenId. The error message "Token id 99 already exists. Please assign a different token id." is misleading since tokenId 99 doesn't exist for Protocol B—only the hash collision exists. This affects legitimate protocol operators who cannot mint specific tokenIds, creating systematic DoS as the ecosystem scales and more 10+ digit symbols are created.

**State Corruption Impact:**
If `IsTokenIdReuse=true` for the colliding protocol, both protocols write to the same state storage locations. The NFT metadata, balances, and allowances become conflated across protocols:
- `GetNFTInfo` returns Protocol A's metadata when querying Protocol B's NFT
- `GetBalance` returns mixed balance data across protocols
- `Transfer` and `TransferFrom` may affect unintended NFTs
- `Burn` operations could destroy wrong assets
- `Approve` permissions get mixed, creating unauthorized transfer capabilities

**Severity: CRITICAL**
This breaks the fundamental invariant that each (symbol, tokenId) pair must uniquely identify an NFT. It enables systematic DoS against new protocols, corrupts core state storage affecting all NFT operations, requires no special privileges, and the impact scales with ecosystem growth.

## Likelihood Explanation

**Attacker Capabilities:**
- Requires mint permission on at least one NFT protocol (obtainable by creating a protocol via the `Create` method or being added as a minter)
- Ability to calculate hash collisions (simple string arithmetic: find symbol `S'` of length `N+1` where `S + tokenId1 == S' + tokenId2`)
- Ability to strategically mint specific tokenIds
- No governance control or special system privileges needed

**Attack Feasibility:**
The attack is straightforward:
1. Monitor on-chain protocol creation to identify symbol values
2. Calculate collision pairs using the formula above
3. Mint the colliding tokenId in the protocol with shorter symbol
4. Legitimate users cannot mint the colliding tokenId in protocols with longer symbols (DoS)
5. If `IsTokenIdReuse=true`, state corruption occurs automatically

**Conditions:**
- Symbol generation is deterministic and publicly observable on-chain
- No special timing windows required beyond standard transaction ordering
- Attack becomes more practical as system scales with more 10+ digit symbols
- Collision probability increases with each new protocol created

**Detection:**
- Collisions appear as legitimate mint transactions
- Error messages don't indicate cross-protocol collision
- No on-chain monitoring mechanism detects this pattern
- Victims may not realize blockage is due to collision from another protocol

**Economic Rationality:**
- Attack cost: Only gas fees for mint transactions
- Potential gain: Blocking competitors' protocols, griefing tokenId ranges, causing protocol-level DoS, corrupting NFT state
- Cost-benefit strongly favors attacker, especially for competitive NFT protocols

## Recommendation

Add protocol scoping to the `CalculateTokenHash` function by including a delimiter, or verify protocol ownership during collision checks:

**Option 1: Add Delimiter to Hash Calculation**
```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}-{tokenId}");  // Add delimiter
}
```

**Option 2: Verify Protocol Ownership During Mint**
```csharp
var nftInfo = State.NftInfoMap[tokenHash];
if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
{
    Assert(nftInfo == null || nftInfo.Symbol == input.Symbol, 
           $"Token id {tokenId} already exists in another protocol. Please assign a different token id.");
}
```

**Option 3: Use Composite Key for State Storage**
Restructure state storage to use `(symbol, tokenId)` composite keys instead of just `tokenHash`, eliminating the collision risk entirely.

## Proof of Concept

```csharp
[Fact]
public void Test_NFT_TokenHash_Collision_DoS()
{
    // Setup: Create two NFT protocols
    var protocolASymbol = "AR123456789";  // 11 chars
    var protocolBSymbol = "AR1234567899"; // 12 chars
    
    CreateProtocol(protocolASymbol, isTokenIdReuse: false);
    CreateProtocol(protocolBSymbol, isTokenIdReuse: false);
    
    // Protocol A mints tokenId=999
    // This creates hash: Hash("AR123456789999")
    MintNFT(protocolASymbol, tokenId: 999);
    
    // Protocol B attempts to mint tokenId=99
    // This would create hash: Hash("AR123456789999") - SAME HASH!
    // Should fail with collision error
    var exception = Assert.Throws<AssertionException>(() => 
        MintNFT(protocolBSymbol, tokenId: 99));
    
    // Error message is misleading - says tokenId 99 exists but it doesn't for Protocol B
    Assert.Contains("Token id 99 already exists", exception.Message);
    
    // Verify collision: both produce same hash
    var hashA = CalculateTokenHash(protocolASymbol, 999);
    var hashB = CalculateTokenHash(protocolBSymbol, 99);
    Assert.Equal(hashA, hashB); // Collision confirmed
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L21-24)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L57-59)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-85)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L393-396)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-30)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L14-18)
```csharp
    public override NFTInfo GetNFTInfo(GetNFTInfoInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        return GetNFTInfoByTokenHash(tokenHash);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L32-36)
```csharp
    public override GetBalanceOutput GetBalance(GetBalanceInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var balance = State.BalanceMap[tokenHash][input.Owner];
        return new GetBalanceOutput
```
