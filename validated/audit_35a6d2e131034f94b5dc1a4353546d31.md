# Audit Report

## Title
Missing Miner List Validation in NextTerm Allows Malicious Miner to Monopolize Block Production

## Summary
The `NextTerm` function in the AEDPoS consensus contract accepts arbitrary miner lists without validating them against the Election Contract's `GetVictories()` result. A malicious current miner can submit a term transition with only themselves in the miner list, bypassing continuous block validation and gaining complete control over block production.

## Finding Description

The vulnerability exists in the term transition validation and processing flow where the system fails to verify that the provided miner list matches the legitimately elected miners.

**Validation Gap**: The `ValidationForNextTerm` method only validates that round and term numbers increment correctly and that InValues are null. It does NOT validate that the miner list in `RealTimeMinersInformation` matches the elected miners from the Election Contract's `GetVictories()` method. [1](#0-0) 

The correct flow should retrieve victories from the Election Contract (as demonstrated in the consensus extra data generation): [2](#0-1) 

However, test code shows the expected pattern - calling `GetVictories()` and using that to build the miner list: [3](#0-2) 

**Unvalidated Processing**: The `ProcessNextTerm` method directly extracts the miner list from the input and stores it via `SetMinerList` without any validation: [4](#0-3) 

**SetMinerList Accepts Without Validation**: The `SetMinerList` method only checks if the miner list was already set for the term, performing no content validation: [5](#0-4) 

**Continuous Blocks Bypass**: When `RealTimeMinersInformation.Count == 1`, the continuous blocks validation is completely bypassed: [6](#0-5) 

**Attack Path**: 
1. Attacker is a legitimate current miner
2. During term transition, attacker produces a block with `NextTerm` behavior
3. Attacker crafts consensus extra data with `NextTermInput` containing only their pubkey in `RealTimeMinersInformation`
4. `PreCheck()` passes because attacker is in current miner list: [7](#0-6) 

5. `ValidationForNextTerm` passes (only checks round/term numbers)
6. `ProcessNextTerm` stores the fraudulent single-miner list
7. Subsequent blocks bypass continuous block checks due to count == 1
8. Attacker maintains sole mining authority

## Impact Explanation

**Consensus Integrity Violation**: The attacker gains complete control over block production for an entire term, fundamentally breaking the multi-validator security assumption of the consensus protocol. The system is designed such that the Election Contract determines legitimate miners through voting, but this validation gap allows that mechanism to be completely bypassed.

**Transaction Censorship**: With sole mining authority, the attacker can permanently censor any transactions including governance proposals to fix the issue, election votes to change the miner set, or any other user transactions.

**Economic Damage**: The attacker captures 100% of mining rewards for the entire term while legitimate elected miners receive nothing, directly stealing value from honest validators who won elections through the proper voting process.

**Exclusion of Legitimate Miners**: All honestly elected miners from `GetVictories()` are removed from consensus and cannot produce blocks or earn rewards despite being legitimately elected.

**Persistent Attack**: The attack continues until the next term transition, which the attacker controls. They can repeatedly submit fraudulent `NextTerm` transactions to maintain their monopoly indefinitely.

## Likelihood Explanation

**Reachable Entry Point**: The `NextTerm` method is public and can be called by any current miner during term transition timing: [8](#0-7) 

**Feasible Preconditions**: 
- Attacker must be one of the current miners (realistic - any compromised or malicious validator)
- Attack executes during natural term transition windows
- No special privileges required beyond normal miner status

**Low Attack Complexity**: The attack requires only producing one block with modified consensus extra data. The validation logic has no defense against this.

**No Detection Mechanisms**: The validation providers check mining permission against the base round (current term), time slots, and round/term number increments, but never validate the new miner list against `GetVictories()`.

**Economic Rationality**: Attack cost is minimal (one block production), while benefit is capturing 100% of mining rewards and complete network control.

## Recommendation

Add miner list validation in `ValidationForNextTerm` or `ProcessNextTerm` to verify that the provided miner list matches the Election Contract's `GetVictories()` result:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Validate term number
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };

    // NEW: Validate miner list against Election Contract
    if (State.IsMainChain.Value && State.ElectionContract.Value != null)
    {
        var victories = State.ElectionContract.GetVictories.Call(new Empty());
        var providedMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var expectedMiners = victories.Value.Select(v => v.ToHex()).OrderBy(k => k).ToList();
        
        if (!providedMiners.SequenceEqual(expectedMiners))
            return new ValidationResult { Message = "Miner list does not match Election Contract victories." };
    }

    return new ValidationResult { Success = true };
}
```

Alternatively, add validation in `ProcessNextTerm` before calling `SetMinerList`.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanMonopolizeBlockProduction_ByProvidingFakeMinerList()
{
    // Setup: Initialize chain with multiple miners
    var initialMiners = new[] { InitialCoreDataCenterKeyPairs[0], InitialCoreDataCenterKeyPairs[1], InitialCoreDataCenterKeyPairs[2] };
    await InitializeAElfConsensus();
    
    // Get current round info
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var attackerKeyPair = initialMiners[0];
    var attackerPubkey = attackerKeyPair.PublicKey.ToHex();
    
    // Attacker crafts NextTermInput with ONLY their pubkey (excluding other legitimate miners)
    var maliciousNextTermInput = new NextTermInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber + 1,
        RealTimeMinersInformation = 
        {
            { 
                attackerPubkey, 
                new MinerInRound 
                { 
                    Pubkey = attackerPubkey,
                    Order = 1,
                    IsExtraBlockProducer = true,
                    ExpectedMiningTime = TimestampHelper.GetUtcNow(),
                    ProducedBlocks = 1
                }
            }
        },
        RandomNumber = ByteString.CopyFrom(HashHelper.ComputeFrom("test").ToByteArray())
    };
    
    // Execute malicious NextTerm
    var attacker = GetConsensusContractTester(attackerKeyPair);
    var result = await attacker.NextTerm.SendAsync(maliciousNextTermInput);
    
    // Verify attack succeeded
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Should fail but doesn't
    
    var newRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    newRound.RealTimeMinersInformation.Count.ShouldBe(1); // Only attacker remains
    newRound.RealTimeMinersInformation.Keys.ShouldContain(attackerPubkey);
    newRound.RealTimeMinersInformation.Keys.ShouldNotContain(initialMiners[1].PublicKey.ToHex());
    newRound.RealTimeMinersInformation.Keys.ShouldNotContain(initialMiners[2].PublicKey.ToHex());
    
    // Attacker can now produce unlimited consecutive blocks (continuous blocks check bypassed)
    for (int i = 0; i < 100; i++)
    {
        await ProduceNormalBlock(attackerKeyPair); // Should fail after limit but doesn't
    }
}
```

## Notes

This vulnerability fundamentally breaks the election-based consensus mechanism. The Election Contract's `GetVictories()` method determines legitimate miners through voting, but the NextTerm validation never verifies that the provided miner list matches this authoritative source. This allows any current miner to arbitrarily replace the entire validator set with just themselves, completely subverting the democratic election process and creating a centralized consensus system under attacker control.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-280)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
```

**File:** test/AElf.Contracts.Economic.TestBase/OtherContractsOperation.cs (L17-36)
```csharp
    protected async Task NextTerm(ECKeyPair keyPair)
    {
        var miner = GetConsensusContractTester(keyPair);
        var round = await miner.GetCurrentRoundInformation.CallAsync(new Empty());
        var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
        var miners = new MinerList
        {
            Pubkeys =
            {
                victories.Value
            }
        };
        var randomNumber = await GenerateRandomProofAsync(keyPair);
        var firstRoundOfNextTerm =
            miners.GenerateFirstRoundOfNewTerm(EconomicContractsTestConstants.MiningInterval,
                randomNumber, BlockTimeProvider.GetBlockTime(), round.RoundNumber, round.TermNumber);
        var executionResult = (await miner.NextTerm.SendAsync(firstRoundOfNextTerm)).TransactionResult;
        executionResult.Error.ShouldBeNullOrEmpty();
        executionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-191)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```
