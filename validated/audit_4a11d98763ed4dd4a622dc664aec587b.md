# Audit Report

## Title
Branch Count DoS in Association Contract via Large Organization Member Lists

## Summary
The Association contract contains a critical vulnerability where organizations with large member lists (5,000-10,000+ members) can be created successfully but become permanently non-functional once proposals receive multiple votes. The O(M×N) nested iteration complexity in threshold validation functions causes branch count limit exceptions, resulting in complete governance DoS.

## Finding Description

The vulnerability stems from inefficient threshold validation logic in the `IsReleaseThresholdReached` helper method. [1](#0-0) 

Three critical functions perform nested iterations with O(M×N) complexity where M is the number of organization members and N is the number of votes:

**IsProposalRejected** uses LINQ's `Count()` with a predicate that calls `Contains()` for each rejection, creating nested loops where each rejection iterates through all members to check membership. [2](#0-1) 

**IsProposalAbstained** performs the same pattern for abstentions. [3](#0-2) 

**CheckEnoughVoteAndApprovals** repeats this for approvals. [4](#0-3) 

The `OrganizationMemberList.Contains()` method performs a linear search through the protobuf `RepeatedField<Address>`. [5](#0-4) 

The `organization_members` field is defined as a protobuf repeated field. [6](#0-5) 

Each iteration through these nested loops consumes branch counts tracked by AElf's ExecutionObserver. The branch count threshold is set to 15,000. [7](#0-6) 

When the threshold is exceeded, a `RuntimeBranchThresholdExceededException` is thrown. [8](#0-7) 

**Attack Vector:**

The `GetProposal` view function calls `IsReleaseThresholdReached` to determine if a proposal is ready for release. [9](#0-8) 

The `Release` function also calls `IsReleaseThresholdReached` and asserts it returns true. [10](#0-9) 

With 10,000 organization members and just 2 votes (rejections, abstentions, or approvals), the nested iterations consume 20,000 branch counts (2 × 10,000), exceeding the 15,000 limit and causing transaction failure.

**Why Existing Protections Fail:**

Organization creation validation only checks for duplicates using `AnyDuplicate()` and validates threshold logic, but does not enforce a maximum member list size. [11](#0-10) 

The `AnyDuplicate()` method uses `GroupBy` with O(N) complexity, which does not create the nested iteration problem. [12](#0-11) 

The transaction size limit is 5MB, easily allowing 10,000+ addresses (~320KB for 10,000 addresses). [13](#0-12) 

## Impact Explanation

**HIGH SEVERITY - Complete Governance DoS**

Once triggered, this vulnerability causes:

1. **Permanent GetProposal Failure**: The view function becomes unusable for checking proposal status, breaking all UI/monitoring tools that depend on querying proposal state.

2. **Permanent Release Failure**: Proposals cannot be executed even if approved, completely blocking all governance actions the organization was designed to perform.

3. **Organization Paralysis**: The organization becomes completely non-functional with no recovery mechanism. The only way to fix this would require a contract upgrade, which itself might require governance approval.

**Quantified Impact:**
- 10,000 members + 2 votes = 20,000 branches (33% over the 15,000 limit)
- 7,500 members + 2 votes = 15,000 branches (exactly at limit)
- 5,000 members + 3 votes = 15,000 branches (exactly at limit)

All organization members lose their governance rights, and any protocols depending on the organization for critical operations (treasury management, parameter updates, contract upgrades) are frozen indefinitely.

## Likelihood Explanation

**HIGH LIKELIHOOD**

**Attacker Requirements:**
- Access to the public `CreateOrganization` function (no special permissions required)
- Ability to generate 10,000 addresses (trivial with sequential key generation)
- Minimal transaction fees to create the organization

**Attack Complexity: LOW**

The attack is straightforward:
1. Generate 10,000 addresses
2. Call `CreateOrganization` with a large `OrganizationMemberList` (passes all validation checks)
3. Wait for legitimate proposal activity (2-3 votes from legitimate members)
4. All subsequent `GetProposal` and `Release` calls fail permanently with `RuntimeBranchThresholdExceededException`

**Feasibility Factors:**
- Transaction size easily accommodates 10,000+ addresses within the 5MB limit
- No maximum member list validation exists in the contract
- The attack leverages the organization's own legitimate voting activity
- Difficult to detect during creation since validation passes
- No mitigation path once triggered without a contract upgrade

The vulnerability can occur both maliciously (attacker creates trap organizations to DoS governance) or accidentally (legitimate organizations with genuinely large membership exceeding the safe threshold).

## Recommendation

Implement a maximum member list size validation in the `Validate` method:

**Solution 1: Add Maximum Member Count Check**

Add a constant for the maximum safe member count and validate against it during organization creation. Based on the 15,000 branch limit and accounting for safety margins, a limit of 5,000 members would be safe (allowing up to 3 votes before hitting the limit).

**Solution 2: Optimize Member Validation (Preferred)**

Replace the nested iteration pattern with a more efficient approach. Instead of using `Count(predicate)` which calls `Contains()` for each vote, convert the member list to a `HashSet` once and then use efficient O(1) lookups:

Create a helper method that builds a HashSet from the member list, then iterate through votes checking membership with O(1) lookups instead of O(N) scans. This would reduce the complexity from O(M×N) to O(M+N).

**Solution 3: Cache Membership Checks**

Store organization members in a mapping structure (State.MappedState) rather than a repeated field, enabling O(1) membership lookups without nested iterations.

## Proof of Concept

```csharp
[Fact]
public async Task BranchCountDoS_LargeMemberList_FailsGetProposalAndRelease()
{
    // Create 10,000 member addresses
    var largeMembers = new OrganizationMemberList();
    for (int i = 0; i < 10000; i++)
    {
        largeMembers.OrganizationMembers.Add(Address.FromPublicKey(
            CryptoHelper.GenerateKeyPair().PublicKey));
    }
    
    // Add reviewers as members and proposers
    largeMembers.OrganizationMembers.Add(Reviewer1);
    largeMembers.OrganizationMembers.Add(Reviewer2);
    
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = largeMembers,
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1,
            MinimalVoteThreshold = 1,
            MaximalAbstentionThreshold = 10000,
            MaximalRejectionThreshold = 10000
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { Reviewer1 }
        }
    };
    
    // Create organization - should succeed
    var txResult = await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    txResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var organizationAddress = txResult.Output;
    
    // Create proposal - should succeed
    var proposalId = await CreateProposalAsync(organizationAddress);
    
    // Have 2 members vote - should succeed
    await ApproveWithStub(AssociationContractStub, proposalId);
    var reviewer2Stub = GetAssociationContractTester(Reviewer2KeyPair);
    await ApproveWithStub(reviewer2Stub, proposalId);
    
    // Try to get proposal - should fail with branch threshold exception
    var getProposalResult = await AssociationContractStub.GetProposal.CallWithExceptionAsync(proposalId);
    getProposalResult.TransactionResult.Error.ShouldContain("RuntimeBranchThresholdExceededException");
    
    // Try to release - should also fail with branch threshold exception
    var releaseResult = await AssociationContractStub.Release.SendWithExceptionAsync(proposalId);
    releaseResult.TransactionResult.Error.ShouldContain("RuntimeBranchThresholdExceededException");
}
```

## Notes

This vulnerability demonstrates a critical availability failure where the contract's design allows the creation of organizations that are fundamentally non-functional once any voting occurs. The mathematical certainty of the DoS (10,000 members × 2 votes = 20,000 branches > 15,000 limit) makes this a deterministic failure rather than an edge case.

The issue is particularly severe because:
1. It affects core governance functionality
2. There is no recovery mechanism without a contract upgrade
3. It can be triggered with minimal resources
4. The public nature of `CreateOrganization` means anyone can create such organizations

The recommended fix should implement both maximum member validation and optimize the iteration pattern to prevent both accidental and malicious exploitation of this vulnerability.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```

**File:** protobuf/association_contract.proto (L105-108)
```text
message OrganizationMemberList {
    // The address of organization members.
    repeated aelf.Address organization_members = 1;
}
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L29-36)
```csharp
    public void BranchCount()
    {
        if (_branchThreshold != -1 && _branchCount == _branchThreshold)
            throw new RuntimeBranchThresholdExceededException(
                $"Contract branch threshold {_branchThreshold} exceeded.");

        _branchCount++;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L18-42)
```csharp
    public override ProposalOutput GetProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        if (proposal == null) return new ProposalOutput();

        var organization = State.Organizations[proposal.OrganizationAddress];
        var readyToRelease = IsReleaseThresholdReached(proposal, organization);

        return new ProposalOutput
        {
            ProposalId = proposalId,
            ContractMethodName = proposal.ContractMethodName,
            ExpiredTime = proposal.ExpiredTime,
            OrganizationAddress = proposal.OrganizationAddress,
            Params = proposal.Params,
            Proposer = proposal.Proposer,
            ToAddress = proposal.ToAddress,
            ToBeReleased = readyToRelease,
            ApprovalCount = proposal.Approvals.Count,
            RejectionCount = proposal.Rejections.Count,
            AbstentionCount = proposal.Abstentions.Count,
            Title = proposal.Title,
            Description = proposal.Description
        };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Extensions.cs (L24-27)
```csharp
    public static bool AnyDuplicate(this OrganizationMemberList organizationMemberList)
    {
        return organizationMemberList.OrganizationMembers.GroupBy(m => m).Any(g => g.Count() > 1);
    }
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L5-5)
```csharp
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
```
