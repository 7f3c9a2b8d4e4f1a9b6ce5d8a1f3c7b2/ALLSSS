# Audit Report

## Title
Cross-Chain NFT Type Synchronization DOS - Custom NFT Types Cause CrossChainCreate Failure

## Summary
Custom NFT types added via `AddNFTType` on one chain are stored in chain-local state and are not automatically synchronized to other chains. When `CrossChainCreate` attempts to create an NFT protocol on a destination chain using a custom type, it fails because the type mapping doesn't exist, creating a systematic DOS condition that requires manual parliament intervention on each chain.

## Finding Description

The NFT contract stores NFT type mappings in chain-local state variables `NFTTypeShortNameMap` and `NFTTypeFullNameMap`. [1](#0-0) 

When `InitialNFTTypeNameMap()` is called, it only initializes 10 predefined NFT types (XX, AR, MU, DN, VW, TC, CO, SP, UT, BA) and returns early if already initialized. [2](#0-1) 

Parliament can add custom NFT types via `AddNFTType`, which stores them in the chain-local state maps. [3](#0-2) 

The vulnerability manifests in `CrossChainCreate` when it attempts to create an NFT protocol on a sidechain. The function calls `InitialNFTTypeNameMap()` to populate default types, then extracts the 2-character type short name from the symbol and looks it up in `State.NFTTypeFullNameMap`. If the custom type doesn't exist on the destination chain, the function throws an exception, completely blocking the protocol creation. [4](#0-3) 

The root cause is that `CrossChainCreateToken` in the MultiToken contract only syncs token information (symbol, name, supply, decimals, issuer, external info) but does NOT sync the NFT type mappings from the NFT contract's separate state. [5](#0-4) 

**Attack Path:**
1. MainChain: Parliament adds custom type "GG" â†’ "Gaming" via `AddNFTType` (stored in mainchain NFT contract state)
2. MainChain: NFT protocol created with symbol "GG123456" 
3. MainChain: `CrossChainCreateToken` syncs token info to SideChain (but NOT the NFT type mapping)
4. SideChain: `CrossChainCreate("GG123456")` is called
5. SideChain: `InitialNFTTypeNameMap()` only populates 10 default types
6. SideChain: Lookup of "GG" in `State.NFTTypeFullNameMap` returns null
7. Transaction fails with "Full name of GG not found. Use AddNFTType to add this new pair."

## Impact Explanation

This vulnerability creates a **High-severity operational DOS** affecting cross-chain NFT functionality:

1. **Protocol Availability DOS**: NFT protocols using custom types cannot be created on sidechains, blocking legitimate cross-chain operations and preventing users from accessing their NFT assets across chains.

2. **Governance Coordination Burden**: Resolution requires parliament proposals on EVERY destination chain to manually add each custom type via `AddNFTType`, introducing significant delays and coordination overhead.

3. **Systematic Failure**: This is not an edge case but a fundamental design gap - ANY use of custom NFT types will trigger this DOS across ALL chains that haven't manually synchronized the type mappings.

4. **Potential Permanent Unavailability**: If a sidechain's parliament is inactive or uncooperative, NFT protocols remain permanently inaccessible on that chain.

The impact is concrete and measurable: cross-chain NFT protocol creation fails with a hard revert, completely blocking the intended functionality.

## Likelihood Explanation

**Likelihood: High**

This is not a theoretical vulnerability requiring malicious actors - it manifests during normal, legitimate protocol operations:

1. **No Attack Required**: The issue occurs when parliament performs its expected governance function (adding custom NFT types) and users attempt standard cross-chain operations.

2. **Minimal Preconditions**: 
   - Custom NFT type feature exists and is documented (`AddNFTType` function)
   - Cross-chain protocol synchronization is a core use case
   - No automatic synchronization mechanism exists

3. **Immediate Trigger**: The DOS activates the moment someone attempts to call `CrossChainCreate` for any NFT protocol using a custom type that hasn't been manually added to the destination chain.

4. **Reproducible**: The execution path is deterministic and will fail consistently for all NFT protocols using non-default types until manual synchronization occurs.

The probability is effectively 100% once a custom NFT type is used, making this a guaranteed operational failure rather than a probabilistic attack.

## Recommendation

Implement an automatic NFT type synchronization mechanism as part of the cross-chain token creation flow:

**Option 1**: Include NFT type mappings in the token's `ExternalInfo` during `CrossChainCreateToken`, then extract and register them automatically in `CrossChainCreate`.

**Option 2**: Add a separate cross-chain message type for synchronizing NFT type mappings that can be called before or during protocol creation.

**Option 3**: Modify `CrossChainCreate` to gracefully handle missing types by either:
- Extracting the type from token's `ExternalInfo` if available
- Allowing the protocol to be created with a placeholder type that can be updated later
- Providing a batched sync operation for multiple type mappings

**Immediate Mitigation**: Document the requirement that custom NFT types must be manually added to all destination chains via `AddNFTType` before attempting cross-chain protocol synchronization. However, this is only a workaround and doesn't address the systematic design issue.

## Proof of Concept

This vulnerability can be demonstrated with the following test scenario:

1. On MainChain: Call `AddNFTType` with input `{ShortName: "GG", FullName: "Gaming"}`
2. On MainChain: Call `Create` to create NFT protocol with `NftType: "Gaming"`, resulting in symbol "GG123456"
3. On MainChain: Call `CrossChainCreateToken` to sync the token to SideChain
4. On SideChain: Call `CrossChainCreate` with input `{Symbol: "GG123456"}`
5. Expected Result: Transaction fails at line 91-93 of `CrossChainCreate` with error "Full name of GG not found. Use AddNFTType to add this new pair."

The test would verify that the transaction reverts with the expected error message, confirming that custom NFT types block cross-chain protocol creation.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L35-36)
```csharp
    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-63)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;

        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }

        return nftTypes;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-93)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L131-150)
```csharp
    public override Empty AddNFTType(AddNFTTypeInput input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        var fullName = input.FullName;
        Assert(input.ShortName.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
        Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
        State.NFTTypeFullNameMap[input.ShortName] = fullName;
        State.NFTTypeShortNameMap[fullName] = input.ShortName;
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Add(input.ShortName, fullName);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeAdded
        {
            ShortName = input.ShortName,
            FullName = input.FullName
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-503)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };
```
