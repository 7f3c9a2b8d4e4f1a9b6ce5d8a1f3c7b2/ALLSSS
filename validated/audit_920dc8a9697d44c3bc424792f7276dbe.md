# Audit Report

## Title
Initial Miners Can Bypass Election Announcement Check via ReplaceCandidatePubkey to Gain Double Subsidies

## Summary
The `ReplaceCandidatePubkey` method in the Election contract contains insufficient validation that allows initial miners to bypass the restriction preventing them from announcing election. By replacing a regular candidate's pubkey with an initial miner's pubkey, the initial miner becomes simultaneously present in both the `Candidates` and `InitialMiners` lists, enabling them to receive both mining rewards and backup subsidy - violating the economic model's separation of reward streams.

## Finding Description

The vulnerability exists due to asymmetric validation logic in `ReplaceCandidatePubkey`. While initial miners are explicitly blocked from directly announcing election [1](#0-0) , this protection is bypassed through pubkey replacement.

The method only validates that the new pubkey isn't already in `Candidates` [2](#0-1) , but fails to check if it's an initial miner.

When replacing a regular candidate's pubkey with an initial miner's pubkey, the code removes the old pubkey from `Candidates` and adds the new pubkey (initial miner) [3](#0-2) . However, the code only modifies `InitialMiners` if the OLD pubkey was in that list [4](#0-3) .

Since the old pubkey (regular candidate) is not in `InitialMiners`, this block is skipped, and the new initial miner pubkey remains in `InitialMiners` from initialization. Meanwhile, backup subsidy beneficiary registration is transferred to the new pubkey [5](#0-4) .

**Result**: The initial miner's pubkey now exists in both `Candidates` (receiving backup subsidy) and `InitialMiners` (eligible for mining), violating the design invariant.

Initial miners can mine when used as fallback validators [6](#0-5)  and receive mining rewards distributed by the Treasury [7](#0-6) . Additionally, candidates in the `DataCentersRankingList` receive backup subsidy [8](#0-7)  with no exclusion logic for active miners. There is no mechanism to remove backup subsidy beneficiaries when they become active miners, enabling the double subsidy extraction.

## Impact Explanation

**Direct Fund Misallocation**: Initial miners gain access to two reward streams simultaneously:

1. **Mining Rewards**: As members of `InitialMiners`, they serve as fallback validators and receive their proportional share of mining rewards (basic reward based on blocks produced, flexible reward)
2. **Backup Subsidy**: As registered beneficiaries in the backup subsidy scheme, they receive shares of the 5% backup subsidy allocation [9](#0-8) 

The Treasury distributes backup subsidy to all candidates in the `DataCentersRankingList` without excluding active miners. When an initial miner both mines AND is registered for backup subsidy, they receive rewards from both pools.

**Affected Parties**:
- Legitimate candidates lose their fair share of backup subsidy as it's diluted by initial miners who shouldn't be eligible
- The economic model is fundamentally broken as initial miners were designed to only receive mining rewards, not election subsidies
- Treasury resources are continuously misallocated over multiple terms

This represents a HIGH severity issue as it enables persistent extraction of unintended rewards, violating core economic design principles.

## Likelihood Explanation

**Entry Point**: `ReplaceCandidatePubkey` is a public method callable by any candidate admin [10](#0-9) .

**Feasible Preconditions**:
- Attacker needs an initial miner pubkey (public information from chain state)
- Attacker announces election with a regular pubkey and sets themselves as admin [11](#0-10) 
- Requires locking tokens but this is recoverable upon quitting

**Execution Steps**:
1. Call `AnnounceElection` with regular pubkey A, setting attacker's address as admin
2. Optionally call `SetProfitsReceiver` to direct rewards to attacker's address
3. Call `ReplaceCandidatePubkey(oldPubkey=A, newPubkey=B)` where B is an initial miner pubkey
4. Initial miner B is now in both lists and registered for backup subsidy

**Attack Complexity**: LOW - Two straightforward contract calls with no timing dependencies or complex state manipulation. All validation checks incorrectly pass due to the missing `InitialMiners` check.

**Economic Rationality**: The cost is temporary token lock (recoverable), while the gain is continuous dual subsidy extraction over multiple terms, making this highly profitable.

The likelihood is MEDIUM-HIGH as the attack is technically simple, requires no special privileges beyond being a candidate admin, and the preconditions are easily satisfiable.

## Recommendation

Add validation in `ReplaceCandidatePubkey` to prevent initial miners from being set as the new pubkey:

```csharp
var initialMiners = State.InitialMiners.Value;
Assert(!initialMiners.Value.Contains(newPubkeyBytes), 
       "New pubkey cannot be an initial miner.");
```

This check should be placed immediately after the existing validation at line 191 that checks if the new pubkey is already a candidate.

## Proof of Concept

```csharp
[Fact]
public async Task ReplaceCandidatePubkey_WithInitialMiner_AllowsDoubleSubsidy()
{
    // Setup: Get initial miner pubkey from chain state
    var initialMiners = await ElectionContractStub.GetInitialMiners.CallAsync(new Empty());
    var initialMinerPubkey = initialMiners.Value.First().ToHex();
    
    // Step 1: Announce election with regular candidate
    var regularCandidateKeyPair = ValidationDataCenterKeyPairs.First();
    var attackerAddress = Address.FromPublicKey(regularCandidateKeyPair.PublicKey);
    await AnnounceElectionAsync(regularCandidateKeyPair, attackerAddress);
    
    // Step 2: Replace regular candidate with initial miner pubkey
    var attackerStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, regularCandidateKeyPair);
    await attackerStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = regularCandidateKeyPair.PublicKey.ToHex(),
        NewPubkey = initialMinerPubkey
    });
    
    // Verify: Initial miner is now in both Candidates and InitialMiners
    var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
    var initialMinersAfter = await ElectionContractStub.GetInitialMiners.CallAsync(new Empty());
    
    var initialMinerBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(initialMinerPubkey));
    candidates.Value.ShouldContain(initialMinerBytes); // In Candidates - receives backup subsidy
    initialMinersAfter.Value.ShouldContain(initialMinerBytes); // In InitialMiners - can mine
    
    // This state allows double subsidy extraction
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-118)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L149-150)
```csharp
        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-173)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L191-191)
```csharp
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L192-197)
```csharp
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L199-218)
```csharp
        var rankingList = State.DataCentersRankingList.Value;
        //the profit receiver is not exist but candidate in the data center ranking list
        if (rankingList.DataCenters.ContainsKey(input.OldPubkey))
        {
            rankingList.DataCenters.Add(input.NewPubkey, rankingList.DataCenters[input.OldPubkey]);
            rankingList.DataCenters.Remove(input.OldPubkey);
            State.DataCentersRankingList.Value = rankingList;

            // Notify Profit Contract to update backup subsidy profiting item.
            if (State.ProfitContract.Value == null)
                State.ProfitContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            
            var oldProfitReceiver = GetProfitsReceiverOrDefault(input.OldPubkey);
            var profitReceiver = oldProfitReceiver.Value.Any()
                ? oldProfitReceiver
                : null;
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L383-392)
```csharp
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L470-478)
```csharp
    private DividendPoolWeightSetting GetDefaultDividendPoolWeightSetting()
    {
        return new DividendPoolWeightSetting
        {
            CitizenWelfareWeight = 15,
            BackupSubsidyWeight = 1,
            MinerRewardWeight = 4
        };
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L777-821)
```csharp
    private void UpdateBasicMinerRewardWeights(IReadOnlyCollection<Round> previousTermInformation)
    {
        if (previousTermInformation.First().RealTimeMinersInformation != null)
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });

        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L781-795)
```csharp
    private void AddBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var subsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = beneficiaryAddress,
                Shares = 1,
            },
            ProfitDetailId = subsidyId
        });
    }
```
