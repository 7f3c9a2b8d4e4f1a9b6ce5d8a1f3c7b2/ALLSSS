# Audit Report

## Title
Missing Validation of Term Transition State Allows Arbitrary Miner List Manipulation

## Summary
The `ProcessNextTerm` method converts `NextTermInput` to a `Round` object and directly commits the miner list to state without validating that it matches the legitimate output from `GenerateFirstRoundOfNextTerm`. A malicious block producer can modify the consensus extra data to inject arbitrary miners, completely bypassing the election system on mainchain or perpetuating control on sidechains.

## Finding Description

The vulnerability exists in the term transition logic where miner lists for the next term are established. The legitimate flow requires calling `GenerateFirstRoundOfNextTerm` which derives miners from election victories (mainchain) or current miners (sidechain). [1](#0-0) 

However, when processing the term transition, `ProcessNextTerm` simply converts the submitted `NextTermInput` to a `Round` via `ToRound()` without any validation of the miner list content. [2](#0-1) 

The `ToRound()` method is a simple data structure conversion with no validation logic. [3](#0-2) 

The pre-execution validation only checks that round and term numbers increment correctly and that InValues are null - it does NOT validate the actual miner list content. [4](#0-3) 

The unvalidated `nextRound.RealTimeMinersInformation` is then directly used to create and commit the miner list for the new term. [5](#0-4) 

While the `AEDPoSExtraDataExtractor` validates that `SenderPubkey` matches the block signer, this only ensures the submitter is the actual block producer - it doesn't prevent them from modifying the Round data. [6](#0-5) 

**Attack Flow:**
1. Malicious miner's node calls `GetConsensusExtraDataForNextTerm` to generate legitimate consensus data [7](#0-6) 

2. Attacker intercepts and modifies the `Round.RealTimeMinersInformation` to add/remove/reorder miners
3. Creates `NextTermInput` from modified Round [8](#0-7) 

4. Signs block with their valid key and includes the modified consensus data
5. Validation passes because only structural checks are performed [9](#0-8) 

6. Modified miner list is committed to state [10](#0-9) 

## Impact Explanation

**Consensus Integrity Compromise (CRITICAL)**: This vulnerability completely breaks the fundamental security property that miners are selected through the election system on mainchain or maintained consistently on sidechains.

On **mainchain**, this bypasses the entire election mechanism where token holders vote for block producers. The attacker can ignore election results and inject arbitrary miners. [11](#0-10) 

On **sidechains**, miners can self-perpetuate or exclude competitors arbitrarily, as the code falls back to using current miners when no election exists. [12](#0-11) 

**Concrete Harm:**
- **Election Bypass**: Democratically elected miners are excluded while colluding nodes are included
- **Consensus Capture**: Attacker gains control over block production for an entire term
- **Schedule Manipulation**: Favorable mining time slots assigned to attacker's nodes via order manipulation [13](#0-12) 
- **Reward Misdirection**: Mining rewards flow to unauthorized nodes
- **Chain Disruption**: Invalid miner configurations can cause consensus failures

This affects all network participants as consensus security is foundational to the entire blockchain system.

## Likelihood Explanation

**Attacker Requirements:**
- Must be a current block producer (member of active miner list)
- Must produce the term transition block (occurs once per term, typically every few days/weeks)

**Attack Complexity:** LOW - The attack is straightforward:
1. Generate legitimate consensus data via contract call
2. Parse and modify the protobuf structure at the node level
3. Sign block with own key (which is valid)
4. Submit modified data

**Feasibility:** HIGH
- No special privileges required beyond being a current miner
- The miner is authorized to produce blocks and sign consensus data
- Validation only checks incremental numbers, not miner list correctness
- The block signature remains valid because the attacker is the legitimate signer
- The after-execution validation compares submitted data against just-committed data (circular check) [14](#0-13) 

**Detection Difficulty:** HIGH - The modified miner list appears legitimate in committed state. There's no on-chain record of what the "correct" list should have been, making it difficult for nodes to detect the manipulation after the fact.

**Probability:** MEDIUM-HIGH - Any compromised or colluding miner can execute this attack when they have the opportunity to produce the term transition block.

## Recommendation

Add validation in `ProcessNextTerm` to verify the submitted miner list matches what `GenerateFirstRoundOfNextTerm` would produce:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // ADDED: Validate the submitted miner list matches expected
    var expectedRound = GenerateFirstRoundOfNextTerm(
        Context.RecoverPublicKey().ToHex(), 
        State.MiningInterval.Value
    );
    
    var expectedMiners = expectedRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    var submittedMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    
    Assert(
        expectedMiners.Count == submittedMiners.Count &&
        expectedMiners.SequenceEqual(submittedMiners),
        "Submitted miner list does not match election results or current miners"
    );
    
    // Rest of existing logic...
    RecordMinedMinerListOfCurrentRound();
    // ...
}
```

Alternatively, add a validation provider in `ValidateBeforeExecution` that checks the miner list against election results on mainchain or current miners on sidechain before allowing term transitions.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMinerCanManipulateMinerListDuringTermTransition()
{
    // Setup: Initialize chain with election and current miners
    await InitializeConsensus();
    await AdvanceToTermEnd();
    
    // Attacker is current miner
    var attackerKeyPair = InitialMinersKeyPairs[0];
    
    // Generate legitimate next term data
    var legitimateExtraData = await ConsensusStub.GetConsensusExtraData.CallAsync(
        new BytesValue { Value = /* trigger info */ }
    );
    var headerInfo = AElfConsensusHeaderInformation.Parser.ParseFrom(legitimateExtraData.Value);
    
    // Malicious modification: Add attacker's second key as miner, remove legitimate winner
    var maliciousRound = headerInfo.Round;
    var legitimateWinner = maliciousRound.RealTimeMinersInformation.Keys.First();
    maliciousRound.RealTimeMinersInformation.Remove(legitimateWinner);
    maliciousRound.RealTimeMinersInformation.Add(
        attackerSecondKeyPair.PublicKey.ToHex(),
        new MinerInRound { /* attacker's node */ }
    );
    
    // Create malicious NextTermInput
    var maliciousInput = NextTermInput.Create(maliciousRound, randomNumber);
    
    // Submit via NextTerm - should fail but currently succeeds
    var result = await ConsensusStub.NextTerm.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Malicious miner list was committed
    var newMinerList = await ConsensusStub.GetCurrentMinerList.CallAsync(new Empty());
    newMinerList.Pubkeys.ShouldContain(
        ByteStringHelper.FromHexString(attackerSecondKeyPair.PublicKey.ToHex())
    );
    newMinerList.Pubkeys.ShouldNotContain(
        ByteStringHelper.FromHexString(legitimateWinner)
    );
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-163)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-46)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L21-33)
```csharp
    public ByteString ExtractConsensusExtraData(BlockHeader header)
    {
        var consensusExtraData =
            _blockExtraDataService.GetExtraDataFromBlockHeader(_consensusExtraDataProvider.BlockHeaderExtraDataKey,
                header);
        if (consensusExtraData == null)
            return null;

        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-92)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```
