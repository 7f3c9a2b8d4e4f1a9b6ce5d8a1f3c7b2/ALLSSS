# Audit Report

## Title
Insufficient Address Validation in Governance Contracts Enables Griefing Attack via Unexecutable Proposals

## Summary
The Association, Parliament, and Referendum governance contracts fail to properly validate the `ToAddress` field of proposals. The validation only checks if the Address object reference is null but does not verify that the internal `Value` byte array is non-empty. This allows whitelisted proposers to create proposals with empty addresses that pass validation but fail during execution, causing approved proposals to become stuck in storage until expiry.

## Finding Description

All three governance contracts use an insufficient validation pattern that checks only the Address object reference, not the internal `Value` property:

**Association Contract** validates proposals by checking only if the address object is null, without validating the byte content: [1](#0-0) 

**Parliament Contract** uses the same insufficient pattern: [2](#0-1) 

**Referendum Contract** also lacks proper validation: [3](#0-2) 

The proper validation pattern used elsewhere in the codebase checks both the object reference AND the internal Value: [4](#0-3) 

Since the Address protobuf message allows an empty `bytes value` field, an attacker can create a valid Address object with `Value.IsNullOrEmpty() == true` that passes the insufficient validation. [5](#0-4) 

When such a proposal reaches the Release stage, the inline transaction is created with the empty address: [6](#0-5) 

The `SendVirtualInlineBySystemContract` method adds the transaction without immediate validation: [7](#0-6) 

During inline transaction execution, the empty address triggers a `SmartContractFindRegistrationException`: [8](#0-7) 

When an inline transaction fails, the parent transaction's state changes are reverted - only pre/post traces are committed: [9](#0-8) 

This means the proposal removal operation never gets committed, leaving the proposal permanently stuck in storage until expiry. The attack breaks the governance execution invariant that approved proposals should be executable.

## Impact Explanation

This vulnerability creates a **governance denial-of-service** attack vector with the following impacts:

1. **Wasted Organizational Resources**: Members spend time and voting power reviewing and approving proposals that can never execute
2. **Governance Disruption**: Critical governance decisions cannot be implemented despite proper approval
3. **Storage Waste**: Malicious proposals occupy contract storage until expiry
4. **Trust Erosion**: Repeated failures undermine confidence in the governance system
5. **Systematic Exploitation**: Any whitelisted proposer can create multiple such proposals

While proposals can eventually be cleared after expiry using `ClearProposal`, the temporary DoS and wasted organizational effort constitute significant operational disruption to governance processes. [10](#0-9) 

The severity is **Medium** because while it doesn't directly steal funds or break cryptographic invariants, it significantly disrupts critical governance operations and can be systematically exploited.

## Likelihood Explanation

The attack is highly feasible:

1. **Attacker Profile**: Any whitelisted proposer can execute this. In multi-organization ecosystems, whitelist membership is a realistic attacker role
2. **Technical Complexity**: Trivial - simply create a `CreateProposalInput` with an Address object containing empty Value bytes
3. **Preconditions**: Only requires being a whitelisted proposer - no additional conditions
4. **Detection Difficulty**: The malicious proposal passes validation at both creation and release stages, making it hard to detect before execution fails
5. **Execution Cost**: Only requires standard transaction fees

The existing tests confirm that validation only catches `ToAddress = null` (object reference null) but not an Address with empty Value: [11](#0-10) 

The likelihood is **Medium** due to the realistic attacker profile and trivial execution complexity.

## Recommendation

Update the validation logic in all three governance contracts to check both the Address object reference and the internal Value:

```csharp
private bool Validate(ProposalInfo proposal)
{
    if (proposal.ToAddress == null || proposal.ToAddress.Value.IsNullOrEmpty() || 
        string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
        !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
        return false;

    return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
}
```

This pattern matches the robust validation used elsewhere in the codebase for address validation.

## Proof of Concept

```csharp
[Fact]
public async Task CreateProposal_WithEmptyAddressValue_ShouldFail()
{
    // Setup: Create organization with whitelisted proposer
    var organizationAddress = await CreateOrganizationAsync(
        minimalApproveThreshold: 1, 
        minimalVoteThreshold: 1,
        maximalAbstentionThreshold: 0, 
        maximalRejectionThreshold: 0, 
        Reviewer1);
    
    var associationStub = GetAssociationContractTester(Reviewer1KeyPair);
    
    // Attack: Create proposal with Address object that has empty Value
    var maliciousProposal = new CreateProposalInput
    {
        ContractMethodName = "SomeMethod",
        ToAddress = new Address(), // Empty Value - bypasses validation
        Params = ByteString.Empty,
        OrganizationAddress = organizationAddress,
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(1)
    };
    
    // Verify: Proposal creation succeeds (vulnerable!)
    var proposalId = await associationStub.CreateProposal.SendAsync(maliciousProposal);
    proposalId.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Approve the proposal
    await associationStub.Approve.SendAsync(proposalId.Output);
    
    // Attempt to release - this will fail but leave proposal stuck
    var releaseResult = await associationStub.Release.SendWithExceptionAsync(proposalId.Output);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Invalid contract address");
    
    // Verify: Proposal is still in storage (stuck)
    var proposal = await associationStub.GetProposal.CallAsync(proposalId.Output);
    proposal.ProposalId.ShouldBe(proposalId.Output);
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L157-166)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = CheckProposalNotExpired(proposal);
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L397-399)
```csharp
        Assert(contractOperation.Deployer != null && !contractOperation.Deployer.Value.IsNullOrEmpty(),
            "Invalid input deploying address.");
        Assert(contractOperation.Salt != null && !contractOperation.Salt.Value.IsNullOrEmpty(), "Invalid input salt.");
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L266-276)
```csharp
    public void SendVirtualInlineBySystemContract(Hash fromVirtualAddress, Address toAddress, string methodName,
        ByteString args)
    {
        TransactionContext.Trace.InlineTransactions.Add(new Transaction
        {
            From = ConvertVirtualAddressToContractAddressWithContractHashName(fromVirtualAddress, Self),
            To = toAddress,
            MethodName = methodName,
            Params = args
        });
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L105-126)
```csharp
    private static bool TryUpdateStateCache(TransactionTrace trace, TieredStateCache groupStateCache)
    {
        if (trace == null)
            return false;

        if (!trace.IsSuccessful())
        {
            var transactionExecutingStateSets = new List<TransactionExecutingStateSet>();

            AddToTransactionStateSets(transactionExecutingStateSets, trace.PreTraces);
            AddToTransactionStateSets(transactionExecutingStateSets, trace.PostTraces);

            groupStateCache.Update(transactionExecutingStateSets);
            trace.SurfaceUpError();
        }
        else
        {
            groupStateCache.Update(trace.GetStateSets());
        }

        return true;
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L150-161)
```csharp
        try
        {
            executive = await _smartContractExecutiveService.GetExecutiveAsync(
                internalChainContext,
                singleTxExecutingDto.Transaction.To);
        }
        catch (SmartContractFindRegistrationException)
        {
            txContext.Trace.ExecutionStatus = ExecutionStatus.ContractError;
            txContext.Trace.Error += "Invalid contract address.\n";
            return trace;
        }
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L356-365)
```csharp
        //ToAddress is null
        {
            createProposalInput.ContractMethodName = "Test";
            createProposalInput.ToAddress = null;

            var transactionResult =
                await associationContractStub.CreateProposal.SendWithExceptionAsync(createProposalInput);
            transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
            transactionResult.TransactionResult.Error.Contains("Invalid proposal.").ShouldBeTrue();
        }
```
