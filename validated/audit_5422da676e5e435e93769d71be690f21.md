# Audit Report

## Title
Inconsistent Vote Counting Allows Governance Manipulation Through Member Removal

## Summary
The Association contract contains a critical vote counting inconsistency where approval, rejection, and abstention counts are filtered by current membership, but total vote count includes all historical votes. This enables organizations to retroactively convert rejected proposals into releasable proposals by removing dissenting members, fundamentally undermining governance integrity.

## Finding Description

The vulnerability exists in the threshold validation logic within `CheckEnoughVoteAndApprovals` method. The contract enforces governance thresholds inconsistently when determining if a proposal can be released.

**The Critical Inconsistency:**

When checking individual vote categories, the contract correctly filters by current membership:
- Approvals are filtered [1](#0-0) 
- Rejections are filtered [2](#0-1) 
- Abstentions are filtered [3](#0-2) 

However, when checking the total vote count for the minimal vote threshold, the contract counts ALL historical votes WITHOUT filtering by current membership [4](#0-3) 

**The Exploitation Mechanism:**

The `RemoveMember` function removes addresses from the organization's member list but does NOT clear their historical votes from existing proposals [5](#0-4) 

This creates an exploitable state transition where:
1. A proposal is initially rejected because filtered rejection count exceeds the maximal rejection threshold [6](#0-5) 
2. Organization removes dissenting members via a separate proposal
3. The same proposal is rechecked: filtered rejection count drops below threshold, but unfiltered total vote count remains unchanged
4. The previously rejected proposal now passes all threshold checks and becomes releasable [7](#0-6) 

The release mechanism enforces this flawed logic during proposal execution [8](#0-7) 

## Impact Explanation

**Critical Governance Integrity Violation:**

This vulnerability breaks the fundamental democratic guarantee that a properly rejected proposal remains rejected. Organizations can manipulate governance outcomes through:

1. **Retroactive Legitimization**: Converting legitimately rejected proposals into executable actions
2. **Threshold Circumvention**: Bypassing maximal rejection thresholds designed to protect minority rights  
3. **Consensus Invalidation**: Executing proposals that failed to achieve required democratic consensus

**Concrete Attack Scenario:**
- Organization: 10 members (A-J)
- Thresholds: `minimal_approval=4`, `maximal_rejection=3`, `minimal_vote=7`
- Proposal P1: 4 approve (A,B,C,D), 4 reject (E,F,G,H), 0 abstain
- Initial status: filtered rejections=4 > 3 threshold → **REJECTED**
- Action: Pass proposal P2 to remove members E and F
- After removal: 
  - Filtered approvals=4 (A,B,C,D still members) ≥ 4 ✓
  - Filtered rejections=2 (only G,H still members) ≤ 3 ✓
  - **Unfiltered** total votes=8 (all historical votes preserved) ≥ 7 ✓
- Result: Previously rejected proposal P1 is now **RELEASABLE**

The severity is Critical because it undermines the core governance mechanism that organizations rely on for decentralized decision-making, enabling unauthorized execution of rejected proposals.

## Likelihood Explanation

**High Likelihood:**

**Attack Feasibility:** The attack uses only standard, legitimate contract functions accessible through normal governance operations. No special privileges beyond standard proposal approval are required.

**Realistic Scenarios:**

1. **Deliberate Manipulation**: A majority coalition can intentionally manipulate governance by strategically removing opposition members after a proposal fails
2. **Accidental Exploitation**: Organizations naturally remove inactive or malicious members for legitimate reasons, unintentionally causing old rejected proposals to become valid  
3. **Systematic Abuse**: Attackers can systematically bypass rejection thresholds across multiple proposals

**Detection Difficulty:** The behavior appears as normal governance operations (member removal followed by proposal release) with no explicit indicators of exploitation, making it difficult to detect or prevent without careful analysis of proposal history.

## Recommendation

Fix the inconsistency by filtering the total vote count by current membership, consistent with how individual vote categories are handled. Modify the `CheckEnoughVoteAndApprovals` method:

**Current (vulnerable) implementation:**
```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**Recommended fix:**
```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
        .Count(organization.OrganizationMemberList.Contains) >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

This ensures all threshold checks consistently filter by current membership, preventing retroactive manipulation through member removal. Note that the Parliament contract already implements this pattern correctly [9](#0-8) 

## Proof of Concept

```csharp
[Fact]
public async Task VoteCountingInconsistency_RejectedProposalBecomesReleasableAfterMemberRemoval()
{
    // Setup: Create organization with 10 members and thresholds
    var members = Enumerable.Range(0, 10).Select(_ => SampleAddress.AddressList[_]).ToList();
    var organization = await CreateOrganizationAsync(
        minimalApproval: 4,
        maximalRejection: 3,
        minimalVote: 7,
        members: members
    );
    
    // Step 1: Create proposal and collect votes that cause rejection
    var proposalId = await CreateProposalAsync(organization);
    
    // 4 approvals (members 0-3)
    for (int i = 0; i < 4; i++)
        await ApproveAsAsync(members[i], proposalId);
    
    // 4 rejections (members 4-7) - exceeds maximal_rejection=3
    for (int i = 4; i < 8; i++)
        await RejectAsAsync(members[i], proposalId);
    
    // Verify proposal is rejected (4 rejections > 3 threshold)
    var proposal1 = await GetProposalAsync(proposalId);
    Assert.False(proposal1.ToBeReleased); // Should be rejected
    
    // Step 2: Remove 2 dissenting members (members 4 and 5)
    await RemoveMemberAsync(organization, members[4]);
    await RemoveMemberAsync(organization, members[5]);
    
    // Step 3: Check same proposal again
    var proposal2 = await GetProposalAsync(proposalId);
    
    // Vulnerability: Proposal that was rejected is now releasable!
    // - Filtered rejections = 2 (only members 6,7 still in org) <= 3 ✓
    // - Filtered approvals = 4 (members 0-3 still in org) >= 4 ✓  
    // - UNFILTERED total votes = 8 (all historical votes) >= 7 ✓
    Assert.True(proposal2.ToBeReleased); // EXPLOITED: Previously rejected proposal is now releasable
    
    // Step 4: Confirm exploitation by successfully releasing
    await ReleaseProposalAsync(proposalId);
    // Proposal executes despite having been legitimately rejected
}
```

**Notes:**

This vulnerability demonstrates a fundamental flaw in the Association contract's governance logic where the filtering strategy is inconsistent between individual vote category checks and total vote count checks. The Parliament contract avoids this issue by consistently filtering all vote counts by current membership. Organizations using the Association contract are at risk of governance manipulation through strategic member removal, undermining the integrity of their decision-making processes.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L97-100)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
                .Count(parliamentMembers.Contains) * AbstractVoteTotal >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold * parliamentMembers.Count;
```
