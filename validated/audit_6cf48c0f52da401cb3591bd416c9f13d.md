# Audit Report

## Title
NFT Contract Spam Prevention Failure - Broken ACS1 Implementation Allows Near-Zero-Cost State Bloat Attack

## Summary
The NFT contract's ACS1 implementation is fundamentally broken. The `SetMethodFee()` and `ChangeMethodFeeController()` methods are no-op stubs that never persist configuration, while `GetMethodFee()` only returns hardcoded fees for the `Create` method. Operations like `Mint`, `Transfer`, and `TransferFrom` have no base fees, charging only negligible transaction size fees (~0.0000000063 ELF per operation). This allows attackers to create millions of permanent state entries for approximately 100 ELF, violating AElf's economic security model and enabling blockchain state bloat attacks.

## Finding Description

The NFT contract implements the ACS1 standard incompletely, with critical methods left as non-functional stubs: [1](#0-0) 

These no-op implementations prevent any fee configuration, contrasting sharply with properly implemented ACS1 in other system contracts: [2](#0-1) 

The `GetMethodFee()` method only returns fees for the `Create` method (100 ELF), while all other methods receive empty `MethodFees`: [3](#0-2) 

The NFT contract state confirms there are no variables for storing transaction fees: [4](#0-3) 

The transaction fee charging mechanism in the token contract calls `GetMethodFee()` on the target contract: [5](#0-4) 

When empty `MethodFees` are returned, only transaction size fees apply based on the formula: [6](#0-5) 

For typical 500-byte transactions: 500/800 + 1/10000 = 0.6251 base units ≈ 0.0000000063 ELF.

Each `Mint` operation creates permanent state entries in `NftInfoMap` and `BalanceMap`: [7](#0-6) 

The protocol creator is automatically added as a minter, granting immediate authorization: [8](#0-7) 

## Impact Explanation

**State Bloat Attack Economics:**
- **Initial cost:** 100 ELF for `Create()` with TotalSupply = 1,000,000
- **Spam cost:** 1,000,000 mints × 0.6251 base units = 625,100 base units = 0.006251 ELF
- **Total attack cost:** ~100.006 ELF to create 2 million permanent state entries (1M in `NftInfoMap`, 1M in `BalanceMap`)

**Chain-Level Impact:**
- **Node Performance Degradation:** Bloated state increases memory consumption, disk I/O, and query latency for all node operators
- **Storage Cost Externalization:** Attacker pays ~100 ELF while node operators bear permanent storage costs
- **DoS Risk:** Sustained attacks across multiple protocols compound state growth, potentially reaching storage/computation limits
- **No Mitigation Path:** The stub `SetMethodFee()` implementation means fees cannot be configured without a contract upgrade

**Protocol Security Violation:**
This directly violates AElf's documented economic security model requiring resource-intensive operations to have commensurate fees. The broken ACS1 implementation creates a permanent vulnerability where state-bloating operations cost effectively zero after the initial protocol creation fee.

## Likelihood Explanation

**Attack Feasibility: HIGH**

**Minimal Barriers to Entry:**
1. **Low Capital Requirement:** 100 ELF is readily obtainable for malicious actors
2. **Automatic Authorization:** Protocol creators automatically become minters
3. **Simple Execution:** Straightforward sequence of `Create()` followed by repeated `Mint()` calls
4. **No Rate Limiting:** No protocol-level restrictions on mint frequency or volume (beyond TotalSupply)

**Amplification Factor:**
- Multiple protocols multiply the attack: 10 protocols × 1M NFTs each = 10M state entries for 1,000 ELF
- Attacker can create unlimited protocols, each with configurable TotalSupply up to int64 maximum

**Permanence:**
The stub implementation of `SetMethodFee()` means this vulnerability cannot be fixed through fee configuration—it requires a contract upgrade. Until then, the attack vector remains open.

**Detection Difficulty:**
Spam minting generates legitimate transaction formats that pass all authorization checks. Distinguishing malicious high-volume minting from legitimate NFT collection launches requires off-chain heuristics.

## Recommendation

**Immediate Actions:**
1. **Contract Upgrade:** Implement proper ACS1 methods that store and retrieve fee configuration from state
2. **Base Fee Configuration:** Set appropriate base fees for `Mint`, `Transfer`, and `TransferFrom` operations proportional to their state impact
3. **Fee Controller:** Establish proper `MethodFeeController` authority to enable governance-controlled fee adjustments

**Proper ACS1 Implementation Pattern:**
```csharp
public override Empty SetMethodFee(MethodFees input)
{
    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, 
           "Unauthorized to set method fee.");
    State.TransactionFees[input.MethodName] = input;
    return new Empty();
}

public override MethodFees GetMethodFee(StringValue input)
{
    return State.TransactionFees[input.Value] ?? new MethodFees();
}
```

**State Definition Addition:**
```csharp
public MappedState<string, MethodFees> TransactionFees { get; set; }
public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

**Recommended Base Fees:**
- `Mint`: 1-10 ELF (proportional to state creation cost)
- `Transfer`: 0.1-1 ELF (proportional to state modification cost)
- `Create`: Maintain 100 ELF or increase to reflect total spam potential

## Proof of Concept

**Attack Simulation:**
```csharp
// Step 1: Attacker creates NFT protocol
var createResult = NFTContract.Create(new CreateInput {
    NftType = "Art",
    ProtocolName = "SpamCollection",
    TotalSupply = 1_000_000,  // 1 million supply
    IsBurnable = false,
    IssueChainId = chainId
});
// Cost: 100 ELF
// Result: Attacker is now authorized minter

// Step 2: Spam mint operations
for (int i = 0; i < 1_000_000; i++) {
    NFTContract.Mint(new MintInput {
        Symbol = createResult.Value,
        Quantity = 1
    });
    // Cost per mint: ~0.6251 base units
    // Creates 2 state entries per mint
}

// Total Cost: 100.006251 ELF
// State Entries Created: 2,000,000 permanent entries
// Cost per state entry: 0.000050003 ELF
```

**Verification Steps:**
1. Check NFT contract `GetMethodFee()` returns empty for "Mint"
2. Verify transaction size fee calculation yields ~0.6251 base units for 500-byte transaction
3. Confirm `NftInfoMap` and `BalanceMap` entries persist after mint
4. Validate `SetMethodFee()` does not modify contract state
5. Demonstrate attack cost vs state bloat ratio

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-16)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }

    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L1-46)
```csharp
﻿using AElf.Sdk.CSharp.State;
using AElf.Types;

namespace AElf.Contracts.NFT;

public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-53)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L274-312)
```csharp
    private CalculateFeeCoefficients GetTxFeeInitialCoefficient()
    {
        return new CalculateFeeCoefficients
        {
            FeeTokenType = (int)FeeTypeEnum.Tx,
            PieceCoefficientsList =
            {
                new CalculateFeePieceCoefficients
                {
                    // Interval [0, 1000000]: x / 800 + 1 / 10000
                    Value =
                    {
                        1000000,
                        1, 1, 800,
                        0, 1, 10000
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (1000000, 5000000): x / 80
                    Value =
                    {
                        5000000,
                        1, 1, 80
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (5000000, ∞): x / 80 + x^2 / 100000
                    Value =
                    {
                        int.MaxValue,
                        1, 1, 80,
                        2, 1, 100000
                    }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L439-441)
```csharp
        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L36-38)
```csharp
        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;
```
