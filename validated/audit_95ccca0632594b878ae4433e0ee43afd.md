# Audit Report

## Title
Missing Authorization Check Allows Multiple Miners to Concurrently Trigger Round Transitions

## Summary
The AEDPoS consensus contract lacks authorization validation to ensure only the designated extra block producer can trigger `NextRound` transitions. Any miner whose time slot has passed can produce blocks with `NextRound` transactions, creating race conditions at round boundaries where multiple miners simultaneously produce competing round transition blocks, violating consensus determinism.

## Finding Description

The vulnerability exists in the consensus validation flow where round transitions are not properly authorized.

The `ValidateBeforeExecution` method applies multiple validation providers for `NextRound` behavior, but none verify that the block producer is the designated extra block producer authorized to terminate the current round: [1](#0-0) 

The validation providers used include:

**MiningPermissionValidationProvider** - only checks if sender is in the miner list, not their specific authorization as extra block producer: [2](#0-1) 

**TimeSlotValidationProvider** - for `NextRound` (new round), only validates the new round's time slot structure, but does not check WHO can trigger it: [3](#0-2) 

**RoundTerminateValidationProvider** - only checks that the round number increments by exactly 1, not authorization: [4](#0-3) 

While an `IsCurrentMiner()` method exists that properly checks extra block producer authorization during the extra block time slot: [5](#0-4) 

This check is never invoked during the validation flow before block execution. The `IsCurrentMiner` method is only used in other contracts (TokenContract, CrossChainContract) for fee-related authorization: [6](#0-5) 

The consensus behavior provider determines that ANY miner whose time slot has passed can trigger round termination: [7](#0-6) [8](#0-7) 

When `NextRound` transactions execute, the only protections are:

1. `EnsureTransactionOnlyExecutedOnceInOneBlock()` - prevents multiple consensus transactions in the SAME block, not across competing blocks at the same height: [9](#0-8) 

2. `TryToUpdateRoundNumber()` - only checks round number increments by 1, which all competing blocks at the same height satisfy when reading from the same parent state: [10](#0-9) 

3. `PreCheck()` - only verifies sender is in the miner list, not their role as extra block producer: [11](#0-10) 

The extra block producer role is deterministically calculated using `CalculateNextExtraBlockProducerOrder()` and marked with the `IsExtraBlockProducer` flag: [12](#0-11) 

However, this designation is never enforced during validation, making it meaningless for authorization purposes.

## Impact Explanation

**Consensus Integrity Violation**: Multiple miners can simultaneously trigger round transitions, creating competing forks where each fork successfully transitions to the next round number but with potentially different internal state (different `ExtraBlockProducerOfPreviousRound`, different miner orders, different timestamps).

**Affected Parties**:
- All network participants face consensus instability and potential chain reorganizations
- Miners lose deterministic round transition leadership, undermining the consensus protocol design
- Cross-chain bridges may receive conflicting state proofs from competing forks
- Applications experience delayed finality and unpredictable state

**Severity Justification**: This violates the critical consensus invariant of "correct round transitions and time-slot validation, miner schedule integrity" by allowing unauthorized miners to trigger round transitions. The designated extra block producer role, determined by `CalculateNextExtraBlockProducerOrder()`, becomes meaningless if any miner whose time slot has passed can trigger the transition. This creates a fundamental race condition in the consensus mechanism at every round boundary.

## Likelihood Explanation

**Reachable Entry Point**: Any miner can call the consensus methods through block production via the ACS4 interface.

**Feasible Preconditions**:
1. Round in progress where all regular time slots have completed
2. Multiple miners simultaneously request their consensus commands via `GetConsensusCommand`
3. Network conditions (latency, partitions) allow multiple miners to produce blocks before one becomes dominant

**Attack Complexity**: Low - this occurs naturally without malicious intent when:
- Network latency causes miners to not immediately see each other's blocks
- Multiple miners reach the end of round simultaneously
- No coordinator explicitly designates the next block producer beyond the theoretical designation

**Probability**: High during normal operation at round boundaries, especially in geographically distributed networks or under network stress. Each round termination (which happens regularly throughout blockchain operation) is a potential race condition opportunity where multiple miners can validly produce competing NextRound blocks.

## Recommendation

Add an extra block producer authorization check to the validation flow. Create a new validation provider:

```csharp
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        
        if (extraData.Behaviour != AElfConsensusBehaviour.NextRound && 
            extraData.Behaviour != AElfConsensusBehaviour.NextTerm)
        {
            validationResult.Success = true;
            return validationResult;
        }
        
        // Check if current time is in extra block time slot
        var currentTime = validationContext.ExtraData.Time;
        var extraBlockTime = validationContext.BaseRound.GetExtraBlockMiningTime();
        
        if (currentTime < extraBlockTime)
        {
            validationResult.Message = "Cannot trigger round transition before extra block time.";
            return validationResult;
        }
        
        // Check if sender is the designated extra block producer
        var extraBlockProducer = validationContext.BaseRound.RealTimeMinersInformation
            .FirstOrDefault(m => m.Value.IsExtraBlockProducer);
            
        if (extraBlockProducer.Key != validationContext.SenderPubkey)
        {
            validationResult.Message = $"Only the designated extra block producer can trigger round transitions. Expected: {extraBlockProducer.Key}, Got: {validationContext.SenderPubkey}";
            return validationResult;
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Then add this provider to the validation flow in `ValidateBeforeExecution`:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new ExtraBlockProducerValidationProvider()); // Add this line
    break;
```

## Proof of Concept

This vulnerability cannot be demonstrated with a single test function as it requires multiple concurrent miners attempting to produce blocks at the same height, which is a network-level race condition. The issue is proven through code analysis showing:

1. The extra block producer role is calculated but never validated
2. Any miner can receive `NextRound` behavior once their slot passes
3. No validation provider checks the extra block producer authorization
4. Multiple miners can simultaneously pass all validation checks

The existing test `AEDPoSContract_FirstRound_Terminate_Test` shows that NextRound can be called successfully, but it doesn't test whether non-designated miners are properly rejected.

## Notes

While AElf may have network-level consensus mechanisms (BFT voting, fork choice rules) that help resolve competing blocks, the contract-level validation should enforce the extra block producer authorization to maintain protocol invariant integrity. The designated role becomes meaningless if not enforced at validation time.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L897-906)
```csharp
    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-83)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L91-97)
```csharp
    private bool TryToUpdateRoundNumber(long roundNumber)
    {
        var oldRoundNumber = State.CurrentRoundNumber.Value;
        if (roundNumber != 1 && oldRoundNumber + 1 != roundNumber) return false;
        State.CurrentRoundNumber.Value = roundNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```
