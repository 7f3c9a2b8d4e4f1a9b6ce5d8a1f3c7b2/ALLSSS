# Audit Report

## Title
NextTerm Block Production Bypasses Tiny Block Limit Due to ActualMiningTimes/ProducedTinyBlocks Desynchronization

## Summary
The `GetConsensusExtraDataForNextTerm` function creates a state desynchronization by setting `ProducedTinyBlocks` to 1 without updating `ActualMiningTimes`. This allows miners producing NextTerm blocks to bypass the 8-block maximum limit and produce 9 total blocks, violating the fork prevention mechanism designed to maintain consensus stability.

## Finding Description

When a miner produces a NextTerm block (transitioning to a new term), the consensus contract creates inconsistent state where `ProducedTinyBlocks` is incremented but `ActualMiningTimes` remains empty.

**Root Cause:**

In `GetConsensusExtraDataForNextTerm`, only `ProducedTinyBlocks` is set to 1 without updating `ActualMiningTimes`: [1](#0-0) 

This contrasts with `GetConsensusExtraDataForNextRound`, which correctly updates both fields: [2](#0-1) 

Similarly, `GetConsensusExtraDataForTinyBlock` and `GetConsensusExtraDataToPublishOutValue` both synchronize these fields: [3](#0-2) [4](#0-3) 

**Why Protections Fail:**

The block production limit enforcement uses `ActualMiningTimes.Count`, not `ProducedTinyBlocks`: [5](#0-4) 

The miner is marked as the extra block producer for the new term: [6](#0-5) 

And can produce tiny blocks before the round starts when `ActualMiningTimes.Count < _maximumBlocksCount`: [7](#0-6) 

After NextTerm processing, `UpdateProducedBlocksNumberOfSender` only updates `ProducedBlocks`, not `ActualMiningTimes`: [8](#0-7) [9](#0-8) 

**Execution Path:**

1. Miner produces NextTerm block → `ProducedTinyBlocks = 1`, `ActualMiningTimes = []`
2. For subsequent tiny blocks, `GetConsensusBehaviour` checks `ActualMiningTimes.Count < 8` (0 < 8 → true)
3. Each tiny block increments both counters via `ProcessTinyBlock`: [10](#0-9) 

4. Miner can produce 8 additional tiny blocks before `ActualMiningTimes.Count = 8`
5. Total: 1 NextTerm + 8 tiny blocks = 9 blocks, exceeding the 8-block limit

The limit is defined as: [11](#0-10) 

## Impact Explanation

**Consensus Integrity Violation**: Miners bypass the fork prevention mechanism that limits blocks to 8 per time slot. The 8-block limit exists explicitly to "avoid too many forks": [12](#0-11) 

**Increased Fork Risk**: Allowing 9 blocks instead of 8 (12.5% increase) directly contradicts the design principle that adjusts tiny block counts to reduce forks during abnormal blockchain status.

**Unfair Advantage**: Only miners producing NextTerm blocks can exceed the limit, creating an unfair advantage over other miners who are constrained to 8 blocks.

**Protocol Safety Degradation**: Undermines the carefully designed block production throttling mechanism that dynamically adjusts based on blockchain health.

**Who is Affected:**
- All network participants suffer from increased fork probability
- Miners not producing NextTerm blocks are disadvantaged
- Consensus stability and finality are compromised

**Quantification:**
- 1 extra block per NextTerm (12.5% over the 8-block limit)
- Affects every term transition (periodic election cycles)
- Cumulative impact on network fork rate over time

## Likelihood Explanation

**Attacker Capabilities:**
- Requires only being a miner at term transition (no special privileges required)
- No additional authority beyond normal miner role
- Exploitation is automatic—occurs without deliberate malicious action

**Attack Complexity:**
- Low: The vulnerability triggers naturally during NextTerm block production
- No special transaction crafting required
- State desynchronization persists automatically once the NextTerm block is produced

**Feasibility:**
- Occurs at every term transition (periodic and predictable)
- No preconditions beyond being in the miner set during term change
- Publicly observable and verifiable by examining `ActualMiningTimes` vs `ProducedTinyBlocks`

**Detection Difficulty:**
- Hard to detect as it appears as normal block production
- The extra block is produced within normal consensus flow
- Only detectable through careful analysis comparing `ActualMiningTimes.Count` vs `ProducedTinyBlocks`

**Probability:** High - Executes automatically at every term transition for miners producing NextTerm blocks.

## Recommendation

Update `GetConsensusExtraDataForNextTerm` to add an entry to `ActualMiningTimes` when setting `ProducedTinyBlocks`, maintaining consistency with other block production methods:

```csharp
private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
    AElfConsensusTriggerInformation triggerInformation)
{
    var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
    Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
    if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
    {
        firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        // Add this line to synchronize ActualMiningTimes
        firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ActualMiningTimes.Add(Context.CurrentBlockTime);
    }

    return new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteStringHelper.FromHexString(pubkey),
        Round = firstRoundOfNextTerm,
        Behaviour = triggerInformation.Behaviour
    };
}
```

This ensures that both `ProducedTinyBlocks` and `ActualMiningTimes` are synchronized, preventing the bypass of the 8-block limit.

## Proof of Concept

A test demonstrating this vulnerability would need to:

1. Set up a consensus scenario with multiple miners
2. Arrange for a term transition (NextTerm block production)
3. Verify that after NextTerm block: `ProducedTinyBlocks = 1` and `ActualMiningTimes.Count = 0`
4. Simulate subsequent tiny block attempts
5. Verify that the miner can produce 8 additional tiny blocks (total 9 blocks)
6. Confirm that this exceeds the intended 8-block limit

The test would validate that the state desynchronization allows bypassing the fork prevention mechanism at every term transition.

## Notes

This is a protocol-level invariant violation that occurs automatically at term transitions without requiring malicious action. The 8-block limit is a critical safety mechanism designed to prevent network forks, and its bypass undermines consensus stability. The issue affects the core consensus logic and should be addressed to maintain the integrity of the fork prevention mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L55-63)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataToPublishOutValue(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L155-163)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForTinyBlock(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L191-196)
```csharp
        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-62)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L254-254)
```csharp
        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L20-35)
```csharp
    private void UpdateProducedBlocksNumberOfSender(Round input)
    {
        var senderPubkey = Context.RecoverPublicKey().ToHex();

        // Update produced block number of transaction sender.
        if (input.RealTimeMinersInformation.ContainsKey(senderPubkey))
            input.RealTimeMinersInformation[senderPubkey].ProducedBlocks =
                input.RealTimeMinersInformation[senderPubkey].ProducedBlocks.Add(1);
        else
            // If the sender isn't in miner list of next term.
            State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
            {
                Pubkey = senderPubkey,
                RecentlyProducedBlocks = 1
            });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L178-186)
```csharp
        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L17-22)
```csharp
    /// <summary>
    ///     Implemented GitHub PR #1952.
    ///     Adjust (mainly reduce) the count of tiny blocks produced by a miner each time to avoid too many forks.
    /// </summary>
    /// <returns></returns>
    private int GetMaximumBlocksCount()
```
