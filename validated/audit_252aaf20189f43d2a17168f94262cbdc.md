# Audit Report

## Title
Non-Deterministic Side Chain Iteration Order Causes Consensus Failure in Block Production

## Summary
The `GetSideChainIndexingInformationList()` method iterates over a protobuf map without sorting, causing non-deterministic ordering of side chains across different nodes. This flows into block header extra data through order-sensitive merkle tree computation, resulting in different block hashes and consensus failure when multiple side chains exist.

## Finding Description

The vulnerability exists in the cross-chain contract's view method that retrieves side chain indexing information. The method iterates over `IdHeightDict` without sorting: [1](#0-0) 

The `IdHeightDict` is a protobuf `map<int32, int64>` type: [2](#0-1) 

Protobuf map types do not guarantee iteration order. The Protocol Buffers specification explicitly states map iteration order is undefined, and the C# `MapField<TKey, TValue>` implementation uses `Dictionary<TKey, TValue>` internally, which does not guarantee consistent iteration order across different processes or runtime versions.

This non-deterministic list is consumed by the cross-chain indexing service during block production: [3](#0-2) 

The service processes chains in the returned order to build `sideChainBlockDataList`: [4](#0-3) 

When extracting block extra data, the system computes a binary merkle tree from the ordered list: [5](#0-4) 

The `BinaryMerkleTree.FromLeafNodes` method is order-sensitive, pairing adjacent nodes: [6](#0-5) 

The merkle tree root becomes part of block header extra data: [7](#0-6) 

The codebase demonstrates explicit awareness of determinism requirements. Block execution uses `SortedSet` for deterministic world state calculation: [8](#0-7) 

## Impact Explanation

When two or more side chains exist with non-terminated status, different nodes may iterate the protobuf map in different orders. This creates a chain reaction:

1. Different iteration orders → different `SideChainBlockDataList` orderings
2. Different orderings → different merkle tree roots (due to order-sensitive pairing)
3. Different merkle roots → different block extra data
4. Different extra data → different block hashes

**Result**: Complete consensus failure. Nodes cannot agree on block validity, causing:
- **Complete network halt** - No blocks can be produced
- **Network-wide impact** - All validators affected simultaneously
- **Service unavailability** - All chain operations cease
- **Requires manual intervention** - Code fix and redeployment needed

The severity is **High** because it causes complete consensus breakdown, effectively halting the entire blockchain network.

## Likelihood Explanation

**Preconditions:**
- Two or more active side chains (non-terminated status) - realistic in production
- Normal block production operations

**Triggering Conditions:**
- No attacker action required - natural determinism bug
- Occurs during every block production when cross-chain data is generated
- Protobuf specification explicitly defines map iteration order as undefined
- .NET `Dictionary<TKey, TValue>` iteration order can vary across processes, even with identical data

**Probability:**
High likelihood in production with multiple side chains. The Protocol Buffers specification explicitly states that map iteration order is undefined, making this a violation of deterministic computation requirements for distributed consensus. Even if current .NET versions maintain insertion order as an implementation detail, relying on undefined behavior in consensus-critical code is a critical bug.

## Recommendation

Add explicit sorting when iterating over the protobuf map. Modify `GetSideChainIndexingInformationList()`:

```csharp
public override SideChainIndexingInformationList GetSideChainIndexingInformationList(Empty input)
{
    var sideChainIndexingInformationList = new SideChainIndexingInformationList();
    var sideChainIdAndHeightDict = GetSideChainIdAndHeight(new Empty());
    
    // Add explicit sorting by chain ID for deterministic ordering
    foreach (var kv in sideChainIdAndHeightDict.IdHeightDict.OrderBy(x => x.Key))
    {
        var chainId = kv.Key;
        sideChainIndexingInformationList.IndexingInformationList.Add(new SideChainIndexingInformation
        {
            ChainId = chainId,
            IndexedHeight = kv.Value
        });
    }

    return sideChainIndexingInformationList;
}
```

## Proof of Concept

The following test demonstrates that different orderings of side chain data produce different merkle tree roots:

```csharp
[Fact]
public void DifferentSideChainOrderProducesDifferentMerkleRoots()
{
    // Create side chain block data with different orderings
    var sideChain1 = new SideChainBlockData
    {
        ChainId = 100,
        Height = 1,
        TransactionStatusMerkleTreeRoot = Hash.FromString("chain100")
    };
    
    var sideChain2 = new SideChainBlockData
    {
        ChainId = 200,
        Height = 1,
        TransactionStatusMerkleTreeRoot = Hash.FromString("chain200")
    };

    // Order 1: chain100, chain200
    var indexedData1 = new IndexedSideChainBlockData();
    indexedData1.SideChainBlockDataList.Add(sideChain1);
    indexedData1.SideChainBlockDataList.Add(sideChain2);
    var extraData1 = indexedData1.ExtractCrossChainExtraDataFromCrossChainBlockData();

    // Order 2: chain200, chain100 (reversed)
    var indexedData2 = new IndexedSideChainBlockData();
    indexedData2.SideChainBlockDataList.Add(sideChain2);
    indexedData2.SideChainBlockDataList.Add(sideChain1);
    var extraData2 = indexedData2.ExtractCrossChainExtraDataFromCrossChainBlockData();

    // Different orderings produce different merkle roots
    extraData1.ShouldNotBe(extraData2);
    
    // This proves that nodes iterating the map in different orders
    // will produce different block extra data and fail to reach consensus
}
```

## Notes

This vulnerability demonstrates a violation of the fundamental determinism requirement for blockchain consensus. The codebase shows clear awareness of this requirement in other areas (world state calculation, consensus round generation), making the lack of explicit sorting in cross-chain indexing an inconsistency that must be addressed. The fix is straightforward - add `OrderBy(x => x.Key)` to ensure consistent iteration order regardless of underlying runtime behavior.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L130-145)
```csharp
    public override SideChainIndexingInformationList GetSideChainIndexingInformationList(Empty input)
    {
        var sideChainIndexingInformationList = new SideChainIndexingInformationList();
        var sideChainIdAndHeightDict = GetSideChainIdAndHeight(new Empty());
        foreach (var kv in sideChainIdAndHeightDict.IdHeightDict)
        {
            var chainId = kv.Key;
            sideChainIndexingInformationList.IndexingInformationList.Add(new SideChainIndexingInformation
            {
                ChainId = chainId,
                IndexedHeight = kv.Value
            });
        }

        return sideChainIndexingInformationList;
    }
```

**File:** protobuf/acs7.proto (L129-132)
```text
message ChainIdAndHeightDict {
    // A collection of chain ids and heights, where the key is the chain id and the value is the height.
    map<int32, int64> id_height_dict = 1;
}
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataService.cs (L194-266)
```csharp
        var sideChainIndexingInformationList = await _contractReaderFactory
            .Create(new ContractReaderContext
            {
                BlockHash = blockHash,
                BlockHeight = blockHeight,
                ContractAddress = crossChainContractAddress
            })
            .GetSideChainIndexingInformationList.CallAsync(new Empty());
        foreach (var sideChainIndexingInformation in sideChainIndexingInformationList.IndexingInformationList)
        {
            var libDto = await _irreversibleBlockStateProvider.GetLastIrreversibleBlockHashAndHeightAsync();
            var sideChainId = sideChainIndexingInformation.ChainId;
            if (excludeChainIdList.Contains(sideChainId))
                continue;
            var sideChainHeightInLibValue = await _contractReaderFactory
                .Create(new ContractReaderContext
                {
                    BlockHash = libDto.BlockHash,
                    BlockHeight = libDto.BlockHeight,
                    ContractAddress = crossChainContractAddress
                })
                .GetSideChainHeight.CallAsync(new Int32Value { Value = sideChainId });

            long toBeIndexedCount;
            long targetHeight;
            var sideChainHeightInLib = sideChainHeightInLibValue?.Value ?? 0;
            if (sideChainHeightInLib > 0)
            {
                targetHeight = sideChainIndexingInformation.IndexedHeight + 1;
                toBeIndexedCount = CrossChainConstants.DefaultBlockCacheEntityCount;
                Logger.LogDebug(
                    $"Target height {targetHeight} of side chain " +
                    $"{ChainHelper.ConvertChainIdToBase58(sideChainId)}.");
            }
            else if (sideChainIndexingInformation.IndexedHeight > 0)
            {
                toBeIndexedCount = 0;
                targetHeight = sideChainIndexingInformation.IndexedHeight + 1;
            }
            else
            {
                toBeIndexedCount = 1;
                targetHeight = AElfConstants.GenesisBlockHeight;
                Logger.LogDebug(
                    $"Target height {targetHeight} of side chain " +
                    $"{ChainHelper.ConvertChainIdToBase58(sideChainId)}.");
            }

            var sideChainBlockDataFromCache = new List<SideChainBlockData>();

            var i = 0;
            while (i < toBeIndexedCount)
            {
                var sideChainBlockData =
                    _blockCacheEntityConsumer.Take<SideChainBlockData>(sideChainIndexingInformation.ChainId,
                        targetHeight, targetHeight == AElfConstants.GenesisBlockHeight);
                if (sideChainBlockData == null || sideChainBlockData.Height != targetHeight)
                    // no more available side chain block info
                    break;

                sideChainBlockDataFromCache.Add(sideChainBlockData);
                targetHeight++;
                i++;
            }

            if (sideChainBlockDataFromCache.Count > 0)
            {
                Logger.LogDebug(
                    $"Got height [{sideChainBlockDataFromCache.First().Height} - {sideChainBlockDataFromCache.Last().Height} ]" +
                    $" from side chain {ChainHelper.ConvertChainIdToBase58(sideChainIndexingInformation.ChainId)}.");
                sideChainBlockDataList.AddRange(sideChainBlockDataFromCache);
            }
        }
```

**File:** src/AElf.CrossChain.Core/Extensions/CrossChainDataTypeExtensions.cs (L30-42)
```csharp
    public static ByteString ExtractCrossChainExtraDataFromCrossChainBlockData(
        this IndexedSideChainBlockData indexedSideChainBlockData)
    {
        var txRootHashList = indexedSideChainBlockData.SideChainBlockDataList
            .Select(scb => scb.TransactionStatusMerkleTreeRoot).ToList();

        var calculatedSideChainTransactionsRoot = BinaryMerkleTree.FromLeafNodes(txRootHashList).Root;
        return new CrossChainExtraData
            {
                TransactionStatusMerkleTreeRoot = calculatedSideChainTransactionsRoot
            }
            .ToByteString();
    }
```

**File:** src/AElf.Types/Types/BinaryMerkleTree.cs (L41-46)
```csharp
            while (i < leafNodes.Count - 1)
            {
                var left = leafNodes[i++];
                var right = leafNodes[i++];
                leafNodes.Add(HashHelper.ConcatAndCompute(left, right));
                if (++newAdded != nodeToAdd)
```

**File:** src/AElf.CrossChain/Application/CrossChainBlockExtraDataProvider.cs (L24-37)
```csharp
    public async Task<ByteString> GetBlockHeaderExtraDataAsync(BlockHeader blockHeader)
    {
        if (blockHeader.Height == AElfConstants.GenesisBlockHeight)
            return ByteString.Empty;

        if (!_transactionPackingOptionProvider.IsTransactionPackable(new ChainContext
                { BlockHash = blockHeader.PreviousBlockHash, BlockHeight = blockHeader.Height - 1 }))
            return ByteString.Empty;

        var bytes = await _crossChainIndexingDataService.PrepareExtraDataForNextMiningAsync(
            blockHeader.PreviousBlockHash, blockHeader.Height - 1);

        return bytes;
    }
```

**File:** src/AElf.Kernel.SmartContractExecution/Application/BlockExecutingService.cs (L165-180)
```csharp
    private IEnumerable<byte[]> GetDeterministicByteArrays(BlockStateSet blockStateSet)
    {
        var keys = blockStateSet.Changes.Keys;
        foreach (var k in new SortedSet<string>(keys))
        {
            yield return Encoding.UTF8.GetBytes(k);
            yield return blockStateSet.Changes[k].ToByteArray();
        }

        keys = blockStateSet.Deletes;
        foreach (var k in new SortedSet<string>(keys))
        {
            yield return Encoding.UTF8.GetBytes(k);
            yield return ByteString.Empty.ToByteArray();
        }
    }
```
