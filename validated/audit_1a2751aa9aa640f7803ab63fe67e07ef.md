# Audit Report

## Title
Decimal Overflow in Bancor Formula Calculation Causing DoS on Token Swaps

## Summary
The TokenConverter contract's Bancor pricing formula can throw an `OverflowException` when extreme but individually valid connector weight ratios are combined with large transaction sizes. This occurs because the `Pow()` function's binary exponentiation algorithm overflows during intermediate calculations, causing complete denial of service on token swap operations for affected connector pairs.

## Finding Description

The vulnerability exists in the Bancor pricing formula implementation. When users call the `Sell()` function [1](#0-0) , it invokes `BancorHelper.GetReturnFromPaid()` to calculate the return amount.

The calculation computes `bt * (decimal.One - Exp(y * Ln(x)))` where [2](#0-1) :
- `y = wf / wt` (ratio of fromConnectorWeight to toConnectorWeight)
- `x = bf / (bf + a)` (balance ratio determining price impact)

**Root Cause:**

Connector weights are validated individually to be strictly between 0 and 1 [3](#0-2)  using the check [4](#0-3) . However, the **ratio** `y = wf/wt` is unbounded.

When `wt` is very small (e.g., 0.001 = 0.1% reserve ratio) and `wf` is larger (e.g., 0.5), the ratio becomes extreme (y = 500). For large transactions where `a` approaches or exceeds `bf`, `x` becomes small, making `Ln(x)` very negative. This causes `y * Ln(x)` to become a large negative number (e.g., -458 when y=500 and Ln(0.4)≈-0.916).

The `Exp()` function [5](#0-4)  computes a power series requiring `Pow(y, k)` for k up to 20. The `Pow()` function [6](#0-5)  uses binary exponentiation with repeated squaring.

When computing `(-458)^20`, the even power produces: `458^20 ≈ 1.65 × 10^53`, which massively exceeds `Decimal.MaxValue ≈ 7.9 × 10^28`. The multiplication `A *= A` at line 115 throws an `OverflowException` in C#, reverting the entire transaction.

**Why Existing Protections Fail:**

The validation logic only enforces individual weight bounds, not their ratio. There is no validation that the input to `Exp()` is within safe computational bounds, and no overflow protection or try-catch blocks exist in the calculation path.

## Impact Explanation

**Severity: HIGH**

This vulnerability causes complete denial of service on token swap functionality for affected connector pairs. Users cannot execute Buy or Sell operations through the TokenConverter, effectively locking liquidity temporarily.

**Affected Parties:**
- Users attempting to swap tokens are unable to execute transactions
- Liquidity providers whose funds become inaccessible until weights are reconfigured
- The protocol's core economic functionality is disrupted

**Why HIGH Severity:**
- Critical core functionality (token swaps) is completely disabled
- No fund loss occurs, but liquidity is effectively locked until governance intervention
- Affects protocol availability and economic operations
- Transaction reverts cleanly before state changes, preventing partial execution

The impact is not CRITICAL because funds are not permanently lost and governance can update connector weights via [7](#0-6)  to restore functionality.

## Likelihood Explanation

**Probability: MEDIUM**

**Required Conditions:**
1. Governance/connector controller must set extreme but valid weight ratios (e.g., wt=0.001, wf=0.5)
2. Users attempt transactions with sizes that make the balance ratio unfavorable
3. The mathematical conditions align to produce overflow

**Why MEDIUM Likelihood:**
- Extreme weight ratios (50:1 or higher) are economically unusual but not prohibited by code
- Low liquidity pools or poorly initialized connectors increase vulnerability
- Large transaction attempts during market volatility can trigger the condition
- No active monitoring prevents reaching overflow conditions
- The vulnerability requires no attacker capability - normal operations can trigger it

**Why not HIGH:**
- Governance would typically avoid extreme reserve ratios for economic reasons
- Most production connectors use balanced weights (e.g., 0.5:0.5)

**Why not LOW:**
- Once extreme weights are set, triggering is automatic during normal operations
- No sophistication required - legitimate large swaps cause the issue

## Recommendation

Add validation for the weight ratio and input bounds to the exponential function:

1. **Add ratio validation** in `AssertValidConnectorWeight` or during connector updates to ensure `wf/wt` remains within safe bounds (e.g., between 0.1 and 10).

2. **Add bounds checking** in `Exp()` function to reject inputs that would cause overflow:
   - Check if `Math.Abs(y) > MAX_SAFE_EXP_INPUT` before computing power series
   - Add try-catch around `Pow()` calls to handle overflow gracefully

3. **Wrap overflow-prone operations** in checked blocks with exception handling to provide meaningful error messages instead of transaction reverts.

## Proof of Concept

```csharp
[Fact]
public async Task Sell_With_Extreme_Weight_Ratio_Causes_Overflow()
{
    // Setup: Create connectors with extreme weight ratio
    var extremeFromConnector = new Connector
    {
        Symbol = "EXTREME",
        Weight = "0.5",  // wf = 0.5
        VirtualBalance = 1000000,
        IsPurchaseEnabled = true,
        RelatedSymbol = "NTEXTREME",
        IsDepositAccount = false
    };
    
    var extremeToConnector = new Connector
    {
        Symbol = "NTEXTREME",
        Weight = "0.001",  // wt = 0.001, ratio = 500
        VirtualBalance = 1000000,
        IsPurchaseEnabled = true,
        IsVirtualBalanceEnabled = true,
        RelatedSymbol = "EXTREME",
        IsDepositAccount = true
    };

    // Initialize with extreme connectors
    await DefaultStub.Initialize.SendAsync(new InitializeInput
    {
        BaseTokenSymbol = "ELF",
        FeeRate = "0.005",
        Connectors = { extremeFromConnector, extremeToConnector }
    });

    // Attempt large sell that triggers overflow
    var sellResult = await DefaultStub.Sell.SendWithExceptionAsync(
        new SellInput
        {
            Symbol = "EXTREME",
            Amount = 600000,  // Large amount relative to balance
            ReceiveLimit = 0
        });
    
    // Verify transaction fails with overflow
    sellResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    sellResult.TransactionResult.Error.ShouldContain("Overflow");
}
```

## Notes

The vulnerability is mathematically certain when extreme weight ratios are configured. The specific overflow occurs in the `Pow()` function during binary exponentiation when computing large powers of large numbers. C# decimal arithmetic throws `OverflowException` when intermediate results exceed `Decimal.MaxValue`, and since there are no try-catch blocks in the calculation path [8](#0-7) , the exception propagates and reverts the transaction.

The same issue affects the `Buy()` function [9](#0-8)  through `GetAmountToPayFromReturn()` [10](#0-9) , which uses the same exponential calculation logic.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-159)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-172)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-94)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L104-120)
```csharp
    public static decimal Pow(decimal x, uint y)
    {
        if (y == 1)
            return x;

        var A = 1m;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;

        for (var i = t - 1; i >= 0; --i)
        {
            A *= A;
            if (e[i]) A *= x;
        }

        return A;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```
