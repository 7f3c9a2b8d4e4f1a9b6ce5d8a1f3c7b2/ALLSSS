# Audit Report

## Title
Unvalidated External Callbacks Enable Denial-of-Service on Token Operations

## Summary
The MultiToken contract accepts arbitrary callback contract addresses in token `ExternalInfo` without validation. When these callbacks are invoked during Transfer, Lock, or Unlock operations and fail, AElf's transaction execution model causes the entire operation to roll back, permanently disabling token operations for all holders.

## Finding Description

The vulnerability exists in the token creation and operation flow where callback addresses are neither validated nor restricted.

**Token Creation - No Validation:**
During token creation, the `CreateToken` method directly stores user-provided `ExternalInfo` without validating callback contract addresses. [1](#0-0) 

**Callback Keys Defined:**
Three callback keys exist for token operations: transfer, lock, and unlock callbacks. [2](#0-1) 

**Unvalidated Callback Invocation:**
When tokens are transferred, the contract invokes callbacks without address validation via `Context.SendInline`. [3](#0-2) 

Similar unvalidated invocations occur during lock operations [4](#0-3)  and unlock operations. [5](#0-4) 

**Callbacks Invoked After State Modifications:**
Critically, these callbacks are invoked AFTER balance modifications in Transfer [6](#0-5) , Lock [7](#0-6) , and Unlock operations. [8](#0-7) 

**Transaction Failure Propagation:**
AElf's execution model recursively checks all inline transactions. The `IsSuccessful()` method returns false if any inline trace fails. [9](#0-8) 

When an inline transaction fails, the execution service stops processing remaining inline transactions and only commits pre/post traces, rolling back the main transaction state changes. [10](#0-9) [11](#0-10) 

**Contrast With Proper Validation:**
The contract properly validates `LockWhiteList` addresses, requiring them to be system contracts. [12](#0-11)  However, no equivalent validation exists for callback addresses in `ExternalInfo`.

## Impact Explanation

**High Severity - Complete Token Operation DoS:**

1. **All holders affected**: Any user attempting to transfer, lock, or unlock the malicious token will have their transaction fail and roll back completely
2. **Funds effectively frozen**: Tokens become non-transferable, trapping value for all holders
3. **DeFi protocol breakage**: If integrated into DEXs, lending protocols, or other DeFi systems, those integrations become non-functional
4. **Cascade failures**: Multi-token transactions fail if they include the malicious token
5. **Unrecoverable**: No RPC method exists to update `ExternalInfo` after token creation, making the DoS permanent

This breaks the fundamental security guarantee that legitimate token holders can freely transfer their assets. While not direct theft, it achieves the same economic outcome: users permanently lose access to their token value.

## Likelihood Explanation

**High Likelihood:**

**Attacker Requirements (all easily obtainable):**
1. SEED NFT for token creation (purchasable on market)
2. Deploy malicious callback contract (trivial: single method that reverts)
3. Create token with callback in ExternalInfo
4. Distribute tokens (airdrops, sales, legitimate-looking marketing)

**Attack Complexity: Very Low**
- No special permissions required
- No trusted role compromise needed
- Single transaction to create malicious token
- Victims trigger DoS automatically by attempting normal operations

**Detection Difficulty: Very High**
- Pre-deployment: Impossible to distinguish from legitimate token without deep inspection
- Post-deployment: Only discovered when users try to transfer
- ExternalInfo is opaque during token creation

**Economic Viability:**
- Cost: One SEED NFT + minimal gas fees
- Impact: Unlimited victims
- Persistent: Cannot be fixed without creating entirely new token
- Use cases: Competitor disruption, exit scams, ransom attacks

## Recommendation

Implement validation for callback contract addresses in `ExternalInfo` during token creation, similar to the existing `LockWhiteList` validation:

1. Add a whitelist check requiring callback contract addresses to be system contracts or pre-approved addresses
2. Validate callback contract addresses exist and implement expected interfaces before storing in `ExternalInfo`
3. Consider adding try-catch logic around callback invocations to prevent transaction rollback from callback failures
4. Implement a governance-controlled method to update or remove malicious callbacks from existing tokens

Example validation to add in `CreateToken`:
```csharp
// After line 77 in TokenContract_Actions.cs
if (input.ExternalInfo != null)
{
    var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Select(m => m.Value);
    
    // Validate transfer callback if present
    if (input.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
    {
        var callbackInfo = JsonParser.Default.Parse<CallbackInfo>(
            input.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
        Assert(systemContractAddresses.Contains(callbackInfo.ContractAddress), 
            "Callback contract must be a system contract");
    }
    
    // Repeat for LockCallbackExternalInfoKey and UnlockCallbackExternalInfoKey
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousCallback_CausesDoS_OnAllTokenOperations()
{
    // 1. Create malicious callback contract that always fails
    var maliciousCallbackAddress = await DeployMaliciousCallbackContract();
    
    // 2. Create token with malicious callback in ExternalInfo
    var tokenSymbol = "MALICIOUS";
    var externalInfo = new ExternalInfo
    {
        Value =
        {
            {
                TokenContractConstants.TransferCallbackExternalInfoKey,
                $"{{\"contract_address\":\"{maliciousCallbackAddress}\",\"method_name\":\"FailingCallback\"}}"
            }
        }
    };
    
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = tokenSymbol,
        TokenName = "Malicious Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAddress,
        IsBurnable = true,
        ExternalInfo = externalInfo
    });
    
    // 3. Issue tokens to victim
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = tokenSymbol,
        Amount = 1000,
        To = UserAddress
    });
    
    // 4. Attempt transfer - should fail due to callback
    var transferResult = await UserTokenContractStub.Transfer.SendWithExceptionAsync(new TransferInput
    {
        Symbol = tokenSymbol,
        Amount = 100,
        To = AnotherUserAddress
    });
    
    // Verify: Transfer fails completely
    transferResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    
    // Verify: Balance unchanged (transaction rolled back)
    var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = tokenSymbol,
        Owner = UserAddress
    });
    balance.Balance.ShouldBe(1000); // Still has all tokens but cannot transfer
    
    // Token is now permanently non-transferable for ALL holders
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L95-98)
```csharp
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Select(m => m.Value);
        var isSystemContractAddress = input.LockWhiteList.All(l => systemContractAddresses.Contains(l));
        Assert(isSystemContractAddress, "Addresses in lock white list should be system contract addresses");
        foreach (var address in input.LockWhiteList) State.LockWhiteLists[input.Symbol][address] = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L183-191)
```csharp
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L212-220)
```csharp
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
        DealWithExternalInfoDuringLocking(new TransferFromInput
        {
            From = input.Address,
            To = virtualAddress,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L236-250)
```csharp
        Context.SendVirtualInline(fromVirtualAddress, Context.Self, nameof(Transfer), new TransferInput
        {
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        DealWithExternalInfoDuringUnlock(new TransferFromInput
        {
            From = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress),
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-15)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
    public const string LockCallbackExternalInfoKey = "aelf_lock_callback";
    public const string UnlockCallbackExternalInfoKey = "aelf_unlock_callback";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L326-331)
```csharp
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.LockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.LockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L341-346)
```csharp
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L356-361)
```csharp
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.UnlockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.UnlockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
```

**File:** src/AElf.Kernel.Core/Extensions/TransactionTraceExtensions.cs (L8-19)
```csharp
    public static bool IsSuccessful(this TransactionTrace txTrace)
    {
        if (txTrace.ExecutionStatus != ExecutionStatus.Executed) return false;

        if (txTrace.PreTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.InlineTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.PostTraces.Any(trace => !trace.IsSuccessful())) return false;

        return true;
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L105-126)
```csharp
    private static bool TryUpdateStateCache(TransactionTrace trace, TieredStateCache groupStateCache)
    {
        if (trace == null)
            return false;

        if (!trace.IsSuccessful())
        {
            var transactionExecutingStateSets = new List<TransactionExecutingStateSet>();

            AddToTransactionStateSets(transactionExecutingStateSets, trace.PreTraces);
            AddToTransactionStateSets(transactionExecutingStateSets, trace.PostTraces);

            groupStateCache.Update(transactionExecutingStateSets);
            trace.SurfaceUpError();
        }
        else
        {
            groupStateCache.Update(trace.GetStateSets());
        }

        return true;
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L236-246)
```csharp
            var inlineTrace = await ExecuteOneAsync(singleTxExecutingDto, cancellationToken);

            if (inlineTrace == null)
                break;
            trace.InlineTraces.Add(inlineTrace);
            if (!inlineTrace.IsSuccessful())
                // Already failed, no need to execute remaining inline transactions
                break;

            internalStateCache.Update(inlineTrace.GetStateSets());
        }
```
