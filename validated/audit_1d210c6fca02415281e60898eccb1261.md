# Audit Report

## Title
Missing Validation of Reserved ExternalInfo Callback Keys Allows Unauthorized Contract Callbacks

## Summary
The MultiToken contract exposes reserved callback keys for token operations (transfer, lock, unlock) via `GetReservedExternalInfoKeyList()`, but never validates these keys during token creation. Any user who can create tokens (via SEED NFT or NFT collection ownership) can embed arbitrary contract callbacks in the ExternalInfo field, which execute automatically during token operations without authorization checks, enabling unauthorized contract execution, reentrancy attacks, DoS, and information leakage.

## Finding Description

The MultiToken contract defines four reserved callback keys through `GetReservedExternalInfoKeyList()`: [1](#0-0) 

These reserved keys are defined as constants: [2](#0-1) 

However, when tokens are created, the `ExternalInfo` field is directly assigned from user input without any validation: [3](#0-2) 

The validation function `AssertValidCreateInput()` only checks token name length, symbol format, decimals, and symbol length - it completely omits ExternalInfo validation: [4](#0-3) 

During token operations, the contract automatically executes callbacks if the reserved keys exist in ExternalInfo, without any authorization checks:

**Transfer callbacks:** [5](#0-4) 

**Lock callbacks:** [6](#0-5) 

**Unlock callbacks:** [7](#0-6) 

The callbacks are invoked via `Context.SendInline()` with the parsed callback info from ExternalInfo, passing full transaction details (from, to, amount, memo) to the attacker-controlled contract address. No validation is performed on the callback contract address or the authorization of who set the callback.

**Evidence of Intent:** The NFT contract demonstrates that the developers understood the need to validate reserved keys. The NFT contract properly validates metadata keys against a reserved list: [8](#0-7) 

And the NFT contract's reserved key list: [9](#0-8) 

This validation is called during NFT creation: [10](#0-9) 

The presence of proper validation in the NFT contract proves the developers recognized this security requirement but failed to implement it in the MultiToken contract, creating a systematic validation gap.

## Impact Explanation

**Unauthorized Contract Execution:** Any user who creates a malicious token can specify arbitrary contract addresses as callbacks. These callbacks execute automatically during every transfer, lock, or unlock operation involving the token, bypassing all intended access controls. This fundamentally breaks the security model that only authorized system contracts should receive inline calls during token operations.

**Reentrancy Attacks:** The callbacks execute via `Context.SendInline()`, which is synchronous. This allows the attacker's contract to re-enter the MultiToken contract during state changes, potentially manipulating balances, allowances, or other state variables before the original operation completes.

**Denial of Service:** If the malicious callback reverts or runs out of gas, the entire token operation fails. An attacker can create a token where all transfers, locks, or unlocks become permanently disabled, making the token completely unusable.

**Information Leakage:** Full transaction details (from address, to address, amount, memo) are sent to the attacker's contract in the callback. This reveals sensitive user behavior, trading patterns, and private transaction data that users expect to remain confidential within the blockchain state.

**Ecosystem Impact:** Any user who receives, holds, or attempts to trade these malicious tokens becomes a victim. Contracts that integrate with arbitrary tokens (DEXs, lending protocols, wallets) become vulnerable to unexpected callback behavior. The trust model of the entire token ecosystem is compromised.

## Likelihood Explanation

**Attacker Requirements:** Token creation requires one of:
- Being in the token creation whitelist (system contracts only - not applicable to attackers)
- Possessing a SEED NFT for the desired symbol (publicly obtainable through the SEED marketplace)
- Owning an NFT collection and creating items within it (most practical - collections can be created with SEED NFTs): [11](#0-10) 

**Attack Complexity:** The exploit is straightforward:
1. Deploy a malicious contract with callback method implementations
2. Create a token with ExternalInfo containing the reserved callback keys pointing to the malicious contract address
3. Distribute tokens to victims or wait for market trading
4. Callbacks execute automatically when victims perform token operations

**Feasibility:** This attack is highly practical:
- NFT collection creators routinely set ExternalInfo on their tokens
- The validation gap is systematic - the reserved key list exists but is completely unused
- No runtime checks prevent callback execution
- The attack can be executed permissionlessly by anyone with access to token creation

## Recommendation

Implement validation of ExternalInfo callback keys during token creation, similar to the NFT contract's approach. The `AssertValidCreateInput()` method should be modified to:

```csharp
private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
{
    Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
           && input.Symbol.Length > 0
           && input.Decimals >= 0
           && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

    // Validate ExternalInfo does not contain reserved callback keys
    if (input.ExternalInfo != null && input.ExternalInfo.Value.Count > 0)
    {
        var reservedKeys = new List<string>
        {
            TokenContractConstants.LockCallbackExternalInfoKey,
            TokenContractConstants.TransferCallbackExternalInfoKey,
            TokenContractConstants.UnlockCallbackExternalInfoKey,
            TokenContractConstants.LogEventExternalInfoKey
        };
        
        foreach (var key in input.ExternalInfo.Value.Keys)
        {
            Assert(!reservedKeys.Contains(key), 
                $"ExternalInfo key {key} is reserved and cannot be set by users.");
        }
    }

    CheckSymbolLength(input.Symbol, symbolType);
    if (symbolType == SymbolType.Nft) return;
    CheckTokenAndCollectionExists(input.Symbol);
    if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
}
```

Alternatively, if callback functionality is intended for specific use cases, add authorization checks to verify the token creator is authorized to set callbacks (e.g., only system contracts or addresses approved through governance).

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task ExternalInfoCallbackVulnerability_Test()
{
    // 1. Create malicious callback contract (simulated by any deployed contract)
    var maliciousContractAddress = DefaultSender;
    
    // 2. Create token with malicious callback in ExternalInfo
    var symbol = "EVIL";
    var createInput = new CreateInput
    {
        Symbol = symbol,
        TokenName = "Evil Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultSender,
        IsBurnable = true,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                {
                    "aelf_transfer_callback",
                    $"{{\"contractAddress\":\"{maliciousContractAddress}\",\"methodName\":\"MaliciousCallback\"}}"
                }
            }
        }
    };
    
    // Token creation succeeds without validation error
    var result = await TokenContractStub.Create.SendAsync(createInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // 3. Verify callback executes during transfer
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = symbol,
        Amount = 1000,
        To = UserAddress,
    });
    
    // Transfer triggers callback execution (would call malicious contract)
    var transferResult = await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        Symbol = symbol,
        Amount = 100,
        To = User2Address,
        Memo = "test"
    });
    
    // Transaction succeeds, proving callbacks execute without authorization
    transferResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // The callback was executed inline during the transfer
    // In a real attack, this would call the attacker's malicious contract
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L238-250)
```csharp
    public override StringList GetReservedExternalInfoKeyList(Empty input)
    {
        return new StringList
        {
            Value =
            {
                TokenContractConstants.LockCallbackExternalInfoKey,
                TokenContractConstants.LogEventExternalInfoKey,
                TokenContractConstants.TransferCallbackExternalInfoKey,
                TokenContractConstants.UnlockCallbackExternalInfoKey
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-16)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
    public const string LockCallbackExternalInfoKey = "aelf_lock_callback";
    public const string UnlockCallbackExternalInfoKey = "aelf_unlock_callback";
    public const string LogEventExternalInfoKey = "aelf_log_event";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L322-335)
```csharp
    private void DealWithExternalInfoDuringLocking(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.LockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.LockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L352-365)
```csharp
    private void DealWithExternalInfoDuringUnlock(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.UnlockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.UnlockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L118-123)
```csharp
    private void AssertMetadataKeysAreCorrect(IEnumerable<string> metadataKeys)
    {
        var reservedMetadataKey = GetNftMetadataReservedKeys();
        foreach (var metadataKey in metadataKeys)
            Assert(!reservedMetadataKey.Contains(metadataKey), $"Metadata key {metadataKey} is reserved.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L97-107)
```csharp
    private List<string> GetNftMetadataReservedKeys()
    {
        return new List<string>
        {
            NftTypeMetadataKey,
            NftBaseUriMetadataKey,
            AssembledNftsKey,
            AssembledFtsKey,
            NftTokenIdReuseMetadataKey
        };
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L184-201)
```csharp
    private ExternalInfo GetTokenExternalInfo(CreateInput input)
    {
        if (input.Metadata != null) AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var tokenExternalInfo = input.Metadata == null
            ? new ExternalInfo()
            : new ExternalInfo
            {
                Value = { input.Metadata.Value }
            };

        // Add NFT Type to external info.
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
        return tokenExternalInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L10-13)
```csharp
    private Empty CreateNFTCollection(CreateInput input)
    {
        return CreateToken(input, SymbolType.NftCollection);
    }
```
