# Audit Report

## Title
Case-Insensitive Token Uniqueness Bypass via CrossChainCreateToken

## Summary
The `CrossChainCreateToken` function implements only case-sensitive token existence checking, while normal token creation enforces case-insensitive uniqueness. This inconsistency allows attackers to create duplicate tokens with different casing (e.g., "ABC-0" and "abc-0") through cross-chain operations, violating the protocol's fundamental token uniqueness invariant.

## Finding Description

The MultiToken contract establishes case-insensitive token uniqueness through the `State.InsensitiveTokenExisting` mapping, which stores symbols in uppercase. [1](#0-0)  The mapping is set during token registration. [2](#0-1) 

Normal token creation via `CreateToken` properly enforces this invariant by calling `CheckTokenExists` before token registration. [3](#0-2) 

The `CheckTokenExists` function performs dual validation - checking both the case-sensitive `State.TokenInfos` and the case-insensitive `State.InsensitiveTokenExisting` mapping. [4](#0-3) 

However, `CrossChainCreateToken` bypasses this protection by using only a case-sensitive check that verifies `State.TokenInfos[tokenInfo.Symbol] == null` without checking `State.InsensitiveTokenExisting`. [5](#0-4) 

When the case-sensitive check passes, `RegisterTokenInfo` is called, which creates a separate entry in `State.TokenInfos` with the different casing while setting the same uppercase key in `State.InsensitiveTokenExisting`. [6](#0-5) 

This results in two distinct tokens ("ABC-0" and "abc-0") with separate balance and allowance mappings, as these state variables use the symbol string as the key without case normalization. [7](#0-6) 

Since `GetTokenInfo` performs case-sensitive lookups without normalization, users querying for "ABC-0" will not find "abc-0" and vice versa. [8](#0-7) 

## Impact Explanation

**Protocol Invariant Violation**: The fundamental guarantee that token symbols are case-insensitively unique is broken. This is a core protocol invariant that all token operations depend on.

**State Fragmentation**: If token "ABC-0" exists, an attacker can create "abc-0" as a completely separate token with independent token information (issuer, owner, supply, decimals), balance mappings for all addresses, allowance mappings between addresses, and lock whitelist configurations.

**User Confusion**: Users and dApps expecting case-insensitive token identification will interact with the wrong token, as token lookups use exact case matching, potentially leading to lost funds or incorrect token transfers.

**NFT Collection Fragmentation**: For NFT collections, this creates parallel namespaces where "ABC-0" and "abc-0" can each issue their own items (ABC-1, ABC-2 vs abc-1, abc-2), fragmenting what should be a unified collection and breaking NFT collection semantics.

**Cross-Chain Consistency**: Multi-chain deployments will face inconsistencies when case variants exist on different chains, breaking cross-chain transfer assumptions and potentially creating economic exploits across chains.

## Likelihood Explanation

**Entry Point**: `CrossChainCreateToken` is a public method accessible to any caller with valid cross-chain proof. [9](#0-8) 

**Prerequisites**:
1. Token contract must be registered in `State.CrossChainTransferWhiteList` for the source chain - this is standard in multi-chain setups [10](#0-9) 
2. Valid merkle proof and cross-chain verification required [11](#0-10) 
3. Attacker must be able to create token on source chain

**Feasibility**: In legitimate multi-chain environments where parent/side chains are properly registered (normal operation), the attack is straightforward once prerequisites are met. The attacker creates a case-variant token on Chain A, then submits `CrossChainCreateToken` on Chain B with valid proof. The case-sensitive check at line 506 will pass if only the different-cased variant exists on Chain B, allowing token creation that bypasses case-insensitive uniqueness.

**Assessment**: MEDIUM likelihood - feasible in multi-chain deployments where chains are legitimately connected and source chain allows token creation.

## Recommendation

Modify `CrossChainCreateToken` to call `CheckTokenExists` before token registration, ensuring consistent case-insensitive validation across all token creation paths:

```csharp
public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
{
    // ... existing validation code ...
    
    var tokenInfo = new TokenInfo
    {
        // ... existing token info construction ...
    };

    var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
    
    // ADD THIS: Check token existence with case-insensitive validation
    CheckTokenExists(tokenInfo.Symbol);
    
    // Only register if check passes
    RegisterTokenInfo(tokenInfo);
    
    // ... rest of the method ...
}
```

This ensures that the same dual validation (case-sensitive and case-insensitive) is applied in cross-chain token creation as in normal token creation.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreateToken_CaseInsensitive_Bypass_Test()
{
    // Setup: Create token "ABC-0" on main chain
    await CreateToken_MainChain("ABC-0");
    
    // Setup cross-chain infrastructure
    var sideChainId = await GenerateSideChainAsync();
    await RegisterSideChainContractAddressOnMainChainAsync();
    
    // Attacker creates lowercase variant "abc-0" on side chain
    await CreateToken_SideChain("abc-0");
    
    // Get validation transaction and proof for "abc-0" from side chain
    var tokenInfo = await SideChainTokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = "abc-0" });
    var validationTx = CreateTokenInfoValidationTransaction(tokenInfo, SideChainTokenContractStub);
    
    var executedSet = await SideChainTestKit.MineAsync(new List<Transaction> { validationTx });
    var merklePath = GetTransactionMerklePathAndRoot(validationTx, out var blockRoot);
    await MainAndSideIndexAsync(sideChainId, executedSet.Height, blockRoot);
    var boundHeight = await GetBoundParentChainHeightAndMerklePathByHeight(executedSet.Height);
    
    // Attack: Call CrossChainCreateToken on main chain to create "abc-0"
    // This should fail but will succeed due to case-sensitive check
    var input = new CrossChainCreateTokenInput
    {
        FromChainId = sideChainId,
        ParentChainHeight = boundHeight.BoundParentChainHeight,
        TransactionBytes = validationTx.ToByteString(),
        MerklePath = merklePath
    };
    input.MerklePath.MerklePathNodes.AddRange(boundHeight.MerklePathFromParentChain.MerklePathNodes);
    
    var result = await TokenContractStub.CrossChainCreateToken.SendAsync(input);
    
    // Verify: Both "ABC-0" and "abc-0" now exist as separate tokens
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var tokenABC = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = "ABC-0" });
    var tokenabc = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = "abc-0" });
    
    tokenABC.ShouldNotBe(tokenabc); // Separate token entries
    tokenABC.Symbol.ShouldBe("ABC-0");
    tokenabc.Symbol.ShouldBe("abc-0");
    
    // Protocol invariant violated: case-insensitive uniqueness broken
}
```

## Notes

This vulnerability represents a critical inconsistency in token creation validation between normal and cross-chain paths. The fix is straightforward - applying the same `CheckTokenExists` validation used in `CreateToken` to `CrossChainCreateToken`. The impact is significant as it breaks a fundamental protocol invariant that all token operations assume.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L17-17)
```csharp
    public MappedState<string, bool> InsensitiveTokenExisting { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L19-20)
```csharp
    public MappedState<Address, string, long> Balances { get; set; }
    public MappedState<Address, Address, string, long> Allowances { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L232-233)
```csharp
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-408)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L87-88)
```csharp
        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-478)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L480-482)
```csharp
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L488-488)
```csharp
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-508)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```
