# Audit Report

## Title
Insufficient Threshold Validation in Referendum Contract Allows Creation of Permanently Non-Functional Governance Organizations

## Summary
The Referendum contract's `CreateOrganization` function lacks validation to ensure `ProposalReleaseThreshold` values are achievable relative to the token's total supply. This breaks consistency with Parliament and Association contracts, allowing creation of organizations that can never release proposals, causing temporary token locking for voters.

## Finding Description

The Referendum contract's validation logic is inconsistent with other governance contracts, creating a protocol-level invariant violation.

The Referendum `Validate` method only checks basic threshold relationships without verifying achievability: [1](#0-0) 

In contrast, Parliament validates that thresholds cannot exceed `AbstractVoteTotal` (set to 10000), ensuring mathematical achievability: [2](#0-1) [3](#0-2) 

Similarly, Association validates thresholds against the organization member count: [4](#0-3) 

When proposals are released, approval count is checked against the threshold: [5](#0-4) 

The approval count accumulates token allowances from voters: [6](#0-5) 

If `MinimalApprovalThreshold` exceeds the token's total supply, `proposal.ApprovalCount` can never reach the threshold. Token supply information is available but not validated: [7](#0-6) 

The `CreateOrganization` function is publicly accessible without authorization: [8](#0-7) 

## Impact Explanation

**Protocol Invariant Violation:**
The Referendum contract violates the established pattern that validated organizations should be operationally viable. Parliament and Association both enforce upper bounds on thresholds, demonstrating this is an intentional design requirement.

**Token Locking:**
Users who vote on proposals under organizations with impossibly high thresholds will have their tokens locked via `TransferFrom` until proposal expiration: [9](#0-8) 

Tokens can only be reclaimed after expiration: [10](#0-9) 

**Governance Deadlock Risk:**
If such an organization is adopted as a `MethodFeeController` or other governance authority through existing governance approval, it creates permanent protocol-level deadlock for that authority path.

## Likelihood Explanation

**Creation is Trivial:**
Any user can call `CreateOrganization` with arbitrary threshold values (e.g., `MinimalApprovalThreshold = 10^30`) that satisfy basic validation but exceed achievable token supplies.

**High Probability Scenarios:**
1. **Accidental Creation:** Users confusing absolute token amounts with percentage values (intending 67% but setting 10^18 against a token with 10^17 supply)
2. **Social Engineering:** Malicious actors creating broken organizations and convincing users to interact with them
3. **Integration Errors:** Systems programmatically creating referendum organizations with incorrect threshold calculations

**Actual Harm Requires Participation:**
While organization creation is permissionless, measurable impact requires users to create proposals and vote under the broken organization. However, this is a realistic scenario given that organizations passing validation are reasonably expected to be functional.

## Recommendation

Add validation to ensure thresholds are achievable relative to the token's total supply, consistent with Parliament and Association patterns:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    var tokenInfo = GetTokenInfo(organization.TokenSymbol);
    Assert(!string.IsNullOrEmpty(tokenInfo.Symbol), "Token not exists.");
    
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    
    // NEW: Validate thresholds against token total supply
    if (proposalReleaseThreshold.MinimalVoteThreshold > tokenInfo.TotalSupply ||
        proposalReleaseThreshold.MinimalApprovalThreshold > tokenInfo.TotalSupply ||
        proposalReleaseThreshold.MaximalAbstentionThreshold + 
            proposalReleaseThreshold.MinimalApprovalThreshold > tokenInfo.TotalSupply ||
        proposalReleaseThreshold.MaximalRejectionThreshold + 
            proposalReleaseThreshold.MinimalApprovalThreshold > tokenInfo.TotalSupply)
        return false;
    
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task CreateOrganization_With_Threshold_Exceeding_TotalSupply_Should_Fail()
{
    // Get token info to determine total supply
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
    {
        Symbol = "ELF"
    });
    
    // Create organization with threshold exceeding total supply
    var impossibleThreshold = tokenInfo.TotalSupply + 1;
    var createInput = new CreateOrganizationInput
    {
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = impossibleThreshold,
            MinimalVoteThreshold = impossibleThreshold,
            MaximalAbstentionThreshold = 0,
            MaximalRejectionThreshold = 0
        },
        TokenSymbol = "ELF",
        ProposerWhiteList = new ProposerWhiteList { Proposers = { DefaultSender } }
    };
    
    // This should fail but currently passes validation
    var result = await ReferendumContractStub.CreateOrganization.SendAsync(createInput);
    
    // Organization is created but will never be able to release proposals
    var organizationAddress = result.Output;
    var organization = await ReferendumContractStub.GetOrganization.CallAsync(organizationAddress);
    
    organization.ProposalReleaseThreshold.MinimalApprovalThreshold.ShouldBe(impossibleThreshold);
    // This organization is permanently broken - no proposal can ever be released
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L39-72)
```csharp
    private ReferendumReceiptCreated LockToken(string symbol, long amount, Hash proposalId, Address lockedAddress,
        Address organizationAddress)
    {
        Assert(State.LockedTokenAmount[lockedAddress][proposalId] == null, "Already locked.");

        var lockId = Context.GenerateId(Context.Self,
            HashHelper.ConcatAndCompute(proposalId, HashHelper.ComputeFrom(lockedAddress)));
        RequireTokenContractStateSet();
        Context.SendVirtualInline(proposalId, State.TokenContract.Value,
            nameof(TokenContractContainer.TokenContractReferenceState.TransferFrom), new TransferFromInput
            {
                From = Context.Sender,
                To = GetProposalVirtualAddress(proposalId),
                Symbol = symbol,
                Amount = amount,
                Memo = "Referendum."
            });
        State.LockedTokenAmount[Context.Sender][proposalId] = new Receipt
        {
            Amount = amount,
            LockId = lockId,
            TokenSymbol = symbol
        };

        return new ReferendumReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = proposalId,
            Amount = amount,
            Symbol = symbol,
            Time = Context.CurrentBlockTime,
            OrganizationAddress = organizationAddress
        };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-40)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");

        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;

        State.Organizations[organizationAddress] = organization;
        Context.Fire(new OrganizationCreated
        {
            OrganizationAddress = organizationAddress
        });

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L70-83)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.ApprovalCount = proposal.ApprovalCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Approve);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L115-122)
```csharp
    public override Empty ReclaimVoteToken(Hash input)
    {
        var proposal = State.Proposals[input];
        Assert(proposal == null ||
               Context.CurrentBlockTime >= proposal.ExpiredTime, "Unable to reclaim at this time.");
        UnlockToken(input, Context.Sender);
        return new Empty();
    }
```

**File:** protobuf/token_contract.proto (L250-273)
```text
message TokenInfo {
    // The symbol of the token.f
    string symbol = 1;
    // The full name of the token.
    string token_name = 2;
    // The current supply of the token.
    int64 supply = 3;
    // The total supply of the token.
    int64 total_supply = 4;
    // The precision of the token.
    int32 decimals = 5;
    // The address that has permission to issue the token.
    aelf.Address issuer = 6;
    // A flag indicating if this token is burnable.
    bool is_burnable = 7;
    // The chain id of the token.
    int32 issue_chain_id = 8;
    // The amount of issued tokens.
    int64 issued = 9;
    // The external information of the token.
    ExternalInfo external_info = 10;
    // The address that owns the token.
    aelf.Address owner = 11;
}
```
