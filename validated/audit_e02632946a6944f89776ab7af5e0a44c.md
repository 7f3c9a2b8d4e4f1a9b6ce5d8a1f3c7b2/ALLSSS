# Audit Report

## Title
BurnProfits Unconditionally Overwrites DistributedProfitsMap Causing Loss of Pre-Contributed Profits

## Summary
The `BurnProfits` function in the Profit contract creates a new `DistributedProfitsInfo` object without reading existing state and unconditionally overwrites the `DistributedProfitsMap` entry for a period. When users contribute profits to future periods via `ContributeProfits`, and the scheme later has zero `totalShares` when that period arrives, `BurnProfits` destroys the accounting record while the contributed tokens remain permanently locked in the period-specific virtual address.

## Finding Description

This vulnerability arises from the interaction between three operations in the Profit contract:

**Step 1: Future Period Contribution**

The `ContributeProfits` function explicitly allows contributions to future periods. [1](#0-0)  When users contribute to a future period, tokens are transferred to a period-specific virtual address. [2](#0-1)  The `DistributedProfitsMap` is updated to track this contribution. [3](#0-2) 

The period-specific virtual address is consistently generated using XOR of the scheme ID and period hash. [4](#0-3) 

**Step 2: Beneficiary Removal**

The scheme manager can legitimately remove all beneficiaries, causing `totalShares` to become zero. [5](#0-4) 

**Step 3: Critical Flaw in BurnProfits**

When `DistributeProfits` is called with `totalShares <= 0`, it invokes `BurnProfits`. [6](#0-5) 

The critical vulnerability is in the `BurnProfits` implementation. It creates a completely new `DistributedProfitsInfo` object without reading any existing state from `State.DistributedProfitsMap[profitsReceivingVirtualAddress]`. [7](#0-6)  It then burns tokens from the scheme's general ledger (not the period-specific address where pre-contributions were deposited) and unconditionally overwrites the state map, destroying any record of previously contributed profits. [8](#0-7) 

**Contrast with Correct Implementation**

The `UpdateDistributedProfits` function (used when `totalShares > 0`) demonstrates the correct approach: it reads the existing `DistributedProfitsMap` entry first using the null-coalescing operator, [9](#0-8)  queries the actual balance from the period-specific virtual address, [10](#0-9)  and adds this to the distributed amounts, thereby preserving any pre-contributions. [11](#0-10) 

**Prevention of Recovery**

After `BurnProfits` executes, it sets `IsReleased = true` in the new object. [12](#0-11)  The `ContributeProfits` function checks this flag and prevents further contributions to released periods. [13](#0-12) 

This creates a permanent loss scenario: the pre-contributed tokens remain in the period-specific virtual address, but the accounting record in `DistributedProfitsMap` either shows zero or negative amounts (from burned general ledger tokens), and the `IsReleased` flag prevents any correction. The `DistributedProfitsMap` state is defined to track distributed profits by address. [14](#0-13) 

## Impact Explanation

**Direct Financial Loss:**

This vulnerability causes permanent loss of user funds. When tokens are contributed to future periods and then `BurnProfits` is called, the contributed tokens become irrecoverable. The tokens physically exist in the period-specific virtual address but have no accounting record, and `ClaimProfits` cannot retrieve them because it reads from the destroyed `DistributedProfitsMap` entry. [15](#0-14) 

**Quantified Damage:**

The impact scales linearly with contribution amounts. For example:
- If 10,000 ELF tokens are contributed to period 5
- And the scheme has zero beneficiaries when period 5 arrives
- All 10,000 ELF become permanently locked with no recovery mechanism

**Affected Parties:**

1. **Users:** Anyone who contributes to future periods expecting normal profit distribution
2. **Scheme Managers:** May inadvertently trigger this when legitimately winding down schemes by removing beneficiaries
3. **Protocol:** Accumulates permanently locked tokens, reducing circulating supply and breaking accounting integrity

## Likelihood Explanation

**High Feasibility:**

This vulnerability can be triggered through entirely normal operations without requiring any special privileges beyond basic contract usage:

1. **Reachable Entry Point:** `ContributeProfits` is a public method callable by any user who has approved the contract to transfer their tokens. [16](#0-15) 

2. **Realistic Preconditions:**
   - A profit scheme exists (common operational state)
   - A user contributes to a future period, e.g., period 5 when current period is 1 (this is an explicitly supported feature as verified by the assertion)
   - Before period 5 arrives, the scheme manager removes all beneficiaries (legitimate when winding down schemes or restructuring)
   - The scheme manager calls `DistributeProfits` for period 5 (normal operation)

3. **Natural Occurrence:** This scenario naturally happens when:
   - Long-running schemes accept future contributions
   - Business circumstances change and schemes need to be wound down
   - The timing gap between contribution and distribution allows for legitimate beneficiary management changes

4. **No Attack Cost:** Beyond the contribution itself, there is no additional cost. A malicious actor could even grief others by contributing to future periods of schemes they control, then removing all beneficiaries.

5. **Detection Difficulty:** Both `ContributeProfits` and `RemoveBeneficiary` are legitimate operations. The loss only becomes apparent when users attempt to claim profits and discover they cannot recover their contributed funds.

## Recommendation

The `BurnProfits` function should read the existing `DistributedProfitsMap` entry before creating a new object, similar to how `UpdateDistributedProfits` correctly implements this pattern.

**Modified BurnProfits implementation:**

```csharp
private Empty BurnProfits(long period, Dictionary<string, long> profitsMap, Scheme scheme,
    Address profitsReceivingVirtualAddress)
{
    scheme.CurrentPeriod = period.Add(1);

    // READ existing state first (FIX)
    var distributedProfitsInfo = State.DistributedProfitsMap[profitsReceivingVirtualAddress] 
        ?? new DistributedProfitsInfo();
    
    distributedProfitsInfo.IsReleased = true;
    
    foreach (var profits in profitsMap)
    {
        var symbol = profits.Key;
        var amount = profits.Value;
        if (amount > 0)
        {
            var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = scheme.VirtualAddress,
                Symbol = symbol
            });
            if (balanceOfToken.Balance < amount)
                continue;
            Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                nameof(State.TokenContract.Transfer), new TransferInput
                {
                    To = Context.Self,
                    Amount = amount,
                    Symbol = symbol
                }.ToByteString());
            State.TokenContract.Burn.Send(new BurnInput
            {
                Amount = amount,
                Symbol = symbol
            });
            
            // ADD to existing amount instead of replacing (FIX)
            if (distributedProfitsInfo.AmountsMap.ContainsKey(symbol))
            {
                distributedProfitsInfo.AmountsMap[symbol] = 
                    distributedProfitsInfo.AmountsMap[symbol].Sub(amount);
            }
            else
            {
                distributedProfitsInfo.AmountsMap.Add(symbol, -amount);
            }
        }
    }

    State.SchemeInfos[scheme.SchemeId] = scheme;
    State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
    return new Empty();
}
```

This ensures that pre-contributed amounts in the `AmountsMap` are preserved and adjusted correctly when burning profits, rather than being completely overwritten.

## Proof of Concept

A complete test demonstrating this vulnerability would involve:

1. Creating a profit scheme
2. Adding beneficiaries
3. Having a user call `ContributeProfits` with a future period (e.g., period 5)
4. Removing all beneficiaries (making `totalShares = 0`)
5. Calling `DistributeProfits` for that future period
6. Verifying that the `DistributedProfitsMap` entry no longer contains the contributed amounts
7. Verifying that tokens remain locked in the period-specific virtual address
8. Attempting to claim profits and observing the failure

The test would demonstrate that after step 5, the accounting record is destroyed while tokens remain permanently locked in the virtual address with no recovery mechanism.

## Notes

This vulnerability represents a critical accounting integrity failure in the Profit contract's distribution mechanism. The bug specifically affects the interaction between future period contributions and the burn-profits path when schemes have zero shares. The fix requires reading existing state before overwriting, following the same pattern already correctly implemented in `UpdateDistributedProfits`.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L260-260)
```csharp
        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L522-525)
```csharp
        var distributedProfitsInfo = new DistributedProfitsInfo
        {
            IsReleased = true
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L539-556)
```csharp
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
                distributedProfitsInfo.AmountsMap.Add(symbol, -amount);
            }
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;
        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L563-565)
```csharp
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L574-578)
```csharp
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L579-579)
```csharp
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-651)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L684-684)
```csharp
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L688-712)
```csharp
            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L866-871)
```csharp
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L57-60)
```csharp
    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L11-11)
```csharp
    public MappedState<Address, DistributedProfitsInfo> DistributedProfitsMap { get; set; }
```
