# Audit Report

## Title
Insufficient Round Validation Allows Consensus Schedule Manipulation via Arbitrary Time Slot Assignments

## Summary
The AEDPoS consensus validation fails to verify that proposed next round information matches the deterministic output of `GenerateNextRoundInformation`. Validators only check structural properties (equal intervals, round number increments) without regenerating and comparing the expected round, allowing malicious miners to craft arbitrary consensus schedules that pass all validation checks.

## Finding Description

When a miner produces a NextRound block, the validation system distinguishes between `BaseRound` (trusted on-chain state) and `ProvidedRound` (attacker-controlled header data). [1](#0-0) 

The legitimate next round should be generated deterministically by `GenerateNextRoundInformation`, which assigns `Order` values based on each miner's `FinalOrderOfNextRound` from the current round and calculates `ExpectedMiningTime` accordingly. [2](#0-1) 

However, the actual validation performed is insufficient:

**TimeSlotValidationProvider** only validates structural consistency through `CheckRoundTimeSlots()`, which checks that intervals are equal and mining times are valid, but does NOT compare order assignments. [3](#0-2) 

The structural check only verifies equal time slots. [4](#0-3) 

**RoundTerminateValidationProvider** only checks round number increment and null InValues. [5](#0-4) 

**NextRoundMiningOrderValidationProvider** only checks that the count of distinct orders equals the count of miners who produced blocks, but does NOT validate that specific order assignments match `BaseRound.FinalOrderOfNextRound` values. [6](#0-5) 

These validators are registered for NextRound behavior but perform no comparison between expected and provided order assignments. [7](#0-6) 

After validation passes, `ProcessNextRound` directly converts the input to a Round object and stores it to state without any comparison to a regenerated expected round. [8](#0-7) 

The `ValidateConsensusAfterExecution` method retrieves the round from state AFTER it was already stored by `ProcessNextRound`, making it compare the malicious data against itself. [9](#0-8) 

## Impact Explanation

This vulnerability breaks the core AEDPoS consensus invariant that miner schedules must be deterministically generated based on current round state. An attacker can:

1. **Manipulate Block Production Order**: Assign themselves order 1 (first producer) regardless of their `FinalOrderOfNextRound` value to maximize block production frequency and MEV opportunities
2. **Unfair Time Slot Distribution**: Create schedules favoring their mining operations while disadvantaging competitors  
3. **Consensus Integrity Violation**: The deterministic fairness guarantee of AEDPoS is completely bypassed

The deterministic generation logic that should be enforced assigns orders based on `FinalOrderOfNextRound` values calculated from miners' signatures during the current round. [10](#0-9) 

**Severity: CRITICAL** - Direct consensus manipulation affecting all network participants and undermining the fundamental fairness guarantees of the protocol.

## Likelihood Explanation

**Attack Prerequisites**:
- Attacker must be a valid miner (normal participant requirement)
- Attacker must be producing the extra block that triggers NextRound (rotates among all miners per round)
- Craft malicious round with valid structure but arbitrary order assignments

**Execution Steps**:
1. Read current BaseRound (round N) from state, which contains `FinalOrderOfNextRound` values for each miner
2. Craft ProvidedRound (round N+1) with RoundNumber = N+1, same pubkeys, equal 4000ms intervals, but arbitrary `Order` assignments (e.g., assign attacker Order=1)
3. Include malicious round in block header consensus extra data
4. Block passes validation (structural checks only, no comparison to deterministic generation)
5. Malicious round stored to state via `ProcessNextRound`

**Probability: HIGH** - Any miner can execute this attack when their turn to produce the NextRound extra block arrives, requiring only standard miner capabilities and no special privileges.

## Recommendation

Add a validation provider that regenerates the expected next round using `GenerateNextRoundInformation` and compares it against the provided round:

```csharp
public class NextRoundDeterministicValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        if (validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextRound)
            return new ValidationResult { Success = true };
            
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        
        // Regenerate expected round deterministically
        baseRound.GenerateNextRoundInformation(
            Context.CurrentBlockTime, 
            GetBlockchainStartTimestamp(), 
            out var expectedRound);
            
        // Compare order assignments
        foreach (var miner in expectedRound.RealTimeMinersInformation)
        {
            if (!providedRound.RealTimeMinersInformation.ContainsKey(miner.Key))
                return new ValidationResult { Message = $"Missing miner {miner.Key}" };
                
            if (providedRound.RealTimeMinersInformation[miner.Key].Order != miner.Value.Order)
                return new ValidationResult { 
                    Message = $"Order mismatch for {miner.Key}: expected {miner.Value.Order}, got {providedRound.RealTimeMinersInformation[miner.Key].Order}" 
                };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Register this provider in `ValidateBeforeExecution` for NextRound behavior.

## Proof of Concept

Due to the complexity of the AEDPoS consensus system requiring full blockchain context, miner list initialization, and round state setup, a complete executable test would require substantial test infrastructure. However, the vulnerability can be demonstrated by examining the validation flow:

1. Create a BaseRound with miners having specific `FinalOrderOfNextRound` values (e.g., MinerA=3, MinerB=1, MinerC=2)
2. Craft a ProvidedRound with arbitrary orders (e.g., MinerA=1, MinerB=2, MinerC=3) but maintaining equal intervals
3. Execute `ValidateBeforeExecution` with this ProvidedRound
4. Observe that validation passes despite order assignments not matching deterministic generation
5. Execute `ProcessNextRound` and confirm malicious round is stored to state

The key proof point is that no code path compares `BaseRound.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound` against `ProvidedRound.RealTimeMinersInformation[pubkey].Order`, as confirmed by code analysis.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L19-27)
```csharp
    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```
