# Audit Report

## Title
Missing Option Length Validation in Vote Contract Registration Allows Permanent Storage Bloat

## Summary
The `Register()` function in the Vote contract does not validate the length of individual option strings when creating a voting item, while `AddOption()`, `AddOptions()`, `RemoveOption()`, and `Vote()` all enforce the 1024-character limit. This inconsistency allows attackers to register voting items with arbitrarily long option strings, causing permanent blockchain storage bloat that cannot be cleaned up.

## Finding Description

The vulnerability exists in the `Register()` function where options are directly copied from input without any length validation. [1](#0-0) 

The validation helper `AssertValidNewVotingItem()` called during registration only validates timestamps and voting item uniqueness, but does not check option lengths. [2](#0-1) 

In contrast, the `AssertOption()` validation function enforces the 1024-character limit defined in the contract constants. [3](#0-2) [4](#0-3) 

The `AddOption()` function enforces the length limit through `AssertOption()`. [5](#0-4) 

The `RemoveOption()` function enforces the length limit **before** checking if the option exists, which creates a permanent lock situation where oversized options cannot be removed. [6](#0-5) 

The `Vote()` function validates option length through `AssertValidVoteInput()`, preventing votes on oversized options. [7](#0-6) 

This inconsistency breaks the contract's intended invariant that all options must be â‰¤ 1024 characters. Once an oversized option is registered, it creates a permanent inconsistent state because:
1. The option exists in storage
2. It cannot be voted on (Vote validates length at line 380)
3. It cannot be removed (RemoveOption validates length at line 307 before checking existence at line 308)

## Impact Explanation

**Storage Bloat**: An attacker can register voting items with option strings containing millions of characters, consuming excessive blockchain storage that all nodes must maintain permanently.

**Permanent Pollution**: The oversized options become permanently stuck in the blockchain state. To remove an option, the sponsor must provide the exact string to `RemoveOption()`, but if the string exceeds 1024 characters, the transaction fails at the length validation check before even checking if the option exists.

**Useless Voting Items**: The voting items become non-functional because users cannot vote for the oversized options, and the sponsor cannot clean up the options. The voting item persists in storage but serves no purpose.

**Cost to Network**: This is a griefing attack vector where malicious actors can bloat the blockchain state at relatively low cost (only transaction fees), affecting all node operators who must store this data permanently. The impact scales with the number of oversized options registered.

## Likelihood Explanation

**Reachable Entry Point**: The `Register()` function is a public method callable by any user. [8](#0-7) 

**Low Preconditions**: The only requirement is that the accepted currency token must be in the whitelist. [9](#0-8)  For common tokens like the native token, this requirement is trivially satisfied.

**Simple Execution**: An attacker simply needs to:
1. Prepare a `VotingRegisterInput` with valid timestamps and accepted currency
2. Include one or more option strings exceeding 1024 characters
3. Call `Register()` 
4. Pay only the standard transaction fee

**No Detection**: The `AssertValidNewVotingItem()` helper only validates voting item uniqueness and timestamps - there is no check that would prevent or detect oversized options before they are permanently stored.

## Recommendation

Add option length validation in the `Register()` function before storing the voting item. The fix should iterate through all options and validate each one against the length limit:

```csharp
// In Register() method, after line 22 (AssertValidNewVotingItem call)
foreach (var option in input.Options)
{
    Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid option length.");
}
```

Alternatively, call `AssertOption()` for each option during registration to maintain consistency with other methods that modify options.

## Proof of Concept

```csharp
[Fact]
public async Task Register_WithOversizedOptions_ShouldSucceed()
{
    // Create an oversized option string (>1024 characters)
    var oversizedOption = new string('A', 2000);
    
    // Register voting item with oversized option
    var registerInput = new VotingRegisterInput
    {
        StartTimestamp = TimestampHelper.GetUtcNow(),
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(7),
        AcceptedCurrency = "ELF", // Assuming ELF is whitelisted
        IsLockToken = true,
        TotalSnapshotNumber = 1,
        Options = { oversizedOption }
    };
    
    // This should fail but doesn't - demonstrating the vulnerability
    await VoteContractStub.Register.SendAsync(registerInput);
    
    // Verify the voting item was created with oversized option
    var votingItemId = registerInput.GetHash(DefaultSender);
    var votingItem = await VoteContractStub.GetVotingItem.CallAsync(
        new GetVotingItemInput { VotingItemId = votingItemId });
    
    Assert.True(votingItem.Options[0].Length > VoteContractConstants.OptionLengthLimit);
    
    // Demonstrate the option cannot be removed
    var removeResult = await VoteContractStub.RemoveOption.SendWithExceptionAsync(
        new RemoveOptionInput
        {
            VotingItemId = votingItemId,
            Option = oversizedOption
        });
    
    // This fails due to length validation, proving permanent lock
    Assert.Contains("Invalid input", removeResult.TransactionResult.Error);
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-20)
```csharp
    public override Empty Register(VotingRegisterInput input)
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L29-34)
```csharp
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L49-49)
```csharp
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L280-290)
```csharp
    public override Empty AddOption(AddOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        AssertOption(votingItem, input.Option);
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        votingItem.Options.Add(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L292-296)
```csharp
    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L303-312)
```csharp
    public override Empty RemoveOption(RemoveOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
        votingItem.Options.Remove(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L6-6)
```csharp
    public const int OptionLengthLimit = 1024;
```
