# Audit Report

## Title
Removed Proposers Retain Proposal Release Authority in Governance Contracts

## Summary
The Association, Parliament, and Referendum governance contracts fail to re-validate proposer whitelist membership when releasing proposals. Proposers removed from the whitelist after creating proposals can still execute those proposals once approved, violating the security model that whitelist removal should revoke all governance permissions.

## Finding Description

This vulnerability exists in the proposal release authorization logic across all three governance contracts, creating a Time-of-Check-Time-of-Use (TOCTOU) access control issue.

**At Proposal Creation:**

When creating a proposal in the Association contract, the `CreateProposal` method validates proposer whitelist membership [1](#0-0) . This check is performed by `AssertIsAuthorizedProposer`, which verifies the proposer is in the organization's `ProposerWhiteList` [2](#0-1) . The proposal then permanently stores the proposer's address [3](#0-2) .

**Whitelist Modification:**

Organizations can remove proposers from the whitelist via `ChangeOrganizationProposerWhiteList`, which updates the organization's ProposerWhiteList [4](#0-3) .

**At Proposal Release:**

When releasing a proposal, the `Release` method only verifies that the caller matches the originally stored proposer address, with no re-validation of ProposerWhiteList membership [5](#0-4) . The authorization check at line 186 only compares `Context.Sender == proposalInfo.Proposer` without consulting the current whitelist state.

**Affected Contracts:**

This pattern is consistent across all three governance contracts:
- Parliament contract exhibits identical behavior with whitelist check at creation [6](#0-5)  but only proposer address check at release [7](#0-6) 
- Referendum contract exhibits identical behavior with whitelist check at creation [8](#0-7)  but only proposer address check at release [9](#0-8) 

The security invariant violation occurs because whitelist removal is expected to revoke ALL governance permissions, but the Release authorization check creates an exception that allows removed proposers to retain execution authority.

## Impact Explanation

**Governance Authority Bypass:**
Organizations remove proposers from whitelists to revoke their authority, typically due to security concerns (compromised accounts), organizational changes, or loss of trust. Despite removal, these proposers retain the ability to execute approved proposals, creating a persistent attack surface.

**Attack Scenarios:**
1. **Malicious Batch Proposals**: A proposer creates multiple proposals, some approved without thorough review. After removal for suspicious behavior, they can still release approved malicious proposals.
2. **Compromised Accounts**: If a proposer's account is compromised after proposal approval but before release, the attacker can execute proposals at strategically chosen times (e.g., when treasury balances peak, during governance transitions).
3. **Timing Manipulation**: Removed proposers can delay release execution to exploit specific blockchain states or market conditions.

**Impact Assessment: Medium**
- Direct unauthorized proposal execution after privilege revocation
- Violates governance security model and access control invariants
- Constraint: Proposals must meet approval thresholds, limiting immediate exploitation but not preventing strategic timing attacks
- Scope: System-wide across all three governance contracts

## Likelihood Explanation

**Attacker Prerequisites:**
- Must initially be authorized proposer (realistic - whitelists include multiple members)
- Must create proposals that achieve approval thresholds (requires member support but feasible through normal governance processes)
- Must be subsequently removed from whitelist (common in governance evolution for security or organizational reasons)

**Execution Complexity:**
- Low - straightforward sequence: create proposal → obtain approval → get removed → call Release()
- No complex state manipulation or precise timing required for the exploit itself
- Entry point is publicly accessible Release() method

**Realistic Preconditions:**
- Organizations frequently adjust proposer whitelists for security and operational reasons
- Proposal approval occurs through standard voting mechanisms
- Long proposal expiration periods create extended windows for exploitation
- No special privileges needed beyond initial whitelist membership

**Likelihood Assessment: Medium**
The vulnerability has medium likelihood because all preconditions represent normal governance operations. Risk increases in organizations with frequent whitelist changes, multiple concurrent proposals, and limited proposal review processes.

## Recommendation

Add whitelist re-validation in the `Release` method for all three governance contracts. The fix should check current whitelist membership before allowing proposal execution:

**For Association Contract:**
```csharp
public override Empty Release(Hash input)
{
    var proposalInfo = GetValidProposal(input);
    Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
    
    // Add whitelist re-validation
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(organization.ProposerWhiteList.Contains(Context.Sender), "Proposer no longer authorized.");
    
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    // ... rest of execution
}
```

Apply the same pattern to Parliament and Referendum contracts, adapting for Parliament's additional authorization modes (ProposerAuthorityRequired and ParliamentMemberProposingAllowed flags).

## Proof of Concept

```csharp
[Fact]
public async Task RemovedProposer_CanStillReleaseProposal()
{
    // Setup: Create organization with proposer in whitelist
    var proposer = Accounts[1].Address;
    var organization = await CreateOrganizationWithWhitelist(new[] { proposer });
    
    // Step 1: Proposer creates proposal (whitelist checked - passes)
    var proposalId = await CreateProposalAsProposer(organization, proposer);
    
    // Step 2: Proposal gets approved by organization members
    await ApproveProposal(proposalId, organization);
    
    // Step 3: Organization removes proposer from whitelist
    await RemoveProposerFromWhitelist(organization, proposer);
    
    // Step 4: Verify proposer is no longer in whitelist
    var whitelistCheck = await AssociationContractStub.ValidateProposerInWhiteList.CallAsync(
        new ValidateProposerInWhiteListInput 
        { 
            OrganizationAddress = organization, 
            Proposer = proposer 
        });
    Assert.False(whitelistCheck.Value); // Proposer removed
    
    // Step 5: VULNERABILITY - Removed proposer can still release proposal
    var result = await ReleaseProposalAsProposer(proposalId, proposer);
    Assert.True(result.Success); // Should fail but succeeds
}
```

## Notes

This is a classic Time-of-Check-Time-of-Use (TOCTOU) vulnerability in access control logic. The authorization check performed at proposal creation time becomes stale when the whitelist is modified, but the release operation trusts the original check without re-validation. This violates the principle that access control decisions should always use current authorization state, not cached or historical state.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L109-109)
```csharp
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L157-157)
```csharp
            Proposer = Context.Sender,
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```
