# Audit Report

## Title
Missing Miner List Validation in NextTerm Allows Consensus Takeover Through Arbitrary Miner Selection

## Summary
The `NextTerm` consensus transaction processing lacks validation that the miner list in `NextTermInput` matches election results from `GetVictories`. A malicious current miner can submit a crafted `NextTermInput` with an arbitrary miner list that passes validation (which only checks term/round number increments), allowing them to bypass the election mechanism and seize permanent control of consensus by excluding legitimately elected miners.

## Finding Description

The vulnerability exists in the validation and processing flow for term transitions in the AEDPoS consensus contract.

**Insufficient Validation:**

The `ValidationForNextTerm` method only validates term and round number increments but does not verify the miner list against election results. [1](#0-0) 

When `NextTerm` consensus transactions are validated via `ValidateConsensusBeforeExecution`, only the `RoundTerminateValidationProvider` is added for NextTerm behavior. [2](#0-1) 

**Unverified Miner List Acceptance:**

The `ProcessNextTerm` method extracts the miner list directly from the input's `RealTimeMinersInformation.Keys` and sets it via `SetMinerList` without any verification against election results. [3](#0-2) 

The `SetMinerList` function only checks if the term's miner list hasn't been set previously, performing no validation against election results. [4](#0-3) 

**Contrast with Legitimate Flow:**

The legitimate term generation process calls `GenerateFirstRoundOfNextTerm`, which queries election results via `TryToGetVictories` to obtain the correct miner list from the Election contract. [5](#0-4) 

However, this election verification only occurs when generating consensus data, not during validation of submitted `NextTermInput`. [6](#0-5) 

**Why Existing Protections Fail:**

The `PreCheck` permission verification only confirms the sender is in the current or previous miner list, which a malicious miner already satisfies. [7](#0-6) 

The `NextTerm` method is publicly callable with any crafted input structure. [8](#0-7) 

## Impact Explanation

**Severity: Critical - Complete Consensus Takeover**

A successful exploit achieves:

1. **Consensus Control**: The attacker can construct a miner list containing only themselves or colluding parties, gaining permanent control over all future block production
2. **Election Bypass**: Completely circumvents the democratic election mechanism where token holders vote for miners, rendering all voting meaningless
3. **Governance Manipulation**: Controls future governance by monopolizing block production and proposal submission
4. **Transaction Censorship**: Can selectively exclude transactions or manipulate block contents without competing miners
5. **Economic Disruption**: Monopolizes mining rewards that should be distributed based on election results

This breaks the fundamental security invariant that "miner lists for each term must correspond to election results" and destroys the integrity of the consensus mechanism. All token holders who voted, legitimately elected candidates, DApps, and users are affected.

## Likelihood Explanation

**High Likelihood - Simple Exploitation**

**Attacker Prerequisites:**
- Must be a current miner (obtainable through legitimate election initially)
- Ability to produce blocks and submit transactions
- No special cryptographic knowledge or computational resources required

**Attack Steps:**
1. Wait until `NeedToChangeTerm` conditions are met (2/3 of miners' mining times exceed the term period) [9](#0-8) 
2. Craft a `NextTermInput` with correct term/round numbers but a malicious miner list using `NextTermInput.Create` structure [10](#0-9) 
3. Submit transaction to the public `NextTerm` method
4. Validation passes (only checks numeric increments)
5. Malicious miner list is accepted and stored as the new consensus

**Exploitation Feasibility:**
- Single transaction required
- No race conditions or timing complexities  
- Deterministic validation checks easily satisfied
- Detection difficult as transaction appears structurally valid

The risk/reward ratio heavily favors attack execution: minimal cost (one transaction fee) versus massive benefit (permanent consensus control and reward monopolization).

## Recommendation

Add validation in `ValidationForNextTerm` to verify the miner list against election results:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Existing term number check
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };

    // NEW: Validate miner list against election results
    var expectedMiners = GetVictoriesFromElection(); // Call Election contract
    var providedMiners = extraData.Round.RealTimeMinersInformation.Keys;
    
    if (!AreMinerListsEqual(expectedMiners, providedMiners))
        return new ValidationResult { Message = "Miner list does not match election results." };

    return new ValidationResult { Success = true };
}
```

Alternatively, add the check in `ProcessNextTerm` before calling `SetMinerList`, querying the Election contract's `GetVictories` and asserting the provided miner list matches.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task MaliciousMinerCanSetArbitraryMinerListDuringNextTerm()
{
    // Setup: Initialize chain with legitimate miners
    var legitimateMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusWithMiners(legitimateMiners);
    
    // Election contract elects new miners for next term
    var electedMiners = new[] { "elected1", "elected2", "elected3" };
    await ElectionContract.SetVictories(electedMiners);
    
    // Attacker (current miner1) crafts malicious NextTermInput
    var maliciousMinerList = new[] { "miner1", "attacker_colluder1", "attacker_colluder2" };
    var maliciousInput = CreateNextTermInput(
        termNumber: 2,
        roundNumber: 1, 
        minerList: maliciousMinerList // DIFFERENT from election results!
    );
    
    // Submit malicious NextTerm transaction as miner1
    await ConsensusContract.NextTerm.SendAsync(miner1Keypair, maliciousInput);
    
    // Verify: Malicious miner list was accepted instead of election results
    var actualMinerList = await ConsensusContract.GetMinerList.CallAsync(new GetMinerListInput { TermNumber = 2 });
    
    // This should fail but passes - showing the vulnerability
    Assert.Equal(maliciousMinerList, actualMinerList.Pubkeys); // PASSES - vulnerability confirmed
    Assert.NotEqual(electedMiners, actualMinerList.Pubkeys); // Election results ignored!
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-190)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```
