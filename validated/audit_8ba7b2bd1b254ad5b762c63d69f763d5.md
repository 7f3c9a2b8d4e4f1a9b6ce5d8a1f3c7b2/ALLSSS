# Audit Report

## Title
NFT Burn Function Allows Negative Amounts to Inflate Balances and Bypass Supply Limits

## Summary
The NFT contract's `Burn` function accepts negative amounts without validation, allowing authorized minters to arbitrarily inflate token balances and supply counters by calling burn with negative values. This completely breaks the token supply invariant and enables unlimited token creation beyond the protocol's `TotalSupply` limit.

## Finding Description

The vulnerability exists in the `Burn` method where `input.Amount` is a signed `int64` field that can accept negative values. [1](#0-0) 

The method performs a balance check that only verifies the current balance is greater than or equal to the input amount. When the amount is negative (e.g., -100), this check passes because any non-negative balance is greater than a negative number (e.g., `0 >= -100` evaluates to true). [2](#0-1) 

Subsequently, three critical state updates use the `Sub` extension method which performs simple arithmetic subtraction. [3](#0-2)  The `Sub` method is implemented as `return a - b` in a checked context. [4](#0-3) 

When subtracting a negative value, this actually increases the balance: `balance.Sub(-100)` = `balance - (-100)` = `balance + 100`. This applies to the caller's balance, the protocol's supply counter, and the NFT's quantity counter.

The vulnerability is evident when comparing to the `DoTransfer` method, which explicitly validates against negative amounts. [5](#0-4)  Additionally, the MultiToken contract's Burn implementation validates amounts using `AssertValidToken` which internally checks `Assert(amount > 0, "Invalid amount.")`. [6](#0-5)  The NFT Burn method lacks both of these critical validations.

## Impact Explanation

This represents **HIGH severity** with direct fund impact:

1. **Unlimited Token Creation**: A minter can inflate their balance arbitrarily by calling Burn with large negative amounts (e.g., -1,000,000), effectively minting unlimited tokens
2. **Bypass Supply Caps**: The `nftProtocolInfo.Supply` counter is inflated alongside balances, allowing token creation beyond the protocol's `TotalSupply` limit set during creation
3. **Broken Accounting Invariants**: The fundamental invariant that `Supply = sum of all balances` is violated, corrupting the protocol's token economics
4. **Privilege Escalation**: While minters are semi-trusted roles, they are NOT intended to have unlimited minting power or the ability to bypass supply caps - this violates the expected privilege boundaries

The minter role is a common authorization in NFT systems (for legitimate minting operations), making this not a theoretical concern but a practical vulnerability in the trust model.

## Likelihood Explanation

**HIGH likelihood** due to:

**Minimal Prerequisites:**
- Must be in the minter list for the NFT protocol (common role that protocol creators routinely grant)
- NFT protocol must have `IsBurnable` set to true (standard feature for NFT protocols)

**Trivial Execution:**
- Requires only a single transaction: `Burn(symbol, tokenId, -1000000)`
- No complex setup or timing requirements
- No need for multiple transactions or state manipulation

**Fully Practical:**
- The protobuf message definition accepts signed `int64`, so negative values are valid input
- No runtime or contract-level validation prevents negative amounts from reaching the arithmetic operations
- Transaction costs are negligible compared to the value of minting unlimited tokens

**Detection Limitations:**
- While the `Burned` event would emit a negative amount (making it theoretically detectable), the state corruption occurs immediately and irreversibly before any monitoring can respond

## Recommendation

Add explicit validation for negative amounts at the beginning of the `Burn` method, consistent with the `DoTransfer` method's approach:

```csharp
public override Empty Burn(BurnInput input)
{
    // Add this validation at the start
    Assert(input.Amount > 0, "Invalid burn amount.");
    
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    // ... rest of existing implementation
}
```

Alternatively, follow the MultiToken contract pattern by creating a shared `AssertValidAmount` helper method that validates `amount > 0` and reuse it across all amount-sensitive operations (Burn, Transfer, Mint, etc.).

## Proof of Concept

```csharp
[Fact]
public async Task BurnWithNegativeAmount_InflatesBalance()
{
    // Setup: Create NFT protocol and mint initial token
    var symbol = await CreateTest(); // Creates burnable NFT protocol
    await AddMinterAsync(symbol);
    
    await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        Quantity = 100,
        Owner = MinterAddress
    });
    
    var initialBalance = (await MinterNFTContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = MinterAddress, Symbol = symbol, TokenId = 1 })).Balance;
    initialBalance.ShouldBe(100);
    
    var initialProtocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(
        new StringValue { Value = symbol });
    var initialSupply = initialProtocolInfo.Supply;
    initialSupply.ShouldBe(100);
    
    // Exploit: Call Burn with negative amount
    var result = await MinterNFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        TokenId = 1,
        Amount = -1000000 // Negative amount
    });
    
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Balance increased instead of decreased
    var finalBalance = (await MinterNFTContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = MinterAddress, Symbol = symbol, TokenId = 1 })).Balance;
    finalBalance.ShouldBe(1000100); // 100 + 1000000 = inflated!
    
    // Verify: Supply increased, bypassing TotalSupply limit
    var finalProtocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(
        new StringValue { Value = symbol });
    var finalSupply = finalProtocolInfo.Supply;
    finalSupply.ShouldBe(1000100); // Supply inflated beyond initial TotalSupply
}
```

---

## Notes

This vulnerability demonstrates a critical inconsistency in input validation across the NFT contract. While `DoTransfer` properly validates against negative amounts and the MultiToken contract's Burn validates with `AssertValidToken`, the NFT contract's Burn method lacks this essential check. The combination of signed integer input types, insufficient validation, and the mathematical properties of subtraction creates a severe supply inflation vulnerability that fundamentally breaks the NFT protocol's token economics.

### Citations

**File:** protobuf/nft_contract.proto (L182-186)
```text
message BurnInput {
    string symbol = 1;
    int64 token_id = 2;
    int64 amount = 3;
}
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-48)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L90-93)
```csharp
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L94-96)
```csharp
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-97)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```
