# Audit Report

## Title
Empty Pubkey Candidate Registration Causes Consensus Failure During Term Transition

## Summary
The Election Contract's `AnnounceElectionFor` method lacks validation to prevent registration of empty pubkey strings. When an empty pubkey candidate accumulates sufficient votes and is elected as a miner, the subsequent term transition fails with an `IndexOutOfRangeException` in `GenerateFirstRoundOfNewTerm`, causing complete blockchain consensus halt.

## Finding Description

The vulnerability exists in the candidate registration flow where pubkey strings are converted to byte arrays without length validation.

In `AnnounceElectionFor`, the input pubkey string is directly converted to a byte array without any validation that the string is non-empty. [1](#0-0) 

When the pubkey is an empty string, `ByteArrayHelper.HexStringToByteArray("")` returns an empty byte array because the method calculates `bytes = new byte[0]` when the hex string length is zero. [2](#0-1) 

This empty byte array is then passed to the internal `AnnounceElection` method, which creates an empty `ByteString` via `ByteString.CopyFrom(pubkeyBytes)` and adds it to the candidates list without any length validation. [3](#0-2) 

The validation checks in `AnnounceElection` verify initial miner status (line 149-150), duplicate announcements (line 154-157), and banned status (line 165), but critically omit pubkey length validation.

During term transitions, the Consensus Contract queries for the new miner list via `GetVictories`. [4](#0-3)  If the empty pubkey candidate has accumulated sufficient votes to rank in the top N candidates, it will be included in the returned victories based solely on vote count sorting (line 79-81).

The Consensus Contract then calls `GenerateFirstRoundOfNewTerm` which retrieves victories from the Election Contract and generates the first round. [5](#0-4) 

The `GenerateFirstRoundOfNewTerm` function in `MinerList` attempts to sort miners by accessing the first byte of each pubkey with the expression `miner[0]` in the dictionary selector. [6](#0-5) 

When `miner` is an empty `ByteString` (length = 0), the indexing operation `miner[0]` throws an `IndexOutOfRangeException`, crashing the term generation process and halting the blockchain's consensus mechanism.

## Impact Explanation

This vulnerability enables a complete denial of service of the blockchain's consensus mechanism with the following impacts:

**Direct Harm:**
- The blockchain cannot transition to new terms, preventing miner list updates
- Block production halts when the exception is thrown during term transition
- All consensus-dependent operations (block validation, finalization, cross-chain communication) become impossible

**Protocol Damage:**
- Indefinite blockchain freeze requiring emergency intervention or hard fork
- Loss of network liveness and availability for all users
- Economic losses from halted transactions and frozen funds
- Severe reputational damage to the blockchain network

**Affected Parties:**
- All network participants (users, dApps, validators)
- The entire AElf mainchain or affected sidechain

This is classified as **HIGH severity** because it completely disables the consensus mechanism, affects the entire network, and requires emergency measures to resolve.

## Likelihood Explanation

The attack has **MEDIUM likelihood** due to the following factors:

**Attacker Capabilities Required:**
1. Lock 100,000 ELF tokens as candidate registration deposit
2. Acquire or coordinate sufficient voting power to place the empty pubkey in the top N miners (typically requires millions of locked ELF tokens depending on network participation)

**Attack Complexity:**
- **Low technical complexity**: Single contract call to register empty pubkey, standard voting operations
- **High economic cost**: Requires substantial capital (100K ELF deposit + significant voting power)
- **Medium coordination**: Can be executed by a single wealthy actor or requires coordinating multiple voters

**Feasibility Conditions:**
- Entry point is publicly accessible via `AnnounceElectionFor`
- No technical barriers prevent the attack
- Economic barrier is high but feasible for well-funded attackers
- One-time cost can cause persistent DoS until fixed
- Attack becomes obvious only during term transition when blockchain halts

The combination of unrestricted entry point, lack of validation, and feasible economic requirements for sophisticated attackers justifies a MEDIUM likelihood assessment.

## Recommendation

Add pubkey length validation in the `AnnounceElection` method immediately after converting the hex string to bytes:

```csharp
private void AnnounceElection(byte[] pubkeyBytes)
{
    // Add validation for empty pubkey
    Assert(pubkeyBytes != null && pubkeyBytes.Length > 0, "Invalid pubkey: cannot be empty.");
    
    var pubkey = pubkeyBytes.ToHex();
    var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);
    
    // ... rest of existing validation
}
```

Additionally, consider adding validation in `AnnounceElectionFor` before calling the internal method to fail fast and provide clearer error messages to users.

## Proof of Concept

```csharp
[Fact]
public async Task EmptyPubkey_CausesConsensusFailure_Test()
{
    // Step 1: Register empty pubkey candidate
    var emptyPubkey = "";
    var admin = DefaultSender;
    
    // Lock 100K ELF tokens
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = ElectionContractAddress,
        Symbol = "ELF",
        Amount = 100_000_00000000
    });
    
    // Register candidate with empty pubkey
    var announceResult = await ElectionContractStub.AnnounceElectionFor.SendAsync(
        new AnnounceElectionForInput
        {
            Pubkey = emptyPubkey,
            Admin = admin
        });
    announceResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 2: Vote for empty pubkey candidate to get it elected
    await VoteForCandidate(emptyPubkey, 10_000_000_00000000); // Large vote amount
    
    // Step 3: Trigger term transition
    // This should throw IndexOutOfRangeException when trying to access miner[0]
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
        // Generate first round with the victories containing empty pubkey
        var minerList = new MinerList { Pubkeys = { victories.Value } };
        minerList.GenerateFirstRoundOfNewTerm(4000, Timestamp.FromDateTime(DateTime.UtcNow));
    });
    
    exception.ShouldNotBeNull();
    exception.Message.ShouldContain("Index was outside the bounds of the array");
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L123-126)
```csharp
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-18)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-84)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
    }

    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```
