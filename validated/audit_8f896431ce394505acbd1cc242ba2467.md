# Audit Report

## Title
Missing LIB Validation in NextRound/NextTerm Allows Arbitrary Irreversible Block Height Manipulation

## Summary
The AEDPoS consensus contract fails to validate Last Irreversible Block (LIB) values during NextRound and NextTerm transitions. The `LibInformationValidationProvider` is only applied to UpdateValue behavior, allowing malicious miners to submit arbitrary LIB values that will be stored without verification, corrupting consensus finality guarantees and blockchain health monitoring.

## Finding Description

The validation architecture in `ValidateBeforeExecution` conditionally applies different validators based on consensus behavior. For UpdateValue behavior, `LibInformationValidationProvider` is explicitly added to the validation chain [1](#0-0) , which prevents LIB values from decreasing.

However, for NextRound and NextTerm behaviors, this critical validator is conspicuously absent. The NextRound behavior only receives `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` [2](#0-1) , while NextTerm only gets `RoundTerminateValidationProvider` [3](#0-2) .

The `LibInformationValidationProvider` contains logic to validate that LIB values don't decrease by checking if `baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight` [4](#0-3) , but this validation is never applied to NextRound/NextTerm behaviors.

During NextRound processing, the input is directly converted to a Round object via `ToRound()` [5](#0-4) , which blindly copies the `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields without any validation [6](#0-5) . This converted Round is then stored directly into state via `AddRoundInformation` [7](#0-6) .

The honest code path in `GenerateNextRoundInformation` correctly preserves LIB values from the current round [8](#0-7) . However, since `NextRound` is a public method accepting `NextRoundInput` as a parameter [9](#0-8) , and the consensus extra data is generated off-chain by miner node software [10](#0-9) , there is no enforcement that the submitted data matches the honestly generated values. A malicious miner can modify their node software to inject arbitrary LIB values into the consensus extra data, and the contract will accept them.

The same vulnerability exists for NextTerm, where `ToRound()` similarly copies LIB fields without validation [11](#0-10) .

## Impact Explanation

**Consensus Integrity Violation:** LIB values represent the blockchain's irreversible finality boundary. Arbitrary manipulation breaks the fundamental consensus guarantee that blocks below LIB cannot be reorganized. This undermines the core trust model of the blockchain.

**Blockchain Health Monitoring Corruption:** The `GetMaximumBlocksCount` function uses stored LIB values (`ConfirmedIrreversibleBlockRoundNumber` and `ConfirmedIrreversibleBlockHeight`) to assess blockchain health status [12](#0-11) . It calculates whether the blockchain is in Normal, Abnormal, or Severe mining status based on the gap between current round and LIB round. Inflated LIB values could prevent proper detection of abnormal/severe mining status, allowing continuous fork conditions that should trigger defensive measures like reduced block production limits.

**Cross-Chain Finality Propagation:** In multi-chain deployments, main chain LIB values inform side chains about which parent chain blocks are finalized. Corrupted LIB values could cause side chains to index unconfirmed main chain blocks as irreversible, leading to potential cross-chain reorganization vulnerabilities.

**State Corruption Persistence:** Once injected, corrupted LIB values affect subsequent UpdateValue operations. The LIB calculation during UpdateValue compares against the stored LIB from previous rounds [13](#0-12) , meaning the corruption cascades forward through subsequent consensus rounds.

Impact severity: **High** - breaks core consensus finality guarantees and can cascade across multi-chain deployments.

## Likelihood Explanation

**Attacker Profile:** Any miner in the validator set can execute this attack when they become the extra block producer for a round. In AEDPoS, this role rotates among miners, ensuring all miners eventually obtain this capability.

**Attack Complexity:** Low. The attack requires:
1. Waiting for designation as extra block producer (happens naturally through rotation)
2. Modifying miner node software to alter consensus extra data generation
3. Setting arbitrary `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields in the generated consensus header information
4. Producing a block with the modified data

The validation logic explicitly omits LIB checks for NextRound/NextTerm [14](#0-13) , so the attack will succeed.

**Detection Difficulty:** Initial detection is difficult as the contract accepts the values without validation. The `RoundTerminateValidationProvider` only checks that round and term numbers increment correctly [15](#0-14) , not LIB values. Discrepancies would only emerge through external monitoring or when UpdateValue calculations produce inconsistent results.

**Preconditions:** Requires a malicious miner willing to corrupt consensus state. Given the economic incentives and reputation risks in a production blockchain, the probability of an intentional attack is moderate. However, the vulnerability could also be triggered accidentally by buggy miner software.

Likelihood: **Medium** - requires miner compromise but attack is straightforward once opportunity arises.

## Recommendation

Add `LibInformationValidationProvider` to the validation chain for both NextRound and NextTerm behaviors in the `ValidateBeforeExecution` method:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add this
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add this
    break;
```

This ensures that LIB values cannot decrease during any consensus transition, maintaining the monotonicity invariant of the Last Irreversible Block height.

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_Should_Reject_Decreased_LIB_Values()
{
    // Arrange: Setup initial state with LIB at height 100, round 5
    var currentRound = GenerateRoundWithLIB(roundNumber: 5, libHeight: 100, libRound: 4);
    await InitializeConsensusContract(currentRound);
    
    // Act: Malicious miner submits NextRound with decreased LIB (height 50, round 3)
    var maliciousNextRound = GenerateNextRoundInput(
        roundNumber: 6,
        confirmedIrreversibleBlockHeight: 50,  // Decreased from 100
        confirmedIrreversibleBlockRoundNumber: 3  // Decreased from 4
    );
    
    var result = await AEDPoSContractStub.NextRound.SendAsync(maliciousNextRound);
    
    // Assert: Should fail validation but currently succeeds (vulnerability)
    // Expected: TransactionResult.Status == TransactionResultStatus.Failed
    // Actual: TransactionResult.Status == TransactionResultStatus.Mined (vulnerability confirmed)
    var storedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    storedRound.ConfirmedIrreversibleBlockHeight.ShouldBe(50); // Proves vulnerability - corrupted value accepted
}
```

This test demonstrates that decreased LIB values are accepted during NextRound transitions, confirming the validation gap.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L25-26)
```csharp
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```
