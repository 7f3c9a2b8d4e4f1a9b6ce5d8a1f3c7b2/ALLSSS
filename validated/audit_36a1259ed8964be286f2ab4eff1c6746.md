# Audit Report

## Title
Miners Lose Term Credit When Replacing Pubkey Before Term End Due to Stale Round Data

## Summary
When a miner replaces their public key via `ReplaceCandidatePubkey`, the Election contract transfers the candidateInformation to the new pubkey and removes it from the old pubkey. However, the consensus contract's stored round data for previous rounds remains unchanged with the old pubkey. When `TakeSnapshot` is called at term end, it retrieves miners from this stale round data, but the early return in `UpdateCandidateInformation` prevents updating the Terms list because the old pubkey's candidateInformation is now null. This causes miners to lose credit for terms where they successfully produced blocks.

## Finding Description

The vulnerability stems from incomplete synchronization between pubkey replacement and historical round data during term snapshots.

**Root Cause:**

When `ReplaceCandidatePubkey` is called, the Election contract removes the old pubkey's candidateInformation and creates it under the new pubkey. [1](#0-0) 

The consensus contract is notified and updates the **current** round's `RealTimeMinersInformation` to use the new pubkey. [2](#0-1) 

However, previous rounds already stored in state remain unchanged and still contain the old pubkey.

**Failure Point:**

When a term ends, `TakeSnapshot` is called by the consensus contract. [3](#0-2) 

It calls `GetPreviousTermMinerPubkeyList`, which returns pubkeys directly from the stored round data without applying any pubkey replacement mapping. [4](#0-3) 

For each pubkey in this list, `UpdateCandidateInformation` is called. This private method has an early return when candidateInformation is null. [5](#0-4) 

Since the old pubkey's candidateInformation was removed during replacement, the method returns early at line 485, preventing the Terms list update.

**Why Existing Protections Fail:**

The codebase has a `GetNewestPubkey` function that correctly maps old pubkeys to their newest replacements. [6](#0-5) 

This function is correctly used in other parts of the codebase, such as when changing voting options. [7](#0-6) 

It is also used in `GetPreviousTermSnapshotWithNewestPubkey` to correctly map banned candidates. [8](#0-7) 

However, it is **not used** in the `TakeSnapshot` flow before calling `UpdateCandidateInformation`, causing the old (now null) pubkey to be used instead of the correctly resolved new one.

## Impact Explanation

This vulnerability breaks critical invariants in the Election contract's miner participation tracking system:

**Direct Impacts:**
1. **Loss of Participation Records**: Miners who replace their pubkeys lose credit for any terms where they successfully produced blocks if the replacement occurs before term end and `TakeSnapshot` is called.

2. **Incomplete Terms List**: The `Terms` list in candidateInformation becomes incomplete, missing terms where the miner actually participated. This violates the documented purpose of the Terms field.

3. **Broken Continuity Tracking**: The `ContinualAppointmentCount` is not updated correctly, breaking the continuity tracking mechanism used to measure consistent miner performance.

**Affected Parties:**
- Any miner who uses the legitimate pubkey replacement feature for key rotation
- Voters who rely on accurate candidate history to make informed voting decisions
- Off-chain systems and UIs that display miner participation history for transparency

**Severity Justification:**
This is a **High** severity issue because it directly compromises the integrity of the election system's transparency and accountability mechanisms. The Terms list serves as the historical record of miner participation, and its corruption undermines trust in the system. While it doesn't directly affect funds, it impacts governance transparency and could affect future eligibility determinations if the Terms list is used for such purposes.

## Likelihood Explanation

**Trigger Conditions:**
- Any miner with a valid candidateInformation entry can trigger this vulnerability by calling `ReplaceCandidatePubkey`
- No special privileges required beyond being a registered candidate
- The vulnerability activates automatically when the term ends and `TakeSnapshot` is executed

**Attack Complexity:**
- **Very Simple**: The miner simply calls `ReplaceCandidatePubkey` at any time before or during a term
- The term credit loss happens passively when the consensus contract calls `TakeSnapshot` at term end
- No special timing requirements or race conditions needed

**Feasibility:**
- Pubkey replacement is a legitimate, documented feature designed for key rotation scenarios
- Using this feature is not suspicious and is expected in production
- Works for any miner in any term with no additional preconditions

**Probability:**
This is **High** likelihood because:
- The vulnerability triggers automatically for every miner who replaces their pubkey before term end
- Key rotation is a security best practice, so usage is expected
- No detection mechanism exists to warn users of the impending credit loss
- The issue is deterministic and reproducible

## Recommendation

Modify the `TakeSnapshot` method to resolve old pubkeys to their newest replacements before calling `UpdateCandidateInformation`:

```csharp
foreach (var pubkey in previousTermMinerList)
{
    var newestPubkey = GetNewestPubkey(pubkey);
    UpdateCandidateInformation(newestPubkey, input.TermNumber, previousTermMinerList);
}
```

This ensures that term credit is properly assigned to the current pubkey, maintaining the integrity of the Terms list even when miners perform key rotation.

## Proof of Concept

```csharp
// Test demonstrates that a miner loses term credit after replacing pubkey
[Fact]
public async Task MinerLosesTermCreditAfterPubkeyReplacement()
{
    // 1. Setup: Miner is active in term 1 with OLD_PUBKEY
    var oldPubkey = "OLD_PUBKEY_HEX";
    var newPubkey = "NEW_PUBKEY_HEX";
    
    // Miner produces blocks during term 1
    // ... mining activity ...
    
    // 2. Miner replaces pubkey during term 1
    await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = oldPubkey,
        NewPubkey = newPubkey
    });
    
    // Verify candidateInformation moved to new pubkey
    var oldInfo = await ElectionContractStub.GetCandidateInformation.CallAsync(new StringValue { Value = oldPubkey });
    var newInfo = await ElectionContractStub.GetCandidateInformation.CallAsync(new StringValue { Value = newPubkey });
    Assert.Null(oldInfo.Pubkey); // Old entry removed
    Assert.Equal(newPubkey, newInfo.Pubkey); // New entry exists
    
    // 3. Term ends, TakeSnapshot is called
    await ConsensusContractStub.TakeSnapshot.SendAsync(new TakeElectionSnapshotInput
    {
        TermNumber = 1,
        MinedBlocks = 100,
        RoundNumber = 10
    });
    
    // 4. Verify: New pubkey's Terms list does NOT contain term 1
    var finalInfo = await ElectionContractStub.GetCandidateInformation.CallAsync(new StringValue { Value = newPubkey });
    Assert.DoesNotContain(1L, finalInfo.Terms); // BUG: Term 1 is missing
    Assert.Equal(0, finalInfo.ContinualAppointmentCount); // BUG: Count not updated
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L237-242)
```csharp
        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L402-434)
```csharp
    public override Empty TakeSnapshot(TakeElectionSnapshotInput input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        Assert(State.AEDPoSContract.Value == Context.Sender, "No permission.");

        SavePreviousTermInformation(input);

        if (State.ProfitContract.Value == null)
        {
            var profitContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            // Return if profit contract didn't deployed. (Often in test cases.)
            if (profitContractAddress == null) return new Empty();
            State.ProfitContract.Value = profitContractAddress;
        }

        // Update snapshot of corresponding voting record by the way.
        State.VoteContract.TakeSnapshot.Send(new TakeSnapshotInput
        {
            SnapshotNumber = input.TermNumber,
            VotingItemId = State.MinerElectionVotingItemId.Value
        });

        State.CurrentTermNumber.Value = input.TermNumber.Add(1);

        var previousTermMinerList =
            State.AEDPoSContract.GetPreviousTermMinerPubkeyList.Call(new Empty()).Pubkeys.ToList();

        foreach (var pubkey in previousTermMinerList)
            UpdateCandidateInformation(pubkey, input.TermNumber, previousTermMinerList);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L481-492)
```csharp
    private void UpdateCandidateInformation(string pubkey, long lastTermNumber,
        List<string> previousMiners)
    {
        var candidateInformation = State.CandidateInformationMap[pubkey];
        if (candidateInformation == null) return;
        candidateInformation.Terms.Add(lastTermNumber);
        var victories = GetVictories(previousMiners);
        candidateInformation.ContinualAppointmentCount = victories.Contains(ByteStringHelper.FromHexString(pubkey))
            ? candidateInformation.ContinualAppointmentCount.Add(1)
            : 0;
        State.CandidateInformationMap[pubkey] = candidateInformation;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L136-146)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L464-471)
```csharp
    public override PubkeyList GetPreviousTermMinerPubkeyList(Empty input)
    {
        var lastRoundNumber = State.FirstRoundNumberOfEachTerm[State.CurrentTermNumber.Value].Sub(1);
        var lastRound = State.Rounds[lastRoundNumber];
        if (lastRound == null || lastRound.RoundId == 0) return new PubkeyList();
        return new PubkeyList
        {
            Pubkeys = { lastRound.RealTimeMinersInformation.Keys }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L63-63)
```csharp
        var oldVoteOptionPublicKey = GetNewestPubkey(votingRecord.Option);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L150-157)
```csharp
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
```
