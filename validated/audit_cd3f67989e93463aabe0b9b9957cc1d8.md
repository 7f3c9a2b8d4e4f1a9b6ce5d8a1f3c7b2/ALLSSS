# Audit Report

## Title
Cross-Chain NFT Protocol Creation Bypasses Metadata Validation Allowing Malicious ExternalInfo Injection

## Summary
The `CrossChainCreate()` function in the NFT contract copies all `tokenInfo.ExternalInfo` directly into `NFTProtocolInfo.Metadata` without validating that metadata keys don't conflict with NFT-reserved keys. An attacker can create a token on the mainchain via `MultiToken.Create()` with malicious ExternalInfo containing NFT-reserved keys, sync it to a sidechain, and register it as an NFT protocol with unvalidated metadata, bypassing the metadata validation enforced by the legitimate `NFT.Create()` flow.

## Finding Description

The vulnerability exists in the `CrossChainCreate()` function where it copies all token metadata without validation. [1](#0-0) 

This line copies all `tokenInfo.ExternalInfo.Value` into the NFT protocol's metadata field without any validation checks. In contrast, the mainchain `Create()` function validates user-provided metadata to ensure it doesn't use reserved keys: [2](#0-1) 

The `AssertMetadataKeysAreCorrect()` function checks that user metadata doesn't conflict with reserved NFT keys: [3](#0-2) 

These reserved keys include critical NFT metadata fields: [4](#0-3) 

**Root Cause:** The `CrossChainCreate()` function assumes that any token retrieved from the TokenContract was created through the proper `NFT.Create()` flow and thus has properly validated metadata. However, tokens can be created directly via `MultiToken.Create()` on the mainchain. When creating NFT collections (symbols ending in "-0"), the MultiToken contract routes to `CreateNFTCollection()`: [5](#0-4) 

Which calls `CreateToken()` that simply assigns the ExternalInfo without NFT-specific validation: [6](#0-5) 

**Exploitation Path:**
1. Attacker creates an NFT collection token on mainchain (AELF) via `MultiToken.Create()` with symbol matching NFT naming conventions (e.g., "AR12345678-0")
2. Attacker includes malicious ExternalInfo with NFT-reserved keys (e.g., `aelf_nft_base_uri` pointing to a phishing site, `aelf_nft_type`, `aelf_nft_token_id_reuse`)
3. Token is synced to sidechain via standard cross-chain flow (`CrossChainCreateToken`)
4. Attacker calls `CrossChainCreate()` on sidechain NFT contract (public method with no authorization): [7](#0-6) 

5. Function extracts baseUri directly from unvalidated ExternalInfo: [8](#0-7) 

6. All malicious metadata is copied into NFT protocol without validation

## Impact Explanation

**Concrete Harm:**

- **Malicious baseUri Injection:** The `baseUri` field is extracted directly from `ExternalInfo` without validation. An attacker can set this to a phishing URL, causing all NFT metadata queries to direct users to malicious websites for credential harvesting or malware distribution.

- **Metadata Poisoning:** The entire `ExternalInfo` dictionary is copied into `NFTProtocolInfo.Metadata`, allowing injection of arbitrary key-value pairs that could override or corrupt NFT-specific metadata fields, include misleading information about token properties, or inject malicious content into metadata fields consumed by wallets and marketplaces.

- **Protocol Integrity Violation:** NFT protocols created via this vulnerability bypass the metadata validation guarantees enforced on the mainchain, creating a trust inconsistency where sidechain NFT protocols don't meet the same security standards as mainchain protocols.

**Affected Parties:**
- End users viewing NFT metadata through frontends/wallets
- NFT marketplaces and applications consuming this metadata  
- The overall integrity of the AElf NFT ecosystem

**Severity Justification (Medium):**
- No direct fund theft, but significant operational and trust impact
- Enables phishing attacks and metadata manipulation
- Affects user safety and protocol reputation

## Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to call public smart contract methods (any user)
- Token creation cost on mainchain (standard SEED NFT consumption or whitelist access)
- Cross-chain transaction fees (minimal)

**Attack Complexity:** LOW
1. Call `MultiToken.Create()` on mainchain with crafted ExternalInfo containing malicious reserved keys
2. Use standard cross-chain token sync process via `CrossChainCreateToken`
3. Call `CrossChainCreate()` on sidechain - public method with no authorization checks

**Feasibility Conditions:**
- No special privileges required beyond obtaining a SEED NFT (publicly available)
- All preconditions are standard operational requirements
- Cross-chain infrastructure is available and functional
- No race conditions or timing dependencies

**Economic Rationality:**
- Attack cost: Standard token creation fee + cross-chain transaction fees
- Potential gain: Phishing victims, reputation damage to legitimate projects
- Cost-benefit ratio favorable for targeted attacks

**Detection Constraints:**
- Malicious metadata appears as legitimate NFT protocol on sidechain
- No on-chain indicators distinguishing bypassed validation
- Requires off-chain monitoring of baseUri endpoints and metadata content

## Recommendation

Add metadata validation to the `CrossChainCreate()` function to ensure that ExternalInfo from the TokenContract doesn't contain user-injected values for NFT-reserved keys. The function should validate that reserved keys in ExternalInfo match expected formats and values, or re-extract them from validated token properties rather than blindly trusting ExternalInfo.

Recommended fix:
1. Add validation before line 104 to verify that only expected reserved keys exist in ExternalInfo
2. Extract reserved key values from TokenInfo properties (like Issuer, IsBurnable, etc.) rather than from ExternalInfo
3. Consider adding a flag or marker in MultiToken that indicates whether a token was created through the proper NFT.Create flow

## Proof of Concept

```csharp
// POC Test demonstrating the vulnerability
public async Task CrossChainCreate_Should_Fail_With_Malicious_ExternalInfo()
{
    // Step 1: On mainchain - create NFT collection via MultiToken.Create with malicious ExternalInfo
    var maliciousExternalInfo = new ExternalInfo();
    maliciousExternalInfo.Value["aelf_nft_base_uri"] = "https://phishing-site.com/steal-credentials";
    maliciousExternalInfo.Value["aelf_nft_type"] = "Art";
    maliciousExternalInfo.Value["aelf_nft_token_id_reuse"] = "true";
    
    var createInput = new CreateInput
    {
        Symbol = "AR12345678-0", // NFT collection format
        TokenName = "Malicious NFT",
        TotalSupply = 10000,
        Decimals = 0,
        Issuer = DefaultSender,
        IsBurnable = true,
        ExternalInfo = maliciousExternalInfo // Malicious metadata injected here
    };
    
    await TokenContractStub.Create.SendAsync(createInput);
    
    // Step 2: Sync to sidechain via CrossChainCreateToken (standard cross-chain flow)
    // ... cross-chain sync code ...
    
    // Step 3: On sidechain - call CrossChainCreate
    var crossChainInput = new CrossChainCreateInput { Symbol = "AR12345678-0" };
    var result = await NFTContractStub.CrossChainCreate.SendAsync(crossChainInput);
    
    // Step 4: Verify malicious metadata was copied without validation
    var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = "AR12345678-0" });
    
    // Assertion: baseUri should NOT be the malicious URL, but it is
    Assert.Equal("https://phishing-site.com/steal-credentials", protocolInfo.BaseUri);
    
    // This proves the vulnerability - malicious metadata bypassed validation
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-75)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L87-88)
```csharp
        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L104-104)
```csharp
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L186-186)
```csharp
        if (input.Metadata != null) AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L118-123)
```csharp
    private void AssertMetadataKeysAreCorrect(IEnumerable<string> metadataKeys)
    {
        var reservedMetadataKey = GetNftMetadataReservedKeys();
        foreach (var metadataKey in metadataKeys)
            Assert(!reservedMetadataKey.Contains(metadataKey), $"Metadata key {metadataKey} is reserved.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L7-11)
```csharp
    private const string NftTypeMetadataKey = "aelf_nft_type";
    private const string NftBaseUriMetadataKey = "aelf_nft_base_uri";
    private const string NftTokenIdReuseMetadataKey = "aelf_nft_token_id_reuse";
    private const string AssembledNftsKey = "aelf_assembled_nfts";
    private const string AssembledFtsKey = "aelf_assembled_fts";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L10-13)
```csharp
    private Empty CreateNFTCollection(CreateInput input)
    {
        return CreateToken(input, SymbolType.NftCollection);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```
