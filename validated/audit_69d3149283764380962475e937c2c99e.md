# Audit Report

## Title
Proposer Whitelist Bypass - Removed Proposers Can Execute Approved Proposals

## Summary
The `Release` method in Association, Parliament, and Referendum governance contracts fails to re-validate whether the caller is still in the organization's proposer whitelist. This allows proposers who have been removed from the whitelist via `ChangeOrganizationProposerWhiteList` to retain execution authority for previously approved proposals, creating a critical authorization bypass.

## Finding Description

The vulnerability exists across all three governance contracts (Association, Parliament, Referendum) due to insufficient authorization validation in the `Release` method.

**Proposal Creation - Whitelist Validated:**
When a proposal is created, the system validates the proposer's whitelist membership through `AssertIsAuthorizedProposer`: [1](#0-0) 

This validation checks the proposer against the current whitelist: [2](#0-1) 

**Whitelist Updates Allowed:**
Organizations can update their proposer whitelist at any time: [3](#0-2) 

**Proposal Release - No Whitelist Re-Check:**
When releasing an approved proposal, only the original proposer identity is verified: [4](#0-3) 

The critical flaw is at line 186: the check `Context.Sender == proposalInfo.Proposer` verifies that the caller is the original proposer, but never re-validates whether this proposer is still in the current whitelist stored in `organization.ProposerWhiteList`.

**Authorization Gap:**
Once a proposer creates a proposal and gets it approved, they retain release authority indefinitely (until expiration), even after being explicitly removed from the whitelist. The whitelist check using the `Contains` extension method is never re-evaluated at release time: [5](#0-4) 

**Identical Pattern in Parliament:** [6](#0-5) 

**Identical Pattern in Referendum:** [7](#0-6) 

## Impact Explanation

**HIGH Severity** - This vulnerability represents a fundamental authorization bypass with severe consequences:

1. **Authorization Invariant Violation:** The proposer whitelist is a core security control mechanism. The expected invariant is: "Only addresses currently in the proposer whitelist can interact with governance proposals." This is completely violated for the Release operation.

2. **No Effective Revocation:** When organizations remove a proposer from the whitelist (due to compromise, discovered malicious intent, or changed trust model), they reasonably expect this revokes all governance authority. However, removed proposers retain full execution rights for any approved proposals.

3. **Arbitrary Contract Execution:** The `Release` method executes `Context.SendVirtualInlineBySystemContract` on behalf of the organization's virtual address, which can invoke any contract method including:
   - Token transfers from organization treasury
   - Contract upgrades and deployments  
   - Permission and configuration changes
   - Cross-chain operations
   - Other privileged governance actions

4. **Real Attack Scenarios:**
   - **Compromised Account:** Organization detects proposer account compromise and removes them from whitelist, but attacker can still execute approved proposals
   - **Malicious Proposer Discovery:** Proposer's malicious intent discovered after approval (through parameter obfuscation), but whitelist removal doesn't prevent execution
   - **Changed Trust Model:** Organization needs to reduce proposer set for security, but cannot revoke release rights for existing approved proposals

5. **No Mitigation Available:** The only defense is waiting for proposal expiration and using `ClearProposal`, requiring organizations to wait the entire proposal lifetime (typically days) while the removed proposer can execute at will: [8](#0-7) 

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability is highly feasible to exploit:

1. **Low Attacker Capabilities:** Attacker must only:
   - Initially be in proposer whitelist (normal operational state)
   - Create a proposal that gets approved (standard governance flow)
   - No special technical exploits, economic resources, or timing attacks required

2. **Low Attack Complexity:** The exploit is straightforward:
   - Step 1: Create proposal while whitelisted (verified by `AssertIsAuthorizedProposer`)
   - Step 2: Wait for organization member approval (normal operation)
   - Step 3: After being removed from whitelist via `ChangeOrganizationProposerWhiteList`, call `Release`
   - Step 4: Release succeeds because it only checks `Context.Sender == proposalInfo.Proposer`

3. **Realistic Triggering Conditions:**
   - Account compromise is a realistic operational risk requiring immediate whitelist removal
   - Discovering proposer malicious intent post-approval is common in governance
   - Organizations regularly need to update their trust model and proposer set
   - Extended attack window (approval to expiration, typically days)

4. **No Effective Detection/Prevention:**
   - Transactions are on-chain and visible, but prevention is impossible once proposal is approved
   - Organizations have no mechanism to revoke release authority
   - `ClearProposal` only works after expiration, leaving a long vulnerable window

## Recommendation

Add whitelist re-validation in the `Release` method before executing the proposal. The fix should verify that the proposer is still in the current whitelist at release time:

**For Association Contract:**
```csharp
public override Empty Release(Hash input)
{
    var proposalInfo = GetValidProposal(input);
    Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
    
    // Add whitelist re-validation
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(organization.ProposerWhiteList.Contains(Context.Sender), 
        "Proposer no longer in whitelist.");
    
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    Context.SendVirtualInlineBySystemContract(
        CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), 
        proposalInfo.ToAddress,
        proposalInfo.ContractMethodName, proposalInfo.Params);
    // ... rest of method
}
```

**For Parliament Contract:**
```csharp
public override Empty Release(Hash proposalId)
{
    var proposalInfo = GetValidProposal(proposalId);
    Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
    
    // Add whitelist re-validation
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(!organization.ProposerAuthorityRequired || 
        ValidateAddressInWhiteList(Context.Sender) ||
        (organization.ParliamentMemberProposingAllowed && 
         ValidateParliamentMemberAuthority(Context.Sender)),
        "Proposer no longer authorized.");
    
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    // ... rest of method
}
```

**For Referendum Contract:**
```csharp
public override Empty Release(Hash input)
{
    var proposal = GetValidProposal(input);
    Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
    
    // Add whitelist re-validation
    var organization = State.Organizations[proposal.OrganizationAddress];
    Assert(organization.ProposerWhiteList.Contains(Context.Sender),
        "Proposer no longer in whitelist.");
    
    Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
    // ... rest of method
}
```

This ensures that whitelist membership is enforced consistently at both proposal creation and release time, maintaining the authorization invariant throughout the proposal lifecycle.

## Proof of Concept

```csharp
[Fact]
public async Task ProposerWhitelistBypass_RemovedProposerCanStillRelease()
{
    // Setup: Create organization with Reviewer1 in whitelist
    var organizationAddress = await CreateOrganizationAsync(
        minimalApproveThreshold: 1, 
        minimalVoteThreshold: 1,
        maximalAbstentionThreshold: 0, 
        maximalRejectionThreshold: 0, 
        Reviewer1);
    
    // Step 1: Reviewer1 (whitelisted) creates a proposal
    var transferInput = new TransferInput
    {
        Symbol = "ELF",
        Amount = 100,
        To = Reviewer1,
        Memo = "Malicious transfer"
    };
    
    var createProposalInput = new CreateProposalInput
    {
        ContractMethodName = nameof(TokenContractStub.Transfer),
        ToAddress = TokenContractAddress,
        Params = transferInput.ToByteString(),
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(2),
        OrganizationAddress = organizationAddress
    };
    
    var associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
    var proposalId = await associationContractStub.CreateProposal.SendAsync(createProposalInput);
    
    // Step 2: Proposal gets approved by organization members
    await ApproveAsync(Reviewer1KeyPair, proposalId.Output);
    
    // Step 3: Organization discovers issue and removes Reviewer1 from whitelist
    var newWhitelist = new ProposerWhiteList
    {
        Proposers = { Reviewer2 } // Reviewer1 removed
    };
    
    var changeWhitelistProposalId = await CreateAssociationProposalAsync(
        Reviewer1KeyPair, 
        newWhitelist,
        nameof(associationContractStub.ChangeOrganizationProposerWhiteList), 
        organizationAddress);
    await ApproveAsync(Reviewer1KeyPair, changeWhitelistProposalId);
    await associationContractStub.Release.SendAsync(changeWhitelistProposalId);
    
    // Verify Reviewer1 is no longer in whitelist
    var verifyResult = await associationContractStub.ValidateProposerInWhiteList.CallAsync(
        new ValidateProposerInWhiteListInput
        {
            OrganizationAddress = organizationAddress,
            Proposer = Reviewer1
        });
    verifyResult.Value.ShouldBeFalse(); // Confirmed removed from whitelist
    
    // Step 4: VULNERABILITY - Reviewer1 can still release the approved proposal
    await TransferToOrganizationAddressAsync(organizationAddress);
    var balanceBefore = await GetBalanceAsync("ELF", Reviewer1);
    
    var releaseResult = await associationContractStub.Release.SendAsync(proposalId.Output);
    
    // EXPLOIT SUCCESS: Release succeeds even though proposer was removed from whitelist
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var balanceAfter = await GetBalanceAsync("ELF", Reviewer1);
    balanceAfter.ShouldBe(balanceBefore + 100); // Funds transferred despite whitelist removal
}
```

This test demonstrates that a proposer removed from the whitelist can still execute previously approved proposals, bypassing the whitelist authorization mechanism entirely.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L107-111)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Extensions.cs (L29-32)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```
