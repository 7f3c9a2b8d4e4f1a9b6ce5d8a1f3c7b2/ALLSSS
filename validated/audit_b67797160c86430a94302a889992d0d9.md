# Audit Report

## Title
Consensus Round Data Pollution via Unvalidated Cross-Miner State Injection

## Summary
A malicious miner can inject arbitrary mining order and consensus state values for ALL miners in a consensus round, bypassing validation due to a critical same-object comparison flaw in `ValidateConsensusAfterExecution`. This enables mining schedule manipulation and consensus state corruption.

## Finding Description

The AEDPoS consensus contract contains a critical vulnerability where `RecoverFromUpdateValue` unconditionally overwrites consensus-critical fields for all miners without proper validation.

**Core Vulnerability - Same-Object Comparison Bug:**

In `ValidateConsensusAfterExecution`, when consensus behavior is `UpdateValue`, the validation performs recovery and comparison: [1](#0-0) 

The critical flaw is in `RecoverFromUpdateValue`, which modifies the `currentRound` object in-place and returns `this`: [2](#0-1) 

After this assignment, both `currentRound` and `headerInformation.Round` reference the **SAME object**. The subsequent hash comparison compares an object to itself, making validation always pass: [3](#0-2) 

**Cross-Miner State Injection:**

The `RecoverFromUpdateValue` method updates ALL miners' consensus-critical fields from the attacker-controlled block header: [4](#0-3) 

**Attack Execution Flow:**

1. **Block Production**: Malicious miner's node generates Round data via `ApplyNormalConsensusData`, then simplifies it for the block header via `GetUpdateValueRound`: [5](#0-4) 

The simplified Round includes `SupposedOrderOfNextRound`, `FinalOrderOfNextRound`, and `PreviousInValue` for ALL miners: [6](#0-5) 

2. **Transaction Generation**: Corrupted data is extracted into `UpdateValueInput` with `TuneOrderInformation` and `MinersPreviousInValues`: [7](#0-6) 

3. **State Corruption**: `ProcessUpdateValue` applies attacker's values to ALL miners without cross-validation: [8](#0-7) [9](#0-8) 

4. **Insufficient Pre-Validation**: `UpdateValueValidationProvider` only validates the sender's data, NOT other miners' values: [10](#0-9) 

## Impact Explanation

**Critical Consensus Integrity Violation:**

1. **Mining Schedule Manipulation**: By setting arbitrary `FinalOrderOfNextRound` values, attackers directly control mining order for the next round. This order is used to assign mining slots: [11](#0-10) 

An attacker can give themselves priority mining positions, demote competitors, or create conflicting orders causing consensus failures.

2. **Consensus State Corruption**: By setting arbitrary `PreviousInValue` for other miners, the attacker corrupts stored consensus state. This can cause legitimate miners to fail validation or produce blocks with mismatched state.

3. **Systemic Impact**: Every malicious miner can corrupt ALL other miners' state in each block they produce. With multiple colluding miners, this leads to widespread consensus failures and potential chain halts.

**Severity: CRITICAL** - Directly violates the core consensus invariant: "Miners cannot unilaterally modify other miners' consensus state."

## Likelihood Explanation

**High Exploitability:**

1. **Accessible Entry Point**: Any elected miner can execute this attack during their scheduled mining slot through standard block production.

2. **Low Attack Complexity**: 
   - Requires only node software modification to tamper with Round data before block creation
   - No cryptographic barriers (VRF signatures authenticate sender's random number, not cross-miner data)
   - No economic cost beyond normal block production

3. **Realistic Preconditions**: 
   - Attacker must be an elected miner (achievable through staking)
   - Must wait for their scheduled turn (guaranteed for elected miners)

4. **Failed Detection**: 
   - Validation has a critical same-object comparison bug
   - Cross-miner data validation is completely absent
   - Corrupted state appears valid to honest nodes

5. **Economic Incentive**: 
   - Gain additional mining rewards through order manipulation
   - Disrupt competitors by corrupting their consensus state
   - Low detection risk due to broken validation

**Probability: HIGH** - Practical attack executable by any malicious elected miner.

## Recommendation

**Fix 1: Correct the Same-Object Comparison Bug**

Modify `RecoverFromUpdateValue` to return a **new** Round object instead of modifying and returning `this`:

```csharp
public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
{
    var recovered = this.Clone(); // Create a deep copy
    
    if (!recovered.RealTimeMinersInformation.ContainsKey(pubkey) ||
        !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return recovered;

    // Apply recovery to the cloned object
    // ... rest of the logic
    
    return recovered;
}
```

**Fix 2: Add Cross-Miner Data Validation**

In `UpdateValueValidationProvider`, add validation for `TuneOrderInformation` and `MinersPreviousInValues` to ensure the sender cannot arbitrarily modify other miners' data without proper authorization or consensus rules.

**Fix 3: Add Post-Execution Hash Verification**

Ensure `ValidateConsensusAfterExecution` performs the hash comparison on distinct objects by not using the recovered round for comparison, or by implementing proper validation before recovery.

## Proof of Concept

The PoC would demonstrate:
1. An elected miner producing a block
2. Modifying the Round data to set arbitrary `FinalOrderOfNextRound` values for all miners
3. The block being accepted despite corrupted data
4. Verification that `ValidateConsensusAfterExecution` passes due to same-object comparison
5. Confirmation that corrupted values are persisted to state and affect next round generation

**Note**: A full implementation test would require access to the AElf test framework and the ability to simulate a malicious miner node.

## Notes

This vulnerability represents a fundamental flaw in the consensus validation architecture where the same-object comparison bug combined with missing cross-miner validation creates a critical attack vector. The impact is severe as it allows unilateral modification of consensus state by any malicious elected miner, breaking the core security guarantees of the AEDPoS consensus mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-92)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-103)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-32)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L28-31)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L35-53)
```csharp
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-47)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);

        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-49)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
