# Audit Report

## Title
Predictable NFT Symbol Generation Allows Miner Manipulation via Known Block Height Random Seed

## Summary
The NFT contract's `GenerateSymbolNumber()` function uses a random seed from the previous block (H-1) that is already publicly stored on-chain when miners are building block H. This allows miners to predict the exact NFT symbol that will be generated for any pending transaction and selectively censor, delay, or front-run transactions to monopolize valuable NFT symbols.

## Finding Description

The vulnerability exists in the NFT symbol generation mechanism where the random seed is deterministic and known before transaction inclusion decisions are made.

When the `Create` method is called to create a new NFT protocol, it invokes `GetSymbol`, which calls `GenerateSymbolNumber()`. [1](#0-0) [2](#0-1) 

This function retrieves random bytes using the block height from the previous block: [3](#0-2) 

The random hash for height H-1 is generated and stored during the consensus transaction execution of block H-1, using EC-VRF verification: [4](#0-3) 

The random hash is stored in `State.RandomHashes`, which is a public mapping accessible through the `GetRandomHash` view method: [5](#0-4) [6](#0-5) 

The block execution order confirms that system transactions (including consensus transactions that store random hashes) execute before user transactions: [7](#0-6) 

**Root Cause**: When a miner is building block H, the random hash for H-1 has already been finalized and stored on-chain during H-1's execution. The symbol generation deterministically combines this known random hash with the known sender address: [8](#0-7) 

The conversion to a numeric symbol is also deterministic: [9](#0-8) 

This makes the outcome 100% predictable to miners before they commit to including the transaction.

**Attack Scenario**:
1. User Alice submits an NFT Create transaction to the mempool
2. Miner Bob is building block H
3. Bob reads `State.RandomHashes[H-1]` via the public `GetRandomHash` view method
4. Bob simulates Alice's transaction: `symbol = Hash(Alice.Address, RandomHash[H-1])`
5. If the symbol is valuable (e.g., "AR0001"), Bob can:
   - Exclude Alice's transaction from block H
   - Submit his own transaction to claim that symbol
   - Front-run by submitting a competing transaction first

## Impact Explanation

**Direct Impact**:
- **Unfair Symbol Allocation**: Certain NFT symbols have inherently higher value (e.g., lower numbers like "AR0001" vs "AR9999", patterns, memorable sequences). Miners can monopolize these valuable symbols for themselves or allies.
- **Censorship Attack**: Miners can indefinitely delay transactions that would generate desirable symbols, preventing legitimate users from obtaining them.
- **Front-Running**: Miners can observe pending NFT creation transactions, identify which would generate valuable symbols, and submit their own transactions to claim those symbols first.

**Who Is Affected**:
- All users attempting to create NFT protocols via the `Create` method
- The NFT protocol's fairness and market integrity
- Users lose the ability to fairly compete for desirable symbols

**Severity Justification**: HIGH severity because:
1. Miners have complete predictability and control over symbol assignment
2. Attack is passive (requires only transaction simulation)
3. Strong economic incentive exists when certain symbols have higher market value
4. Users cannot defend against this manipulation
5. No on-chain detection mechanism exists

## Likelihood Explanation

**Attacker Capabilities**: 
- Only requires being a block producer (miner) in the AEDPoS consensus
- No special privileges beyond normal mining capabilities
- Attack is passive observation and transaction selection

**Attack Complexity**: LOW
- Miners can trivially simulate NFT creation transactions before including them
- Random hash for H-1 is publicly readable via `GetRandomHash` view method
- No complex cryptographic attacks or state manipulation required
- Simple calculation: `symbol = ConvertHashToInt64(Hash(Sender, RandomBytes[H-1]))`

**Feasibility Conditions**:
- Happens naturally during normal block production
- No additional setup or preconditions needed
- Works on every block where NFT creation transactions are present
- Economic incentive aligns with rational miner behavior

**Detection/Operational Constraints**:
- Censorship appears as normal transaction pool dynamics
- Front-running is observable but not provably malicious
- No on-chain evidence of manipulation
- Victims cannot distinguish between network congestion and intentional censorship

**Probability**: HIGH - Any rational profit-seeking miner will exploit this when valuable symbols are available, especially for patterns that command premium market prices.

## Recommendation

Implement a commit-reveal scheme or use randomness from the current block instead of the previous block. Options include:

1. **Current Block Randomness**: Modify `GenerateSymbolNumber()` to use `Context.CurrentHeight` instead of `Context.CurrentHeight.Sub(1)`. This ensures the random seed is unknown when miners are selecting transactions for inclusion.

2. **Commit-Reveal Scheme**: Require users to commit to a hash in one transaction, then reveal the preimage in a subsequent transaction. The symbol generation would combine both the block random hash and the user's revealed secret.

3. **Delayed Symbol Assignment**: Store NFT protocol creation requests and assign symbols in a future block using that block's random hash, making prediction impossible at submission time.

## Proof of Concept

```csharp
// Test demonstrating miner can predict NFT symbols before inclusion
[Fact]
public async Task Miner_Can_Predict_NFT_Symbol_Before_Inclusion()
{
    // Setup: Get current block height and random hash
    var currentHeight = await BlockchainService.GetBestChainAsync();
    var previousHeight = currentHeight.Height - 1;
    
    // Miner reads the publicly available random hash for H-1
    var randomHash = await ConsensusStub.GetRandomHash.CallAsync(new Int64Value 
    { 
        Value = previousHeight 
    });
    
    // Miner simulates user Alice's pending NFT Create transaction
    var aliceAddress = Address.FromPublicKey(AliceKeyPair.PublicKey);
    var predictedHash = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(aliceAddress),
        HashHelper.ComputeFrom(randomHash.ToBytesValue())
    );
    
    var predictedSymbol = ConvertHashToInt64(predictedHash, 1000, 10000);
    
    // Now execute Alice's actual Create transaction
    var result = await NFTStub.Create.SendAsync(new CreateInput
    {
        NftType = NFTType.Art.ToString(),
        ProtocolName = "Test NFT",
        TotalSupply = 10000,
        BaseUri = "https://test.com/",
        IsBurnable = true,
        IssueChainId = ChainHelper.ConvertBase58ToChainId("AELF")
    });
    
    var actualSymbol = result.Output.Value;
    
    // Verify: Miner's prediction matches actual symbol
    Assert.Equal($"AR{predictedSymbol}", actualSymbol);
    
    // This proves miners can predict symbols before deciding whether to include the tx
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L20-20)
```csharp
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L71-74)
```csharp
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L75-77)
```csharp
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L117-122)
```csharp
    public override Hash GetRandomHash(Int64Value input)
    {
        Assert(input.Value > 1, "Invalid block height.");
        Assert(Context.CurrentHeight >= input.Value, "Block height not reached.");
        return State.RandomHashes[input.Value] ?? Hash.Empty;
    }
```

**File:** protobuf/aedpos_contract.proto (L143-145)
```text
    rpc GetRandomHash (google.protobuf.Int64Value) returns (aelf.Hash) {
        option (aelf.is_view) = true;
    }
```

**File:** src/AElf.Kernel.SmartContractExecution/Application/BlockExecutingService.cs (L60-81)
```csharp
        var nonCancellableReturnSets =
            await _transactionExecutingService.ExecuteAsync(
                new TransactionExecutingDto { BlockHeader = blockHeader, Transactions = nonCancellable },
                CancellationToken.None);
        Logger.LogTrace("Executed non-cancellable txs");

        var returnSetCollection = new ExecutionReturnSetCollection(nonCancellableReturnSets);
        var cancellableReturnSets = new List<ExecutionReturnSet>();

        if (!cancellationToken.IsCancellationRequested && cancellable.Count > 0)
        {
            cancellableReturnSets = await _transactionExecutingService.ExecuteAsync(
                new TransactionExecutingDto
                {
                    BlockHeader = blockHeader,
                    Transactions = cancellable,
                    PartialBlockStateSet = returnSetCollection.ToBlockStateSet()
                },
                cancellationToken);
            returnSetCollection.AddRange(cancellableReturnSets);
            Logger.LogTrace("Executed cancellable txs");
        }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-178)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
    }
```
