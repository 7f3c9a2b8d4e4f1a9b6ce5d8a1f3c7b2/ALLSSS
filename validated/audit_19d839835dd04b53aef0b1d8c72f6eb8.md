# Audit Report

## Title
Missing Validation of Term Transition State Allows Arbitrary Miner List Manipulation

## Summary
The AEDPoS consensus contract fails to validate miner list content during term transitions. When processing `NextTerm` transactions, the contract directly accepts and commits the submitted miner information to state without verifying it matches legitimate election results or current miners, allowing any current block producer to install an arbitrary miner list that bypasses the election system entirely.

## Finding Description

The vulnerability exists in the term transition validation and processing logic. The legitimate flow for generating miner lists occurs in `GenerateFirstRoundOfNextTerm`, which retrieves miners from election victories (mainchain) or current miners (sidechain): [1](#0-0) 

However, when `ProcessNextTerm` executes, it performs a blind conversion of the input and directly commits the miner list without validation: [2](#0-1) 

The `ToRound()` method is a simple data structure conversion with no validation logic - it copies the `RealTimeMinersInformation` field directly: [3](#0-2) 

The validation pipeline for NextTerm only adds `RoundTerminateValidationProvider`, which validates numeric increments but NOT miner list content: [4](#0-3) [5](#0-4) 

The `MiningPermissionValidationProvider` only checks if the SENDER is a current miner, not the content of the new miner list being submitted: [6](#0-5) 

The `SetMinerList` function directly stores the miner list without any validation against legitimate sources: [7](#0-6) 

**Attack Sequence:**
1. Malicious miner calls `GetConsensusExtraData` with NextTerm behavior to obtain legitimate Round structure
2. Modifies `Round.RealTimeMinersInformation` to include colluding nodes and exclude legitimate elected miners
3. Creates `NextTermInput` from modified Round using `NextTermInput.Create`: [8](#0-7) 
4. Submits NextTerm transaction with malicious input
5. Passes `PreCheck()` since attacker is current miner
6. Validation passes because it only checks round/term numbers and InValues
7. Malicious miner list committed to state via `SetMinerList`

## Impact Explanation

**Critical Consensus Integrity Violation:**
- The miner schedule determines who can produce blocks - the foundation of consensus security
- A compromised miner list grants attackers complete control over future block production
- Enables censorship, double-spending, chain halts, and arbitrary transaction manipulation
- On mainchain, completely bypasses the election system where token holders vote for block producers
- The legitimate miner selection from `TryToGetVictories` (lines 266-283 in AEDPoSContract_ViewMethods.cs) is entirely ignored

**Concrete Harm:**
- Attacker excludes all legitimate miners and populates list with colluding nodes
- Manipulates mining time slots for unfair advantages
- Breaks the fundamental trust assumption that consensus follows election results
- All network participants affected as consensus safety underpins all blockchain operations

This violates the core protocol invariant that miner lists must be derived from legitimate election results.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be current block producer (member of active miner list)
- Must produce the specific block when term transition occurs (once per term)

**Attack Complexity: LOW**
The attack requires only basic data manipulation:
1. Call standard consensus method to retrieve legitimate data structure
2. Modify miner list fields in memory
3. Submit modified input via public `NextTerm` method

**Feasibility: HIGH**
- Any compromised or malicious miner can execute
- Opportunity occurs regularly (every term transition, typically days/weeks)
- No special cryptographic operations required
- Detection difficult as malicious list appears legitimate in state
- No validation compares submitted list against election results

**Probability Assessment:** MEDIUM-HIGH - Simple to execute, any malicious miner can perform during term transition window.

## Recommendation

Add validation in `ProcessNextTerm` to verify the miner list matches legitimate sources:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // VALIDATE MINER LIST CONTENT
    var legitimateRound = GenerateFirstRoundOfNextTerm(
        Context.RecoverPublicKey().ToHex(), 
        State.MiningInterval.Value
    );
    
    // Ensure miner list matches legitimate sources
    var inputMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k);
    var legitimateMiners = legitimateRound.RealTimeMinersInformation.Keys.OrderBy(k => k);
    
    Assert(
        inputMiners.SequenceEqual(legitimateMiners),
        "Miner list does not match legitimate election results or current miners."
    );
    
    // Continue with existing processing...
    RecordMinedMinerListOfCurrentRound();
    // ... rest of method
}
```

Alternatively, add a dedicated validation provider that compares the submitted miner list against election victories or current miners.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMinerCanInstallArbitraryMinerList()
{
    // Setup: Initialize consensus with legitimate miners
    var legitimateMinerKeys = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensus(legitimateMinerKeys);
    
    // Attacker (current miner) generates legitimate NextTerm data
    var trigger = new AElfConsensusTriggerInformation 
    { 
        Pubkey = ByteString.CopyFrom(legitimateMinerKeys[0]), 
        Behaviour = AElfConsensusBehaviour.NextTerm 
    };
    var extraData = await ConsensusContract.GetConsensusExtraData.CallAsync(trigger.ToByteString());
    var headerInfo = AElfConsensusHeaderInformation.Parser.ParseFrom(extraData.Value);
    
    // ATTACK: Modify miner list to exclude legitimate miners and add malicious ones
    var maliciousRound = headerInfo.Round;
    maliciousRound.RealTimeMinersInformation.Clear();
    maliciousRound.RealTimeMinersInformation.Add("attacker1", new MinerInRound { Order = 1 });
    maliciousRound.RealTimeMinersInformation.Add("attacker2", new MinerInRound { Order = 2 });
    maliciousRound.RealTimeMinersInformation.Add("attacker3", new MinerInRound { Order = 3 });
    
    // Create malicious NextTermInput
    var maliciousInput = NextTermInput.Create(maliciousRound, ByteString.Empty);
    
    // Submit malicious NextTerm transaction
    var result = await ConsensusContract.NextTerm.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // SUCCEEDS
    
    // VERIFY: Malicious miner list was committed to state
    var currentMiners = await ConsensusContract.GetCurrentMinerList.CallAsync(new Empty());
    currentMiners.Pubkeys.Select(p => p.ToHex()).ShouldContain("attacker1");
    currentMiners.Pubkeys.Select(p => p.ToHex()).ShouldContain("attacker2");
    currentMiners.Pubkeys.Select(p => p.ToHex()).ShouldNotContain("miner1"); // Legitimate miner excluded
}
```

## Notes

The vulnerability stems from a design assumption that consensus extra data generation and transaction submission are coupled, when in reality the `NextTerm` method accepts arbitrary `NextTermInput` from any current miner. The validation logic checks structural correctness (numeric increments) but critically omits content validation (miner list legitimacy). This allows the election system to be completely bypassed, violating the core security property that block producers must be democratically elected by token holders.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-191)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```
