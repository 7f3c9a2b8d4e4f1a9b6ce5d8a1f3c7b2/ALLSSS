# Audit Report

## Title
Delegation Slot Exhaustion via Unconsumed Zero-Value Non-Unlimited Delegatees

## Summary
The `ModifyDelegation` function fails to remove delegatee entries when their delegation amounts are consumed to zero during transaction fee charging. This creates persistent "zombie" delegatees with zero-value entries that count toward the hard limit of 24 delegatees, eventually causing a denial of service where users cannot add new valid delegatees.

## Finding Description
The vulnerability stems from an inconsistency between manual delegation updates and automatic fee charging paths in the MultiToken contract's delegation system.

When delegations are manually updated via `SetTransactionFeeDelegateInfos`, the `UpdateDelegateInfo` helper properly removes zero-value entries from the delegations dictionary. [1](#0-0)  Additionally, `SetTransactionFeeDelegateInfos` checks if the delegations dictionary becomes empty and removes the entire delegatee entry. [2](#0-1) 

Similarly, `SetTransactionFeeDelegations` removes individual zero-value entries during updates. [3](#0-2)  It also removes the entire delegatee when no delegations remain. [4](#0-3) 

However, when transaction fees are automatically charged from delegations via `ChargeFromDelegations`, the `ModifyDelegation` function only performs subtraction operations without removing entries that reach zero. [5](#0-4) [6](#0-5) 

After a delegation amount is fully consumed, the dictionary entry persists with value 0. Since the cleanup check only triggers when `Delegations.Count == 0` (completely empty dictionary), these zero-value entries prevent cleanup because `Count > 0`.

The system enforces a hard limit of 24 delegatees per delegator. [7](#0-6)  This limit is enforced when adding new delegatees. [8](#0-7)  When all 24 slots are occupied by zombie delegatees with zero-value entries, the assertion `Assert(existDelegateeList.Count < TokenContractConstants.DELEGATEE_MAX_COUNT, "The quantity of delegatee has reached its limit")` prevents adding any new delegatees.

## Impact Explanation
**Denial of Service Impact:**
- When all 24 delegatee slots contain exhausted delegations with zero-value entries, users cannot add new valid delegatees
- The delegation feature becomes permanently unavailable for that delegator-contract-method combination until manual cleanup
- Users must identify each zombie delegatee individually and call `RemoveTransactionFeeDelegateeInfos` or `RemoveTransactionFeeDelegatorInfos` for cleanup, incurring additional gas costs

**Affected Parties:**
- Delegators who actively use delegations for transaction fee payment
- Legitimate delegatees who cannot be added when slots are exhausted
- DApp users relying on delegation functionality for their applications

**Storage & Operational Impact:**
- Persistent storage bloat from useless zero-value entries
- Additional gas expenditure for manual cleanup operations
- Poor user experience with cryptic "delegatee limit reached" errors when trying to add new delegatees

This is **HIGH severity** because it causes operational denial of service of a core token contract feature during normal usage (no attacker required), and the 24-slot limit makes exhaustion practically achievable through regular transaction fee consumption.

## Likelihood Explanation
**Occurrence Probability:** Very High
- Occurs automatically during normal transaction fee charging when non-unlimited delegations are consumed
- No malicious actor required - happens to regular users as they use delegations to pay transaction fees
- The more actively delegations are used for fee payment, the faster slots fill with zombie entries
- Each delegation that gets fully consumed creates a permanent zombie delegatee until manual cleanup

**Feasibility:**
- Entry point: Automatic transaction fee charging via `ChargeTransactionFees` (public method)
- No special permissions or privileges required
- No economic cost beyond normal transaction fees
- State persists indefinitely until manual intervention via removal methods
- `ModifyDelegation` is called at line 202 of TokenContract_Fees.cs whenever fees are charged from non-unlimited delegations [9](#0-8) 

**Detection Difficulty:**
- Users may not realize their delegation slots are filled with zero-value entries
- No automatic notification or self-healing mechanism exists in the contract
- Issue manifests as confusing assertion failures when attempting to add new delegatees

## Recommendation
Add cleanup logic to `ModifyDelegation` to remove zero-value delegation entries and empty delegatees after fee deduction:

```csharp
private void ModifyDelegation(TransactionFeeBill bill, TransactionFreeFeeAllowanceBill allowanceBill,
    Address delegateeAddress, Address contractAddress, string methodName, Address delegatorAddress)
{
    var delegateInfo = State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] ?? 
                      State.TransactionFeeDelegateesMap[delegatorAddress];
    var delegations = delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations;
    
    // Process fee bill
    foreach (var (symbol, amount) in bill.FeesMap)
    {
        if (amount <= 0) continue;
        delegations[symbol] = delegations[symbol].Sub(amount);
        // Remove entry if it reaches zero
        if (delegations[symbol] == 0)
        {
            delegations.Remove(symbol);
        }
    }
    
    // Process allowance bill
    foreach (var (symbol, amount) in allowanceBill.FreeFeeAllowancesMap)
    {
        if (amount <= 0) continue;
        delegations[symbol] = delegations[symbol].Sub(amount);
        // Remove entry if it reaches zero
        if (delegations[symbol] == 0)
        {
            delegations.Remove(symbol);
        }
    }
    
    // Remove delegatee if no delegations remain
    if (delegations.Count == 0 && !delegateInfo.Delegatees[delegateeAddress.ToBase58()].IsUnlimitedDelegate)
    {
        delegateInfo.Delegatees.Remove(delegateeAddress.ToBase58());
        // Fire cancellation event
        Context.Fire(new TransactionFeeDelegateInfoCancelled
        {
            Caller = delegateeAddress,
            Delegatee = delegateeAddress,
            Delegator = delegatorAddress,
            DelegateTransactionList = new DelegateTransactionList
            {
                Value = { new DelegateTransaction { ContractAddress = contractAddress, MethodName = methodName } }
            }
        });
    }
}
```

This ensures consistency with the manual update paths and prevents zombie delegatees from accumulating.

## Proof of Concept

```csharp
[Fact]
public async Task DelegationSlotExhaustion_ZombieEntries_Test()
{
    await Initialize();
    
    // Create 24 delegatees with limited delegations
    for (int i = 0; i < 24; i++)
    {
        var delegateeAddress = SampleAddress.AddressList[i];
        await TokenContractStubDelegatee[i].SetTransactionFeeDelegations.SendAsync(
            new SetTransactionFeeDelegationsInput
            {
                DelegatorAddress = User1Address,
                Delegations = { { "BASIC", 100 } } // Small amount to be consumed
            });
    }
    
    // Verify 24 delegatees exist
    var delegatees = await TokenContractStub.GetTransactionFeeDelegatees.CallAsync(
        new GetTransactionFeeDelegateesInput { DelegatorAddress = User1Address });
    delegatees.DelegateeAddresses.Count.ShouldBe(24);
    
    // Charge fees from each delegatee until delegation consumed to 0
    for (int i = 0; i < 24; i++)
    {
        var delegateeAddress = SampleAddress.AddressList[i];
        await IssueTokenToUserAsync("BASIC", 100, delegateeAddress);
        
        // Charge exactly 100 BASIC fee to consume delegation completely
        await TokenContractStubDelegatee[i].ChargeTransactionFees.SendAsync(
            new ChargeTransactionFeesInput
            {
                MethodName = "Transfer",
                ContractAddress = TokenContractAddress,
                TransactionSizeFee = 0,
                SymbolsToPayTxSizeFee = {}
            });
    }
    
    // Verify zombie delegatees still exist with zero values
    delegatees = await TokenContractStub.GetTransactionFeeDelegatees.CallAsync(
        new GetTransactionFeeDelegateesInput { DelegatorAddress = User1Address });
    delegatees.DelegateeAddresses.Count.ShouldBe(24); // Still 24!
    
    for (int i = 0; i < 24; i++)
    {
        var delegation = await TokenContractStub.GetTransactionFeeDelegationsOfADelegatee.CallAsync(
            new GetTransactionFeeDelegationsOfADelegateeInput
            {
                DelegatorAddress = User1Address,
                DelegateeAddress = SampleAddress.AddressList[i]
            });
        delegation.Delegations["BASIC"].ShouldBe(0); // Zero value!
    }
    
    // Try to add 25th delegatee - should fail due to limit
    var newDelegatee = SampleAddress.AddressList[24];
    var result = await TokenContractStubDelegatee[24].SetTransactionFeeDelegations.SendWithExceptionAsync(
        new SetTransactionFeeDelegationsInput
        {
            DelegatorAddress = User1Address,
            Delegations = { { "BASIC", 1000 } }
        });
    result.TransactionResult.Error.ShouldContain("The quantity of delegatee has reached its limit");
}
```

This test demonstrates that after delegations are consumed to zero through fee charging, the delegatee entries persist as zombies, and the 24-slot limit prevents adding new valid delegatees.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L71-74)
```csharp
                if (value <= 0 && delegationsMap.ContainsKey(key))
                {
                    delegationsMap.Remove(key);
                }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L86-91)
```csharp
            if (allDelegateesMap[delegateeAddress].Delegations.Count != 0)
                return new SetTransactionFeeDelegationsOutput()
                {
                    Success = true
                };
            State.TransactionFeeDelegateesMap[input.DelegatorAddress].Delegatees.Remove(delegateeAddress);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L226-227)
```csharp
                Assert(existDelegateeList.Count < TokenContractConstants.DELEGATEE_MAX_COUNT,
                    "The quantity of delegatee has reached its limit");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L233-242)
```csharp
            if (existDelegateeInfoList.Delegatees[delegateeAddress].Delegations.Count == 0 &&
                !existDelegateeInfoList.Delegatees[delegateeAddress].IsUnlimitedDelegate)
            {
                existDelegateeInfoList.Delegatees.Remove(delegateeAddress);
                toCancelTransactionList.Value.Add(new DelegateTransaction
                {
                    ContractAddress = delegateInfo.ContractAddress,
                    MethodName = delegateInfo.MethodName
                });
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L286-288)
```csharp
                    if (amount <= 0)
                    {
                        existDelegation.Remove(symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L200-204)
```csharp
            if (!delegations.IsUnlimitedDelegate)
            {
                ModifyDelegation(delegateeBill, delegateeAllowanceBill, fromAddress, input.ContractAddress,
                    input.MethodName, delegatorAddress);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L215-222)
```csharp
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            var delegateInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] ??
                State.TransactionFeeDelegateesMap[delegatorAddress];
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol] =
                delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol].Sub(amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L225-233)
```csharp
        foreach (var (symbol, amount) in allowanceBill.FreeFeeAllowancesMap)
        {
            if (amount <= 0) continue;

            var delegateInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] ??
                State.TransactionFeeDelegateesMap[delegatorAddress];
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol] =
                delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol].Sub(amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L18-18)
```csharp
    public const int DELEGATEE_MAX_COUNT = 24;
```
