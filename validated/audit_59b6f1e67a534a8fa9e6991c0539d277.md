# Audit Report

## Title
Missing Character Validation in AddNFTType Enables DoS of NFT Protocol Creation

## Summary
The `AddNFTType` method only validates the length of short names (exactly 2 characters) but does not validate the character content. This allows governance to add NFT types with special characters that will subsequently fail MultiToken contract symbol validation, making it impossible to create NFT protocols of that type and causing a denial-of-service for that NFT category.

## Finding Description

The vulnerability stems from insufficient input validation in the NFT contract's `AddNFTType` method compared to the strict symbol validation enforced by the MultiToken contract.

**Root Cause - Insufficient Validation in AddNFTType:**

The `AddNFTType` method validates that the short name is exactly 2 characters long but accepts any characters including special characters. [1](#0-0) 

The validation only checks `input.ShortName.Length == 2` without validating the actual character content, allowing short names like "@@", "!!", or "$%" to be stored.

**Symbol Generation - Direct Concatenation:**

When creating an NFT protocol, the `GetSymbol` method retrieves the short name from storage and concatenates it directly with a random number to generate the protocol symbol. [2](#0-1) 

The symbol is generated as `$"{shortName}{randomNumber}"` without any intermediate validation of the short name content.

**MultiToken Validation - Strict Alphanumeric Requirement:**

The generated symbol is passed to the MultiToken contract's `Create` method, which immediately calls `GetSymbolType` to validate the symbol. [3](#0-2) 

The `GetSymbolType` method enforces strict validation by requiring that the symbol prefix passes `IsValidCreateSymbol`. [4](#0-3) 

The `IsValidCreateSymbol` method uses a regex pattern `^[a-zA-Z0-9]+$` that only allows alphanumeric characters, rejecting any special characters. [5](#0-4) 

**Exploit Scenario:**

1. Parliament governance calls `AddNFTType` with input `{ FullName: "CustomType", ShortName: "@@" }`
2. The method accepts it (only checks `Length == 2`)
3. The mapping is stored: `NFTTypeShortNameMap["CustomType"] = "@@"`
4. A user attempts to create an NFT protocol: `Create({ NftType: "CustomType", ... })`
5. `GetSymbol` generates symbol: `"@@123456789"`
6. MultiToken's `GetSymbolType` validates the prefix `"@@"` with `IsValidCreateSymbol("@@")`
7. Regex `^[a-zA-Z0-9]+$` fails to match `"@@"`
8. Assertion fails with "Invalid Symbol input"
9. NFT protocol creation is permanently blocked for this type

## Impact Explanation

This vulnerability causes a **Medium severity operational DoS**:

**Operational Impact:**
- Any NFT type added with special characters becomes permanently unusable for protocol creation
- All attempts to create NFT protocols of that type will fail with "Invalid Symbol input"
- The invalid NFT type entry wastes a governance action and requires remediation via `RemoveNFTType`
- Users cannot utilize that NFT category until governance fixes it through another proposal [6](#0-5) 

**Affected Parties:**
- Users attempting to create NFT protocols of the invalid type experience complete denial of service
- Protocol operators must coordinate additional governance actions to remediate
- Overall protocol usability and trust are impacted by the validation gap

**Why Medium Severity:**
- Clear DoS of specific functionality (NFT protocol creation for that type)
- Requires governance oversight (not direct attacker exploitation)
- Reversible through governance but causes disruption and wastes resources
- No direct fund loss but impacts protocol availability

## Likelihood Explanation

This is a **Medium likelihood** vulnerability:

**Attack Vector:**
- Requires Parliament governance to add an NFT type with special characters
- Can occur through malicious proposal or honest oversight/mistake
- No sophisticated exploitation techniques needed beyond submitting a governance proposal

**Feasibility:**
- Governance proposers may not be aware of downstream MultiToken validation requirements
- The default NFT types use alphanumeric characters (AR, MU, VW, TC, etc.) which don't alert governance to the restriction [7](#0-6) 

- No automated pre-flight validation exists to catch this during proposal review
- The validation gap is easily overlooked without specific knowledge of MultiToken symbol validation rules

**Probability:**
Medium likelihood due to reliance on governance oversight, but the validation inconsistency is subtle and easily missed, especially when all existing default types use valid alphanumeric characters.

## Recommendation

Add character validation to the `AddNFTType` method to ensure short names only contain alphanumeric characters, matching the MultiToken contract's validation requirements:

```csharp
public override Empty AddNFTType(AddNFTTypeInput input)
{
    AssertSenderIsParliamentDefaultAddress();
    InitialNFTTypeNameMap();
    var fullName = input.FullName;
    Assert(input.ShortName.Length == 2, "Incorrect short name.");
    Assert(Regex.IsMatch(input.ShortName, "^[a-zA-Z0-9]+$"), "Short name must contain only alphanumeric characters.");
    Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
    Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
    // ... rest of the method
}
```

This ensures consistency between NFT contract input validation and MultiToken contract symbol validation, preventing governance from inadvertently creating unusable NFT types.

## Proof of Concept

```csharp
[Fact]
public async Task AddNFTType_WithSpecialCharacters_CausesDoS_Test()
{
    // Step 1: Governance adds an NFT type with special characters
    var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    
    var addNFTTypeInput = new AddNFTTypeInput
    {
        FullName = "CustomType",
        ShortName = "@@"  // Special characters that pass length check but fail MultiToken validation
    };
    
    var proposalId = await CreateProposalAsync(
        NFTContractAddress,
        defaultParliament,
        nameof(NFTContractStub.AddNFTType),
        addNFTTypeInput
    );
    
    await ApproveWithMinersAsync(proposalId);
    await ParliamentContractStub.Release.SendAsync(proposalId);
    
    // Verify the NFT type was added successfully
    var nftTypes = await NFTContractStub.GetNFTTypes.CallAsync(new Empty());
    nftTypes.Value.ShouldContainKey("@@");
    
    // Step 2: Attempt to create an NFT protocol with this type
    var createInput = new CreateInput
    {
        BaseUri = "ipfs://test/",
        Creator = DefaultAddress,
        IsBurnable = true,
        NftType = "CustomType",
        ProtocolName = "TEST",
        TotalSupply = 1000
    };
    
    // Step 3: Creation fails with "Invalid Symbol input" due to special characters
    var exception = await Assert.ThrowsAsync<Exception>(async () => 
        await NFTContractStub.Create.SendAsync(createInput)
    );
    
    exception.Message.ShouldContain("Invalid Symbol input");
    
    // The NFT type is now permanently unusable until governance removes it
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L131-150)
```csharp
    public override Empty AddNFTType(AddNFTTypeInput input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        var fullName = input.FullName;
        Assert(input.ShortName.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
        Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
        State.NFTTypeFullNameMap[input.ShortName] = fullName;
        State.NFTTypeShortNameMap[fullName] = input.ShortName;
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Add(input.ShortName, fullName);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeAdded
        {
            ShortName = input.ShortName,
            FullName = input.FullName
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-169)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        Assert(input.Value.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
        var fullName = State.NFTTypeFullNameMap[input.Value];
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Remove(input.Value);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeRemoved
        {
            ShortName = input.Value
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-63)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;

        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }

        return nftTypes;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L28-31)
```csharp
    private bool IsValidCreateSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+$");
    }
```
