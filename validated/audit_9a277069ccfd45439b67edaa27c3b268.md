# Audit Report

## Title
Missing Timestamp Validation in Round Time Slot Checking Allows Consensus DoS

## Summary
The `CheckRoundTimeSlots` validation method fails to verify that `ExpectedMiningTime` values are reasonable relative to the current block time. A malicious elected miner can exploit this by submitting a `NextRound` transaction with distant future timestamps that pass validation, causing severe consensus disruption as miners cannot satisfy time slot requirements for block production.

## Finding Description

The vulnerability exists in the round time slot validation logic where `CheckRoundTimeSlots` only validates structural properties without temporal bounds checking. [1](#0-0) 

This method checks three conditions: (1) `ExpectedMiningTime` is not null, (2) mining interval is greater than zero, and (3) intervals between consecutive miners are roughly equal. **Critically, no validation ensures timestamps are reasonable relative to `Context.CurrentBlockTime`.**

**Attack Flow:**

1. An attacker who is an elected miner calls the public `NextRound` method: [2](#0-1) 

2. The `PreCheck` validation only verifies miner list membership, not timestamp reasonableness: [3](#0-2) 

3. During block validation, `TimeSlotValidationProvider` calls `CheckRoundTimeSlots` on the provided round: [4](#0-3) 

4. The malicious round with future timestamps passes validation and is stored to state: [5](#0-4) 

5. Subsequent mining attempts fail because `IsCurrentMiner` performs time comparisons that fail when `ExpectedMiningTime` is in the distant future: [6](#0-5) 

When `ExpectedMiningTime` is set to a distant future date (e.g., year 3000) while `Context.CurrentBlockTime` is current (year 2024), the condition `timeSlotStartTime <= Context.CurrentBlockTime` evaluates to false, blocking normal time slot mining.

**Input Control:** The attacker directly controls timestamp values through the `NextRoundInput` structure, which is converted to a `Round` object without timestamp validation: [7](#0-6) 

**Contrast with Legitimate Generation:** Proper round generation calculates timestamps relative to current block time: [8](#0-7) 

However, the `NextRound` method accepts raw `NextRoundInput` which bypasses this legitimate calculation path.

## Impact Explanation

**Severity: HIGH - Consensus DoS**

Once the malicious round is stored to state, the blockchain experiences severe consensus disruption:

1. **Block Production Severely Impaired:** Most miners fail the `IsCurrentMiner` check because their `ExpectedMiningTime` is in the distant future while `Context.CurrentBlockTime` remains in the present
2. **Limited Recovery Window:** Only the `ExtraBlockProducerOfPreviousRound` might pass the check at lines 150-154 due to the condition `Context.CurrentBlockTime <= currentRound.GetRoundStartTime()`, but this single miner cannot restore normal consensus operation
3. **Abnormal Mining Time Calculation Broken:** The `ArrangeAbnormalMiningTime` method relies on calculating `distanceToRoundStartTime = currentBlockTime - GetRoundStartTime()`, which produces negative or incorrect values when timestamps are in the future: [9](#0-8) 

4. **Network-Wide Impact:** All validators and users are affected simultaneously
5. **Recovery Difficulty:** Requires manual intervention, likely a hard fork or chain rollback to a state before the malicious round

This breaks the fundamental consensus guarantee that the network can continue producing blocks as long as Byzantine miners are below the threshold. A single malicious elected miner can cause severe consensus disruption.

## Likelihood Explanation

**Probability: MEDIUM**

**Preconditions:**
- Attacker must be an elected miner (verified by `PreCheck` in the current or previous round's miner list)
- In a typical DPoS system with 21-100 validators, this is a realistic threat model where any validator could be compromised or turn malicious

**Attack Complexity:**
- **Low** - The attacker simply crafts a `NextRoundInput` message with modified `ExpectedMiningTime` values set to distant future dates while maintaining valid 4000ms intervals
- No cryptographic operations or complex exploitation required
- Single transaction execution through the public `NextRound` method

**Detection:**
- **None before execution** - The attack succeeds silently during validation
- No timestamp bound checks exist in the validation pipeline
- The malicious round appears structurally valid to all validation providers

The combination of realistic preconditions (compromised validator), trivial execution complexity, and catastrophic impact justifies a MEDIUM likelihood assessment.

## Recommendation

Add timestamp bounds validation to `CheckRoundTimeSlots` to ensure `ExpectedMiningTime` values are reasonable relative to `Context.CurrentBlockTime`:

```csharp
public ValidationResult CheckRoundTimeSlots(Timestamp currentBlockTime)
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    // NEW: Validate timestamps are reasonable relative to current time
    var firstMinerTime = miners[0].ExpectedMiningTime;
    var maxAllowedDelay = GetMiningInterval() * miners.Count * 2; // Allow 2x normal round duration
    
    if (firstMinerTime < currentBlockTime)
        return new ValidationResult { Message = "Round start time cannot be in the past." };
    
    if ((firstMinerTime - currentBlockTime).Milliseconds() > maxAllowedDelay)
        return new ValidationResult { Message = "Round start time too far in the future." };

    var baseMiningInterval = (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();
    
    if (baseMiningInterval <= 0)
        return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

    for (var i = 1; i < miners.Count - 1; i++)
    {
        var miningInterval = (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
        if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
            return new ValidationResult { Message = "Time slots are so different." };
    }

    return new ValidationResult { Success = true };
}
```

Update `TimeSlotValidationProvider` to pass `Context.CurrentBlockTime` to the validation method, and modify the consensus validation context to include this timestamp for proper bounds checking.

## Proof of Concept

A proof of concept would involve:

1. Deploy a test chain with multiple miners
2. Have one miner craft a `NextRoundInput` with all `ExpectedMiningTime` values set to timestamps 1000 years in the future (maintaining proper 4000ms intervals)
3. Submit the `NextRound` transaction
4. Observe that validation passes (CheckRoundTimeSlots returns Success)
5. Verify that subsequent `IsCurrentMiner` calls for all miners return false
6. Confirm that normal block production is disrupted

The test would demonstrate that structural validation passes while temporal validation is absent, enabling the consensus DoS attack.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-19)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L159-167)
```csharp
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;

        // Check normal time slot.
        if (timeSlotStartTime <= Context.CurrentBlockTime && Context.CurrentBlockTime <=
            timeSlotStartTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]NORMAL");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L33-36)
```csharp
        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
```
