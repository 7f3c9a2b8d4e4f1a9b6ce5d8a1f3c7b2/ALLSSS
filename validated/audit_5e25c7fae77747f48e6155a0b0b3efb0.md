# Audit Report

## Title
BurnProfits Unconditionally Overwrites DistributedProfitsMap Causing Loss of Pre-Contributed Profits

## Summary
The `BurnProfits` function creates a new `DistributedProfitsInfo` object and unconditionally overwrites existing state without preserving pre-contributed profits. When users contribute tokens to future periods via `ContributeProfits` and the scheme later has zero `totalShares` at distribution time, `BurnProfits` destroys the accounting record while tokens remain locked in period-specific virtual addresses, making them permanently unclaimable.

## Finding Description

The vulnerability exists in how `BurnProfits` handles periods that already have pre-contributed profits.

When users contribute to future periods, `ContributeProfits` validates the period is valid [1](#0-0) , generates a period-specific virtual address [2](#0-1) , and transfers tokens there [3](#0-2) . The contribution is recorded in `DistributedProfitsMap` [4](#0-3) .

When `DistributeProfits` is later called for that period with `totalShares <= 0`, it invokes `BurnProfits` [5](#0-4) .

The critical flaw is in `BurnProfits` implementation: it creates a **brand new** `DistributedProfitsInfo` object [6](#0-5)  without reading any existing state. It then burns tokens from the scheme's **general ledger** [7](#0-6) , not from the period-specific address where pre-contributions were deposited. Finally, it unconditionally overwrites the state [8](#0-7) , destroying all records of previously contributed profits.

In contrast, the normal distribution path via `UpdateDistributedProfits` correctly reads existing state [9](#0-8)  and checks the period-specific address balance [10](#0-9) .

After `BurnProfits` sets `IsReleased=true`, future contributions to that period are blocked [11](#0-10) .

When users try to claim profits via `ClaimProfits`, the calculation depends entirely on `DistributedProfitsMap` [12](#0-11) . With the accounting destroyed, the contributed tokens become permanently unrecoverable despite remaining in the period-specific virtual address.

## Impact Explanation

**High Severity - Permanent Loss of User Funds:**

1. **Complete Fund Loss:** Tokens contributed to future periods become permanently locked in period-specific virtual addresses with no recovery mechanism. The accounting in `DistributedProfitsMap` is destroyed, and `ClaimProfits` cannot retrieve these funds.

2. **Quantified Damage:** The impact scales linearly with contribution amounts. If 10,000 ELF tokens are contributed to period 5, and the scheme has zero beneficiaries when period 5 arrives, all 10,000 ELF become permanently locked.

3. **Affected Parties:**
   - Users who contribute profits to future periods expecting normal distribution
   - Scheme managers who inadvertently trigger this by removing all beneficiaries during scheme wind-down
   - The overall protocol, as tokens become permanently stuck in virtual addresses

4. **No Recovery Path:** Once `BurnProfits` executes, there is no mechanism to recover the contributed funds. The virtual address still holds the tokens, but all accounting is lost.

## Likelihood Explanation

**Medium Likelihood - Triggered Through Normal Operations:**

1. **Public Entry Point:** `ContributeProfits` is a public method callable by any user with token allowance, requiring no special privileges for the contribution step.

2. **Realistic Preconditions:**
   - Profit scheme exists and accepts contributions (common scenario)
   - User contributes to a future period (explicitly allowed by the contract at line 684)
   - By the time that period arrives, all beneficiaries have been removed via `RemoveBeneficiary`, resulting in `totalShares = 0`
   - Scheme manager calls `DistributeProfits` for the period

3. **Natural Occurrence:** This scenario occurs when:
   - A scheme is being wound down and beneficiaries are systematically removed
   - Users had previously contributed to future periods expecting normal operation
   - The timing gap between contribution and distribution allows legitimate beneficiary changes

4. **No Attack Cost:** Beyond the initial contribution (which could be small), there's no additional cost to trigger the vulnerability. The loss occurs through legitimate contract operations.

5. **Detection Difficulty:** Both `ContributeProfits` and `RemoveBeneficiary` are legitimate operations. The fund loss only becomes apparent when users attempt to claim profits, potentially much later.

## Recommendation

The `BurnProfits` method should be modified to:

1. **Read existing state** before creating a new object, similar to `UpdateDistributedProfits`
2. **Check the period-specific virtual address balance** and include pre-contributed amounts
3. **Preserve pre-contribution accounting** by reading and merging with existing `DistributedProfitsInfo`

Suggested fix for the `BurnProfits` method:

```csharp
private Empty BurnProfits(long period, Dictionary<string, long> profitsMap, Scheme scheme,
    Address profitsReceivingVirtualAddress)
{
    scheme.CurrentPeriod = period.Add(1);

    // Read existing state instead of creating new
    var distributedProfitsInfo = State.DistributedProfitsMap[profitsReceivingVirtualAddress] 
        ?? new DistributedProfitsInfo();
    
    distributedProfitsInfo.IsReleased = true;
    
    foreach (var profits in profitsMap)
    {
        var symbol = profits.Key;
        var amount = profits.Value;
        if (amount > 0)
        {
            var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = scheme.VirtualAddress,
                Symbol = symbol
            });
            if (balanceOfToken.Balance >= amount)
            {
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
                distributedProfitsInfo.AmountsMap[symbol] = 
                    distributedProfitsInfo.AmountsMap.ContainsKey(symbol)
                        ? distributedProfitsInfo.AmountsMap[symbol] - amount
                        : -amount;
            }
        }
    }

    State.SchemeInfos[scheme.SchemeId] = scheme;
    State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
    return new Empty();
}
```

This ensures that pre-contributed amounts are preserved in the accounting even when burning occurs.

## Proof of Concept

```csharp
[Fact]
public async Task BurnProfits_LosePreContributedFunds_Test()
{
    // Setup: Create scheme
    var schemeId = await CreateScheme();
    
    // Add initial beneficiary so scheme has shares
    await AddBeneficiary(schemeId, beneficiary: UserAddress, shares: 100);
    
    // User contributes 10000 ELF to future period 5
    await ApproveToken(UserAddress, ProfitContractAddress, 10000);
    await ContributeProfits(schemeId, period: 5, amount: 10000, symbol: "ELF");
    
    // Verify contribution was recorded
    var periodAddress = await GetSchemeAddress(schemeId, period: 5);
    var balanceBefore = await GetBalance(periodAddress, "ELF");
    Assert.Equal(10000, balanceBefore);
    
    // Remove all beneficiaries (scheme wind-down)
    await RemoveBeneficiary(schemeId, UserAddress);
    
    // Advance to period 5 and distribute with zero shares
    await AdvanceToPeriod(schemeId, 5);
    await DistributeProfits(schemeId, period: 5);
    
    // Verify tokens still in virtual address
    var balanceAfter = await GetBalance(periodAddress, "ELF");
    Assert.Equal(10000, balanceAfter); // Tokens still there
    
    // Verify accounting destroyed - user cannot claim
    var distributedInfo = await GetDistributedProfitsInfo(schemeId, period: 5);
    Assert.True(distributedInfo.IsReleased);
    Assert.False(distributedInfo.AmountsMap.ContainsKey("ELF") && 
                 distributedInfo.AmountsMap["ELF"] == 10000); // Accounting lost
    
    // Permanent loss: tokens locked, no way to claim
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L522-525)
```csharp
        var distributedProfitsInfo = new DistributedProfitsInfo
        {
            IsReleased = true
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L532-545)
```csharp
                var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = symbol
                });
                if (balanceOfToken.Balance < amount)
                    continue;
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L556-556)
```csharp
        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L563-565)
```csharp
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L574-578)
```csharp
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L684-684)
```csharp
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L685-686)
```csharp
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L698-699)
```csharp
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L704-710)
```csharp
            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L712-712)
```csharp
            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L867-871)
```csharp
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```
