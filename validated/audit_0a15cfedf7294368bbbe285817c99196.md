# Audit Report

## Title
Unvalidated Secret Sharing Revelations Allow Consensus State Poisoning via First-Write-Wins Policy

## Summary
The AEDPoS consensus contract accepts `RevealedInValues` from miner-controlled trigger information without cryptographic validation, implementing a first-write-wins policy that allows malicious miners to inject incorrect `PreviousInValue` data for other miners. These poisoned values persist to state and corrupt consensus signatures through XOR operations, affecting randomness generation and mining order.

## Finding Description

The vulnerability exists in the secret sharing revelation mechanism where a malicious miner can inject arbitrary `PreviousInValue` data for other miners without on-chain validation.

**Attack Flow:**

When a miner produces a block with `UpdateValue` behavior, their node provides trigger information containing `RevealedInValues` through the off-chain `SecretSharingService`. [1](#0-0)  Since this service runs on the miner's node, they can modify it to return arbitrary values instead of legitimately computed secret sharing results.

The `UpdateLatestSecretPieces()` method processes these revealed values and writes them directly to the Round object if the target miner's `PreviousInValue` is null or empty, implementing a first-write-wins policy. [2](#0-1) 

The modified Round flows into transaction input via `ExtractInformationToUpdateConsensus()`, which extracts all non-null `PreviousInValue` fields into `MinersPreviousInValues`. [3](#0-2) 

During transaction execution, `PerformSecretSharing()` writes these unvalidated values directly to on-chain state without any verification. [4](#0-3) 

When `NextRound` is triggered, `SupplyCurrentRoundInformation()` reads the poisoned `PreviousInValue` from state for miners who didn't mine, and uses it to calculate their signatures via `CalculateSignature()`. [5](#0-4) 

**Root Cause:**

The validation provider only checks the sender's own `PreviousInValue` against their previous `OutValue`. [6](#0-5) 

No validation occurs for the `RevealedInValues` that the sender provides for OTHER miners. The legitimate `RevealSharedInValues` method cannot correct this because it only reconstructs values for miners with sufficient encrypted/decrypted pieces, which don't exist for miners who failed to mine. [7](#0-6) 

## Impact Explanation

**Consensus State Corruption:** The attack corrupts the cryptographic integrity of consensus state. The `CalculateSignature` method performs XOR operations that combine the malicious `PreviousInValue` with all miners' existing signatures. [8](#0-7) 

**Specific Impacts:**
- **Randomness Manipulation**: Incorrect signatures affect consensus randomness generation used for block producer selection and other consensus operations
- **Mining Order Disruption**: Corrupted signature values influence the calculated mining order for subsequent rounds through the XOR-based signature mechanism
- **Persistent State Corruption**: Incorrect values remain in on-chain state until affected miners successfully mine again, potentially spanning multiple rounds
- **Consensus Integrity Violation**: The fundamental security guarantee that consensus state reflects legitimate cryptographic operations is broken

While this doesn't directly result in fund theft, it undermines the security properties of the consensus mechanism itself, which is critical for blockchain operation.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a scheduled miner in the current miner list
- Must control their node software to inject arbitrary `RevealedInValues` in trigger information  
- Must produce a block during a round where target miners have failed to mine

**Feasibility:** MEDIUM
- Miners naturally control their own node software and can modify the `SecretSharingService` that generates revealed values [9](#0-8) 
- The trigger information is generated by the attacker's node and directly accepted by the contract [10](#0-9) 
- The first-write-wins policy ensures malicious values persist once written
- Detection is difficult as revealed values appear legitimate without independent secret sharing verification

**Exploitation Window:** The attack targets miners who missed their time slots in previous rounds, which naturally occurs during network issues or node maintenance.

## Recommendation

Implement cryptographic verification of `RevealedInValues` by reconstructing the expected value from on-chain `DecryptedPieces` and comparing it to the provided value. Only accept revealed values that match the secret sharing reconstruction.

```csharp
private void UpdateLatestSecretPieces(Round updatedRound, string pubkey,
    AElfConsensusTriggerInformation triggerInformation)
{
    // ... existing encrypted/decrypted pieces logic ...

    foreach (var revealedInValue in triggerInformation.RevealedInValues)
    {
        if (!updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key)) continue;
        
        var targetMiner = updatedRound.RealTimeMinersInformation[revealedInValue.Key];
        
        // Only apply if PreviousInValue is not set
        if (targetMiner.PreviousInValue != Hash.Empty && targetMiner.PreviousInValue != null) 
            continue;

        // NEW: Verify the revealed value matches secret sharing reconstruction
        if (TryToGetPreviousRoundInformation(out var previousRound) &&
            previousRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
        {
            var minerInPrevRound = previousRound.RealTimeMinersInformation[revealedInValue.Key];
            var minersCount = updatedRound.RealTimeMinersInformation.Count;
            var minimumCount = minersCount.Mul(2).Div(3);
            
            // Only accept if sufficient pieces exist to verify
            if (minerInPrevRound.EncryptedPieces.Count >= minimumCount &&
                minerInPrevRound.DecryptedPieces.Count >= minersCount)
            {
                // Reconstruct and verify
                var orders = minerInPrevRound.DecryptedPieces.Select((t, i) =>
                        previousRound.RealTimeMinersInformation.Values
                            .First(m => m.Pubkey == minerInPrevRound.DecryptedPieces.Keys.ToList()[i]).Order)
                    .ToList();
                var sharedParts = minerInPrevRound.DecryptedPieces.Values.ToList()
                    .Select(s => s.ToByteArray()).ToList();
                var expectedValue = HashHelper.ComputeFrom(
                    SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
                
                // Only accept if matches expected value
                if (revealedInValue.Value != expectedValue)
                    continue;
            }
            else
            {
                // Don't accept unverifiable values
                continue;
            }
        }
        
        targetMiner.PreviousInValue = revealedInValue.Value;
    }
}
```

## Proof of Concept

Due to the complexity of the consensus system requiring multiple rounds, miner setup, and secret sharing state, a complete working test would require significant test infrastructure. However, the vulnerability can be demonstrated by:

1. Setting up a test with multiple miners where one miner (B) fails to mine in Round N
2. Having a malicious miner (A) produce an UpdateValue block in Round N+1
3. Providing malicious `RevealedInValues["B"] = <arbitrary_hash>` in trigger information
4. Observing that the malicious value is written to state via `UpdateLatestSecretPieces` 
5. Verifying that when NextRound triggers, the poisoned value is used in `CalculateSignature`

The key verification points are:
- Lines 148-152 of `AEDPoSContract_GetConsensusBlockExtraData.cs` show first-write-wins logic with no validation
- Lines 35-49 of `UpdateValueValidationProvider.cs` show validation only checks sender's own value
- Lines 295-296 of `AEDPoSContract_ProcessConsensusInformation.cs` show unchecked write to state
- Lines 191-199 of `AEDPoSContract.cs` show usage of potentially poisoned values in signature calculation

## Notes

This vulnerability specifically targets miners who have failed to mine in previous rounds, as they lack the encrypted/decrypted pieces needed for legitimate secret sharing verification. The attack window opens whenever network issues or maintenance cause miners to miss their time slots, which is a natural occurrence in distributed systems.

The legitimate `RevealSharedInValues` method cannot correct these poisoned values because it skips miners without sufficient pieces, allowing the malicious first-write to persist until the victim miner successfully produces a block.

### Citations

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L112-114)
```csharp
            var revealedInValues = _secretSharingService.GetRevealedInValues(hint.RoundId);
            foreach (var revealedInValue in revealedInValues)
                trigger.RevealedInValues.Add(revealedInValue.Key, revealedInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L122-125)
```csharp
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L144-184)
```csharp
    private void RevealPreviousInValues(SecretSharingInformation secretSharingInformation, string selfPubkey)
    {
        var round = secretSharingInformation.PreviousRound;
        var minersCount = round.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        var revealedInValues = new Dictionary<string, Hash>();

        foreach (var pair in round.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == selfPubkey) continue;

            var pubkey = pair.Key;
            var minerInRound = pair.Value;

            if (minerInRound.EncryptedPieces.Count < minimumCount) continue;
            if (minerInRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = minerInRound.DecryptedPieces.Select((t, i) =>
                    round.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    minerInRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = minerInRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            Logger.LogDebug($"Revealed in value of {pubkey} of round {round.RoundNumber}: {revealedInValue}");

            revealedInValues[pubkey] = revealedInValue;
        }

        _revealedInValues[secretSharingInformation.CurrentRoundId] = revealedInValues;
    }
```
