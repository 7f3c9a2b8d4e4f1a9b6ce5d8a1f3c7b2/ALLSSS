# Audit Report

## Title
Self-Referential Method Fee Setting Enables Governance Lockout

## Summary
The `SetMethodFee` function in the Genesis contract lacks validation to prevent setting transaction fees on itself, allowing governance to configure a fee that must be paid to modify any method fees. If set excessively high and the Parliament organization's virtual address lacks sufficient funds, governance becomes permanently locked out of all method fee management system-wide.

## Finding Description

The `SetMethodFee` method stores fee configurations without validating whether `input.MethodName` references itself, directly storing the value into `State.TransactionFees[input.MethodName]` with only token validity and authorization checks. [1](#0-0) 

When Parliament releases an approved proposal, the transaction originates from the organization's virtual address calculated via `CalculateVirtualHash` and executed through `Context.SendVirtualInlineBySystemContract`. [2](#0-1) [3](#0-2) 

Before any transaction executes, the pre-execution plugin generates a `ChargeTransactionFees` transaction that retrieves the method fee via `Context.Call<MethodFees>` and attempts to charge fees from `Context.Sender` (which is the organization's virtual address for proposal executions). [4](#0-3) 

The `GetMethodFee` method returns the stored fee from `State.TransactionFees[input.Value]` without any special exemption for `SetMethodFee` or other governance-critical methods. [5](#0-4) 

If fee charging fails due to insufficient balance, the `IsStopExecuting` method in the pre-execution plugin returns `true` (by checking `!chargeTransactionFeesOutput.Success`), which blocks the main transaction from executing. [6](#0-5) 

The fee charging logic treats organization virtual addresses identically to regular addresses. The only exemption in `IsExemptedTransaction` is for `ChargeTransactionFees` calls to the token contract itself, with no special handling for governance operations. [7](#0-6) 

Both `SetMethodFee` and `ChangeMethodFeeController` require authorization from the same `State.MethodFeeController.Value.OwnerAddress` (defaulting to Parliament's default organization), providing no alternative recovery path. [8](#0-7) 

## Impact Explanation

Once a prohibitively high fee is configured for `SetMethodFee`, all future method fee modifications require paying that fee from Parliament's virtual address. Since `SetMethodFee` is the only mechanism to modify method fees (including reducing its own fee), and `ChangeMethodFeeController` requires identical authorization, governance lockout occurs if the organization cannot afford the fee.

This affects system-wide fee management capability across all contracts. Test evidence confirms organizations must pre-fund their virtual addresses before releasing proposals, as demonstrated by the explicit `TransferToOrganizationAddressAsync` call required before proposal release. [9](#0-8) 

If the fee exceeds economically feasible amounts (e.g., exceeding total circulating ELF supply), recovery becomes mathematically impossible, resulting in permanent loss of fee governance across the entire system. This breaks the critical invariant that governance should always be able to recover from misconfigurations.

## Likelihood Explanation

While this requires Parliament governance approval (2/3 miner consensus), it represents a realistic threat through:

1. **Human error**: Accidental misconfiguration during routine fee updates (e.g., incorrect decimal places: intending 100 ELF but setting 100000000 ELF due to copy-paste error or unit confusion)
2. **Lack of validation**: The `AssertValidToken` helper only validates that the amount is non-negative and the token exists, with no upper bounds checking or warnings for excessive values [10](#0-9) 
3. **Approval blindness**: Multiple miners could approve routine-looking fee adjustment proposals without detailed value verification, especially if the proposal description doesn't highlight the magnitude

The attack requires only one successful governance proposal with `input.MethodName = "SetMethodFee"` and an excessive fee value. The precondition (governance approval) is routine as Parliament regularly votes on fee adjustments during normal operations, making this a realistic operational mistake scenario rather than requiring malicious intent.

## Recommendation

Implement self-referential validation and bounds checking in `SetMethodFee`:

```csharp
public override Empty SetMethodFee(MethodFees input)
{
    // Prevent setting fees on critical governance methods
    Assert(input.MethodName != nameof(SetMethodFee) && 
           input.MethodName != nameof(ChangeMethodFeeController),
           "Cannot set fees on fee governance methods.");
    
    foreach (var methodFee in input.Fees)
    {
        AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        
        // Add reasonable upper bound check (e.g., 10000 ELF)
        Assert(methodFee.BasicFee <= 10000_00000000, 
               "Fee amount exceeds reasonable maximum.");
    }
    
    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, 
           "Unauthorized to set method fee.");
    State.TransactionFees[input.MethodName] = input;
    
    return new Empty();
}
```

Additionally, consider implementing an emergency recovery mechanism that allows a supermajority (e.g., 100% miner consensus) to reset critical fee configurations to default values.

## Proof of Concept

```csharp
[Fact]
public async Task SetMethodFee_SelfReferential_CausesGovernanceLockout()
{
    // 1. Setup: Create Parliament organization
    var organizationAddress = await CreateOrganizationAsync(6667, 2000, 3000, 8000);
    
    // 2. Create proposal to set excessive fee on SetMethodFee itself
    var setMethodFeeInput = new MethodFees
    {
        MethodName = "SetMethodFee",
        Fees = { new MethodFee { Symbol = "ELF", BasicFee = 999999999_00000000 } } // 999M ELF
    };
    
    var proposalId = await CreateProposalAsync(
        DefaultSenderKeyPair, 
        organizationAddress,
        nameof(BasicContractZero.SetMethodFee),
        setMethodFeeInput
    );
    
    // 3. Transfer only 1000 ELF to organization (insufficient for future fee)
    await TransferToOrganizationAddressAsync(organizationAddress, 1000_00000000);
    
    // 4. Approve and release proposal
    await ApproveAsync(InitialMinersKeyPairs[0], proposalId);
    await ApproveAsync(InitialMinersKeyPairs[1], proposalId);
    await ApproveAsync(InitialMinersKeyPairs[2], proposalId);
    await ParliamentContractStub.Release.SendAsync(proposalId);
    
    // 5. Verify fee was set
    var methodFee = await BasicContractZeroStub.GetMethodFee.CallAsync(
        new StringValue { Value = "SetMethodFee" });
    methodFee.Fees[0].BasicFee.ShouldBe(999999999_00000000);
    
    // 6. Attempt to fix by reducing the fee - THIS WILL FAIL
    var fixProposalInput = new MethodFees
    {
        MethodName = "SetMethodFee",
        Fees = { new MethodFee { Symbol = "ELF", BasicFee = 100_00000000 } }
    };
    
    var fixProposalId = await CreateProposalAsync(
        DefaultSenderKeyPair,
        organizationAddress,
        nameof(BasicContractZero.SetMethodFee),
        fixProposalInput
    );
    
    await ApproveAsync(InitialMinersKeyPairs[0], fixProposalId);
    await ApproveAsync(InitialMinersKeyPairs[1], fixProposalId);
    await ApproveAsync(InitialMinersKeyPairs[2], fixProposalId);
    
    // 7. Release fails due to insufficient balance to pay 999M ELF fee
    var releaseResult = await ParliamentContractStub.Release.SendWithExceptionAsync(fixProposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Transaction fee not enough");
    
    // 8. Governance is now permanently locked out - cannot modify any method fees
}
```

## Notes

This vulnerability represents a **design flaw** in the fee governance system where lack of validation enables a catastrophic failure mode through realistic operational mistakes. While Parliament is a trusted role, the absence of safety guards violates the critical invariant that governance should always be recoverable from misconfigurations. The issue is not about malicious governance but about missing defensive programming practices (input validation, bounds checking, self-referential prevention) that are essential for system robustness.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L9-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L34-47)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var fees = State.TransactionFees[input.Value];
        if (fees == null && input.Value == nameof(ReleaseApprovedUserSmartContract))
        {
            fees = new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        }

        return fees;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L73-82)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L307-312)
```csharp
    private Hash CalculateVirtualHash(Hash organizationHash, Hash creationToken)
    {
        return creationToken == null
            ? organizationHash
            : HashHelper.ConcatAndCompute(organizationHash, creationToken);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-53)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L123-129)
```csharp
    public bool IsStopExecuting(ByteString txReturnValue, out string preExecutionInformation)
    {
        var chargeTransactionFeesOutput = new ChargeTransactionFeesOutput();
        chargeTransactionFeesOutput.MergeFrom(txReturnValue);
        preExecutionInformation = chargeTransactionFeesOutput.ChargingInformation;
        return !chargeTransactionFeesOutput.Success;
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/FeeChargePreExecutionPlugin.cs (L25-31)
```csharp
    protected override bool IsExemptedTransaction(Transaction transaction, Address tokenContractAddress,
        TokenContractImplContainer.TokenContractImplStub tokenStub)
    {
        return transaction.To == tokenContractAddress &&
               (transaction.MethodName == nameof(tokenStub.ChargeTransactionFees) || transaction.MethodName ==
                   nameof(tokenStub.ChargeUserContractTransactionFees));
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L719-748)
```csharp
    {
        // await InitializeParliamentContracts();
        var minimalApprovalThreshold = 6667;
        var maximalAbstentionThreshold = 2000;
        var maximalRejectionThreshold = 3000;
        var minimalVoteThreshold = 8000;
        var organizationAddress = await CreateOrganizationAsync(minimalApprovalThreshold,
            maximalAbstentionThreshold, maximalRejectionThreshold, minimalVoteThreshold);
        var proposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
        await TransferToOrganizationAddressAsync(organizationAddress);
        await ApproveAsync(InitialMinersKeyPairs[0], proposalId);
        await ApproveAsync(InitialMinersKeyPairs[1], proposalId);
        await ApproveAsync(InitialMinersKeyPairs[2], proposalId);

        ParliamentContractStub = GetParliamentContractTester(DefaultSenderKeyPair);
        var result = await ParliamentContractStub.Release.SendAsync(proposalId);
        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        // Check inline transaction result
        var getBalance = TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = "ELF",
            Owner = Tester
        }).Result.Balance;
        getBalance.ShouldBe(100);

        var proposalInfo = await ParliamentContractStub.GetProposal.CallAsync(proposalId);
        proposalInfo.ShouldBe(new ProposalOutput());
    }

```
