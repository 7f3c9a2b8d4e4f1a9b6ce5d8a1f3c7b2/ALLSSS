# Audit Report

## Title
Cross-Term Secret Sharing Corruption in NextRound Consensus Behavior

## Summary
The `RevealSharedInValues` function is called during `NextRound` consensus behavior without validating that `currentRound` and `previousRound` belong to the same term. When a term transition occurs and miner counts differ, the function uses secret sharing data from the old term with threshold parameters calculated from the new term, causing mismatches that corrupt `PreviousInValue` fields and subsequent consensus signatures.

## Finding Description

When transitioning from round 1 to round 2 of a new term, `GetConsensusExtraDataForNextRound` calls `RevealSharedInValues` without term validation [1](#0-0) . This function retrieves the previous round [2](#0-1)  which, after a term change, belongs to the old term with a potentially different miner count.

The function calculates threshold parameters from the NEW term's miner count [3](#0-2)  but applies them to secret sharing pieces from the OLD term [4](#0-3) . Specifically, the validation at line 36 checks if `DecryptedPieces.Count < minersCount` where `minersCount` is from the new term, but the pieces were generated for the old term's miner count.

In contrast, `GetConsensusExtraDataToPublishOutValue` properly validates term boundaries before using previous round data [5](#0-4)  using the `IsFirstRoundOfCurrentTerm` check [6](#0-5) .

While `AddRoundInformation` prevents NEW secret sharing generation when the miner list changes [7](#0-6) , it does NOT prevent `RevealSharedInValues` from USING old cross-term secret sharing data. The first round of a new term has `IsMinerListJustChanged` set to true [8](#0-7)  but this only affects secret sharing generation, not consumption.

The corrupted `PreviousInValue` is stored in the current round's miner information [9](#0-8)  and subsequently used in signature calculations.

## Impact Explanation

**Consensus Integrity Corruption**: The incorrectly decoded `PreviousInValue` directly corrupts consensus signatures. These signatures are fundamental to AEDPoS consensus for:

1. **Signature Chain Integrity**: Signatures form a cryptographic chain where each signature depends on the previous in-value. Corrupted values break this chain's verifiability.

2. **Randomness Source**: Signatures are converted to random values that determine mining order and extra block producer selection. Corrupted signatures compromise this randomness, potentially affecting block producer fairness.

3. **Consensus Divergence**: When multiple miners process the corrupted round transition, they may produce inconsistent round data, leading to consensus instability.

**Severity: Medium-High** because:
- Directly impacts core consensus integrity (critical invariant)
- No direct fund theft, but corrupts fundamental security properties
- Affects all miners transitioning across terms
- Can compromise randomness-dependent features (block producer selection, rewards)

## Likelihood Explanation

**Trigger Path**: The public `NextRound` method [10](#0-9)  triggers this vulnerability when called during the first round of a new term.

**Automatic Execution**: The consensus behavior provider returns `NextRound` behavior when `CurrentRound.RoundNumber == 1` [11](#0-10) . This means after any term transition via `ProcessNextTerm` [12](#0-11) , the next round advancement will trigger `NextRound` behavior.

**Preconditions**:
1. Term transition occurs (periodic, every `PeriodSeconds`)
2. Miner count or membership changes between terms
3. Any miner calls `NextRound` to advance from round 1 to round 2 of the new term

These are normal consensus operations requiring no special privileges or timingâ€”just being a miner in the current term.

**Probability: High** - Occurs automatically on every term transition where miner count changes. Term transitions are periodic and the vulnerability triggers during standard consensus progression.

## Recommendation

Add term validation in `GetConsensusExtraDataForNextRound` before calling `RevealSharedInValues`, similar to the protection in `GetConsensusExtraDataToPublishOutValue`:

```csharp
private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
    string pubkey, AElfConsensusTriggerInformation triggerInformation)
{
    GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

    nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

    if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };

    // Add term validation check
    if (!IsFirstRoundOfCurrentTerm(out _))
    {
        RevealSharedInValues(currentRound, pubkey);
    }

    nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
    Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
    nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
    nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
        .Add(Context.CurrentBlockTime);

    return new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteStringHelper.FromHexString(pubkey),
        Round = nextRound,
        Behaviour = triggerInformation.Behaviour
    };
}
```

This ensures that secret sharing revelation only occurs when both current and previous rounds belong to the same term, preventing cross-term threshold mismatches.

## Proof of Concept

A proof of concept would require:

1. Initialize consensus with Term N having 5 miners
2. Run consensus through Term N until term transition time
3. Call `NextTerm` to create Term N+1 with 7 miners (different count)
4. Verify round 1 of Term N+1 is current
5. Call `NextRound` to advance from round 1 to round 2
6. Observe that `RevealSharedInValues` attempts to decode secrets using:
   - `minersCount = 7` (from new term)
   - `minimumCount = 4` (7 * 2 / 3)
   - But `DecryptedPieces` from previous round has at most 5 pieces (from old term with 5 miners)
7. The validation `DecryptedPieces.Count < minersCount` (5 < 7) passes, skipping all secret reveals
8. Alternatively, if count decreased (7 to 5), wrong `minimumCount` corrupts decoding

The key evidence is that the behavior provider guarantees `NextRound` is called for round 1, making this a deterministic issue during normal term transitions with miner count changes.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L72-72)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L19-19)
```csharp
        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L25-50)
```csharp
        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L52-52)
```csharp
            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L27-34)
```csharp
    private bool IsFirstRoundOfCurrentTerm(out long termNumber)
    {
        termNumber = 1;
        return (TryToGetTermNumber(out termNumber) &&
                TryToGetPreviousRoundInformation(out var previousRound) &&
                previousRound.TermNumber != termNumber) ||
               (TryToGetRoundNumber(out var roundNumber) && roundNumber == 1);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-115)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L42-42)
```csharp
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L30-35)
```csharp
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```
