# Audit Report

## Title
TokenHolder RemoveBeneficiary Allows Profit Rights Revocation While Tokens Remain Locked

## Summary
The `RemoveBeneficiary` function in TokenHolderContract allows scheme managers to remove a user's beneficiary status from the profit scheme while their tokens remain locked in the MultiToken contract. This creates a critical state inconsistency where users have tokens forcibly locked without receiving any profit distributions until the minimum lock period expires, violating the fundamental economic invariant that locked tokens should always entitle holders to profits.

## Finding Description

The vulnerability exists because `RemoveBeneficiary` only removes beneficiary status from the Profit contract but fails to unlock the corresponding locked tokens or remove the lockId from state. [1](#0-0) 

When a user calls `RegisterForProfits`, three interconnected state changes occur atomically: (1) tokens are locked via MultiToken contract, (2) the lockId is stored in state, and (3) the user is added as a beneficiary with shares equal to the locked amount. [2](#0-1) 

However, `RemoveBeneficiary` only reverses the beneficiary registration (step 3) without unlocking tokens or removing the lockId. When `input.Amount == 0`, the conditional re-add at line 85-95 is skipped, completely removing the user's profit rights while tokens remain locked.

**Why Protections Fail:**

The only function that removes lockIds from state is `Withdraw`, which users cannot call until the minimum lock period expires. [3](#0-2) 

Users cannot directly unlock their tokens from the MultiToken contract because the virtual address for locking is computed based on `Context.Sender`, which is the TokenHolder contract address during lock operations. [4](#0-3) 

The unlock operation also uses the same virtual address computation, making direct user unlock impossible as the `Context.Sender` would differ. [5](#0-4) 

When `Withdraw` is eventually called, it attempts to remove the beneficiary again, but the Profit contract gracefully handles non-existent beneficiaries by returning early without error. [6](#0-5) 

TokenHolder schemes are always created with `CanRemoveBeneficiaryDirectly = true`, which enables the Profit contract to remove beneficiaries directly without period restrictions. [7](#0-6) 

## Impact Explanation

This vulnerability causes direct financial harm to users:

1. **Profit Loss**: Users' locked tokens no longer generate any profit rights. During the lock period, all profits that should be distributed to the affected user are instead redistributed proportionally to remaining beneficiaries, effectively transferring the user's rightful share to others.

2. **Forced Lock Without Benefit**: Users cannot access their locked tokens until the minimum lock period expires (configurable per scheme), creating a situation where capital is locked without any return.

3. **Economic Invariant Violation**: The scheme design explicitly creates locked tokens and beneficiary status together as an atomic operation in `RegisterForProfits`, establishing the protocol's guarantee that these states remain synchronized. Breaking this invariant undermines the fundamental trust model of the profit-sharing mechanism.

**Quantified Example**: If a user locks 1,000 tokens representing 10% of total locked amount, and 10,000 tokens are distributed as profits after the manager removes their beneficiary status, the user receives 0 tokens instead of the expected 1,000 tokens. The remaining beneficiaries receive this 1,000 tokens as additional profit.

This is CRITICAL severity because it enables direct profit theft while tokens remain forcibly locked, impacting user funds and violating protocol economic guarantees.

## Likelihood Explanation

The likelihood is HIGH:

**Attacker Profile**: The attacker must be the scheme manager set during `CreateScheme`. This is NOT a trusted system role but rather any user who creates a profit scheme. Realistic threat scenarios include:
- A scheme manager turning malicious after users have locked tokens
- A compromised scheme manager account
- A multi-signature scheme manager with malicious members

**Attack Complexity**: The attack requires only a single transaction calling `RemoveBeneficiary` with `amount = 0` to completely remove the user's beneficiary status while leaving tokens locked.

**Economic Incentive**: Scheme managers have direct financial motivation because removing other beneficiaries increases their own proportional share of distributed profits. If the manager is also a beneficiary, they directly benefit from the attack.

**Detection Difficulty**: The operation appears as legitimate beneficiary management with no clear indication that tokens remain locked without profit rights.

**Preconditions**: Only requires normal operation (users having called `RegisterForProfits`) and the attacker being the scheme manager.

## Recommendation

Modify `RemoveBeneficiary` to enforce state consistency by either:

1. **Prevent removal if tokens are locked**: Check if a lockId exists for the user before allowing removal, and revert if tokens are still locked.

2. **Force unlock when removing**: Automatically unlock the user's tokens and remove the lockId when removing their beneficiary status.

Recommended fix (Option 1 - safer):

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    // NEW: Check if user has locked tokens
    var lockId = State.LockIds[Context.Sender][input.Beneficiary];
    Assert(lockId == null, "Cannot remove beneficiary while tokens are locked. User must withdraw first.");
    
    var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
    {
        Beneficiary = input.Beneficiary,
        SchemeId = scheme.SchemeId
    }).Details.Single();
    
    // ... rest of existing logic
}
```

## Proof of Concept

```csharp
[Fact]
public async Task RemoveBeneficiary_LeavesTokensLocked_Test()
{
    // Setup: User registers for profits and locks 1000 tokens
    var user = Accounts[1].Address;
    var manager = Accounts[0].Address;
    var lockAmount = 1000;
    
    // Manager creates scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });
    
    // User registers and locks tokens
    await TokenHolderContractStub_User.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = manager,
        Amount = lockAmount
    });
    
    // Verify tokens are locked
    var lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = user,
        Symbol = "ELF",
        LockId = /* lockId from state */
    });
    lockedAmount.Amount.ShouldBe(lockAmount);
    
    // Manager removes beneficiary
    await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
    {
        Beneficiary = user,
        Amount = 0 // Complete removal
    });
    
    // Verify user is removed from profit scheme
    var profitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = /* scheme id */,
        Beneficiary = user
    });
    profitDetails.Details.Count.ShouldBe(0); // No longer a beneficiary
    
    // But tokens are STILL locked
    lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = user,
        Symbol = "ELF",
        LockId = /* lockId from state */
    });
    lockedAmount.Amount.ShouldBe(lockAmount); // Still locked!
    
    // User cannot withdraw until lock period expires
    var result = await TokenHolderContractStub_User.Withdraw.SendAsync(manager);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Cannot withdraw");
}
```

## Notes

This vulnerability represents a fundamental state consistency failure where the protocol's own invariant (locked tokens entitle holders to profits) can be violated by scheme managers. The atomic creation of lock+beneficiary state in `RegisterForProfits` establishes a clear protocol guarantee that `RemoveBeneficiary` violates by only reversing one half of the state change. This is particularly severe because users have no recourse until the lock period expires, during which they suffer ongoing profit losses.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-177)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-245)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L195-222)
```csharp
    public override Empty Lock(LockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");

        var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
        if (allowance >= input.Amount)
            State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
        DealWithExternalInfoDuringLocking(new TransferFromInput
        {
            From = input.Address,
            To = virtualAddress,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L224-252)
```csharp
    public override Empty Unlock(UnlockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");

        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        Context.SendVirtualInline(fromVirtualAddress, Context.Self, nameof(Transfer), new TransferInput
        {
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        DealWithExternalInfoDuringUnlock(new TransferFromInput
        {
            From = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress),
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```
