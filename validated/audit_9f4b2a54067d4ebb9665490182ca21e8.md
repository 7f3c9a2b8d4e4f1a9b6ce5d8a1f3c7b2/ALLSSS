# Audit Report

## Title
State Inconsistency in RemoveBeneficiary Allows Orphaned Lock State and Profit Loss

## Summary
The `RemoveBeneficiary` function in the TokenHolder contract removes a user's profit shares without unlocking their tokens or cleaning up associated lock state mappings. This creates an inconsistent state where users who registered via `RegisterForProfits` have locked tokens but no profit beneficiary status, causing them to lose expected dividends while their funds remain inaccessible for the `MinimumLockMinutes` period.

## Finding Description

When a user calls `RegisterForProfits`, the TokenHolder contract performs three critical state changes: (1) locks tokens in the MultiToken contract, (2) creates a `LockIds` mapping entry tracking the lock, and (3) adds the user as a beneficiary in the Profit contract with shares equal to the locked amount. [1](#0-0) 

The `LockIds` mapping maintains the relationship between scheme managers, users, and their lock identifiers. [2](#0-1) 

However, the `RemoveBeneficiary` function only interacts with the Profit contract to remove or reduce beneficiary shares. It does NOT unlock the tokens in the MultiToken contract, does NOT remove the `LockIds` mapping entry, and does NOT update any lock-related state. [3](#0-2) 

This creates an inconsistent state where `State.LockIds[schemeManager][user]` still exists, the user's tokens remain locked in the MultiToken contract, but the user is removed or has reduced shares in the Profit contract and receives no or reduced profit distributions.

The `Withdraw` function is designed to clean up this state, but it requires `MinimumLockMinutes` to elapse before tokens can be unlocked. During this entire period, users with orphaned lock state receive no profits despite having locked tokens. [4](#0-3) 

Additionally, the Profit contract's `RemoveBeneficiary` function silently succeeds even if the beneficiary is already removed or doesn't exist, which masks the inconsistency from the TokenHolder contract. [5](#0-4) 

## Impact Explanation

**Financial Impact:**
Users lose all expected profit distributions for the entire duration their tokens remain locked (up to `MinimumLockMinutes`). If a scheme distributes profits multiple times during the lock period (e.g., weekly distributions over a 90-day lock), users receive none of these profits despite having committed their tokens. This represents direct financial loss with no compensation mechanism.

**State Consistency Impact:**
The vulnerability violates the core invariant that locked tokens should earn profit shares. It creates orphaned `LockIds` entries that reference locked tokens with no corresponding profit beneficiary status, causing token lock amounts and profit shares to become permanently desynchronized until the lock period expires.

**Affected Parties:**
Any user who called `RegisterForProfits` and subsequently had the scheme manager call `RemoveBeneficiary` on them. In schemes with long `MinimumLockMinutes` values, users could lose months of profit distributions while their capital remains inaccessible. [6](#0-5) 

## Likelihood Explanation

**Attacker Capabilities:**
The scheme manager, who is set at scheme creation time to `Context.Sender`, can call `RemoveBeneficiary` on any registered user at any time. [7](#0-6) 

**Feasibility:**
While the scheme manager is a privileged role, it is NOT listed as a trusted role in the AElf security model (which only trusts genesis method-fee providers, organization controllers, and consensus system contracts). The scheme manager could be a malicious actor from the start, a compromised account, or an automated contract with flawed logic. Users who lock tokens trust they will receive profits, but have no protection against this scenario.

**Detection:**
No checks prevent `RemoveBeneficiary` from being called on users with locked tokens. The function validates only that the caller is the scheme manager through `GetValidScheme(Context.Sender)`. [8](#0-7) 

## Recommendation

The `RemoveBeneficiary` function should be modified to check if the beneficiary has locked tokens via `RegisterForProfits` and either:

1. **Prevent removal** if tokens are locked (require user to call `Withdraw` first after lock period expires), OR
2. **Automatically unlock tokens** and clean up lock state when removing a beneficiary who registered via `RegisterForProfits`

Recommended fix (Option 1 - Prevent removal):
```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    // Check if beneficiary has locked tokens via RegisterForProfits
    var lockId = State.LockIds[Context.Sender][input.Beneficiary];
    Assert(lockId == null, "Cannot remove beneficiary with locked tokens. User must withdraw first after lock period expires.");
    
    // ... rest of existing logic
}
```

## Proof of Concept

```csharp
[Fact]
public async Task RemoveBeneficiary_CreatesOrphanedLockState()
{
    // Setup: Create scheme
    var schemeManager = DefaultSender;
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 129600 // 90 days
    });
    
    // User registers for profits - locks 1000 tokens
    var user = Accounts[1].Address;
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = schemeManager,
        Amount = 1000
    });
    
    // Verify user has locked tokens and LockIds entry exists
    var lockId = (await TokenHolderContractStub.GetScheme.CallAsync(schemeManager)).LockIds[user];
    Assert.NotNull(lockId);
    
    // Scheme manager removes beneficiary
    await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
    {
        Beneficiary = user,
        Amount = 0 // Remove completely
    });
    
    // BUG: LockIds entry still exists
    var lockIdAfterRemove = (await TokenHolderContractStub.GetScheme.CallAsync(schemeManager)).LockIds[user];
    Assert.NotNull(lockIdAfterRemove); // FAILS - should be null but isn't
    
    // BUG: Tokens still locked in MultiToken contract
    var lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = user,
        LockId = lockId,
        Symbol = "ELF"
    });
    Assert.Equal(1000, lockedAmount.Amount); // Tokens remain locked
    
    // BUG: User has no profit shares
    var profitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = user
    });
    Assert.Empty(profitDetails.Details); // No profit shares
    
    // BUG: User cannot withdraw until MinimumLockMinutes expires (90 days)
    // User loses all profit distributions during this 90-day period
}
```

**Notes:**
- This vulnerability creates a critical state inconsistency where the invariant "locked tokens earn profit shares" is violated
- The scheme manager is not a trusted role in the AElf security model, making this a realistic attack vector
- Users have no recourse except waiting for `MinimumLockMinutes` to expire to call `Withdraw` and recover their locked funds
- All profit distributions during the lock period are permanently lost to affected users

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-24)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-176)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-245)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L12-15)
```csharp
    /// <summary>
    ///     Contract address (Manager address) -> Beneficiary address -> Lock id.
    /// </summary>
    public MappedState<Address, Address, Hash> LockIds { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L233-235)
```csharp
        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();
```

**File:** protobuf/token_holder_contract.proto (L66-67)
```text
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
```
