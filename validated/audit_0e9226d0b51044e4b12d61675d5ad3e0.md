# Audit Report

## Title
Fee-Free CheckThreshold Method Enables Resource Exhaustion DOS Attack via Unbounded State Reads

## Summary
The `CheckThreshold` method in the MultiToken contract lacks input validation on the `symbol_to_threshold` map size while being marked as fee-free, allowing attackers to craft transactions that force validator nodes to perform hundreds of thousands of expensive state read operations at zero cost during transaction validation, creating a denial-of-service vector against the network's transaction processing infrastructure.

## Finding Description

The `CheckThreshold` method is a public method in the MultiToken contract that validates whether a sender has sufficient token balances to meet specified thresholds. [1](#0-0) 

The method is explicitly marked as `IsSizeFeeFree = true` in the fee provider implementation, exempting it from both method fees and transaction size fees. [2](#0-1) 

The critical vulnerability lies in the implementation's unbounded iteration through the input map. The method loops through every entry in `input.SymbolToThreshold`, calling `GetBalance` for each symbol. [3](#0-2) 

Each `GetBalance` call performs a state read operation from the contract's state storage. [4](#0-3) 

When `IsCheckAllowance` is true, the method performs additional state reads for each qualifying symbol, checking allowances from the state mapping. [5](#0-4) 

The protobuf definition for `CheckThresholdInput` shows `symbol_to_threshold` as an unbounded `map<string, int64>` with no size constraints. [6](#0-5) 

The transaction size limit is 5MB, which allows an attacker to include tens or hundreds of thousands of symbol entries in a single transaction. [7](#0-6) 

By default, `TransactionExecutionValidationProvider` pre-executes transactions during validation to prevent transaction flood attacks. [8](#0-7)  This pre-execution occurs even for transactions that will ultimately fail, meaning all the expensive state reads are performed before the transaction is rejected. [9](#0-8) 

**Attack Scenario:**
1. Attacker crafts a `CheckThreshold` transaction with 100,000+ symbols in the `symbol_to_threshold` map (well within the 5MB size limit)
2. Transaction is submitted to the mempool
3. Each validator node's `TransactionExecutionValidationProvider` pre-executes the transaction
4. During pre-execution, `CheckThreshold` performs 100,000+ state reads via `GetBalance` calls
5. Transaction ultimately fails the threshold assertion and is rejected
6. However, validator resources have already been consumed performing the state reads
7. Attacker repeats with zero cost due to fee-free status
8. Network transaction validation becomes congested, delaying legitimate transactions

## Impact Explanation

This vulnerability enables **operational denial-of-service** against the transaction validation infrastructure:

- **Validator Resource Exhaustion**: Each malicious transaction forces validators to perform hundreds of thousands of database read operations during pre-execution validation
- **Network Throughput Degradation**: Validators spending CPU and I/O resources on validation cannot process legitimate transactions efficiently
- **Zero Attack Cost**: The fee-free status removes all economic barriers, making sustained attacks cost-free for adversaries
- **Service Quality Impact**: Legitimate users experience delayed transaction confirmation as nodes process malicious payloads

**Severity Justification**: While this does not compromise funds, consensus integrity, or governance, it enables operational disruption of critical transaction processing infrastructure at zero attacker cost, significantly degrading network availability for legitimate users.

## Likelihood Explanation

**High Likelihood** due to:

- **Minimal Attacker Capabilities**: No special permissions, tokens, or privileges required - only ability to submit transactions
- **Low Complexity**: Straightforward to construct a `CheckThresholdInput` with many symbols using standard transaction tools
- **Zero Financial Barrier**: Fee-free status means no economic disincentive for sustained attacks
- **High Feasibility**: `CheckThreshold` is publicly callable with no rate limiting or caller restrictions
- **Enabled by Default**: Transaction execution validation is enabled by default on common nodes, ensuring the attack vector is active network-wide

The combination of public accessibility, zero cost, and lack of input validation makes this vulnerability both practical and economically rational for adversaries.

## Recommendation

Implement a maximum size limit on the `symbol_to_threshold` map in the `CheckThreshold` method:

```csharp
public override Empty CheckThreshold(CheckThresholdInput input)
{
    AssertValidInputAddress(input.Sender);
    
    // Add size validation
    const int MaxSymbolsPerCheck = 10; // Reasonable limit for legitimate threshold checks
    Assert(input.SymbolToThreshold.Count <= MaxSymbolsPerCheck, 
        $"Cannot check more than {MaxSymbolsPerCheck} symbols at once.");
    
    // ... rest of implementation
}
```

Additional mitigations:
1. Consider whether `CheckThreshold` needs to remain fee-free or if a minimal fee would prevent abuse
2. Implement rate limiting for fee-free methods at the protocol level
3. Add monitoring to detect patterns of resource-intensive validation requests

## Proof of Concept

```csharp
[Fact]
public async Task CheckThreshold_DOS_Attack_Test()
{
    // Setup: Initialize token contract
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "ELF",
        TokenName = "ELF Token",
        TotalSupply = 1000000000,
        Decimals = 8,
        Issuer = DefaultAddress,
        IsBurnable = true
    });
    
    // Attack: Create CheckThresholdInput with 50,000 symbols
    var maliciousInput = new CheckThresholdInput
    {
        Sender = DefaultAddress,
        IsCheckAllowance = false,
        SymbolToThreshold = { }
    };
    
    // Add 50,000 symbol entries (well under 5MB limit)
    for (int i = 0; i < 50000; i++)
    {
        maliciousInput.SymbolToThreshold[$"TOKEN{i}"] = 1000;
    }
    
    // This transaction will be accepted for validation and pre-executed
    // performing 50,000+ GetBalance state reads before being rejected
    var result = await TokenContractStub.CheckThreshold.SendWithExceptionAsync(maliciousInput);
    
    // Transaction fails as expected, but resources were already consumed
    result.TransactionResult.Error.ShouldContain("Cannot meet the calling threshold");
}
```

## Notes

The vulnerability analysis reveals that an attacker can actually fit significantly more than the claimed "thousands" of symbols - with careful protobuf encoding, upwards of 100,000+ symbols could fit within the 5MB transaction size limit, making the potential impact even more severe than initially described. The root cause is the combination of three factors: (1) lack of input size validation in the contract code, (2) fee-free designation removing economic barriers, and (3) pre-execution validation enabled by default causing resource consumption even for transactions that will be rejected.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L339-369)
```csharp
    public override Empty CheckThreshold(CheckThresholdInput input)
    {
        AssertValidInputAddress(input.Sender);
        var meetThreshold = false;
        var meetBalanceSymbolList = new List<string>();
        foreach (var symbolToThreshold in input.SymbolToThreshold)
        {
            if (GetBalance(input.Sender, symbolToThreshold.Key) < symbolToThreshold.Value)
                continue;
            meetBalanceSymbolList.Add(symbolToThreshold.Key);
        }

        if (meetBalanceSymbolList.Count > 0)
        {
            if (input.IsCheckAllowance)
                foreach (var symbol in meetBalanceSymbolList)
                {
                    if (State.Allowances[input.Sender][Context.Sender][symbol] <
                        input.SymbolToThreshold[symbol]) continue;
                    meetThreshold = true;
                    break;
                }
            else
                meetThreshold = true;
        }

        if (input.SymbolToThreshold.Count == 0) meetThreshold = true;

        Assert(meetThreshold, "Cannot meet the calling threshold.");
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L39-49)
```csharp
        if (new List<string>
            {
                nameof(ClaimTransactionFees), nameof(DonateResourceToken), nameof(ChargeTransactionFees),
                nameof(CheckThreshold), nameof(CheckResourceToken), nameof(ChargeResourceToken),
                nameof(CrossChainReceiveToken)
            }.Contains(input.Value))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L166-172)
```csharp
    private long GetBalance(Address address, string symbol)
    {
        AssertValidInputAddress(address);
        var actualSymbol = GetActualTokenSymbol(symbol);
        Assert(!string.IsNullOrWhiteSpace(actualSymbol), "Invalid symbol.");
        return State.Balances[address][actualSymbol];
    }
```

**File:** protobuf/token_contract.proto (L413-420)
```text
message CheckThresholdInput {
    // The sender of the transaction.
    aelf.Address sender = 1;
    // The threshold to set, Symbol->Threshold.
    map<string, int64> symbol_to_threshold = 2;
    // Whether to check the allowance.
    bool is_check_allowance = 3;
}
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L1-6)
```csharp
namespace AElf.Kernel.TransactionPool;

public class TransactionPoolConsts
{
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
}
```

**File:** src/AElf.Kernel.TransactionPool/TransactionOptions.cs (L15-19)
```csharp
    /// <summary>
    ///     Bp Node can disable this flag to make best performance.
    ///     But common node needs to enable it to prevent transaction flood attack
    /// </summary>
    public bool EnableTransactionExecutionValidation { get; set; } = true;
```

**File:** src/AElf.Kernel.TransactionPool/Infrastructure/TransactionExecutionValidationProvider.cs (L31-49)
```csharp
    public async Task<bool> ValidateTransactionAsync(Transaction transaction, IChainContext chainContext)
    {
        if (!_transactionOptions.EnableTransactionExecutionValidation)
            return true;

        var executionReturnSets = await _plainTransactionExecutingService.ExecuteAsync(new TransactionExecutingDto
        {
            Transactions = new[] { transaction },
            BlockHeader = new BlockHeader
            {
                PreviousBlockHash = chainContext.BlockHash,
                Height = chainContext.BlockHeight + 1,
                Time = TimestampHelper.GetUtcNow()
            }
        }, CancellationToken.None);

        var executionValidationResult =
            executionReturnSets.FirstOrDefault()?.Status == TransactionResultStatus.Mined;
        if (!executionValidationResult)
```
