# Audit Report

## Title
Miner List Manipulation via Unvalidated NextTerm Input Allows Consensus Takeover

## Summary
The `NextTerm` method in the AEDPoS consensus contract accepts arbitrary miner lists without validating them against election results. Any current miner can submit a fraudulent `NextTerm` transaction with a manipulated miner list, completely bypassing the election system and enabling indefinite consensus control.

## Finding Description

The vulnerability exists in the term transition flow where the consensus contract fails to validate the legitimacy of the new miner list against election results.

The `NextTerm` method is publicly accessible and processes term transitions: [1](#0-0) 

When processing a term transition, `ProcessNextTerm` extracts the miner list directly from the input parameter and calls `SetMinerList` without any validation against election results: [2](#0-1) 

Specifically, lines 187-190 show the miner list is extracted from the input and set directly: [3](#0-2) 

The **intended** design uses `GenerateFirstRoundOfNextTerm` as a view method to obtain legitimate miners from the election contract: [4](#0-3) 

This view method calls `TryToGetVictories` to retrieve legitimate miners from the election contract: [5](#0-4) 

However, this entire validation flow occurs **off-chain**. The view method is called during block extra data generation: [6](#0-5) 

The `NextTermInput` structure is created off-chain and can be manipulated: [7](#0-6) 

The on-chain validation system **fails to verify** that the miner list matches election results. The `RoundTerminateValidationProvider` only validates term and round number increments: [8](#0-7) 

For NextTerm behavior, only this validator is added during pre-execution validation: [9](#0-8) 

Post-execution validation also fails to check election results. The `ValidateConsensusAfterExecution` method only validates within-term miner replacements using `GetNewestPubkey`, not term transitions: [10](#0-9) 

The access control check in `PreCheck` only verifies that the transaction sender is in the current or previous miner list, which the attacker satisfies: [11](#0-10) 

**Attack Sequence:**
1. Attacker (current miner) waits for term transition time
2. Off-chain: Attacker obtains proper structure (optionally by calling `GenerateFirstRoundOfNextTerm`)
3. Off-chain: Modifies `RealTimeMinersInformation` dictionary to include arbitrary miners
4. On-chain: Submits `NextTerm` transaction with fraudulent miner list during their time slot
5. Validation passes (only checks term/round numbers, not miner legitimacy)
6. `SetMinerList` accepts the fraudulent miners as the new consensus set
7. Attacker now controls consensus and can repeat indefinitely

## Impact Explanation

**Critical Consensus Integrity Break:** The election system is the fundamental security mechanism in AEDPoS for determining legitimate block producers through token holder voting. This vulnerability renders the entire election process meaningless, allowing attackers to completely bypass democratic validator selection.

**Indefinite Control:** Once an attacker gains control through one fraudulent term transition, they can perpetuate control indefinitely by:
- Including themselves and accomplice nodes in every subsequent term
- Excluding legitimately elected validators
- Maintaining majority/supermajority control over consensus

**Protocol-Wide Damage:**
- **Consensus Security:** The 2/3+ honest miner assumption is violated when the miner set is attacker-controlled
- **Economic Integrity:** Mining rewards are misdirected to fraudulent miners instead of elected validators
- **Governance Nullification:** Token holder voting power becomes worthless
- **Cross-Chain Security:** Side chains relying on main chain miner integrity are compromised
- **Treasury Corruption:** Reward distribution goes to attackers

**Affected Parties:** All network participants lose fundamental security guarantees, legitimate validators lose staked capital and rewards, and token holders lose governance rights.

## Likelihood Explanation

**Easily Reachable Entry Point:** The `NextTerm` method is public with minimal access control - any current miner can call it when term change conditions are met (time-based periodic occurrence based on `PeriodSeconds` configuration).

**Realistic Preconditions:**
1. Attacker must be a current miner (achievable through legitimate election initially or by having one compromised validator)
2. Must wait for term transition point (periodic occurrence that happens automatically)

**Execution Practicality:** The attack requires no complex exploit chains:
1. Monitor blockchain for term transition time
2. Construct `NextTermInput` with arbitrary miner list
3. Submit transaction during attacker's time slot
4. All validations pass automatically

**No Detection Barriers:** The fraudulent transaction appears identical to a legitimate term transition. The validation logic checks only metadata (term/round numbers), not the critical miner list content. Other nodes would accept the block using the same insufficient validation.

**Economic Rationality:** The reward structure heavily incentivizes this attack - mining rewards and consensus control far exceed any transaction costs. The attacker gains ongoing block production rewards while excluding competitors.

## Recommendation

Add on-chain validation in `ProcessNextTerm` to verify the miner list matches election results:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    RecordMinedMinerListOfCurrentRound();
    CountMissedTimeSlots();
    Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");
    Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
    Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    UpdateMinersCountToElectionContract(nextRound);
    
    // ADD VALIDATION: Verify miner list matches election results
    if (State.IsMainChain.Value && State.ElectionContract.Value != null)
    {
        var victories = State.ElectionContract.GetVictories.Call(new Empty());
        var expectedMiners = victories.Value.Select(v => v.ToHex()).OrderBy(m => m).ToList();
        var inputMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(m => m).ToList();
        Assert(expectedMiners.Count == inputMiners.Count && 
               expectedMiners.SequenceEqual(inputMiners),
               "Miner list does not match election results.");
    }
    
    // Continue with existing logic...
    foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
    {
        minerInRound.MissedTimeSlots = 0;
        minerInRound.ProducedBlocks = 0;
    }
    
    UpdateProducedBlocksNumberOfSender(nextRound);
    
    var miners = new MinerList();
    miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
    if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
    
    State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;
    AddRoundInformation(nextRound);
    
    if (!TryToGetPreviousRoundInformation(out var previousRound))
        Assert(false, "Failed to get previous round information.");
    
    UpdateCurrentMinerInformationToElectionContract(previousRound);
    
    if (DonateMiningReward(previousRound))
    {
        State.TreasuryContract.Release.Send(new ReleaseInput
        {
            PeriodNumber = termNumber
        });
        Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
    }
    
    State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
    {
        MinedBlocks = previousRound.GetMinedBlocks(),
        TermNumber = termNumber,
        RoundNumber = previousRound.RoundNumber
    });
    
    Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
}
```

This ensures that the miner list in any `NextTerm` transaction must match the current election results from the Election Contract.

## Proof of Concept

```csharp
[Fact]
public async Task NextTerm_WithArbitraryMinerList_ShouldAcceptFraudulentMiners()
{
    // Setup: Initialize blockchain with initial miners
    var initialMiners = GenerateInitialMiners(5);
    await InitializeAEDPoS(initialMiners);
    
    // Advance to term transition point
    await AdvanceToTermTransition();
    
    // Get current miner (attacker)
    var attackerKeyPair = initialMiners[0];
    
    // Create fraudulent NextTermInput with arbitrary miner list
    var fraudulentMiners = GenerateArbitraryMiners(3); // Different from election results
    var fraudulentNextTermInput = CreateNextTermInput(
        nextTermNumber: 2,
        minerList: fraudulentMiners
    );
    
    // Submit NextTerm transaction as current miner
    var result = await ConsensusContract.NextTerm.SendAsync(fraudulentNextTermInput);
    
    // VULNERABILITY: Transaction succeeds without validation
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify fraudulent miners are now active
    var currentMinerList = await ConsensusContract.GetCurrentMinerList.CallAsync(new Empty());
    currentMinerList.Pubkeys.Count.ShouldBe(3);
    
    // Verify the fraudulent miners match our input, not election results
    foreach (var fraudulentMiner in fraudulentMiners)
    {
        currentMinerList.Pubkeys.ShouldContain(ByteStringHelper.FromHexString(fraudulentMiner));
    }
    
    // Election results are bypassed - legitimate elected miners are excluded
    var electionVictories = await ElectionContract.GetVictories.CallAsync(new Empty());
    foreach (var legitimateMiner in electionVictories.Value)
    {
        var isInConsensus = currentMinerList.Pubkeys.Any(p => p.ToHex() == legitimateMiner.ToHex());
        isInConsensus.ShouldBeFalse(); // Legitimate miners excluded!
    }
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```
