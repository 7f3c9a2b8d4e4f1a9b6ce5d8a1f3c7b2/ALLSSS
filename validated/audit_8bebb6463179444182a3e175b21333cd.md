# Audit Report

## Title
Denial of Service in TokenHolder AddBeneficiary/RemoveBeneficiary Due to Invalid Single() Assumption on Multiple Profit Details

## Summary
The TokenHolderContract's `AddBeneficiary()` and `RemoveBeneficiary()` methods incorrectly assume beneficiaries have exactly one profit detail by calling `.Single()`, but the contract's own partial removal feature legitimately creates multiple `ProfitDetail` entries. This causes permanent transaction failures that prevent scheme managers from adjusting beneficiary shares, creating a denial of service condition for normal TokenHolder operations.

## Finding Description

The vulnerability exists in two critical locations within TokenHolderContract:

**Location 1 - AddBeneficiary()**: [1](#0-0) 

The method attempts to consolidate existing profit details by calling `.Single()` which expects exactly one element in the collection.

**Location 2 - RemoveBeneficiary()**: [2](#0-1) 

The method also calls `.Single()` to access the beneficiary's profit detail.

However, the underlying Profit contract is explicitly designed to support multiple `ProfitDetail` entries per beneficiary through a repeated field: [3](#0-2) 

**Root Cause - Partial Removal Pattern**: When `RemoveBeneficiary` is called with a partial amount, it removes the beneficiary completely and then re-adds them with reduced shares. This pattern creates two `ProfitDetail` entries in the Profit contract - the old detail with an ended period and a new detail with reduced shares. The contract's own test suite explicitly confirms this behavior: [4](#0-3) 

The test at line 192 asserts that after partial removal, the beneficiary has 2 details: `profitAmount.Details.Count.ShouldBe(2)`.

**Execution Flow to Trigger DOS:**

1. **Initial State**: Beneficiary has 1000 shares with 1 `ProfitDetail` entry
2. **Partial Removal**: Manager calls `RemoveBeneficiary(Beneficiary: X, Amount: 10)` where 10 < 1000
   - Contract removes all shares from Profit contract
   - Contract re-adds beneficiary with 990 shares (1000 - 10)
   - Profit contract now stores 2 `ProfitDetail` entries for this beneficiary
3. **DOS Triggered**: Any subsequent call to `AddBeneficiary` or `RemoveBeneficiary` for this beneficiary:
   - `.Single()` is called on a collection with 2 elements
   - C# runtime throws `InvalidOperationException`
   - Transaction reverts completely before any state changes
   - Beneficiary's shares become permanently frozen in TokenHolder context

## Impact Explanation

**Permanent Operational DOS:**
- Once a beneficiary undergoes partial removal, they permanently have 2+ `ProfitDetail` entries in the Profit contract
- All subsequent `AddBeneficiary` calls for that beneficiary fail at the `.Single()` invocation
- All subsequent `RemoveBeneficiary` calls also fail at the `.Single()` invocation
- The scheme manager cannot adjust shares for affected beneficiaries through TokenHolder's interface
- Beneficiaries' share allocations become frozen and cannot be modified through normal TokenHolder operations

**Workaround Limitations:**
While managers could theoretically bypass this by directly calling the Profit contract, this approach:
- Bypasses TokenHolder's intended abstraction layer and API design
- Requires deep knowledge of internal implementation details
- May create state inconsistencies between TokenHolder and Profit contract
- Indicates a fundamental broken design in TokenHolder's profit detail management

**Affected Systems:**
- Any TokenHolder profit scheme that uses the partial removal feature
- DApp creators relying on flexible beneficiary share management
- Any system requiring dynamic share adjustments over time
- All schemes where beneficiary participation changes incrementally

The impact is limited to availability (DOS) rather than fund loss, but it breaks core functionality and forces managers to use undocumented workarounds.

## Likelihood Explanation

**High Likelihood - Triggered by Normal Operations:**

**Reachability**: Both `AddBeneficiary` and `RemoveBeneficiary` are public methods with standard access control - only the scheme manager can call them, which is an expected privilege level for these operations.

**Feasible Preconditions:**
- Partial removal is an intentionally designed and implemented feature [5](#0-4) 
- The test suite confirms this is an expected operational pattern, not an edge case
- Any scheme using dynamic share adjustments (common in staking, voting, or reward distribution systems) will likely use partial removals

**No Attack Required:**
- This is a logic error in contract design, not an attack vector requiring malicious intent
- Triggered through normal, legitimate usage of the partial removal feature
- The existence of a dedicated test case demonstrates this is standard functionality that developers expected to work

**Permanent Condition:**
- Once multiple profit details exist for a beneficiary, the condition persists indefinitely
- No self-healing mechanism exists in TokenHolder
- Requires manual intervention via direct Profit contract calls to resolve

## Recommendation

Replace `.Single()` calls with safe collection access that handles multiple profit details appropriately. The contract should either:

**Option 1 - Aggregate Multiple Details**: Sum all active profit detail shares when reading beneficiary information, properly handling the case where multiple details exist.

**Option 2 - Proper Consolidation**: Before accessing profit details in `AddBeneficiary`, ensure all existing details are properly consolidated by removing all and re-adding with the total share count, then verify only one detail exists before proceeding.

**Option 3 - Use FirstOrDefault with Validation**: Replace `.Single()` with `.FirstOrDefault()` or iterate through all details, but add explicit validation to warn if multiple details exist when only one is expected.

The recommended fix is Option 1, as it aligns with the Profit contract's design that explicitly supports multiple details through its repeated field structure.

## Proof of Concept

```csharp
[Fact]
public async Task DOS_After_Partial_Removal_Test()
{
    // Step 1: Setup - Create scheme and add beneficiary with initial shares
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF"
    });
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 9999
    });
    await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = Starter,
        Shares = 1000
    });

    // Step 2: Perform partial removal - this creates 2 ProfitDetail entries
    await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
    {
        Beneficiary = Starter,
        Amount = 10  // Partial removal: 10 out of 1000
    });

    // Step 3: Verify DOS - subsequent AddBeneficiary throws InvalidOperationException
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
        {
            Beneficiary = Starter,
            Shares = 100
        });
    });
    
    // The exception message should indicate .Single() failed due to multiple elements
    exception.Message.ShouldContain("Sequence contains more than one element");
}
```

This test demonstrates that after a partial removal creates multiple profit details, any subsequent `AddBeneficiary` call fails with an `InvalidOperationException` from the `.Single()` method, confirming the permanent DOS condition.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-68)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }

        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = shares
            }
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** protobuf/profit_contract.proto (L233-236)
```text
message ProfitDetails {
    // The profit information.
    repeated ProfitDetail details = 1;
}
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L156-196)
```csharp
    public async Task RemoveBeneficiary_With_Amount_Test()
    {
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF"
        });
        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Symbol = "ELF",
            Amount = 9999
        });
        await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
        {
            Beneficiary = Starter,
            Shares = 1000
        });
        var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
        {
            Manager = Starter
        });
        var schemeId = schemeIds.SchemeIds[0];
        var beforeRemoveScheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
        var amount = 10;
        await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
        {
            Beneficiary = Starter,
            Amount = amount
        });
        var afterRemoveScheme = await ProfitContractStub.GetScheme.CallAsync(schemeIds.SchemeIds[0]);
        afterRemoveScheme.TotalShares.ShouldBe(beforeRemoveScheme.TotalShares - amount);
        var profitAmount = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
        {
            Beneficiary = Starter,
            SchemeId = schemeId
        });
        profitAmount.Details.Count.ShouldBe(2);
        profitAmount.Details[0].Shares.ShouldBe(beforeRemoveScheme.TotalShares);
        profitAmount.Details[0].EndPeriod.ShouldBe(0);
        profitAmount.Details[1].Shares.ShouldBe(beforeRemoveScheme.TotalShares - amount);
    }
```
