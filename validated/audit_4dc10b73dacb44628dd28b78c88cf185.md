# Audit Report

## Title
Hash Input Collision Vulnerability in NFT Token Hash Calculation

## Summary
The `CalculateTokenHash()` function concatenates symbol and tokenId without a delimiter, enabling different (symbol, tokenId) pairs from separate NFT protocols to produce identical hash values. This allows cross-protocol state collisions that cause denial of service or state corruption depending on the `IsTokenIdReuse` configuration.

## Finding Description

The vulnerability exists in the hash calculation mechanism that generates unique identifiers for NFTs. The `CalculateTokenHash` method directly concatenates the symbol string with the tokenId without any delimiter or separator: [1](#0-0) 

NFT protocol symbols follow the format `{2-char-prefix}{numeric-suffix}` where the numeric suffix starts at 9 digits minimum but can vary in length: [2](#0-1) [3](#0-2) 

The `CrossChainCreate` method accepts protocols from other chains with minimal validation, only checking that the first 2 characters match a valid NFT type: [4](#0-3) 

Without a delimiter, different (symbol, tokenId) combinations produce identical hash inputs:
- Protocol A: symbol="AR123456789", tokenId=12 → hash input="AR12345678912"
- Protocol B: symbol="AR1234567891", tokenId=2 → hash input="AR12345678912"

The resulting tokenHash collision causes both protocols to share the same state mappings. When minting, the `PerformMint` method checks for existing NFTs but only at the hash level, not validating protocol ownership: [5](#0-4) 

When `IsTokenIdReuse=false`, the assertion blocks legitimate mints from the second protocol. When `IsTokenIdReuse=true`, the code updates the existing NFT without verifying it belongs to the same protocol: [6](#0-5) 

The vulnerability affects all state mappings keyed by tokenHash: [7](#0-6) 

## Impact Explanation

**Scenario 1 - Denial of Service (IsTokenIdReuse=false):**
When a hash collision occurs between two different protocols, the second protocol's mint attempt fails with "Token id already exists" error even though it's a completely different NFT protocol. This permanently blocks that specific (symbol, tokenId) combination in the affected protocol.

**Scenario 2 - Cross-Protocol State Corruption (IsTokenIdReuse=true):**
The collision causes Protocol B's mint operation to update Protocol A's NFT state:
- Protocol B's minter is added to Protocol A's NFT minters list
- Quantity counters are incorrectly aggregated across unrelated protocols
- Balance mappings become shared between different protocol NFTs
- Allowances are confused between unrelated NFT tokens
- The NFT's symbol field shows Protocol A's symbol despite having mixed state from both protocols

This violates the fundamental invariant that each NFT must have unique, isolated state within its protocol.

## Likelihood Explanation

**Attack Vector:** The most feasible attack path is through cross-chain protocol creation. An attacker can:
1. Monitor existing NFT protocols and their tokenId usage on the mainchain
2. Create a protocol on a sidechain with a deliberately crafted symbol that will collide when combined with a specific tokenId
3. Use `CrossChainCreate` to sync the malicious protocol to the mainchain
4. Mint an NFT with the collision-inducing tokenId

**Attacker Capabilities:** Any user who can create tokens on sidechains and sync them to mainchain via the cross-chain mechanism can execute this attack.

**Cost vs Benefit:** Protocol creation has associated costs (token creation fees, cross-chain operation fees), but the ability to cause DoS on competitor protocols or corrupt state for protocols with `IsTokenIdReuse=true` may justify these costs for malicious actors.

**Collision Probability:** While natural collisions may be rare initially, they become more likely as:
- More protocols are created with varying symbol lengths
- Token ID spaces grow larger
- Cross-chain protocols introduce symbols with non-standard lengths

## Recommendation

**Primary Fix:** Include a delimiter in the hash calculation to ensure unambiguous parsing:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}|{tokenId}");
}
```

**Additional Validation:** In `PerformMint`, when `nftInfo` already exists, verify it belongs to the same protocol:

```csharp
if (nftInfo != null && nftInfo.Symbol != input.Symbol)
{
    throw new AssertionException($"Token hash collision detected between protocols {nftInfo.Symbol} and {input.Symbol}");
}
```

**Symbol Format Standardization:** Consider enforcing fixed-length symbol suffixes or adding additional validation in `CrossChainCreate` to ensure symbol formats cannot cause ambiguities.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Create Protocol A on mainchain with symbol "AR123456789" (9-digit suffix)
2. Mint NFT with tokenId=12 in Protocol A
3. Create Protocol B on sidechain with symbol "AR1234567891" (10-digit suffix)
4. Sync Protocol B to mainchain via CrossChainCreate
5. Attempt to mint NFT with tokenId=2 in Protocol B
6. Observe:
   - If Protocol B has IsTokenIdReuse=false: Mint fails with "Token id already exists"
   - If Protocol B has IsTokenIdReuse=true: Protocol A's NFT state is corrupted with Protocol B's data

The collision occurs because: `hash("AR123456789" + "12") == hash("AR1234567891" + "2")` as both evaluate to `hash("AR12345678912")`.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L393-396)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-441)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }

        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-93)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-30)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }
```
