# Audit Report

## Title
NFT Alias Symbol Resolution Bypass Causes Undeclared State Path Access in Parallel Execution

## Summary
The ACS2 state path provider declares resource paths using input symbols without resolving NFT aliases, while execution resolves aliases before accessing state. This mismatch causes transactions using NFT aliases to access undeclared state paths (balances, allowances, and NFT collection paths), breaking parallel execution safety guarantees and enabling race conditions.

## Finding Description

The vulnerability exists in the interaction between the ACS2 resource path declaration system and NFT alias resolution.

**Root Cause:**

The `GetResourceInfo` method for `TransferFrom` parses the transaction parameters and declares resource paths using the input symbol directly without alias resolution. [1](#0-0) 

When an NFT alias is used (e.g., "TP" for "TP-31175"), the `AddPathForAllowance` method calls `GetSymbolType` on the unresolved alias. [2](#0-1) 

Since NFT aliases lack hyphens by design, `GetSymbolType` splits the symbol on the hyphen separator and returns `SymbolType.Token` for single-part symbols instead of `SymbolType.Nft`. [3](#0-2) 

This causes `AddPathForAllowance` to skip declaring the NFT collection allowance path (e.g., "TP-*"), which is only added when the symbol type is NFT or NftCollection.

**Execution Flow Mismatch:**

During actual execution, the `TransferFrom` method calls `AssertValidToken` which resolves the alias to the actual NFT symbol before state access. [4](#0-3) 

The resolution occurs through `GetTokenInfo`, which checks `State.SymbolAliasMap` to convert aliases to actual symbols. [5](#0-4) 

The resolved symbol (e.g., "TP-31175") is then passed to `DoTransferFrom`, which accesses the NFT collection allowance path that was never declared. [6](#0-5) 

Specifically, `GetAllowance` calls `GetNftCollectionAllSymbolAllowance` which constructs the collection identifier and accesses `State.Allowances[from][spender]["TP-*"]` - an undeclared path. [7](#0-6) 

Similarly, balance accesses use the resolved symbol, accessing paths like `State.Balances[address]["TP-31175"]` when only `State.Balances[address]["TP"]` was declared. [8](#0-7) 

**Alias Validation Confirms the Issue:**

The `CheckTokenAlias` method validates that aliases must equal the collection prefix (without hyphen), confirming that aliases never contain hyphens by design. [9](#0-8) 

This is a supported feature with test coverage demonstrating `TransferFrom` works with aliases. [10](#0-9) 

## Impact Explanation

**Concrete Path Mismatch:**

For NFT "TP-31175" with alias "TP":
- **Declared paths**: `Allowances[from][spender]["TP"]`, `Allowances[from][spender]["*"]`, `Balances[from]["TP"]`, `Balances[to]["TP"]`
- **Accessed paths**: `Allowances[from][spender]["TP-31175"]`, `Allowances[from][spender]["TP-*"]`, `Allowances[from][spender]["*"]`, `Balances[from]["TP-31175"]`, `Balances[to]["TP-31175"]`

Only the global allowance path "*" overlaps. All NFT-specific and collection paths are undeclared.

**Critical Impacts:**

1. **Parallel Execution Violations**: Transactions write to undeclared state paths, violating ACS2 guarantees. The parallel execution system relies on accurate resource path declarations to determine which transactions can execute concurrently. Undeclared path access breaks this fundamental assumption.

2. **Race Conditions**: Two transactions using aliases for different NFTs in the same collection (e.g., "ALIAS1"→"ABC-1" and "ALIAS2"→"ABC-2") won't declare the shared collection allowance path "ABC-*". The system may incorrectly allow parallel execution when these transactions actually conflict on the same collection-level allowance state.

3. **State Corruption Risk**: Concurrent writes to the same undeclared allowance or balance paths can cause lost updates, inconsistent state, or transaction failures in parallel execution environments.

**Affected Parties**: All users of NFTs with aliases, NFT collection owners, and the parallel execution system's integrity.

## Likelihood Explanation

**Attacker Capabilities:**
- NFT collection owners/issuers can set aliases via the public `SetSymbolAlias` method (requires only NFT ownership, not special privileges)
- Any user can invoke `TransferFrom` with an alias after receiving approval

**Attack Complexity**: Low - simply use an alias in a transaction parameter.

**Feasibility Conditions:**
- Aliases are a documented, supported feature as evidenced by dedicated test coverage
- The vulnerability triggers automatically for any transaction using an alias, requiring no special exploitation technique
- No economic barriers beyond normal transaction fees

**Probability**: HIGH - This occurs for 100% of transactions using NFT aliases, which is a legitimate and encouraged use case supported by the protocol.

## Recommendation

Resolve aliases to their actual symbols in `GetResourceInfo` before declaring state paths. Modify the `GetResourceInfo` method to call a helper that resolves aliases:

1. Add alias resolution in `AddPathForAllowance` by checking `State.SymbolAliasMap[symbol]` before calling `GetSymbolType`
2. Use the resolved symbol when constructing all resource paths in `GetResourceInfo`
3. Alternatively, add a helper method `GetActualSymbolForResourceDeclaration` that resolves aliases before resource path construction

This ensures the declared paths match the paths actually accessed during execution.

## Proof of Concept

```csharp
[Fact]
public async Task NFTAlias_UndeclaredStatePath_ParallelExecution_Test()
{
    // Setup: Create NFT collection and set alias
    await CreateNFTCollectionAsync("TP");
    await IssueNFTAsync("TP-31175", 1, DefaultAddress);
    await SetSymbolAliasAsync("TP-31175", "TP");
    
    // Approve spender to use the NFT via alias
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Symbol = "TP",  // Using alias
        Amount = 1,
        Spender = User1Address
    });
    
    // Get resource info for TransferFrom with alias
    var transaction = GenerateTokenTransaction(User1Address, nameof(TokenContractStub.TransferFrom),
        new TransferFromInput
        {
            Symbol = "TP",  // Using alias in transaction
            Amount = 1,
            From = DefaultAddress,
            To = User2Address
        });
    
    var resourceInfo = await Acs2BaseStub.GetResourceInfo.CallAsync(transaction);
    
    // Verify: Collection path "TP-*" is NOT declared
    var collectionPath = $"Allowances.{DefaultAddress}.{User1Address}.TP-*";
    resourceInfo.WritePaths.ShouldNotContain(p => p.Path.Parts.Contains("TP-*"));
    
    // Execute TransferFrom - will access undeclared "TP-*" path
    await TokenContractStubUser.TransferFrom.SendAsync(new TransferFromInput
    {
        Symbol = "TP",
        Amount = 1,
        From = DefaultAddress,
        To = User2Address
    });
    
    // Vulnerability: Transaction executed successfully but accessed undeclared state paths
}
```

## Notes

The vulnerability also affects the `Transfer` method which similarly uses input symbols directly in `GetResourceInfo` and resolves aliases during execution, causing balance path mismatches. [11](#0-10) [12](#0-11) 

The NFT symbol separator is defined as a hyphen character. [13](#0-12)

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L15-38)
```csharp
            case nameof(Transfer):
            {
                var args = TransferInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), txn.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol)
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };

                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L40-64)
```csharp
            case nameof(TransferFrom):
            {
                var args = TransferFromInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), args.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.LockWhiteLists), args.Symbol, txn.From.ToString())
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };
                AddPathForAllowance(resourceInfo, args.From.ToString(), txn.From.ToString(), args.Symbol);
                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L71-82)
```csharp
    private void AddPathForAllowance(ResourceInfo resourceInfo, string from, string spender, string symbol)
    {
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender, symbol));
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
            GetAllSymbolIdentifier()));
        var symbolType = GetSymbolType(symbol);
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
        {
            resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
                GetNftCollectionAllSymbolIdentifier(symbol)));
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L254-259)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransferFrom(input.From, input.To, Context.Sender, tokenInfo.Symbol, input.Amount, input.Memo);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L840-852)
```csharp
    private void CheckTokenAlias(string alias, string collectionSymbol)
    {
        if (collectionSymbol == null)
        {
            throw new AssertionException("Token alias can only be set for NFT Item.");
        }

        // Current Rule: Alias must be the seed name.
        var parts = collectionSymbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(parts.Length == 2, $"Incorrect collection symbol: {collectionSymbol}.");
        Assert(parts.Last() == TokenContractConstants.CollectionSymbolSuffix, "Incorrect collection symbol suffix.");
        Assert(alias == parts.First(), $"Alias for an item of {collectionSymbol} cannot be {alias}.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L70-95)
```csharp
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L125-135)
```csharp
    private long GetNftCollectionAllSymbolAllowance(Address from, Address spender, string sourceSymbol,
        out string allowanceSymbol)
    {
        allowanceSymbol = GetNftCollectionAllSymbolIdentifier(sourceSymbol);
        return State.Allowances[from][spender][allowanceSymbol];
    }

    private string GetNftCollectionAllSymbolIdentifier(string sourceSymbol)
    {
        // "AAA-*"
        return $"{sourceSymbol.Split(TokenContractConstants.NFTSymbolSeparator)[0]}-{TokenContractConstants.AllSymbolIdentifier}";
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenAliasTests.cs (L203-238)
```csharp
    [Fact]
    public async Task ApproveAndTransferFromViaAlias_Test()
    {
        await CreateTokenWithAlias_Test();

        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = "TP-31175",
            Amount = 1,
            To = DefaultAddress
        });

        await TokenContractStub.Approve.SendAsync(new ApproveInput
        {
            Symbol = "TP",
            Amount = 1,
            Spender = User1Address
        });

        await TokenContractStubUser.TransferFrom.SendAsync(new TransferFromInput
        {
            Symbol = "TP",
            Amount = 1,
            From = DefaultAddress,
            To = User2Address,
        });

        {
            var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = User2Address,
                Symbol = "TP"
            });
            balance.Balance.ShouldBe(1);
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L19-19)
```csharp
    public const char NFTSymbolSeparator = '-';
```
