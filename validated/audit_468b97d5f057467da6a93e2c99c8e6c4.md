# Audit Report

## Title
Two-Miner Consensus Deadlock: Malicious Miner Can Permanently Block Term Transitions

## Summary
In a two-miner network, a single malicious miner can permanently block term transitions by refusing to mine, creating an unrecoverable deadlock. The consensus mechanism requires both miners to have mined blocks before allowing term transition, but the attacker prevents this threshold from being met. This permanently freezes the miner list, blocks treasury distributions, and renders the blockchain governance ineffective.

## Finding Description

The vulnerability stems from the consensus term transition logic that requires a two-thirds majority of miners to have mined in the new period before transitioning terms.

**Root Cause:**

The `GetConsensusBehaviourToTerminateCurrentRound` method determines whether to use `NextRound` or `NextTerm` behavior based on `NeedToChangeTerm`: [1](#0-0) 

The `NeedToChangeTerm` method implements the consensus requirement by counting only miners who have `ActualMiningTimes`: [2](#0-1) 

The critical flaw is in `MinersCountOfConsent` calculation for a two-miner network: [3](#0-2) 

For 2 miners: `2 * 2 / 3 + 1 = 1 + 1 = 2` (integer division), requiring BOTH miners.

**Attack Mechanism:**

When a malicious miner refuses to mine, the filter at line 219 `.Where(m => m.ActualMiningTimes.Any())` excludes the non-mining attacker. Only 1 miner passes the filter, but the count (1) is less than MinersCountOfConsent (2), so `NeedToChangeTerm` returns false and the system uses `NextRound` instead of `NextTerm`.

**Why Protections Fail:**

After 4320 missed slots, evil miners are detected during `ProcessNextRound`: [4](#0-3) [5](#0-4) [6](#0-5) 

However, marking as evil only updates the Election contract - it does NOT remove the miner from the active consensus list.

The active miner list is ONLY updated during term transitions in `ProcessNextTerm`: [7](#0-6) 

**Miner Replacement Cannot Break Deadlock:**

The system attempts mid-term miner replacement through `GetMinerReplacementInformation`: [8](#0-7) [9](#0-8) 

In a two-miner network where both miners are initial miners, alternative candidates from election exclude current miners (line 374) and alternative candidates from initial miners also exclude current miners (line 390). Result: `AlternativeCandidatePubkeys.Count = 0`, and the line 309 check fails, so replacement never occurs.

**Governance Cannot Recover:**

The `RemoveEvilNode` governance method also cannot break the deadlock: [10](#0-9) 

This only calls `UpdateCandidateInformation` which updates Election contract state, not the active consensus miner list.

**Unbreakable Circular Dependency:**
1. To remove evil miner from active list → need term transition (`ProcessNextTerm`)
2. To trigger term transition → need `NextTerm` behavior
3. To get `NextTerm` → need `NeedToChangeTerm = true`
4. To satisfy `NeedToChangeTerm` → need both miners to have mined
5. But attacker refuses to mine → **deadlock**

## Impact Explanation

This vulnerability creates **permanent, unrecoverable protocol failure** with the following critical impacts:

**Consensus Availability Failure:**
- Term transitions are permanently blocked
- The system freezes at the current term indefinitely
- No mechanism exists to recover without hard fork intervention

**Economic Impact:**
- Treasury distributions halt (only occur during term transitions): [11](#0-10) 
- Mining rewards cannot be donated to Treasury
- Token holders receive no profit distributions

**Governance Paralysis:**
- Election results cannot be applied (miner list updates only happen in ProcessNextTerm)
- New miners cannot join despite winning elections
- Evil miners cannot be removed from active consensus
- Protocol cannot adapt to changing conditions

**Network Control:**
- The malicious miner maintains their position indefinitely
- Effectively achieves permanent 50% control over block production
- Prevents legitimate miners from joining

This is CRITICAL severity because it permanently breaks the consensus mechanism's availability and governance with no in-protocol recovery path.

## Likelihood Explanation

**High likelihood** in two-miner network scenarios due to:

**Low Attack Barrier:**
- Requires control of only 1 of 2 miners (50% threshold)
- No special technical capabilities needed
- Trivial execution: simply stop mining at period boundary
- Zero transaction costs
- Passive attack - just refuse to participate

**Realistic Deployment Scenarios:**
- Early-stage sidechains during bootstrap
- Test networks with minimal miners
- Small private chains
- Development/staging environments
- Period boundaries occur every 7 days (604800 seconds default)

**Economic Incentive:**
- Attacker maintains their miner position indefinitely
- Prevents competitors from joining via elections
- Zero cost to maintain attack
- High benefit: permanent control over 50% of block production and rewards

**Detection Difficulty:**
- Initially appears as normal network issues or miner downtime
- By the time deadlock is recognized (3+ days after marking as evil), recovery requires hard fork
- No in-protocol detection mechanism for this specific deadlock scenario

**Attack Rationality:**
- Economically rational: maintain privileged position at zero cost
- Strategically beneficial: block competition from new miners
- Risk-free: no penalty for refusing to mine beyond detection (which doesn't resolve the issue)

## Recommendation

Implement a special case handling for two-miner networks in the `NeedToChangeTerm` logic:

1. **Modify MinersCountOfConsent calculation** to account for edge cases where requiring 100% participation creates deadlocks
2. **Add fallback mechanism** that allows term transition after extended periods of non-participation (e.g., if one miner hasn't mined for > 7 days, allow single-miner consensus for term transition)
3. **Implement emergency governance action** that can force term transitions and update miner lists without requiring the normal consensus threshold
4. **Add minimum miner count enforcement** that prevents networks from running with only 2 miners in production environments

Example fix for `NeedToChangeTerm`:
```csharp
public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
{
    var minersWhoMined = RealTimeMinersInformation.Values
        .Where(m => m.ActualMiningTimes.Any())
        .ToList();
    
    // Special handling for two-miner networks to prevent deadlock
    if (RealTimeMinersInformation.Count == 2 && minersWhoMined.Count == 1)
    {
        var soloMiner = minersWhoMined[0];
        // If the single active miner has crossed the term boundary, allow transition
        if (IsTimeToChangeTerm(blockchainStartTimestamp, 
            soloMiner.ActualMiningTimes.Last(), currentTermNumber, periodSeconds))
        {
            return true;
        }
    }
    
    // Normal consensus logic
    return minersWhoMined
        .Select(m => m.ActualMiningTimes.Last())
        .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
            t, currentTermNumber, periodSeconds))
        >= MinersCountOfConsent;
}
```

## Proof of Concept

A test demonstrating this vulnerability would:

1. Initialize a two-miner network
2. Progress to a period boundary (term transition point)
3. Have one miner stop mining (refuse to call UpdateValue/NextRound)
4. Have the honest miner continue attempting to mine
5. Observe that `GetConsensusBehaviourToTerminateCurrentRound` returns `NextRound` instead of `NextTerm`
6. Verify that after 4320 missed slots, the evil miner is marked in Election contract but remains in active consensus
7. Verify that `GetMinerReplacementInformation` returns no alternative candidates
8. Confirm that term never transitions and treasury distributions never occur

The vulnerability is proven by the code analysis showing the circular dependency that creates an unbreakable deadlock in two-miner configurations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L368-392)
```csharp
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-320)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-351)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
    }
```
