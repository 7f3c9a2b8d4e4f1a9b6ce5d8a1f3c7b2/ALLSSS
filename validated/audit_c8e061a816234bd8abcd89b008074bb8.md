# Audit Report

## Title
BurnProfits Unconditionally Overwrites DistributedProfitsMap Causing Loss of Pre-Contributed Profits

## Summary
The `BurnProfits` function creates a new `DistributedProfitsInfo` object and unconditionally overwrites existing state without preserving pre-contributed profits. When users contribute tokens to future periods via `ContributeProfits` and the scheme later has zero `totalShares` at distribution time, `BurnProfits` destroys the accounting record while tokens remain locked in period-specific virtual addresses, making them permanently unclaimable.

## Finding Description

The vulnerability exists in how `BurnProfits` handles periods that already have pre-contributed profits.

When users contribute to future periods, `ContributeProfits` validates the period is valid and generates a period-specific virtual address. [1](#0-0)  The tokens are transferred to this period-specific address, [2](#0-1)  and the contribution is recorded in `DistributedProfitsMap`. [3](#0-2) 

When `DistributeProfits` is later called for that period with `totalShares <= 0`, it invokes `BurnProfits`. [4](#0-3) 

The critical flaw is in the `BurnProfits` implementation: it creates a brand new `DistributedProfitsInfo` object without reading any existing state. [5](#0-4)  It then burns tokens from the scheme's general ledger (not the period-specific address where pre-contributions were deposited), [6](#0-5)  and unconditionally overwrites the state. [7](#0-6) 

In contrast, the normal distribution path via `UpdateDistributedProfits` correctly reads existing state and checks the period-specific address balance. [8](#0-7) 

After `BurnProfits` sets `IsReleased=true`, future contributions to that period are blocked. [9](#0-8) 

When users try to claim profits via `ClaimProfits`, the calculation depends entirely on `DistributedProfitsMap`. [10](#0-9)  With the accounting destroyed, the contributed tokens become permanently unrecoverable despite remaining in the period-specific virtual address.

## Impact Explanation

**High Severity - Permanent Loss of User Funds:**

1. **Complete Fund Loss:** Tokens contributed to future periods become permanently locked in period-specific virtual addresses with no recovery mechanism. The accounting in `DistributedProfitsMap` is destroyed, and `ClaimProfits` cannot retrieve these funds.

2. **Quantified Damage:** The impact scales linearly with contribution amounts. If 10,000 ELF tokens are contributed to period 5, and the scheme has zero beneficiaries when period 5 arrives, all 10,000 ELF become permanently locked.

3. **Affected Parties:**
   - Users who contribute profits to future periods expecting normal distribution
   - Scheme managers who inadvertently trigger this by removing all beneficiaries during scheme wind-down
   - The overall protocol, as tokens become permanently stuck in virtual addresses

4. **No Recovery Path:** Once `BurnProfits` executes, there is no mechanism to recover the contributed funds. The virtual address still holds the tokens, but all accounting is lost.

## Likelihood Explanation

**Medium Likelihood - Triggered Through Normal Operations:**

1. **Public Entry Point:** `ContributeProfits` is a public method callable by any user with token allowance, requiring no special privileges for the contribution step.

2. **Realistic Preconditions:**
   - Profit scheme exists and accepts contributions (common scenario)
   - User contributes to a future period (explicitly allowed by the contract, validated in the code)
   - By the time that period arrives, all beneficiaries have been removed via `RemoveBeneficiary`, resulting in `totalShares = 0`
   - Scheme manager calls `DistributeProfits` for the period

3. **Natural Occurrence:** This scenario occurs when:
   - A scheme is being wound down and beneficiaries are systematically removed
   - Users had previously contributed to future periods expecting normal operation
   - The timing gap between contribution and distribution allows legitimate beneficiary changes

4. **No Attack Cost:** Beyond the initial contribution (which could be small), there's no additional cost to trigger the vulnerability. The loss occurs through legitimate contract operations.

5. **Detection Difficulty:** Both `ContributeProfits` and `RemoveBeneficiary` are legitimate operations. The fund loss only becomes apparent when users attempt to claim profits, potentially much later.

## Recommendation

Modify `BurnProfits` to preserve pre-contributed profits by reading the existing `DistributedProfitsInfo` state before overwriting it, similar to how `UpdateDistributedProfits` operates:

```csharp
private Empty BurnProfits(long period, Dictionary<string, long> profitsMap, Scheme scheme,
    Address profitsReceivingVirtualAddress)
{
    scheme.CurrentPeriod = period.Add(1);

    // Read existing state instead of creating new
    var distributedProfitsInfo = State.DistributedProfitsMap[profitsReceivingVirtualAddress] 
        ?? new DistributedProfitsInfo();
    
    distributedProfitsInfo.IsReleased = true;
    
    // Check period-specific address balance for pre-contributions
    foreach (var profits in profitsMap)
    {
        var symbol = profits.Key;
        var amount = profits.Value;
        
        // Get balance from period-specific address
        var balanceOfPeriodAddress = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = profitsReceivingVirtualAddress,
            Symbol = symbol
        }).Balance;
        
        // If there are pre-contributed tokens, burn them from period address
        if (balanceOfPeriodAddress > 0)
        {
            Context.SendVirtualInline(
                GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                State.TokenContract.Value,
                nameof(State.TokenContract.Transfer), new TransferInput
                {
                    To = Context.Self,
                    Amount = balanceOfPeriodAddress,
                    Symbol = symbol
                }.ToByteString());
            State.TokenContract.Burn.Send(new BurnInput
            {
                Amount = balanceOfPeriodAddress,
                Symbol = symbol
            });
            distributedProfitsInfo.AmountsMap[symbol] = -balanceOfPeriodAddress;
        }
        
        // Also burn from general ledger if specified in profitsMap
        if (amount > 0)
        {
            var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = scheme.VirtualAddress,
                Symbol = symbol
            });
            if (balanceOfToken.Balance >= amount)
            {
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
                distributedProfitsInfo.AmountsMap[symbol] = 
                    (distributedProfitsInfo.AmountsMap.ContainsKey(symbol) 
                        ? distributedProfitsInfo.AmountsMap[symbol] : 0).Sub(amount);
            }
        }
    }

    State.SchemeInfos[scheme.SchemeId] = scheme;
    State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task BurnProfits_Destroys_PreContributed_Funds_Test()
{
    const long contributeAmount = 100_000;
    const int futureP eriod = 5;
    
    var creator = Creators[0];
    var creatorAddress = Address.FromPublicKey(CreatorKeyPair[0].PublicKey);
    
    // Create scheme
    await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true,
        ProfitReceivingDuePeriodCount = 100
    });
    
    var schemeIds = (await creator.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = creatorAddress })).SchemeIds;
    var schemeId = schemeIds.First();
    
    // User contributes to future period 5
    await ProfitContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol,
        Amount = contributeAmount,
        Period = futurePerio
    });
    
    // Verify tokens are in period-specific address
    var periodAddress = await creator.GetSchemeAddress.CallAsync(
        new SchemePeriod { SchemeId = schemeId, Period = futurePerio });
    var balanceBefore = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = periodAddress, Symbol = ProfitContractTestConstants.NativeTokenSymbol })).Balance;
    balanceBefore.ShouldBe(contributeAmount);
    
    // Verify accounting exists
    var distributedInfoBefore = await creator.GetDistributedProfitsInfo.CallAsync(
        new SchemePeriod { SchemeId = schemeId, Period = futurePerio });
    distributedInfoBefore.AmountsMap[ProfitContractTestConstants.NativeTokenSymbol].ShouldBe(contributeAmount);
    
    // Advance periods and distribute with totalShares=0 (no beneficiaries)
    for (int p = 1; p < futurePerio; p++)
    {
        await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeId = schemeId,
            Period = p
        });
    }
    
    // This triggers BurnProfits due to totalShares=0
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = futurePerio
    });
    
    // Tokens still in period address
    var balanceAfter = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = periodAddress, Symbol = ProfitContractTestConstants.NativeTokenSymbol })).Balance;
    balanceAfter.ShouldBe(contributeAmount); // Tokens still there!
    
    // But accounting is destroyed
    var distributedInfoAfter = await creator.GetDistributedProfitsInfo.CallAsync(
        new SchemePeriod { SchemeId = schemeId, Period = futurePerio });
    distributedInfoAfter.IsReleased.ShouldBeTrue();
    distributedInfoAfter.AmountsMap[ProfitContractTestConstants.NativeTokenSymbol].ShouldBe(0); // Lost!
    
    // Funds are permanently locked - no way to recover
}
```

## Notes

This vulnerability demonstrates a critical flaw in the profit distribution system where the `BurnProfits` function fails to account for pre-contributed profits when burning. The root cause is that `BurnProfits` creates a fresh `DistributedProfitsInfo` object instead of reading and preserving the existing state, unlike the normal distribution path in `UpdateDistributedProfits`. This design inconsistency leads to permanent fund loss when schemes reach zero beneficiaries after users have contributed to future periods.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L522-525)
```csharp
        var distributedProfitsInfo = new DistributedProfitsInfo
        {
            IsReleased = true
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L532-552)
```csharp
                var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = symbol
                });
                if (balanceOfToken.Balance < amount)
                    continue;
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
                distributedProfitsInfo.AmountsMap.Add(symbol, -amount);
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L556-556)
```csharp
        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L563-579)
```csharp
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L684-686)
```csharp
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L688-712)
```csharp
            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L866-871)
```csharp
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```
