# Audit Report

## Title
Unvalidated ActualMiningTime Allows Manipulation of Term Change Consensus Threshold

## Summary
The AEDPoS consensus contract accepts miner-provided `ActualMiningTime` values without validating they equal `Context.CurrentBlockTime`. This allows malicious miners controlling >1/3 of slots to prevent term changes indefinitely by submitting timestamps before term boundaries, breaking consensus liveness and freezing critical governance operations.

## Finding Description

The vulnerability exists in how the consensus contract processes and validates `ActualMiningTime` values during block production.

**Root Cause:**

The `ProcessUpdateValue` method directly stores the miner-provided `ActualMiningTime` from `UpdateValueInput` without any validation against the actual block timestamp: [1](#0-0) 

**Missing Validations:**

1. The `TimeSlotValidationProvider` only validates that `ActualMiningTime` falls within the miner's expected time slot window, NOT that it equals the actual block production time: [2](#0-1) 

2. The `UpdateValueValidationProvider` validates signatures and previous in values but completely ignores the `ActualMiningTime` field: [3](#0-2) 

3. VRF verification only covers the `randomNumber` field and does not cryptographically bind `ActualMiningTime`: [4](#0-3) 

**Normal Flow vs Exploitation:**

In honest implementations, `ActualMiningTime` is set to `Context.CurrentBlockTime` when generating consensus extra data: [5](#0-4) 

However, a malicious miner can modify their node software to submit any `ActualMiningTime` value within their time slot window. During validation, this manipulated value is recovered into the base round for checking: [6](#0-5) 

The validation passes as long as the timestamp is within the time slot, and the manipulated value is permanently stored.

**Impact on Term Change Consensus:**

Term change decisions depend on `NeedToChangeTerm`, which counts how many miners' last `ActualMiningTime` indicates a term change is needed: [7](#0-6) 

This requires a supermajority threshold defined as: [8](#0-7) 

Term change is determined by checking if timestamps cross the term period boundary: [9](#0-8) 

By submitting `ActualMiningTime` values just before the term boundary (even when actual block production occurs after), malicious miners prevent their timestamps from indicating term change. If >1/3 of miners do this, the 2/3+1 threshold cannot be met.

This decision directly controls whether the system proceeds to `NextTerm` or stays in `NextRound`: [10](#0-9) 

## Impact Explanation

**Severity: High**

This vulnerability breaks fundamental consensus assumptions with protocol-wide impact:

**Governance Halt:**
Term changes trigger critical governance operations. The `ProcessNextTerm` method handles treasury releases, election snapshots, and miner list updates: [11](#0-10) 

Preventing term changes blocks these operations indefinitely, freezing:
- Treasury fund releases to stakeholders (lines 205-208)
- Election snapshots for validator selection (lines 213-218)
- Miner list updates, allowing malicious miners to remain in power (lines 188-190)
- Reward distribution mechanisms (line 203)

**Consensus Integrity:**
The attack breaks the liveness property of the consensus mechanism by allowing a minority (>1/3) to halt protocol progression, violating Byzantine fault tolerance assumptions that should tolerate up to 1/3 malicious nodes.

**No Recovery Mechanism:**
There is no automatic recovery path once term changes are blocked, requiring manual intervention or hard fork to resolve.

## Likelihood Explanation

**Probability: High**

The attack is highly feasible:

**Low Attacker Requirements:**
- Control of >1/3 of miner nodes (realistic threshold for coordinated attacks)
- No special privileges beyond normal miner operations
- Standard transaction construction capabilities

**Trivial Technical Complexity:**
- Attack requires only modifying one timestamp field in `UpdateValueInput`
- No cryptographic expertise needed
- No sophisticated timing coordination required

**Many Attack Opportunities:**
- Any time a miner's time slot is near the term boundary
- With 7-day terms and 4-second blocks: ~151,200 blocks per term
- Each colluding miner has thousands of opportunities

**No Detection or Penalty:**
- Manipulated timestamps appear valid (within time slots)
- No monitoring mechanism to detect timestamp manipulation
- No slashing or penalty for this behavior
- Zero cost to execute

## Recommendation

Add validation to ensure `ActualMiningTime` equals `Context.CurrentBlockTime`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // Add validation: ActualMiningTime must equal current block time
    Assert(updateValueInput.ActualMiningTime == Context.CurrentBlockTime, 
        "ActualMiningTime must equal current block timestamp");
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
    // ... rest of method
}
```

Additionally, consider implementing:
1. Off-chain monitoring to detect timestamp manipulation attempts
2. Slashing mechanisms for miners who submit invalid timestamps
3. Emergency governance procedures to recover from stalled term transitions

## Proof of Concept

A test demonstrating the vulnerability would involve:

1. Set up a test environment with multiple miner nodes
2. Configure miners near a term boundary
3. Have >1/3 of miners modify their `UpdateValueInput.ActualMiningTime` to be just before the term boundary
4. Submit blocks with these manipulated timestamps
5. Verify the timestamps pass validation (within time slots)
6. Verify `NeedToChangeTerm` returns false despite actual block time being past the boundary
7. Confirm term transition is blocked and governance operations are frozen

The test would demonstrate that the 2/3+1 threshold cannot be met when >1/3 of miners manipulate their timestamps, permanently blocking term changes.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-243)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-50)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-20)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L239-243)
```csharp
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```
