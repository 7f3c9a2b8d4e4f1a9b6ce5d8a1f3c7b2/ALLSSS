# Audit Report

## Title
Critical Consensus DoS via Integer Division Precision Loss in Mining Interval Validation

## Summary
The AEDPoS consensus contract contains a critical validation gap allowing any active miner to permanently brick the blockchain by injecting rounds with sub-8ms mining intervals. Integer division of `MiningInterval / 8` produces 0ms execution timeouts when intervals are 1-7ms, causing all block production to fail. The validation only enforces `MiningInterval > 0` rather than `>= 8`, enabling atomic and irreversible chain denial of service.

## Finding Description

The vulnerability originates in the `TinyBlockSlotInterval` calculation which divides the mining interval by 8 using integer division: [1](#0-0) 

When `MiningInterval` is 1-7ms, this produces 0ms. This zero value cascades to all mining execution limits: [2](#0-1) [3](#0-2) 

**Validation Failure**: The `CheckRoundTimeSlots()` method only validates that mining interval is greater than 0, not greater than or equal to 8: [4](#0-3) 

**Attack Path**:

1. A malicious miner calls the public `NextRound` method: [5](#0-4) 

2. Authorization only checks if sender is in the miner list: [6](#0-5) 

3. Round validation uses `TimeSlotValidationProvider` which calls the insufficient validation: [7](#0-6) 

4. The malicious round is stored via `ProcessNextRound`: [8](#0-7) 

5. Future rounds perpetually inherit the broken interval via `GetMiningInterval()` which calculates from stored `ExpectedMiningTime` values: [9](#0-8) 

6. The 0ms limits are used in consensus commands to set block execution timeouts: [10](#0-9) [11](#0-10) 

7. The mining service receives 0ms execution time and immediately cancels all transaction execution: [12](#0-11) 

## Impact Explanation

**Complete Chain Denial of Service**: When `LimitMillisecondsOfMiningBlock` is 0ms, the cancellation token in `MiningService.MineAsync` is cancelled immediately before any transactions can execute. This affects both user transactions AND consensus system transactions, creating an unrecoverable state.

**Concrete Damage**:
- All miners receive 0ms execution time, causing immediate cancellation of block execution
- No transactions can be processed, including recovery attempts via `NextRound`
- Chain throughput drops to zero - blockchain becomes completely unusable
- **Permanent damage**: Future rounds perpetually calculate `MiningInterval` from the poisoned stored values
- Requires emergency intervention: hard fork or restoration from pre-attack backup
- All staked assets, locked tokens, and pending transactions become frozen

**Affected Parties**: All network participants - miners cannot produce functional blocks, users cannot submit transactions, dApps cease operation, entire economic activity halts.

## Likelihood Explanation

**Attack Complexity: LOW**
- Requires only being an active miner (17-21 elected validators on mainchain)
- Executable during any `NextRound` transition when attacker's turn arrives
- Simple execution: manually construct `NextRoundInput` with `ExpectedMiningTime` values 5ms apart instead of standard 4000ms
- No complex cryptographic operations or multi-step coordination needed

**Feasibility: HIGH**
- Entry point is the public `NextRound` method accessible to all miners
- Precondition is realistic: attacker needs election as miner via normal process
- No economic barriers - attack cost is minimal (single transaction gas fee)
- Attack succeeds atomically upon transaction execution

**Detection**: Attack is immediately detectable (zero user transactions per block) but damage is irreversible by the time detection occurs.

**Probability: HIGH** - Any of the 17-21 mainchain miners can execute this attack at any time during their assigned NextRound turn.

## Recommendation

Add minimum mining interval validation in `CheckRoundTimeSlots()`:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    var baseMiningInterval =
        (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

    // ADD THIS CHECK:
    const int MinimumMiningInterval = 8; // Minimum to ensure TinyBlockSlotInterval >= 1ms
    if (baseMiningInterval < MinimumMiningInterval)
        return new ValidationResult { Message = $"Mining interval must be at least {MinimumMiningInterval}ms.\n{this}" };

    if (baseMiningInterval <= 0)
        return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

    for (var i = 1; i < miners.Count - 1; i++)
    {
        var miningInterval =
            (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
        if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
            return new ValidationResult { Message = "Time slots are so different." };
    }

    return new ValidationResult { Success = true };
}
```

Alternatively, use a more conservative minimum like 4000ms (the standard single-miner interval) to prevent any abnormally low intervals.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanBrickChain_WithSubThresholdMiningInterval()
{
    // Setup: Initialize consensus with normal miners
    var initialMiners = await InitializeConsensusAsync();
    var maliciousMiner = initialMiners[0];
    
    // Create malicious NextRoundInput with 5ms intervals (below 8ms threshold)
    var currentRound = await GetCurrentRoundAsync();
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber
    };
    
    // Set ExpectedMiningTime values only 5ms apart
    var baseTime = TimestampHelper.GetUtcNow();
    for (int i = 0; i < initialMiners.Count; i++)
    {
        maliciousNextRound.RealTimeMinersInformation[initialMiners[i]] = new MinerInRound
        {
            Pubkey = initialMiners[i],
            Order = i + 1,
            ExpectedMiningTime = baseTime.AddMilliseconds(5 * (i + 1)) // 5ms intervals
        };
    }
    maliciousNextRound.RandomNumber = await GenerateRandomNumberAsync(maliciousMiner);
    
    // Execute attack
    await ExecuteConsensusTransactionAsync(maliciousMiner, nameof(AEDPoSContract.NextRound), maliciousNextRound);
    
    // Verify: Check that validation passed (should not pass if vulnerability is fixed)
    var newRound = await GetCurrentRoundAsync();
    newRound.RoundNumber.ShouldBe(maliciousNextRound.RoundNumber);
    
    // Verify: Mining interval is now poisoned
    var miningInterval = newRound.GetMiningInterval();
    miningInterval.ShouldBe(5); // 5ms interval stored
    
    // Verify: Mining limits are now 0ms
    var tinyBlockSlotInterval = miningInterval / 8;
    tinyBlockSlotInterval.ShouldBe(0); // Integer division produces 0
    
    // Verify: Next block production fails due to 0ms timeout
    var nextBlockAttempt = await TryProduceNextBlockAsync(initialMiners[1]);
    nextBlockAttempt.Success.ShouldBeFalse();
    nextBlockAttempt.TransactionCount.ShouldBe(0); // No transactions executed
    
    // Verify: Chain is permanently bricked - no recovery possible
    for (int i = 0; i < initialMiners.Count; i++)
    {
        var recoveryAttempt = await TryProduceNextBlockAsync(initialMiners[i]);
        recoveryAttempt.Success.ShouldBeFalse();
    }
}
```

## Notes

This vulnerability breaks the fundamental liveness guarantee of the blockchain consensus mechanism. The validation gap allows a malicious miner with legitimate credentials to permanently halt all transaction processing through a single malformed consensus transaction. The integer division behavior creates a precision-loss edge case that the validation logic fails to guard against, resulting in cascading 0ms timeout values throughout the mining pipeline. Recovery requires external intervention beyond the protocol's self-healing capabilities.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L42-42)
```csharp
        private int TinyBlockSlotInterval => MiningInterval.Div(TinyBlocksCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L49-49)
```csharp
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L54-54)
```csharp
        protected int LastTinyBlockMiningLimit => TinyBlockSlotInterval.Div(2);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L46-47)
```csharp
        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L79-80)
```csharp
        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L39-39)
```csharp
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L48-50)
```csharp
                    LimitMillisecondsOfMiningBlock = IsLastTinyBlockOfCurrentSlot()
                        ? LastTinyBlockMiningLimit
                        : DefaultBlockMiningLimit
```

**File:** src/AElf.Kernel/Miner/Application/MiningService.cs (L50-62)
```csharp
            using var cts = new CancellationTokenSource();
            var expirationTime = blockTime + requestMiningDto.BlockExecutionTime;
            if (expirationTime < TimestampHelper.GetUtcNow())
            {
                cts.Cancel();
            }
            else
            {
                var ts = (expirationTime - TimestampHelper.GetUtcNow()).ToTimeSpan();
                if (ts.TotalMilliseconds > int.MaxValue) ts = TimeSpan.FromMilliseconds(int.MaxValue);

                cts.CancelAfter(ts);
            }
```
