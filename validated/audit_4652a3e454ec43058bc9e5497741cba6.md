# Audit Report

## Title
NFT Collection Creation Bypass Allows Non-Zero Decimals Through Direct TokenContract Call

## Summary
The NFT contract enforces `Decimals = 0` for NFT collections, but this invariant can be bypassed by calling `TokenContract.Create` directly with NFT collection symbols (ending in "-0") and non-zero decimals. The TokenContract only validates decimals within [0, 18] for NFT collections, not that they equal zero, allowing creation of divisible "NFTs" that violate the fundamental NFT indivisibility property.

## Finding Description

The NFT contract's `Create` method correctly hardcodes `Decimals = 0` when creating NFT protocols [1](#0-0) , ensuring NFT collections are non-divisible.

However, the `TokenContract.Create` method is publicly accessible and can be called directly by any user possessing a valid SEED NFT. The method routes token creation based on symbol patterns through `GetSymbolType` [2](#0-1) .

The symbol type classification is purely pattern-based. Symbols ending with "-0" are classified as `SymbolType.NftCollection` [3](#0-2) .

For NFT collections, `CreateNFTCollection` simply delegates to `CreateToken` without additional validation [4](#0-3) .

The `CreateToken` method validates decimals only through `AssertValidCreateInput`, which permits any value between 0 and `MaxDecimals` (18) [5](#0-4) [6](#0-5) .

Only SEED NFT items (within SEED-0 collection) have explicit `Decimals == 0` validation [7](#0-6) . This validation does NOT prevent SEED NFTs from having `OwnedSymbol` values ending in "-0" (NFT collection format), as it only checks that the owned symbol is not of type `SymbolType.Nft` (individual NFT items), allowing `SymbolType.NftCollection` to pass.

**Attack Flow:**
1. Create SEED NFT (e.g., SEED-1) with `ExternalInfo["__seed_owned_symbol"] = "ABC-0"`
2. Call `TokenContract.Create` with `Symbol = "ABC-0"` and `Decimals = 8`
3. System classifies "ABC-0" as NFT collection, validates SEED, and creates token with `Decimals = 8`
4. Result: NFT collection exists with non-zero decimals, making it divisible

## Impact Explanation

**Protocol Invariant Violation**: NFTs are fundamentally non-fungible and indivisible tokens. The protocol design enforces `Decimals = 0` for all NFT collections to guarantee uniqueness and prevent fractional ownership. Creating NFT collections with `Decimals > 0` breaks this core invariant, allowing fractional NFT amounts (e.g., 0.5 of an NFT with `Decimals = 8` represented as 50000000 smallest units).

**Ecosystem Confusion**: dApps, wallets, and NFT marketplaces rely on symbol patterns (symbols ending in "-0" for collections) to identify and handle NFTs. These divisible tokens will be incorrectly treated as proper NFTs, causing:
- Incorrect display/accounting in NFT galleries and marketplaces
- Failed assumptions in smart contracts expecting indivisible NFT units
- User deception when purchasing apparent NFTs that are actually divisible

**Operational Impact**: Once created, these malformed NFT collections can be issued and transferred in fractional amounts via standard token operations [8](#0-7) , violating the NFT uniqueness guarantee.

## Likelihood Explanation

**Reachable Entry Point**: `TokenContract.Create` is a public method callable by any user with a valid SEED NFT [2](#0-1) .

**Feasible Preconditions**: 
- Attacker must acquire a SEED NFT for the target symbol via normal SEED NFT acquisition mechanisms
- No special privileges required beyond standard SEED NFT ownership
- SEED creation validation allows OwnedSymbol ending in "-0" because it only rejects `SymbolType.Nft`, not `SymbolType.NftCollection` [9](#0-8) 

**Execution Steps**:
1. Acquire/create SEED NFT with `OwnedSymbol = "ABC-0"`
2. Call `TokenContract.Create(Symbol="ABC-0", Decimals=8, ...)`
3. System validates SEED NFT and burns it
4. Token created with `Decimals = 8`
5. Attacker can now issue/transfer fractional amounts

## Recommendation

Add explicit validation in `CreateToken` or `AssertValidCreateInput` to enforce `Decimals == 0` for NFT collections:

```csharp
private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
{
    Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
           && input.Symbol.Length > 0
           && input.Decimals >= 0
           && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");
    
    // Enforce NFT collection invariant
    if (symbolType == SymbolType.NftCollection)
    {
        Assert(input.Decimals == 0, "NFT collections must have Decimals = 0");
    }

    CheckSymbolLength(input.Symbol, symbolType);
    if (symbolType == SymbolType.Nft) return;
    CheckTokenAndCollectionExists(input.Symbol);
    if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
}
```

Additionally, consider adding validation in `CreateNFTInfo` (SEED creation) to prevent `OwnedSymbol` from being an NFT collection format:

```csharp
var ownedSymbolType = GetSymbolType(ownedSymbol);
Assert(ownedSymbolType == SymbolType.Token, "OwnedSymbol must be a regular token symbol.");
```

## Proof of Concept

```csharp
[Fact]
public async Task Create_NFT_Collection_With_NonZero_Decimals_Should_Succeed()
{
    // Step 1: Create SEED NFT with OwnedSymbol ending in "-0"
    var seedSymbol = "SEED-1";
    var targetCollection = "TEST-0"; // NFT collection format
    
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = seedSymbol,
        TokenName = "SEED Token",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultSender,
        IsBurnable = true,
        IssueChainId = _chainId,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                { "__seed_owned_symbol", targetCollection }, // Collection symbol!
                { "__seed_exp_time", "9999999999" }
            }
        }
    });
    
    // Step 2: Call TokenContract.Create directly with non-zero decimals
    var result = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = targetCollection,
        TokenName = "Test NFT Collection",
        TotalSupply = 10000,
        Decimals = 8, // Non-zero decimals!
        Issuer = DefaultSender,
        IsBurnable = true,
        IssueChainId = _chainId
    });
    
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 3: Verify the collection was created with non-zero decimals
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
    {
        Symbol = targetCollection
    });
    
    tokenInfo.Decimals.ShouldBe(8); // Vulnerability confirmed: NFT collection with Decimals > 0
    tokenInfo.Symbol.ShouldBe(targetCollection);
}
```

This test demonstrates that an NFT collection (symbol ending in "-0") can be created with non-zero decimals, violating the NFT indivisibility invariant.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L26-26)
```csharp
            Decimals = 0, // Fixed
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-178)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(input.To, input.Symbol, input.Amount);

        Context.Fire(new Issued
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = input.To,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L10-13)
```csharp
    private Empty CreateNFTCollection(CreateInput input)
    {
        return CreateToken(input, SymbolType.NftCollection);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L37-52)
```csharp
        if (nftCollectionInfo.Symbol == TokenContractConstants.SeedCollectionSymbol)
        {
            Assert(input.Decimals == 0 && input.TotalSupply == 1, "SEED must be unique.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedOwnedSymbolExternalInfoKey,
                    out var ownedSymbol), "OwnedSymbol does not exist.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var expirationTime)
                   && long.TryParse(expirationTime, out var expirationTimeLong) &&
                   Context.CurrentBlockTime.Seconds <= expirationTimeLong, "Invalid ownedSymbol.");
            var ownedSymbolType = GetSymbolType(ownedSymbol);
            Assert(ownedSymbolType != SymbolType.Nft, "Invalid OwnedSymbol.");
            CheckSymbolLength(ownedSymbol, ownedSymbolType);
            CheckTokenAndCollectionExists(ownedSymbol);
            CheckSymbolSeed(ownedSymbol);
            State.SymbolSeedMap[ownedSymbol.ToUpper()] = input.Symbol;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L6-6)
```csharp
    public const int MaxDecimals = 18;
```
