# Audit Report

## Title
Deterministic Hash Causes Infinite Loop DOS in NFT Protocol Creation

## Summary
The `GenerateSymbolNumber()` function in the NFT contract contains a critical infinite loop vulnerability. The function generates a random hash once before a collision-avoidance loop but never regenerates it within the loop. Since `Context.ConvertHashToInt64()` is deterministic, the same number is produced on every iteration, causing an infinite loop until gas exhaustion when that number already exists in `State.IsCreatedMap`.

## Finding Description

The vulnerability exists in the `GenerateSymbolNumber()` helper function where collision avoidance is attempted through a do-while loop, but the collision-avoidance mechanism is fundamentally broken. [1](#0-0) 

The critical flaw occurs in this sequence:

1. A `randomHash` is computed **once** outside the loop using random bytes from the consensus contract combined with the sender's address [2](#0-1) 

2. Inside the do-while loop, this **fixed** `randomHash` is passed to `Context.ConvertHashToInt64()` with constant parameters [3](#0-2) 

3. The `ConvertHashToInt64()` method is **purely deterministic** - it uses BigInteger modulo arithmetic with no randomness or state changes [4](#0-3) 

Given identical inputs (`randomHash`, `from`, `from.Mul(10)`), this function always returns the exact same `randomNumber` value on every loop iteration. If `State.IsCreatedMap[randomNumber]` returns true, the loop continues infinitely with no mechanism to escape.

This vulnerability is triggered through the public `Create()` method which calls `GetSymbol()`, which in turn calls `GenerateSymbolNumber()` [5](#0-4) [6](#0-5) 

The initial number space starts at 9 digits [7](#0-6) , providing 9×10^8 possible values, but the deterministic mapping means certain (sender, blockHeight) combinations will always collide with existing entries.

## Impact Explanation

**Severity: Critical**

**Direct Operational Impact:**
- Complete DOS of the `Create()` function for specific (sender address, block height) combinations that generate already-used numbers
- Users experience transaction failures after gas exhaustion with no clear error message
- The NFT protocol creation mechanism becomes progressively unreliable as `State.IsCreatedMap` accumulates entries

**Scope of Affected Users:**
- Any user whose deterministic hash mapping collides with an existing entry
- Since the mapping is deterministic per (sender, blockHeight) pair, certain addresses become permanently unable to create protocols at specific block heights
- Collision probability increases geometrically as protocol creation continues
- With sufficient protocol creation, some address ranges may become completely blocked

**Protocol Integrity Impact:**
- Core functionality of the NFT contract is compromised
- User trust erodes as creation attempts mysteriously fail
- Wasted transaction fees for users encountering the infinite loop
- Potential forced migration to alternative NFT solutions

This represents a critical availability vulnerability affecting the primary purpose of the NFT contract.

## Likelihood Explanation

**Likelihood: Medium to High (increasing over time)**

**Attacker Capabilities Required:** 
None - this occurs naturally without malicious intent when legitimate users attempt to create NFT protocols.

**Attack Complexity:** 
Trivial - users simply call the public `Create()` method with valid inputs. No special setup, permissions, or manipulation required.

**Feasibility Conditions:**
- Triggers automatically when deterministic number generation produces a value already present in `State.IsCreatedMap`
- Initial collision probability is low with 9×10^8 possible 9-digit values
- Hash-to-number mapping is deterministic for each (sender address, block height) combination
- As more NFT protocols are created, `State.IsCreatedMap` grows and collision probability increases monotonically
- Eventually, certain sender addresses will consistently fail at specific block heights

**Probability Assessment:**
- **Initial phase:** Low probability when few protocols exist
- **Growth phase:** Probability increases linearly with number of created protocols
- **Saturation phase:** Certain address/block height combinations reach 100% failure rate
- **Persistence:** Once an address encounters a collision at one block height, retrying at that same height always fails due to deterministic behavior

## Recommendation

Regenerate the `randomHash` inside the do-while loop to ensure different values are tried on each iteration:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    long randomNumber;
    do
    {
        // Generate a NEW hash on each iteration
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(Context.Sender),
            HashHelper.ComputeFrom(randomBytes),
            HashHelper.ComputeFrom(Context.TransactionId) // Add transaction ID for uniqueness
        );
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

Alternatively, add an incrementing nonce to the hash generation to guarantee different values on each iteration.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Create an NFT protocol to populate `State.IsCreatedMap` with a specific number
2. Call `Create()` with a sender address and block height that deterministically maps to the same number
3. The transaction enters an infinite loop and exhausts all gas
4. The same sender at the same block height will always fail due to deterministic hash generation

A unit test would:
- Mock `State.IsCreatedMap` to return true for a specific number
- Mock the random number provider to return predictable bytes
- Call `Create()` and verify gas exhaustion occurs due to the infinite loop
- Demonstrate that the same inputs always produce the same collision

**Notes:**
This is a genuine code-level vulnerability with deterministic behavior. The infinite loop occurs because the collision-avoidance mechanism fails to regenerate the hash value inside the loop, violating the basic principle that collision resolution requires trying different values. The deterministic nature of `ConvertHashToInt64()` combined with fixed loop inputs guarantees the same output on every iteration, making escape from a collision impossible.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-27)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-178)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```
