# Audit Report

## Title
NFT Contract Memo Validation Bypass Enables Storage Bloat DoS Attack

## Summary
The NFT contract's `Transfer` and `TransferFrom` methods accept unbounded memo strings without validation, while the MultiToken and Economic contracts enforce a strict 64-byte limit. This defense-in-depth violation enables attackers to include arbitrarily large memos (up to transaction size limits) in NFT transfers, causing permanent blockchain storage bloat through event data accumulation that disproportionately burdens node operators.

## Finding Description

The AElf codebase establishes a 64-byte memo validation standard across token operations. The MultiToken contract defines `MemoMaxLength` as 64 bytes [1](#0-0)  and validates memo size using the `AssertValidMemo` helper method [2](#0-1) , which is invoked in the `DoTransfer` method before any transfer operation [3](#0-2) . The Economic contract similarly defines and enforces `MemoMaxLength` [4](#0-3)  with validation before token issuance [5](#0-4) .

However, the NFT contract completely bypasses this protection pattern. The `Transfer` method accepts a memo parameter from `TransferInput` [6](#0-5)  but directly fires the `Transferred` event without any validation [7](#0-6) . The `TransferFrom` method exhibits identical vulnerability [8](#0-7) . The NFT contract's internal `DoTransfer` method only validates amount and balance, omitting memo checks entirely [9](#0-8) . The NFT constants file contains no `MemoMaxLength` definition [10](#0-9) .

This inconsistency is confirmed by test coverage: MultiToken tests explicitly verify memo validation with "Invalid memo size" assertions [11](#0-10) , while NFT contract tests omit memo parameters entirely in transfer operations [12](#0-11) .

## Impact Explanation

Events fired via `Context.Fire` are permanently stored in `TransactionResult.Logs` and persisted to blockchain storage. An attacker can exploit the unbounded memo acceptance by repeatedly calling NFT `Transfer` or `TransferFrom` with large memos approaching the transaction size limit, causing:

1. **Permanent Storage Bloat**: Each transfer embeds the full memo in the `Transferred` event, consuming permanent blockchain storage. Unlike transient state, event data persists indefinitely across all archive nodes.

2. **Indexing Performance Degradation**: Event indexers must parse and process bloated event data, degrading query performance and real-time monitoring capabilities for all ecosystem participants.

3. **Asymmetric Cost Burden**: While attackers pay transaction fees proportional to data size, the permanent storage and indexing costs are distributed across all node operators who must maintain this data indefinitely. A single attacker's transaction fees may be significantly lower than the aggregate storage burden imposed on the network.

This is **Medium severity** because:
- Transaction fees provide economic deterrence but don't prevent funded attackers
- The attack violates defense-in-depth principles by bypassing validation present in analogous contracts
- Storage degradation is permanent and affects protocol operational efficiency
- Unlike fund theft, this is resource exhaustion rather than value extraction

## Likelihood Explanation

The attack is highly feasible:

**Entry Points**: Both `Transfer` and `TransferFrom` are public methods [13](#0-12)  callable by any NFT owner without special permissions.

**Preconditions**: Attackers only need to own NFTs through normal protocol usage (minting or purchase). No special authorization beyond token ownership is required.

**Execution**: The attack is straightforward - invoke `Transfer` with memo approaching transaction size limits. No complex state manipulation, timing windows, or multi-step sequences are required.

**Economic Feasibility**: While transaction fees scale with data size, motivated actors (e.g., competing protocols, disgruntled users, or actors seeking to demonstrate vulnerability) can systematically execute this attack. The per-transaction cost to the attacker may be outweighed by the aggregate burden on all nodes maintaining the bloated data permanently.

## Recommendation

Implement consistent memo validation in the NFT contract by:

1. Adding `MemoMaxLength` constant to `NFTContractConstants.cs`:
```csharp
public const int MemoMaxLength = 64;
```

2. Adding validation helper method to `NFTContract`:
```csharp
private void AssertValidMemo(string memo)
{
    Assert(memo == null || Encoding.UTF8.GetByteCount(memo) <= NFTContractConstants.MemoMaxLength,
        "Invalid memo size.");
}
```

3. Invoking validation in both `Transfer` and `TransferFrom` before firing events:
```csharp
public override Empty Transfer(TransferInput input)
{
    AssertValidMemo(input.Memo); // Add this line
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
    // ... rest of method
}
```

This aligns NFT contract behavior with MultiToken/Economic standards and restores defense-in-depth protection.

## Proof of Concept

```csharp
[Fact]
public async Task NFT_Transfer_UnboundedMemo_Test()
{
    // Setup: Create NFT protocol and mint token
    var symbol = await CreateTest();
    await AddMinterAsync(symbol);
    await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        Owner = MinterAddress,
        Quantity = 100
    });

    // Attack: Send transfer with extremely large memo (exceeds MultiToken's 64-byte limit)
    var largeMemo = new string('X', 10000); // 10KB memo, far exceeding 64-byte limit
    
    var result = await MinterNFTContractStub.Transfer.SendAsync(new TransferInput
    {
        To = User1Address,
        Symbol = symbol,
        TokenId = 1,
        Amount = 1,
        Memo = largeMemo // This should fail but doesn't
    });

    // Vulnerability demonstrated: Transaction succeeds with unbounded memo
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify event contains full bloated memo in permanent storage
    var transferredEvent = result.TransactionResult.Logs
        .First(l => l.Name == nameof(Transferred))
        .Indexed.First();
    transferredEvent.ShouldContain(largeMemo.Substring(0, 100)); // Partial check
    
    // Contrast with MultiToken which would reject this:
    // MultiToken.Transfer with same memo would fail with "Invalid memo size."
}
```

## Notes

This vulnerability represents a **defense-in-depth failure** rather than a critical protocol break. While transaction fees provide some economic protection, the permanent nature of blockchain storage and the asymmetric cost distribution (attacker pays once, all nodes store forever) make this a valid Medium severity finding. The inconsistency with MultiToken/Economic contracts indicates this is an oversight rather than intentional design, and aligning validation standards across all token operations strengthens protocol resilience.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L8-8)
```csharp
    public const int MemoMaxLength = 64;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L88-92)
```csharp
    private void AssertValidMemo(string memo)
    {
        Assert(memo == null || Encoding.UTF8.GetByteCount(memo) <= TokenContractConstants.MemoMaxLength,
            "Invalid memo size.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L99-114)
```csharp
    private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
    {
        Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
        Assert(from != to, "Can't do transfer to sender itself.");
        AssertValidMemo(memo);
        ModifyBalance(from, symbol, -amount);
        ModifyBalance(to, symbol, amount);
        Context.Fire(new Transferred
        {
            From = from,
            To = to,
            Symbol = symbol,
            Amount = amount,
            Memo = memo ?? string.Empty
        });
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L28-28)
```csharp
    public const int MemoMaxLength = 64;
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L262-265)
```csharp
    private void AssertValidMemo(string memo)
    {
        Assert(Encoding.UTF8.GetByteCount(memo) <= EconomicContractConstants.MemoMaxLength, "Invalid memo size.");
    }
```

**File:** protobuf/nft_contract.proto (L136-142)
```text
message TransferInput {
    aelf.Address to = 1;
    string symbol = 2;
    int64 token_id = 3;
    string memo = 4;
    int64 amount = 5;
}
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L21-35)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-55)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");

        if (amount == 0) return;

        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L57-80)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var operatorList = State.OperatorMap[input.Symbol][input.From];
        var isOperator = operatorList?.Value.Contains(Context.Sender) ?? false;
        if (!isOperator)
        {
            var allowance = State.AllowanceMap[tokenHash][input.From][Context.Sender];
            Assert(allowance >= input.Amount, "Not approved.");
            State.AllowanceMap[tokenHash][input.From][Context.Sender] = allowance.Sub(input.Amount);
        }

        DoTransfer(tokenHash, input.From, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = input.From,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L1-12)
```csharp
namespace AElf.Contracts.NFT;

public partial class NFTContract
{
    private const int NumberMinLength = 9;

    private const string NftTypeMetadataKey = "aelf_nft_type";
    private const string NftBaseUriMetadataKey = "aelf_nft_base_uri";
    private const string NftTokenIdReuseMetadataKey = "aelf_nft_token_id_reuse";
    private const string AssembledNftsKey = "aelf_assembled_nfts";
    private const string AssembledFtsKey = "aelf_assembled_fts";
}
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L439-468)
```csharp
    [Fact(DisplayName = "[MultiToken] Token transferFrom with different memo length.")]
    public async Task MultiTokenContract_TransferFrom_MemoLength_Test()
    {
        await MultiTokenContract_Approve_Test();
        var user1Stub =
            GetTester<TokenContractImplContainer.TokenContractImplStub>(TokenContractAddress, User1KeyPair);
        {
            var result = await user1Stub.TransferFrom.SendAsync(new TransferFromInput
            {
                Amount = 1000L,
                From = DefaultAddress,
                Memo = "MemoTest MemoTest MemoTest MemoTest MemoTest MemoTest MemoTest..",
                Symbol = AliceCoinTokenInfo.Symbol,
                To = User1Address
            });
            result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        }
        {
            var result = await user1Stub.TransferFrom.SendWithExceptionAsync(new TransferFromInput
            {
                Amount = 1000L,
                From = DefaultAddress,
                Memo = "MemoTest MemoTest MemoTest MemoTest MemoTest MemoTest MemoTest...",
                Symbol = AliceCoinTokenInfo.Symbol,
                To = User1Address
            });
            result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
            result.TransactionResult.Error.Contains("Invalid memo size.").ShouldBeTrue();
        }
    }
```

**File:** test/AElf.Contracts.NFT.Tests/NFTContractTests.cs (L151-161)
```csharp
    [Fact]
    public async Task<string> TransferTest()
    {
        var symbol = await MintMultiTokenTest();
        await MinterNFTContractStub.Transfer.SendAsync(new TransferInput
        {
            To = User1Address,
            Symbol = symbol,
            TokenId = 1,
            Amount = 10
        });
```
