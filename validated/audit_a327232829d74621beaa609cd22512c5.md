# Audit Report

## Title
TokenHolder RemoveBeneficiary Allows Profit Rights Revocation While Tokens Remain Locked

## Summary
The `RemoveBeneficiary` function in TokenHolderContract allows scheme managers to remove a user's beneficiary status and profit rights while their tokens remain locked in the MultiToken contract. This creates a state inconsistency where users lose profit distributions while their tokens remain inaccessible until the minimum lock period expires, violating the core invariant that locked tokens should entitle holders to profits.

## Finding Description

When a user calls `RegisterForProfits`, three atomic state changes occur: tokens are locked via the MultiToken contract, a lockId is stored in state, and the user is added as a beneficiary with shares equal to the locked amount. [1](#0-0) 

However, the `RemoveBeneficiary` function only reverses the beneficiary status by removing the user from the Profit contract. It performs no validation that the user has locked tokens, does not unlock those tokens, and does not remove the lockId from state. [2](#0-1) 

The state variables tracking locks (`LockIds` and `LockTimestamp`) are only cleared in the `Withdraw` function, not in `RemoveBeneficiary`. [3](#0-2) 

Users cannot directly unlock their tokens from the MultiToken contract because the virtual address for locking is computed using the TokenHolder contract's address as the sender, not the user's address. The authorization check requires either the sender to be in the lock whitelist or the origin to match the locked address, but the virtual address computation depends on the original sender. [4](#0-3) 

The user must call `Withdraw` to unlock tokens, which includes a minimum lock period check that prevents early withdrawal. [5](#0-4) 

The Profit contract's `RemoveBeneficiary` gracefully handles the case where a beneficiary doesn't exist by returning early, so the duplicate removal during `Withdraw` doesn't cause an error. [6](#0-5) 

## Impact Explanation

This vulnerability has critical impact on users and protocol integrity:

1. **Direct Financial Loss**: Users lose their share of profit distributions while tokens remain locked. If a scheme distributes profits during the lock period, the removed user receives 0% of their expected share, while other beneficiaries receive the user's portion.

2. **Forced Token Lockup**: Users cannot access their locked tokens until the minimum lock period expires, which is configurable per scheme and can be substantial.

3. **Protocol Invariant Violation**: The fundamental guarantee that locked tokens entitle holders to profits is broken. The `RegisterForProfits` function design implies an atomic relationship between locking tokens and receiving profit rights, but this can be unilaterally severed by the scheme manager.

4. **Quantified Example**: 
   - User locks 1,000 tokens (10% of total)
   - Manager removes user as beneficiary
   - Scheme distributes 10,000 tokens
   - User receives 0 instead of expected 1,000 tokens
   - Other beneficiaries receive the user's 1,000 tokens

## Likelihood Explanation

The likelihood of exploitation is HIGH due to:

1. **Low Complexity**: Requires only a single transaction calling `RemoveBeneficiary` with `amount = 0` to completely remove a user's profit rights.

2. **Economic Incentive**: Scheme managers have direct economic motivation to remove beneficiaries and increase their own profit share or that of preferred participants.

3. **Privileged but Realistic Threat**: While the attacker must be a scheme manager (set during `CreateScheme`), this represents a realistic threat model where managers become malicious, compromised, or make honest mistakes not realizing tokens remain locked.

4. **Detection Difficulty**: The operation appears legitimate since managers are expected to manage beneficiaries. There's no clear on-chain signal that this creates an inconsistent locked-without-profits state.

5. **Normal Preconditions**: Only requires that users have called `RegisterForProfits`, which is the intended normal operation of the TokenHolder contract.

## Recommendation

Add validation in `RemoveBeneficiary` to check if the beneficiary has locked tokens before allowing removal. The function should either:

1. **Prevent removal if tokens are locked**: Check `State.LockIds[Context.Sender][input.Beneficiary]` and revert if a lockId exists.

2. **Force unlock when removing**: If removal is necessary, automatically unlock the tokens and remove the lockId, similar to what `Withdraw` does.

Recommended fix approach:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    // Check if beneficiary has locked tokens
    var lockId = State.LockIds[Context.Sender][input.Beneficiary];
    Assert(lockId == null, "Cannot remove beneficiary with locked tokens. User must withdraw first.");
    
    // Existing logic continues...
    var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
    {
        Beneficiary = input.Beneficiary,
        SchemeId = scheme.SchemeId
    }).Details.Single();
    // ... rest of function
}
```

Alternatively, implement forced unlock during removal to maintain state consistency.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveBeneficiary_With_Locked_Tokens_Loses_Profits()
{
    // Setup: Create scheme with 10 minute lock period
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 10
    });
    
    // User registers and locks 1000 tokens
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = Starter,
        Amount = 1000
    });
    
    // Verify user is beneficiary with 1000 shares
    var scheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    var profitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = UserAddresses.First()
    });
    profitDetails.Details[0].Shares.ShouldBe(1000);
    
    // Manager removes beneficiary (VULNERABILITY)
    await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
    {
        Beneficiary = UserAddresses.First(),
        Amount = 0
    });
    
    // Verify user is NO LONGER beneficiary
    var detailsAfterRemoval = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = UserAddresses.First()
    });
    detailsAfterRemoval.Details.Count.ShouldBe(0); // No longer beneficiary
    
    // BUT tokens are still locked - verify by checking token balance
    var lockedBalance = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = UserAddresses.First(),
        Symbol = "ELF",
        LockId = /* lockId from state */
    });
    lockedBalance.Amount.ShouldBe(1000); // STILL LOCKED
    
    // Profit distribution happens - user gets NOTHING
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 10000
    });
    
    // User cannot claim profits because they're not a beneficiary anymore
    var claimResult = await TokenHolderContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeManager = Starter,
        Beneficiary = UserAddresses.First()
    });
    // This should fail or return 0 profits
    
    // User cannot withdraw until minimum lock period (10 minutes) expires
    // Tokens remain locked without profit rights until then
}
```

**Notes:**
- This vulnerability specifically affects users who register via `RegisterForProfits` (which locks tokens), not those added via `AddBeneficiary` (which doesn't lock tokens)
- The scheme manager role is set during `CreateScheme` and is a privileged but realistic threat model
- The minimum lock period is configurable per scheme and can trap users' tokens for extended periods

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-176)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-245)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L12-17)
```csharp
    /// <summary>
    ///     Contract address (Manager address) -> Beneficiary address -> Lock id.
    /// </summary>
    public MappedState<Address, Address, Hash> LockIds { get; set; }

    public MappedState<Hash, Timestamp> LockTimestamp { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L224-252)
```csharp
    public override Empty Unlock(UnlockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");

        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        Context.SendVirtualInline(fromVirtualAddress, Context.Self, nameof(Transfer), new TransferInput
        {
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        DealWithExternalInfoDuringUnlock(new TransferFromInput
        {
            From = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress),
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```
