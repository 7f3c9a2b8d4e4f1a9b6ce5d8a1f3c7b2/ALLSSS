# Audit Report

## Title
Incomplete Fee Coefficient Validation Allows Zero-Fee Configurations via Single-Value Arrays

## Summary
The `AssertCoefficientsValid()` function contains a critical validation flaw that allows coefficient arrays with only a single element (the upper bound) to pass validation, despite the intended requirement of "n >= 1" complete coefficient units. [1](#0-0)  This results in fee calculations returning zero for entire piece intervals, causing complete loss of protocol fee revenue and enabling unlimited free resource consumption.

## Finding Description

The vulnerability exists in the coefficient validation logic where the assertion check `Assert(count > 0 && (count - 1) % 3 == 0, ...)` allows count=1 to pass validation. [1](#0-0) 

**Mathematical Analysis:**
- For count=1: `(1-1) % 3 = 0 % 3 = 0` âœ“ **PASSES**
- The validation loop `for (var i = 1; i < count; i += 3)` never executes when count=1, as the condition `1 < 1` is false
- Result: No coefficient units are validated despite passing the assertion

**Fee Calculation Impact:**
When such malformed coefficients reach the fee calculation function, `GetExponentialFunc()` returns zero because the calculation loop condition `while (currentIndex < parameters.Length)` where `currentIndex=1` and `parameters.Length=1` is false, so the loop never executes and returns `cost=0`. [2](#0-1) 

**Entry Points:**
The vulnerability is reachable through governance-controlled functions:
- `UpdateCoefficientsForContract()` for resource fees (READ, STORAGE, WRITE, TRAFFIC) [3](#0-2) 
- `UpdateCoefficientsForSender()` for transaction size fees [4](#0-3) 

Both require governance authority checks through DeveloperFeeController and UserFeeController respectively. [5](#0-4) 

## Impact Explanation

**Direct Fund Impact:**
- Complete loss of protocol fee revenue for affected piece intervals
- If applied to commonly-used ranges (e.g., transactions with size 0-1,000,000 bytes), ALL transaction fees in that range become zero
- Resource tokens (READ, STORAGE, WRITE, TRAFFIC) could be consumed for free

**Operational Impact:**
- Protocol-wide DoS vulnerability: users can perform unlimited free transactions/operations in affected ranges
- Economic security model breaks down when fees become zero
- No rate limiting for free operations enables spam attacks

**Affected Parties:**
- Protocol treasury loses all fee income from affected intervals
- Validators/miners lose transaction fee rewards
- Network becomes vulnerable to spam/DoS attacks without economic deterrent

**Severity:** HIGH - While requiring governance approval, the validation explicitly claims to enforce "n >= 1" in its comment but fails to implement this correctly, meaning governance could unknowingly approve such configurations thinking they are valid.

## Likelihood Explanation

**Required Capabilities:**
- Must control or influence governance (DeveloperFeeController for resource fees, UserFeeController for transaction fees)
- Both require multi-layer governance approval through Association/Parliament/Referendum contracts

**Attack Complexity:**
- MODERATE: Requires crafting governance proposal with payload: `CalculateFeePieceCoefficients { Value = { 1000000 } }` (only upper bound)
- The validation appears correct superficially (comment states "n >= 1") but the implementation is flawed
- Mathematical constraint is subtle: count=1 satisfies the modulo check `(count - 1) % 3 == 0` but violates the semantic intent

**Feasibility Conditions:**
- **Malicious Governance:** Attackers with governance control could intentionally set zero-fee configurations
- **Honest Mistake:** More likely - governance members could unknowingly approve such proposals because:
  - Validation passes without error
  - No test coverage for count=1 edge case exists in the test suite [6](#0-5) 
  - The mathematical constraint is non-obvious

**Probability:** MEDIUM-HIGH - The subtle nature of the bug and absence of test coverage significantly increases likelihood of accidental approval.

## Recommendation

Fix the validation to enforce the minimum coefficient count requirement:

```csharp
private void AssertCoefficientsValid(CalculateFeePieceCoefficients coefficients)
{
    // Assert the count should be (3n + 1), n >= 1.
    var count = coefficients.Value.Count;
    // Enforce minimum count of 4: upper bound + at least one complete triplet
    Assert(count >= 4 && (count - 1) % 3 == 0, "Coefficients count should be (3n + 1), n >= 1.");

    // Assert every unit. one [(B / C) * x ^ A] means one unit.
    for (var i = 1; i < count; i += 3)
    {
        var power = coefficients.Value[i];
        var divisor = coefficients.Value[i + 1];
        var dividend = coefficients.Value[i + 2];
        Assert(power >= 0 && divisor >= 0 && dividend > 0, "Invalid coefficient.");
    }
}
```

Additionally, add comprehensive test coverage for edge cases including count=1, count=2, count=3 to ensure validation catches all malformed inputs.

## Proof of Concept

```csharp
[Fact]
public async Task UpdateCoefficients_WithSingleValueArray_ShouldProduceZeroFees()
{
    // Initialize governance controllers
    await TokenContractStub.InitializeAuthorizedController.SendAsync(new Empty());
    
    // Create malformed coefficient with only upper bound (count=1)
    var malformedCoefficient = new CalculateFeePieceCoefficients
    {
        Value = { 1000000 } // Only upper bound, no polynomial terms
    };
    
    // Create update input for piece 1 of READ resource fees
    var updateInput = new UpdateCoefficientsInput
    {
        PieceNumbers = { 1 }, // Update first piece
        Coefficients = new CalculateFeeCoefficients
        {
            FeeTokenType = (int)FeeTypeEnum.Read,
            PieceCoefficientsList = { malformedCoefficient }
        }
    };
    
    // Submit through governance (this SHOULD fail but currently PASSES)
    var proposalId = await CreateToRootForDeveloperFeeByTwoLayerAsync(
        updateInput,
        nameof(TokenContractImplContainer.TokenContractImplStub.UpdateCoefficientsForContract)
    );
    
    await ApproveToRootForDeveloperFeeByTwoLayerAsync(proposalId);
    var middleApproveProposalId = await ApproveToRootForDeveloperFeeByMiddleLayerAsync(proposalId);
    await ApproveThenReleaseMiddleProposalForDeveloperAsync(middleApproveProposalId);
    await ReleaseToRootForDeveloperFeeByTwoLayerAsync(proposalId);
    
    // Verify malformed coefficient was accepted
    var updatedCoefficients = await GetCalculateFeeCoefficientsByFeeTypeAsync((int)FeeTypeEnum.Read);
    var firstPiece = updatedCoefficients.PieceCoefficientsList[0];
    firstPiece.Value.Count.ShouldBe(1); // Only upper bound present
    
    // Demonstrate fee calculation returns ZERO
    var feeFunction = updatedCoefficients.ToCalculateFunction();
    var calculatedFee = feeFunction.CalculateFee(500); // Any transaction count in range
    calculatedFee.ShouldBe(0); // CRITICAL: Fee is ZERO instead of expected value
}
```

**Notes:**
- This vulnerability requires governance control but represents a critical validation failure that breaks the fundamental economic security model of the protocol
- The comment explicitly states "n >= 1" but the implementation allows n=0 (count=1)
- No existing tests validate the count=1 edge case, indicating this was an oversight rather than intentional design
- The fix is straightforward: change `count > 0` to `count >= 4` in the validation assertion

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L16-23)
```csharp
    public override Empty UpdateCoefficientsForContract(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        Assert(input.Coefficients.FeeTokenType != (int)FeeTypeEnum.Tx, "Invalid fee type.");
        AssertDeveloperFeeController();
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L25-32)
```csharp
    public override Empty UpdateCoefficientsForSender(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        AssertUserFeeController();
        input.Coefficients.FeeTokenType = (int)FeeTypeEnum.Tx; // The only possible for now.
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L74-88)
```csharp
    private void AssertCoefficientsValid(CalculateFeePieceCoefficients coefficients)
    {
        // Assert the count should be (3n + 1), n >= 1.
        var count = coefficients.Value.Count;
        Assert(count > 0 && (count - 1) % 3 == 0, "Coefficients count should be (3n + 1), n >= 1.");

        // Assert every unit. one [(B / C) * x ^ A] means one unit.
        for (var i = 1; i < count; i += 3)
        {
            var power = coefficients.Value[i];
            var divisor = coefficients.Value[i + 1];
            var dividend = coefficients.Value[i + 2];
            Assert(power >= 0 && divisor >= 0 && dividend > 0, "Invalid coefficient.");
        }
    }
```

**File:** src/AElf.Kernel.FeeCalculation/Extensions/CalculateFeeCoefficientsExtensions.cs (L30-45)
```csharp
    private static long GetExponentialFunc(int count, params int[] parameters)
    {
        long cost = 0;

        // Skip parameters[0] which is meant to be piece upper bound.
        var currentIndex = 1;
        while (currentIndex < parameters.Length)
        {
            cost += GetUnitExponentialCalculation(count, parameters[currentIndex],
                parameters[currentIndex + 1],
                parameters[currentIndex + 2]);
            currentIndex += 3;
        }

        return cost;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L383-397)
```csharp
    private void AssertDeveloperFeeController()
    {
        Assert(State.DeveloperFeeController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");

        Assert(Context.Sender == State.DeveloperFeeController.Value.RootController.OwnerAddress, "no permission");
    }

    private void AssertUserFeeController()
    {
        Assert(State.UserFeeController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");
        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == State.UserFeeController.Value.RootController.OwnerAddress, "no permission");
    }
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/MultiTokenContractReferenceFeeTest.cs (L160-213)
```csharp
    [InlineData(false, 3, new[] { 1 }, new[] { 1000000, 4, 3, 2 })]
    [InlineData(false, 0, new[] { 2 }, new[] { 999999, 1, 4, 2, 5, 250, 40 })]
    [InlineData(false, 0, new[] { 3 }, new[] { int.MaxValue, 2, 8, 2, 6, 300, 50 })]
    [InlineData(false, 2, new[] { 2, 3 }, new[] { 100, 1, 4, 10000 }, new[] { 1000000, 1, 4, 2, 2, 250, 50 })]
    [InlineData(true, 0, new[] { 2 }, new[] { int.MaxValue, 4, 3, 2 })]
    [InlineData(true, 0, new[] { 3 }, new[] { int.MaxValue, 2, 8, 2, 6, 300 })]
    [InlineData(true, 0, new[] { 3, 2 }, new[] { 1000, 4, 3, 2 }, new[] { int.MaxValue, 4, 3, 2 })]
    [InlineData(true, 0, new[] { 2, 3 }, new[] { 100, 4, 3, 2 })]
    [InlineData(true, 3, new[] { 1 }, new[] { 1000000, -1, 3, 2 })]
    [InlineData(true, 3, new[] { 1 }, new[] { 1000000, 4, -1, 2 })]
    [InlineData(true, 3, new[] { 1 }, new[] { 1000000, 4, 3, 0 })]
    public async Task Update_Coefficient_For_Contract_Test(bool isFail, int feeType, int[] pieceNumber,
        params int[][] newPieceFunctions)
    {
        var originalCoefficients = await GetCalculateFeeCoefficientsByFeeTypeAsync(feeType);
        var newPieceCoefficientList = newPieceFunctions.Select(x => new CalculateFeePieceCoefficients
        {
            Value = { x }
        }).ToList();
        var updateInput = new UpdateCoefficientsInput
        {
            PieceNumbers = { pieceNumber },
            Coefficients = new CalculateFeeCoefficients
            {
                FeeTokenType = feeType
            }
        };
        updateInput.Coefficients.PieceCoefficientsList.AddRange(newPieceCoefficientList);
        var proposalId = await CreateToRootForDeveloperFeeByTwoLayerAsync(updateInput,
            nameof(TokenContractImplContainer.TokenContractImplStub.UpdateCoefficientsForContract));
        await ApproveToRootForDeveloperFeeByTwoLayerAsync(proposalId);
        var middleApproveProposalId = await ApproveToRootForDeveloperFeeByMiddleLayerAsync(proposalId);
        await ApproveThenReleaseMiddleProposalForDeveloperAsync(middleApproveProposalId);
        await ReleaseToRootForDeveloperFeeByTwoLayerAsync(proposalId);
        var updatedCoefficients = await GetCalculateFeeCoefficientsByFeeTypeAsync(feeType);
        if (!isFail)
        {
            foreach (var newPieceFunction in newPieceFunctions)
            {
                var hasModified =
                    GetCalculateFeePieceCoefficients(updatedCoefficients.PieceCoefficientsList, newPieceFunction[0]);
                var newCoefficient = newPieceFunction.Skip(1).ToArray();
                hasModified.Value.Skip(1).ShouldBe(newCoefficient);
            }
        }
        else
        {
            var pieceCount = originalCoefficients.PieceCoefficientsList.Count;
            updatedCoefficients.PieceCoefficientsList.Count.ShouldBe(pieceCount);
            for (var i = 0; i < pieceCount; i++)
                originalCoefficients.PieceCoefficientsList[i]
                    .ShouldBe(updatedCoefficients.PieceCoefficientsList[i]);
        }
    }
```
