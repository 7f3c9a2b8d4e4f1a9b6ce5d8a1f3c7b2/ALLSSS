# Audit Report

## Title
Hex Case Mismatch in Pubkey Replacement Causes Miner Denial of Service

## Summary
A case-sensitivity mismatch in the pubkey replacement flow prevents miners from producing blocks. The `RecordCandidateReplacement` method stores pubkey strings without case normalization, while `GetConsensusCommand` converts input bytes to lowercase hex before dictionary lookup, causing key mismatches when uppercase or mixed-case pubkeys are used during replacement.

## Finding Description

The vulnerability exists in the consensus contract's pubkey replacement mechanism where inconsistent hex case handling causes miner lookup failures.

**Root Cause**: The `RecordCandidateReplacement` method directly adds the new pubkey string to `RealTimeMinersInformation` dictionary without normalizing its hex case. [1](#0-0) 

**Entry Point**: Candidate admins call `ReplaceCandidatePubkey` in the Election contract, which forwards the raw input strings to the consensus contract without case normalization. [2](#0-1) 

**Failure Point**: When a miner requests consensus commands, the system converts their pubkey bytes to lowercase hex using `ToHex()`. [3](#0-2)  It then performs a case-sensitive dictionary lookup via `IsInMinerList()`. [4](#0-3)  The `IsInMinerList` method uses case-sensitive string comparison. [5](#0-4) 

**Hex Conversion Behavior**: The `ToHex()` method produces lowercase hex characters by adding 0x20 to uppercase character codes. [6](#0-5) 

**Initial Miner List**: All initial miners are normalized to lowercase when their pubkeys are converted via `ToHex()` during first round generation. [7](#0-6) 

**Lack of Validation**: The `ByteArrayHelper.HexStringToByteArray()` method accepts both uppercase and lowercase hex strings using `Convert.ToByte` with base 16, which is case-insensitive. [8](#0-7)  However, no validation enforces lowercase format before storage in the consensus contract.

## Impact Explanation

**Direct Harm:**
- The affected miner cannot retrieve valid consensus commands, returning `InvalidConsensusCommand` instead, which prevents block production
- Network consensus capacity is reduced by one miner per affected replacement
- The miner loses potential block rewards during the outage period
- If multiple miners are affected, network liveness and block production speed could be significantly degraded

**Affected Parties:**
- The miner whose pubkey was replaced with incorrect hex case cannot participate in consensus
- The blockchain network experiences reduced consensus participation and potentially degraded performance
- Token holders may experience slower transaction confirmations if multiple miners are affected

**Severity Assessment (Medium):**
- No direct fund theft or permanent token loss occurs
- Causes operational disruption to the consensus mechanism
- Can be remediated by calling `ReplaceCandidatePubkey` again with correct lowercase format
- Requires privileged admin action to trigger, limiting likelihood
- Impact severity scales with the number of simultaneously affected miners

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a candidate admin authorized to call `ReplaceCandidatePubkey`
- Must provide new pubkey in non-lowercase format (uppercase or mixed case)
- No special technical knowledge required beyond basic hex string manipulation

**Attack Complexity:**
- Low complexity: single transaction with uppercase hex string
- No timing requirements or race conditions needed
- Deterministic outcome - always causes miner DoS when case mismatches

**Feasibility Conditions:**
- All test cases use `.ToHex()` producing lowercase, establishing convention but not enforcement [9](#0-8) 
- No contract-level validation enforces lowercase format
- Manual API calls or custom UI inputs could provide uppercase strings
- The validation logic accepts any valid hex string regardless of case

**Probability Assessment:**
- Moderate probability: requires deviation from established patterns but no validation prevents it
- More likely to be accidental (admin copy-paste error from external source) than intentional
- Detection occurs immediately when the affected miner fails to produce blocks
- Recovery requires another admin transaction to correct the replacement

## Recommendation

Normalize all pubkey strings to lowercase before storing them in the consensus contract. In `RecordCandidateReplacement`, convert the input pubkey to lowercase:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    // ... existing validation ...
    
    var normalizedNewPubkey = input.NewPubkey.ToLower(); // Add normalization
    
    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
    realTimeMinerInformation.Pubkey = normalizedNewPubkey;
    currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
    currentRound.RealTimeMinersInformation.Add(normalizedNewPubkey, realTimeMinerInformation);
    // ... rest of method ...
}
```

Alternatively, add validation in `ReplaceCandidatePubkey` to reject non-lowercase inputs or automatically normalize them before forwarding to the consensus contract.

## Proof of Concept

```csharp
[Fact]
public async Task HexCaseMismatch_CausesMinerDoS_Test()
{
    // Setup: Create a miner and make them part of active consensus
    var minerKeyPair = ValidationDataCenterKeyPairs.First();
    var candidateAdmin = ValidationDataCenterKeyPairs.Last();
    var candidateAdminAddress = Address.FromPublicKey(candidateAdmin.PublicKey);
    
    await AnnounceElectionAsync(minerKeyPair, candidateAdminAddress);
    // ... additional setup to make miner active in current round ...
    
    // Attack: Admin replaces pubkey with UPPERCASE hex
    var newKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
    var uppercaseNewPubkey = newKeyPair.PublicKey.ToHex().ToUpper(); // Use uppercase
    
    var adminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, candidateAdmin);
    await adminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = minerKeyPair.PublicKey.ToHex(),
        NewPubkey = uppercaseNewPubkey // Uppercase hex
    });
    
    // Verify: Miner cannot get consensus commands
    var consensusStub = GetTester<AEDPoSContractImplContainer.AEDPoSContractImplStub>(
        ConsensusContractAddress, newKeyPair);
    var consensusCommand = await consensusStub.GetConsensusCommand.CallAsync(
        new BytesValue { Value = ByteString.CopyFrom(newKeyPair.PublicKey) });
    
    // Assert: Returns InvalidConsensusCommand due to case mismatch
    consensusCommand.Hint.ShouldBe(ByteString.Empty); // InvalidConsensusCommand has empty hint
    consensusCommand.ArrangedMiningTime.ShouldBeNull();
}
```

## Notes

This vulnerability demonstrates a critical inconsistency between input validation (case-insensitive hex parsing) and storage/retrieval operations (case-sensitive string comparison). While the probability is moderate due to the requirement for admin privileges, the impact on consensus availability is significant. The issue is particularly concerning because standard tooling uses lowercase hex via `ToHex()`, creating a false sense of security while leaving the attack surface open to manual inputs or external integrations that might use uppercase hex conventions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L142-143)
```csharp
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L19-19)
```csharp
        _processingBlockMinerPubkey = input.Value.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L38-41)
```csharp
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L16-19)
```csharp
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L15-16)
```csharp
            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ReplaceCandidateTests.cs (L40-41)
```csharp
            OldPubkey = announceElectionKeyPair.PublicKey.ToHex(),
            NewPubkey = newKeyPair.PublicKey.ToHex()
```
