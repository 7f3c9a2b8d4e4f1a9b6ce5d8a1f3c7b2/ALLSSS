# Audit Report

## Title
Period Desynchronization Causes DoS in RegisterForProfits Auto-Distribution

## Summary
The TokenHolderContract maintains a local period counter that becomes desynchronized from the authoritative ProfitContract when scheme managers distribute profits directly. This causes RegisterForProfits calls with auto-distribution to fail with "Invalid period" assertion errors, creating a denial-of-service condition for new user registrations.

## Finding Description

The TokenHolderContract caches a local period counter in `scheme.Period` that must match the ProfitContract's `CurrentPeriod` for distributions to succeed. However, period synchronization logic is inconsistent across code paths, creating a desynchronization vulnerability.

**Critical Code Paths:**

When `RegisterForProfits` is called with auto-distribution enabled, it invokes `GetValidScheme` with the default parameter `updateSchemePeriod = false`: [1](#0-0) 

The `UpdateTokenHolderProfitScheme` method returns early when `updateSchemePeriod = false` and `scheme.SchemeId != null`, completely bypassing period synchronization: [2](#0-1) 

RegisterForProfits then uses this potentially stale local period for auto-distribution: [3](#0-2) 

In contrast, manual `DistributeProfits` calls force synchronization by passing `updateSchemePeriod = true`: [4](#0-3) 

**Authorization Vulnerability:**

The ProfitContract explicitly authorizes BOTH the scheme manager AND the TokenHolderContract to call DistributeProfits: [5](#0-4) 

When the scheme manager calls `ProfitContract.DistributeProfits` directly (bypassing TokenHolder), the ProfitContract increments its authoritative `CurrentPeriod`: [6](#0-5) 

But TokenHolderContract's local `scheme.Period` remains unchanged, causing desynchronization.

**Strict Period Validation:**

The ProfitContract strictly validates that the input period matches its current period: [7](#0-6) 

When desynchronized, RegisterForProfits attempts auto-distribution with a stale period, triggering this assertion failure and reverting the entire transaction.

## Impact Explanation

**Severity: HIGH**

This vulnerability causes complete denial-of-service for the RegisterForProfits function when auto-distribution is enabled:

1. **User Impact**: All new users attempting to register for profits are unable to complete their registration when the threshold triggers auto-distribution
2. **Permanence**: The scheme remains broken until manual intervention (calling TokenHolder.DistributeProfits) resyncs the period
3. **Scope**: Affects all schemes configured with `AutoDistributeThreshold`, which is a documented, intended feature
4. **Availability**: Core user-facing functionality becomes completely unavailable

The error message returned to users would be: "Invalid period. When release scheme {schemeId} of period {stalePeriod}. Current period is {actualPeriod}"

This is not a fund loss vulnerability, but it breaks a critical protocol invariant: users must be able to register for profit schemes without interference from scheme manager actions.

## Likelihood Explanation

**Likelihood: HIGH**

1. **No privilege escalation required**: The scheme manager has legitimate authorization to call ProfitContract.DistributeProfits directly as shown in the authorization check
2. **Simple trigger**: The manager simply calls `ProfitContract.DistributeProfits` instead of `TokenHolderContract.DistributeProfits`
3. **Accidental occurrence**: The dual authorization pattern suggests direct calls are an intended use case, making accidental desynchronization likely during normal operations
4. **No warnings**: There is no documentation or technical restriction preventing direct ProfitContract calls

The vulnerability requires:
- Scheme created with `AutoDistributeThreshold` set (common configuration)
- Manager calls ProfitContract directly at least once
- User attempts RegisterForProfits, triggering auto-distribution

All preconditions are realistic and achievable through normal protocol operations.

## Recommendation

Modify the `RegisterForProfits` method to always synchronize the period before checking auto-distribution thresholds. Change line 152 from:
```csharp
var scheme = GetValidScheme(input.SchemeManager);
```
to:
```csharp
var scheme = GetValidScheme(input.SchemeManager, true);
```

This ensures that TokenHolderContract always reads the latest `CurrentPeriod` from ProfitContract before attempting auto-distribution, preventing desynchronization.

Alternatively, modify `UpdateTokenHolderProfitScheme` to always synchronize when the period will be used for distribution operations, or remove the dual authorization pattern to prevent direct ProfitContract calls by scheme managers.

## Proof of Concept

```csharp
[Fact]
public async Task PeriodDesynchronization_DoS_Test()
{
    // Setup: Create scheme with auto-distribution threshold
    var amount = 1000L;
    var nativeTokenSymbol = TokenHolderContractTestConstants.NativeTokenSymbol;
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = nativeTokenSymbol,
        AutoDistributeThreshold = { { nativeTokenSymbol, amount } }
    });
    
    // Contribute profits to meet threshold
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Amount = amount,
        Symbol = nativeTokenSymbol
    });
    
    // Get scheme ID for direct ProfitContract call
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
    {
        Manager = Starter
    });
    var schemeId = schemeIds.SchemeIds.First();
    
    // Trigger desynchronization: Manager calls ProfitContract.DistributeProfits directly
    await ProfitContractStub.DistributeProfits.SendAsync(new Profit.DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { { nativeTokenSymbol, 0L } }
    });
    
    // Verify desynchronization
    var profitScheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    var tokenHolderScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    profitScheme.CurrentPeriod.ShouldBe(2);  // ProfitContract incremented
    tokenHolderScheme.Period.ShouldBe(1);     // TokenHolder still at 1 (desynchronized!)
    
    // Contribute more profits to trigger auto-distribution on RegisterForProfits
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Amount = amount,
        Symbol = nativeTokenSymbol
    });
    
    // DoS: RegisterForProfits will fail with "Invalid period" error
    var result = await TokenHolderContractStub.RegisterForProfits.SendWithExceptionAsync(
        new RegisterForProfitsInput
        {
            Amount = amount,
            SchemeManager = Starter
        });
    
    // Verify the assertion failure
    result.TransactionResult.Error.ShouldContain("Invalid period");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L133-133)
```csharp
        var scheme = GetValidScheme(input.SchemeManager, true);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L152-152)
```csharp
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L193-197)
```csharp
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L289-289)
```csharp
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L426-428)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L478-480)
```csharp
        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```
