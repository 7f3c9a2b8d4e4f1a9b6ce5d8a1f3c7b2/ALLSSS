# Audit Report

## Title
Invalid FinalOrderOfNextRound Values Enable Consensus Disruption Through Malicious Order Assignment

## Summary
Active miners can inject arbitrary `FinalOrderOfNextRound` values (including 0, duplicates, or values exceeding `minersCount`) via the `UpdateValue` method without validation. These values are used directly in next round generation, enabling consensus crashes through missing expected mining orders or creating invalid consensus states that exclude legitimate miners.

## Finding Description

### Root Cause - Unvalidated Order Assignment

The `ProcessUpdateValue` method applies `TuneOrderInformation` values from user input directly to `FinalOrderOfNextRound` without any bounds checking or duplicate validation: [1](#0-0) 

The protobuf definition allows arbitrary `int32` values in the `tune_order_information` map: [2](#0-1) 

### Vulnerable Code Path

The `UpdateValue` method is publicly accessible, allowing any miner to call it with custom input: [3](#0-2) 

The only permission check verifies the sender is in the miner list, but does not validate the `TuneOrderInformation` contents: [4](#0-3) 

When `GenerateNextRoundInformation()` processes the next round, it uses these unvalidated `FinalOrderOfNextRound` values to assign mining orders: [5](#0-4) 

The `occupiedOrders` calculation collects whatever `FinalOrderOfNextRound` values exist, including invalid ones: [6](#0-5) 

### Why Existing Protections Fail

The `NextRoundMiningOrderValidationProvider` only checks that the count of miners with `FinalOrderOfNextRound > 0` matches the count of miners who mined, using `Distinct()` on `MinerInRound` objects (not on order values): [7](#0-6) 

This validation operates on distinct `MinerInRound` objects (compared by reference or all fields), which means two miners with the same `FinalOrderOfNextRound` but different pubkeys are counted as distinct. This fails to detect duplicate order values or out-of-range values.

Additionally, this validator only runs for `NextRound` behavior validation, not during `UpdateValue`: [8](#0-7) 

The `UpdateValueValidationProvider` only validates cryptographic fields but does not check `TuneOrderInformation`: [9](#0-8) 

### Downstream Crash Points

The `BreakContinuousMining` function is called during round generation and expects specific orders to exist: [10](#0-9) 

It uses `.First()` which throws `InvalidOperationException` if orders 1, 2, or `minersCount-1` are missing: [11](#0-10) [12](#0-11) [13](#0-12) 

## Impact Explanation

**High Severity - Consensus Integrity Violation**

1. **Consensus Execution Crashes**: By setting `FinalOrderOfNextRound` values such that the generated next round lacks required orders (e.g., no miner has order 1, 2, or `minersCount-1`), an attacker causes `BreakContinuousMining` to throw `InvalidOperationException`, crashing consensus execution and halting block production.

2. **Duplicate Orders**: Multiple miners assigned the same order compete for the same time slot, causing conflicting block production schedules and consensus ambiguity.

3. **Invalid Order Values**: 
   - Order = 0 creates a miner scheduled to mine at the current block timestamp (in the past), bypassing time-slot validation
   - Order > `minersCount` creates out-of-range orders that break schedule integrity

4. **Miner Exclusion**: When miners with duplicate `FinalOrderOfNextRound` values are processed in the generation loop, they overwrite each other in the dictionary-based assignment, causing legitimate miners who successfully mined to be excluded from the next round.

**Affected Components**:
- All miners attempting to participate in consensus
- Block production scheduling and time-slot validation  
- Round transition logic and irreversible block height calculation
- Cross-chain verification that depends on valid consensus state

## Likelihood Explanation

**High Probability - Easily Executable by Any Active Miner**

**Attack Complexity:** LOW

1. Malicious miner constructs `UpdateValueInput` with crafted `TuneOrderInformation` containing invalid values (e.g., all miners set to order 0, or duplicate orders, or orders > minersCount)
2. Calls `UpdateValue` during their mining slot
3. Values are stored immediately without validation
4. Next round generation uses these invalid values
5. Consensus crashes when `BreakContinuousMining` executes `.First()` on missing orders, or enters invalid state with duplicate/out-of-range orders

**Feasibility Conditions:**
- Attacker must be an elected miner (already in consensus participation)
- Single transaction execution required
- No special timing or state requirements beyond being in the miner list
- Economically rational for miners to attack competitors or disrupt consensus

## Recommendation

Add validation in `ProcessUpdateValue` to ensure all `TuneOrderInformation` values are within valid bounds and unique:

```csharp
// Validate TuneOrderInformation before applying
var minersCount = currentRound.RealTimeMinersInformation.Count;
var tuneOrders = updateValueInput.TuneOrderInformation.Values.ToList();

// Check all orders are in valid range [1, minersCount]
Assert(tuneOrders.All(order => order > 0 && order <= minersCount), 
    "Invalid order values in TuneOrderInformation");

// Check for duplicate order values
Assert(tuneOrders.Count == tuneOrders.Distinct().Count(), 
    "Duplicate order values in TuneOrderInformation");

// Check that tuned orders match miners who actually mined
var tunedMiners = updateValueInput.TuneOrderInformation.Keys.ToList();
Assert(tunedMiners.All(pubkey => 
    currentRound.RealTimeMinersInformation.ContainsKey(pubkey) && 
    currentRound.RealTimeMinersInformation[pubkey].OutValue != null),
    "TuneOrderInformation contains invalid miner pubkeys");

foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

Additionally, enhance `NextRoundMiningOrderValidationProvider` to validate order values themselves, not just object distinctness.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousOrderAssignment_CausesConsensusCrash()
{
    // Setup: Initialize consensus with 5 miners
    var miners = await InitializeMinerListAsync(5);
    var maliciousMiner = miners[0];
    
    // Attacker constructs UpdateValueInput with all miners assigned to invalid order 0
    var maliciousInput = new UpdateValueInput
    {
        // ... valid signature, outValue, etc ...
        TuneOrderInformation =
        {
            { miners[0], 0 },  // Invalid: order 0
            { miners[1], 0 },  // Duplicate: also 0
            { miners[2], 100 }, // Invalid: exceeds minersCount
            { miners[3], 1 },
            { miners[4], 1 }   // Duplicate: same as miners[3]
        }
    };
    
    // Execute: Malicious miner calls UpdateValue
    await maliciousMiner.UpdateValueAsync(maliciousInput);
    
    // Trigger: Next round generation attempts to process invalid orders
    var exception = await Assert.ThrowsAsync<InvalidOperationException>(
        async () => await AnyMiner.NextRoundAsync()
    );
    
    // Verify: Consensus crashes due to missing required orders
    Assert.Contains("Sequence contains no matching element", exception.Message);
    
    // Result: Block production halted, consensus disrupted
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** protobuf/aedpos_contract.proto (L208-208)
```text
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L67-68)
```csharp
        BreakContinuousMining(ref nextRound);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-80)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L83-84)
```csharp
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L100-101)
```csharp
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-88)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```
