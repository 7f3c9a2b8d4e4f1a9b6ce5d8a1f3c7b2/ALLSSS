# Audit Report

## Title
Consensus Halt Attack via Empty Miner List in NextRound Validation

## Summary
The AEDPoS consensus contract fails to validate that round transitions must contain at least one miner. A malicious miner can craft a `NextRound` transaction with an empty `RealTimeMinersInformation` map, which passes all validation checks due to incorrect logic handling empty collections. Once stored, the empty round permanently halts consensus as no miner can subsequently obtain valid consensus commands.

## Finding Description

The vulnerability exists in the round termination validation logic within `RoundTerminateValidationProvider`. When `RealTimeMinersInformation` is an empty collection, the validation logic incorrectly returns success: [1](#0-0) 

The expression `extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)` evaluates to `false` when the collection is empty (no elements to check). The ternary operator then returns `new ValidationResult { Success = true }`, incorrectly validating an empty miner list.

The validation orchestration for `NextRound` behavior adds multiple validators: [2](#0-1) 

However, none prevent empty miner lists:

**MiningPermissionValidationProvider** only checks if the sender exists in the BaseRound (current round), not the proposed next round: [3](#0-2) 

**NextRoundMiningOrderValidationProvider** compares counts that both equal zero when the list is empty: [4](#0-3) 

When both `distinctCount` and `Count(m => m.OutValue != null)` equal zero (empty list), the check `0 != 0` evaluates to false and validation passes.

After passing validation, the `ProcessNextRound` method unconditionally stores the empty round: [5](#0-4) 

The `AddRoundInformation` method stores the round without any validation of non-empty miners: [6](#0-5) 

Once stored, all miners are permanently locked out. When any miner requests a consensus command via the public ACS4 interface, the system checks miner list membership: [7](#0-6) 

The `IsInMinerList` method checks if the pubkey exists in `RealTimeMinersInformation.Keys`: [8](#0-7) 

With an empty `RealTimeMinersInformation`, this returns `false` for ALL miners, causing `GetConsensusCommand` to return `InvalidConsensusCommand` for everyone, permanently halting block production.

## Impact Explanation

**CRITICAL**: This vulnerability causes complete and irreversible consensus failure, breaking the fundamental blockchain availability guarantee. After execution:

- **No blocks can be produced**: All miners receive `InvalidConsensusCommand` and cannot mine
- **Transaction processing halts**: No new transactions can be included or executed
- **Chain permanently frozen**: The empty round becomes the current state with no mechanism to recover within protocol rules
- **Hard fork required**: Recovery necessitates out-of-band coordination and chain restart
- **Economic disruption**: All pending transactions stuck, DeFi operations cease, token transfers impossible

This violates the core consensus invariant that valid rounds must contain at least one miner capable of producing blocks.

## Likelihood Explanation

**MEDIUM-HIGH**: The attack is straightforward to execute with minimal preconditions:

**Attacker Capabilities**: Any current miner who reaches their block production opportunity can execute this attack by proposing a malicious `NextRound` transition.

**Attack Complexity**: LOW
- Attacker crafts a `NextRoundInput` with empty `RealTimeMinersInformation` map via the `ToRound()` conversion method: [9](#0-8) 

- No cryptographic manipulation or complex exploit chaining required
- Single transaction execution via the public `NextRound` method: [10](#0-9) 

**Preconditions**:
- Attacker must be a legitimate miner in current round (achievable through normal election/staking)
- Attacker must have opportunity to propose NextRound (occurs naturally at round boundaries)

The `PreCheck` method only verifies the sender is in the current or previous round, not that the proposed next round is valid: [11](#0-10) 

**Detection**: Attack is immediately detectable (consensus stops), but damage is irreversible without hard fork.

## Recommendation

Add explicit validation that `RealTimeMinersInformation` is non-empty in the `RoundTerminateValidationProvider`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    // NEW: Validate miner list is non-empty
    if (extraData.Round.RealTimeMinersInformation.Count == 0)
        return new ValidationResult { Message = "Next round must contain at least one miner." };

    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

Alternatively, add a dedicated validator that checks miner list cardinality for both `NextRound` and `NextTerm` behaviors.

## Proof of Concept

```csharp
[Fact]
public async Task EmptyMinerListHaltsConsensus()
{
    // Setup: Initialize consensus with legitimate miners
    var keyPair = CryptoHelper.GenerateKeyPair();
    var tester = new AEDPoSContractTestBase();
    await tester.InitializeContracts();
    
    // Attacker (legitimate miner) crafts NextRound with empty miner list
    var maliciousNextRoundInput = new NextRoundInput
    {
        RoundNumber = 2,
        RealTimeMinersInformation = { }, // EMPTY!
        TermNumber = 1,
        RandomNumber = HashHelper.ComputeFrom("random").ToByteString()
    };
    
    // Execute attack - this should fail but will succeed
    var result = await tester.AEDPoSContractStub.NextRound.SendAsync(maliciousNextRoundInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify impact: All miners now receive InvalidConsensusCommand
    var consensusCommand = await tester.AEDPoSContractStub.GetConsensusCommand.CallAsync(
        new BytesValue { Value = ByteString.CopyFrom(keyPair.PublicKey) });
    
    // This proves consensus is halted
    consensusCommand.ShouldBe(ConsensusCommandProvider.InvalidConsensusCommand);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L32-34)
```csharp
        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-158)
```csharp
        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
