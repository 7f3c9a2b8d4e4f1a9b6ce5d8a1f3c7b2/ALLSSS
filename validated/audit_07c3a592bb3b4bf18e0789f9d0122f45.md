# Audit Report

## Title
NextTerm Transaction Lacks Validation of Miner List Against Election Contract Results

## Summary
The AEDPoS consensus contract's NextTerm transaction flow fails to validate that the miner list in the transaction input matches the legitimate election winners from the Election contract. This allows any current miner who becomes the extra block producer at term transition to unilaterally install an arbitrary set of miners for the next consensus term, completely bypassing the democratic election process.

## Finding Description

The vulnerability exists in the term transition mechanism where the consensus contract accepts a miner list without verifying it against the authoritative Election contract results.

**Missing Validation in Pre-Execution:**

When validating a NextTerm block, the `ValidateBeforeExecution` method only adds the `RoundTerminateValidationProvider` for NextTerm behavior: [1](#0-0) 

This provider only validates that round and term numbers are correctly incremented: [2](#0-1) 

**Critically absent** is any validation provider that queries `State.ElectionContract.GetVictories()` and compares the result against the miner list contained in the transaction input.

**Unchecked Miner Installation During Execution:**

The `ProcessNextTerm` method directly extracts miners from the input Round object and stores them via `SetMinerList`: [3](#0-2) 

At no point does this execution path call `GetVictories()` from the Election contract to verify that the miners being installed match the legitimate election winners.

**SetMinerList Provides No Legitimacy Check:**

The `SetMinerList` method only prevents duplicate updates for the same term but performs no validation of miner legitimacy: [4](#0-3) 

**Honest Path Not Enforced:**

While the honest code generation path does query the Election contract via `TryToGetVictories()`: [5](#0-4) 

This is only called during honest transaction generation by `GenerateFirstRoundOfNextTerm`: [6](#0-5) 

There is no validation code that enforces the same query must produce the same miners as those in the transaction input. A malicious miner can bypass this generation path entirely and directly craft a `NextTermInput` with arbitrary miners using: [7](#0-6) 

**Attack Execution:**

1. Malicious miner waits to become extra block producer at term boundary
2. Instead of calling `GetConsensusExtraDataForNextTerm` honestly, they craft a malicious Round with chosen miners
3. They create a NextTerm transaction with `NextTermInput.Create(maliciousRound, randomNumber)`
4. Validation passes (only round/term numbers checked)
5. Execution installs the arbitrary miner list
6. The attacker's chosen miners control consensus for the entire next term

The `PreCheck` method only verifies the sender is in the current or previous miner list, which the attacker satisfies: [8](#0-7) 

## Impact Explanation

**Consensus Integrity Catastrophic Failure:**
- A malicious extra block producer gains unilateral control over which miners validate the blockchain for the next term (typically 7 days)
- The attacker can inject arbitrary public keys as the complete miner set, including non-existent or colluding parties
- All legitimate election winners are excluded from consensus participation
- This violates the fundamental "Delegated" aspect of DPoS where token holders elect validators

**Democratic Process Nullification:**
- All token holder votes through the Election contract become meaningless
- The Election contract's `GetVictories()` results have no binding effect on actual consensus participation
- Voters lose their governance rights over block producer selection

**Cascading Permanent Control:**
- Malicious miners controlling term N can inject themselves into term N+1
- Creates self-perpetuating consensus capture with no recovery mechanism
- Even if honest miners win future elections, they can be perpetually excluded

## Likelihood Explanation

**Attack Prerequisites:**
- Attacker must be a current miner who becomes the extra block producer at term transition
- Attacker must modify their node software to generate malicious consensus transactions

Both prerequisites are realistic:
- Any miner in the current set eventually becomes the extra block producer (rotates among miners)
- Miners control their own node software

**Execution Feasibility:**
- Attack requires a single malicious NextTerm transaction
- No complex state manipulation or race conditions needed
- No economic cost beyond normal block production
- Validation checks are insufficient to detect the attack

**Detection:**
- Malicious transaction appears structurally valid
- No on-chain validation failures occur
- Requires off-chain monitoring to compare against `GetVictories()` results
- By detection time, malicious miners already control consensus

**Likelihood: HIGH** (once attacker becomes extra block producer at term boundary)

## Recommendation

Add a validation provider for NextTerm behavior that enforces miner list legitimacy:

```csharp
public class NextTermMinerListValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour != AElfConsensusBehaviour.NextTerm)
            return new ValidationResult { Success = true };
        
        // Query Election contract for legitimate winners
        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        var legitimateMiners = new HashSet<string>(
            victoriesPublicKeys.Value.Select(pk => pk.ToHex())
        );
        
        var proposedMiners = extraData.Round.RealTimeMinersInformation.Keys.ToHashSet();
        
        // Verify proposed miners match election results
        if (!proposedMiners.SetEquals(legitimateMiners))
        {
            return new ValidationResult 
            { 
                Success = false,
                Message = "Proposed miner list does not match Election contract results"
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Update `ValidateBeforeExecution` to include this provider:
```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new NextTermMinerListValidationProvider());
    break;
```

## Proof of Concept

```csharp
[Fact]
public async Task NextTerm_WithArbitraryMiners_ShouldFail()
{
    // Setup: Advance to term boundary
    await InitializeAndAdvanceToTermBoundary();
    
    // Attacker is current extra block producer
    var attackerKeyPair = InitialCoreDataCenterKeyPairs[0];
    var attackerStub = GetAEDPoSContractStub(attackerKeyPair);
    
    // Malicious: Craft Round with arbitrary miners (not from Election contract)
    var maliciousMiners = new[] { 
        SampleKeyPairs[10].PublicKey, // Not elected
        SampleKeyPairs[11].PublicKey, // Not elected
        SampleKeyPairs[12].PublicKey  // Not elected
    };
    
    var maliciousRound = new Round
    {
        RoundNumber = 1,
        TermNumber = 2,
        RealTimeMinersInformation = 
        {
            maliciousMiners.Select((pk, i) => new KeyValuePair<string, MinerInRound>(
                pk.ToHex(),
                new MinerInRound { Pubkey = pk.ToHex(), Order = i + 1 }
            ))
        }
    };
    
    var randomNumber = await GenerateRandomProofAsync(attackerKeyPair);
    var maliciousInput = NextTermInput.Create(maliciousRound, ByteString.CopyFrom(randomNumber));
    
    // Execute malicious NextTerm
    var result = await attackerStub.NextTerm.SendAsync(maliciousInput);
    
    // VULNERABILITY: Transaction succeeds despite invalid miner list
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Arbitrary miners are now in control
    var currentRound = await attackerStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.RealTimeMinersInformation.Keys.ShouldBe(
        maliciousMiners.Select(pk => pk.ToHex())
    );
    
    // Verify: Legitimate election winners are excluded
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    var electedMiners = victories.Value.Select(pk => pk.ToHex()).ToHashSet();
    var installedMiners = currentRound.RealTimeMinersInformation.Keys.ToHashSet();
    installedMiners.Intersect(electedMiners).ShouldBeEmpty(); // No overlap = complete takeover
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```
