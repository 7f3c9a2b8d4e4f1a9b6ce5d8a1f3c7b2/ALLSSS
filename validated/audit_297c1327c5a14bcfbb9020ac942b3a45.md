# Audit Report

## Title
Vote Contract Storage Bomb via Unvalidated Options During Registration

## Summary
The `Register` method in the Vote contract fails to validate the `options` array against the defined constraints `MaximumOptionsCount` (64) and `OptionLengthLimit` (1024 bytes) during voting item creation. This validation gap allows any address to create unlimited voting items with oversized option arrays, enabling a storage bomb attack that permanently bloats blockchain state.

## Finding Description

The vulnerability stems from a critical validation inconsistency where option constraints are strictly enforced for post-registration modifications but completely bypassed during initial registration.

The `Register` method directly assigns input options without any validation. [1](#0-0) 

The validation helper `AssertValidNewVotingItem` only verifies that the voting item doesn't already exist, handles timestamp validity, and checks snapshot numbers—it completely omits option validation. [2](#0-1) 

The contract defines security constants that should constrain options but are not enforced during registration. [3](#0-2) 

In stark contrast, validation exists and is properly enforced in the `AddOption` method for post-registration modifications. [4](#0-3)  The helper method `AssertOption` checks option length limits. [5](#0-4) 

Similarly, the `AddOptions` method validates each option and enforces the count limit after adding. [6](#0-5) 

Test evidence confirms this validation gap exists—voting items can be successfully registered with exactly 64 options, and the validation only triggers when attempting to add more via `AddOption`. [7](#0-6) 

The protobuf definition allows unlimited options in the repeated field with no built-in constraints. [8](#0-7) 

An attacker can exploit this by repeatedly calling `Register` with voting items containing large option arrays (e.g., 64 options × 1024 bytes = 65,536 bytes plus protobuf overhead), staying under the automatic 128KB state size limit while creating thousands of bloated voting items. There is no rate limiting, cooldown period, or per-address restriction on voting item creation.

## Impact Explanation

**Operational Impact - Storage Bomb Attack:**
- Any address can create unlimited voting items without authorization or rate limiting
- Each voting item can store up to ~64KB of option data (constrained only by the 128KB per-state-write limit)
- Conservative attack scenario: 1,000 voting items × 64KB = 64MB of bloated state
- Aggressive attack scenario: 10,000 voting items × 64KB = 640MB; 100,000 items = 6.4GB
- All full nodes must permanently sync, validate, and store this state
- No cleanup mechanism exists—voting items persist indefinitely in the state mapping stored at line 54 [9](#0-8) 
- Severely impacts blockchain operability, node sync times, and infrastructure costs

**Who is Affected:**
- All network participants (node operators, validators, developers, users)
- Blockchain infrastructure becomes increasingly expensive to maintain and operate
- State pruning becomes necessary but difficult to implement retroactively

**Severity Assessment:** HIGH - This directly threatens blockchain operational integrity through permanent state bloat, affects all network participants, and has no built-in mitigation beyond transaction fees which scale linearly and are not prohibitive for a determined attacker.

## Likelihood Explanation

**Attacker Capabilities:**
- Any address can call the public `Register` method—no special permissions, staking, or reputation requirements
- No authentication or authorization checks beyond basic token whitelist validation

**Attack Complexity:**
- Extremely straightforward: repeatedly call `Register` with `VotingRegisterInput` containing large option arrays
- Can create voting items exceeding the intended 64-option limit during registration (only limited by 128KB state size, not by `MaximumOptionsCount`)
- Simple automation via script or repeated transactions

**Economic Feasibility:**
- Transaction fees scale linearly with transaction data size
- No exponential backoff, quadratic costs, or other prohibitive economic barriers
- Attack can be distributed across multiple addresses to reduce per-address cost
- Determined attacker with moderate funds can execute significant attack

**Feasibility Conditions:**
- Zero rate limiting, cooldown periods, or per-address voting item creation limits
- No governance intervention required to execute
- Fully compatible with all AElf execution semantics and runtime constraints

**Likelihood Assessment:** HIGH - The combination of public access, completely missing validation, no rate limiting mechanisms, straightforward execution path, and economically feasible cost structure makes this attack highly probable for motivated attackers.

## Recommendation

Add comprehensive option validation to the `Register` method before storing the voting item:

```csharp
private Hash AssertValidNewVotingItem(VotingRegisterInput input)
{
    // Existing validation...
    var votingItemId = input.GetHash(Context.Sender);
    Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");
    if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;
    Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");
    
    // ADD: Validate options count
    Assert(input.Options.Count <= VoteContractConstants.MaximumOptionsCount,
        $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
    
    // ADD: Validate each option length and uniqueness
    var seenOptions = new HashSet<string>();
    foreach (var option in input.Options)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(seenOptions.Add(option), "Option already exists.");
    }
    
    Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");
    return votingItemId;
}
```

This ensures consistency between registration-time and post-registration validation, enforcing the same constraints throughout the voting item lifecycle.

## Proof of Concept

The existing test demonstrates that registration succeeds with 64 options, and only post-registration additions trigger validation. [7](#0-6) 

An attacker can register voting items with large option counts (up to ~128 options of 500 bytes each to stay under 128KB limit) by calling:

```csharp
await VoteContractStub.Register.SendAsync(new VotingRegisterInput
{
    StartTimestamp = TimestampHelper.GetUtcNow(),
    EndTimestamp = TimestampHelper.GetUtcNow().AddDays(100),
    Options = { GenerateLargeOptions(128, 500) }, // 128 options of 500 bytes each
    AcceptedCurrency = "ELF",
    IsLockToken = true,
    TotalSnapshotNumber = 1
});
```

This transaction succeeds because no validation checks options count or length during registration, only the 128KB state size limit applies. Repeating this call 1,000 times creates 64MB+ of permanent state bloat.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L49-49)
```csharp
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L54-54)
```csharp
        State.VotingItems[votingItemId] = votingItem;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L284-286)
```csharp
        AssertOption(votingItem, input.Option);
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L292-296)
```csharp
    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L318-321)
```csharp
        foreach (var option in input.Options) AssertOption(votingItem, option);
        votingItem.Options.AddRange(input.Options);
        Assert(votingItem.Options.Count <= VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-6)
```csharp
    public const int MaximumOptionsCount = 64;
    public const int OptionLengthLimit = 1024;
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L340-352)
```csharp
        // option count exceed 64
        {
            var registerItem = await RegisterVotingItemAsync(100, VoteContractConstant.MaximumOptionsCount, true,
                DefaultSender, 1);
            var newOption = Accounts[VoteContractConstant.MaximumOptionsCount].Address.ToBase58();
            var transactionResult = (await VoteContractStub.AddOption.SendWithExceptionAsync(new AddOptionInput
            {
                Option = newOption,
                VotingItemId = registerItem.VotingItemId
            })).TransactionResult;
            transactionResult.Error.ShouldContain(
                $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        }
```

**File:** protobuf/vote_contract.proto (L99-99)
```text
    repeated string options = 6;
```
