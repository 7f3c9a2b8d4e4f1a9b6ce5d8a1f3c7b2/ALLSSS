# Audit Report

## Title
Unhandled KeyNotFoundException in RecoverFromUpdateValue During Miner Replacement Causes Block Validation DoS

## Summary
The `RecoverFromUpdateValue` method contains a critical ordering flaw where it iterates over all miners from the block header's round information without validating their existence in the current state, causing an unhandled `KeyNotFoundException` when a miner replacement occurs mid-block. This prevents the existing replacement detection logic from executing and results in rejection of legitimate blocks.

## Finding Description

The vulnerability exists in the consensus validation flow when a block contains both a miner replacement transaction and UpdateValue consensus behavior.

The `RecoverFromUpdateValue` method performs an initial validation check that only verifies the block producer's pubkey exists in both the provided round (from block header) and current round (from state). [1](#0-0) 

However, the method then iterates over ALL miners in the provided round and directly accesses the current round's `RealTimeMinersInformation` dictionary without checking if each key exists. [2](#0-1) 

When `ReplaceCandidatePubkey` is called, the election contract triggers `RecordCandidateReplacement` in the consensus contract. [3](#0-2) 

The consensus contract's `RecordCandidateReplacement` method removes the old pubkey and adds the new pubkey to the current round state. [4](#0-3) 

During post-execution validation, `ValidateConsensusAfterExecution` calls `RecoverFromUpdateValue` with the block header's round (containing old pubkey) and the current state's round (containing new pubkey). [5](#0-4) 

The critical flaw is that `RecoverFromUpdateValue` is called BEFORE the replacement detection logic, which exists specifically to handle this scenario. [6](#0-5) 

When the foreach loop encounters the old pubkey that no longer exists in the current round, it throws an unhandled `KeyNotFoundException`, preventing the replacement detection logic from ever executing.

## Impact Explanation

**Severity: Medium**

This vulnerability breaks the consensus validation system's guarantee of handling all valid state transitions gracefully. When triggered:

1. **Block Validation Failure**: Blocks containing both miner replacement and UpdateValue transactions fail post-execution validation with an unhandled exception
2. **Consensus Disruption**: Legitimate blocks are rejected by validators, disrupting normal consensus operations
3. **Chain Availability**: Repeated triggering can impact chain availability as blocks fail validation
4. **No Direct Fund Loss**: While this doesn't steal funds or inflate supply, it disrupts the core consensus mechanism

The severity is assessed as Medium because it affects consensus reliability and chain availability but does not directly compromise funds or enable unauthorized state changes. The impact is operational rather than financial.

## Likelihood Explanation

**Probability: Medium**

The vulnerability can be triggered through normal protocol operations:

**Attacker Prerequisites:**
- Register as a candidate (publicly accessible via election contract)
- Obtain candidate admin privileges (automatic upon registration)
- Call `ReplaceCandidatePubkey` for any active miner

**Execution Path:**
1. Any candidate admin can call `ReplaceCandidatePubkey` at any time
2. If a miner includes this transaction in their block with UpdateValue behavior (the most common consensus behavior), validation fails
3. The miner may unknowingly include the replacement transaction from the mempool
4. No special timing or network conditions required beyond normal block production

**Feasibility Factors:**
- Becoming a candidate admin is achievable through normal protocol operations
- UpdateValue is the standard consensus behavior for most blocks
- Miners cannot easily detect that including a replacement transaction will cause their block to fail validation
- The issue can occur accidentally without malicious intent

The likelihood is Medium because while the preconditions are achievable, it requires coordination between the replacement transaction timing and block production with UpdateValue behavior.

## Recommendation

Add a `ContainsKey` check before accessing the dictionary in the foreach loop:

```csharp
foreach (var information in providedRound.RealTimeMinersInformation)
{
    if (!RealTimeMinersInformation.ContainsKey(information.Key))
        continue;
        
    RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
        information.Value.SupposedOrderOfNextRound;
    RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
        information.Value.FinalOrderOfNextRound;
    RealTimeMinersInformation[information.Key].PreviousInValue =
        information.Value.PreviousInValue;
}
```

Alternatively, reorder the validation logic to perform replacement detection before calling `RecoverFromUpdateValue`, allowing the method to work with the corrected round information.

## Proof of Concept

```csharp
[Fact]
public async Task ReplaceMinerDuringUpdateValue_CausesValidationFailure()
{
    // Setup: Initialize consensus with active miners [A, B, C]
    // Miner B registers as candidate and becomes candidate admin
    
    // 1. Miner A produces block with UpdateValue behavior
    //    Block header contains round info with miners [A, B, C]
    
    // 2. Block contains ReplaceCandidatePubkey transaction replacing B with B'
    var replacementTx = await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(
        new ReplaceCandidatePubkeyInput
        {
            OldPubkey = minerB_PublicKey,
            NewPubkey = minerBNew_PublicKey
        });
    
    // 3. During execution: RecordCandidateReplacement updates state
    //    Current round now has [A, B', C]
    
    // 4. After execution: ValidateConsensusAfterExecution is called
    //    - currentRound (from state) has [A, B', C]
    //    - headerInformation.Round (from block header) has [A, B, C]
    
    // 5. RecoverFromUpdateValue is called
    //    - Lines 10-12: Check block producer A exists in both → PASS
    //    - Lines 22-30: Iterate over header round [A, B, C]
    //    - Try to access RealTimeMinersInformation["B"] → KEY NOT FOUND
    
    // Expected: KeyNotFoundException thrown
    // Result: Block validation fails, block rejected
    
    var validationResult = await ConsensusContractStub.ValidateConsensusAfterExecution.CallAsync(
        blockHeader.ConsensusExtraData);
    
    // This will throw KeyNotFoundException before reaching replacement detection logic
    Assert.Throws<KeyNotFoundException>(() => validationResult);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L10-12)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-302)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;

        // Notify Consensus Contract to update replacement information. (Update from old record.)
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L142-143)
```csharp
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-92)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L103-123)
```csharp
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
```
