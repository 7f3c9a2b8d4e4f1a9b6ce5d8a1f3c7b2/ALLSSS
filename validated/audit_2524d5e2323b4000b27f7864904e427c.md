# Audit Report

## Title
Missing ProducedBlocks Counter Validation in NextRound Transitions Enables Treasury Reward Manipulation

## Summary
The AEDPoS consensus validation pipeline fails to validate `ProducedBlocks` counters during NextRound transitions. A malicious miner producing a round-terminating block can submit manipulated `ProducedBlocks` values that directly control Treasury BasicMinerReward distribution, enabling systematic theft of mining rewards from honest miners.

## Finding Description

The consensus validation for NextRound transitions contains a critical gap that allows miners to manipulate ProducedBlocks counters without detection.

**Validation Gap**: The `ValidationForNextRound` method explicitly validates only two properties - round number increment and null InValues - but completely omits ProducedBlocks validation: [1](#0-0) 

**Legitimate Data Flow**: When generating next round information correctly, ProducedBlocks values are preserved from the current round: [2](#0-1) [3](#0-2) 

**Unvalidated Processing**: The `ProcessNextRound` method directly converts the miner-supplied input without ProducedBlocks validation: [4](#0-3) 

The `ToRound()` conversion performs simple field copying with zero validation: [5](#0-4) 

**Financial Impact Path**: The manipulated ProducedBlocks values directly control Treasury reward distribution through `UpdateBasicMinerRewardWeights`: [6](#0-5) 

The `CalculateShares` function implements strict penalty thresholds based on ProducedBlocks relative to average: [7](#0-6) 

**Attack Vector**: A malicious miner producing the round-terminating block can:
1. Inflate their own ProducedBlocks → bypass quadratic penalty, receive full linear shares
2. Deflate competitors' ProducedBlocks → force victims below 50% threshold (0 shares) or 80% threshold (quadratic penalty)
3. Shift the average → manipulate penalty boundaries affecting all miners

The only validators invoked for NextRound behavior are structural validators that don't examine ProducedBlocks: [8](#0-7) 

## Impact Explanation

**Severity: Critical** - Direct financial theft with compounding effects.

The BasicMinerReward scheme controls a significant portion of mining rewards (default weight 2 out of 4 in MinerReward distribution). Manipulation of ProducedBlocks enables:

1. **Immediate Reward Theft**: Attacker inflates their shares while reducing competitors to 0 (below 50% threshold)
2. **Compounding Damage**: Attack repeats every round throughout the entire term (typically 7 days)
3. **Systemic Impact**: Manipulating the average shifts penalty thresholds, affecting ALL miners' rewards
4. **Undetectable**: Manipulated values pass all existing validation and appear legitimate [9](#0-8) 

The economic incentive is overwhelming - attackers gain substantial mining rewards with zero detection risk.

## Likelihood Explanation

**Likelihood: High** - Regularly exploitable by any authorized miner.

**Opportunity**: Every miner producing a round-terminating block (last block producer or extra block producer) can exploit this. This occurs at the end of every consensus round.

**Execution**: 
1. Miner's node generates correct NextRoundInput via `GetConsensusExtraData`
2. Miner modifies `RealTimeMinersInformation[pubkey].ProducedBlocks` values
3. Miner includes transaction calling `NextRound(manipulated_input)` in their block
4. Validation checks only round number and InValues - ProducedBlocks bypass all checks

**No Cryptographic Binding**: There is no signature, hash, or cryptographic commitment that binds ProducedBlocks values to the actual blockchain state. The validation pipeline cannot detect the manipulation.

**No Detection**: The manipulated values are structurally valid integers that pass all type checks. Post-execution validation compares round hashes but this doesn't effectively validate NextRound because it compares different rounds (current vs next).

## Recommendation

Add ProducedBlocks integrity validation to `RoundTerminateValidationProvider.ValidationForNextRound`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing validations
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Validate ProducedBlocks integrity
    foreach (var miner in extraData.Round.RealTimeMinersInformation)
    {
        var currentMinerInfo = validationContext.BaseRound.RealTimeMinersInformation
            .GetValueOrDefault(miner.Key);
        if (currentMinerInfo != null)
        {
            // ProducedBlocks in next round must equal current round's value
            // (extra block producer gets +1 later during processing)
            var expectedProducedBlocks = currentMinerInfo.ProducedBlocks;
            if (miner.Value.ProducedBlocks != expectedProducedBlocks)
                return new ValidationResult 
                { 
                    Message = $"ProducedBlocks mismatch for {miner.Key}: " +
                              $"expected {expectedProducedBlocks}, got {miner.Value.ProducedBlocks}" 
                };
        }
    }
    
    return new ValidationResult { Success = true };
}
```

Additionally, increment the extra block producer's ProducedBlocks BEFORE validation instead of during processing, or validate that only the extra block producer has +1 increment.

## Proof of Concept

```csharp
[Fact]
public async Task ProducedBlocksManipulation_BypassesValidation_InflatesRewards()
{
    // Setup: Initialize consensus with multiple miners
    await InitializeConsensusAsync();
    
    // Attacker is the extra block producer for round termination
    var attackerPubkey = SamplePubkey[0];
    var victimPubkey = SamplePubkey[1];
    
    // Progress through a round where all miners produce blocks normally
    await ProduceNormalRoundAsync();
    
    // Get current round information to construct malicious NextRoundInput
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Generate legitimate next round data
    var legitimateNextRound = GenerateNextRound(currentRound);
    
    // ATTACK: Manipulate ProducedBlocks before submission
    var maliciousNextRound = legitimateNextRound.Clone();
    maliciousNextRound.RealTimeMinersInformation[attackerPubkey].ProducedBlocks = 1000; // Inflate attacker
    maliciousNextRound.RealTimeMinersInformation[victimPubkey].ProducedBlocks = 10;    // Deflate victim
    
    // Submit malicious NextRound transaction
    var result = await ConsensusStub.NextRound.SendAsync(
        NextRoundInput.Create(maliciousNextRound, GenerateRandomNumber()));
    
    // ASSERTION: Transaction succeeds despite manipulated ProducedBlocks
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify manipulated data was persisted
    var persistedRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    persistedRound.RealTimeMinersInformation[attackerPubkey].ProducedBlocks.ShouldBe(1000);
    persistedRound.RealTimeMinersInformation[victimPubkey].ProducedBlocks.ShouldBe(10);
    
    // Progress to term end and trigger Treasury distribution
    await AdvanceToNextTermAsync();
    
    // Calculate reward shares using manipulated data
    var attackerShares = CalculateShares(1000, average: 500); // Gets full linear shares
    var victimShares = CalculateShares(10, average: 500);     // Below 50% threshold = 0 shares
    
    // CRITICAL: Victim receives ZERO rewards despite producing blocks
    victimShares.ShouldBe(0);
    attackerShares.ShouldBeGreaterThan(0);
    
    // Attacker stole victim's portion of BasicMinerReward
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L46-56)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L480-488)
```csharp
    private MinerRewardWeightSetting GetDefaultMinerRewardWeightSetting()
    {
        return new MinerRewardWeightSetting
        {
            BasicMinerRewardWeight = 2,
            WelcomeRewardWeight = 1,
            FlexibleRewardWeight = 1
        };
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L777-822)
```csharp
    private void UpdateBasicMinerRewardWeights(IReadOnlyCollection<Round> previousTermInformation)
    {
        if (previousTermInformation.First().RealTimeMinersInformation != null)
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });

        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
