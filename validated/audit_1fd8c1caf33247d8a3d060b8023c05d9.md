# Audit Report

## Title
Sponsor Can Remove Voted Options During Active Voting, Causing DOS and Vote Manipulation

## Summary
The `RemoveOption()` function in the Vote contract lacks timestamp validation, allowing sponsors to remove options during active voting periods even when votes have been cast. This creates a denial-of-service condition for new voters and enables vote manipulation through selective option removal and re-addition, fundamentally breaking voting integrity.

## Finding Description

The `RemoveOption()` function only validates sponsor permission, option existence, and option length before removing an option from a voting item. [1](#0-0) 

The function performs no validation against the voting item's `StartTimestamp` or `EndTimestamp` fields, which are defined in the VotingItem structure. [2](#0-1) 

When voters call the `Vote()` function, it validates that the option exists in `votingItem.Options` list through `AssertValidVoteInput()`. [3](#0-2) 

However, votes are stored separately in the `VotingResult.Results[option]` mapping through `UpdateVotingResult()`. [4](#0-3) 

**Attack Path**:
1. Sponsor registers voting item with options A, B, C via `Register()` [5](#0-4) 
2. Voting period becomes active (CurrentBlockTime >= StartTimestamp)
3. Multiple voters cast votes for option A via `Vote()` â†’ stored in `VotingResult.Results["A"]`
4. Sponsor calls `RemoveOption()` to remove option A from `VotingItem.Options` (no timestamp check)
5. New voters attempting to vote for A fail at the assertion that validates option existence
6. Existing votes for A remain in `VotingResult.Results["A"]` but option is unavailable
7. Sponsor can later re-add option A via `AddOption()` [6](#0-5) 

This creates a fundamental inconsistency where votes exist for options that are not available, and new voters are denied the ability to vote on options that already have votes.

## Impact Explanation

**Voting Integrity Violation**: The core invariant of fair voting - that all eligible voters have equal opportunity to vote on the same set of options - is broken. The system creates two classes of voters: those who voted before option removal and those who cannot vote after removal.

**Denial of Service**: New voters are completely blocked from voting on removed options despite existing votes, creating an availability issue for a critical governance function.

**Vote Manipulation**: Sponsors can strategically remove losing options during voting, wait for sentiment to change, then re-add them. This enables timing-based manipulation of voting outcomes.

**Governance Impact**: The Vote contract is used by the Election contract for candidate selection and other governance processes. [7](#0-6)  This vulnerability undermines the integrity of AElf's governance mechanisms, potentially affecting fund allocations and protocol decisions.

**Data Inconsistency**: Voting results contain orphaned votes for non-existent options, breaking result integrity and making accurate tallying impossible.

The severity is **Medium-High** because while no funds are directly stolen, the governance manipulation capability can indirectly affect fund distributions and protocol security decisions.

## Likelihood Explanation

**Attacker Profile**: Any user can be a voting sponsor by calling `Register()`. The attacker doesn't need special privileges beyond creating their own voting item.

**Execution Complexity**: **Low** - Single transaction calling `RemoveOption()` with voting item ID and option name. No complex state setup, timing windows, or race conditions required.

**Prerequisites**: 
- Voting item must exist (trivial - attacker creates it)
- Attacker must be sponsor (trivial - attacker sponsors their own voting)
- Option must exist (trivial - attacker knows their voting options)

**Detection**: Difficult - The function does not emit events when options are removed, creating no on-chain audit trail. Off-chain systems would need to continuously poll voting item state to detect modifications.

**Reproducibility**: **High** - Can be executed repeatedly during any voting period with no rate limits or cooldowns.

The likelihood is **High** due to low technical barriers and easy executability by any sponsor.

## Recommendation

Add timestamp validation to prevent option modification during active voting periods:

```csharp
public override Empty RemoveOption(RemoveOptionInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
    
    // Add timestamp validation
    Assert(Context.CurrentBlockTime < votingItem.StartTimestamp, 
           "Cannot remove options during or after voting period.");
    
    Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
    Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
    votingItem.Options.Remove(input.Option);
    State.VotingItems[votingItem.VotingItemId] = votingItem;
    return new Empty();
}
```

Apply the same fix to `AddOption()` and `RemoveOptions()` methods to maintain consistency.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveOption_DuringActiveVoting_ShouldCauseDoS()
{
    // Setup: Register voting item with option A
    var startTime = TimestampHelper.GetUtcNow().AddSeconds(10);
    var endTime = startTime.AddDays(7);
    var votingItemId = await RegisterVotingItem(new[] { "OptionA", "OptionB" }, startTime, endTime);
    
    // Advance time to voting period
    BlockTimeProvider.SetBlockTime(startTime.AddSeconds(1));
    
    // Voter1 successfully votes for OptionA
    var voter1 = Accounts[1].KeyPair;
    await VoteForOption(voter1, votingItemId, "OptionA", 100);
    
    // Sponsor removes OptionA during active voting
    await RemoveOption(votingItemId, "OptionA");
    
    // Voter2 attempts to vote for OptionA - should fail with DOS
    var voter2 = Accounts[2].KeyPair;
    var result = await VoteForOption(voter2, votingItemId, "OptionA", 100);
    
    // Assert: Vote fails due to option not found
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Option OptionA not found");
    
    // Verify: Old votes still exist but option is unavailable
    var votingResult = await GetVotingResult(votingItemId);
    votingResult.Results["OptionA"].ShouldBe(100); // Old vote remains
    
    var votingItem = await GetVotingItem(votingItemId);
    votingItem.Options.ShouldNotContain("OptionA"); // Option removed
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-82)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
        };

        State.VotingItems[votingItemId] = votingItem;

        // Initialize first voting going information of registered voting event.
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };

        Context.Fire(new VotingItemRegistered
        {
            Sponsor = votingItem.Sponsor,
            VotingItemId = votingItemId,
            AcceptedCurrency = votingItem.AcceptedCurrency,
            IsLockToken = votingItem.IsLockToken,
            TotalSnapshotNumber = votingItem.TotalSnapshotNumber,
            CurrentSnapshotNumber = votingItem.CurrentSnapshotNumber,
            CurrentSnapshotStartTimestamp = votingItem.StartTimestamp,
            StartTimestamp = votingItem.StartTimestamp,
            EndTimestamp = votingItem.EndTimestamp,
            RegisterTimestamp = votingItem.RegisterTimestamp,
            IsQuadratic = votingItem.IsQuadratic,
            TicketCost = votingItem.TicketCost
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L280-290)
```csharp
    public override Empty AddOption(AddOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        AssertOption(votingItem, input.Option);
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        votingItem.Options.Add(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L303-312)
```csharp
    public override Empty RemoveOption(RemoveOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
        votingItem.Options.Remove(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-381)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
```

**File:** protobuf/vote_contract.proto (L122-124)
```text
    google.protobuf.Timestamp start_timestamp = 8;
    // The end time of the voting.
    google.protobuf.Timestamp end_timestamp = 9;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L257-260)
```csharp
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
```
