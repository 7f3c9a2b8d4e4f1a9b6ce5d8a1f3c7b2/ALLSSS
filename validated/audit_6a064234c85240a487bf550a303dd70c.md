# Audit Report

## Title
Unbounded ReceivedTokenSymbols Growth Enables State Bloat and Iteration DoS on Profit Schemes

## Summary
The `ReceivedTokenSymbols` field in profit schemes has no size limit and can be populated by any user contributing arbitrary token types to any scheme. When this list grows large (1000+ symbols), operations that iterate over all symbols—such as profit distribution and claiming—will exceed gas limits or become prohibitively expensive, causing operational DoS for scheme managers and beneficiaries, including critical infrastructure like the consensus dividend pool.

## Finding Description

The `ReceivedTokenSymbols` field is defined as an unbounded repeated string field in the Scheme structure with no maximum size constraint. [1](#0-0) 

This list is populated in two locations without any bound validation. First, in `DistributeProfitsForSubSchemes()` when distributing to sub-schemes: [2](#0-1) 

Second, in `ContributeProfits()` when anyone contributes tokens: [3](#0-2) 

The critical vulnerability is that `ContributeProfits()` has no access control. The only validation performed is checking that the token exists and the amount is positive: [4](#0-3) 

Any user can call this function to contribute dust amounts (e.g., 1 unit) of any valid token to any profit scheme, causing that token symbol to be permanently added to `ReceivedTokenSymbols`.

The `TokenAmountLimit` constant is unrelated to this vulnerability—it only applies to method fee configuration: [5](#0-4) 

Once the list grows large, three critical DoS vectors emerge:

**DoS Vector 1**: `DistributeProfits()` when `IsReleaseAllBalanceEveryTimeByDefault` is true and no specific amounts are provided—it iterates over ALL symbols making external `GetBalance` calls for each: [6](#0-5) 

**DoS Vector 2**: `ProfitAllPeriods()` when calculating profits for beneficiaries iterates over all symbols: [7](#0-6) 

**DoS Vector 3**: `GetUndistributedDividends()` in the AEDPoS consensus contract iterates all symbols to calculate undistributed dividends for the consensus dividend pool: [8](#0-7) 

Each iteration involves expensive external contract calls to the Token contract, causing gas consumption to scale linearly with the number of symbols.

## Impact Explanation

**Operational DoS:**
- Scheme managers (especially for the consensus dividend pool) become unable to call `DistributeProfits()` if the gas cost of iterating 1000+ symbols exceeds block gas limits or becomes prohibitively expensive
- Beneficiaries become unable to claim profits via `ClaimProfits()` when calculation functions timeout or exceed gas limits
- The consensus dividend pool could become completely non-operational, disrupting validator reward distributions

**State Bloat:**
- Each token symbol added increases the state size of the Scheme object permanently
- No mechanism exists to remove symbols from the list
- Storage costs accumulate over time

**Affected Parties:**
- Scheme managers needing to distribute profits
- Beneficiaries attempting to claim their profits
- The protocol's consensus dividend pool infrastructure
- Any high-value profit scheme targeted by attackers

This breaks the operational availability guarantee of the profit distribution system, which is critical infrastructure for AElf's economic model. While the attack requires sustained effort and transaction fees, the impact on critical schemes like consensus rewards justifies Medium severity rather than Low.

## Likelihood Explanation

**Attack Feasibility:**
- **Attacker Capabilities**: Needs access to multiple token types (can use existing tokens or create new ones) and must pay transaction fees for each contribution
- **Technical Complexity**: Low—simply call `ContributeProfits()` repeatedly with different token symbols and minimal amounts (1 unit)
- **Economic Rationality**: For N=1000 symbols, cost = N × (transaction_fee + 1_token_unit), which is economically feasible for motivated attackers targeting critical infrastructure

**Execution Characteristics:**
- Can be executed gradually over time to avoid detection
- No special permissions or exploitation techniques required
- Attack is detectable through monitoring but difficult to prevent without access control changes
- No automatic cleanup mechanism exists

**Probability Assessment**: Medium-Low. While technically simple and economically feasible for high-value targets, it requires sustained effort and upfront costs. The attack is more likely against critical infrastructure schemes (consensus dividend pool, treasury) where DoS disrupts network operations, rather than general profit schemes.

## Recommendation

Implement a maximum size limit for `ReceivedTokenSymbols` and add validation in both locations where symbols are added:

1. Add a constant for maximum symbols (e.g., `MaximumReceivedTokenSymbols = 100`)
2. Check the size before adding in `ContributeProfits()`:
   ```csharp
   if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol))
   {
       Assert(scheme.ReceivedTokenSymbols.Count < ProfitContractConstants.MaximumReceivedTokenSymbols, 
              "Maximum number of token symbols reached.");
       scheme.ReceivedTokenSymbols.Add(input.Symbol);
   }
   ```
3. Apply the same check in `DistributeProfitsForSubSchemes()`

Additionally, consider implementing:
- A whitelist mechanism for approved token symbols per scheme
- Access control on `ContributeProfits()` to restrict contributions to scheme manager or approved addresses
- A mechanism to remove unused token symbols from old schemes

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task ReceivedTokenSymbols_Unbounded_Growth_DoS()
{
    // Setup: Create a profit scheme
    var schemeId = await CreateProfitSchemeAsync();
    
    // Attack: Add 1000 different token symbols by contributing dust amounts
    for (int i = 0; i < 1000; i++)
    {
        var tokenSymbol = $"TOKEN{i}";
        await CreateTokenAsync(tokenSymbol); // Create token if needed
        
        // Contribute 1 unit of the token to the scheme
        await ProfitContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeId = schemeId,
            Symbol = tokenSymbol,
            Amount = 1,
            Period = 0
        });
    }
    
    // Verify: ReceivedTokenSymbols now contains 1000 symbols
    var scheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    scheme.ReceivedTokenSymbols.Count.ShouldBe(1000);
    
    // Impact: DistributeProfits with IsReleaseAllBalanceEveryTimeByDefault
    // will iterate 1000 times making external calls, causing DoS
    var distributeProfitsTask = ProfitContractStub.DistributeProfits.SendAsync(
        new DistributeProfitsInput
        {
            SchemeId = schemeId,
            Period = 1
        });
    
    // This call will exceed gas limits or timeout
    await Assert.ThrowsAsync<Exception>(() => distributeProfitsTask);
}
```

### Citations

**File:** protobuf/profit_contract.proto (L159-159)
```text
    repeated string received_token_symbols = 12;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L449-459)
```csharp
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L641-645)
```csharp
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L656-660)
```csharp
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L716-716)
```csharp
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L851-851)
```csharp
        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L14-14)
```csharp
        Assert(input.Fees.Count <= ProfitContractConstants.TokenAmountLimit, "Invalid input.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L154-158)
```csharp
                scheme.ReceivedTokenSymbols.Select(s => State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = s
                })).ToDictionary(b => b.Symbol, b => b.Balance)
```
