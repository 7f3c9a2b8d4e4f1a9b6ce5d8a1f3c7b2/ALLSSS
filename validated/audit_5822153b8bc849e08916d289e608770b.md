# Audit Report

## Title
Dynamic GetMaximumBlocksCount() Changes Mid-Round Allow Miners to Exceed Tiny Block Limits

## Summary
The AEDPoS consensus contract's tiny block limiting mechanism fails to properly enforce dynamically-adjusted limits when blockchain status changes between command generation and block processing. The counter-based validation does not reset for the same miner when `GetMaximumBlocksCount()` returns a reduced value, allowing miners to produce up to 8 blocks even when the current limit is 1, defeating the fork-reduction mechanism during critical stress periods.

## Finding Description

The vulnerability exists in the consensus command generation and block processing flow:

**Command Generation Phase:**

When a miner requests a consensus command, `GetConsensusCommand` calls `GetMaximumBlocksCount()` and creates a `SideChainConsensusBehaviourProvider` with this value. [1](#0-0) 

The base class constructor stores this value in the `_maximumBlocksCount` field. [2](#0-1) 

The behavior provider then uses this stored value to determine if TinyBlock behavior is allowed by checking if `ActualMiningTimes.Count < _maximumBlocksCount`. [3](#0-2) 

**Block Processing Phase:**

During block processing, `ProcessConsensusInformation` calls `GetMaximumBlocksCount()` again and uses the potentially different value to update the counter. [4](#0-3) 

**Root Cause - Dynamic Status Changes:**

`GetMaximumBlocksCount()` dynamically adjusts based on blockchain mining status. In Normal status it returns 8, in Abnormal status it returns a reduced count (as low as 3), and in Severe status it returns 1. [5](#0-4) 

The status is determined by the distance between the current round and the Last Irreversible Block (LIB) round, which can change mid-round as blocks are produced. [6](#0-5) 

**Critical Flaw - Counter Does Not Reset:**

The `ResetLatestProviderToTinyBlocksCount` method only decrements the counter for the same miner, rather than resetting it based on the new `minersCountInTheory` value. [7](#0-6) 

The counter only resets to the new maximum when a DIFFERENT miner produces a block. [8](#0-7) 

**Missing Validation:**

The validation only checks if `BlocksCount < 0`, which allows the counter value 0 to pass. [9](#0-8) 

No validation provider checks that the miner's `ActualMiningTimes.Count` respects the current `GetMaximumBlocksCount()` value during block processing.

**Attack Scenario:**

1. Initial state: counter = 7, `GetMaximumBlocksCount()` returns 8 (Normal status)
2. Miner A produces blocks 1-3, counter decrements to 4
3. Blockchain enters Severe status, `GetMaximumBlocksCount()` now returns 1
4. Miner A continues producing blocks 4-8
5. For each block, validation sees counter ≥ 0 (passes), then counter decrements
6. Block 8: validation sees counter = 0 (≥ 0, passes!), then counter → -1
7. Block 9: validation sees counter = -1 (< 0, finally fails)

Result: Miner A produced 8 blocks when the current limit was 1 (8x violation).

## Impact Explanation

**Consensus Stability Degradation:**

The fork-reduction mechanism implemented in PR #1952 is defeated. When the blockchain enters Abnormal or Severe status due to LIB not advancing, the system attempts to reduce tiny block production to minimize forks. However, miners who began producing blocks before the status change can continue producing up to 8 blocks regardless of the current limit.

**Quantified Impact:**
- In Normal status: limit is 8 blocks (from `MaximumTinyBlocksCount` constant) [10](#0-9) 
- In Abnormal status: limit reduces to 3-7 blocks based on miner participation
- In Severe status: limit reduces to 1 block
- Actual violation: miners can produce 8 blocks when limit is 1 (8x excess)

**Network-Wide Effects:**
- Excessive forks proliferate during the most critical stress periods
- Block finality is delayed as the chain struggles to achieve consensus
- The self-healing capability designed to recover from network issues is undermined
- Extended chain stalls or inconsistencies may occur during sustained Severe status

This is a Medium severity issue because while it does not directly steal funds, it significantly degrades consensus reliability precisely when the blockchain is most vulnerable, potentially causing operational disruptions.

## Likelihood Explanation

**Trigger Conditions:**
The vulnerability triggers naturally during normal blockchain operations when:
1. The blockchain transitions from Normal to Abnormal/Severe status mid-round
2. A miner has already requested a consensus command and begun producing tiny blocks
3. The LIB fails to advance properly (common during network congestion or consensus issues)

**Execution Complexity:**
- No special attacker capabilities required - any valid miner can trigger this
- Entry point is the public `GetConsensusCommand` method (ACS4 interface)
- No special permissions needed beyond being in the current miner list
- Timing window: seconds to minutes between command generation and status change
- Cannot be easily detected as it appears as legitimate mining activity

**Probability Assessment:**
Production blockchains periodically experience network stress, LIB lag, or temporary consensus issues that trigger Abnormal/Severe status. Given that multiple miners operate concurrently and the status can change within a mining round, this condition has a **Medium** likelihood of occurring in real-world operations.

The vulnerability is not theoretical - it will manifest whenever the blockchain enters stress conditions and a miner happens to be in the middle of producing tiny blocks.

## Recommendation

Add validation during block processing to enforce that `ActualMiningTimes.Count` does not exceed the current `GetMaximumBlocksCount()` value:

**In `ContinuousBlocksValidationProvider.ValidateHeaderInformation`:**

Add a check that compares the miner's actual block production count against the current maximum:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    if (validationContext.ProvidedRound.RoundNumber > 2 && 
        validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
    {
        // Existing counter check
        var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
        if (latestPubkeyToTinyBlocksCount != null &&
            latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
            latestPubkeyToTinyBlocksCount.BlocksCount < 0)
        {
            validationResult.Message = "Sender produced too many continuous blocks.";
            return validationResult;
        }
        
        // NEW: Check against current maximum
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var currentMaximum = validationContext.CurrentMaximumBlocksCount; // Pass this in context
        if (minerInRound.ActualMiningTimes.Count >= currentMaximum)
        {
            validationResult.Message = "Sender exceeded current maximum blocks count.";
            return validationResult;
        }
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

**Additionally, in `ConsensusValidationContext`:**

Add a field to pass the current maximum:

```csharp
public int CurrentMaximumBlocksCount { get; set; }
```

**And in `ValidateBeforeExecution`:**

Populate this field when creating the validation context:

```csharp
var validationContext = new ConsensusValidationContext
{
    BaseRound = baseRound,
    CurrentTermNumber = State.CurrentTermNumber.Value,
    CurrentRoundNumber = State.CurrentRoundNumber.Value,
    PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
    LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
    CurrentMaximumBlocksCount = GetMaximumBlocksCount(), // Add this
    ExtraData = extraData
};
```

This ensures that the validation enforces the current dynamically-adjusted limit, preventing miners from exceeding it even if the blockchain status changed after command generation.

## Proof of Concept

A test demonstrating this vulnerability would need to:

1. Initialize a blockchain in Normal status with `GetMaximumBlocksCount()` returning 8
2. Have a miner request a consensus command and begin producing tiny blocks
3. Simulate the blockchain entering Severe status (by not advancing LIB for multiple rounds)
4. Verify that `GetMaximumBlocksCount()` now returns 1
5. Demonstrate that the miner can still produce up to 8 blocks total before the counter prevents further blocks
6. Show that this exceeds the current maximum of 1 by 8x

The test would validate that blocks 4-8 are accepted even though the current limit is 1, proving the counter mechanism fails to enforce the dynamically-adjusted limit for the same miner.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L44-46)
```csharp
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L26-32)
```csharp
        protected ConsensusBehaviourProviderBase(Round currentRound, string pubkey, int maximumBlocksCount,
            Timestamp currentBlockTime)
        {
            CurrentRound = currentRound;

            _pubkey = pubkey;
            _maximumBlocksCount = maximumBlocksCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-62)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L68-69)
```csharp
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-357)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L359-363)
```csharp
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L42-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L119-129)
```csharp
        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
