# Audit Report

## Title
Signature Forgery Enables Mining Order Manipulation in AEDPoS Consensus

## Summary
The AEDPoS consensus validation fails to verify that miner-provided signature values are cryptographically correct, allowing malicious miners to forge arbitrary signatures and manipulate their mining position in subsequent rounds. This breaks the fundamental randomness guarantee of the consensus mechanism.

## Finding Description

The AEDPoS consensus mechanism calculates mining order for the next round based on a signature value that should be computed as `XOR(inValue, XOR of all previous miner signatures)` [1](#0-0) . During honest block production, this signature is calculated using `CalculateSignature()` [2](#0-1) .

However, the validation flow never verifies this calculation. When processing UpdateValue behavior, `RecoverFromUpdateValue()` directly copies the signature from provided data without any cryptographic verification [3](#0-2) . It also copies `SupposedOrderOfNextRound` values for all miners from the provided round [4](#0-3) .

The `UpdateValueValidationProvider` performs only superficial validation, checking that signature and outvalue are non-empty [5](#0-4) , but never verifies the signature matches what `CalculateSignature()` would produce.

Subsequently, `ProcessUpdateValue()` directly assigns both the signature and `SupposedOrderOfNextRound` from user input to the miner's round information [6](#0-5) .

The vulnerability exists because `SupposedOrderOfNextRound` is calculated directly from the signature value using modulo arithmetic [7](#0-6) . When transitioning to the next round, miners who successfully mined are assigned their `FinalOrderOfNextRound` value as their actual mining order [8](#0-7) .

**Attack Execution:**
1. Malicious miner calculates desired order position (e.g., order = 1 for mining first)
2. Works backwards to find a signature value where `signature.ToInt64() % minersCount == (desiredOrder - 1)`
3. Constructs `UpdateValueInput` with the forged signature and corresponding `SupposedOrderOfNextRound`
4. Submits the block with this consensus data during their mining time slot
5. Validation passes because no signature correctness check exists
6. The forged order value propagates to the next round as their actual mining position

## Impact Explanation

**Critical Consensus Integrity Breach:**
This vulnerability breaks the core security property that mining order must be unpredictably randomized. A malicious miner can consistently choose to mine first in each round, providing them with:
- Maximum MEV (Miner Extractable Value) opportunities to extract value from transaction ordering
- Ability to reorder or censor transactions within their block production window
- Greater influence over which transactions get included in blocks
- First-mover advantage in capturing profitable transactions
- Potential for unfair reward accumulation across multiple rounds

The randomness guarantee is fundamental to consensus fairness - without it, the protocol cannot ensure equal opportunity among miners. This affects all network participants by allowing systematic value extraction by malicious miners at the expense of fair competition.

**Severity: CRITICAL** - Directly compromises a foundational security property of the blockchain consensus mechanism, enabling ongoing exploitation without detection.

## Likelihood Explanation

**High Likelihood:**

The attacker must be an authorized miner (verified by existing permission checks), which is a realistic precondition since the attack is performed BY a miner during their legitimate mining window, not against the authorization system itself.

**Attack Complexity: LOW**
- Simple arithmetic calculation to determine the signature value needed for desired order
- No complex preconditions or state manipulation required
- Executed through normal block production operations
- No additional transactions or approvals needed

**Detection: IMPOSSIBLE**
- All existing validation checks pass with forged values
- The post-execution hash comparison in `ValidateConsensusAfterExecution` succeeds because `RecoverFromUpdateValue()` modifies the current round to match provided data before comparison [9](#0-8) 
- No on-chain mechanism can detect the forgery without re-computing the expected signature using `CalculateSignature()`
- Repeatable every round without risk of detection

## Recommendation

Add signature verification to the validation flow:

```csharp
private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var previousInValue = minerInRound.PreviousInValue;
    
    if (previousInValue == null || previousInValue == Hash.Empty) 
        return true; // Skip validation for first round or missing previousInValue
    
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    return minerInRound.Signature == expectedSignature;
}
```

Add this check to `UpdateValueValidationProvider.ValidateHeaderInformation()` and reject blocks where the signature doesn't match the expected value calculated via `CalculateSignature()`.

Additionally, verify that `SupposedOrderOfNextRound` matches the value calculated from the signature:
```csharp
var expectedOrder = GetAbsModulus(minerInRound.Signature.ToInt64(), minersCount) + 1;
if (minerInRound.SupposedOrderOfNextRound != expectedOrder)
    return new ValidationResult { Message = "Incorrect SupposedOrderOfNextRound." };
```

## Proof of Concept

The vulnerability can be demonstrated with a test that:
1. Sets up a round with multiple miners
2. Constructs an `UpdateValueInput` with a forged signature designed to produce `SupposedOrderOfNextRound = 1`
3. Processes the update through `ProcessConsensusInformation()`
4. Verifies the forged order value is accepted and propagates to the next round
5. Shows that validation passes despite the signature being cryptographically incorrect

The key assertion would verify that a miner can achieve any desired order position by choosing an appropriate signature value, without the signature matching what `CalculateSignature()` would produce from their actual `previousInValue`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L17-17)
```csharp
        minerInRound.Signature = providedInformation.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L24-25)
```csharp
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-246)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-32)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L91-101)
```csharp
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```
