# Audit Report

## Title
State Corruption in UpdateTokenHolderProfitScheme Enables Unauthorized Profit Scheme Manipulation

## Summary
The `UpdateTokenHolderProfitScheme` function in the TokenHolder contract writes scheme data to the wrong state entry (`Context.Sender` instead of `manager` parameter), causing persistent state corruption. When users register for another manager's profit scheme via `RegisterForProfits`, their own state entry gets overwritten with that manager's scheme data. Attackers exploit this corrupted state by calling `AddBeneficiary` or `RemoveBeneficiary`, which then operate on the victim's scheme instead of their own. The Profit contract's authorization bypass for TokenHolder contract allows these unauthorized operations to succeed, enabling direct fund theft.

## Finding Description

**Root Cause:**

The `UpdateTokenHolderProfitScheme` function receives a `manager` parameter indicating which scheme to update, but incorrectly writes the updated scheme to `State.TokenHolderProfitSchemes[Context.Sender]` instead of `State.TokenHolderProfitSchemes[manager]`. [1](#0-0) 

The function fetches scheme data for the `manager` address from the Profit contract, but then writes it to the caller's state entry at line 298, causing state corruption whenever `Context.Sender != manager`.

**Exploitation Sequence:**

1. **Setup Phase**: Alice creates a profit scheme using `CreateScheme`, which stores her scheme configuration at `State.TokenHolderProfitSchemes[Alice]` and registers it with the Profit contract.

2. **State Corruption Phase**: Bob calls `RegisterForProfits(schemeManager=Alice, amount=100)` to participate in Alice's scheme. This triggers:
   - `GetValidScheme(Alice)` at line 152 [2](#0-1) 
   - Which calls `UpdateTokenHolderProfitScheme(ref scheme, manager=Alice, updateSchemePeriod=false)`
   - The function fetches Alice's SchemeId from the Profit contract
   - **Bug triggers**: Line 298 writes Alice's scheme data to `State.TokenHolderProfitSchemes[Bob]`
   - Bob's state entry now contains Alice's SchemeId and Period

3. **Exploitation Phase**: Bob calls `AddBeneficiary(beneficiary=Bob, shares=1000000)`:
   - This calls `GetValidScheme(Context.Sender)` which is `GetValidScheme(Bob)` [3](#0-2) 
   - Loads the corrupted state containing Alice's SchemeId
   - Calls `State.ProfitContract.AddBeneficiary.Send()` with Alice's SchemeId
   - Bob successfully adds himself as beneficiary to Alice's scheme

4. **Authorization Bypass**: The Profit contract's `AddBeneficiary` function explicitly allows the TokenHolder contract to bypass manager verification: [4](#0-3) 

This design assumes TokenHolder correctly verifies caller permissions, but the state corruption bug breaks this assumption.

The same vulnerability affects `RemoveBeneficiary`, which also relies on the TokenHolder contract authorization: [5](#0-4) 

**Security Guarantees Broken:**
- Only scheme managers should control beneficiary additions/removals
- State mapping should correctly associate addresses with their own schemes
- Profit distribution should only reach authorized beneficiaries

## Impact Explanation

**Direct Financial Impact:**

Attackers can manipulate beneficiary lists of victim schemes by:
1. Adding themselves with arbitrary share weights (e.g., 1,000,000 shares)
2. Removing legitimate beneficiaries
3. Claiming profits proportional to their unauthorized shares

**Quantified Scenario:**
- Alice's scheme has 1,000 total shares distributed to legitimate beneficiaries
- Bob exploits the vulnerability to add himself with 1,000,000 shares
- Total shares become 1,001,000
- Bob now captures 99.9% of all future profit distributions
- Legitimate beneficiaries lose 99.9% of their expected rewards

**Systemic Impact:**
- Any TokenHolder profit scheme with external participants (users who called `RegisterForProfits`) is vulnerable
- State corruption persists indefinitely across transactions
- Multiple attackers can exploit the same scheme simultaneously
- The entire TokenHolder profit distribution mechanism integrity is compromised

**Severity: CRITICAL** - Direct theft of funds through unauthorized state manipulation, affecting core economic primitives with no special permissions required.

## Likelihood Explanation

**Attacker Requirements:**
- Basic blockchain interaction capability (wallet + transaction signing)
- Sufficient token balance to call `RegisterForProfits` (minimal amount, e.g., 1 token)
- Knowledge of target scheme manager address
- No governance control, special privileges, or compromised keys needed

**Attack Complexity:**
- **Low complexity**: 3 simple transactions with no timing constraints
  1. `RegisterForProfits(schemeManager=VictimAddress, amount=1)` - triggers corruption
  2. `AddBeneficiary(beneficiary=AttackerAddress, shares=1000000)` - exploits corruption
  3. `ClaimProfits()` - steals funds
- No race conditions or block timing dependencies
- State corruption occurs automatically as side effect of legitimate operations
- All transactions appear valid to external observers

**Preconditions:**
- Target scheme must exist (created via TokenHolder's `CreateScheme`)
- No additional constraints on scheme state or configuration
- Works regardless of existing beneficiary count or total shares

**Economic Incentive:**
- Attack cost: ~3 transaction fees (approximately 0.01-0.03 ELF)
- Potential gain: Proportional to all future profits in target scheme
- For active schemes distributing rewards, gain can be orders of magnitude higher than cost
- Risk/reward ratio extremely favorable for attackers

**Detection Difficulty:**
- No on-chain indicators of malicious activity
- Transactions use standard public methods with valid parameters
- State corruption not visible until unexpected beneficiary distributions occur

**Probability: HIGH** - The vulnerability is triggered by normal user interactions with predictable outcomes, requires minimal resources, and provides strong economic incentives with negligible risk.

## Recommendation

**Fix for UpdateTokenHolderProfitScheme:**

Change line 298 from:
```csharp
State.TokenHolderProfitSchemes[Context.Sender] = scheme;
```

To:
```csharp
State.TokenHolderProfitSchemes[manager] = scheme;
```

This ensures scheme updates are written to the correct manager's state entry, not the caller's entry.

**Additional Security Measures:**

1. Add validation in `GetValidScheme` to verify the loaded scheme belongs to the requested manager
2. Consider removing the TokenHolder authorization bypass in Profit contract and implementing explicit manager delegation
3. Add integration tests covering cross-user scheme interactions

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task ExploitStateCorruption_UnauthorizedBeneficiaryAddition()
{
    // Setup: Alice creates a scheme
    var aliceAddress = Address.FromPublicKey(AliceKeyPair.PublicKey);
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });
    
    // Get Alice's scheme ID from Profit contract
    var aliceSchemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = aliceAddress });
    var aliceSchemeId = aliceSchemeIds.SchemeIds.First();
    
    // Step 1: Bob registers for Alice's scheme (triggers state corruption)
    var bobStub = GetTokenHolderContractStub(BobKeyPair);
    await bobStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = aliceAddress,
        Amount = 100
    });
    
    // Verify Bob's state is corrupted with Alice's SchemeId
    var bobScheme = await bobStub.GetScheme.CallAsync(Address.FromPublicKey(BobKeyPair.PublicKey));
    Assert.Equal(aliceSchemeId, bobScheme.SchemeId); // Bob's entry contains Alice's SchemeId!
    
    // Step 2: Bob exploits corrupted state to add himself to Alice's scheme
    await bobStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = Address.FromPublicKey(BobKeyPair.PublicKey),
        Shares = 1000000 // Bob adds massive shares
    });
    
    // Verify Bob is now a beneficiary of Alice's scheme
    var bobProfitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(
        new GetProfitDetailsInput
        {
            SchemeId = aliceSchemeId,
            Beneficiary = Address.FromPublicKey(BobKeyPair.PublicKey)
        });
    
    Assert.True(bobProfitDetails.Details.Count > 0); // Bob successfully added to Alice's scheme!
    Assert.Equal(1000000, bobProfitDetails.Details.First().Shares); // With unauthorized shares
    
    // Impact: Bob can now claim profits from Alice's scheme
}
```

This test demonstrates:
1. Alice creates a legitimate profit scheme
2. Bob calls `RegisterForProfits` with Alice as scheme manager, corrupting his own state
3. Bob exploits the corrupted state to add himself as beneficiary to Alice's scheme
4. Bob's unauthorized beneficiary entry is confirmed in the Profit contract

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-68)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }

        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = shares
            }
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-209)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

        // Check auto-distribute threshold.
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L237-239)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");
```
