# Audit Report

## Title
Inconsistent Vote Counting Allows Governance Bypass Through Member Removal

## Summary
The Association contract contains a critical vote counting inconsistency where rejection and abstention votes are filtered by current membership, but the total vote count for `MinimalVoteThreshold` includes all historical votes regardless of membership status. This allows legitimately rejected proposals to become releasable by removing members who voted to reject after voting has occurred.

## Finding Description

The vulnerability exists in the vote threshold validation logic within `IsReleaseThresholdReached()` and its helper methods. [1](#0-0) 

The `IsProposalRejected()` method filters rejection votes to count only those from current organization members. [2](#0-1) 

Similarly, `IsProposalAbstained()` filters abstention votes by current membership. [3](#0-2) 

However, `CheckEnoughVoteAndApprovals()` contains a critical inconsistency. While it correctly filters approval votes by current membership at line 49, the total vote count check for `MinimalVoteThreshold` at line 56 uses raw concatenation and counting of ALL votes WITHOUT filtering by membership status. [4](#0-3) 

Members can be removed from an organization via the `RemoveMember()` method, which is callable by the organization itself through proposals. [5](#0-4) 

The `Release()` method enforces these threshold checks before executing any proposal. [6](#0-5) 

Vote lists are permanently stored in `ProposalInfo` as repeated address fields that are never cleaned up when members are removed. [7](#0-6) 

**Attack Execution Path:**
1. Organization members cast votes on a controversial proposal
2. Proposal is initially rejected (rejection count > `MaximalRejectionThreshold`)
3. Coalition creates and passes member removal proposals targeting rejecting members
4. After removal, `IsProposalRejected()` now counts fewer rejections (only current members)
5. `CheckEnoughVoteAndApprovals()` still counts all historical votes toward `MinimalVoteThreshold`
6. Original proposal becomes releasable despite legitimate rejection

## Impact Explanation

**HIGH Severity** - This vulnerability directly undermines the governance security model by allowing rejection threshold bypass.

**Concrete Scenario:**
- Organization: 10 members
- Thresholds: `MinimalVoteThreshold=7`, `MinimalApprovalThreshold=4`, `MaximalRejectionThreshold=3`
- Proposal receives: 4 approvals, 4 rejections (8 total votes)
- Status: REJECTED (4 rejections > 3 threshold)
- Attack: Remove 3 rejecting members via separate proposals
- New calculation: 4 approvals (current members), 1 rejection (current member only), 8 total votes (ALL historical)
- Result: Proposal becomes releasable (1 rejection ≤ 3 threshold, 4 approvals ≥ 4 threshold, 8 votes ≥ 7 threshold)

**Broken Invariant:** The governance invariant that "proposals exceeding MaximalRejectionThreshold cannot be executed" is violated. Proposals that were democratically rejected through proper threshold mechanisms can be executed by post-voting manipulation.

**Affected Parties:** All Association contract organizations, as their rejection and abstention thresholds can be circumvented through strategic member removal after voting completes.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood**

**Attacker Requirements:**
- Sufficient voting power to pass member removal proposals (standard organization capability)
- Coordination between voting on target proposal and removing dissenting members
- No requirement for elevated privileges beyond standard organization membership

**Feasibility:** The attack is deterministic and requires no external dependencies. Both voting and member removal are standard organization operations that appear legitimate individually. The validation logic in `RemoveMember()` only ensures the organization remains valid (member count still satisfies configured thresholds), which doesn't prevent this attack.

**Realistic Conditions:** 
- Organizations where a coalition controls enough votes for proposals but faces minority opposition
- No time-lock or cooling-off mechanisms prevent sequential proposal execution
- Member management through proposals is an inherent design feature, not a misconfiguration

**Detection Difficulty:** The attack uses authorized operations in their intended manner - the vulnerability lies in the logical inconsistency between filtered and unfiltered vote counting, not unauthorized access.

## Recommendation

Apply consistent membership filtering to ALL vote counting operations. The total vote count in `CheckEnoughVoteAndApprovals()` should also filter by current membership:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter total votes by current membership
    var totalVotes = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
                     proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
                     proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached = totalVotes >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

This ensures that all threshold calculations (rejection, abstention, approval, and total vote count) consistently consider only current organization members, preventing the governance bypass.

## Proof of Concept

```csharp
[Fact]
public async Task GovernanceBypass_RemovingRejectingMembers_Test()
{
    // Setup organization with 10 members
    var members = Enumerable.Range(0, 10).Select(_ => SampleAddress.AddressList[_]).ToList();
    var proposers = new[] { DefaultSender };
    
    var organizationAddress = await CreateOrganizationAsync(new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList { OrganizationMembers = { members } },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { proposers } },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalVoteThreshold = 7,
            MinimalApprovalThreshold = 4,
            MaximalRejectionThreshold = 3,
            MaximalAbstentionThreshold = 10
        }
    });

    // Create controversial proposal
    var proposalId = await CreateProposalAsync(DefaultSender, organizationAddress);
    
    // Cast votes: 4 approvals, 4 rejections
    for (int i = 0; i < 4; i++)
        await ApproveAsync(members[i], proposalId);
    for (int i = 4; i < 8; i++)
        await RejectAsync(members[i], proposalId);
    
    // Verify proposal is REJECTED
    var proposalInfo = await GetProposalAsync(proposalId);
    proposalInfo.ToBeReleased.ShouldBeFalse(); // 4 rejections > 3 threshold
    
    // Attack: Remove 3 rejecting members (members[5], members[6], members[7])
    for (int i = 5; i < 8; i++)
    {
        var removeProposalId = await CreateRemoveMemberProposalAsync(organizationAddress, members[i]);
        // Coalition passes removal (4 approvers + 3 others)
        for (int j = 0; j < 7; j++)
            if (j < 4 || j >= 8) // Skip the member being removed
                await ApproveAsync(members[j], removeProposalId);
        await ReleaseProposalAsync(DefaultSender, removeProposalId);
    }
    
    // Verify: Original proposal is now RELEASABLE (governance bypass!)
    proposalInfo = await GetProposalAsync(proposalId);
    proposalInfo.ToBeReleased.ShouldBeTrue(); // VULNERABILITY: Now releasable despite rejection
}
```

**Notes:**
- This vulnerability represents a fundamental flaw in the Association contract's governance logic that affects all organizations using this contract.
- The inconsistency between filtered rejection/abstention counts and unfiltered total vote counts creates an exploitable governance bypass.
- The attack is particularly insidious because it uses legitimate governance operations (voting and member management) in ways that appear normal individually but violate governance guarantees when combined.
- Similar patterns should be audited in Parliament and Referendum contracts to ensure consistent vote counting across all governance contracts.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** protobuf/association_contract.proto (L91-96)
```text
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
```
