# Audit Report

## Title
Unvalidated Boolean Parsing in CrossChainCreate Enables NFT Protocol Creation DoS

## Summary
An attacker can create a token on mainchain with malicious `NftTokenIdReuseMetadataKey` values (e.g., "1", "yes") by directly calling the MultiToken contract's Create method. When cross-chained to sidechains and `CrossChainCreate()` is invoked, the unprotected `bool.Parse()` call throws a `FormatException`, permanently preventing NFT protocol creation for that symbol.

## Finding Description

The vulnerability exists in the NFT contract's `CrossChainCreate()` method which retrieves token information and directly parses the boolean metadata value without validation or error handling. [1](#0-0) 

C#'s `bool.Parse()` only accepts "True"/"False" (case-insensitive) and throws `FormatException` for any other input like "1", "yes", etc.

The root cause is that the MultiToken contract's `Create()` method accepts arbitrary ExternalInfo values without validating their content or format. [2](#0-1) 

The validation method `AssertValidCreateInput` only checks token name length, symbol format, and decimals, but does not validate ExternalInfo content. [3](#0-2) 

While the NFT contract's `Create()` method properly sets this value using `bool.ToString()` which produces valid "True"/"False" strings, [4](#0-3)  an attacker can bypass the NFT contract entirely by calling MultiToken.Create directly.

The NFT contract validates that user-provided metadata does not contain reserved keys including `NftTokenIdReuseMetadataKey`. [5](#0-4) [6](#0-5) 

An attacker can bypass this by calling MultiToken.Create directly. The only requirement is possessing a seed NFT for the target symbol or being whitelisted. [7](#0-6) 

Once created, the malicious token can be legitimately cross-chained via `CrossChainCreateToken`, which validates token existence but preserves the malicious ExternalInfo values without any content validation. [8](#0-7) 

The sidechain's duplicate protocol check only prevents re-creation after success, not after repeated failures. [9](#0-8)  Since the transaction fails at line 88 before setting `State.NftProtocolMap[input.Symbol]` at line 108, the protocol remains null and the check passes on subsequent attempts, but the parsing error recurs every time.

There is no method to update or override NFTProtocolInfo after creation or governance mechanism to recover from poisoned symbols.

## Impact Explanation

**Operational Impact - DoS of NFT Protocol Creation:**
- When `CrossChainCreate()` is called on a sidechain for a poisoned token symbol, the unhandled `FormatException` causes transaction failure
- Since the protocol state remains null, the duplicate check passes on subsequent attempts
- However, the parsing error recurs on every attempt, creating permanent DoS
- This blocks legitimate NFT functionality for that symbol namespace on affected sidechains
- Multiple symbols can be poisoned if the attacker obtains multiple seed NFTs
- No fund loss occurs, but NFT protocol deployment becomes impossible for affected symbols

**Severity Justification:** Medium - Operational DoS with no direct fund impact, but permanently damages protocol functionality on sidechains for affected symbols. The attack requires obtaining seed NFTs but is otherwise straightforward to execute.

## Likelihood Explanation

**Attacker Capabilities:**
- Must obtain seed NFTs for target symbols (e.g., "XX123456" with valid NFT type prefix like "XX")
- Seed NFTs can be purchased or obtained through normal protocol mechanisms
- No special privileges or compromised roles required beyond seed NFT ownership

**Attack Complexity:**
- Low - straightforward execution path:
  1. Obtain seed NFT for desired symbol
  2. Call `MultiToken.Create()` with malicious ExternalInfo containing invalid boolean strings
  3. Call `ValidateTokenInfoExists()` on mainchain to establish cross-chain proof
  4. Call `CrossChainCreateToken()` on sidechain with merkle proof
  5. Any call to `CrossChainCreate()` â†’ permanent transaction failure

**Economic Rationality:**
- Cost: Seed NFT acquisition price + transaction fees
- Detection: Malicious ExternalInfo visible on-chain but may not be detected before cross-chaining
- Attack is economically feasible for targeted DoS scenarios

**Probability:** High - All preconditions are realistic and execution is straightforward under normal AElf contract semantics. Seed NFTs are obtainable through standard mechanisms.

## Recommendation

Add try-catch error handling and validation in the `CrossChainCreate` method:

```csharp
var isTokenIdReuse = false;
if (tokenInfo.ExternalInfo.Value.TryGetValue(NftTokenIdReuseMetadataKey, out var reuseValue))
{
    if (!bool.TryParse(reuseValue, out isTokenIdReuse))
    {
        // Handle invalid value - either throw meaningful error or default to false
        throw new AssertionException($"Invalid {NftTokenIdReuseMetadataKey} value: {reuseValue}");
    }
}
```

Additionally, consider adding validation in `MultiToken.Create()` for known metadata keys used by other contracts, or implement a metadata validation callback mechanism.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreate_WithInvalidBooleanMetadata_ShouldFail()
{
    // Setup: Create a token on mainchain with malicious ExternalInfo
    var maliciousExternalInfo = new ExternalInfo();
    maliciousExternalInfo.Value["aelf_nft_token_id_reuse"] = "1"; // Invalid boolean
    
    // Attacker calls MultiToken.Create directly (bypassing NFT contract)
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "XX123456",
        TokenName = "Malicious",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = DefaultAddress,
        IsBurnable = true,
        ExternalInfo = maliciousExternalInfo
    });
    
    // Token is cross-chained to sidechain (simulation)
    // Now attempt CrossChainCreate on sidechain
    var result = await NFTContractStub.CrossChainCreate.SendWithExceptionAsync(
        new CrossChainCreateInput { Symbol = "XX123456" }
    );
    
    // Should throw FormatException due to bool.Parse("1")
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("FormatException");
}
```

## Notes

The claim contained one minor inaccuracy: "TRUE" was listed as an invalid boolean string, but C#'s `bool.Parse()` is case-insensitive, so "TRUE", "True", and "true" all parse correctly. However, "1", "yes", "0", "no" and other non-boolean strings correctly trigger `FormatException`, confirming the core vulnerability.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L79-79)
```csharp
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L88-88)
```csharp
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L186-186)
```csharp
        if (input.Metadata != null) AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L199-199)
```csharp
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L501-501)
```csharp
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L97-107)
```csharp
    private List<string> GetNftMetadataReservedKeys()
    {
        return new List<string>
        {
            NftTypeMetadataKey,
            NftBaseUriMetadataKey,
            AssembledNftsKey,
            AssembledFtsKey,
            NftTokenIdReuseMetadataKey
        };
    }
```
