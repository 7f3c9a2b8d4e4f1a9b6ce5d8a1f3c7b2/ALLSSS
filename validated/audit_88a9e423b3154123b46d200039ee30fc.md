# Audit Report

## Title
Consensus Behavior Spoofing Enables Bypass of UpdateValue Validation Requirements

## Summary
The AEDPoS consensus validation logic blindly trusts the `Behaviour` field in block headers without verifying it matches the expected behavior determined by consensus state. A malicious miner can claim `TinyBlock` behavior when they should provide `UpdateValue`, bypassing OutValue and Signature validation requirements, thereby evading cryptographic consensus commitments while still receiving block rewards.

## Finding Description

The vulnerability exists because the validation flow trusts the miner-supplied `Behaviour` field without cross-checking it against what the consensus rules mandate.

**Expected Behavior Determination:**
The `GetConsensusBehaviour()` method calculates what behavior a miner SHOULD exhibit based on consensus state. When a miner has `OutValue == null` and their time slot hasn't passed, it returns `UpdateValue` behavior. [1](#0-0) 

**Validation Bypass:**
However, the `ValidateBeforeExecution` method uses `extraData.Behaviour` directly from the block header to determine which recovery method to use and which validation providers to apply, without ever verifying this matches the expected behavior. [2](#0-1) 

**Differential Recovery:**
The system uses different recovery methods based on the claimed behavior:
- `RecoverFromUpdateValue` restores OutValue, Signature, PreviousInValue, and other critical fields [3](#0-2) 
- `RecoverFromTinyBlock` only restores ImpliedIrreversibleBlockHeight and ActualMiningTimes, omitting OutValue and Signature [4](#0-3) 

**Validation Provider Selection:**
The `UpdateValueValidationProvider`, which validates OutValue and Signature presence, is ONLY added when `extraData.Behaviour == UpdateValue`. For TinyBlock behavior, this critical validator is skipped. [5](#0-4) 

**Transaction Routing:**
The transaction generation uses the claimed behavior to decide which method to call - `UpdateValue` versus `UpdateTinyBlockInformation`. [6](#0-5) 

**State Update Divergence:**
- `ProcessUpdateValue` updates OutValue, Signature, PreviousInValue, and ProducedBlocks [7](#0-6) 
- `ProcessTinyBlock` only updates ActualMiningTimes and ProducedBlocks, NOT OutValue or Signature [8](#0-7) 

**Attack Path:**
A malicious miner whose OutValue is null (should use UpdateValue) modifies their node to set `Behaviour = TinyBlock` in block headers. During validation, other nodes call `RecoverFromTinyBlock` and skip the `UpdateValueValidationProvider`, allowing the block to pass validation. The resulting `UpdateTinyBlockInformation` transaction increments ProducedBlocks but leaves OutValue and Signature null, violating consensus obligations while claiming rewards.

## Impact Explanation

**Consensus Integrity Compromise:**
- The random number generation chain breaks as miners can skip providing OutValue, which is computed as the hash of their InValue and forms the basis for secure randomness in AEDPoS
- Signature-based accountability is eliminated since miners avoid publishing signatures that commit them to their consensus participation
- The secret sharing mechanism for random number generation degrades as fewer miners contribute their cryptographic commitments

**Protocol Fairness Violation:**
- Miners receive block production rewards (ProducedBlocks counter incremented) without fulfilling the complete consensus obligations required by the UpdateValue behavior
- This creates an asymmetric advantage for malicious miners who avoid cryptographic overhead while honest miners bear the full computational cost
- The consensus mechanism's security guarantees weaken proportionally to the number of miners exploiting this bypass

**Affected Parties:**
- All network participants relying on the security properties of AEDPoS consensus
- Applications depending on the quality of on-chain random numbers
- Honest miners who properly fulfill UpdateValue requirements face unfair competition

The severity is Medium because while this doesn't enable direct fund theft, it fundamentally undermines consensus integrity and enables selective protocol violation that degrades the security foundation of the entire chain.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must control a block producer node (requires becoming a miner through normal election mechanisms, achievable with sufficient staked tokens and votes)
- Needs full control over their node software to modify block header generation logic
- Must be in their assigned time slot when OutValue is null (occurs naturally on their first block in each round)

**Attack Complexity:**
The attack is technically straightforward - simply modify the node's block production logic to set `Behaviour = TinyBlock` instead of the correct `UpdateValue` when generating the `AElfConsensusHeaderInformation`. No complex cryptographic operations, state manipulation, or timing windows are required beyond normal block production. [9](#0-8) 

**Detection Constraints:**
- The attack is observable by monitoring round state - other nodes can see that a miner's OutValue remains null after producing blocks
- However, there is no automatic validation or penalty mechanism in the validation code to reject such blocks or punish the offending miner
- Detection requires manual monitoring and governance intervention, which may be slow or ineffective

**Feasibility Assessment:**
Medium likelihood - technically simple for any miner to execute with modified node software, but carries reputational risk if detected. The lack of automated prevention makes exploitation practical, though the visibility of missing OutValue fields in state provides some deterrent.

## Recommendation

Add explicit behavior verification in the `ValidateBeforeExecution` method:

1. After retrieving the current round information, call the same behavior determination logic (`GetConsensusBehaviour`) to calculate what behavior the miner SHOULD be using based on their current state
2. Compare the calculated expected behavior against `extraData.Behaviour` from the block header
3. Return a validation failure if they don't match

Example conceptual fix:
```csharp
// In ValidateBeforeExecution, after line 20:
var expectedBehaviour = IsMainChain
    ? new MainChainConsensusBehaviourProvider(baseRound, extraData.SenderPubkey.ToHex(),
            GetMaximumBlocksCount(), Context.CurrentBlockTime, GetBlockchainStartTimestamp(), 
            State.PeriodSeconds.Value).GetConsensusBehaviour()
    : new SideChainConsensusBehaviourProvider(baseRound, extraData.SenderPubkey.ToHex(),
            GetMaximumBlocksCount(), Context.CurrentBlockTime).GetConsensusBehaviour();

if (extraData.Behaviour != expectedBehaviour)
    return new ValidationResult { 
        Success = false, 
        Message = $"Behaviour mismatch: claimed {extraData.Behaviour}, expected {expectedBehaviour}" 
    };
```

This ensures miners cannot claim arbitrary behaviors that bypass validation requirements.

## Proof of Concept

A complete proof of concept would require:

1. Setting up an AElf test network with multiple miner nodes
2. Modifying one miner node's block production logic in `GetConsensusExtraData` to force `Behaviour = TinyBlock` when `GetConsensusBehaviour()` would return `UpdateValue`
3. Observing that the modified miner successfully produces blocks that pass validation
4. Verifying in the consensus state that the miner's OutValue and Signature remain null despite ProducedBlocks being incremented
5. Confirming the miner receives block rewards without fulfilling UpdateValue obligations

The core vulnerability is evident from the code structure where validation uses `extraData.Behaviour` without verification against expected behavior, and the differential handling in recovery methods and validation provider selection creates the exploitable gap.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-115)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }

        /// <summary>
        ///     If this miner come to a new round, normally, there are three possible behaviour:
        ///     UPDATE_VALUE (most common)
        ///     TINY_BLOCK (happens if this miner is mining blocks for extra block time slot of previous round)
        ///     NEXT_ROUND (only happens in first round)
        /// </summary>
        /// <returns></returns>
        private AElfConsensusBehaviour HandleMinerInNewRound()
        {
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;

            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;

            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-92)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L135-163)
```csharp
        switch (behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                Context.LogDebug(() =>
                    $"Previous in value in extra data:{round.RealTimeMinersInformation[pubkey.ToHex()].PreviousInValue}");
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
                };
            case AElfConsensusBehaviour.TinyBlock:
                var minerInRound = round.RealTimeMinersInformation[pubkey.ToHex()];
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateTinyBlockInformation),
                            new TinyBlockInput
                            {
                                ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
                                ProducedBlocks = minerInRound.ProducedBlocks,
                                RoundId = round.RoundIdForValidation,
                                RandomNumber = randomNumber
                            })
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L26-48)
```csharp
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
        }
```
