# Audit Report

## Title
Parliament Proposal Threshold Calculations Use Dynamic Miner Count Leading to Incorrect Approval/Rejection Outcomes

## Summary
The Parliament contract calculates proposal approval thresholds using the current miner list count at the time of release, rather than snapshotting the parliament size when the proposal was created or when votes were cast. When the miner count changes during consensus term transitions, proposals that legitimately met approval thresholds can fail to release, or proposals that should fail can pass, violating governance integrity.

## Finding Description
The Parliament contract stores proposal votes as address lists but does not snapshot the parliament size at proposal creation time. [1](#0-0) 

When a proposal is checked for release, the contract dynamically retrieves the CURRENT miner list from the consensus contract. [2](#0-1) 

The current miner list is obtained by calling the consensus contract's `GetCurrentMinerList()` method. [3](#0-2) 

This method returns miners from the current round's `RealTimeMinersInformation`, which represents the active miners at query time. [4](#0-3) 

All threshold calculations use `parliamentMembers.Count` as the denominator, which represents the current parliament size at check time:

- Approval threshold calculation uses the current count. [5](#0-4) 
- Rejection threshold calculation uses the current count. [6](#0-5) 
- Abstention threshold calculation uses the current count. [7](#0-6) 
- Vote threshold calculation uses the current count. [8](#0-7) 

The `Release` method invokes `IsReleaseThresholdReached()` which performs these calculations using the current miner count. [9](#0-8) 

The miner list changes during consensus term transitions. The `ProcessNextTerm` method updates the miner list by calling `SetMinerList`. [10](#0-9) 

The `SetMinerList` method updates `State.MainChainCurrentMinerList` and `State.MinerListMap[termNumber]`, changing the active parliament composition. [11](#0-10) 

Test evidence confirms that miner counts change during term transitions, with the test showing an increase of 2 miners per term. [12](#0-11) 

Test configuration sets `IsTermStayOne = true` for testing, indicating production uses `IsTermStayOne = false`, enabling term transitions. [13](#0-12) 

The `AbstractVoteTotal` constant is 10000, used as the numerator scaling factor in all threshold calculations. [14](#0-13) 

This creates a window of vulnerability between proposal creation/voting and release where the parliament size can change, causing threshold calculations to use incorrect denominators.

## Impact Explanation

**Governance Integrity Violation:**

**Scenario 1 - Legitimate proposals fail:**
A proposal receives 7 approvals from a 9-member parliament (77.8%), meeting the default 66.67% approval threshold:
- Calculation at voting time: `7 * 10000 >= 6667 * 9` → `70000 >= 60003` ✓ PASS
- Parliament grows to 12 members before release
- Calculation at release time: `7 * 10000 >= 6667 * 12` → `70000 >= 80004` ✗ FAIL
- Result: Legitimately approved proposal cannot be released

**Scenario 2 - Invalid proposals pass rejection:**
A proposal receives 2 rejections from a 10-member parliament (20%), at the exact default 20% rejection threshold:
- Calculation at voting time: `2 * 10000 > 2000 * 10` → `20000 > 20000` ✗ FALSE (not rejected)
- Parliament shrinks to 8 members before release
- Calculation at release time: `2 * 10000 > 2000 * 8` → `20000 > 16000` ✓ TRUE (rejected)
- Result: Proposal that should pass is incorrectly rejected

**Affected Parties:**
- All parliament organizations (default organization, custom organizations, emergency response organization)
- System upgrades and configuration changes controlled by parliament
- Treasury operations and economic parameter adjustments
- Cross-chain operations requiring parliament approval
- Any governance action dependent on parliament approval integrity

**Severity Justification - HIGH:**
1. **Violates fundamental governance invariant:** The core principle that proposals meeting approval thresholds should pass is broken
2. **No privilege escalation required:** Triggered by normal consensus operations
3. **Affects critical system operations:** System upgrades, fee structures, treasury distributions
4. **Silent failure mode:** No warning mechanism; proposals appear valid but behave unexpectedly
5. **Affects all parliament organizations:** Not limited to a single organization or edge case

## Likelihood Explanation

**Trigger Conditions:**
This vulnerability is triggered whenever all of the following occur:
1. A proposal is created before a consensus term transition
2. The proposal receives votes that place it near threshold boundaries
3. A term transition occurs, changing the miner count
4. The proposal is released after the term transition

**Feasibility - HIGH:**

**No special attacker capabilities required:**
- Term transitions are normal blockchain operations that occur regularly in AEDPoS consensus
- Any user can call `Release()` on proposals they created once thresholds appear to be met
- No special privileges, compromised keys, or consensus manipulation needed

**Attack complexity - LOW:**
- Passive exploitation: Legitimate proposals can fail during natural term transitions without malicious intent
- Active exploitation: An adversary can monitor pending proposals and strategically time release attempts around known term transitions
- Proposals typically have multi-day expiration windows (common governance practice), creating large overlap windows with term transition periods

**Frequency of occurrence:**
- Consensus term transitions occur regularly (evidence from test suite showing term changes are expected behavior)
- Miner count changes are explicitly tested and designed into the system (test shows +2 miners per term)
- Production configuration enables term transitions (`IsTermStayOne = false` in production vs `true` in tests)
- Multiple proposals often pending simultaneously, increasing probability of affected proposals

**Probability:**
HIGH - The combination of regular term transitions, multi-day proposal lifetimes, and proposals near threshold boundaries makes this scenario highly probable in production environments.

## Recommendation

**Solution: Snapshot Parliament Size at Proposal Creation**

Modify the `ProposalInfo` structure to include a `ParliamentMemberCount` field that captures the parliament size at proposal creation time.

**Implementation steps:**

1. Add parliament count field to proposal storage:
```csharp
// In ProposalInfo message (protobuf)
int32 parliament_member_count = [next_available_field_number];
```

2. Snapshot the count during proposal creation in `CreateNewProposal`:
```csharp
var proposalId = GenerateProposalId(input);
var currentParliament = GetCurrentMinerList();
var proposal = new ProposalInfo
{
    // ... existing fields ...
    ParliamentMemberCount = currentParliament.Count
};
```

3. Use the snapshotted count in threshold calculations:
```csharp
private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
{
    var parliamentMembers = GetCurrentMinerList();
    var storedParliamentCount = proposal.ParliamentMemberCount;
    
    // Use storedParliamentCount instead of parliamentMembers.Count in calculations
    var isRejected = IsProposalRejected(proposal, organization, parliamentMembers, storedParliamentCount);
    // ... rest of logic
}
```

4. Update all threshold helper methods to accept and use the snapshotted count:
```csharp
private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
    ICollection<Address> parliamentMembers, int parliamentMemberCount)
{
    var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
    return rejectionMemberCount * AbstractVoteTotal >
           organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMemberCount;
}
```

**Alternative approach:** If snapshotting is not desired for compatibility reasons, add validation that prevents releasing proposals if the parliament size has changed since the last vote was cast, forcing re-approval with the new parliament composition.

## Proof of Concept

```csharp
[Fact]
public async Task Parliament_Proposal_Fails_When_MinerCount_Increases_After_Voting()
{
    // Setup: Initialize parliament with 9 miners
    var initialMiners = InitialCoreDataCenterKeyPairs.Take(9).ToList();
    await InitializeParliamentWithMiners(initialMiners);
    
    // Create proposal requiring 66.67% approval (6667/10000)
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = DefaultOrganizationAddress,
        ToAddress = TokenContractAddress,
        ContractMethodName = nameof(TokenContractStub.Transfer),
        Params = new TransferInput { To = UserAddress, Amount = 100 }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(7)
    };
    var proposalId = await ParliamentContractStub.CreateProposal.SendAsync(proposalInput);
    
    // 7 out of 9 miners approve (77.8% > 66.67% threshold)
    for (int i = 0; i < 7; i++)
    {
        var minerStub = GetParliamentContractTester(initialMiners[i]);
        await minerStub.Approve.SendAsync(proposalId.Output);
    }
    
    // Verify proposal meets threshold with 9 miners
    var proposal = await ParliamentContractStub.GetProposal.CallAsync(proposalId.Output);
    proposal.ToBeReleased.ShouldBeTrue(); // 7/9 = 77.8% >= 66.67%
    
    // Simulate term transition that adds 3 more miners (9 -> 12)
    var newMiners = InitialCoreDataCenterKeyPairs.Skip(9).Take(3).ToList();
    await SimulateTermTransitionWithNewMiners(newMiners);
    
    // Verify miner count increased to 12
    var currentMinerList = await ConsensusContractStub.GetCurrentMinerList.CallAsync(new Empty());
    currentMinerList.Pubkeys.Count.ShouldBe(12);
    
    // Attempt to release - should succeed but will FAIL due to bug
    // 7/12 = 58.3% < 66.67% threshold
    var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId.Output);
    
    // BUG DEMONSTRATED: Release fails despite having legitimate approval
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // Verify proposal now shows as not meeting threshold
    var proposalAfter = await ParliamentContractStub.GetProposal.CallAsync(proposalId.Output);
    proposalAfter.ToBeReleased.ShouldBeFalse(); // Same 7 approvals now insufficient
}
```

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L13-20)
```csharp
    private List<Address> GetCurrentMinerList()
    {
        RequireConsensusContractStateSet();
        var miner = State.ConsensusContract.GetCurrentMinerList.Call(new Empty());
        var members = miner.Pubkeys.Select(publicKey =>
            Address.FromPublicKey(publicKey.ToByteArray())).ToList();
        return members;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-70)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L72-78)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(parliamentMembers.Contains);
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L94-102)
```csharp
    private bool IsVoteThresholdReached(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
                .Count(parliamentMembers.Contains) * AbstractVoteTotal >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold * parliamentMembers.Count;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L225-253)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L31-42)
```csharp
    public override MinerList GetCurrentMinerList(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var round)
            ? new MinerList
            {
                Pubkeys =
                {
                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))
                }
            }
            : new MinerList();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-191)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/MinersCountTest.cs (L110-119)
```csharp
        while (minerCount < maxCount)
        {
            var currentRound = await newMinerStub.GetCurrentRoundInformation.CallAsync(new Empty());
            var firstPubKey = currentRound.RealTimeMinersInformation.Keys.First();
            var keypair = ValidationDataCenterKeyPairs.First(o => o.PublicKey.ToHex() == firstPubKey);
            newMinerStub = GetAEDPoSContractStub(keypair);

            minerCount = currentRound.RealTimeMinersInformation.Count;
            Assert.Equal(AEDPoSContractTestConstants.SupposedMinersCount.Add(termCount.Mul(2)), minerCount);

```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTestBase.cs (L151-156)
```csharp
    private async Task InitializeConsensusAsync()
    {
        await ConsensusContractStub.InitialAElfConsensusContract.SendAsync(new InitialAElfConsensusContractInput
        {
            IsTermStayOne = true
        });
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L1-10)
```csharp
namespace AElf.Contracts.Parliament;

public partial class ParliamentContract
{
    private const int DefaultOrganizationMinimalApprovalThreshold = 6667;
    private const int DefaultOrganizationMaximalAbstentionThreshold = 2000;
    private const int DefaultOrganizationMaximalRejectionThreshold = 2000;
    private const int DefaultOrganizationMinimalVoteThresholdThreshold = 7500;
    private const int AbstractVoteTotal = 10000;
}
```
