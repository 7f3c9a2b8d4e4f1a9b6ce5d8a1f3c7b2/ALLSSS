# Audit Report

## Title
Malicious DecryptedPieces Can Corrupt Secret Sharing Reconstruction Due to Improper Signed BigInteger Handling

## Summary
The Shamir secret sharing reconstruction in AElf consensus contains a critical flaw where malicious miners can submit crafted `DecryptedPieces` byte arrays that produce negative BigInteger values, causing incorrect finite field arithmetic and corrupting revealed InValues stored in consensus state.

## Finding Description

The vulnerability exists in the secret sharing reconstruction flow used by the AEDPoS consensus mechanism. When miners submit `UpdateValue` transactions, they provide `DecryptedPieces` for other miners' encrypted secret shares. These pieces are later used to reconstruct the original InValues through Shamir's Secret Sharing scheme.

The core issue is in the `SecretSharingHelper.DecodeSecret` method. At the reconstruction stage, DecryptedPieces are converted to BigIntegers without validation using the standard BigInteger constructor which interprets byte arrays as signed integers in little-endian two's complement format. [1](#0-0) 

When a byte array has its most significant byte with the high bit set (â‰¥ 0x80), the resulting BigInteger becomes negative. The codebase provides an `Abs()` extension method specifically designed to handle this issue by applying modular arithmetic correctly. [2](#0-1) 

This behavior is confirmed by unit tests showing that byte arrays like `[0xFF, 0xFF]` create `-1` instead of positive values, which the `Abs()` method then corrects. [3](#0-2) 

However, `DecodeSecret` does not use this extension method, causing incorrect finite field arithmetic when processing malicious DecryptedPieces.

**Attack Vector:**

The attack exploits the `UpdateValue` consensus behavior. When miners submit their consensus data, they include `DecryptedPieces` which are stored without validation. [4](#0-3) 

The validation providers only check OutValue, Signature, and PreviousInValue matching, but completely ignore DecryptedPieces content validation. [5](#0-4) 

When transitioning to the next round, `RevealSharedInValues` is called on-chain to reconstruct other miners' InValues using the stored DecryptedPieces. [6](#0-5) 

The reconstructed InValue is then stored as `PreviousInValue` in the consensus state, corrupting the legitimate miner's data. [7](#0-6) 

## Impact Explanation

**Consensus Integrity Violation:** This attack directly corrupts consensus state by storing incorrect `PreviousInValue` data for victim miners. The consensus mechanism relies on these values for round transitions, miner validation, and random number generation.

**Affected Parties:**
- Victim miners whose InValues are incorrectly reconstructed
- All nodes relying on accurate consensus state for validation
- The protocol's Byzantine fault tolerance guarantees are undermined

**Concrete Harm:**
1. Corrupted consensus state persists on-chain across multiple rounds
2. Incorrect PreviousInValues may cause validation failures or incorrect behavior in subsequent rounds
3. The revealed InValues serve as fallback when miners fail to produce blocks, potentially causing unfair penalties or rewards
4. Byzantine miners can systematically corrupt competitors' consensus records

**Severity:** Medium - While this corrupts critical consensus state and could affect reward distribution or miner reputation, it does not directly enable immediate fund theft or chain halt. The impact is primarily on consensus integrity and fairness.

## Likelihood Explanation

**Attacker Capabilities:** The attacker must be an active miner in the current consensus round. In AElf's DPoS system, miners are elected through voting, making this a realistic but privileged position.

**Attack Complexity:** Low - The attack simply requires crafting byte arrays where the MSB is set (e.g., `[0xFF, 0xFF, ...]`) and including them as DecryptedPieces in an UpdateValue transaction. No sophisticated cryptographic attacks or timing exploits are needed.

**Preconditions:**
1. Attacker is an active miner (achievable through election)
2. Victim has published EncryptedPieces in the previous round (standard consensus operation)
3. No cryptographic validation links DecryptedPieces to EncryptedPieces on-chain

**Execution:**
1. Wait for victim to publish EncryptedPieces in round N-1
2. In round N, submit UpdateValue with crafted DecryptedPieces containing byte arrays like `[0xFF, 0xFF, ...]`
3. When NextRound transition occurs, RevealSharedInValues executes on-chain
4. Corrupted PreviousInValue is stored in consensus state

**Detection:** The malicious byte arrays appear as valid serialized BigIntegers, making detection difficult without explicit validation of DecryptedPieces against their corresponding EncryptedPieces.

## Recommendation

Apply the `Abs()` extension method in `DecodeSecret` to ensure all BigInteger values remain positive in the finite field:

```csharp
public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
{
    var result = BigInteger.Zero;

    for (var i = 0; i < threshold; i++)
    {
        // Use Abs() to handle negative BigIntegers from byte arrays with MSB >= 0x80
        var numerator = new BigInteger(sharedParts[i]).Abs();
        var denominator = BigInteger.One;
        for (var j = 0; j < threshold; j++)
        {
            if (i == j) continue;

            (numerator, denominator) =
                MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
        }

        result += RationalToWhole(numerator, denominator);
        result = result.Abs(); // Also apply Abs() to intermediate results
    }

    return result.ToBytesArray();
}
```

Alternatively, use the custom `ToBigInteger()` extension method which ensures positive values by adding a leading zero byte:

```csharp
var numerator = sharedParts[i].ToBigInteger();
```

Additionally, consider adding cryptographic validation in `UpdateValueValidationProvider` to verify that DecryptedPieces are valid decryptions of the corresponding EncryptedPieces, though this would require storing additional proof data.

## Proof of Concept

```csharp
[Fact]
public void MaliciousDecryptedPieces_CorruptsSecretReconstruction()
{
    // Setup: Create legitimate secret shares
    var originalSecret = HashHelper.ComputeFrom("legitimate_invalue").ToByteArray();
    var threshold = 3;
    var totalParts = 5;
    var legitimateShares = SecretSharingHelper.EncodeSecret(originalSecret, threshold, totalParts);
    
    // Attack: Create malicious byte arrays with MSB >= 0x80
    var maliciousShares = new List<byte[]>
    {
        new byte[] { 0xFF, 0xFF }, // This creates BigInteger(-1)
        new byte[] { 0xFF, 0xFF, 0xFF }, // This creates BigInteger(-1)
        new byte[] { 0x80, 0x00, 0x00 } // This creates negative BigInteger
    };
    
    var orders = new List<int> { 1, 2, 3 };
    
    // Decode using malicious shares - this will produce incorrect result
    var maliciousResult = SecretSharingHelper.DecodeSecret(maliciousShares, orders, threshold);
    
    // Decode using legitimate shares - this produces correct result
    var legitimateResult = SecretSharingHelper.DecodeSecret(
        legitimateShares.Take(threshold).ToList(), 
        orders, 
        threshold);
    
    // Verify that malicious shares produce different (corrupted) output
    Assert.NotEqual(legitimateResult, maliciousResult);
    
    // Demonstrate that negative BigIntegers are created
    var negativeBigInt = new BigInteger(new byte[] { 0xFF, 0xFF });
    Assert.True(negativeBigInt < 0);
    Assert.Equal(-1, negativeBigInt);
    
    // Show that Abs() would fix this
    var fixedBigInt = negativeBigInt.Abs();
    Assert.True(fixedBigInt > 0);
}
```

## Notes

The vulnerability is confirmed by the existence of the `Abs()` extension method and its usage in other parts of the codebase (e.g., in the `Inverse` method at line 95 of SecretSharingHelper.cs), indicating the developers were aware of the signed BigInteger issue but failed to apply the fix consistently in `DecodeSecret`. The attack requires Byzantine miner behavior but does not require breaking any cryptographic primitives or compromising keys.

### Citations

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingExtensions.cs (L39-43)
```csharp
        public static BigInteger Abs(this BigInteger integer)
        {
            return (integer % SecretSharingConsts.FieldPrime + SecretSharingConsts.FieldPrime) %
                   SecretSharingConsts.FieldPrime;
        }
```

**File:** test/AElf.Cryptography.Tests/SecretSharingTest.cs (L35-42)
```csharp
    public void BigIntegerAbsTest()
    {
        var dataArray = new byte[] { 0xff, 0xff };
        var rawData = new BigInteger(dataArray);
        rawData.ShouldBe(-1);
        var absData = rawData.Abs();
        absData.ShouldBe(SecretSharingConsts.FieldPrime - 1);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-203)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```
