# Audit Report

## Title
Missing Validation Allows Consensus DoS via Zero FinalOrderOfNextRound Values

## Summary
The `ProcessUpdateValue` method in the AEDPoS consensus contract accepts arbitrary `SupposedOrderOfNextRound` values and `TuneOrderInformation` entries without validation, allowing malicious miners to corrupt consensus state with invalid order values (including 0). While `NextRoundMiningOrderValidationProvider` detects this corruption during round transitions, the invalid data has already been written to state, creating a denial-of-service condition that blocks all subsequent round transitions with no built-in recovery mechanism.

## Finding Description

The vulnerability exists in the consensus state update flow where miners submit `UpdateValueInput` data during normal block production.

**Root Cause - Missing Input Validation:**

In `ProcessUpdateValue`, user-controlled values from `UpdateValueInput` are directly assigned to consensus state without range validation. The method directly assigns `SupposedOrderOfNextRound` to both the miner's `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` fields without checking if the value is greater than zero. [1](#0-0) 

Additionally, the `TuneOrderInformation` dictionary allows arbitrary key-value pairs to overwrite any miner's `FinalOrderOfNextRound`. [2](#0-1) 

**Why Existing Protections Fail:**

The `UpdateValueValidationProvider` only validates that `OutValue` and `Signature` are non-null/non-empty, and that `PreviousInValue` matches the hash of the previous `OutValue`. It does NOT validate `SupposedOrderOfNextRound` or `FinalOrderOfNextRound` values. [3](#0-2) 

**Detection at NextRound (Too Late):**

The issue is only detected when `NextRoundMiningOrderValidationProvider` validates round transitions. This provider checks that the count of miners with `FinalOrderOfNextRound > 0` equals the count of miners with non-null `OutValue`. [4](#0-3) 

However, this validation only runs for `NextRound` behavior, not for `UpdateValue`. The validation routing shows `NextRoundMiningOrderValidationProvider` is only added for `NextRound` behavior (line 86), while `UpdateValue` behavior only uses `UpdateValueValidationProvider` (line 80). [5](#0-4) 

**Expected vs Actual Behavior:**

By design, `ApplyNormalConsensusData` calculates order values that are always in the valid range [1, minersCount] using `GetAbsModulus(sigNum, minersCount) + 1`. [6](#0-5) 

The `GetAbsModulus` function ensures non-negative results by taking the absolute value of the modulus operation. [7](#0-6) 

However, miners control the `UpdateValueInput` they submit via the public `UpdateValue` method, which directly calls `ProcessConsensusInformation` without additional validation. [8](#0-7) 

The only access control is performed by `PreCheck`, which validates that the sender is in the current or previous round's miner list, but does not validate the input values. [9](#0-8) 

**Attack Execution:**

A malicious miner can craft an `UpdateValueInput` with:
- Their own `SupposedOrderOfNextRound = 0` 
- `TuneOrderInformation` entries setting other miners' `FinalOrderOfNextRound = 0`

These invalid values bypass validation and get written to state. When any miner attempts `NextRound`, the validation fails because miners have `FinalOrderOfNextRound = 0` but non-null `OutValue`, causing the check to fail and permanently blocking round transitions.

## Impact Explanation

**Complete Consensus Halt:**
- Once invalid `FinalOrderOfNextRound` values are written to state, all subsequent `NextRound` attempts fail validation
- The blockchain cannot progress to the next round
- Block production halts completely
- All network participants experience service interruption
- DApps and users cannot submit transactions
- Economic activity on the chain stops entirely

**No Built-In Recovery:**

The `SupplyCurrentRoundInformation` method called before `NextRound` only fills missing `OutValue`/`Signature` data for non-participating miners. It iterates through miners who haven't mined (`m.OutValue == null`) and supplies their in-value and signature, but it does not fix corrupted `FinalOrderOfNextRound` values. [10](#0-9) 

Recovery would require governance intervention or chain restart.

**Severity:** High - Complete denial of service of consensus mechanism with no automatic recovery path.

## Likelihood Explanation

**Attack Feasibility:**
- **Entry Point:** Public `UpdateValue` method is the standard entry point for all miners during normal block production
- **Access Control:** Only requires being in the miner list (miners are not trusted roles in the threat model)
- **Technical Complexity:** Low - malicious miner modifies node software to generate invalid `UpdateValueInput` 
- **Collusion Requirement:** Single malicious miner can execute if they produce a block late enough in the round to set invalid values via `TuneOrderInformation` for other miners

**Attack Sequence:**
1. Malicious miner waits for honest miners to submit their `UpdateValue` transactions
2. Malicious miner produces their block with crafted `UpdateValueInput`:
   - `SupposedOrderOfNextRound = 0`
   - `TuneOrderInformation` containing entries for all/most miners with value 0
3. Transaction passes validation (only `OutValue`/`Signature` checked)
4. Invalid values written to consensus state
5. All subsequent `NextRound` attempts fail validation
6. Chain halted

**Economic Considerations:**
While miners have economic incentive to maintain chain operation, a malicious miner could use this for:
- Extortion (demand payment to fix the chain)
- Competitive attack against the network
- Political/ideological attack

**Overall Likelihood:** Medium - Practical to execute with single malicious miner, but requires miner participation which may be uncommon in practice.

## Recommendation

Add validation in `ProcessUpdateValue` to ensure `SupposedOrderOfNextRound` and all values in `TuneOrderInformation` are within the valid range [1, minersCount]:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // Validate SupposedOrderOfNextRound is in valid range
    Assert(updateValueInput.SupposedOrderOfNextRound > 0 && 
           updateValueInput.SupposedOrderOfNextRound <= minersCount,
           "Invalid SupposedOrderOfNextRound value.");
    
    // Validate all TuneOrderInformation values are in valid range
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(tuneOrder.Value > 0 && tuneOrder.Value <= minersCount,
               "Invalid FinalOrderOfNextRound value in TuneOrderInformation.");
    }
    
    // Rest of the method...
}
```

Alternatively, add order value validation to `UpdateValueValidationProvider` to catch this at the validation layer before state is modified.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanCorruptConsensusWithZeroOrderValues()
{
    // Setup: Initialize consensus with multiple miners
    await InitializeCandidates(5);
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Simulate normal mining for first few miners
    var maliciousMinerKeyPair = InitialCoreDataCenterKeyPairs[2];
    var maliciousMinerPubkey = maliciousMinerKeyPair.PublicKey.ToHex();
    
    // Malicious miner crafts UpdateValueInput with zero order values
    var maliciousInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("valid_output"),
        Signature = HashHelper.ComputeFrom("valid_signature"),
        PreviousInValue = Hash.Empty,
        RoundId = firstRound.RoundIdForValidation,
        ActualMiningTime = Context.CurrentBlockTime,
        SupposedOrderOfNextRound = 0, // MALICIOUS: Zero value
        TuneOrderInformation = {
            { InitialCoreDataCenterKeyPairs[0].PublicKey.ToHex(), 0 }, // Corrupt other miners
            { InitialCoreDataCenterKeyPairs[1].PublicKey.ToHex(), 0 }
        },
        ImpliedIrreversibleBlockHeight = 1,
        RandomNumber = ByteString.CopyFrom(await GenerateRandomProofAsync(maliciousMinerKeyPair))
    };
    
    KeyPairProvider.SetKeyPair(maliciousMinerKeyPair);
    var maliciousTester = GetAEDPoSContractStub(maliciousMinerKeyPair);
    
    // Attack: Submit malicious UpdateValue - this should pass validation
    var result = await maliciousTester.UpdateValue.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: State is corrupted with zero FinalOrderOfNextRound values
    var corruptedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    corruptedRound.RealTimeMinersInformation[maliciousMinerPubkey]
        .FinalOrderOfNextRound.ShouldBe(0); // Corrupted!
    
    // Impact: NextRound will now fail validation and consensus halts
    var nextRoundInput = GenerateNextRoundInput(corruptedRound);
    var nextRoundResult = await AEDPoSContractStub.NextRound.SendAsync(nextRoundInput);
    nextRoundResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    nextRoundResult.TransactionResult.Error.ShouldContain("Invalid FinalOrderOfNextRound");
}
```

## Notes

This vulnerability demonstrates a critical gap in input validation for consensus-critical data. The separation of validation logic between `UpdateValueValidationProvider` (used during UpdateValue) and `NextRoundMiningOrderValidationProvider` (used during NextRound) creates a window where invalid state can be written and only detected later when it's too late to prevent. The attack is particularly severe because it requires only a single malicious miner and results in complete consensus halt with no automatic recovery mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-49)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-20)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-22)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L171-221)
```csharp
    private void SupplyCurrentRoundInformation()
    {
        var currentRound = GetCurrentRoundInformation(new Empty());
        Context.LogDebug(() => $"Before supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
        TryToGetPreviousRoundInformation(out var previousRound);
        foreach (var miner in notMinedMiners)
        {
            Context.LogDebug(() => $"Miner pubkey {miner.Pubkey}");

            Hash previousInValue = null;
            Hash signature = null;

            // Normal situation: previous round information exists and contains this miner.
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }

            // Fill this two fields at last.
            miner.InValue = previousInValue;
            miner.Signature = signature;

            currentRound.RealTimeMinersInformation[miner.Pubkey] = miner;
        }

        TryToUpdateRoundInformation(currentRound);
        Context.LogDebug(() => $"After supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
    }
```
