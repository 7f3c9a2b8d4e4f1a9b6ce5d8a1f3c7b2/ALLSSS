# Audit Report

## Title
Missing Dictionary Key Validation in CrossChainCreate Causes KeyNotFoundException and DoS

## Summary
The `CrossChainCreate` method in the NFT contract directly accesses `ExternalInfo.Value` dictionary keys without validation, causing unhandled `KeyNotFoundException` when tokens lack required NFT metadata. This enables permanent DoS of cross-chain NFT protocol creation through pre-creation of malformed tokens with NFT collection symbol formats but incomplete metadata.

## Finding Description

The vulnerability exists in the `CrossChainCreate` method where dictionary keys `NftBaseUriMetadataKey` and `NftTokenIdReuseMetadataKey` are accessed directly without checking if they exist [1](#0-0) .

The method is publicly accessible with no authorization checks beyond basic token existence validation [2](#0-1) .

**Root Cause:**

When creating tokens through the legitimate `NFTContract.Create()` flow, the required metadata keys are automatically added to `ExternalInfo` [3](#0-2) .

However, the `MultiToken.Create` method accepts arbitrary `ExternalInfo` without validating NFT-specific metadata requirements. When a symbol ends with "-0", it's detected as an NFT collection [4](#0-3) , and routed to `CreateNFTCollection` which simply calls `CreateToken` [5](#0-4) .

The `CreateToken` method assigns `ExternalInfo` directly from user input without NFT metadata validation [6](#0-5) .

An attacker with seed NFT ownership can create tokens with NFT collection symbol formats, as enforced by the seed NFT requirement [7](#0-6) .

When tokens are synchronized cross-chain via `CrossChainCreateToken`, the incomplete `ExternalInfo` is preserved without validation [8](#0-7) .

**Why Existing Protections Fail:**

The `MultiToken` contract uses defensive patterns with `TryGetValue` for dictionary access throughout the codebase [9](#0-8) .

However, the NFT contract does not follow this pattern, directly accessing dictionary keys that may not exist. The required metadata keys are defined as constants [10](#0-9) .

## Impact Explanation

**Concrete Harm:**
- **Permanent DoS**: Attackers can irreversibly block legitimate NFT protocols from being created on sidechains by pre-creating tokens with matching symbols but incomplete metadata
- **Cross-Chain Disruption**: All calls to `CrossChainCreate` for affected symbols throw unhandled `KeyNotFoundException`, completely breaking cross-chain NFT synchronization  
- **No Recovery**: Once a malformed token exists, the assertion at line 79 prevents any override or fix mechanism [11](#0-10) 
- **Ecosystem Impact**: Affects NFT protocol creators, sidechain users, and the broader AElf cross-chain NFT functionality

**Severity Justification:**
High severity due to permanent, irrecoverable DoS with low attack complexity and broad ecosystem impact.

## Likelihood Explanation

**Attacker Requirements:**
- Seed NFT ownership (obtainable through normal protocol mechanisms) OR whitelist access
- The seed NFT mechanism is designed to allow token creation for any user who owns the appropriate seed

**Attack Complexity:**
Low - requires only:
1. One `TokenContract.Create()` call with NFT collection symbol format (e.g., "ABART-0") and empty/incomplete `ExternalInfo`
2. Automatic cross-chain synchronization propagates the malformed token via the standard cross-chain token creation mechanism
3. Any user calling `CrossChainCreate()` triggers the `KeyNotFoundException`

**Probability:**
Medium-High because seed NFTs are obtainable through normal protocol operations, the attack is straightforward with clear griefing motivation, and no technical sophistication is required.

## Recommendation

Add defensive dictionary access checks using `TryGetValue` pattern before accessing `ExternalInfo` keys in `CrossChainCreate`:

```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    MakeSureTokenContractAddressSet();
    InitialNFTTypeNameMap();
    Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
    {
        Symbol = input.Symbol
    });
    if (string.IsNullOrEmpty(tokenInfo.Symbol))
        throw new AssertionException($"Token info {input.Symbol} not exists.");

    // Add validation
    Assert(tokenInfo.ExternalInfo != null && 
           tokenInfo.ExternalInfo.Value.TryGetValue(NftBaseUriMetadataKey, out var baseUri),
           "Missing NFT base URI metadata.");
    Assert(tokenInfo.ExternalInfo.Value.TryGetValue(NftTokenIdReuseMetadataKey, out var tokenIdReuseStr) &&
           bool.TryParse(tokenIdReuseStr, out var isTokenIdReuse),
           "Missing or invalid NFT token ID reuse metadata.");
    
    // Rest of the method...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreate_WithMalformedToken_ShouldThrowKeyNotFoundException()
{
    // Step 1: Create a malformed NFT collection token directly via MultiToken
    // with symbol format "TEST-0" but without required NFT metadata
    var malformedSymbol = "TEST-0";
    
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = malformedSymbol,
        TokenName = "Malformed NFT Collection",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = DefaultAddress,
        IsBurnable = true,
        ExternalInfo = new ExternalInfo() // Empty - missing NFT metadata
    });
    
    // Step 2: Simulate cross-chain sync (in real scenario, this happens automatically)
    // Token now exists on sidechain with incomplete ExternalInfo
    
    // Step 3: Attempt to create NFT protocol via CrossChainCreate
    // This should throw KeyNotFoundException due to missing metadata keys
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
        {
            Symbol = malformedSymbol
        });
    });
    
    // Verify the exception is KeyNotFoundException from missing dictionary keys
    exception.Message.ShouldContain("KeyNotFoundException");
}
```

## Notes

The vulnerability demonstrates a critical gap between the MultiToken and NFT contracts' validation assumptions. While MultiToken allows flexible `ExternalInfo` for general token creation, the NFT contract assumes that NFT collection tokens will always have specific metadata keys populated. This assumption breaks when tokens are created directly via MultiToken with NFT collection symbol formats, creating a permanent DoS vector for cross-chain NFT protocol creation with no recovery mechanism.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-85)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L87-88)
```csharp
        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L184-201)
```csharp
    private ExternalInfo GetTokenExternalInfo(CreateInput input)
    {
        if (input.Metadata != null) AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var tokenExternalInfo = input.Metadata == null
            ? new ExternalInfo()
            : new ExternalInfo
            {
                Value = { input.Metadata.Value }
            };

        // Add NFT Type to external info.
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
        return tokenExternalInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L10-13)
```csharp
    private Empty CreateNFTCollection(CreateInput input)
    {
        return CreateToken(input, SymbolType.NftCollection);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L124-127)
```csharp
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L492-503)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L7-9)
```csharp
    private const string NftTypeMetadataKey = "aelf_nft_type";
    private const string NftBaseUriMetadataKey = "aelf_nft_base_uri";
    private const string NftTokenIdReuseMetadataKey = "aelf_nft_token_id_reuse";
```
