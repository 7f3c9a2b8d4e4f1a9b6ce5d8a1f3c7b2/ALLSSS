# Audit Report

## Title
Missing Validation Allows Miners to Spoof TinyBlock Behavior and Bypass Consensus Value Submission

## Summary
The AEDPoS consensus contract fails to validate that a miner's claimed consensus behavior matches their actual state requirements. Malicious miners can claim `TinyBlock` behavior when they should use `UpdateValue` behavior, bypassing mandatory OutValue and Signature submission, thereby degrading consensus randomness and Last Irreversible Block (LIB) calculation mechanisms.

## Finding Description

The vulnerability exists in the consensus validation flow where miners can specify their desired behavior without verification that this choice is appropriate for their current state.

Miners call either `UpdateValue` or `UpdateTinyBlockInformation` as public entry points, both of which simply delegate to `ProcessConsensusInformation` without validating whether the chosen behavior is appropriate for the miner's current state [1](#0-0) .

The `GetConsensusBehaviour` method in `ConsensusBehaviourProviderBase` determines what behavior a miner SHOULD use based on their state (e.g., if `OutValue` is null, they should use `UpdateValue`) [2](#0-1) . However, there is no validation that enforces this determination.

The validation in `ValidateBeforeExecution` applies behavior-specific validators only for `UpdateValue`, `NextRound`, and `NextTerm` behaviors via a switch statement. Critically, the `TinyBlock` case has no additional validators added [3](#0-2) . This means TinyBlock claims only undergo basic validation (mining permission, time slot, continuous blocks) without verifying whether the miner's state actually permits TinyBlock usage.

The processing difference is substantial. When a miner uses `ProcessTinyBlock`, it only updates `ActualMiningTimes` and block production counters [4](#0-3) . In contrast, `ProcessUpdateValue` sets OutValue, Signature, performs secret sharing if enabled, and triggers LIB calculation [5](#0-4) .

Post-execution validation cannot detect this misbehavior because `GetCheckableRound` explicitly clears `ActualMiningTimes` before computing the round hash [6](#0-5) . This means differences in `ActualMiningTimes` won't trigger validation failures during hash comparison in `ValidateConsensusAfterExecution` [7](#0-6) .

The system tolerates missing OutValues by auto-supplying fake values in `SupplyCurrentRoundInformation` [8](#0-7) , but this is intended as a fallback for failures, not for intentional malicious behavior.

## Impact Explanation

This vulnerability degrades critical consensus security properties:

1. **Consensus Randomness Degradation**: AEDPoS relies on miners' OutValue and Signature for randomness generation via VRF verification. When miners bypass this requirement, randomness quality degrades and becomes dependent on fewer honest participants. The system computes signatures by XORing all miners' contributions, so missing contributions from multiple miners significantly compromises the randomness beacon.

2. **LIB Calculation Bypass**: The `ProcessUpdateValue` method triggers Last Irreversible Block height calculation using `LastIrreversibleBlockHeightCalculator`. By using TinyBlock instead, miners prevent LIB updates during their blocks, potentially delaying chain finality and the ability to prune old state.

3. **Reward Without Contribution**: Miners receive block production rewards and increment their `ProducedBlocks` and `ProducedTinyBlocks` counters without fulfilling their cryptographic consensus obligations (OutValue/Signature computation and secret sharing).

4. **Secret Sharing Bypass**: When enabled, `ProcessUpdateValue` performs secret sharing for consensus security by encrypting and distributing pieces. TinyBlock skips this entirely, weakening the protocol's cryptographic guarantees.

The severity is **Medium** because while it doesn't directly steal funds or break the chain, it compromises fundamental consensus invariants that ensure randomness quality, finality progression, and cryptographic security guarantees.

## Likelihood Explanation

**Attack Feasibility**: High - The attack requires only:
- Being an active miner in the consensus set (realistic in DPoS where miner compromise is a valid threat)
- Calling `UpdateTinyBlockInformation` instead of `UpdateValue` when `OutValue` is null
- No complex timing or state manipulation needed

**Preconditions**: Requires miner-level access. In a DPoS system like AEDPoS, this is a realistic threat model consideration, as miners are elected from a larger candidate pool and could be compromised or act maliciously.

**Detection Difficulty**: The attack is extremely hard to detect because:
- All validation checks pass (no TinyBlock-specific validator exists to check behavior appropriateness)
- Round hash validation succeeds (ActualMiningTimes is excluded from the checkable round hash)
- The system auto-supplies missing OutValues/Signatures via `SupplyCurrentRoundInformation`, so rounds complete normally
- Only detailed post-analysis of consensus data quality patterns would reveal the issue

**Economic Motivation**: Rational miners might exploit this to reduce computational overhead (skipping OutValue/Signature computation) while maintaining full block production rewards, or to strategically degrade consensus quality for advantage in elections or randomness-dependent operations.

The likelihood is assessed as **Medium** - requires miner access but is trivially executable once that access exists.

## Recommendation

Add explicit validation in `ValidateBeforeExecution` to verify that the claimed behavior matches what `GetConsensusBehaviour` would determine based on the miner's current state. Specifically:

1. Add a TinyBlock-specific validation provider that checks:
   - The miner's `OutValue` is already set (not null) for the current round
   - The miner is within their allowed block production count
   - The time slot conditions justify TinyBlock usage

2. Alternatively, compute the expected behavior using the same logic as `GetConsensusBehaviour` during validation and reject transactions where claimed behavior doesn't match expected behavior.

3. Consider adding a specific validator case in the switch statement (lines 77-92 of `AEDPoSContract_Validation.cs`) that adds a `TinyBlockBehaviourValidationProvider` to verify state requirements.

## Proof of Concept

A proof of concept would require:

1. Setting up an AEDPoS test environment with multiple miners
2. Having a miner with `OutValue == null` (hasn't mined in current round)
3. That miner calls `UpdateTinyBlockInformation` instead of `UpdateValue`
4. Verification that:
   - The transaction succeeds
   - No OutValue/Signature is recorded
   - Block production counters are incremented
   - Validation passes despite incorrect behavior choice
   - Round hash validation succeeds in post-execution checks

The key assertion would be that a miner can produce blocks and receive credit without contributing their OutValue and Signature to the consensus randomness, violating the protocol's security assumptions.

**Notes**

This vulnerability represents a design flaw in the consensus validation architecture where behavior selection is left to miners without enforcement. While the system has fallback mechanisms (`SupplyCurrentRoundInformation`) to handle missing values, these were designed for network failures or unavailable miners, not for intentional malicious behavior. The attack is particularly insidious because it passes all existing validation checks and only degrades consensus quality rather than causing immediate chain failures, making it difficult to detect and attribute.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-112)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }

    #endregion

    #region UpdateTinyBlockInformation

    public override Empty UpdateTinyBlockInformation(TinyBlockInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L171-221)
```csharp
    private void SupplyCurrentRoundInformation()
    {
        var currentRound = GetCurrentRoundInformation(new Empty());
        Context.LogDebug(() => $"Before supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
        TryToGetPreviousRoundInformation(out var previousRound);
        foreach (var miner in notMinedMiners)
        {
            Context.LogDebug(() => $"Miner pubkey {miner.Pubkey}");

            Hash previousInValue = null;
            Hash signature = null;

            // Normal situation: previous round information exists and contains this miner.
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }

            // Fill this two fields at last.
            miner.InValue = previousInValue;
            miner.Signature = signature;

            currentRound.RealTimeMinersInformation[miner.Pubkey] = miner;
        }

        TryToUpdateRoundInformation(currentRound);
        Context.LogDebug(() => $"After supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```
