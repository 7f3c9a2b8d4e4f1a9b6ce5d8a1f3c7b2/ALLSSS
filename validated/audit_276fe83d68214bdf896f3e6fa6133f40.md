# Audit Report

## Title
State Corruption in Cross-Chain Data Recording Due to Asymmetric Parent/Side Chain Persistence

## Summary
The `RecordCrossChainData()` function in the CrossChain contract exhibits asymmetric data persistence between parent chain and side chain processing. Parent chain data is persisted immediately within the indexing function, while side chain data is accumulated and only persisted conditionally. However, ALL proposals are unconditionally marked as ACCEPTED regardless of whether side chain data was actually persisted, creating a critical state inconsistency where proposals show ACCEPTED status but their data is absent from `State.IndexedSideChainBlockData`.

## Finding Description

The vulnerability exists in the `RecordCrossChainData()` method which processes cross-chain block data with fundamentally different persistence models: [1](#0-0) 

**Asymmetric Processing:**

1. **Parent Chain Processing** - When processing parent chain data, `IndexParentChainBlockData()` is called which **immediately modifies persistent state variables**: [2](#0-1) 

The parent chain indexing directly updates state including `State.ParentChainTransactionStatusMerkleTreeRoot`, `State.TransactionMerkleTreeRootRecordedInParentChain`, and `State.CurrentParentChainHeight`.

2. **Side Chain Processing** - When processing side chain data, `IndexSideChainBlockData()` returns a list that can be **empty without throwing an exception**: [3](#0-2) 

The critical issue is at lines 838-839: when the target height doesn't match the proposed height, the function **breaks early and returns whatever has been accumulated** (potentially an empty list). No exception is thrown.

3. **Conditional Persistence** - Side chain data persistence to `State.IndexedSideChainBlockData` only occurs if the accumulated list has count > 0 (lines 331-335 in the first citation).

4. **Unconditional Status Update** - Despite conditional persistence, the proposal status is **unconditionally set to ACCEPTED** at line 327-328 for ALL chain IDs processed, regardless of whether their data was actually persisted.

**The Invariant Violation:**

The protobuf definition confirms that ACCEPTED status means "The proposal has been released": [4](#0-3) 

This implies successful data recording, but the implementation violates this guarantee for side chains when height mismatches occur.

## Impact Explanation

**Critical Cross-Chain Integrity Break:**

1. **State Inconsistency** - Side chain proposals are marked ACCEPTED but have no corresponding entry in `State.IndexedSideChainBlockData`, violating the protocol's invariant that ACCEPTED status indicates successful persistence.

2. **Failed Cross-Chain Verification** - The view function `GetIndexedSideChainBlockDataByHeight` directly queries `State.IndexedSideChainBlockData`: [5](#0-4) 

When queried for a height where the proposal was ACCEPTED but data not persisted, it returns empty data, breaking cross-chain transaction verification.

3. **Merkle Root Calculation Failure** - The `GetSideChainMerkleTreeRoot` function relies on `State.IndexedSideChainBlockData`: [6](#0-5) 

Missing data causes incorrect or incomplete merkle root computation, breaking the cryptographic verification of cross-chain transactions.

4. **Proposal System Corruption** - Once marked ACCEPTED, proposals are cleared via `ResetChainIndexingProposal`: [7](#0-6) 

This prevents re-proposal of the missing data, requiring creation of a new proposal with potentially stale or different block data.

**Affected Parties:** All users relying on cross-chain asset transfers, message passing, or transaction verification between parent and side chains are affected.

## Likelihood Explanation

**Moderate-High Likelihood:**

The vulnerability is triggered through normal operation via `ReleaseCrossChainIndexingProposal`: [8](#0-7) 

**Preconditions:**
1. Multiple chain IDs (parent + side chain) passed to `RecordCrossChainData` in a single call
2. Parent chain indexing succeeds
3. Side chain's `IndexSideChainBlockData` returns empty list due to height mismatch (lines 838-839 in IndexSideChainBlockData)
4. No exception thrown during processing

**Feasibility:**
- Only miners can call this function (enforced at line 297), but this is part of **normal cross-chain operation**, not requiring malicious intent
- The height mismatch scenario can occur **naturally** when proposed block heights don't align with current state expectations
- The inconsistency is **subtle** - proposals show ACCEPTED in status queries but view functions return empty data
- Detection requires comparing proposal status with actual persisted data

## Recommendation

Modify `RecordCrossChainData()` to validate that side chain data was successfully persisted before marking the proposal as ACCEPTED:

```csharp
private void RecordCrossChainData(IEnumerable<int> chainIdList)
{
    var indexedSideChainBlockData = new IndexedSideChainBlockData();
    foreach (var chainId in chainIdList)
    {
        var pendingProposalExists = TryGetIndexingProposalWithStatus(chainId,
            CrossChainIndexingProposalStatus.Pending,
            out var pendingCrossChainIndexingProposal);
        Assert(pendingProposalExists, "Chain indexing not proposed.");

        if (chainId == State.ParentChainId.Value)
        {
            IndexParentChainBlockData(pendingCrossChainIndexingProposal.ProposedCrossChainBlockData
                .ParentChainBlockDataList);
        }
        else
        {
            var indexed = IndexSideChainBlockData(
                pendingCrossChainIndexingProposal.ProposedCrossChainBlockData.SideChainBlockDataList,
                pendingCrossChainIndexingProposal.Proposer, chainId);
            
            // Only mark as ACCEPTED if data was actually indexed
            Assert(indexed.Count > 0, "No side chain data indexed - height mismatch or empty input.");
            indexedSideChainBlockData.SideChainBlockDataList.Add(indexed);
        }

        SetCrossChainIndexingProposalStatus(pendingCrossChainIndexingProposal,
            CrossChainIndexingProposalStatus.Accepted);
    }

    if (indexedSideChainBlockData.SideChainBlockDataList.Count > 0)
    {
        State.IndexedSideChainBlockData.Set(Context.CurrentHeight, indexedSideChainBlockData);
        Context.Fire(new SideChainBlockDataIndexed());
    }
}
```

Alternatively, throw an exception in `IndexSideChainBlockData` when height mismatch occurs, or revert the proposal status change if no data was persisted.

## Proof of Concept

```csharp
[Fact]
public async Task StateCorruption_SideChainProposalAccepted_ButDataNotPersisted()
{
    // Setup: Create side chain
    var lockedToken = 10;
    var sideChainId = await InitAndCreateSideChainAsync(0, 0, lockedToken);
    
    // Create side chain block data with WRONG height (height 10 instead of expected 1)
    // This will cause height mismatch in IndexSideChainBlockData
    var fakeSideChainBlockHash = HashHelper.ComputeFrom("sideChainBlockHash");
    var fakeTxMerkleTreeRoot = HashHelper.ComputeFrom("txMerkleTreeRoot");
    var wrongHeightData = CreateSideChainBlockData(fakeSideChainBlockHash, 10, sideChainId, fakeTxMerkleTreeRoot);
    
    var crossChainBlockData = new CrossChainBlockData
    {
        SideChainBlockDataList = { wrongHeightData }
    };
    
    // Propose with wrong height
    var txRes = await CrossChainContractStub.ProposeCrossChainIndexing.SendAsync(crossChainBlockData);
    var proposalId = ProposalCreated.Parser
        .ParseFrom(txRes.TransactionResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
        .ProposalId;
    
    // Approve proposal
    await ApproveWithMinersAsync(proposalId);
    
    // Release proposal - this triggers RecordCrossChainData
    await CrossChainContractStub.ReleaseCrossChainIndexingProposal.SendAsync(
        new ReleaseCrossChainIndexingProposalInput { ChainIdList = { sideChainId } });
    
    // VULNERABILITY: Proposal status shows ACCEPTED
    var proposalStatus = await CrossChainContractStub.GetIndexingProposalStatus.CallAsync(new Empty());
    // Proposal was cleared (marked ACCEPTED) - this should be empty after acceptance
    proposalStatus.ChainIndexingProposalStatus.ShouldBeEmpty(); // Cleared because marked ACCEPTED
    
    // BUT: No data was actually persisted to State.IndexedSideChainBlockData
    var indexedData = await CrossChainContractStub.GetIndexedSideChainBlockDataByHeight.CallAsync(
        new Int64Value { Value = await BlockTimeProvider.GetBlockTimeAsync() });
    
    // PROOF: Returns empty data even though proposal was ACCEPTED
    indexedData.SideChainBlockDataList.Count.ShouldBe(0); // NO DATA PERSISTED
    
    // IMPACT: Side chain height remains 0 (not updated)
    var height = await CrossChainContractStub.GetSideChainHeight.CallAsync(
        new Int32Value { Value = sideChainId });
    height.Value.ShouldBe(0); // State not updated
    
    // State Corruption Confirmed:
    // - Proposal was marked ACCEPTED and cleared
    // - But State.IndexedSideChainBlockData has no entry
    // - Cannot re-propose the same data
}
```

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L241-246)
```csharp
    private Hash GetSideChainMerkleTreeRoot(long parentChainHeight)
    {
        var indexedSideChainData = State.IndexedSideChainBlockData[parentChainHeight];
        return ComputeRootWithMultiHash(
            indexedSideChainData.SideChainBlockDataList.Select(d => d.TransactionStatusMerkleTreeRoot));
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L309-336)
```csharp
    private void RecordCrossChainData(IEnumerable<int> chainIdList)
    {
        var indexedSideChainBlockData = new IndexedSideChainBlockData();
        foreach (var chainId in chainIdList)
        {
            var pendingProposalExists = TryGetIndexingProposalWithStatus(chainId,
                CrossChainIndexingProposalStatus.Pending,
                out var pendingCrossChainIndexingProposal);
            Assert(pendingProposalExists, "Chain indexing not proposed.");

            if (chainId == State.ParentChainId.Value)
                IndexParentChainBlockData(pendingCrossChainIndexingProposal.ProposedCrossChainBlockData
                    .ParentChainBlockDataList);
            else
                indexedSideChainBlockData.SideChainBlockDataList.Add(IndexSideChainBlockData(
                    pendingCrossChainIndexingProposal.ProposedCrossChainBlockData.SideChainBlockDataList,
                    pendingCrossChainIndexingProposal.Proposer, chainId));

            SetCrossChainIndexingProposalStatus(pendingCrossChainIndexingProposal,
                CrossChainIndexingProposalStatus.Accepted);
        }

        if (indexedSideChainBlockData.SideChainBlockDataList.Count > 0)
        {
            State.IndexedSideChainBlockData.Set(Context.CurrentHeight, indexedSideChainBlockData);
            Context.Fire(new SideChainBlockDataIndexed());
        }
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L498-504)
```csharp
    private void ResetChainIndexingProposal(int chainId)
    {
        // clear pending proposal
        var proposedIndexingProposal = State.IndexingPendingProposal.Value;
        proposedIndexingProposal.ChainIndexingProposalCollections.Remove(chainId);
        State.IndexingPendingProposal.Value = proposedIndexingProposal;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L761-807)
```csharp
    private IndexedParentChainBlockData IndexParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        var indexedParentChainBlockData = new IndexedParentChainBlockData
        {
            LocalChainHeight = Context.CurrentHeight
        };
        for (var i = 0; i < parentChainBlockData.Count; i++)
        {
            var blockInfo = parentChainBlockData[i];
            AssertParentChainBlock(parentChainId, currentHeight, blockInfo);
            var parentChainHeight = blockInfo.Height;
            State.ParentChainTransactionStatusMerkleTreeRoot[parentChainHeight] =
                blockInfo.TransactionStatusMerkleTreeRoot;
            foreach (var indexedBlockInfo in blockInfo.IndexedMerklePath)
            {
                BindParentChainHeight(indexedBlockInfo.Key, parentChainHeight);
                AddIndexedTxRootMerklePathInParentChain(indexedBlockInfo.Key, indexedBlockInfo.Value);
            }

            // send consensus data shared from main chain  
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }

            if (blockInfo.CrossChainExtraData != null)
                State.TransactionMerkleTreeRootRecordedInParentChain[parentChainHeight] =
                    blockInfo.CrossChainExtraData.TransactionStatusMerkleTreeRoot;

            indexedParentChainBlockData.ParentChainBlockDataList.Add(blockInfo);
            currentHeight += 1;
        }

        State.CurrentParentChainHeight.Value = currentHeight;
        
        Context.Fire(new ParentChainIndexed
        {
            ChainId = parentChainId,
            IndexedHeight = currentHeight
        });

        return indexedParentChainBlockData;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L816-893)
```csharp
    private List<SideChainBlockData> IndexSideChainBlockData(IList<SideChainBlockData> sideChainBlockDataList,
        Address proposer, int chainId)
    {
        var indexedSideChainBlockData = new List<SideChainBlockData>();

        {
            var formattedProposerAddress = proposer.ToByteString().ToBase64();
            long indexingFeeAmount = 0;

            var sideChainInfo = State.SideChainInfo[chainId];
            var currentSideChainHeight = State.CurrentSideChainHeight[chainId];
            long arrearsAmount = 0;
            var lockedToken = sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt
                ? 0
                : GetSideChainIndexingFeeDeposit(chainId);

            foreach (var sideChainBlockData in sideChainBlockDataList)
            {
                var target = currentSideChainHeight != 0
                    ? currentSideChainHeight + 1
                    : AElfConstants.GenesisBlockHeight;
                var sideChainHeight = sideChainBlockData.Height;
                if (target != sideChainHeight)
                    break;

                // indexing fee
                var indexingPrice = sideChainInfo.IndexingPrice;

                lockedToken -= indexingPrice;

                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
                else
                {
                    indexingFeeAmount += indexingPrice;
                }

                currentSideChainHeight++;
                indexedSideChainBlockData.Add(sideChainBlockData);
            }

            if (indexingFeeAmount > 0)
                TransferDepositToken(new TransferInput
                {
                    To = proposer,
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = indexingFeeAmount,
                    Memo = "Index fee."
                }, chainId);

            if (arrearsAmount > 0)
            {
                if (sideChainInfo.ArrearsInfo.TryGetValue(formattedProposerAddress, out var amount))
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = amount + arrearsAmount;
                else
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = arrearsAmount;
            }

            State.SideChainInfo[chainId] = sideChainInfo;
            State.CurrentSideChainHeight[chainId] = currentSideChainHeight;
            
            Context.Fire(new SideChainIndexed
            {
                ChainId = chainId,
                IndexedHeight = currentSideChainHeight
            });
        }

        if (indexedSideChainBlockData.Count > 0)
            Context.LogDebug(() =>
                $"Last indexed height {indexedSideChainBlockData.Last().Height} for side chain {chainId}");

        return indexedSideChainBlockData;
    }
```

**File:** protobuf/cross_chain_contract.proto (L181-187)
```text
enum CrossChainIndexingProposalStatus{
    NON_PROPOSED = 0;
    // The proposal is pending.
    PENDING = 1;
    // The proposal has been released.
    ACCEPTED = 2;
}
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L13-17)
```csharp
    public override IndexedSideChainBlockData GetIndexedSideChainBlockDataByHeight(Int64Value input)
    {
        var indexedSideChainBlockData = State.IndexedSideChainBlockData[input.Value];
        return indexedSideChainBlockData ?? new IndexedSideChainBlockData();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```
