# Audit Report

## Title
Integer Overflow in Miner Count Auto-Increase Calculation Leading to Consensus Failure

## Summary
The consensus contract performs an unsafe cast from `long` to `int` when calculating auto-increased miner counts, without overflow protection or minimum bound validation on the `MinerIncreaseInterval` parameter. This allows governance to either trigger immediate division-by-zero DoS by setting the interval to 0, or cause integer overflow that produces negative miner counts after extended blockchain operation (34+ years with minimal intervals), corrupting consensus state across the system.

## Finding Description

The vulnerability exists in two critical calculation methods that determine the number of active miners in the consensus system.

**Location 1** - `GetAutoIncreasedMinersCount()` performs an unchecked cast: [1](#0-0) 

**Location 2** - `GetMinersCount()` has identical vulnerable pattern: [2](#0-1) 

The calculation `(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds.Div(State.MinerIncreaseInterval.Value).Mul(2)` produces a `long` value. The SafeMath operations (`Div` and `Mul` on `long`) return `long` values: [3](#0-2) 

However, the explicit `(int)` cast performs unchecked conversion that silently wraps on overflow rather than throwing an exception. Even though SafeMath's `Add` uses checked arithmetic, this occurs AFTER the unsafe cast has already corrupted the value.

**Root Cause: Missing Validation**

The `SetMinerIncreaseInterval` method lacks minimum bound validation: [4](#0-3) 

The validation only enforces `input.Value <= State.MinerIncreaseInterval.Value` (decreasing only), with no check for positive values or minimum bounds. The initialization also lacks validation: [5](#0-4) 

**Propagation to Election Contract**

The corrupted miner count propagates through `SetMaximumMinersCount`: [6](#0-5) 

And through `ProcessNextRound`: [7](#0-6) 

The Election contract stores the value without validation: [8](#0-7) 

## Impact Explanation

**HIGH Impact - Complete Consensus Failure**

**Scenario 1: Division by Zero DoS**
If governance sets `MinerIncreaseInterval = 0`, any subsequent call to `GetAutoIncreasedMinersCount()`, `GetMinersCount()`, or `GetMaximumMinersCount()` will trigger `DivideByZeroException` since SafeMath's `Div` operation naturally throws on division by zero. This completely breaks consensus operations that depend on these methods, halting block production and freezing the blockchain.

**Scenario 2: Integer Overflow State Corruption**
With `MinerIncreaseInterval = 1` second after 34.08 years of operation:
- Elapsed time: 1,073,741,824 seconds
- Calculation: (1,073,741,824 / 1) Ã— 2 = 2,147,483,648
- Exceeds `Int32.MaxValue` (2,147,483,647) by 1
- Cast wraps to `Int32.MinValue` (-2,147,483,648)
- Final result: 17 + (-2,147,483,648) = -2,147,483,631

This negative miner count corrupts consensus state across:
- AEDPoS consensus contract's miner count calculations
- Election contract's `MinersCount` state variable
- Round generation and time-slot allocation logic expecting positive values
- Potential downstream arithmetic errors in any logic using miner count

The protocol cannot function with invalid miner counts, causing complete consensus liveness failure where validators cannot produce blocks and the entire blockchain becomes inoperable.

## Likelihood Explanation

**MEDIUM Likelihood - Governance-Triggered with Multiple Paths**

**Attacker Capabilities**: Requires Parliament/governance authorization to call `SetMinerIncreaseInterval`. This is the normal operational state of the protocol, not a privileged compromise.

**Scenario 1 (Division by Zero)**: 
- Complexity: LOW
- Single governance proposal to set `MinerIncreaseInterval = 0`
- Immediate consensus failure on next miner count calculation
- No special timing or conditions required

**Scenario 2 (Integer Overflow)**:
- Complexity: MEDIUM
- Requires either:
  - Natural occurrence after 34+ years of operation with small intervals
  - Aggressive reduction of `MinerIncreaseInterval` through multiple governance proposals
- Less immediate but more insidious as overflow is silent

**Feasibility**: Governance control of Parliament is the normal operational state. The default interval (31,536,000 seconds = 1 year) provides initial protection, but this can be circumvented through legitimate governance actions. No monitoring exists for suspicious `MinerIncreaseInterval` values or calculations approaching overflow thresholds.

**Detection Constraints**: The overflow is completely silent until the cast completes, and there are no alerts or bounds checking to detect approaching critical values.

## Recommendation

Add comprehensive validation to prevent both division by zero and integer overflow:

1. **Minimum Bound Validation in `SetMinerIncreaseInterval`**:
   - Add assertion: `Assert(input.Value > 0, "MinerIncreaseInterval must be positive")`
   - Add minimum threshold: `Assert(input.Value >= MIN_MINER_INCREASE_INTERVAL, "MinerIncreaseInterval below minimum threshold")`
   - Consider a reasonable minimum like 86400 seconds (1 day) to prevent both DoS and premature overflow

2. **Validation in `InitialAElfConsensusContract`**:
   - Add same positive and minimum checks during initialization
   - Validate: `Assert(input.MinerIncreaseInterval > 0 && input.MinerIncreaseInterval >= MIN_MINER_INCREASE_INTERVAL, "Invalid MinerIncreaseInterval")`

3. **Safe Overflow Handling in Calculation Methods**:
   - Replace unchecked `(int)` cast with checked conversion that throws on overflow
   - Or use `long` throughout and only validate range when needed
   - Or add explicit overflow check: `Assert(calculatedValue <= Int32.MaxValue, "Miner count calculation overflow")`

4. **Validation in `UpdateMinersCount`**:
   - Add assertion: `Assert(input.MinersCount > 0, "MinersCount must be positive")`

## Proof of Concept

The vulnerability can be demonstrated with the following scenarios:

**Test 1: Division by Zero**
```csharp
// 1. Governance calls SetMinerIncreaseInterval with 0
SetMinerIncreaseInterval(new Int64Value { Value = 0 });

// 2. Any subsequent call to GetMaximumMinersCount will throw DivideByZeroException
// This demonstrates immediate DoS of consensus operations
GetMaximumMinersCount(new Empty()); // Throws DivideByZeroException
```

**Test 2: Integer Overflow** (requires simulating long runtime or manipulating time)
```csharp
// 1. Set very small interval
SetMinerIncreaseInterval(new Int64Value { Value = 1 });

// 2. Simulate blockchain running for 34+ years
// When (elapsed_seconds / 1) * 2 exceeds Int32.MaxValue:
// Result wraps to negative value, corrupting consensus state
GetMaximumMinersCount(new Empty()); // Returns negative value
```

The actual overflow calculation: When `elapsed_seconds = 1,073,741,824` and `MinerIncreaseInterval = 1`, the result `(1,073,741,824 / 1) * 2 = 2,147,483,648` exceeds `Int32.MaxValue` and wraps to negative.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L79-90)
```csharp
    public static long Mul(this long a, long b)
    {
        checked
        {
            return a * b;
        }
    }

    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L22-32)
```csharp
    public override Empty InitialAElfConsensusContract(InitialAElfConsensusContractInput input)
    {
        Assert(State.CurrentRoundNumber.Value == 0 && !State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        State.PeriodSeconds.Value = input.IsTermStayOne
            ? int.MaxValue
            : input.PeriodSeconds;

        State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L126-135)
```csharp
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```
