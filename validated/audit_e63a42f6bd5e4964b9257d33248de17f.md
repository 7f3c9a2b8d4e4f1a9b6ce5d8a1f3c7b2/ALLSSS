# Audit Report

## Title
Original SEED Creator Can Sabotage Transferred SEEDs by Setting Expiration to Past

## Summary
The `ExtendSeedExpirationTime()` function uses `tokenInfo.Owner` for authorization, which is never updated when SEED NFTs are transferred. This allows the original creator to set the expiration time to the past even after selling the SEED, permanently destroying its utility and causing direct financial loss to the buyer.

## Finding Description
The vulnerability stems from a critical disconnect between **balance ownership** (who holds the tokens) and **metadata ownership** (the `tokenInfo.Owner` field) in the MultiToken contract's SEED NFT system.

When a SEED NFT is created, the `tokenInfo.Owner` field is set to the creator's address during token creation. [1](#0-0)  For SEED NFTs specifically, this owner field is validated and must match the collection owner. [2](#0-1) 

When the SEED is transferred via `Transfer()`, the function only modifies balance mappings through `DoTransfer()`. [3](#0-2)  The `DoTransfer()` function exclusively calls `ModifyBalance()` to update sender and receiver balances. [4](#0-3)  The `ModifyBalance()` function only updates the balance state mapping. [5](#0-4)  The `DealWithExternalInfoDuringTransfer()` helper only handles callbacks and logging, never touching the owner field. [6](#0-5) 

The `tokenInfo.Owner` field can only be changed through `ModifyTokenIssuerAndOwner()`, which explicitly requires the token's owner field to be null. [7](#0-6)  Since SEED NFTs are created with an owner, this method cannot be used to fix the ownership after transfers.

The `ExtendSeedExpirationTime()` function authorizes callers by checking `tokenInfo.Owner == Context.Sender`, not the current balance holder. [8](#0-7)  Critically, this function **imposes no validation** that the new expiration time must be in the future - it directly sets whatever timestamp is provided at lines 711-712.

When the SEED is later used to create a token, the `CheckSeedNFT()` validation function checks if the expiration time has passed. [9](#0-8)  If the expiration has been set to the past (e.g., timestamp 1), the check at line 130 fails with "OwnedSymbol is expired.", making the SEED permanently unusable despite the new owner having valid balance.

**Attack Flow:**
1. Alice creates SEED-1 NFT (`tokenInfo.Owner` = Alice, `State.Balances[Alice][SEED-1]` = 1)
2. Alice transfers SEED-1 to Bob (balances update to `State.Balances[Bob][SEED-1]` = 1, but `tokenInfo.Owner` remains Alice)
3. Alice calls `ExtendSeedExpirationTime({Symbol: "SEED-1", ExpirationTime: 1})`
4. Authorization passes because Alice == `tokenInfo.Owner`
5. Bob's SEED is now expired and unusable, causing complete financial loss

## Impact Explanation
**Direct Financial Loss:** SEED NFTs are valuable assets that grant exclusive rights to create tokens with specific symbols. They are tradeable on secondary markets. By setting the expiration to the past, the original creator permanently destroys the SEED's utility, making the buyer's purchase worthless.

**Who is Affected:** Any user who purchases or receives a SEED NFT from its original creator through legitimate transfers, marketplace transactions, or OTC trades.

**Severity: HIGH** - This enables theft-equivalent damage where Alice can destroy the value of assets she no longer possesses, with zero cost to execute (single transaction), no technical barriers, and no recovery mechanism. The attack is undetectable until Bob attempts to use the SEED. The SEED becomes permanently unusable as the expiration check in `CheckSeedNFT()` will always fail for past timestamps.

## Likelihood Explanation
**Entry Point:** `ExtendSeedExpirationTime()` is a public method directly accessible via transaction submission.

**Attacker Prerequisites:** The attacker must be the original creator (or designated `tokenInfo.Owner`) of a SEED NFT that has been transferred to another party. This is a **common scenario** in NFT marketplaces and secondary sales.

**Attack Complexity:** Trivial - requires only a single transaction with `ExpirationTime = 1` or any past timestamp. No special privileges beyond being the original creator are needed.

**Economic Rationality:**
- **Griefing attacks:** Malicious sellers sabotage buyers post-sale
- **Market manipulation:** Devalue competitor SEEDs or manipulate prices
- **Front-running:** Seller lists SEED, observes incoming purchase, front-runs with expiration modification
- **Exit scams:** Large-scale SEED creator sells inventory then destroys all sold SEEDs

**Likelihood: HIGH** - The vulnerability is directly reachable, requires only common preconditions (SEED transfer), and has multiple rational attack motivations.

## Recommendation
Implement one or more of the following fixes:

**Option 1: Update owner on transfer**
Modify the transfer logic to update `tokenInfo.Owner` to the recipient for SEED NFTs, ensuring ownership metadata matches balance ownership.

**Option 2: Validate expiration time must be in the future**
Add validation in `ExtendSeedExpirationTime()`:
```csharp
Assert(input.ExpirationTime >= Context.CurrentBlockTime.Seconds, 
       "Expiration time must be in the future.");
```

**Option 3: Check balance holder authorization**
Change authorization in `ExtendSeedExpirationTime()` to verify the sender holds the SEED balance:
```csharp
Assert(State.Balances[Context.Sender][input.Symbol] > 0, 
       "Sender does not hold the Seed NFT.");
```

**Option 4: Disable modification after transfer**
Track if a SEED has been transferred and prevent expiration modification after the first transfer.

The recommended approach is **Option 1** combined with **Option 2** for defense-in-depth, as it aligns ownership semantics with standard NFT behavior while preventing past-dated expiration times.

## Proof of Concept
```csharp
[Fact]
public async Task SeedExpirationSabotage_AfterTransfer_Test()
{
    // Step 1: Alice creates SEED NFT
    var seedSymbol = "SEED-SABOTAGE";
    var targetSymbol = "VICTIM";
    var aliceStub = TokenContractStub; // Alice's stub
    
    var createInput = new CreateInput
    {
        Symbol = seedSymbol,
        Decimals = 0,
        IsBurnable = true,
        TokenName = "Sabotage Seed",
        TotalSupply = 1,
        Issuer = DefaultAddress,
        Owner = DefaultAddress, // Alice is owner
        ExternalInfo = new ExternalInfo()
    };
    createInput.ExternalInfo.Value["__seed_owned_symbol"] = targetSymbol;
    createInput.ExternalInfo.Value["__seed_exp_time"] = 
        TimestampHelper.GetUtcNow().AddDays(365).Seconds.ToString();
    
    await aliceStub.Create.SendAsync(createInput);
    
    // Step 2: Alice transfers SEED to Bob
    var bobAddress = Accounts[1].Address;
    await aliceStub.Transfer.SendAsync(new TransferInput
    {
        To = bobAddress,
        Symbol = seedSymbol,
        Amount = 1,
        Memo = "Sale to Bob"
    });
    
    // Verify Bob has the balance
    var bobBalance = await aliceStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = bobAddress,
        Symbol = seedSymbol
    });
    bobBalance.Balance.ShouldBe(1);
    
    // Step 3: Alice sabotages by setting expiration to past (timestamp = 1)
    await aliceStub.ExtendSeedExpirationTime.SendAsync(
        new ExtendSeedExpirationTimeInput
        {
            Symbol = seedSymbol,
            ExpirationTime = 1 // Far in the past
        });
    
    // Step 4: Bob attempts to create token using the SEED - should fail
    var bobStub = GetTokenContractStub(Accounts[1].KeyPair);
    
    var tokenCreateInput = new CreateInput
    {
        Symbol = targetSymbol,
        TokenName = "Victim Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = bobAddress,
        IsBurnable = true
    };
    
    var result = await bobStub.Create.SendWithExceptionAsync(tokenCreateInput);
    
    // Verify the SEED is now unusable due to expired timestamp
    result.TransactionResult.Error.ShouldContain("OwnedSymbol is expired");
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L118-131)
```csharp
    private void CheckSeedNFT(string symbolSeed, String symbol)
    {
        Assert(!string.IsNullOrEmpty(symbolSeed), "Seed NFT does not exist.");
        var tokenInfo = GetTokenInfo(symbolSeed);
        Assert(tokenInfo != null, "Seed NFT does not exist.");
        Assert(State.Balances[Context.Sender][symbolSeed] > 0, "Seed NFT balance is not enough.");
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L642-659)
```csharp
    public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
    {
        Assert(!State.TokenIssuerAndOwnerModificationDisabled.Value, "Set token issuer and owner disabled.");
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
        Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");

        var tokenInfo = GetTokenInfo(input.Symbol);

        Assert(tokenInfo != null, "Token is not found.");
        Assert(tokenInfo.Issuer == Context.Sender, "Only token issuer can set token issuer and owner.");
        Assert(tokenInfo.Owner == null, "Can only set token which does not have owner.");
        
        tokenInfo.Issuer = input.Issuer;
        tokenInfo.Owner = input.Owner;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L695-722)
```csharp
    public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo == null)
        {
            throw new AssertionException("Seed NFT does not exist.");
        }

        Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
        var oldExpireTimeLong = 0L;
        if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                out var oldExpireTime))
        {
            long.TryParse(oldExpireTime, out oldExpireTimeLong);
        }

        tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
            input.ExpirationTime.ToString();
        State.TokenInfos[input.Symbol] = tokenInfo;
        Context.Fire(new SeedExpirationTimeUpdated
        {
            ChainId = tokenInfo.IssueChainId,
            Symbol = input.Symbol,
            OldExpirationTime = oldExpireTimeLong,
            NewExpirationTime = input.ExpirationTime
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L35-36)
```csharp
        var owner = nftCollectionInfo.Owner ?? nftCollectionInfo.Issuer;
        Assert(Context.Sender == owner && owner == input.Owner, "NFT owner must be collection's owner");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L99-114)
```csharp
    private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
    {
        Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
        Assert(from != to, "Can't do transfer to sender itself.");
        AssertValidMemo(memo);
        ModifyBalance(from, symbol, -amount);
        ModifyBalance(to, symbol, amount);
        Context.Fire(new Transferred
        {
            From = from,
            To = to,
            Symbol = symbol,
            Amount = amount,
            Memo = memo ?? string.Empty
        });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```
