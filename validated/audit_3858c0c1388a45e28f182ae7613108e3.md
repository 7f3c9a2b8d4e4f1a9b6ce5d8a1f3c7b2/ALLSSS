# Audit Report

## Title
Unbounded Token Symbol Accumulation Causes DOS in Profit Claiming

## Summary
The Profit contract's `ReceivedTokenSymbols` list lacks size limits, allowing unlimited token types to accumulate. When beneficiaries claim profits via `ClaimProfits`, nested iteration through all symbols and periods causes transaction complexity to exceed execution limits, resulting in denial of service for legitimate profit claims.

## Finding Description

The vulnerability exists in the profit claiming mechanism where token symbols accumulate without bounds in the `Scheme` structure. [1](#0-0) 

Symbols are added without size validation in two locations:

1. **In `DistributeProfitsForSubSchemes`**: When distributing to sub-schemes, the method adds new token symbols to `ReceivedTokenSymbols` without checking list size. [2](#0-1) 

2. **In `ContributeProfits`**: Any user can contribute profits with any valid token symbol. The method has no access control restrictions and adds new symbols without size limits. [3](#0-2)  The specific symbol addition occurs at: [4](#0-3) 

When `ClaimProfits` is called, it processes up to 10 profit details by calling `ProfitAllPeriods` for each. [5](#0-4) 

The `ProfitAllPeriods` method creates a nested loop structure that iterates through ALL symbols in the unbounded `ReceivedTokenSymbols` list and for each symbol loops through periods up to `maxProfitReceivingPeriodCount` (default 100). [6](#0-5) 

The symbol loop specifically retrieves all received token symbols: [7](#0-6) 

Each iteration performs state reads to retrieve `DistributedProfitsInfo` and may generate inline token transfers. [8](#0-7) 

The constant `TokenAmountLimit = 5` only applies to method fee configuration in `SetMethodFee`, not to `ReceivedTokenSymbols`. [9](#0-8) [10](#0-9) 

The maximum period count defaults to 100. [11](#0-10) 

## Impact Explanation

**Direct Impact:**
- Beneficiaries cannot claim their legitimate profits when many token symbols accumulate
- Transaction complexity: 10 profit details × N symbols × 100 periods = 1,000N iterations
- With 100+ token types, a single claim requires 100,000+ loop iterations with state reads
- Transaction will timeout or exceed resource limits

**Who is Affected:**
- All beneficiaries of schemes with many accumulated token types
- Particularly severe for long-running treasury schemes accepting diverse tokens

**Operational Damage:**
- Legitimate profit claims fail due to transaction resource exhaustion
- Users experience poor UX requiring workarounds
- In extreme cases, profits may become permanently unclaimable

**Severity Justification (Low):**
- No direct fund theft or permanent loss
- Funds remain securely in the contract
- DOS is operational rather than complete system failure
- Can be mitigated through careful scheme design
- Attack requires non-trivial economic cost (owning/creating many different tokens and transferring them)

## Likelihood Explanation

**Attacker Capabilities:**
Any user can call `ContributeProfits` to add new token symbols to a scheme without requiring manager permissions or special privileges.

**Attack Complexity:**
1. Attacker identifies target profit scheme
2. Creates or obtains many different token types (incurs cost)
3. Calls `ContributeProfits` repeatedly with minimal amounts of each different token
4. Each call adds new symbol to `ReceivedTokenSymbols` if not already present
5. Accumulates hundreds of different token symbols
6. Beneficiaries calling `ClaimProfits` hit complexity limits and transaction failures

**Feasibility:**
- **Natural Occurrence**: Multi-token treasury or reward schemes can legitimately accumulate dozens of tokens through normal operations (Medium-High probability)
- **Accelerated Attack**: Malicious actor can deliberately speed up accumulation (Low-Medium probability due to economic costs)
- **Economic Barrier**: Attacker must own tokens and pay transaction fees, but minimal amounts suffice

**Detection/Constraints:**
- No on-chain detection mechanism for this attack
- AElf transaction limits will eventually reject transactions
- No circuit breaker for symbol count

## Recommendation

Implement a maximum limit on `ReceivedTokenSymbols` list size:

1. Add a constant for maximum token symbols (e.g., `MaxTokenSymbolsPerScheme = 50`)
2. Check symbol count before adding in both `DistributeProfitsForSubSchemes` and `ContributeProfits`
3. Revert transaction if limit would be exceeded
4. Consider allowing scheme managers to prune old/unused token symbols

Alternative mitigations:
- Implement pagination for profit claiming across multiple transactions
- Allow claiming profits for specific token symbols rather than all at once
- Add manager-only restriction to `ContributeProfits` for public schemes

## Proof of Concept

A test case would demonstrate:
1. Create a profit scheme
2. Call `ContributeProfits` repeatedly with 100+ different token symbols (each with minimal amounts)
3. Add a beneficiary with shares
4. Call `DistributeProfits` to distribute profits across all token types
5. Attempt to call `ClaimProfits` as the beneficiary
6. Observe transaction failure due to excessive computational complexity

The transaction would require approximately 100,000+ loop iterations (10 details × 100 symbols × 100 periods), exceeding practical execution limits and causing the claim to fail while leaving funds inaccessible to legitimate beneficiaries.

### Citations

**File:** protobuf/profit_contract.proto (L159-159)
```text
    repeated string received_token_symbols = 12;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L641-644)
```csharp
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-720)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
        // ReSharper disable once PossibleNullReferenceException
        var virtualAddress = scheme.VirtualAddress;

        if (input.Period == 0)
        {

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = virtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = $"Add {input.Amount} dividends."
            });
        }
        else
        {
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
        }

        // If someone directly use virtual address to do the contribution, won't sense the token symbol he was using.
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);

        State.SchemeInfos[scheme.SchemeId] = scheme;

        return new Empty();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L773-784)
```csharp
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
        // Only can get profit from last profit period to actual last period (profit.CurrentPeriod - 1),
        // because current period not released yet.
        for (var i = 0; i < profitableDetailCount; i++)
        {
            var profitDetail = profitableDetails[i];
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L845-920)
```csharp
    private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
        bool isView = false, string targetSymbol = null)
    {
        var profitsMap = new Dictionary<string, long>();
        var lastProfitPeriod = profitDetail.LastProfitPeriod;

        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }

        profitDetail.LastProfitPeriod = lastProfitPeriod;

        return profitsMap;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L8-8)
```csharp
    public const int TokenAmountLimit = 5;
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L9-9)
```csharp
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        Assert(input.Fees.Count <= ProfitContractConstants.TokenAmountLimit, "Invalid input.");
        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```
