# Audit Report

## Title
Miners Can Force UpdateValue Behaviour to Prevent Round/Term Transitions

## Summary
The AEDPoS consensus contract allows miners to arbitrarily choose their consensus behaviour when producing blocks. The validation system validates data format for each behaviour type but critically fails to enforce that the behaviour choice itself is appropriate for the current consensus state. This enables malicious miners to force UpdateValue behaviour when they should terminate rounds with NextRound or NextTerm, causing consensus stalling and block production monopolization.

## Finding Description

The consensus system has a fundamental architectural flaw in how it determines and validates consensus behaviours.

**Behaviour Determination (Advisory Only):**
The contract determines expected behaviour through `GetConsensusBehaviour()` which uses `IsTimeSlotPassed()` to decide whether a miner should update values within their time slot or terminate the round. [1](#0-0)  When `IsTimeSlotPassed()` returns true (time slot has expired), the method calls `GetConsensusBehaviourToTerminateCurrentRound()` which returns NextRound or NextTerm. [2](#0-1) 

**Miner-Controlled Behaviour Field:**
However, this determination is purely advisory. Miners provide their own behaviour choice in the `behaviour` field of `AElfConsensusTriggerInformation`. The `GetConsensusBlockExtraData` method directly uses whatever behaviour the miner provides via a switch statement, without validating that this matches the expected behaviour. [3](#0-2) 

**No Validation of Behaviour Appropriateness:**
The validation system in `ValidateBeforeExecution` selects different validators based on the miner-provided behaviour. [4](#0-3)  For UpdateValue behaviour, it adds `UpdateValueValidationProvider` which only validates that OutValue and Signature fields are properly filled, not whether UpdateValue should be used at all. [5](#0-4) 

The `TimeSlotValidationProvider` checks that `latestActualMiningTime < endOfExpectedTimeSlot`, which validates that the miner's PREVIOUS mining time was within their allocated time slot. [6](#0-5)  This does not prevent a miner who already mined during their slot from continuing to use UpdateValue after their time slot has passed.

**Missing Critical Validator:**
There is no validator that enforces: "If `IsTimeSlotPassed()` returns true, reject UpdateValue and require NextRound/NextTerm." This gap allows malicious miners to continuously submit UpdateValue when consensus protocol requires round termination.

**Attack Execution:**
1. Malicious miner produces their first block during their time slot using UpdateValue (passes all validations)
2. Miner's time slot expires - protocol expects NextRound/NextTerm
3. Miner continues producing UpdateValue blocks instead
4. `MiningPermissionValidationProvider` passes: miner is in the valid miner list [7](#0-6) 
5. `TimeSlotValidationProvider` passes: their LAST mining time was within their slot
6. `UpdateValueValidationProvider` passes: data is well-formed
7. Round never advances, other miners cannot mine (their time slots are in the stalled round)

## Impact Explanation

This vulnerability breaks the fundamental consensus invariant that rounds and terms must progress according to the time-slot schedule. The impact is critical and multi-faceted:

**Consensus Stalling:** The round never advances because `GenerateNextRoundInformation` is only called by NextRound transactions. [8](#0-7)  Without round progression, the blockchain effectively halts new miner participation.

**Block Production Monopolization:** Other miners cannot mine because their `ExpectedMiningTime` values are calculated relative to the current round's start time, which remains fixed. As time progresses past all miners' time slots in the stalled round, only the malicious miner (who ignores the time slot constraint) can continue producing blocks.

**Reward Capture:** The malicious miner monopolizes all block rewards that should be distributed across the miner set over multiple rounds, creating severe economic damage.

**LIB Calculation Failure:** Last Irreversible Block calculation depends on multiple miners providing inputs across rounds. Single-miner monopolization breaks this distributed trust mechanism.

**Term Transition Prevention:** On main chain, malicious miners can prevent NextTerm transitions, maintaining an outdated miner set indefinitely and blocking legitimate validator rotation through the election process.

## Likelihood Explanation

The likelihood of exploitation is HIGH due to multiple factors:

**Low Barrier to Entry:** Any active miner in the miner set can execute this attack. The miner role is obtained through normal protocol operations (staking tokens and election), not through exploiting a separate vulnerability.

**Simple Technical Execution:** The attack requires minimal modification to a mining node - simply override the `behaviour` field in `AElfConsensusTriggerInformation` to always use UpdateValue. The off-chain `AEDPoSTriggerInformationProvider` generates the correct hint, but miners can modify this. [9](#0-8) 

**Passes All Validations:** The attack succeeds because the validation system has a fundamental architectural gap - it validates data format but not behaviour appropriateness. All three core validators (`MiningPermissionValidationProvider`, `TimeSlotValidationProvider`, `UpdateValueValidationProvider`) pass for well-formed UpdateValue data.

**High Economic Incentive:** Monopolizing block production is highly profitable through reward accumulation while preventing competitors from earning.

**Difficult to Detect:** The attack appears as normal UpdateValue transactions on-chain. Distinguishing malicious from legitimate UpdateValue requires off-chain monitoring to detect when a miner should have terminated the round based on time slot expiration.

## Recommendation

Add a new validation provider that enforces behaviour appropriateness based on consensus state:

```csharp
public class BehaviourAppropriatenessValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var baseRound = validationContext.BaseRound;
        var senderPubkey = validationContext.SenderPubkey;
        var currentBlockTime = validationContext.ExtraData.Round.RealTimeMinersInformation[senderPubkey]
            .ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        
        if (currentBlockTime == null) 
            return new ValidationResult { Success = true };
            
        var isTimeSlotPassed = baseRound.IsTimeSlotPassed(senderPubkey, currentBlockTime);
        
        // If time slot has passed, only allow round termination behaviours
        if (isTimeSlotPassed)
        {
            if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.UpdateValue ||
                validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            {
                return new ValidationResult 
                { 
                    Message = $"Time slot has passed. Expected NextRound or NextTerm, got {validationContext.ExtraData.Behaviour}" 
                };
            }
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Add this validator to the basic providers list in `ValidateBeforeExecution`:

```csharp
var validationProviders = new List<IHeaderInformationValidationProvider>
{
    new MiningPermissionValidationProvider(),
    new TimeSlotValidationProvider(),
    new ContinuousBlocksValidationProvider(),
    new BehaviourAppropriatenessValidationProvider() // Add this
};
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanForceUpdateValue_WhenShouldTerminateRound()
{
    // Setup: Complete first round with all miners except last (extra block producer)
    await InitializeConsensusAndMinersAsync();
    var extraBlockMinerKeyPair = BootMinerKeyPair;
    KeyPairProvider.SetKeyPair(extraBlockMinerKeyPair);
    
    // Extra block miner mines during their time slot (legitimate)
    var consensusCommand = await AEDPoSContractStub.GetConsensusCommand.CallAsync(
        TriggerInformationProvider.GetTriggerInformationForConsensusCommand(new BytesValue()));
    consensusCommand.Hint.ToAElfConsensusHint().Behaviour.ShouldBe(AElfConsensusBehaviour.NextRound);
    
    // Advance time PAST the extra block producer's time slot
    BlockTimeProvider.SetBlockTime(BlockchainStartTimestamp + new Duration
    {
        Seconds = AEDPoSContractTestConstants.MiningInterval
            .Mul(AEDPoSContractTestConstants.InitialMinersCount + 1).Div(1000)
    });
    
    // ATTACK: Malicious miner overrides behaviour to UpdateValue instead of NextRound
    var maliciousHint = new AElfConsensusHint { Behaviour = AElfConsensusBehaviour.UpdateValue };
    consensusCommand.Hint = maliciousHint.ToByteString();
    
    var triggerForExtraData = TriggerInformationProvider
        .GetTriggerInformationForBlockHeaderExtraData(consensusCommand.ToBytesValue());
    var extraDataBytes = await AEDPoSContractStub.GetConsensusExtraData.CallAsync(triggerForExtraData);
    
    // VULNERABILITY: Validation passes even though behaviour is inappropriate
    var validationResult = await AEDPoSContractStub.ValidateConsensusBeforeExecution
        .CallAsync(extraDataBytes);
    validationResult.Success.ShouldBeTrue(); // Should be FALSE but passes!
    
    // Execute the malicious UpdateValue
    var triggerForTransaction = TriggerInformationProvider
        .GetTriggerInformationForConsensusTransactions(new ChainContext(), consensusCommand.ToBytesValue());
    var transactions = await AEDPoSContractStub.GenerateConsensusTransactions
        .CallAsync(triggerForTransaction);
    transactions.Transactions[0].MethodName.ShouldBe(nameof(AEDPoSContractStub.UpdateValue));
    
    var updateValueInput = UpdateValueInput.Parser.ParseFrom(transactions.Transactions[0].Params);
    await AEDPoSContractStub.UpdateValue.SendAsync(updateValueInput);
    
    // IMPACT: Round is still 1 (should have advanced to round 2)
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.RoundNumber.ShouldBe(1); // Consensus is stalled!
}
```

## Notes

This vulnerability exists because the consensus system separates behaviour determination (`GetConsensusBehaviour`) from behaviour execution (`GetConsensusBlockExtraData`) and validation (`ValidateBeforeExecution`), but fails to enforce consistency between the determination and the actual execution. The determination is treated as advisory guidance for honest miners rather than a protocol-enforced requirement. A malicious miner can ignore this guidance and the protocol has no mechanism to detect or prevent the deviation.

The fix requires adding explicit validation that the provided behaviour matches what the consensus state requires, particularly enforcing that UpdateValue cannot be used when `IsTimeSlotPassed()` indicates round termination is required.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-99)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L13-53)
```csharp
    private BytesValue GetConsensusBlockExtraData(BytesValue input, bool isGeneratingTransactions = false)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);

        Assert(triggerInformation.Pubkey.Any(), "Invalid pubkey.");

        TryToGetCurrentRoundInformation(out var currentRound);

        var publicKeyBytes = triggerInformation.Pubkey;
        var pubkey = publicKeyBytes.ToHex();

        var information = new AElfConsensusHeaderInformation();
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
        }

        if (!isGeneratingTransactions) information.Round.DeleteSecretSharingInformation();

        return information.ToBytesValue();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-104)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }

        var service = new HeaderInformationValidationService(validationProviders);

        Context.LogDebug(() => $"Validating behaviour: {extraData.Behaviour.ToString()}");

        var validationResult = service.ValidateInformation(validationContext);

        if (validationResult.Success == false)
            Context.LogDebug(() => $"Consensus Validation before execution failed : {validationResult.Message}");

        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L41-75)
```csharp
    public BytesValue GetTriggerInformationForBlockHeaderExtraData(BytesValue consensusCommandBytes)
    {
        if (consensusCommandBytes == null)
            return new AElfConsensusTriggerInformation
            {
                Pubkey = Pubkey,
                Behaviour = AElfConsensusBehaviour.UpdateValue
            }.ToBytesValue();

        var command = consensusCommandBytes.ToConsensusCommand();
        var hint = command.Hint.ToAElfConsensusHint();

        if (hint.Behaviour == AElfConsensusBehaviour.UpdateValue)
        {
            var newInValue = _inValueCache.GetInValue(hint.RoundId);
            var previousInValue = _inValueCache.GetInValue(hint.PreviousRoundId);
            Logger.LogDebug($"New in value {newInValue} for round of id {hint.RoundId}");
            Logger.LogDebug($"Previous in value {previousInValue} for round of id {hint.PreviousRoundId}");
            var trigger = new AElfConsensusTriggerInformation
            {
                Pubkey = Pubkey,
                InValue = newInValue,
                PreviousInValue = previousInValue,
                Behaviour = hint.Behaviour
            };

            return trigger.ToBytesValue();
        }

        return new AElfConsensusTriggerInformation
        {
            Pubkey = Pubkey,
            Behaviour = hint.Behaviour
        }.ToBytesValue();
    }
```
