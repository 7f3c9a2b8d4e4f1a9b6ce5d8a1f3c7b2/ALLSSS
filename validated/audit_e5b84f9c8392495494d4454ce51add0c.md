# Audit Report

## Title
Non-Deterministic Miner Selection in FirstMiner() Due to MapField Iteration Order and Missing Order Uniqueness Validation

## Summary
The `FirstMiner()` method uses non-deterministic protobuf MapField iteration to find the miner with `Order == 1`, while validation logic fails to enforce Order field uniqueness. A malicious miner can exploit this by submitting a `NextRoundInput` with duplicate Order values, causing different nodes to return different miners from `FirstMiner()`, resulting in consensus failure and potential chain fork.

## Finding Description

The vulnerability exists at the intersection of two critical flaws:

**Flaw 1: Non-Deterministic MapField Iteration**

The `FirstMiner()` method relies on `RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == 1)` [1](#0-0) , where `RealTimeMinersInformation` is defined as a protobuf map type [2](#0-1) . Google.Protobuf's MapField does not guarantee deterministic iteration order across different nodes or serialization cycles.

**Flaw 2: Missing Order Field Uniqueness Validation**

When a miner submits `NextRoundInput` via the `NextRound` behavior, the input is converted to a Round object [3](#0-2)  and processed [4](#0-3) . 

The validation system applies `NextRoundMiningOrderValidationProvider` [5](#0-4) , which only validates `FinalOrderOfNextRound` uniqueness, NOT the `Order` field itself [6](#0-5) .

**Attack Scenario:**

A malicious miner who is in the current miner list (required to pass PreCheck) can craft a `NextRoundInput` where two miners have `Order == 1` but with unique `FinalOrderOfNextRound` values. This input would:
1. Pass miner permission checks
2. Pass `FinalOrderOfNextRound` uniqueness validation  
3. Pass time slot validation (which sorts by Order but doesn't enforce uniqueness)
4. Be accepted and stored in state

**Consensus Divergence:**

Once stored, different nodes would experience non-deterministic behavior when calling `FirstMiner()`:
- Node A's MapField iteration might return Miner X as the first element with Order==1
- Node B's MapField iteration might return Miner Y as the first element with Order==1

This divergence cascades to multiple consensus-critical functions:
- `GetRoundStartTime()` returns different timestamps [7](#0-6) 
- `IsTimeSlotPassed()` checks different miners' ActualMiningTimes [8](#0-7) 
- `ConsensusBehaviourProviderBase` checks different miners' OutValue [9](#0-8) 
- `GetMiningInterval()` retrieves miners with Order==1 or Order==2 non-deterministically [10](#0-9) 

**Secondary Issue:**

Additionally, `GenerateNextRoundInformation` contains non-deterministic code when selecting the extra block producer if the expected miner is null, using `.First()` on MapField.Values without any ordering [11](#0-10) .

## Impact Explanation

**Critical Consensus Integrity Breach:**

This vulnerability breaks the fundamental consensus guarantee that all honest nodes must reach the same state given the same inputs. When different nodes return different miners from `FirstMiner()`:

1. **Divergent Block Production**: Nodes would calculate different consensus behaviors, leading some to expect different miners to produce blocks
2. **Chain Fork**: Nodes would reject each other's blocks as invalid due to inconsistent consensus state expectations
3. **Network Partition**: The blockchain would fork, with different subsets of nodes following different chains
4. **Loss of Finality**: The network would lose its ability to reach irreversible block height consensus

**Affected Parties:**
- All network nodes experience consensus failure
- Users cannot reliably transact as the network halts or fragments
- Protocol integrity is completely compromised

The severity is **CRITICAL** because it directly breaks the consensus layer, which is the foundation of blockchain security.

## Likelihood Explanation

**Attack Feasibility: Medium**

**Required Preconditions:**
1. Attacker must be an active miner in the current round (passes `PreCheck()` validation)
2. Attacker must craft a malicious `NextRoundInput` with duplicate Order values
3. The `FinalOrderOfNextRound` values must still be unique (to bypass existing validation)

**Why Existing Protections Fail:**

The validation logic explicitly checks only `FinalOrderOfNextRound` distinctness, not `Order` field uniqueness. The `CheckRoundTimeSlots()` method [12](#0-11)  sorts miners by Order but doesn't reject duplicates.

**Normal Operation Safety:**

Under normal conditions, `GenerateNextRoundInformation` ensures Order uniqueness through `occupiedOrders` tracking [13](#0-12) . However, this provides no protection against maliciously crafted external inputs.

**Detection Difficulty:**

Non-deterministic consensus failures would manifest as seemingly random block rejections across nodes, making diagnosis extremely difficult without deep protocol analysis.

**Overall Probability: Medium**

While requiring miner status raises the bar, the complete absence of Order validation makes exploitation straightforward for any malicious miner. The impact severity combined with feasible attack conditions warrants immediate remediation.

## Recommendation

**Primary Fix: Add Order Field Uniqueness Validation**

Extend `NextRoundMiningOrderValidationProvider` to validate Order field uniqueness:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var providedRound = validationContext.ProvidedRound;
    
    // Existing FinalOrderOfNextRound validation
    var distinctCount = providedRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0)
        .Distinct().Count();
    if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound.";
        return validationResult;
    }

    // NEW: Validate Order field uniqueness
    var orderValues = providedRound.RealTimeMinersInformation.Values.Select(m => m.Order).ToList();
    if (orderValues.Count != orderValues.Distinct().Count())
    {
        validationResult.Message = "Duplicate Order values detected in round information.";
        return validationResult;
    }

    validationResult.Success = true;
    return validationResult;
}
```

**Secondary Fix: Make FirstMiner() Deterministic**

Replace non-deterministic MapField iteration with deterministic lookup:

```csharp
public MinerInRound FirstMiner()
{
    if (RealTimeMinersInformation.Count == 0)
        return new MinerInRound();
    
    // Use OrderBy for deterministic behavior
    return RealTimeMinersInformation.Values
        .OrderBy(m => m.Pubkey) // Deterministic tiebreaker
        .FirstOrDefault(m => m.Order == 1) ?? new MinerInRound();
}
```

**Tertiary Fix: Fix GenerateNextRoundInformation**

Replace non-deterministic `.First()` with deterministic selection:

```csharp
var expectedExtraBlockProducer =
    nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
if (expectedExtraBlockProducer == null)
    // Use deterministic ordering instead of arbitrary First()
    nextRound.RealTimeMinersInformation.Values.OrderBy(m => m.Pubkey).First().IsExtraBlockProducer = true;
else
    expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

## Proof of Concept

```csharp
[Fact]
public async Task NonDeterministicFirstMiner_WithDuplicateOrders_CausesConsensusDivergence()
{
    // Arrange: Create a malicious NextRoundInput with duplicate Order values
    var currentRound = await GetCurrentRoundInformation();
    var minerList = currentRound.RealTimeMinersInformation.Keys.ToList();
    
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RealTimeMinersInformation = 
        {
            // Both miners have Order == 1 (DUPLICATE)
            [minerList[0]] = new MinerInRound 
            { 
                Pubkey = minerList[0], 
                Order = 1,  // Duplicate!
                FinalOrderOfNextRound = 1,
                ExpectedMiningTime = TimestampHelper.GetUtcNow().AddSeconds(4)
            },
            [minerList[1]] = new MinerInRound 
            { 
                Pubkey = minerList[1], 
                Order = 1,  // Duplicate!
                FinalOrderOfNextRound = 2,  // Unique FinalOrder (passes validation)
                ExpectedMiningTime = TimestampHelper.GetUtcNow().AddSeconds(8)
            }
        },
        RandomNumber = GenerateRandomNumber()
    };
    
    // Act: Submit the malicious NextRoundInput
    var result = await AEDPoSContractStub.NextRound.SendAsync(maliciousNextRound);
    
    // Assert: Transaction succeeds (validation doesn't catch duplicate Orders)
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: The round was stored with duplicate Orders
    var storedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var minersWithOrderOne = storedRound.RealTimeMinersInformation.Values
        .Where(m => m.Order == 1).ToList();
    
    // VULNERABILITY CONFIRMED: Multiple miners have Order == 1
    minersWithOrderOne.Count.ShouldBe(2);
    
    // Demonstrate non-deterministic behavior
    var firstMiner1 = storedRound.FirstMiner();
    // Different nodes would get different results here due to MapField iteration order
    // This would cause consensus divergence and chain fork
}
```

**Notes:**
- The vulnerability is confirmed through code analysis showing the validation gap
- Protobuf MapField iteration order non-determinism is a well-documented property
- The attack requires miner privileges but no other special conditions
- Impact is critical as it breaks consensus integrity at the protocol level

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L92-93)
```csharp
        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L105-108)
```csharp
    public Timestamp GetRoundStartTime()
    {
        return FirstMiner().ExpectedMiningTime;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L142-148)
```csharp
    public MinerInRound FirstMiner()
    {
        return RealTimeMinersInformation.Count > 0
            ? RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == 1)
            // Unlikely.
            : new MinerInRound();
    }
```

**File:** protobuf/aedpos_contract.proto (L247-247)
```text
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L94-102)
```csharp
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L60-65)
```csharp
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```
