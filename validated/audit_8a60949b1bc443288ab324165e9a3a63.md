# Audit Report

## Title
Method Fee Controller Capture Through Unchecked External Call in Organization Validation

## Summary
The `ChangeMethodFeeController` function in multiple AElf governance contracts (Parliament, Association, Referendum) performs an unchecked external call to validate organization existence without verifying the target contract is legitimate. An attacker can deploy a malicious contract that always returns true for `ValidateOrganizationExist`, enabling capture of method fee control through governance approval.

## Finding Description

The vulnerability exists in the `ChangeMethodFeeController` function which updates the method fee controller authority. [1](#0-0) 

The root cause is in the `CheckOrganizationExist` helper method that makes an unchecked external call to the `ContractAddress` specified in the input without validating it's a legitimate governance contract: [2](#0-1) 

**Attack Execution Path:**

1. Attacker deploys a malicious contract with fake `ValidateOrganizationExist` returning true
2. Governance proposal created to call `ChangeMethodFeeController` with malicious `ContractAddress` 
3. Miners approve the proposal (difficult to detect without inspecting bytecode)
4. Upon proposal release, authorization check passes because sender is the current controller's virtual address [3](#0-2) 
5. The malicious contract returns true, bypassing validation
6. Controller is updated to attacker-controlled setup [4](#0-3) 

For comparison, legitimate governance contract implementations verify organizations exist in their state: [5](#0-4)  and [6](#0-5) 

The same vulnerability pattern exists across multiple contracts including Association [7](#0-6) , Referendum [8](#0-7) , and MultiToken [9](#0-8)  contracts.

## Impact Explanation

**Governance Bypass Scenario:** If attacker sets `OwnerAddress` to their personal address, they gain direct control over `SetMethodFee` without governance approval. [10](#0-9) 

The attacker can arbitrarily manipulate transaction fees for all contract methods:
- Set fees to zero for economic exploitation
- Set excessive fees to DOS legitimate users  
- Extract value through fee manipulation

**Permanent Lock Scenario:** If attacker sets `OwnerAddress` to a non-existent organization address, the method fee configuration becomes permanently frozen since no proposals can be created or approved to regain control.

**Severity: CRITICAL** because:
- Completely breaks governance model for fee control
- Affects multiple critical system contracts
- Once captured, extremely difficult or impossible to recover
- Can lead to unauthorized fee manipulation or permanent operational lock

## Likelihood Explanation

**Attacker Requirements:**
- Deploy a simple malicious contract (single method returning true)
- Create governance proposal with malicious contract address

**Attack Complexity: LOW** - The malicious contract is trivial to implement and uses standard governance processes.

**Detection Difficulty:** Proposals only display addresses without contract implementation. Miners cannot easily verify `ContractAddress` legitimacy without:
- Inspecting contract bytecode
- Verifying it matches known governance contracts
- Checking organization existence in target contract

The Parliament contract has no whitelist or validation mechanism for permitted controller contracts, despite AElf having `ValidateSystemContractAddress` functionality that is not utilized here.

**Likelihood: MEDIUM-HIGH** - While requiring governance approval adds friction, the lack of on-chain validation and routine nature of administrative proposals make successful social engineering plausible.

## Recommendation

Implement contract address validation in `CheckOrganizationExist`:

1. **Whitelist Approach:** Maintain a state variable of approved governance contract addresses (Parliament, Association, Referendum) and validate `authorityInfo.ContractAddress` against this whitelist before making the external call.

2. **System Contract Validation:** Use the existing `ValidateSystemContractAddress` functionality to ensure the contract is a registered system contract.

3. **Additional Check:** Verify the contract implements the expected ACS3 interface through introspection or known contract addresses.

Example fix:
```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a known governance contract
    var validContracts = new[] { 
        Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName)
    };
    
    Assert(validContracts.Contains(authorityInfo.ContractAddress), 
        "Invalid governance contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousContractCanCaptureMethodFeeControl()
{
    // 1. Deploy malicious contract that always returns true
    var maliciousContractAddress = await DeployMaliciousValidatorContract();
    
    // 2. Create proposal to change controller to malicious setup
    var attackerAddress = SampleAccount.Accounts[1].Address;
    var proposal = await ParliamentContractStub.CreateProposal.SendAsync(new CreateProposalInput
    {
        ToAddress = ParliamentContractAddress,
        ContractMethodName = nameof(ParliamentContractStub.ChangeMethodFeeController),
        Params = new AuthorityInfo
        {
            ContractAddress = maliciousContractAddress,
            OwnerAddress = attackerAddress
        }.ToByteString(),
        OrganizationAddress = defaultOrganization,
        ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
    });
    
    // 3. Approve proposal by miners
    await ApprovalProposalByMiners(proposal.Output);
    
    // 4. Release proposal - should pass with malicious validation
    await ParliamentContractStub.Release.SendAsync(proposal.Output);
    
    // 5. Verify attacker now controls method fees
    var controller = await ParliamentContractStub.GetMethodFeeController.CallAsync(new Empty());
    controller.OwnerAddress.ShouldBe(attackerAddress);
    controller.ContractAddress.ShouldBe(maliciousContractAddress);
    
    // 6. Attacker can now set fees without governance
    var result = await ParliamentContractStub.SetMethodFee.SendWithExceptionAsync(new MethodFees
    {
        MethodName = nameof(ParliamentContractStub.CreateProposal),
        Fees = { new MethodFee { Symbol = "ELF", BasicFee = 0 } }
    });
    
    // Should succeed because attacker is now the controller owner
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

### Citations

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L56-60)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L70-74)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Referendum/ReferendumContract_ACS1_TransactionFeeProvider.cs (L70-74)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```
