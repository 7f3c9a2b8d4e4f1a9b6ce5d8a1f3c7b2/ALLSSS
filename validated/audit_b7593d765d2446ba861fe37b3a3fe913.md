# Audit Report

## Title
Missing Cross-Round Order Validation Allows Mining Order Manipulation During Round Transitions

## Summary
The AEDPoS consensus contract fails to validate that mining orders in a proposed next round match the `FinalOrderOfNextRound` values determined in the current round. The `NextRoundMiningOrderValidationProvider` validates fields that are never populated during legitimate round generation, allowing any miner acting as extra block producer to manipulate mining orders and gain unfair block production advantages.

## Finding Description

The vulnerability stems from incorrect validation logic in the round transition process. During normal consensus operation, miners determine their `FinalOrderOfNextRound` values during the current round through cryptographic signatures and conflict resolution. When the extra block producer triggers the next round, these `FinalOrderOfNextRound` values should dictate the `Order` assignments in the new round. However, the validation fails to enforce this relationship.

**Flawed Validation Logic:**

The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` method attempts to validate mining orders but checks the wrong data structure. [1](#0-0) 

The validator checks `FinalOrderOfNextRound` and `OutValue` fields within the `providedRound` (the next round being proposed). However, when a legitimate next round is generated via `GenerateNextRoundInformation()`, these fields are explicitly NOT populated. [2](#0-1) 

The `Order` field in the next round is supposed to be derived from the current round's `FinalOrderOfNextRound` values, [3](#0-2)  but no validation verifies this relationship.

**Missing Cross-Validation:**

When `ProcessNextRound()` executes, it directly stores the provided next round without regenerating it or validating the Order assignments. [4](#0-3) 

The validation setup in `ValidateBeforeExecution()` adds the flawed `NextRoundMiningOrderValidationProvider` for NextRound behavior, [5](#0-4)  but this validator passes trivially since it checks unpopulated fields (0 == 0).

**Ineffective Post-Execution Check:**

The `ValidateConsensusAfterExecution()` method compares the header round hash with the current round hash. [6](#0-5) 

However, since `ProcessNextRound()` already stored the provided round as the new current round, this comparison validates the manipulated round against itself, always passing.

The round hash calculation includes the `Order` field through `GetCheckableRound()`, [7](#0-6)  which means manipulating Order values would be detectable IF the validation compared against a regenerated round, but it doesn't.

## Impact Explanation

This vulnerability breaks the fundamental fairness guarantee of the AEDPoS consensus mechanism. A malicious miner can:

1. **Monopolize Priority Positions**: Repeatedly assign themselves Order 1 to mine first in each round, collecting maximum transaction fees
2. **Disadvantage Competitors**: Assign unfavorable orders to competing miners, reducing their mining opportunities
3. **Centralize Block Production**: Over time, systematically gain disproportionate rewards, undermining the decentralization guarantee
4. **Violate Deterministic Ordering**: Break the cryptographic signature-based order determination that should be unpredictable and fair

While this doesn't directly steal funds from user accounts, it violates a critical protocol invariant: **miner schedule integrity**. The consensus mechanism's security depends on fair, deterministic, and verifiable miner ordering. Breaking this enables economic attacks that can lead to consensus centralization and network trust degradation.

## Likelihood Explanation

This vulnerability is **highly likely** to be exploited:

**Attacker Requirements:**
- Must be a legitimate network miner (normal participation requirement)
- Must wait to be selected as extra block producer (~1/N chance per round, where N = miner count)
- Must modify client software to manipulate Order values before submission

**Attack Execution:**
1. Monitor consensus rounds until selected as extra block producer
2. Generate legitimate next round using standard `GetConsensusExtraDataForNextRound()` logic [8](#0-7) 
3. Modify `Order` values in the `RealTimeMinersInformation` dictionary before creating `NextRoundInput` [9](#0-8) 
4. Submit via `NextRound()` public method [10](#0-9) 

**No Detection:**
- Validation passes because it checks wrong fields
- Manipulated round becomes legitimate state
- Other miners cannot distinguish legitimate from manipulated rounds
- No audit trail or recovery mechanism

**Economic Rationality:**
Every miner has strong economic incentive to exploit this for competitive advantage. The cost is minimal (normal mining operations), while benefits accumulate over time through preferential block production positioning.

## Recommendation

Implement proper cross-round order validation in `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var currentRound = validationContext.BaseRound;
    var providedNextRound = validationContext.ProvidedRound;
    
    // Validate that Order values in next round match FinalOrderOfNextRound from current round
    foreach (var minerInNextRound in providedNextRound.RealTimeMinersInformation)
    {
        var pubkey = minerInNextRound.Key;
        
        // Check if miner existed in current round and had determined their next round order
        if (currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
        {
            var expectedOrder = currentRound.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound;
            var actualOrder = minerInNextRound.Value.Order;
            
            // Only validate if FinalOrderOfNextRound was set (miner mined in current round)
            if (expectedOrder > 0 && expectedOrder != actualOrder)
            {
                validationResult.Message = $"Miner {pubkey} order mismatch: expected {expectedOrder}, actual {actualOrder}";
                return validationResult;
            }
        }
    }
    
    // Verify all miners who mined in current round are present in next round
    var minersWhoMined = currentRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0)
        .Select(m => m.Pubkey)
        .ToList();
        
    foreach (var pubkey in minersWhoMined)
    {
        if (!providedNextRound.RealTimeMinersInformation.ContainsKey(pubkey))
        {
            validationResult.Message = $"Miner {pubkey} who mined in current round is missing from next round";
            return validationResult;
        }
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

Additionally, consider regenerating the expected next round in `ValidateConsensusAfterExecution()` and comparing it against the provided round to catch any discrepancies.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Set up a multi-miner consensus scenario
2. Have miners complete a round with `FinalOrderOfNextRound` values determined
3. Simulate extra block producer calling `NextRound()` with manipulated Order values
4. Verify the manipulated round is accepted and stored
5. Confirm next round uses the manipulated orders instead of cryptographically determined ones

The test would validate that `NextRound(manipulatedInput)` succeeds where it should fail, proving the validation gap allows arbitrary order manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-21)
```csharp
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L87-114)
```csharp
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
