# Audit Report

## Title
Missing Term Period Validation Allows Premature Term Transitions

## Summary
The AEDPoS consensus contract lacks validation to verify that the configured term period (`periodSeconds`) has elapsed before allowing term transitions. The timing check (`NeedToChangeTerm`) only occurs during local consensus command generation but is never re-validated during block validation or execution, enabling a malicious miner to force premature term changes with significant economic consequences.

## Finding Description

The vulnerability exists across the complete validation and execution flow of NextTerm consensus behavior.

**Root Cause - Timing Check Only in Command Generation:**

The `NeedToChangeTerm()` method determines whether a term transition should occur based on elapsed time. It checks if at least 2/3 of miners have timestamps indicating the `periodSeconds` duration has passed using the formula `(blockProducedTimestamp - blockchainStartTimestamp).Seconds / periodSeconds != termNumber - 1`: [1](#0-0) 

However, this timing validation **only occurs in the local command generation logic** to decide whether to return `NextRound` or `NextTerm` behavior: [2](#0-1) 

Critically, a grep search confirms that `NeedToChangeTerm()` and `IsTimeToChangeTerm()` are **only called in these two locations** - they are never invoked during block validation or execution.

**Missing Validation During Block Validation:**

When `ValidateBeforeExecution` processes a NextTerm behavior, it only adds `RoundTerminateValidationProvider` to the validation provider list: [3](#0-2) 

The `RoundTerminateValidationProvider.ValidationForNextTerm()` **only validates numeric increments** of round and term numbers - it performs **NO timing verification**: [4](#0-3) 

Similarly, `TimeSlotValidationProvider` only validates internal consistency of mining intervals within a round, not whether the term period has elapsed: [5](#0-4) 

**Missing Validation During Execution:**

During `ProcessNextTerm` execution, the only term validation is `TryToUpdateTermNumber`, which again only checks numeric increment with no timing validation: [6](#0-5) [7](#0-6) 

**Attack Vector:**

A malicious miner can:
1. Modify their node software to bypass the `NeedToChangeTerm()` check in `GetConsensusBehaviourToTerminateCurrentRound()`
2. Generate consensus extra data with NextTerm behavior by calling `GetConsensusExtraDataForNextTerm()`, which creates a valid Round structure with incremented term/round numbers: [8](#0-7) [9](#0-8) 

3. The block will pass all validation checks since no validator checks whether `periodSeconds` time has actually elapsed
4. Term transition executes successfully with all economic side effects

## Impact Explanation

**Consensus Integrity Compromise:**

Attackers can arbitrarily accelerate term transitions, breaking the fundamental timing invariant of the consensus mechanism (default 7-day term schedule with `periodSeconds = 604800`).

**Economic Impact - Premature Operations:**

Term transitions trigger critical economic operations that become exploitable when executed prematurely:

1. **Early Mining Reward Donations:** Mining rewards calculated and donated to Treasury ahead of schedule: [10](#0-9) 

2. **Early Treasury Releases:** Treasury funds distributed before the scheduled time, using the premature term number as period number: [11](#0-10) 

3. **Election Snapshot Timing Manipulation:** Snapshots taken at incorrect times, affecting staking reward calculations: [12](#0-11) 

**Affected Parties:**

All network participants suffer from disrupted economic schedules, incorrect reward distribution timing, and potential manipulation of election outcomes through snapshot timing control. Treasury beneficiaries receive funds prematurely, potentially enabling front-running strategies coordinated with governance proposals.

## Likelihood Explanation

**Attacker Capabilities:**

Requires being in the current miner list, which is realistic as miners are elected through staking mechanisms. A compromised or malicious miner node represents a valid threat model in Byzantine consensus systems. No additional privileges beyond standard miner status are needed.

**Attack Complexity:**

Moderate - the attacker must:
- Modify their node software to override the local `GetConsensusBehaviourToTerminateCurrentRound()` decision
- Understand the Round generation logic to create structurally valid NextTermInput
- Does NOT require breaking cryptography, manipulating block timestamps beyond normal tolerances, or complex state manipulation

**Execution Practicality:**

High - the attack path is straightforward:
1. Miner produces block during their normal time slot (e.g., day 3 of 7-day term)
2. Modified node forces NextTerm behavior in consensus extra data generation
3. Block passes all validation checks (only numeric increments validated)
4. Term changes 4 days early with all economic effects triggered immediately

**Detection Difficulty:**

The block appears structurally valid to all validators. Detection requires off-chain monitoring of term transition frequency against the expected schedule based on blockchain start timestamp and configured period seconds.

**Economic Rationality:**

Attack cost is zero (already a miner with block production rights). Potential benefits include:
- Manipulating treasury release timing for front-running opportunities
- Coordinating with governance proposals timed to specific terms
- Disrupting competitor staking reward calculations through snapshot manipulation

## Recommendation

Add timing validation during block validation and/or execution to verify that the configured term period has actually elapsed. The validation should re-check the same condition used in `NeedToChangeTerm()`:

```csharp
// In RoundTerminateValidationProvider.ValidationForNextTerm()
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Validate term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };

    // ADD: Validate that term period has actually elapsed
    var blockchainStartTimestamp = GetBlockchainStartTimestamp(); // Access from context
    var periodSeconds = GetPeriodSeconds(); // Access from state
    if (!extraData.Round.NeedToChangeTerm(blockchainStartTimestamp, 
        validationContext.BaseRound.TermNumber, periodSeconds))
    {
        return new ValidationResult { Message = "Term period has not elapsed yet." };
    }

    return new ValidationResult { Success = true };
}
```

Alternatively, add the check in `TryToUpdateTermNumber()` during execution to provide defense in depth.

## Proof of Concept

A test demonstrating the vulnerability would:

1. Initialize the consensus contract with a known blockchain start timestamp and `periodSeconds` (e.g., 604800 seconds for 7 days)
2. Advance blockchain to day 3 (259200 seconds elapsed, less than `periodSeconds`)
3. Have a miner in the current miner list call `NextTerm()` with a valid `NextTermInput` structure (incremented term/round numbers)
4. Verify the transaction succeeds despite insufficient time elapsed
5. Confirm premature treasury release, mining reward donation, and election snapshot execution

The test would prove that no validation checks whether `(currentBlockTime - blockchainStartTimestamp).Seconds / periodSeconds` allows the term transition, violating the consensus timing invariant.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-243)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }

    /// <summary>
    ///     If periodSeconds == 7:
    ///     1, 1, 1 => 0 != 1 - 1 => false
    ///     1, 2, 1 => 0 != 1 - 1 => false
    ///     1, 8, 1 => 1 != 1 - 1 => true => term number will be 2
    ///     1, 9, 2 => 1 != 2 - 1 => false
    ///     1, 15, 2 => 2 != 2 - 1 => true => term number will be 3.
    /// </summary>
    /// <param name="blockchainStartTimestamp"></param>
    /// <param name="termNumber"></param>
    /// <param name="blockProducedTimestamp"></param>
    /// <param name="periodSeconds"></param>
    /// <returns></returns>
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L8-35)
```csharp
public class TimeSlotValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-174)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L98-105)
```csharp
    private bool TryToUpdateTermNumber(long termNumber)
    {
        var oldTermNumber = State.CurrentTermNumber.Value;
        if (termNumber != 1 && oldTermNumber + 1 != termNumber) return false;

        State.CurrentTermNumber.Value = termNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```
