# Audit Report

## Title
Off-By-One Error in GetAllChainsIdAndHeight() Invalidates Genesis Block Height and Causes Cross-Chain DoS

## Summary
The `GetAllChainsIdAndHeight()` method contains an off-by-one error using strict greater-than (`>`) instead of greater-than-or-equal (`>=`) when validating parent chain height against the genesis block height constant. This causes the method to incorrectly reject height 1 (the valid genesis height), creating a denial-of-service condition for side chains created at parent chain heights 1 or 2.

## Finding Description

The vulnerability exists in the `GetAllChainsIdAndHeight()` contract method which validates the parent chain height using a strict comparison: [1](#0-0) 

The method asserts that `parentChainHeight` must be strictly greater than `AElfConstants.GenesisBlockHeight`, which is defined as 1: [2](#0-1) 

During side chain initialization, the cross-chain contract sets `CurrentParentChainHeight` to `CreationHeightOnParentChain - 1`: [3](#0-2) 

When a side chain is created, the `CreationHeightOnParentChain` is set directly to `Context.CurrentHeight` without any minimum height validation: [4](#0-3) 

This creates two problematic scenarios:

**Scenario 1: Side chain created at parent height 2**
- `CurrentParentChainHeight = 2 - 1 = 1`
- Assertion checks `1 > 1`, which evaluates to FALSE
- Method reverts with "Invalid parent chain height"

**Scenario 2: Side chain created at parent height 1 (genesis)**  
- `CurrentParentChainHeight = 1 - 1 = 0` initially
- Even after indexing the genesis block, `CurrentParentChainHeight = 1`
- Assertion checks `1 > 1`, which evaluates to FALSE
- Method permanently fails

The issue breaks the protocol invariant that genesis block height (1) should be a valid, queryable height.

## Impact Explanation

This method is critical for cross-chain operations as it's called by off-chain services to retrieve chain heights: [5](#0-4) 

The retrieved data is used in two critical flows:

1. **Initial synchronization** - Registers new chains in the cross-chain cache: [6](#0-5) 

2. **Continuous updates** - Updates the cross-chain cache with latest indexed heights: [7](#0-6) 

When `GetAllChainsIdAndHeight()` fails for side chains created at early parent chain heights, the entire cross-chain infrastructure becomes non-functional:
- Cross-chain cache cannot be initialized
- Parent chain data cannot be indexed
- Cross-chain verification and merkle proof operations become unavailable

The severity is **Low-to-Medium** depending on deployment context:
- **LOW** in production environments where governance approval processes naturally span multiple blocks, making early-height creation unlikely
- **MEDIUM** in test/development environments where genesis and early-stage scenarios are common

## Likelihood Explanation

**Feasibility:** The bug triggers naturally without malicious intent when a side chain is created at parent chain heights 1 or 2. The `CreateSideChain` method has no minimum height validation, making this technically possible.

**Probability:**
- **LOW in production**: Side chain creation requires governance proposal, approval, and release processes that typically span many blocks, naturally preventing creation at heights 1-2
- **HIGH in test/development**: Genesis scenarios and early-stage testing routinely create side chains at early heights
- **Technically unrestricted**: No protocol-level barrier prevents early side chain creation

The existing test suite explicitly avoids this condition by using `parentChainHeightOfCreation = 10`: [8](#0-7) 

## Recommendation

Change the validation from strict greater-than to greater-than-or-equal to properly accept the genesis block height:

```csharp
Assert(parentChainHeight >= AElfConstants.GenesisBlockHeight, "Invalid parent chain height");
```

This correctly validates that the height is at least the genesis height (1), while still rejecting invalid states where `CurrentParentChainHeight` is 0 (uninitialized).

## Proof of Concept

```csharp
[Fact]
public async Task GetAllChainsIdAndHeight_FailsAtHeight2()
{
    var parentChainId = 123;
    long parentChainHeightOfCreation = 2; // Create at height 2
    var sideChainId = await InitAndCreateSideChainAsync(
        parentChainHeightOfCreation, 
        parentChainId, 
        lockedTokenAmount: 10L
    );

    // This call will fail with "Invalid parent chain height" 
    // because CurrentParentChainHeight = 2-1 = 1, and 1 > 1 is false
    var exception = await Assert.ThrowsAsync<Exception>(async () => 
        await CrossChainContractStub.GetAllChainsIdAndHeight.CallAsync(new Empty())
    );
    
    exception.Message.ShouldContain("Invalid parent chain height");
}
```

**Notes:**
- The vulnerability affects the on-chain smart contract code in production scope
- While the immediate impact manifests through off-chain services, the root cause is the incorrect contract logic
- The fix is trivial (changing `>` to `>=`) and should be applied to maintain protocol correctness
- Production deployments are unlikely to be affected due to governance delays, but the bug represents a protocol invariant violation that should be corrected

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L118-128)
```csharp
    public override ChainIdAndHeightDict GetAllChainsIdAndHeight(Empty input)
    {
        var dict = GetSideChainIdAndHeight(new Empty());

        if (State.ParentChainId.Value == 0)
            return dict;
        var parentChainHeight = GetParentChainHeight(new Empty()).Value;
        Assert(parentChainHeight > AElfConstants.GenesisBlockHeight, "Invalid parent chain height");
        dict.IdHeightDict.Add(State.ParentChainId.Value, parentChainHeight);
        return dict;
    }
```

**File:** src/AElf.Types/AElfConstants.cs (L6-6)
```csharp
        public const long GenesisBlockHeight = 1;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L14-31)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");
        State.ParentChainId.Value = input.ParentChainId;
        State.CurrentParentChainHeight.Value = input.CreationHeightOnParentChain - 1;
        State.IndexingPendingProposal.Value = new ProposedCrossChainIndexing();

        CreateInitialOrganizationForInitialControllerAddress();
        State.Initialized.Value = true;

        if (Context.CurrentHeight != AElfConstants.GenesisBlockHeight)
            return new Empty();

        State.GenesisContract.Value = Context.GetZeroSmartContractAddress();
        State.GenesisContract.SetContractProposerRequiredState.Send(
            new BoolValue { Value = input.IsPrivilegePreserved });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L121-167)
```csharp
    public override Int32Value CreateSideChain(CreateSideChainInput input)
    {
        // side chain creation should be triggered by organization address.
        AssertSideChainLifetimeControllerAuthority(Context.Sender);

        var proposedSideChainCreationRequestState = State.ProposedSideChainCreationRequestState[input.Proposer];
        State.ProposedSideChainCreationRequestState.Remove(input.Proposer);
        var sideChainCreationRequest = input.SideChainCreationRequest;
        Assert(
            proposedSideChainCreationRequestState != null &&
            proposedSideChainCreationRequestState.SideChainCreationRequest.Equals(sideChainCreationRequest),
            "Side chain creation failed without proposed data.");
        AssertValidSideChainCreationRequest(sideChainCreationRequest, input.Proposer);

        State.SideChainSerialNumber.Value = State.SideChainSerialNumber.Value.Add(1);
        var serialNumber = State.SideChainSerialNumber.Value;
        var chainId = GetChainId(serialNumber);
        State.AcceptedSideChainCreationRequest[chainId] = sideChainCreationRequest;

        // lock token
        ChargeSideChainIndexingFee(input.Proposer, sideChainCreationRequest.LockedTokenAmount, chainId);

        var sideChainInfo = new SideChainInfo
        {
            Proposer = input.Proposer,
            SideChainId = chainId,
            SideChainStatus = SideChainStatus.Active,
            IndexingPrice = sideChainCreationRequest.IndexingPrice,
            IsPrivilegePreserved = sideChainCreationRequest.IsPrivilegePreserved,
            CreationTimestamp = Context.CurrentBlockTime,
            CreationHeightOnParentChain = Context.CurrentHeight,
            IndexingFeeController = CreateDefaultOrganizationForIndexingFeePriceManagement(input.Proposer)
        };
        State.SideChainInfo[chainId] = sideChainInfo;
        State.CurrentSideChainHeight[chainId] = 0;

        var chainInitializationData =
            GetChainInitializationData(sideChainInfo, sideChainCreationRequest);
        State.SideChainInitializationData[sideChainInfo.SideChainId] = chainInitializationData;

        Context.Fire(new SideChainCreatedEvent
        {
            ChainId = chainId,
            Creator = input.Proposer
        });
        return new Int32Value { Value = chainId };
    }
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataService.cs (L157-176)
```csharp
    public async Task<ChainIdAndHeightDict> GetAllChainIdHeightPairsAtLibAsync()
    {
        var isReadyToCreateChainCache =
            await _irreversibleBlockStateProvider.ValidateIrreversibleBlockExistingAsync();
        if (!isReadyToCreateChainCache)
            return new ChainIdAndHeightDict();
        var lib = await _irreversibleBlockStateProvider.GetLastIrreversibleBlockHashAndHeightAsync();
        return await _contractReaderFactory
            .Create(new ContractReaderContext
            {
                BlockHash = lib.BlockHash,
                BlockHeight = lib.BlockHeight,
                ContractAddress = await GetCrossChainContractAddressAsync(new ChainContext
                {
                    BlockHash = lib.BlockHash,
                    BlockHeight = lib.BlockHeight
                })
            }).GetAllChainsIdAndHeight
            .CallAsync(new Empty());
    }
```

**File:** src/AElf.CrossChain/Application/CrossChainService.cs (L26-34)
```csharp
    public async Task FinishInitialSyncAsync()
    {
        CrossChainConfigOptions.Value.CrossChainDataValidationIgnored = false;
        var chainIdHeightPairs =
            await _crossChainIndexingDataService.GetAllChainIdHeightPairsAtLibAsync();
        foreach (var chainIdHeight in chainIdHeightPairs.IdHeightDict)
            // register new chain
            _crossChainCacheEntityService.RegisterNewChain(chainIdHeight.Key, chainIdHeight.Value);
    }
```

**File:** src/AElf.CrossChain/Application/CrossChainService.cs (L36-48)
```csharp
    public async Task UpdateCrossChainDataWithLibAsync(Hash blockHash, long blockHeight)
    {
        if (CrossChainConfigOptions.Value.CrossChainDataValidationIgnored
            || blockHeight <= AElfConstants.GenesisBlockHeight)
            return;

        _crossChainIndexingDataService.UpdateCrossChainDataWithLib(blockHash, blockHeight);

        var chainIdHeightPairs =
            await _crossChainIndexingDataService.GetAllChainIdHeightPairsAtLibAsync();

        await _crossChainCacheEntityService.UpdateCrossChainCacheAsync(blockHash, blockHeight, chainIdHeightPairs);
    }
```

**File:** test/AElf.Contracts.CrossChain.Tests/SideChainLifeTimeManagementTest.cs (L770-783)
```csharp
    public async Task GetAllChainsIdAndHeight_Test()
    {
        var parentChainId = 123;
        var lockedTokenAmount = 10L;
        long parentChainHeightOfCreation = 10;
        var sideChainId =
            await InitAndCreateSideChainAsync(parentChainHeightOfCreation, parentChainId, lockedTokenAmount);

        var sideChainIdAndHeight = await CrossChainContractStub.GetAllChainsIdAndHeight.CallAsync(new Empty());
        sideChainIdAndHeight.IdHeightDict.Count.ShouldBe(2);
        var chainIds = sideChainIdAndHeight.IdHeightDict.Keys;
        chainIds.ShouldContain(parentChainId);
        chainIds.ShouldContain(sideChainId);
    }
```
