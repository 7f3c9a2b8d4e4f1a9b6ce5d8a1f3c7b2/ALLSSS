# Audit Report

## Title
Side Chain ID Spoofing in Cross-Chain Transaction Verification

## Summary
The `VerifyTransaction()` function in the CrossChain contract fails to validate that the provided `VerifiedChainId` parameter matches the actual source chain of a transaction. When multiple side chains are indexed together at the same parent chain height, the function returns an identical combined merkle root for all side chains, allowing attackers to verify transactions from Chain A while falsely claiming they originated from Chain B.

## Finding Description

The vulnerability exists in the cross-chain transaction verification flow where the `VerifiedChainId` parameter is not properly validated against the actual transaction source chain.

**Entry Point:** The `VerifyTransaction()` method accepts a `VerifiedChainId` parameter but only uses it to determine the verification path type (parent/side/cousin chain), not to filter which specific chain's data is verified. [1](#0-0) 

**Root Cause:** The `GetMerkleTreeRoot()` function checks if the provided chainId is a registered side chain via `State.SideChainInfo[chainId] != null`, but when this check passes, it calls `GetSideChainMerkleTreeRoot()` without passing the chain ID parameter. [2](#0-1) 

**Critical Flaw:** The `GetSideChainMerkleTreeRoot()` function only accepts a `parentChainHeight` parameter and computes a combined merkle root from ALL side chains' `TransactionStatusMerkleTreeRoot` values indexed at that height, without any chain-specific filtering. [3](#0-2) 

**Storage Design:** Multiple side chains' data is aggregated into a single `IndexedSideChainBlockData` object when indexed via `ReleaseCrossChainIndexingProposal()`. All chains indexed in the same transaction are stored together at `Context.CurrentHeight`. [4](#0-3) 

**Attack Scenario:**
1. Two side chains (A and B) are indexed together at parent chain height H via `ReleaseCrossChainIndexingProposal({ChainIdList: [A, B]})`
2. Attacker executes transaction TX on Chain A and obtains its merkle path
3. Attacker calls `VerifyTransaction(TX, path, H, VerifiedChainId: B)` claiming TX is from Chain B
4. `GetMerkleTreeRoot(B, H)` checks `State.SideChainInfo[B] != null` (passes) and returns the combined merkle root
5. The merkle path from Chain A validates against this combined root
6. Verification succeeds with the wrong chain ID

## Impact Explanation

**Cross-Chain Security Invariant Broken:** The fundamental security guarantee that `VerifyTransaction()` validates a transaction came from a SPECIFIC chain is violated. Transactions from any side chain indexed together can be verified as originating from any other co-indexed side chain.

**Real-World Exploitation:** The `RegisterCrossChainTokenContractAddress()` method in the MultiToken contract relies on `VerifyTransaction()` to ensure token contract addresses are registered from trusted chains. An attacker can execute a transaction on an untrusted Chain B, verify it as coming from trusted Chain A, and register a malicious token contract address. [5](#0-4) [6](#0-5) 

**Severity Justification:**
- Breaks core cross-chain authentication mechanism
- Exploitable whenever multiple side chains are indexed together (common operational scenario)
- Requires no special permissions or economic cost
- Enables bypass of chain-specific security controls in dependent contracts

## Likelihood Explanation

**Highly Likely to be Exploitable:**

**Public Access:** `VerifyTransaction()` is defined as a public view method with no access restrictions in the ACS7 interface. [7](#0-6) 

**Attacker Capabilities:**
- Execute standard transactions on any registered side chain (no special privilege required)
- Obtain merkle paths via public side chain APIs
- Call `VerifyTransaction()` with arbitrary chain ID claims

**Low Attack Complexity:**
1. Execute transaction on Side Chain A
2. Retrieve merkle path from Chain A's block data
3. Identify parent chain height where Chain A and target Chain B were co-indexed
4. Call `VerifyTransaction` with `VerifiedChainId = B`
5. Verification succeeds due to shared combined merkle root

**Realistic Preconditions:**
- Multiple side chains indexed at the same height (standard practice when miners call `ReleaseCrossChainIndexingProposal` with multiple chain IDs for efficiency) [8](#0-7) 

## Recommendation

Modify the side chain merkle root computation to be chain-specific. The recommended fix:

1. **Change `GetSideChainMerkleTreeRoot` signature** to accept a chain ID parameter:
```csharp
private Hash GetSideChainMerkleTreeRoot(int chainId, long parentChainHeight)
```

2. **Filter side chain data by chain ID** before computing the merkle root:
```csharp
private Hash GetSideChainMerkleTreeRoot(int chainId, long parentChainHeight)
{
    var indexedSideChainData = State.IndexedSideChainBlockData[parentChainHeight];
    var chainSpecificData = indexedSideChainData.SideChainBlockDataList
        .Where(d => d.ChainId == chainId)
        .Select(d => d.TransactionStatusMerkleTreeRoot);
    return ComputeRootWithMultiHash(chainSpecificData);
}
```

3. **Update `GetMerkleTreeRoot` call** to pass the chain ID:
```csharp
if (State.SideChainInfo[chainId] != null)
    return GetSideChainMerkleTreeRoot(chainId, parentChainHeight);
```

## Proof of Concept

```csharp
[Fact]
public async Task SideChainIdSpoofing_Vulnerability()
{
    // Setup: Create two side chains
    var chainA = await CreateSideChainAsync();
    var chainB = await CreateSideChainAsync();
    
    // Index both chains together at same height
    var txOnChainA = await ExecuteTransactionOnChain(chainA);
    var merklePathA = await GetMerklePathForTransaction(txOnChainA);
    var parentHeight = await GetCurrentParentHeight();
    
    await IndexMultipleChainsToget her(new[] { chainA, chainB }, parentHeight);
    
    // Attack: Verify Chain A transaction as if from Chain B
    var verifyInput = new VerifyTransactionInput
    {
        TransactionId = txOnChainA,
        Path = merklePathA,
        ParentChainHeight = parentHeight,
        VerifiedChainId = chainB  // WRONG CHAIN ID
    };
    
    var result = await CrossChainContractStub.VerifyTransaction.CallAsync(verifyInput);
    
    // Vulnerability: Verification succeeds despite wrong chain ID
    Assert.True(result.Value); // Should be False but returns True
}
```

## Notes

This vulnerability exists because the storage design aggregates all side chains' merkle tree roots into a combined structure without maintaining chain-specific separation during verification. The `VerifiedChainId` parameter becomes merely decorative - it's checked for validity but not used to filter the actual verification data. Any contract that relies on this parameter to enforce chain-specific security policies can be completely bypassed.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L37-46)
```csharp
    public override BoolValue VerifyTransaction(VerifyTransactionInput input)
    {
        var parentChainHeight = input.ParentChainHeight;
        var merkleTreeRoot = GetMerkleTreeRoot(input.VerifiedChainId, parentChainHeight);
        Assert(merkleTreeRoot != null,
            $"Parent chain block at height {parentChainHeight} is not recorded.");
        var rootCalculated = ComputeRootWithTransactionStatusMerklePath(input.TransactionId, input.Path);

        return new BoolValue { Value = merkleTreeRoot == rootCalculated };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L241-246)
```csharp
    private Hash GetSideChainMerkleTreeRoot(long parentChainHeight)
    {
        var indexedSideChainData = State.IndexedSideChainBlockData[parentChainHeight];
        return ComputeRootWithMultiHash(
            indexedSideChainData.SideChainBlockDataList.Select(d => d.TransactionStatusMerkleTreeRoot));
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L253-264)
```csharp
    private Hash GetMerkleTreeRoot(int chainId, long parentChainHeight)
    {
        if (chainId == State.ParentChainId.Value)
            // it is parent chain
            return GetParentChainMerkleTreeRoot(parentChainHeight);

        if (State.SideChainInfo[chainId] != null)
            // it is child chain
            return GetSideChainMerkleTreeRoot(parentChainHeight);

        return GetCousinChainMerkleTreeRoot(parentChainHeight);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L309-336)
```csharp
    private void RecordCrossChainData(IEnumerable<int> chainIdList)
    {
        var indexedSideChainBlockData = new IndexedSideChainBlockData();
        foreach (var chainId in chainIdList)
        {
            var pendingProposalExists = TryGetIndexingProposalWithStatus(chainId,
                CrossChainIndexingProposalStatus.Pending,
                out var pendingCrossChainIndexingProposal);
            Assert(pendingProposalExists, "Chain indexing not proposed.");

            if (chainId == State.ParentChainId.Value)
                IndexParentChainBlockData(pendingCrossChainIndexingProposal.ProposedCrossChainBlockData
                    .ParentChainBlockDataList);
            else
                indexedSideChainBlockData.SideChainBlockDataList.Add(IndexSideChainBlockData(
                    pendingCrossChainIndexingProposal.ProposedCrossChainBlockData.SideChainBlockDataList,
                    pendingCrossChainIndexingProposal.Proposer, chainId));

            SetCrossChainIndexingProposalStatus(pendingCrossChainIndexingProposal,
                CrossChainIndexingProposalStatus.Accepted);
        }

        if (indexedSideChainBlockData.SideChainBlockDataList.Count > 0)
        {
            State.IndexedSideChainBlockData.Set(Context.CurrentHeight, indexedSideChainBlockData);
            Context.Fire(new SideChainBlockDataIndexed());
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L536-552)
```csharp
    public override Empty RegisterCrossChainTokenContractAddress(RegisterCrossChainTokenContractAddressInput input)
    {
        CheckCrossChainTokenContractRegistrationControllerAuthority();

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);
        AssertCrossChainTransaction(originalTransaction, Context.GetZeroSmartContractAddress(input.FromChainId),
            nameof(ACS0Container.ACS0ReferenceState.ValidateSystemContractAddress));

        var validAddress = ExtractTokenContractAddress(originalTransaction.Params);

        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);

        State.CrossChainTransferWhiteList[input.FromChainId] = validAddress;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```
