# Audit Report

## Title
Arithmetic Overflow in Bancor Price Calculation Due to Unbounded Weight Ratios

## Summary
The TokenConverter contract's `GetAmountToPayFromReturn` function can overflow when computing exponential calculations for connector pairs with large weight ratios. Individual connector weights are validated to be between 0 and 1, but the ratio between paired connector weights is unbounded, allowing configurations like ResourceWeight=0.01 and NativeWeight=0.5 (ratio=50) that cause arithmetic overflow in the `Pow` function during large token purchases, rendering the connector pair unusable.

## Finding Description

The vulnerability exists in the Bancor price calculation implementation used by the TokenConverter contract. When users call the `Buy` method to purchase tokens, the contract calculates the amount to pay using `BancorHelper.GetAmountToPayFromReturn`. [1](#0-0) 

This function computes the weight ratio `y = wt / wf` without any bounds checking on the ratio itself: [2](#0-1) 

The result is then passed to `Exp(y * Ln(x))` where `Ln(x)` can approach ln(2) ≈ 0.693 when purchases approach 50% of reserves. [3](#0-2)  The `Exp` function implements a 20-term Taylor series expansion that requires computing powers up to `Pow(y, 20)` for the final term: [4](#0-3) 

The `Pow` function uses binary exponentiation with repeated `A *= A` operations: [5](#0-4) 

When the exponential argument exceeds approximately 30, computing `Pow(30+, 20)` results in values exceeding `decimal.MaxValue` (≈7.9×10²⁸), causing an overflow exception due to AElf's `CheckForOverflowUnderflow` requirement for smart contracts.

The root cause is that connector weight validation only ensures individual weights are between 0 and 1, without validating the ratio between paired connectors: [6](#0-5) 

The `AddPairConnector` function validates both connectors individually but never checks their ratio: [7](#0-6) 

## Impact Explanation

**High Operational Severity:**

This vulnerability causes complete denial-of-service for token conversion through affected connector pairs:

1. **Unusable Connectors**: Connector pairs with weight ratios exceeding ~40-50 become completely unusable for purchases exceeding ~40% of reserves
2. **Transaction Failures**: All `Buy` transactions for affected connectors fail with `OverflowException`
3. **Liquidity Fragmentation**: Users cannot swap tokens through broken pairs, fragmenting protocol liquidity
4. **False Security**: Governance receives no warnings during connector creation, as both individual weights pass validation
5. **User Experience**: Smaller purchases may succeed while larger ones mysteriously fail, creating confusing behavior

**No Direct Fund Loss**: While no funds are directly stolen, the operational disruption is severe and affects protocol reliability. This qualifies as "High-confidence DoS of token operations" per the validation framework.

**Affected Parties**:
- Regular users attempting legitimate token swaps
- Governance members who may unknowingly deploy broken configurations
- Protocol reputation and user trust

## Likelihood Explanation

**Medium Likelihood:**

**Preconditions**:
- ConnectorController (Parliament by default) must call `AddPairConnector` with unbalanced weights
- Example: ResourceWeight="0.01", NativeWeight="0.5" (both individually valid)

**Triggering Scenarios**:
1. **Governance Mistake**: Weight ratios like 50:1 or 100:1 might seem economically reasonable for certain token pairs without understanding the computational constraints
2. **No Warnings**: The contract provides no feedback that the configuration will fail at runtime
3. **Delayed Discovery**: The issue only manifests when users attempt purchases exceeding certain thresholds

**Execution Path**:
- Straightforward governance proposal to add connector pair
- No special contract semantics or race conditions required
- Observable through transaction failures

**Detection Difficulty**:
- Not visible until users attempt larger purchases
- Smaller trades succeed while larger ones fail
- No validation errors during connector creation

## Recommendation

Add validation to `AddPairConnector` to enforce maximum weight ratio constraints:

```csharp
public override Empty AddPairConnector(PairConnectorParam input)
{
    AssertPerformedByConnectorController();
    Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
        "resource token symbol should not be empty");
    
    var resourceWeight = AssertedDecimal(input.ResourceWeight);
    var nativeWeight = AssertedDecimal(input.NativeWeight);
    
    // Validate weight ratio to prevent computational overflow
    var ratio = Math.Max(resourceWeight, nativeWeight) / Math.Min(resourceWeight, nativeWeight);
    Assert(ratio <= 10m, "Weight ratio between connectors must not exceed 10:1 to prevent overflow");
    
    // ... rest of existing code
}
```

Alternatively, modify the `Exp` and `Pow` functions to handle larger values using different numerical methods or add bounds checking before computation.

## Proof of Concept

```csharp
[Fact]
public async Task AddPairConnector_LargeWeightRatio_CausesOverflow()
{
    // Setup: Add connector pair with large weight ratio
    var param = new PairConnectorParam
    {
        ResourceConnectorSymbol = "TEST",
        ResourceWeight = "0.01",  // 1% weight
        NativeWeight = "0.5",      // 50% weight - ratio is 50:1
        NativeVirtualBalance = 1_000_000
    };
    
    await ExecuteProposalForParliamentTransaction(
        TokenConverterContractAddress,
        nameof(TokenConverterContractStub.AddPairConnector),
        param);
    
    // Enable the connector
    await CreateTokenAsync("TEST");
    var enableInput = new ToBeConnectedTokenInfo
    {
        TokenSymbol = "TEST",
        AmountToTokenConvert = 1_000_000
    };
    await EnableConnectorAsync(enableInput);
    
    // Attempt to buy native tokens (this will overflow)
    var buyInput = new BuyInput
    {
        Symbol = "(NT)TEST",  // Native connector symbol
        Amount = 500_000,      // ~50% of reserves
        PayLimit = long.MaxValue
    };
    
    // This should fail with OverflowException
    var result = await TokenConverterContractStub.Buy.SendWithExceptionAsync(buyInput);
    result.TransactionResult.Error.ShouldContain("Overflow");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L92-92)
```csharp
        var y = wt / wf;
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L93-93)
```csharp
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L109-119)
```csharp
        var A = 1m;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;

        for (var i = t - 1; i >= 0; --i)
        {
            A *= A;
            if (e[i]) A *= x;
        }

        return A;
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L154-162)
```csharp
        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }
```
