# Audit Report

## Title
InitialNFTTypeNameMap Fails to Re-initialize After All NFT Types Are Removed, Causing Permanent DoS of NFT Creation

## Summary
The `InitialNFTTypeNameMap()` function contains a flawed null check that only verifies object existence without checking if the internal map is empty. After Parliament removes all default NFT types, the initialization logic returns early without repopulating the required mappings, permanently breaking `Create()` and `CrossChainCreate()` functions until manual recovery.

## Finding Description
The vulnerability stems from an insufficient guard condition in `InitialNFTTypeNameMap()` that only checks if the `State.NFTTypes.Value` object is null, without verifying whether its internal collection contains any entries. [1](#0-0) 

The `NFTTypes` protobuf message is defined as a map field, where the object itself can be non-null while the map is empty: [2](#0-1) 

**Exploitation Path:**

1. During initial usage, `InitialNFTTypeNameMap()` creates 10 default NFT type mappings and populates both the singleton state and bidirectional mapping states: [3](#0-2) 

2. Parliament legitimately calls `RemoveNFTType()` to remove all default types. Each removal deletes entries from the mapping states and the NFTTypes map: [4](#0-3) 

After removing all 10 types, `State.NFTTypes.Value` remains a non-null object with an empty internal map.

3. When a user attempts to create an NFT via `Create()`, the code calls `GetSymbol()`: [5](#0-4) 

4. In `GetSymbol()`, the lookup fails because the maps are empty, triggering a call to `InitialNFTTypeNameMap()`: [6](#0-5) 

5. The guard at line 41 detects that `State.NFTTypes.Value != null` and returns early, skipping reinitialization. Back in `GetSymbol()`, the `shortName` remains null, causing an `AssertionException`.

6. The same vulnerability affects `CrossChainCreate()`, which calls `InitialNFTTypeNameMap()` and then attempts to lookup the full name from the empty map: [7](#0-6) 

## Impact Explanation
**Severity: HIGH** - Complete operational DoS of core NFT contract functionality.

**Operational Impact:**
- All calls to `Create()` fail with "Short name of NFT Type {nftType} not found"
- All calls to `CrossChainCreate()` fail with "Full name of {nftTypeShortName} not found"
- No new NFT protocols can be created across the entire system
- Cross-chain NFT protocol synchronization becomes impossible

**Affected Parties:**
- All users attempting to create new NFT protocols
- Developers and applications relying on NFT functionality
- Cross-chain NFT operations are completely blocked

**Recovery:**
Recovery requires manual Parliament intervention through multiple `AddNFTType()` transactions: [8](#0-7) 

During the recovery period, the contract remains in a DoS state.

## Likelihood Explanation
**Likelihood: MEDIUM** - Requires Parliament action but realistic through legitimate governance operations.

**Feasible Preconditions:**
- Requires Parliament default address authorization (legitimate trusted role)
- Parliament could legitimately remove types for valid reasons:
  - Deprecation of certain NFT categories
  - Reorganization of type taxonomy
  - Policy changes or contract upgrades
- No malicious intent required - can occur through governance mistakes

**Execution Practicality:**
- Simple execution: Parliament calls `RemoveNFTType()` 10 times (one per default type)
- Each call is authorized for Parliament: [9](#0-8) 

- Once triggered, affects all users attempting NFT creation

## Recommendation
Modify `InitialNFTTypeNameMap()` to check if the map is empty, not just if the object is null:

```csharp
private NFTTypes InitialNFTTypeNameMap()
{
    // Check both null and empty map
    if (State.NFTTypes.Value != null && State.NFTTypes.Value.Value.Count > 0) 
        return State.NFTTypes.Value;

    var nftTypes = new NFTTypes();
    // ... rest of initialization logic
}
```

## Proof of Concept
```csharp
[Fact]
public async Task NFTCreation_DoS_After_Parliament_Removes_All_Types()
{
    // Setup: Initialize NFT contract and Parliament
    await InitializeNFTContract();
    
    // Step 1: Parliament removes all 10 default NFT types
    var defaultTypes = new[] { "XX", "AR", "MU", "DN", "VW", "TC", "CO", "SP", "UT", "BA" };
    foreach (var shortName in defaultTypes)
    {
        await ParliamentStub.RemoveNFTType.SendAsync(new StringValue { Value = shortName });
    }
    
    // Step 2: User attempts to create NFT - should fail with DoS
    var createInput = new CreateInput
    {
        NftType = "Art",
        ProtocolName = "TestNFT",
        TotalSupply = 1000,
        BaseUri = "https://test.com/",
        IsBurnable = true
    };
    
    // Assert: Create() throws AssertionException due to empty map
    var exception = await Assert.ThrowsAsync<AssertionException>(
        async () => await NFTStub.Create.SendAsync(createInput)
    );
    Assert.Contains("Short name of NFT Type Art not found", exception.Message);
    
    // Step 3: CrossChainCreate also fails
    var crossChainInput = new CrossChainCreateInput
    {
        Symbol = "AR12345" // Symbol with valid format
    };
    
    exception = await Assert.ThrowsAsync<AssertionException>(
        async () => await NFTStub.CrossChainCreate.SendAsync(crossChainInput)
    );
    Assert.Contains("Full name of AR not found", exception.Message);
}
```

**Notes**

This vulnerability represents a critical design flaw in state initialization logic. The protobuf `map<string, string>` field creates an object that persists even when all entries are removed, causing the guard condition to incorrectly assume the mappings are populated. The issue is particularly severe because:

1. It affects core NFT creation functionality globally
2. Recovery requires multiple governance transactions
3. The DoS persists throughout the entire recovery period
4. No warnings or safeguards exist to prevent this scenario

The vulnerability could be triggered through legitimate governance actions without malicious intent, making it a realistic threat despite requiring Parliament authority.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L28-34)
```csharp
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-41)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L43-60)
```csharp
        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }
```

**File:** protobuf/nft_contract.proto (L104-106)
```text
message NFTTypes {
    map<string, string> value = 1;
}
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L78-93)
```csharp
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L131-149)
```csharp
    public override Empty AddNFTType(AddNFTTypeInput input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        var fullName = input.FullName;
        Assert(input.ShortName.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
        Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
        State.NFTTypeFullNameMap[input.ShortName] = fullName;
        State.NFTTypeShortNameMap[fullName] = input.ShortName;
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Add(input.ShortName, fullName);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeAdded
        {
            ShortName = input.ShortName,
            FullName = input.FullName
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-157)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        Assert(input.Value.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L159-163)
```csharp
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Remove(input.Value);
        State.NFTTypes.Value = nftTypes;
```
