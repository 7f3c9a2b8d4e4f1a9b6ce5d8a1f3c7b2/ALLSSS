# Audit Report

## Title
Treasury Accepts Unfavorable Prices Due to Missing Slippage Protection on Token Conversion

## Summary
The Treasury contract's `ConvertToNativeToken` method performs token sales without specifying the `ReceiveLimit` parameter, accepting any exchange rate regardless of how unfavorable. This violates core DeFi security principles and exposes the Treasury to value loss during token conversions.

## Finding Description

When users donate non-native tokens to Treasury via the `Donate` method, the contract checks if the token can be converted to the native token. [1](#0-0)  If conversion is required, the private `ConvertToNativeToken` method is invoked. [2](#0-1) 

The vulnerable `ConvertToNativeToken` method constructs a `SellInput` with only the `Symbol` and `Amount` fields, completely omitting the `ReceiveLimit` parameter. [3](#0-2) 

The protobuf specification explicitly defines `receive_limit` as a slippage protection mechanism: "Limits on tokens obtained by selling. If the token obtained is less than this value, the sale will be abandoned. And 0 is no limit." [4](#0-3) 

In the TokenConverter's `Sell` implementation, when `ReceiveLimit` defaults to 0, the assertion `Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.")` always passes via short-circuit evaluation, providing no minimum price protection. [5](#0-4) 

The exchange rate is calculated deterministically by `BancorHelper.GetReturnFromPaid` based on connector balance ratios. [6](#0-5) [7](#0-6)  These connector balances are modified by public `Buy` and `Sell` operations accessible to any user. [8](#0-7) [9](#0-8) 

This creates a security vulnerability where Treasury conversions lack protection against unfavorable exchange rates, whether caused by natural market volatility, concurrent trading activity, or deliberate price manipulation.

## Impact Explanation

This vulnerability causes **direct financial loss to the Treasury** on every conversion of donated non-native tokens. The Treasury is a critical component of AElf's economic model, managing the primary profit scheme and distributing rewards to miners, voters, and other stakeholders. [10](#0-9) 

Without slippage protection, the Treasury accepts whatever price the Bancor formula yields at execution time, regardless of market conditions. During periods of:
- High trading volume altering connector balance ratios
- Natural price volatility between donation submission and execution
- Large trades moving prices before Treasury conversions execute

The Treasury systematically receives less native token value than the fair market rate would provide. The loss magnitude scales with donation amounts and the degree of price movement. Since the `Donate` method is publicly callable and processes conversions automatically, [11](#0-10)  this vulnerability affects every convertible token donation.

The cumulative impact reduces funds available for protocol rewards and economic sustainability.

## Likelihood Explanation

**High Likelihood** - This vulnerability is triggered on every donation requiring token conversion, making it a systemic issue rather than an edge case:

1. **Public Entry Point**: The `Donate` method is publicly accessible with no privilege requirements, accepting any valid token symbol and amount.

2. **Automatic Execution**: Conversion happens automatically when non-native convertible tokens are donated, without user control over pricing parameters.

3. **No Protection Mechanism**: The existing `ReceiveLimit` slippage protection in TokenConverter is completely unused by Treasury, as confirmed by test coverage showing proper usage elsewhere but not in Treasury's conversion flow. [12](#0-11) 

4. **Deterministic Price Impact**: The Bancor formula means any change in connector balances (from any source - legitimate trading, arbitrage, or deliberate manipulation) directly affects the conversion rate Treasury receives.

5. **DeFi Standard Violation**: Industry best practice mandates slippage protection for all AMM interactions. The absence of this protection in a critical protocol component represents a significant security gap.

The vulnerability manifests on every affected transaction, making exploitation probability 100% for conversions occurring during unfavorable market conditions.

## Recommendation

Implement slippage protection by calculating and specifying an appropriate `ReceiveLimit` in the `ConvertToNativeToken` method. The fix should:

1. Calculate the expected return amount before initiating the sale
2. Apply a reasonable slippage tolerance (e.g., 1-5% below expected)
3. Set `ReceiveLimit` in the `SellInput` to enforce this minimum

**Recommended Fix:**
```csharp
private void ConvertToNativeToken(string symbol, long amount)
{
    // Calculate expected return with slippage tolerance
    var fromConnector = State.TokenConverterContract.GetPairConnector.Call(
        new TokenSymbol { Symbol = symbol });
    
    var expectedReturn = CalculateExpectedReturn(fromConnector, amount);
    var minAcceptableReturn = expectedReturn.Mul(95).Div(100); // 5% slippage tolerance
    
    State.TokenContract.Approve.Send(new ApproveInput
    {
        Spender = State.TokenConverterContract.Value,
        Symbol = symbol,
        Amount = amount
    });

    State.TokenConverterContract.Sell.Send(new SellInput
    {
        Symbol = symbol,
        Amount = amount,
        ReceiveLimit = minAcceptableReturn  // ADD SLIPPAGE PROTECTION
    });

    Context.SendInline(Context.Self, nameof(DonateAll), new DonateAllInput
    {
        Symbol = Context.Variables.NativeSymbol
    });
}
```

Alternatively, consider allowing governance to configure the slippage tolerance percentage, or implement an oracle-based price verification mechanism.

## Proof of Concept

While a complete POC would require test infrastructure setup, the vulnerability can be demonstrated by:

1. Deploy test tokens with TokenConverter connectors
2. Call `Donate` with convertible tokens when connector balances are at different ratios
3. Observe Treasury receives different native token amounts for the same donation amount
4. Execute trades that move connector balances between donation and conversion
5. Verify Treasury accepts the worse price with no transaction reversion

The core issue is architecturally provable: `ConvertToNativeToken` creates `SellInput` without `ReceiveLimit`, and TokenConverter's `Sell` method bypasses price validation when `ReceiveLimit == 0`. This is visible directly in the source code without requiring runtime testing.

---

**Notes:**
- Treasury receives fee-free conversions (line 176-177 of TokenConverterContract.cs), but this doesn't address the missing slippage protection
- The vulnerability exists regardless of whether malicious front-running occurs - natural market dynamics alone cause value loss
- Other contracts using TokenConverter properly specify limits in tests, confirming this protection mechanism's intended usage

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L17-39)
```csharp
// ReSharper disable InconsistentNaming
/// <summary>
///     The Treasury is the largest profit scheme in AElf main chain.
///     Actually the Treasury is our Dividends Pool.
///     Income of the Treasury is mining rewards
///     (AEDPoS Contract will:
///     1. transfer ELF tokens to general ledger of Treasury every time we change term (7 days),
///     the amount of ELF should be based on blocks produced during last term. 1,000,000 * 1250000 ELF,
///     then release the Treasury;
///     2. Release Treasury)
///     3 sub profit schemes:
///     (Mining Reward for Miners) - 3
///     (Subsidy for Candidates / Backups) - 1
///     (Welfare for Electors / Voters / Citizens) - 1
///     3 sub profit schemes for Mining Rewards:
///     (Basic Rewards) - 4
///     (Welcome Rewards) - 1
///     (Flexible Rewards) - 1
///     3 incomes:
///     1. 20% total supply of elf, from consensus contract
///     2. tx fees.
///     3. resource consumption of developer's contracts.
/// </summary>
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L174-174)
```csharp
    public override Empty Donate(DonateInput input)
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L188-192)
```csharp
        var isNativeSymbol = input.Symbol == Context.Variables.NativeSymbol;
        var canExchangeWithNativeSymbol =
            isNativeSymbol ||
            State.TokenConverterContract.IsSymbolAbleToSell
                .Call(new StringValue { Value = input.Symbol }).Value;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L204-208)
```csharp
        var needToConvert = !isNativeSymbol && canExchangeWithNativeSymbol;
        if (needToConvert)
        {
            ConvertToNativeToken(input.Symbol, input.Amount);
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L676-680)
```csharp
        State.TokenConverterContract.Sell.Send(new SellInput
        {
            Symbol = symbol,
            Amount = amount
        });
```

**File:** protobuf/token_converter_contract.proto (L140-142)
```text
    // Limits on tokens obtained by selling. If the token obtained is less than this value, the sale will be abandoned.
    // And 0 is no limit.
    int64 receive_limit = 3;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-116)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-165)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L180-180)
```csharp
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConverterContractTests.cs (L281-286)
```csharp
        var sellResult = (await DefaultStub.Sell.SendAsync(new SellInput
        {
            Symbol = WriteConnector.Symbol,
            Amount = 1000L,
            ReceiveLimit = amountToReceive - fee - 10L
        })).TransactionResult;
```
