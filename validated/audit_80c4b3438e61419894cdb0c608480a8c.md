# Audit Report

## Title
Non-Evil Miner Replacements Incorrectly Bypass Reward Penalty Calculations

## Summary
The `RecordMinerReplacement()` function unconditionally marks ALL replacement miners as evil miner replacements, causing legitimate (non-evil) replacement miners to bypass performance-based penalty calculations during Basic Miner Reward distribution. This enables miners to gain unfair rewards by replacing their public key before terms where they anticipate poor performance.

## Finding Description

The vulnerability exists in the Treasury contract's `RecordMinerReplacement()` method. While the function correctly branches based on the `IsOldPubkeyEvil` flag to update different state variables, it unconditionally sets `State.IsReplacedEvilMiner[input.NewPubkey] = true` after the conditional block, executing for ALL replacement cases regardless of whether the old miner was evil or not. [1](#0-0) 

The execution flow begins when any candidate admin voluntarily replaces their public key through the Election contract's `ReplaceCandidatePubkey()` method. [2](#0-1) 

This triggers a cross-contract notification chain where the Election contract calls the AEDPoS consensus contract, which then calls the Treasury contract's `RecordMinerReplacement` method. Critically, the AEDPoS contract does NOT set the `IsOldPubkeyEvil` field in the input message, causing it to default to `false` for voluntary replacements. [3](#0-2) 

The protobuf message definition confirms that `is_old_pubkey_evil` is indeed a field that should distinguish evil from non-evil replacements. [4](#0-3) 

During reward distribution, the `UpdateBasicMinerRewardWeights` function checks the `IsReplacedEvilMiner` flag. When true, miners receive shares equal to their produced blocks directly, completely bypassing the penalty calculation. [5](#0-4) 

The `CalculateShares()` function enforces strict performance penalties that replacement miners incorrectly avoid: if a miner produces less than 50% of the average, they receive 0 shares; if they produce less than 80% of average, they receive quadratically reduced shares. [6](#0-5) 

## Impact Explanation

This vulnerability breaks the Treasury contract's fundamental invariant of fair, performance-based reward distribution. Replacement miners gain a systematic unfair advantage in Basic Miner Reward allocation:

**Concrete Scenario (Average blocks = 100):**
- A regular miner producing 40 blocks (40% of average) receives 0 shares due to the < 50% penalty threshold
- A replacement miner producing 40 blocks receives 40 shares with no penalty
- **Result**: Infinite advantage for severe underperformance

**Medium Performance Scenario:**
- A regular miner producing 60 blocks receives 36 shares (60² ÷ 100) due to quadratic penalty
- A replacement miner producing 60 blocks receives 60 shares
- **Result**: 67% excess rewards (24 additional shares)

Over multiple terms, this systematically misallocates Basic Miner Rewards from high-performing miners to strategically-timed underperforming replacement miners. The economic impact scales with the number of replacements and the degree of underperformance, directly affecting the fairness and integrity of the Treasury's reward distribution mechanism.

## Likelihood Explanation

**Attacker Capability**: Any candidate admin can trigger this vulnerability. The Election contract only requires the sender to be the candidate's admin, which is a standard operational role for key rotation or security updates. [7](#0-6) 

**Attack Complexity**: Low. The exploitation requires a single transaction calling `ReplaceCandidatePubkey(oldPubkey, newPubkey)`, which automatically propagates through the contract chain to mark the new key with the bypass flag, and the next reward distribution will exempt the miner from penalties.

**Feasibility**: High. Public key replacement is a legitimate operational feature designed for key rotation. There are no rate limits, governance approvals, or additional restrictions beyond being a candidate admin - a role achievable through normal election participation.

**Economic Rationality**: Clear financial incentive. A miner anticipating poor performance (hardware issues, network problems, scheduled downtime) can strategically replace their key to receive full rewards instead of 0-60% reduced rewards. The cost is minimal (one transaction), while the benefit can be 40-100% additional reward shares per term.

**Preconditions**: Requires being a current candidate with admin control, which is a standard operational state for any active candidate in the system.

## Recommendation

Move the unconditional state mutation inside the conditional block so it only applies to actual evil miner replacements:

```csharp
public override Empty RecordMinerReplacement(RecordMinerReplacementInput input)
{
    Assert(
        Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
        "Only AEDPoS Contract can record miner replacement.");

    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    if (!input.IsOldPubkeyEvil)
    {
        var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
        State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
        State.LatestMinedTerm.Remove(input.OldPubkey);
    }
    else
    {
        var replaceCandidates = State.ReplaceCandidateMap[input.CurrentTermNumber] ?? new StringList();
        replaceCandidates.Value.Add(input.NewPubkey);
        State.ReplaceCandidateMap[input.CurrentTermNumber] = replaceCandidates;
        
        // ONLY mark as evil miner replacement when actually replacing an evil miner
        State.IsReplacedEvilMiner[input.NewPubkey] = true;
    }

    return new Empty();
}
```

Additionally, ensure the AEDPoS contract properly sets `IsOldPubkeyEvil = true` when processing actual evil node replacements (if such a mechanism exists or is planned).

## Proof of Concept

A test demonstrating this vulnerability would:

1. Set up a candidate with admin control
2. Have the candidate mine with normal performance in term N
3. Call `ReplaceCandidatePubkey()` before term N+1
4. Have the replacement miner severely underperform in term N+1 (e.g., produce 40% of average blocks)
5. Verify that during reward distribution for term N+1:
   - The replacement miner receives shares equal to produced blocks (bypassing penalties)
   - A non-replacement miner with identical performance receives 0 shares (due to <50% penalty)
6. Assert that the replacement miner gained unfair reward advantage despite identical underperformance

The test would demonstrate that the `IsReplacedEvilMiner` flag was set to `true` for a non-evil replacement, allowing the penalty bypass in `UpdateBasicMinerRewardWeights`.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L573-599)
```csharp
    public override Empty RecordMinerReplacement(RecordMinerReplacementInput input)
    {
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only AEDPoS Contract can record miner replacement.");

        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        if (!input.IsOldPubkeyEvil)
        {
            var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
            State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
            State.LatestMinedTerm.Remove(input.OldPubkey);
        }
        else
        {
            var replaceCandidates = State.ReplaceCandidateMap[input.CurrentTermNumber] ?? new StringList();
            replaceCandidates.Value.Add(input.NewPubkey);
            State.ReplaceCandidateMap[input.CurrentTermNumber] = replaceCandidates;
        }

        State.IsReplacedEvilMiner[input.NewPubkey] = true;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L777-822)
```csharp
    private void UpdateBasicMinerRewardWeights(IReadOnlyCollection<Round> previousTermInformation)
    {
        if (previousTermInformation.First().RealTimeMinersInformation != null)
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });

        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** protobuf/treasury_contract.proto (L154-159)
```text
message RecordMinerReplacementInput {
    string old_pubkey = 1;
    string new_pubkey = 2;
    int64 current_term_number = 3;
    bool is_old_pubkey_evil = 4;
}
```
