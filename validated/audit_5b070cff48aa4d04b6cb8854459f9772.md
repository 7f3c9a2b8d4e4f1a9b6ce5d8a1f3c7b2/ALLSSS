# Audit Report

## Title
Arithmetic Overflow in Bancor Price Calculation Due to Unbounded Weight Ratios

## Summary
The `GetAmountToPayFromReturn` function in the TokenConverter contract computes exponential calculations without validating the ratio between connector weights. When connector pairs have highly unbalanced weights (e.g., 0.01 vs 0.5), large purchase amounts cause arithmetic overflow in the power calculation, rendering the connector pair unusable and creating a denial-of-service condition for token conversion operations.

## Finding Description

The vulnerability exists in the Bancor formula implementation used for token conversion pricing. When a user attempts to buy tokens via the `Buy` method, the contract calculates the required payment amount using `GetAmountToPayFromReturn`. [1](#0-0) 

This function computes the weight ratio `y = toConnectorWeight / fromConnectorWeight` without any bounds checking on the ratio magnitude: [2](#0-1) 

The exponential calculation `Exp(y * Ln(x))` uses a 20-term Taylor series expansion that requires computing high powers of the input: [3](#0-2) [4](#0-3) 

The `Pow` function uses binary exponentiation with repeated multiplication: [5](#0-4) 

**Exploitation Scenario:**

1. Governance calls `AddPairConnector` with unbalanced weights (e.g., ResourceWeight="0.01", NativeWeight="0.5")
2. Both weights pass validation since they're individually between 0 and 1: [6](#0-5) [7](#0-6) 

3. Connector pair is created successfully: [8](#0-7) 

4. User attempts to buy a significant portion of the resource token supply (e.g., 45%)
5. The calculation produces: y = 0.5 / 0.01 = 50, and when x ≈ 1.82 (for 45% purchase), the Exp argument becomes approximately 50 × 0.598 ≈ 29.9
6. Computing Pow(29.9, 20) requires intermediate values exceeding decimal.MaxValue (≈ 7.9 × 10²⁸)
7. Since AElf contracts enforce overflow checking, an `OverflowException` is thrown: [9](#0-8) 

8. The entire Buy transaction fails, creating a DoS for this connector pair

**No validation exists on weight ratios** - only individual weight bounds are checked, allowing problematic configurations to be deployed.

## Impact Explanation

**High Severity - Operational Denial of Service:**

The vulnerability breaks the availability guarantee of the token conversion system. Connector pairs with weight ratios exceeding approximately 40-50:1 become unusable for legitimate large purchases (>40% of reserves), effectively fragmenting protocol liquidity.

**Specific impacts:**
- All `Buy` transactions for affected connectors fail with `OverflowException` when purchase amounts exceed the overflow threshold
- Users cannot swap tokens through affected pairs, disrupting token economics
- Governance may unknowingly deploy broken connectors since validation provides false security
- No mechanism exists to detect the issue until users attempt transactions
- Smaller purchases succeed while larger ones fail, creating confusing and inconsistent user experience
- Protocol reputation damage due to unexplained transaction failures

**No direct fund theft occurs**, but the complete operational disruption represents a critical availability failure. The confirmation that overflow checking is enforced means the system fails-safe rather than producing incorrect prices, but the DoS impact remains severe. [10](#0-9) 

## Likelihood Explanation

**Medium Likelihood:**

The vulnerability requires governance action to deploy misconfigured connectors, but this can occur through either malicious intent or accidental misconfiguration during normal operations.

**Preconditions:**
- ConnectorController (Parliament by default) must call `AddPairConnector` with unbalanced weights
- Both individual weights must be valid (between 0 and 1), but their ratio must be high

**Why this is realistic:**
- Weight ratios like 50:1 or 100:1 might appear economically reasonable for certain token pairs (e.g., high-value vs low-value tokens)
- Governance members lack tooling or warnings about ratio constraints
- No documentation specifies ratio limits
- The validation logic provides false confidence that checked weights are safe

**Evidence of missing safeguards:**
- Test cases only validate equal or similar weights (0.05/0.05, 0.6/0.5): [11](#0-10) 

- No overflow scenario testing exists in the BancorHelper tests: [12](#0-11) 

**Detection difficulty:**
- Issue not visible during connector creation
- Manifests only during user transactions
- Smaller purchases succeed, masking the problem initially

## Recommendation

Add validation in `AddPairConnector` and `UpdateConnector` to enforce maximum weight ratios:

```csharp
private void AssertValidConnectorWeightRatio(Connector connector1, Connector connector2)
{
    var weight1 = AssertedDecimal(connector1.Weight);
    var weight2 = AssertedDecimal(connector2.Weight);
    
    var maxRatio = Math.Max(weight1 / weight2, weight2 / weight1);
    const decimal MaxAllowedRatio = 10m; // Conservative limit to prevent overflow
    
    Assert(maxRatio <= MaxAllowedRatio, 
        $"Connector weight ratio ({maxRatio}) exceeds maximum allowed ({MaxAllowedRatio})");
}
```

Apply this validation in `AddPairConnector` after both connectors are created:

```csharp
public override Empty AddPairConnector(PairConnectorParam input)
{
    // ... existing code ...
    
    AssertValidConnectorWeight(resourceConnector);
    AssertValidConnectorWeight(nativeTokenToResourceConnector);
    
    // Add ratio validation
    AssertValidConnectorWeightRatio(resourceConnector, nativeTokenToResourceConnector);
    
    State.Connectors[resourceConnector.Symbol] = resourceConnector;
    State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
    return new Empty();
}
```

Alternatively, implement safe arithmetic in the `Pow` and `Exp` functions using checked blocks with overflow handling, though this would only provide error messages rather than preventing misconfiguration.

## Proof of Concept

```csharp
[Fact]
public async Task Buy_With_Unbalanced_Weight_Ratio_Causes_Overflow()
{
    // Setup: Create connector pair with 50:1 weight ratio
    var tokenSymbol = "UNBALANCED";
    await CreateTokenAsync(tokenSymbol);
    
    var pairConnector = new PairConnectorParam
    {
        ResourceConnectorSymbol = tokenSymbol,
        ResourceWeight = "0.01",      // Very low weight
        NativeWeight = "0.5",          // Much higher weight (ratio = 50)
        NativeVirtualBalance = 1_000_000_00000000
    };
    
    await ExecuteProposalForParliamentTransaction(
        TokenConverterContractAddress,
        nameof(TokenConverterContractImplContainer.TokenConverterContractImplStub.AddPairConnector),
        pairConnector);
    
    // Enable the connector
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = 100_000_00000000,
        To = DefaultSender,
        Symbol = tokenSymbol
    });
    
    await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 100_000_00000000
    });
    
    // Attempt to buy ~45% of supply - this will trigger overflow
    var largePurchaseAmount = 45_000_00000000; // 45% of 100,000
    
    var buyResult = await DefaultStub.Buy.SendWithExceptionAsync(new BuyInput
    {
        Symbol = tokenSymbol,
        Amount = largePurchaseAmount,
        PayLimit = long.MaxValue
    });
    
    // Verify overflow exception occurs
    buyResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    buyResult.TransactionResult.Error.ShouldContain("OverflowException");
}
```

This test demonstrates that connector pairs with weight ratios around 50:1 fail on large purchases due to arithmetic overflow in the Bancor calculation, confirming the vulnerability.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-109)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L98-98)
```csharp
    private const int _LOOPS = 20; // Max = 20
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L104-120)
```csharp
    public static decimal Pow(decimal x, uint y)
    {
        if (y == 1)
            return x;

        var A = 1m;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;

        for (var i = t - 1; i >= 0; --i)
        {
            A *= A;
            if (e[i]) A *= x;
        }

        return A;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/project.md (L20-30)
```markdown
- It is required to enable `CheckForOverflowUnderflow` for both Release and Debug mode so that your contract will use arithmetic operators that will throw `OverflowException` if there is any overflow. This is to ensure that execution will not continue in case of an overflow in your contract and result with unpredictable output.

```xml
<PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
  <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
</PropertyGroup>

<PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
  <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
</PropertyGroup>
```
```

**File:** test/AElf.Contracts.TestContract.Tests/ContractSecurityTests.cs (L30-36)
```csharp
        var transactionResult = (await TestBasicSecurityContractStub.TestInt32State.SendWithExceptionAsync(
            new Int32Input
            {
                Int32Value = 100
            })).TransactionResult;
        transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        transactionResult.Error.Contains("System.OverflowException").ShouldBeTrue();
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L493-502)
```csharp
    private PairConnectorParam GetLegalPairConnectorParam(string tokenSymbol, long nativeBalance = 1_0000_0000,
        string resourceWeight = "0.05", string nativeWeight = "0.05")
    {
        return new PairConnectorParam
        {
            ResourceConnectorSymbol = tokenSymbol,
            ResourceWeight = resourceWeight,
            NativeWeight = nativeWeight,
            NativeVirtualBalance = nativeBalance
        };
```

**File:** test/AElf.Contracts.TokenConverter.Internal.Tests/BancorHelperTest.cs (L35-41)
```csharp
    public void Pow_Test()
    {
        var result1 = BancorHelper.Pow(1.5m, 1);
        result1.ShouldBe(1.5m);

        BancorHelper.Pow(1.5m, 2);
    }
```
