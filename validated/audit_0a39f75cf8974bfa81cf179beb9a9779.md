# Audit Report

## Title
Malicious Miners Can Bypass Time Slot Validation by Forging ActualMiningTime in Consensus Header

## Summary
The AEDPoS consensus mechanism fails to verify that the `ActualMiningTime` claimed in consensus extra data matches the actual block timestamp (`Header.Time`). This allows malicious miners to produce blocks outside their assigned time slots by providing a forged `ActualMiningTime` that falls within their valid slot while setting the actual block timestamp to any arbitrary value, completely bypassing the fundamental time-slot scheduling mechanism.

## Finding Description

The vulnerability exists in the consensus validation and processing pipeline where `ActualMiningTime` values from consensus extra data are trusted without verification.

**Honest Block Generation Establishes the Invariant:**
During honest block generation, the system correctly sets `ActualMiningTime` to `Context.CurrentBlockTime`: [1](#0-0) [2](#0-1) 

This establishes the expected invariant: `ActualMiningTime == Context.CurrentBlockTime == Header.Time`.

**Validation Phase - Blind Recovery:**
During validation, the system recovers round information by blindly adding `ActualMiningTimes` from the provided consensus header without verification: [3](#0-2) [4](#0-3) [5](#0-4) 

**TimeSlotValidationProvider - Insufficient Check:**
The time slot validator only checks if the recovered `ActualMiningTime` is within slot boundaries, but never compares it against `Context.CurrentBlockTime`: [6](#0-5) 

The validation retrieves `latestActualMiningTime` from the recovered round and only validates it against `expectedMiningTime` and `endOfExpectedTimeSlot`. There is no validation that this `ActualMiningTime` matches the actual block time (`Context.CurrentBlockTime`).

**Processing Phase - Direct Storage:**
When consensus transactions are executed, the system directly stores the unverified `ActualMiningTime` to state: [7](#0-6) [8](#0-7) 

**Missing Protection - IsCurrentMiner Not Used:**
While the system has an `IsCurrentMiner` method that correctly validates timing using `Context.CurrentBlockTime`: [9](#0-8) 

This method is NOT called during block validation. The validation only uses `MiningPermissionValidationProvider` which performs a simple miner list membership check: [10](#0-9) 

**Attack Scenario:**
1. Malicious miner sets `Header.Time = T_attack` (e.g., 3 seconds before their assigned slot)
2. In consensus extra data, provides `ActualMiningTime = T_valid` (within their assigned slot)
3. Validation recovers the forged `ActualMiningTime` into `baseRound`
4. `TimeSlotValidationProvider` checks `T_valid` against slot boundaries - PASSES
5. No validation compares `T_valid` with `Context.CurrentBlockTime` (which is `T_attack`)
6. Block is accepted with actual timestamp `T_attack`, successfully mining outside the assigned slot

**Constraint Analysis:**
The only constraint on `Header.Time` is that it cannot be more than 4 seconds in the future: [11](#0-10) 

This means a miner can set `Header.Time` to any time in the past or up to 4 seconds in the future, while claiming a different `ActualMiningTime` in consensus data.

## Impact Explanation

This vulnerability breaks the fundamental time-slot scheduling invariant of AEDPoS consensus, which ensures fair block production among elected miners.

**Direct Impacts:**
- **Consensus Integrity Violation**: The core scheduling mechanism is bypassed, allowing miners to produce blocks at arbitrary times rather than respecting their assigned slots
- **Unfair Economic Advantage**: Attackers can mine blocks earlier than their slot (up to 4 seconds early or arbitrarily far into the past), capturing significantly more blocks and rewards than their fair share
- **Centralization Risk**: Over time, malicious miners consistently produce more blocks than honest miners, concentrating rewards and potentially gaining enough stake to increase their miner count
- **Network Destabilization**: Unpredictable block timing disrupts the consensus schedule and may cause legitimate miners to miss their slots

**Quantified Impact:**
In a typical 7-miner configuration with 4000ms time slots, an attacker producing blocks 2-4 seconds early could potentially mine during time windows allocated to other miners, capturing 20-30% more block rewards per term than their legitimate allocation.

## Likelihood Explanation

**Attack Requirements:**
- Attacker must be elected as a miner (achievable through standard staking/voting mechanisms)
- Requires modified node software to construct forged consensus extra data
- Technical sophistication to understand consensus protocol structure

**Feasibility: HIGH**
- No special cryptographic breaks or protocol-level exploits required
- Elected miners already have the infrastructure to produce blocks
- Modifying consensus extra data generation is straightforward for developers familiar with the codebase
- No additional constraints prevent the attack once miner status is obtained

**Detection Difficulty: HIGH**
- Forged blocks appear valid and pass all validation checks
- Detection requires external timestamp monitoring or statistical analysis of mining patterns
- Individual instances are indistinguishable from legitimate blocks

The combination of achievable prerequisites (miner election), straightforward execution (consensus data modification), and significant economic incentive (increased block rewards) makes this vulnerability highly likely to be exploited.

## Recommendation

Add validation to ensure that `ActualMiningTime` from consensus extra data matches `Context.CurrentBlockTime` (which is derived from `Header.Time`).

**Fix Location 1 - Validation Phase:**
In `ValidateBeforeExecution`, after recovering the round information, add a check:
```csharp
// After line 50 in AEDPoSContract_Validation.cs
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue || 
    extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
{
    var providedMinerInfo = extraData.Round.RealTimeMinersInformation[extraData.SenderPubkey.ToHex()];
    var providedActualMiningTime = providedMinerInfo.ActualMiningTimes.LastOrDefault();
    if (providedActualMiningTime != null && providedActualMiningTime != Context.CurrentBlockTime)
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = "ActualMiningTime in consensus data does not match block timestamp" 
        };
    }
}
```

**Fix Location 2 - Processing Phase:**
In `ProcessUpdateValue` and `ProcessTinyBlock`, add validation before storing:
```csharp
// In ProcessUpdateValue before line 243
Assert(updateValueInput.ActualMiningTime == Context.CurrentBlockTime, 
       "ActualMiningTime must match block timestamp");

// In ProcessTinyBlock before line 304
Assert(tinyBlockInput.ActualMiningTime == Context.CurrentBlockTime,
       "ActualMiningTime must match block timestamp");
```

## Proof of Concept

The vulnerability can be demonstrated by examining the validation flow:

1. Create a test where a miner produces a block with:
   - `Header.Time = T` (e.g., current time)
   - Consensus extra data with `ActualMiningTime = T + 5000ms` (in the future, within their slot)

2. The block will pass validation because:
   - `TimeSlotValidationProvider` only checks `ActualMiningTime` (T+5000ms) against slot boundaries
   - No validator checks if `ActualMiningTime == Context.CurrentBlockTime` (T)

3. The forged `ActualMiningTime` gets stored to state, while the actual block has timestamp T, allowing the miner to produce a block 5 seconds before their intended time.

The test would verify that:
- The block passes all validation in `ValidateBeforeExecution`
- The forged `ActualMiningTime` is stored in the round state
- The block's actual timestamp (`Header.Time`) differs from the claimed `ActualMiningTime`

This demonstrates the complete bypass of time-slot scheduling, allowing miners to mine outside their assigned windows.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L162-163)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L47-50)
```csharp
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L20-20)
```csharp
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L44-44)
```csharp
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L304-304)
```csharp
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L136-167)
```csharp
    private bool IsCurrentMiner(string pubkey)
    {
        if (pubkey == null) return false;

        if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;

        Context.LogDebug(() =>
            $"Extra block producer of previous round: {currentRound.ExtraBlockProducerOfPreviousRound}");

        // Check confirmed extra block producer of previous round.
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }

        var miningInterval = currentRound.GetMiningInterval();
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;

        // Check normal time slot.
        if (timeSlotStartTime <= Context.CurrentBlockTime && Context.CurrentBlockTime <=
            timeSlotStartTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]NORMAL");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** src/AElf.Kernel.Types/KernelConstants.cs (L19-19)
```csharp
    public static Duration AllowedFutureBlockTimeSpan = new() { Seconds = 4 };
```
