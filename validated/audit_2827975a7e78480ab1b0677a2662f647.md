# Audit Report

## Title
Self-Referential Method Fee Setting Enables Governance Lockout

## Summary
The `SetMethodFee` function in the Genesis contract lacks validation to prevent setting transaction fees on itself, allowing governance to configure a fee that must be paid to modify any method fees. If set excessively high and the Parliament organization's virtual address lacks sufficient funds, governance becomes permanently locked out of all method fee management system-wide.

## Finding Description

The `SetMethodFee` method stores fee configurations without validating whether `input.MethodName` references itself. [1](#0-0) 

When Parliament releases a proposal, the transaction originates from the organization's virtual address via `SendVirtualInlineBySystemContract`. [2](#0-1) 

Before any transaction executes, the pre-execution plugin generates a `ChargeTransactionFees` transaction that retrieves the method fee and attempts to charge `Context.Sender`. [3](#0-2) 

The `GetMethodFee` method returns the stored fee from `State.TransactionFees[input.Value]` without special exemption for `SetMethodFee`. [4](#0-3) 

If fee charging fails due to insufficient balance, `IsStopExecuting` returns true, blocking the main transaction. [5](#0-4) 

The fee charging logic treats organization virtual addresses identically to regular addresses with no exemptions. [6](#0-5) 

Both `SetMethodFee` and `ChangeMethodFeeController` require authorization from the same Parliament organization address, providing no alternative recovery path. [7](#0-6) 

## Impact Explanation

Once a prohibitively high fee is configured for `SetMethodFee`, all future method fee modifications require paying that fee from Parliament's virtual address. Since `SetMethodFee` is the only mechanism to modify method fees (including reducing its own fee), and `ChangeMethodFeeController` requires identical authorization, governance lockout occurs if the organization cannot afford the fee.

This affects system-wide fee management capability across all contracts. Test evidence confirms organizations must pre-fund their virtual addresses before releasing proposals. [8](#0-7) 

If the fee exceeds economically feasible amounts (e.g., exceeding total ELF supply), recovery becomes impossible, resulting in permanent loss of fee governance.

## Likelihood Explanation

While this requires Parliament governance approval (2/3 miner consensus), it represents a realistic threat through:

1. **Human error**: Accidental misconfiguration during routine fee updates (e.g., incorrect decimal places: intending 100 ELF but setting 100000000 ELF)
2. **Lack of validation**: No warnings or bounds checking during proposal creation/approval
3. **Approval blindness**: Multiple miners could approve routine-looking fee adjustment proposals without detailed value verification

The attack requires only one successful governance proposal with `input.MethodName = "SetMethodFee"` and an excessive fee value. The precondition (governance approval) is routine as Parliament regularly votes on fee adjustments during normal operations.

## Recommendation

Add validation in `SetMethodFee` to prevent self-referential fee configuration:

```csharp
public override Empty SetMethodFee(MethodFees input)
{
    // Prevent setting fee for SetMethodFee itself
    Assert(input.MethodName != nameof(SetMethodFee), 
        "Cannot set fee for SetMethodFee method.");
    Assert(input.MethodName != nameof(ChangeMethodFeeController),
        "Cannot set fee for ChangeMethodFeeController method.");
    
    foreach (var methodFee in input.Fees) 
        AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, 
        "Unauthorized to set method fee.");
    
    State.TransactionFees[input.MethodName] = input;
    return new Empty();
}
```

Additionally, implement maximum fee bounds checking to prevent catastrophic misconfigurations even for other methods.

## Proof of Concept

```csharp
[Fact]
public async Task SelfReferentialMethodFee_CausesGovernanceLockout_Test()
{
    // 1. Get Parliament default organization address
    var parliamentOrg = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    
    // 2. Create proposal to set prohibitively high fee for SetMethodFee itself
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = parliamentOrg,
        ContractMethodName = "SetMethodFee",
        ToAddress = BasicContractZeroAddress,
        Params = new MethodFees
        {
            MethodName = "SetMethodFee", // Self-referential
            Fees = { new MethodFee { Symbol = "ELF", BasicFee = 1000000000000 } } // 10000 ELF
        }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
    };
    
    var proposalId = (await ParliamentContractStub.CreateProposal.SendAsync(proposalInput)).Output;
    
    // 3. Approve by all miners
    foreach (var miner in InitialMinersKeyPairs)
    {
        await GetParliamentContractTester(miner).Approve.SendAsync(proposalId);
    }
    
    // 4. Release proposal - succeeds (organization has no balance check on first call)
    await ParliamentContractStub.Release.SendAsync(proposalId);
    
    // 5. Verify fee is now set for SetMethodFee
    var fee = await BasicContractStub.GetMethodFee.CallAsync(new StringValue { Value = "SetMethodFee" });
    fee.Fees.First().BasicFee.ShouldBe(1000000000000);
    
    // 6. Attempt to reduce the fee - FAILS due to insufficient organization balance
    var recoverProposal = new CreateProposalInput
    {
        OrganizationAddress = parliamentOrg,
        ContractMethodName = "SetMethodFee",
        ToAddress = BasicContractZeroAddress,
        Params = new MethodFees
        {
            MethodName = "SetMethodFee",
            Fees = { new MethodFee { Symbol = "ELF", BasicFee = 100 } } // Try to reduce
        }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
    };
    
    var recoverProposalId = (await ParliamentContractStub.CreateProposal.SendAsync(recoverProposal)).Output;
    
    foreach (var miner in InitialMinersKeyPairs)
    {
        await GetParliamentContractTester(miner).Approve.SendAsync(recoverProposalId);
    }
    
    // Release fails - organization address doesn't have 10000 ELF to pay the fee
    var result = await ParliamentContractStub.Release.SendWithExceptionAsync(recoverProposalId);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Transaction fee not enough");
    
    // Governance lockout confirmed - cannot modify any method fees
}
```

## Notes

This vulnerability demonstrates a critical design flaw where lack of self-reference validation creates an unrecoverable failure state. While requiring governance approval, the realistic likelihood of configuration errors combined with catastrophic impact justifies classification as a valid security vulnerability requiring immediate mitigation through validation logic.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L9-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L34-47)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var fees = State.TransactionFees[input.Value];
        if (fees == null && input.Value == nameof(ReleaseApprovedUserSmartContract))
        {
            fees = new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        }

        return fees;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L58-121)
```csharp
    public async Task<IEnumerable<Transaction>> GetPreTransactionsAsync(IReadOnlyList<ServiceDescriptor> descriptors,
        ITransactionContext transactionContext)
    {
        try
        {
            var chainContext = new ChainContext
            {
                BlockHash = transactionContext.PreviousBlockHash,
                BlockHeight = transactionContext.BlockHeight - 1
            };

            var tokenContractAddress = await _smartContractAddressService.GetAddressByContractNameAsync(
                chainContext,
                TokenSmartContractAddressNameProvider.StringName);

            if (transactionContext.BlockHeight < AElfConstants.GenesisBlockHeight + 1 ||
                tokenContractAddress == null)
                return new List<Transaction>();

            if (!IsApplicableToTransaction(descriptors, transactionContext.Transaction, tokenContractAddress))
                return new List<Transaction>();

            var tokenStub = _contractReaderFactory.Create(new ContractReaderContext
            {
                Sender = transactionContext.Transaction.From,
                ContractAddress = tokenContractAddress,
                RefBlockNumber = transactionContext.Transaction.RefBlockNumber
            });

            if (IsExemptedTransaction(transactionContext.Transaction, tokenContractAddress, tokenStub))
                return new List<Transaction>();

            var txCost = await _txFeeService.CalculateFeeAsync(transactionContext, chainContext);
            var chargeTransactionFeesInput = new ChargeTransactionFeesInput
            {
                MethodName = transactionContext.Transaction.MethodName,
                ContractAddress = transactionContext.Transaction.To,
                TransactionSizeFee = txCost
            };

            var transactionSizeFeeSymbols =
                await _transactionSizeFeeSymbolsProvider.GetTransactionSizeFeeSymbolsAsync(chainContext);
            if (transactionSizeFeeSymbols != null)
                foreach (var transactionSizeFeeSymbol in transactionSizeFeeSymbols.TransactionSizeFeeSymbolList)
                    chargeTransactionFeesInput.SymbolsToPayTxSizeFee.Add(new SymbolToPayTxSizeFee
                    {
                        TokenSymbol = transactionSizeFeeSymbol.TokenSymbol,
                        BaseTokenWeight = transactionSizeFeeSymbol.BaseTokenWeight,
                        AddedTokenWeight = transactionSizeFeeSymbol.AddedTokenWeight
                    });

            var chargeFeeTransaction = GetTransaction(tokenStub, chargeTransactionFeesInput);
            return new List<Transaction>
            {
                chargeFeeTransaction
            };
        }
        catch (Exception e)
        {
            Logger.LogError(
                $"Failed to generate ChargeTransactionFees tx.Transaction to: {transactionContext.Transaction.To},transation method name: {transactionContext.Transaction.MethodName}. Error message: {e.Message}");
            throw;
        }
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L123-129)
```csharp
    public bool IsStopExecuting(ByteString txReturnValue, out string preExecutionInformation)
    {
        var chargeTransactionFeesOutput = new ChargeTransactionFeesOutput();
        chargeTransactionFeesOutput.MergeFrom(txReturnValue);
        preExecutionInformation = chargeTransactionFeesOutput.ChargingInformation;
        return !chargeTransactionFeesOutput.Success;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-53)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L582-591)
```csharp
            var maximalAbstentionThreshold = 3000;
            var maximalRejectionThreshold = 3000;
            var minimalVoteThreshold = 6000;
            var organizationAddress = await CreateOrganizationAsync(minimalApprovalThreshold,
                maximalAbstentionThreshold, maximalRejectionThreshold, minimalVoteThreshold);

            // Rejection probability > maximalRejectionThreshold
            {
                var proposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
                await TransferToOrganizationAddressAsync(organizationAddress);
```
