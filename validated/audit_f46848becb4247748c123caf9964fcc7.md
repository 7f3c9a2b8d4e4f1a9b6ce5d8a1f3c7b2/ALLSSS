# Audit Report

## Title
Missing Range Validation on Mining Orders Allows Consensus DoS via Invalid Order Assignment

## Summary
The AEDPoS consensus contract fails to validate the range of mining order values in `TuneOrderInformation` when processing `UpdateValue` transactions. A malicious miner can inject out-of-range order values (e.g., 100, 101) that corrupt the consensus state, causing all subsequent attempts to generate the next round to throw exceptions and halt the blockchain.

## Finding Description

The vulnerability exists across three interconnected failures in the consensus validation logic:

**1. Insufficient Validation in NextRoundMiningOrderValidationProvider**

The validation provider only checks that the count of distinct miners with assigned orders matches the count of miners who mined, but does NOT verify that order values are within the valid range [1, minersCount]: [1](#0-0) 

**2. Missing Validation in UpdateValue Processing**

When `UpdateValue` is called, `ProcessUpdateValue` blindly applies all values from `TuneOrderInformation` without any validation: [2](#0-1) 

The `UpdateValueValidationProvider` only checks that OutValue and Signature are properly filled, but does NOT validate `TuneOrderInformation`: [3](#0-2) 

**3. Validation Provider Not Applied to UpdateValue**

Critically, `NextRoundMiningOrderValidationProvider` is only added when the behavior is `NextRound`, NOT when it's `UpdateValue`: [4](#0-3) 

**Exploitation Path:**

A malicious miner submits an `UpdateValue` transaction with `TuneOrderInformation` containing out-of-range order values for all active miners (e.g., orders 100, 101, 102, 103 for a 4-miner network). These corrupted values are persisted to state.

When any miner attempts to produce the next round block, `GetConsensusExtraDataForNextRound` calls `GenerateNextRoundInformation`: [5](#0-4) 

Which calls the Round extension method that directly assigns `FinalOrderOfNextRound` as `Order`: [6](#0-5) 

This then invokes `BreakContinuousMining`, which assumes orders 1 and 2 exist and calls `First()` operations that throw `InvalidOperationException` when no miner has those orders: [7](#0-6) 

Additionally, `GetMiningInterval` assumes miners with Order 1 and 2 exist and will throw `IndexOutOfRangeException`: [8](#0-7) 

## Impact Explanation

**Severity: HIGH - Complete Consensus Failure**

This vulnerability causes catastrophic failure of the consensus mechanism:

1. **Consensus Halt**: Once invalid orders are injected, every miner attempting to produce the next round block encounters the same exception during block preparation, preventing ANY new blocks from being produced.

2. **Network-Wide DoS**: The entire blockchain stops functioning - no transactions can be processed, no blocks can be produced.

3. **Recovery Difficulty**: Recovery requires either:
   - Manual state intervention to fix the corrupted `FinalOrderOfNextRound` values
   - Hard fork to bypass the corrupted round
   - Network restart with state rollback

4. **No Fund Loss but Critical Availability Impact**: While no funds are directly stolen, the complete unavailability of the blockchain is a critical security failure affecting all users and operations.

The impact meets HIGH severity criteria as it completely breaks the consensus integrity and causes a high-confidence DoS of all consensus operations.

## Likelihood Explanation

**Probability: HIGH - Easy to Execute**

The attack has minimal barriers:

1. **Attacker Requirements**: Only requires being an active miner in the current mining schedule - no special privileges or elevated permissions needed.

2. **Attack Complexity**: Extremely low - single malicious `UpdateValue` transaction with crafted `TuneOrderInformation` parameter mapping each miner to an out-of-range order value.

3. **No Economic Cost**: Beyond standard transaction fees, there is no economic deterrent. The attack doesn't require stake loss or significant resource investment.

4. **Public Attack Surface**: `UpdateValue` is a public RPC method: [9](#0-8) 

5. **Authorization Check Insufficient**: The only check is `PreCheck()` which merely verifies the sender is in the current or previous miner list, but doesn't prevent malicious order assignments: [10](#0-9) 

## Recommendation

Add range validation for `TuneOrderInformation` values in `ProcessUpdateValue` before applying them to state. The validation should ensure:

1. All order values are within the valid range [1, minersCount]
2. All order values are unique (no duplicates)
3. Only miners who actually mined in the current round can have their orders tuned

Alternatively, extend `UpdateValueValidationProvider` to include `TuneOrderInformation` validation, checking that all provided order values fall within the expected range based on the current miner count.

Example fix in `ProcessUpdateValue`:

```csharp
// Validate TuneOrderInformation before applying
var minersCount = currentRound.RealTimeMinersInformation.Count;
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount, 
           $"Invalid order value {tuneOrder.Value}. Must be in range [1, {minersCount}]");
    Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key), 
           "Cannot tune order for non-existent miner");
}

// Check for duplicate order values
var orderValues = updateValueInput.TuneOrderInformation.Values.ToList();
Assert(orderValues.Count == orderValues.Distinct().Count(), 
       "Duplicate order values detected in TuneOrderInformation");
```

## Proof of Concept

A PoC test would demonstrate:

1. Initialize a consensus round with 4 miners having valid orders (1, 2, 3, 4)
2. Miner A calls `UpdateValue` with `TuneOrderInformation` setting all miners to orders 100, 101, 102, 103
3. Verify the corrupted orders are persisted to state
4. Attempt to call `GetConsensusExtraDataForNextRound` for any miner
5. Observe that the call throws `InvalidOperationException` or `IndexOutOfRangeException`
6. Verify that no miner can produce the next block, resulting in consensus halt

This demonstrates complete consensus DoS achievable by any active miner with a single malicious transaction.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-88)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-176)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-84)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** protobuf/aedpos_contract.proto (L30-31)
```text
    rpc UpdateValue (UpdateValueInput) returns (google.protobuf.Empty) {
    }
```
