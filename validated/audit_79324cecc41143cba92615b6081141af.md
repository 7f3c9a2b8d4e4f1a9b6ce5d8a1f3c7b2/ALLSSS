# Audit Report

## Title
Last Miner InValue Grinding Attack - Mining Order Manipulation

## Summary
The AEDPoS consensus validation fails to prevent the last miner in a round from grinding their current `InValue` to manipulate their mining order in subsequent rounds. By observing all other miners' signatures before committing their own `OutValue`, the last miner can choose an `InValue` that produces a favorable signature for the next round, violating the consensus mechanism's randomness guarantee and fairness.

## Finding Description

The AEDPoS consensus uses a commit-reveal scheme where miners commit `OutValue = hash(InValue)` in round N and reveal `InValue` in round N+1. The revealed `InValue` is used to calculate a signature that determines mining order. [1](#0-0) 

The signature calculation XORs the `inValue` with all signatures from the previous round. When producing blocks, miners calculate their signature from the previous round using this method. [2](#0-1) 

This signature then determines the miner's order in the next round through a modulo operation: [3](#0-2) 

**Root Cause**: The validation only checks that the revealed `PreviousInValue` matches the previously committed `PreviousOutValue`: [4](#0-3) 

The validation does NOT validate the randomness or unbiased selection of the CURRENT `InValue` being committed. Additionally, the VRF random beacon mechanism is separate from the InValue mechanism and does not constrain InValue choice: [5](#0-4) [6](#0-5) 

The VRF verification validates the `random_number` field but is independent of the `InValue` validation: [7](#0-6) 

**Attack Flow:**

When the last miner in round N produces their block:
1. They can observe all other miners' signatures (Sig_N^1, Sig_N^2, ..., Sig_N^{K-1}) already published in round N
2. They calculate their own Sig_N^K using their known InValue_{N-1}^K
3. They now know ALL Sig_N values
4. They need to commit OutValue_N^K = hash(InValue_N^K) for the current round
5. They try different InValue_N^K candidates offline:
   - Calculate Sig_{N+1}^K = XOR(InValue_N^K, XOR of all Sig_N)
   - Calculate order_{N+2}^K = (Sig_{N+1}^K.ToInt64() % minersCount) + 1
6. Select the InValue_N^K that gives the best order (e.g., order 1)
7. Commit the optimized OutValue_N^K = hash(chosen InValue_N^K)

The validation providers for UpdateValue behavior do not include any randomness checks on the InValue: [8](#0-7) 

## Impact Explanation

**Consensus Integrity Violation**: The randomness guarantee of the AEDPoS consensus mechanism is broken. The system assumes mining order is unpredictable and fair, but the last miner can systematically bias their position.

**Concrete Harm**:
- The last miner can systematically obtain better mining positions (e.g., order 1) more frequently than statistically expected
- Better positions correlate with more blocks produced and higher rewards
- Over many rounds, this advantage compounds significantly  
- Mining becomes unfair, with the attacker gaining disproportionate rewards
- Network decentralization is compromised as the attacking miner gains disproportionate influence

**Who is Affected**:
- All other honest miners who follow the protocol correctly suffer reduced block production opportunities
- The network's decentralization guarantee is violated
- Block reward distribution becomes skewed toward the attacker

**Severity**: Medium - Requires being last in mining order (1/K probability), but impact accumulates over time and violates a critical consensus invariant (mining order randomness).

## Likelihood Explanation

**Attacker Capabilities**: Any elected miner who mines last in their round order can execute this attack. No special privileges beyond normal mining rights are required.

**Attack Complexity**: Low
- Computational cost is minimal (just hash computations offline)
- No complex timing or coordination needed
- Can be automated in mining software
- Takes only seconds to find an optimal InValue

**Feasibility Conditions**:
- Attacker is an elected miner (normal requirement)
- Attacker mines last in round order (probability = 1/K per round where K is miner count)
- Attack can be repeated every time the miner is last

**Detection Difficulty**: Very hard to detect because:
- The chosen `InValue` looks like any other random value to observers
- Validation only checks hash consistency, not randomness source
- Statistical analysis would require many rounds and be inconclusive
- No on-chain evidence distinguishes grinding from honest behavior

**Probability**: High for any miner who is last in order, which occurs regularly in the mining rotation (1/K of all rounds).

## Recommendation

Implement one or more of the following mitigations:

1. **Bind InValue to VRF Proof**: Derive the InValue deterministically from the VRF random_number proof output, ensuring it cannot be chosen arbitrarily. This would make the InValue verifiable and prevent grinding.

2. **Add Commit-Reveal Delay**: Require miners to commit their OutValue before any miner in the round publishes their signature, preventing last miners from seeing all signatures before committing.

3. **Use VRF for Order Calculation**: Instead of using XOR of InValues for signature calculation, use the VRF proof output directly to determine mining order, eliminating the grindable InValue mechanism.

4. **Add Entropy Validation**: Validate that the InValue has sufficient entropy or follows a specific generation pattern that can be verified (though this is harder to implement securely).

The most robust solution would be option 1 or 3, which eliminates the ability to grind InValue by tying it cryptographically to a verifiable random function.

## Proof of Concept

While a full PoC would require a complete test environment with multiple miners, the vulnerability can be demonstrated through the following logical proof:

1. **Information Availability**: When miner K (last in round N) produces their block, they can call `GetCurrentRoundInformation()` to retrieve all previous miners' signatures from round N.

2. **Grinding Feasibility**: Given all Sig_N values, miner K can iterate through possible InValue_N candidates:
   ```
   for each candidate InValue_N:
       Sig_{N+1} = XOR(InValue_N, XOR(all Sig_N))
       order_{N+2} = (Sig_{N+1}.ToInt64() % K) + 1
       if order_{N+2} == 1: // or any desired order
           use this InValue_N
           break
   ```

3. **Validation Bypass**: The `ValidatePreviousInValue` method only checks hash consistency, allowing any InValue that hashes to the committed OutValue.

4. **Impact**: Over multiple rounds where the miner is last (1/K probability), they accumulate unfair mining advantages.

A formal test would require:
- Deploying consensus contract in test environment
- Simulating multiple miners
- Having test miner mine last and demonstrate consistent order manipulation
- Measuring statistical deviation from expected fair distribution

## Notes

This vulnerability is subtle because:
- The VRF random beacon mechanism exists but operates independently from the InValue mechanism
- The InValue commit-reveal scheme appears secure but lacks randomness validation
- The attack is probabilistic (requires being last) but has compounding impact over time
- Detection requires long-term statistical analysis across many rounds

The core issue is that the AEDPoS consensus assumes miners will honestly select random InValues, but provides no cryptographic enforcement of this assumption for the last miner in each round who has complete information before committing.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L39-49)
```csharp
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
            RandomNumber = randomNumber
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L45-47)
```csharp
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```
