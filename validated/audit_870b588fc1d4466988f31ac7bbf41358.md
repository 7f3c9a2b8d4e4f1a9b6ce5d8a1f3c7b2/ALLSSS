# Audit Report

## Title
TokenHolder Scheme Symbol Overwrite Causes Permanent Fund Lock

## Summary
The `CreateScheme` method in TokenHolderContract lacks validation to prevent overwriting existing schemes. When a scheme manager calls `CreateScheme` multiple times with different symbols, it causes a critical mismatch between the symbol used during token locking and the symbol queried during withdrawal, resulting in permanent fund loss for all users who locked tokens before the symbol change.

## Finding Description

**Root Cause:**

The `CreateScheme` method directly overwrites the scheme state without any validation check for existing schemes. [1](#0-0) 

**Execution Flow:**

1. **Initial Token Lock**: Users call `RegisterForProfits` which locks tokens using the current scheme's symbol. [2](#0-1) 

2. **Virtual Address Computation**: The MultiToken contract computes the virtual address for locking using only `Context.Sender + input.Address + input.LockId` - notably, the symbol is NOT part of this computation. [3](#0-2) 

3. **Scheme Overwrite**: When the manager calls `CreateScheme` again with a different symbol (e.g., changing from "ELF" to "USDT"), the entire scheme is replaced without any checks.

4. **Withdrawal Failure**: When users attempt to withdraw, the `Withdraw` method retrieves the NEW scheme with the changed symbol. [4](#0-3) 

5. **Zero Balance Query**: The `GetLockedAmount` call queries the balance at the virtual address for the NEW symbol. Since the virtual address only contains tokens of the ORIGINAL symbol, it returns zero. [5](#0-4) 

6. **Failed Unlock**: The subsequent `Unlock` call attempts to unlock zero tokens of the wrong symbol, leaving the original tokens permanently locked at the virtual address.

**Why Existing Protections Fail:**

- No assertion validates that a scheme doesn't already exist before overwriting
- The virtual address computation being symbol-agnostic creates an implicit dependency that the symbol must remain constant throughout the scheme's lifetime
- There is no recovery mechanism to unlock tokens using a different symbol than what's stored in the current scheme

## Impact Explanation

This vulnerability results in **CRITICAL** severity impact:

**Direct Fund Loss:**
- All users who called `RegisterForProfits` before the scheme symbol change lose access to their locked tokens permanently
- The tokens remain locked at the virtual address but become unrecoverable because the contract queries for the wrong symbol
- If N users locked A tokens each, total locked value = N Ã— A becomes permanently inaccessible

**Irreversibility:**
- The virtual address holding the original tokens becomes effectively inaccessible
- The lockId remains the same, but the symbol change makes the tokens unqueryable
- No contract mechanism exists to recover these funds

**Broken Invariant:**
This violates the fundamental lock/unlock correctness invariant: "Users can always withdraw tokens they have locked after the minimum lock period expires."

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attack Vectors:**
1. **Accidental Misuse**: Manager inadvertently calls `CreateScheme` twice during contract setup or configuration updates
2. **Malicious Intent**: Compromised or rogue manager intentionally locks user funds
3. **Operational Error**: Contract upgrade scenarios or management handovers leading to scheme reinitialization attempts

**Attack Complexity: LOW**
- Requires only a single function call to `CreateScheme` with a different symbol
- No preconditions beyond being the scheme manager (Context.Sender matches scheme creator)
- Standard transaction fee only

**Feasibility:**
- `CreateScheme` is a public method with no special authorization beyond being called by the manager [6](#0-5) 
- All steps are executable under standard AElf contract semantics
- No cryptographic barriers or complex state manipulation required

**Detection Difficulty:**
- No events are fired indicating scheme overwrite
- Silent failure mode during withdrawal (returns 0 instead of reverting)
- Post-incident detection requires manual inspection of scheme history

## Recommendation

Add a validation check in `CreateScheme` to prevent overwriting existing schemes:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add validation to prevent overwriting
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
           "Scheme already exists for this manager. Cannot overwrite.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, if scheme updates are a legitimate use case, implement a separate `UpdateScheme` method that validates no users have locked tokens before allowing symbol changes.

## Proof of Concept

```csharp
[Fact]
public async Task CreateScheme_SymbolOverwrite_CausesFundLock()
{
    // Setup: Create initial scheme with ELF symbol
    var manager = Accounts[0].Address;
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });

    // User locks 1000 ELF tokens
    var user = Accounts[1].Address;
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = manager,
        Amount = 1000_00000000
    });

    // Verify tokens are locked
    var lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = user,
        Symbol = "ELF",
        LockId = GenerateLockId(manager, user)
    });
    lockedAmount.Amount.ShouldBe(1000_00000000);

    // Manager overwrites scheme with different symbol
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",
        MinimumLockMinutes = 1
    });

    // Advance time past minimum lock period
    await AdvanceTime(2);

    // User attempts withdrawal - will fail because scheme now has wrong symbol
    var result = await TokenHolderContractStub.Withdraw.SendAsync(manager);
    
    // Verify original ELF tokens remain locked and inaccessible
    var remainingLocked = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = user,
        Symbol = "ELF",
        LockId = GenerateLockId(manager, user)
    });
    remainingLocked.Amount.ShouldBe(1000_00000000); // Still locked!
    
    // User cannot access these funds because contract now queries for USDT
    var userBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = user,
        Symbol = "ELF"
    });
    userBalance.Balance.ShouldBe(0); // Funds are stuck!
}
```

## Notes

This vulnerability represents a fundamental design flaw in the TokenHolder contract's scheme management. The lack of immutability or update restrictions on the scheme's symbol field, combined with the symbol-agnostic virtual address computation in the MultiToken contract, creates a critical invariant violation. Even though the scheme manager is typically a trusted role, the absence of basic validation allows for both accidental operational errors and potential malicious exploitation that result in irreversible fund loss.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-14)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-165)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L213-225)
```csharp
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-210)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-115)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
```
