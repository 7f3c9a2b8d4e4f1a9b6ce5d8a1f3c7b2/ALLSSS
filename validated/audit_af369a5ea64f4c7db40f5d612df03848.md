# Audit Report

## Title
Token Supply State Inconsistency After Burn Operations Causes Cross-Chain Transfer DoS

## Summary
The `Burn()` method modifies the `tokenInfo.Supply` field but fails to persist the change to `State.TokenInfos`, while `Issue()` and `CrossChainReceiveToken()` correctly persist their Supply updates. This causes `GetTokenInfo()` to return stale Supply values after burn operations, leading to incorrect "Total supply exceeded" failures in `CrossChainReceiveToken()` that block legitimate cross-chain token receives.

## Finding Description

The vulnerability exists in the `Burn()` method which modifies the local `tokenInfo.Supply` field but never persists this change back to the contract state. [1](#0-0) 

The method retrieves `tokenInfo`, decrements `Supply` at line 328, but critically never calls `SetTokenInfo()` to persist this modification to `State.TokenInfos`. This contrasts sharply with the correct implementation in `Issue()`, which properly calls `SetTokenInfo(tokenInfo)` after modifying Supply fields. [2](#0-1) 

Similarly, `CrossChainReceiveToken()` correctly persists its Supply modifications by calling `SetTokenInfo(tokenInfo)` after updating the Supply field. [3](#0-2) 

The `GetTokenInfo()` helper method reads directly from the persistent state `State.TokenInfos`, meaning it will return stale data if the state was never updated. [4](#0-3) 

The `SetTokenInfo()` helper is responsible for persisting changes to `State.TokenInfos`. [5](#0-4) 

Since `Burn()` never calls `SetTokenInfo()`, subsequent `GetTokenInfo()` calls return the outdated Supply value. The critical impact occurs in `CrossChainReceiveToken()` at line 621, which performs a supply limit check using the stale (non-decremented) Supply value obtained from `GetTokenInfo()`, causing it to incorrectly reject legitimate cross-chain receives after tokens have been burned.

## Impact Explanation

**Direct Operational Impact - Cross-Chain Transfer DoS:**

After burn operations, the `CrossChainReceiveToken()` function will incorrectly fail with "Total supply exceeded" error even when the actual circulating supply is well below the limit.

**Concrete Scenario:**
1. Token has `TotalSupply = 1000`, `Supply = 1000` (all tokens issued)
2. User burns 500 tokens via `Burn()`
3. Real circulating supply is now 500, but `State.TokenInfos` still shows `Supply = 1000`
4. User attempts `CrossChainReceiveToken(100)` 
5. The check evaluates: `1000 + 100 <= 1000` → **FAILS** (using stale 1000)
6. Should evaluate: `500 + 100 <= 1000` → **PASSES** (using actual 500)
7. Legitimate cross-chain receive is blocked

**Affected Operations:**
- All cross-chain token receives after any burn operations
- Token metadata queries returning incorrect circulating supply  
- Any external contracts or services relying on accurate Supply data

**Severity:** This is a **Medium severity** issue causing operational DoS of the cross-chain transfer functionality, a core protocol feature. While no direct fund loss occurs, it blocks legitimate user operations and disrupts cross-chain interoperability.

## Likelihood Explanation

**Attacker Capabilities:** Any user with burnable tokens can trigger this issue simply by calling the public `Burn()` method. [6](#0-5) 

**Attack Complexity:** Trivial - just burn tokens and attempt cross-chain receive.

**Preconditions:**
- Token must have `IsBurnable = true` (common for many token types)
- User must have token balance to burn (normal condition)
- Cross-chain functionality must be in use (normal protocol operation)

**Execution Steps:**
1. Call `Burn()` with any amount
2. Attempt `CrossChainReceiveToken()` 
3. Observe incorrect "Total supply exceeded" failure

**Probability:** High - affects all burnable tokens with cross-chain functionality enabled. The bug is deterministic and will occur every time tokens are burned and then cross-chain receives are attempted.

## Recommendation

Add the missing `SetTokenInfo(tokenInfo)` call in the `Burn()` method after updating the Supply field:

```csharp
private Empty Burn(Address address, string symbol, long amount)
{
    var tokenInfo = AssertValidToken(symbol, amount);
    Assert(tokenInfo.IsBurnable, "The token is not burnable.");
    ModifyBalance(address, symbol, -amount);
    tokenInfo.Supply = tokenInfo.Supply.Sub(amount);
    SetTokenInfo(tokenInfo);  // Add this line to persist the Supply change

    Context.Fire(new Burned
    {
        Burner = address,
        Symbol = symbol,
        Amount = amount
    });
    return new Empty();
}
```

This ensures consistency with the `Issue()` and `CrossChainReceiveToken()` implementations, which both correctly persist their Supply modifications.

## Proof of Concept

```csharp
[Fact]
public async Task Burn_DoesNotPersist_SupplyChange_CausesXChainReceiveDOS()
{
    // Setup: Create burnable token with TotalSupply=1000
    var symbol = "TEST";
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = symbol,
        TokenName = "Test Token",
        TotalSupply = 1000,
        Decimals = 8,
        IsBurnable = true,
        Issuer = DefaultAddress,
        Owner = DefaultAddress
    });
    
    // Issue all 1000 tokens
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = symbol,
        Amount = 1000,
        To = DefaultAddress
    });
    
    // Verify Supply = 1000
    var tokenInfoBefore = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = symbol });
    tokenInfoBefore.Supply.ShouldBe(1000);
    
    // Burn 500 tokens
    await TokenContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        Amount = 500
    });
    
    // BUG: GetTokenInfo still returns Supply = 1000 (stale)
    var tokenInfoAfter = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = symbol });
    tokenInfoAfter.Supply.ShouldBe(500); // FAILS - still shows 1000
    
    // This causes CrossChainReceiveToken to fail incorrectly
    // Check would be: 1000 + 100 <= 1000 (FAIL)
    // Should be: 500 + 100 <= 1000 (PASS)
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-178)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(input.To, input.Symbol, input.Amount);

        Context.Fire(new Issued
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = input.To,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L318-321)
```csharp
    public override Empty Burn(BurnInput input)
    {
        return Burn(Context.Sender, input.Symbol, input.Amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L323-337)
```csharp
    private Empty Burn(Address address, string symbol, long amount)
    {
        var tokenInfo = AssertValidToken(symbol, amount);
        Assert(tokenInfo.IsBurnable, "The token is not burnable.");
        ModifyBalance(address, symbol, -amount);
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);

        Context.Fire(new Burned
        {
            Burner = address,
            Symbol = symbol,
            Amount = amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L591-638)
```csharp
    public override Empty CrossChainReceiveToken(CrossChainReceiveTokenInput input)
    {
        var transferTransaction = Transaction.Parser.ParseFrom(input.TransferTransactionBytes);
        var transferTransactionId = transferTransaction.GetHash();

        Assert(!State.VerifiedCrossChainTransferTransaction[transferTransactionId],
            "Token already claimed.");

        var crossChainTransferInput =
            CrossChainTransferInput.Parser.ParseFrom(transferTransaction.Params.ToByteArray());
        var symbol = crossChainTransferInput.Symbol;
        var amount = crossChainTransferInput.Amount;
        var receivingAddress = crossChainTransferInput.To;
        var targetChainId = crossChainTransferInput.ToChainId;
        var transferSender = transferTransaction.From;

        var tokenInfo = AssertValidToken(symbol, amount);
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
        Assert(targetChainId == Context.ChainId, "Unable to claim cross chain token.");
        var registeredTokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        AssertCrossChainTransaction(transferTransaction, registeredTokenContractAddress,
            nameof(CrossChainTransfer));
        Context.LogDebug(() =>
            $"symbol == {tokenInfo.Symbol}, amount == {amount}, receivingAddress == {receivingAddress}, targetChainId == {targetChainId}");

        CrossChainVerify(transferTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);

        State.VerifiedCrossChainTransferTransaction[transferTransactionId] = true;
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(receivingAddress, tokenInfo.Symbol, amount);

        Context.Fire(new CrossChainReceived
        {
            From = transferSender,
            To = receivingAddress,
            Symbol = tokenInfo.Symbol,
            Amount = amount,
            Memo = crossChainTransferInput.Memo,
            FromChainId = input.FromChainId,
            ParentChainHeight = input.ParentChainHeight,
            IssueChainId = issueChainId,
            TransferTransactionId = transferTransactionId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L418-422)
```csharp
    private void SetTokenInfo(TokenInfo tokenInfo)
    {
        var symbol = tokenInfo.Symbol;
        State.TokenInfos[symbol] = tokenInfo;
    }
```
