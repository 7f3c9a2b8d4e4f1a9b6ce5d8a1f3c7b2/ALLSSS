# Audit Report

## Title
Integer Overflow in TokenHolder Withdraw Function Enables Permanent Token Lock via Malicious MinimumLockMinutes

## Summary
The TokenHolderContract allows any address to create profit-sharing schemes without validating the `MinimumLockMinutes` parameter. When set to extremely large values (≥153,722,867,280,912,931), the time calculation in the `Withdraw` function triggers a checked arithmetic overflow exception, permanently preventing users from unlocking their tokens with no recovery mechanism.

## Finding Description

The vulnerability exists across three key components that interact to create a permanent denial-of-service condition on user funds:

**1. Unvalidated Scheme Creation**

The `CreateScheme` function accepts arbitrary `MinimumLockMinutes` values without any bounds checking. [1](#0-0) 

The protobuf definition confirms `MinimumLockMinutes` is a standard `int64` with no constraints: [2](#0-1) 

**2. Overflow in Time Validation**

When users attempt to withdraw, the contract validates the lock duration using `AddMinutes(scheme.MinimumLockMinutes)`: [3](#0-2) 

The `AddMinutes` extension method multiplies minutes by 60 to convert to seconds: [4](#0-3) 

The `Mul` operation uses checked arithmetic that throws `OverflowException` instead of silently wrapping: [5](#0-4) 

For `MinimumLockMinutes ≥ 153,722,867,280,912,931`, the calculation `minutes * 60` exceeds `Int64.MaxValue` (9,223,372,036,854,775,807), triggering the overflow exception and reverting the entire withdraw transaction.

**3. No Alternative Recovery Path**

Users cannot unlock tokens through alternative mechanisms:

- Direct calls to `Token.Unlock` fail authorization checks requiring the caller to be in the symbol's LockWhiteList or be a system contract: [6](#0-5) 

- The whitelist validation enforces that only system contracts or explicitly whitelisted addresses can unlock: [7](#0-6) 

- The `RemoveBeneficiary` function only removes users from the profit scheme but does not unlock tokens: [8](#0-7) 

**Attack Flow:**
1. Attacker calls `CreateScheme` with `MinimumLockMinutes = 153722867280912931` (or any value ≥ this threshold)
2. Victim calls `RegisterForProfits`, locking tokens via the Token contract
3. Victim attempts `Withdraw` → `AddMinutes` overflows → transaction reverts
4. Tokens remain permanently locked with no recovery mechanism

## Impact Explanation

**Severity: HIGH**

This vulnerability enables permanent, irrecoverable loss of user funds:

- **Direct Financial Loss**: Users lose 100% of tokens locked in malicious schemes with no time-based or governance recovery mechanism
- **Fund Accessibility**: Tokens are locked in the MultiToken contract's virtual address system with the only unlock path permanently disabled
- **Scope**: Any user who registers for profits in a malicious scheme is affected
- **Permanence**: The scheme parameters cannot be modified after creation, making the lock condition permanent

The attacker does not gain direct access to locked funds, but achieves complete denial-of-service, effectively destroying user assets.

## Likelihood Explanation

**Probability: HIGH**

The attack is straightforward to execute with minimal barriers:

**Attacker Requirements:**
- No special privileges or governance approval needed
- Any address can call `CreateScheme` (no authorization checks)
- Single parameter manipulation: set `MinimumLockMinutes` to malicious value

**User Vulnerability:**
- Users may be attracted by profit-sharing opportunities without scrutinizing all parameters
- The `MinimumLockMinutes` value is visible but requires users to query scheme data and calculate overflow thresholds
- No warnings or validation errors occur during scheme creation
- Schemes could appear legitimate with attractive profit distribution terms

**Attack Simplicity:**
- One-transaction setup (`CreateScheme`)
- No complex preconditions or state manipulation required
- Exploit triggers automatically when victims attempt withdrawal

## Recommendation

Add validation to the `CreateScheme` function to enforce reasonable bounds on `MinimumLockMinutes`:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add validation for MinimumLockMinutes
    const long MaxSafeMinutes = 153722867280912930; // Int64.MaxValue / 60
    const long ReasonableMaxMinutes = 525600 * 10; // 10 years in minutes
    Assert(input.MinimumLockMinutes >= 0, "MinimumLockMinutes cannot be negative.");
    Assert(input.MinimumLockMinutes <= ReasonableMaxMinutes, 
           $"MinimumLockMinutes exceeds reasonable maximum of {ReasonableMaxMinutes}.");
    
    // Existing code...
}
```

Additionally, consider implementing a scheme upgrade mechanism or emergency unlock function controlled by governance to provide recovery options for edge cases.

## Proof of Concept

```csharp
[Fact]
public async Task IntegerOverflow_PermanentLock_Test()
{
    // Attacker creates malicious scheme with overflow-inducing MinimumLockMinutes
    const long maliciousMinutes = 153722867280912931L; // Causes overflow when multiplied by 60
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = maliciousMinutes
    });
    
    // Victim registers and locks tokens
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = Starter,
        Amount = 1000
    });
    
    // Victim attempts to withdraw - should throw OverflowException
    var withdrawResult = await TokenHolderContractStub.Withdraw.SendAsync(Starter);
    
    // Transaction reverts due to overflow, tokens permanently locked
    withdrawResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    withdrawResult.TransactionResult.Error.ShouldContain("Overflow");
}
```

## Notes

The calculation of the overflow threshold:
- `Int64.MaxValue = 9,223,372,036,854,775,807`
- `Threshold = Int64.MaxValue / 60 = 153,722,867,280,912,930.116...`
- Any `MinimumLockMinutes ≥ 153,722,867,280,912,931` causes overflow

The vulnerability affects all tokens that users lock through this mechanism, and there is no governance or time-based recovery path since the TokenHolder contract is the only entity authorized to unlock these tokens, and its unlock path is permanently broken by the overflow condition.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** protobuf/token_holder_contract.proto (L63-70)
```text
message CreateTokenHolderProfitSchemeInput {
    // The token symbol.
    string symbol = 1;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 3;
}
```

**File:** src/AElf.CSharp.Core/Extension/TimestampExtensions.cs (L39-42)
```csharp
    public static Timestamp AddMinutes(this Timestamp timestamp, long minutes)
    {
        return timestamp + new Duration { Seconds = minutes.Mul(60) };
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L79-85)
```csharp
    public static long Mul(this long a, long b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L224-231)
```csharp
    public override Empty Unlock(UnlockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L196-203)
```csharp
    private void AssertSystemContractOrLockWhiteListAddress(string symbol)
    {
        var symbolState = State.LockWhiteLists[symbol];
        var isInWhiteList = symbolState != null && symbolState[Context.Sender];
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Values;
        var isSystemContractAddress = systemContractAddresses.Contains(Context.Sender);
        Assert(isInWhiteList || isSystemContractAddress, "No Permission.");
    }
```
