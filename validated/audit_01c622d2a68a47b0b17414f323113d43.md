# Audit Report

## Title
NextTerm Transaction Lacks Validation of Miner List Against Election Contract Results

## Summary
The AEDPoS consensus contract's NextTerm transaction flow accepts arbitrary miner lists without validating them against election results from the Election contract. A malicious extra block producer can unilaterally determine which miners control the blockchain for the next term, completely bypassing the democratic election process and achieving permanent consensus takeover.

## Finding Description

The vulnerability exists in a critical disconnect between honest transaction generation and actual transaction validation/execution during term transitions.

**The Honest Path (Not Enforced):**

When generating NextTerm consensus data honestly, the system queries the Election contract to obtain legitimate miners. [1](#0-0)  calls `GenerateFirstRoundOfNextTerm`, which in turn queries election results: [2](#0-1) 

The election contract is queried via `GetVictories()`: [3](#0-2) 

**Critical Gap - No Validation During Execution:**

However, the actual NextTerm execution path never validates that the miners in the transaction input match election results. The `NextTermInput.Create()` method blindly copies all miner information: [4](#0-3) 

During validation, only `RoundTerminateValidationProvider` is added for NextTerm behavior: [5](#0-4) 

This provider only validates that round and term numbers are incremented correctly: [6](#0-5) 

**Execution Blindly Accepts Arbitrary Miners:**

The `ProcessNextTerm` method extracts miners directly from the input Round and stores them: [7](#0-6) 

The `SetMinerList` method only prevents duplicate updates for the same term, but performs zero validation of miner legitimacy: [8](#0-7) 

The `PreCheck()` authorization only verifies the sender is in current or previous miner list: [9](#0-8) 

**Attack Scenario:**

1. A malicious miner waits until they become the extra block producer when term transition is scheduled
2. Instead of calling the honest `GetConsensusExtraDataForNextTerm` path, they craft a malicious `Round` object containing their chosen miners (could be themselves, accomplices, or even non-existent keys)
3. They create a `NextTermInput` with this malicious Round
4. They broadcast the NextTerm transaction in their block
5. Validation passes because only round/term number increments are checked
6. Execution accepts and permanently stores the arbitrary miner list
7. The entire next term (typically 7 days) is controlled by the attacker's chosen miners
8. These malicious miners can repeat the attack indefinitely, creating permanent consensus capture

## Impact Explanation

**Consensus Integrity Catastrophic Failure:**
This vulnerability represents a complete breakdown of the DPoS consensus model. The "Delegated" aspect of Delegated Proof of Stake depends entirely on token holders electing block producers through voting. When a malicious extra block producer can arbitrarily choose all miners for the next term, the entire democratic election process becomes meaningless.

**Scope of Damage:**
- All token holder votes are nullified - voters lose their fundamental governance right to select block producers
- Legitimate election winners are excluded from consensus participation despite winning fairly
- Attacker gains unilateral control over which public keys can produce blocks for the next term (typically 604,800 seconds = 7 days)
- Malicious miners can inject themselves, colluding parties, or even invalid public keys
- All subsequent blocks, transactions, and state transitions fall under attacker control

**Cascading Permanent Control:**
The most severe aspect is that malicious miners controlling term N can simply repeat the attack to control term N+1, N+2, and so on indefinitely. There is no recovery mechanism because the malicious miners control consensus and can prevent any corrective transactions from being included in blocks. Even if honest miners win future elections, they can be perpetually excluded from actual consensus participation.

**Network-Wide Impact:**
- Entire blockchain security model compromised
- Liveness guarantees broken (honest transactions can be censored)
- Smart contract execution integrity compromised
- Cross-chain bridge security affected (consensus controls cross-chain data)
- Economic value of the token destroyed (governance is fundamental to token value proposition)

## Likelihood Explanation

**Attack Prerequisites Are Realistic:**

1. **Attacker must be a current miner:** This is achievable through normal election processes. An attacker could accumulate votes or the vulnerability could be exploited by any existing miner who turns malicious.

2. **Attacker must become extra block producer at term boundary:** The extra block producer role rotates among all miners. Every miner in the current set will eventually get this role when term transition is needed. The scheduling is deterministic based on consensus rules.

3. **Attacker must control their node software:** Miners inherently control their own node software and consensus transaction generation logic. This is not a privilege escalation - it's the normal operation mode for a miner.

**Execution Is Trivial:**
- Attack requires crafting a single malicious NextTerm transaction
- No complex timing, race conditions, or state manipulation needed
- No economic cost beyond normal block production
- The malicious transaction structure is identical to legitimate ones (cannot be detected by structure alone)

**Detection Is Extremely Difficult:**
- No on-chain validation failures occur during the attack
- The malicious NextTerm transaction passes all existing validation checks
- Off-chain observers would need to independently query `GetVictories()` and manually compare against the executed miner list to detect the attack
- By the time detection occurs, malicious miners already control consensus and can prevent any remediation

**Barriers to Exploitation: NONE**
There are no cryptographic, economic, or technical barriers preventing this attack once a malicious miner becomes the extra block producer at a term boundary.

## Recommendation

Implement strict validation that enforces miners in NextTerm transactions must match Election contract results:

1. **Add Election Validation Provider:**
Create a new `ElectionResultValidationProvider` that:
   - Queries `State.ElectionContract.GetVictories()`  
   - Compares the result against miners in `extraData.Round.RealTimeMinersInformation`
   - Returns validation failure if they don't match exactly

2. **Integrate into Validation Pipeline:**
Add this provider to the validation list in `ValidateBeforeExecution` for NextTerm behavior:

```
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new ElectionResultValidationProvider());  // NEW
    break;
```

3. **Double-Check During Execution:**
As defense-in-depth, add validation in `ProcessNextTerm` before calling `SetMinerList`:

```
// Validate miners match election results
var victories = State.ElectionContract.GetVictories.Call(new Empty());
var expectedMiners = victories.Pubkeys.Select(p => p.ToHex()).OrderBy(m => m).ToList();
var actualMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(m => m).ToList();
Assert(expectedMiners.SequenceEqual(actualMiners), "Miners do not match election results.");
```

This ensures that the democratic election process is cryptographically enforced at the consensus protocol level, making it impossible for any single miner to bypass election results.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanInjectArbitraryMinersInNextTerm()
{
    // Setup: Initialize consensus with legitimate miners from election
    var legitimateMiners = await InitializeConsensusWithElection();
    var maliciousMiner = legitimateMiners.First();
    
    // Advance to term boundary where maliciousMiner is extra block producer
    await AdvanceToTermBoundary(maliciousMiner);
    
    // Attack: Craft malicious Round with arbitrary miners (not from election)
    var attackerChosenMiners = new[] { 
        "AttackerPubkey1", 
        "AttackerPubkey2", 
        "AttackerPubkey3" 
    };
    var maliciousRound = CreateRoundWithArbitraryMiners(attackerChosenMiners);
    var maliciousInput = NextTermInput.Create(maliciousRound, GenerateRandomNumber());
    
    // Execute malicious NextTerm transaction
    var result = await AEDPoSContract.NextTerm.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Should FAIL but passes
    
    // Verify: Arbitrary miners are now installed (vulnerability confirmed)
    var currentMiners = await AEDPoSContract.GetCurrentMinerList.CallAsync(new Empty());
    currentMiners.Pubkeys.Select(p => p.ToHex()).ShouldBe(attackerChosenMiners);
    
    // Verify legitimate election winners are excluded
    var electionWinners = await ElectionContract.GetVictories.CallAsync(new Empty());
    currentMiners.Pubkeys.ShouldNotBe(electionWinners.Value); // Election results ignored!
}
```

This test demonstrates that a malicious miner can successfully install arbitrary miners by crafting a NextTerm transaction, completely bypassing the election contract's GetVictories() results. The vulnerability is confirmed when the test shows that miners who did not win the election are installed as consensus participants for the next term.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-209)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L274-274)
```csharp
        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L12-12)
```csharp
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L44-44)
```csharp
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L72-79)
```csharp
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }
```
