# Audit Report

## Title
Zero Virtual Balance in AddPairConnector Causes Permanent Connector Failure

## Summary
The `AddPairConnector()` function does not validate that `NativeVirtualBalance` is greater than zero, allowing creation of deposit connectors with zero virtual balance. When combined with tokens having low circulation, `EnableConnector()` can succeed with zero deposit, resulting in a connector with both zero virtual and deposit balances. This causes all subsequent `Buy()` and `Sell()` operations to fail permanently with `InvalidValueException`, as `UpdateConnector()` cannot fix enabled connectors. [1](#0-0) 

## Finding Description

The TokenConverter contract implements a Bancor-based token exchange mechanism where each trading pair consists of a resource connector and a deposit connector. The vulnerability stems from insufficient validation in the connector creation and enabling flow.

**Step 1: Unvalidated Connector Creation**

The `AddPairConnector()` method creates a deposit connector without validating the `NativeVirtualBalance` parameter. The method directly assigns `VirtualBalance = input.NativeVirtualBalance` without checking if it's positive, only validating the weight parameter through `AssertValidConnectorWeight()`. [1](#0-0) [2](#0-1) 

**Step 2: Zero Deposit Enablement**

When `EnableConnector()` is invoked, it calculates the required deposit via `GetNeededDeposit()`. If `amountOutOfTokenConvert <= 0` (meaning all tokens are already in the contract or being converted), the BancorHelper calculation is skipped and `needDeposit` remains zero. [3](#0-2) 

This allows `EnableConnector()` to succeed with zero deposit, setting `State.DepositBalance[toConnector.Symbol] = 0` and marking both connectors as enabled. [4](#0-3) 

**Step 3: Permanent Buy/Sell Failure**

When `Buy()` or `Sell()` operations are invoked, they call `GetSelfBalance()` for both connectors. For a deposit connector with `VirtualBalance = 0` and `DepositBalance = 0`, this returns `0 + 0 = 0`. [5](#0-4) [6](#0-5) 

This zero balance is then passed to BancorHelper methods, which explicitly validate against zero balances and throw `InvalidValueException`. [7](#0-6) [8](#0-7) 

**Step 4: No Recovery Mechanism**

The `UpdateConnector()` method explicitly prevents updating activated connectors, leaving the connector permanently broken. [9](#0-8) 

## Impact Explanation

This vulnerability causes **critical denial of service** with the following impacts:

1. **Permanent Operational Failure**: All `Buy()` and `Sell()` operations for the affected connector pair permanently fail with "Connector balance needs to be a positive number". Users cannot convert between the resource token and base token.

2. **No Recovery Path**: The connector cannot be disabled or updated after activation. The only recovery mechanism is a full contract upgrade, which is a complex governance operation requiring significant time and coordination.

3. **Liquidity Lockup**: Any tokens already held by the converter contract for this pair become effectively locked, as trading cannot occur. This impacts protocol liquidity and user funds.

4. **Protocol Integrity Violation**: The connector becomes dead code that cannot fulfill its intended Bancor pricing mechanism, violating the core invariant that enabled connectors should support trading.

The severity is **CRITICAL** because the failure is permanent and irreversible without contract upgrade, affects core protocol functionality, can occur through honest admin configuration error, and has no emergency recovery mechanism.

## Likelihood Explanation

The vulnerability has **HIGH likelihood** of occurrence:

1. **Reachable Entry Point**: `AddPairConnector()` is accessible to the connector controller (governance/Parliament by default), making it a legitimate administrative operation.

2. **Feasible Preconditions**:
   - Admin mistakenly sets `NativeVirtualBalance = 0` during connector creation
   - Token has low or zero circulation outside the converter contract
   - `EnableConnector()` is called with sufficient `AmountToTokenConvert`

3. **Lack of Safeguards**: No validation warnings or checks during connector creation. The `UpdateConnector()` method has a conditional check for `VirtualBalance > 0` when updating deposit accounts, suggesting positive values are expected, but this validation is absent in `AddPairConnector()`. [10](#0-9) 

4. **Detection Difficulty**: The issue only manifests after enabling, not during creation. An administrator could successfully create and enable the connector, only discovering the problem when users attempt to trade.

5. **Realistic Scenario**: This represents a genuine configuration error scenario that could occur during routine administrative operations, rather than requiring malicious intent.

## Recommendation

Add validation in `AddPairConnector()` to ensure `NativeVirtualBalance` is greater than zero for deposit connectors:

```csharp
public override Empty AddPairConnector(PairConnectorParam input)
{
    AssertPerformedByConnectorController();
    Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
        "resource token symbol should not be empty");
    Assert(input.NativeVirtualBalance > 0, 
        "Native virtual balance must be greater than zero");
    // ... rest of the method
}
```

Additionally, consider adding validation in `EnableConnector()` to prevent enabling connectors with zero total balance:

```csharp
var totalBalance = GetSelfBalance(toConnector);
Assert(totalBalance > 0, "Connector balance must be positive before enabling");
```

## Proof of Concept

```csharp
[Fact]
public async Task AddPairConnector_ZeroVirtualBalance_CausesPermanentFailure()
{
    // Step 1: Create connector with zero virtual balance
    var tokenSymbol = "TEST";
    await CreateTokenAsync(tokenSymbol);
    
    var pairConnector = new PairConnectorParam
    {
        ResourceConnectorSymbol = tokenSymbol,
        ResourceWeight = "0.5",
        NativeWeight = "0.5",
        NativeVirtualBalance = 0  // Zero virtual balance
    };
    
    await ExecuteProposalForParliamentTransaction(
        TokenConverterContractAddress,
        nameof(TokenConverterContractImplContainer.TokenConverterContractImplStub.AddPairConnector),
        pairConnector);
    
    // Step 2: Enable connector with zero deposit (all tokens in contract)
    var totalSupply = 1000000;
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = TokenConverterContractAddress,
        Symbol = tokenSymbol,
        Amount = totalSupply
    });
    
    await ExecuteProposalForParliamentTransaction(
        TokenConverterContractAddress,
        nameof(TokenConverterContractImplContainer.TokenConverterContractImplStub.EnableConnector),
        new ToBeConnectedTokenInfo
        {
            TokenSymbol = tokenSymbol,
            AmountToTokenConvert = totalSupply
        });
    
    // Step 3: Verify Buy operation fails permanently
    var buyException = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await DefaultStub.Buy.SendAsync(new BuyInput
        {
            Symbol = tokenSymbol,
            Amount = 100,
            PayLimit = 1000000
        });
    });
    
    Assert.Contains("Connector balance needs to be a positive number", 
        buyException.Message);
    
    // Step 4: Verify UpdateConnector cannot fix the issue
    var updateException = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await ExecuteProposalForParliamentTransaction(
            TokenConverterContractAddress,
            nameof(TokenConverterContractImplContainer.TokenConverterContractImplStub.UpdateConnector),
            new Connector
            {
                Symbol = tokenSymbol,
                VirtualBalance = 1000000
            });
    });
    
    Assert.Contains("connector can not be updated because it has been activated", 
        updateException.Message);
}
```

## Notes

This vulnerability demonstrates a critical gap in input validation that can lead to permanent denial of service. The issue arises from the interaction between three contract methods (`AddPairConnector`, `GetNeededDeposit`, and `EnableConnector`) where each individually appears correct, but together allow an invalid state. The permanent nature of the issue (no recovery mechanism except contract upgrade) makes this particularly severe. The vulnerability affects the core TokenConverter functionality and could realistically occur through administrative configuration errors during routine operations.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L96-109)
```csharp
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L276-300)
```csharp
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-84)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-40)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-73)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");
```
