# Audit Report

## Title
Scheme Overwriting Causes Permanent Token Lock Due to Symbol Mismatch

## Summary
When a manager calls `CreateScheme` multiple times, the new scheme overwrites the previous one but existing user lock records persist with the old scheme's token symbol. Users cannot withdraw their locked tokens because the `Withdraw` function queries locked amounts using the new scheme's symbol with the old lock ID, returning zero balance and leaving original tokens permanently locked.

## Finding Description

The TokenHolder contract allows managers to create profit schemes by calling `CreateScheme`, which stores scheme metadata including the token symbol at `State.TokenHolderProfitSchemes[Context.Sender]`. [1](#0-0) 

However, this method lacks validation to prevent multiple calls by the same manager, allowing the scheme data to be overwritten. [2](#0-1) 

When users register for profits via `RegisterForProfits`, their tokens are locked using the scheme's current symbol, and a deterministic lock ID is generated based solely on the manager and user addresses (not the symbol). [3](#0-2) 

The MultiToken contract's `Lock` method transfers tokens to a virtual address computed from Context.Sender, the user address, and the lock ID - notably, this virtual address does NOT depend on the token symbol. [4](#0-3) 

When the manager later calls `CreateScheme` again with a different symbol, it overwrites the scheme metadata but leaves the lock ID mappings intact. Subsequently, when users attempt to withdraw via the `Withdraw` method, it retrieves the NEW scheme with the NEW symbol. [5](#0-4) 

The critical flaw occurs in `GetLockedAmount`, which queries the token balance at the virtual address for the specified symbol. [6](#0-5)  Since the tokens were locked with the OLD symbol but the query uses the NEW symbol, it returns zero even though the original tokens remain at the virtual address.

The `Unlock` operation then proceeds with zero amount, leaving the original tokens permanently locked. [7](#0-6) 

## Impact Explanation

This vulnerability results in HIGH severity impact because:

1. **Permanent Fund Loss**: Users lose access to all their locked tokens with no recovery mechanism. Once `Withdraw` executes, it removes the lock ID mapping (`State.LockIds[input].Remove(Context.Sender)`), preventing any future withdrawal attempts or re-registration.

2. **Wide Scope**: All users who registered under the original scheme are affected simultaneously when the manager overwrites it. For staking schemes, this can involve substantial amounts per user.

3. **No Administrative Recovery**: The tokens remain locked at a virtual address computed from the lock ID, but with the wrong symbol mapping. There is no admin function to recover these funds, and the lock ID mapping has been deleted.

4. **User Helplessness**: Users have no way to detect this issue before attempting withdrawal, and cannot prevent the manager from overwriting the scheme after they've already locked their tokens.

## Likelihood Explanation

This vulnerability has HIGH likelihood because:

1. **Public Accessibility**: The `CreateScheme` method is publicly accessible to any address without special privileges. [8](#0-7) 

2. **Simple Trigger Path**: Exploitation requires only two standard contract calls by the manager - no complex state manipulation or timing requirements.

3. **Realistic Scenarios**:
   - **Accidental**: A manager may legitimately want to "update" scheme parameters and call `CreateScheme` again, unaware it will lock user funds
   - **Malicious**: A manager can intentionally trap user funds by changing the symbol after users have registered

4. **No Validation**: There are no checks preventing duplicate `CreateScheme` calls or validating symbol consistency during withdrawal. The only check in `RegisterForProfits` prevents duplicate registrations by the same user, which doesn't help after the first registration. [9](#0-8) 

## Recommendation

Add validation in `CreateScheme` to prevent overwriting existing schemes:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists. Cannot overwrite existing scheme.");
    
    // ... existing implementation
}
```

Alternatively, if scheme updates are intended functionality, implement a proper update mechanism that:
1. Checks if existing users have locked tokens
2. Either prevents updates when locks exist, or
3. Maintains backward compatibility by storing symbol per lock ID rather than per scheme

## Proof of Concept

The vulnerability can be demonstrated with the following test sequence:

```csharp
// Step 1: Manager creates initial scheme with ELF
TokenHolderContract.CreateScheme(new CreateTokenHolderProfitSchemeInput {
    Symbol = "ELF",
    MinimumLockMinutes = 1000
});

// Step 2: User registers and locks 10,000 ELF tokens
TokenHolderContract.RegisterForProfits(new RegisterForProfitsInput {
    SchemeManager = managerAddress,
    Amount = 10000
});

// Step 3: Manager overwrites scheme with USDT symbol
TokenHolderContract.CreateScheme(new CreateTokenHolderProfitSchemeInput {
    Symbol = "USDT",
    MinimumLockMinutes = 10
});

// Step 4: User attempts withdrawal after lock period
// Expected: Withdraw 10,000 ELF
// Actual: Withdraws 0 tokens, original 10,000 ELF remains locked forever
TokenHolderContract.Withdraw(managerAddress);

// Verification: Check that user's ELF balance did not increase
// and tokens remain locked at the virtual address
```

The test would demonstrate that after step 4, the user's ELF balance remains unchanged and the 10,000 ELF tokens are permanently inaccessible at the computed virtual address.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L151-151)
```csharp
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-166)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-225)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L230-238)
```csharp
        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-212)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L104-114)
```csharp
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
```
