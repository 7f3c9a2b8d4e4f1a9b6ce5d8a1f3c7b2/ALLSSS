# Audit Report

## Title
Insufficient Time Slot Overlap Validation Allows Consensus Disruption Through Miner Schedule Collision

## Summary
The `CheckRoundTimeSlots()` validation method contains a flawed comparison operator (`>` instead of `>=`) that fails to detect when consecutive miners beyond the first pair have identical `ExpectedMiningTime` values. A Byzantine miner can exploit this to submit malicious `NextRound` consensus data with overlapping time slots, causing consensus disruption through miner schedule collisions.

## Finding Description

The vulnerability exists in the time slot validation logic that validates round information before block execution. When a new round is proposed, `TimeSlotValidationProvider` invokes `CheckRoundTimeSlots()` to validate proper time slot spacing: [1](#0-0) 

The `CheckRoundTimeSlots()` method is designed to ensure all miners have properly spaced time slots. The method documentation explicitly states this requirement: [2](#0-1) 

While the method correctly validates the first two miners, the subsequent validation loop contains a critical flaw: [3](#0-2) 

**Root Cause**: The comparison at line 53 uses `Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval`, which only rejects intervals that differ by MORE than `baseMiningInterval`. When two consecutive miners have identical `ExpectedMiningTime` values (i.e., `miningInterval = 0`), the mathematical evaluation is:
- `Math.Abs(0 - baseMiningInterval) = baseMiningInterval`
- Check: `baseMiningInterval > baseMiningInterval` = `false`
- Validation incorrectly passes

The check at lines 46-47 correctly catches overlaps between miners at positions 0 and 1, but the flawed operator at line 53 allows overlaps in all subsequent consecutive miner pairs.

When malicious round data passes validation, it is stored in state without further checks: [4](#0-3) 

Normal round generation properly spaces miners by calculating unique `ExpectedMiningTime` values based on order and mining interval: [5](#0-4) 

However, a Byzantine miner producing the `NextRound` block can modify the consensus extra data before block production. The only validation on consensus extra data is that `SenderPubkey` matches `SignerPubkey`: [6](#0-5) 

Since the miner controls both the signing key and the consensus extra data content, they can modify the `Round` object's `ExpectedMiningTime` values while maintaining this check.

## Impact Explanation

This vulnerability directly violates the critical consensus invariant that each miner must have an exclusive, non-overlapping time slot for block production. When multiple miners have overlapping `ExpectedMiningTime` values, the `IsCurrentMiner` check will return true for multiple miners simultaneously: [7](#0-6) 

This causes:
- **Time slot collision**: Multiple miners believe they can produce blocks at the same timestamp
- **Fork risk**: Miners produce competing blocks simultaneously at the same height
- **Block production disruption**: Conflicting schedules cause missed slots and timing conflicts
- **Consensus degradation**: Network throughput decreases as miners compete for same slots
- **Schedule integrity violation**: The fundamental time-ordering assumption is broken

The entire network is affected because the consensus mechanism depends on strict time-ordered block production. This is a **consensus integrity break** with network-wide impact.

## Likelihood Explanation

**Attacker Profile**: A Byzantine authorized miner (block producer) who controls their node software and is scheduled to produce a `NextRound` block (the extra block that transitions rounds).

**Attack Execution**:
1. Malicious miner waits for their turn to produce the extra block
2. Node calls `GetConsensusExtraDataForNextRound()` to generate next round information
3. Attacker modifies the returned `Round` object's `ExpectedMiningTime` values before embedding in block header
4. Sets `ExpectedMiningTime` for miners at positions 2 and 3 (or any subsequent pair) to be identical
5. Maintains proper spacing between miners 0 and 1 to pass the initial check
6. Submits block with malicious consensus data
7. Validation passes due to flawed `>` operator
8. Corrupted round information is committed to state

**Feasibility**: HIGH - Requires only one compromised miner who produces a `NextRound` block. No special economic resources needed beyond normal block production. Detection may occur when affected miners attempt to mine, but by then the corrupted round data is already in state. No other validation checks prevent this attack.

## Recommendation

Change the comparison operator at line 53 from `>` to `>=` to properly detect when consecutive miners have identical or overlapping time slots:

```csharp
// Change line 53 from:
if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)

// To:
if (Math.Abs(miningInterval - baseMiningInterval) >= baseMiningInterval)
```

Alternatively, add an explicit zero-check:
```csharp
if (miningInterval <= 0 || Math.Abs(miningInterval - baseMiningInterval) >= baseMiningInterval)
    return new ValidationResult { Message = "Time slots are so different or overlapping." };
```

This ensures that when `miningInterval = 0` (identical timestamps), the check evaluates to `true` and validation correctly fails.

## Proof of Concept

```csharp
[Fact]
public async Task TimeSlotOverlapBypassTest()
{
    // Setup: Get current round and create malicious next round
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var maliciousRound = new Round
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber
    };
    
    // Create miners with overlapping time slots at positions 2 and 3
    var currentTime = TimestampHelper.GetUtcNow();
    var miningInterval = 4000;
    
    maliciousRound.RealTimeMinersInformation.Add("miner1", new MinerInRound
    {
        Pubkey = "miner1",
        Order = 1,
        ExpectedMiningTime = currentTime.AddMilliseconds(miningInterval)
    });
    
    maliciousRound.RealTimeMinersInformation.Add("miner2", new MinerInRound
    {
        Pubkey = "miner2",
        Order = 2,
        ExpectedMiningTime = currentTime.AddMilliseconds(miningInterval * 2)
    });
    
    // MALICIOUS: Set positions 3 and 4 to have IDENTICAL ExpectedMiningTime
    var overlappingTime = currentTime.AddMilliseconds(miningInterval * 3);
    maliciousRound.RealTimeMinersInformation.Add("miner3", new MinerInRound
    {
        Pubkey = "miner3",
        Order = 3,
        ExpectedMiningTime = overlappingTime
    });
    
    maliciousRound.RealTimeMinersInformation.Add("miner4", new MinerInRound
    {
        Pubkey = "miner4",
        Order = 4,
        ExpectedMiningTime = overlappingTime // SAME TIME AS MINER3
    });
    
    // Validate: This should FAIL but will PASS due to > instead of >=
    var validationResult = maliciousRound.CheckRoundTimeSlots();
    
    // Assertion: Validation incorrectly passes
    Assert.True(validationResult.Success); // This demonstrates the vulnerability
    // Expected: validationResult.Success should be FALSE
}
```

## Notes

The vulnerability is mathematically proven: when `miningInterval = 0`, the expression `baseMiningInterval > baseMiningInterval` always evaluates to `false`, allowing overlapping time slots to pass validation. The fix is straightforwardâ€”changing `>` to `>=` at line 53 will properly catch all cases where consecutive miners have identical or improperly spaced timestamps.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L28-31)
```csharp
    /// <summary>
    ///     Check the equality of time slots of miners.
    ///     Also, the mining interval shouldn't be 0.
    /// </summary>
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-55)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L29-32)
```csharp
        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L162-167)
```csharp
        if (timeSlotStartTime <= Context.CurrentBlockTime && Context.CurrentBlockTime <=
            timeSlotStartTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]NORMAL");
            return true;
        }
```
