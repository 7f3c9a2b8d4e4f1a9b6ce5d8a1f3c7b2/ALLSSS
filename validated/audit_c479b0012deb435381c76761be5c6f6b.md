# Audit Report

## Title
Side Chain Term Number State Inconsistency Due to Missing NextTerm Processing

## Summary
Side chains fail to properly update their term number state when miner lists change. While round data contains incremented term numbers, the global `State.CurrentTermNumber.Value` remains stale because side chains always use `NextRound` behavior instead of `NextTerm`, causing critical state variables to become inconsistent with actual round data.

## Finding Description

The vulnerability stems from an architectural mismatch in how main chains and side chains handle term transitions.

**Main chains** conditionally return `NextTerm` or `NextRound` behavior based on whether a term change is needed [1](#0-0) , checking `NeedToChangeTerm` to determine if a term transition should occur.

**Side chains** unconditionally return `NextRound` behavior with no term change logic [2](#0-1) .

When a side chain's miner list changes (synchronized from main chain via cross-chain communication), the system detects this change [3](#0-2)  and generates a "first round of new term" with incremented term number [4](#0-3) .

This generation method explicitly increments the term number [5](#0-4) .

The incremented term number is copied into the `NextRoundInput` [6](#0-5) , and because the side chain behavior provider returns `NextRound`, a transaction is generated calling the `NextRound` method [7](#0-6) .

**Critical Issue**: `ProcessNextRound` only updates round information and round number, but never calls `TryToUpdateTermNumber` [8](#0-7) .

In contrast, `ProcessNextTerm` explicitly updates the term number state by calling `TryToUpdateTermNumber` [9](#0-8)  and sets critical mappings like `State.MinerListMap` and `State.FirstRoundNumberOfEachTerm` [10](#0-9) . Additionally, it resets miner statistics [11](#0-10) .

The `TryToUpdateTermNumber` method updates `State.CurrentTermNumber.Value` [12](#0-11) , which is the global term number state.

## Impact Explanation

This vulnerability creates multiple state inconsistencies on all side chains:

1. **Term Number Mismatch**: External callers querying the current term number receive stale values [13](#0-12) .

2. **Validation Context Corruption**: Consensus validation uses the incorrect term number from state instead of the actual term number in round data [14](#0-13) .

3. **Missing Historical Mappings**: Queries for miner lists by term number [15](#0-14)  and first round numbers of each term [16](#0-15)  fail because `State.MinerListMap[N+1]` and `State.FirstRoundNumberOfEachTerm[N+1]` are never populated for the new term.

4. **Miner Statistics Not Reset**: Unlike `ProcessNextTerm` which resets statistics for fairness, `ProcessNextRound` allows new miners to inherit stale `MissedTimeSlots` and `ProducedBlocks` values, causing incorrect performance tracking.

**Severity: Medium** - This breaks protocol correctness and state integrity but does not directly enable fund theft or halt block production. It affects cross-contract data consistency and fairness of miner performance tracking on all side chains.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is automatically triggered through normal protocol operation. When main chain miner lists change through elections, the cross-chain contract synchronizes this information to side chains [17](#0-16) , which updates `State.MainChainCurrentMinerList.Value`.

This requires no attacker actionâ€”it's inherent to how AElf side chains operate. Every time the main chain conducts an election that changes the miner list, all connected side chains experience this state inconsistency. The issue is deterministic and reproducible.

## Recommendation

Modify the side chain behavior to properly handle term transitions when miner lists change. There are two potential approaches:

**Option 1**: Make `SideChainConsensusBehaviourProvider` conditionally return `NextTerm` when miner list changes are detected, similar to the main chain logic.

**Option 2**: Update `ProcessNextRound` to check if the incoming round has `IsMinerListJustChanged = true` and an incremented term number, and if so, call `TryToUpdateTermNumber`, populate the term mappings, and reset miner statistics.

The recommended fix is Option 1 for consistency with main chain behavior:

```csharp
protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
{
    // Check if miner list is about to change by comparing with main chain miner list
    var isMainChainMinerListChanged = State.MainChainCurrentMinerList.Value.Pubkeys.Any() &&
        GetMinerListHash(CurrentRound.RealTimeMinersInformation.Keys) !=
        GetMinerListHash(State.MainChainCurrentMinerList.Value.Pubkeys.Select(p => p.ToHex()));
    
    return isMainChainMinerListChanged 
        ? AElfConsensusBehaviour.NextTerm 
        : AElfConsensusBehaviour.NextRound;
}
```

## Proof of Concept

A test demonstrating the vulnerability would:
1. Initialize a side chain with initial miners
2. Update the main chain miner list via `UpdateInformationFromCrossChain`
3. Trigger the next round consensus
4. Verify that `GetCurrentTermNumber` returns the old term number (stale state)
5. Verify that round data contains the new term number (inconsistency)
6. Verify that `GetMinerList` for the new term returns empty (missing mapping)
7. Verify that miner statistics were not reset

This demonstrates the state inconsistency between round data and global state variables on side chains when miner lists change.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L16-23)
```csharp
        /// <summary>
        ///     Simply return NEXT_ROUND for side chain.
        /// </summary>
        /// <returns></returns>
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L66-69)
```csharp
    public override MinerList GetMinerList(GetMinerListInput input)
    {
        return State.MinerListMap[input.TermNumber] ?? new MinerList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L71-81)
```csharp
    public override Int64Value GetMinedBlocksOfPreviousTerm(Empty input)
    {
        if (TryToGetTermNumber(out var termNumber))
        {
            var targetRound = State.FirstRoundNumberOfEachTerm[termNumber].Sub(1);
            if (TryToGetRoundInformation(targetRound, out var round))
                return new Int64Value { Value = round.GetMinedBlocks() };
        }

        return new Int64Value();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-294)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L349-354)
```csharp
    private bool IsMainChainMinerListChanged(Round currentRound)
    {
        return State.MainChainCurrentMinerList.Value.Pubkeys.Any() &&
               GetMinerListHash(currentRound.RealTimeMinersInformation.Keys) !=
               GetMinerListHash(State.MainChainCurrentMinerList.Value.Pubkeys.Select(p => p.ToHex()));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L362-365)
```csharp
    public override Int64Value GetCurrentTermNumber(Empty input)
    {
        return new Int64Value { Value = State.CurrentTermNumber.Value };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L40-42)
```csharp
        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-22)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L164-171)
```csharp
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-174)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L178-183)
```csharp
        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-193)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L98-105)
```csharp
    private bool TryToUpdateTermNumber(long termNumber)
    {
        var oldTermNumber = State.CurrentTermNumber.Value;
        if (termNumber != 1 && oldTermNumber + 1 != termNumber) return false;

        State.CurrentTermNumber.Value = termNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-64)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
    }
```
