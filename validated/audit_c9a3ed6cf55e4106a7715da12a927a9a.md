# Audit Report

## Title
Incorrect Threshold Check in Secret Sharing Reconstruction Defeats Byzantine Fault Tolerance

## Summary
The AEDPoS consensus contract's secret sharing reconstruction logic incorrectly requires 100% of miners to provide decrypted pieces before attempting reconstruction, contradicting the 2/3 threshold defined by Shamir's Secret Sharing algorithm. This design flaw allows a single malicious miner to prevent forced revelation of their InValue by providing incomplete encrypted pieces, breaking the commit-reveal scheme's security guarantees and enabling manipulation of consensus randomness and mining order.

## Finding Description

The vulnerability exists in the `RevealSharedInValues` method where secret reconstruction is performed. The system correctly calculates a 2/3 threshold (`minimumCount`) for Shamir's Secret Sharing: [1](#0-0) 

However, the validation logic incorrectly requires ALL miners' decrypted pieces (100%) before attempting reconstruction: [2](#0-1) 

Despite this strict check, the actual secret reconstruction correctly uses only the 2/3 threshold: [3](#0-2) 

**Root Cause:** The check requires `DecryptedPieces.Count >= minersCount` instead of `DecryptedPieces.Count >= minimumCount`, contradicting Shamir's Secret Sharing mathematical properties which only require the threshold (2/3) for reconstruction.

**Why Protections Fail:**

1. **No EncryptedPieces Validation:** When miners submit their UpdateValue transactions, encrypted pieces are added without any completeness validation: [4](#0-3) 

2. **Empty PreviousInValue Allowed:** The UpdateValue validation explicitly permits `PreviousInValue = Hash.Empty`, bypassing forced revelation: [5](#0-4) 

3. **No Secret Sharing Enforcement:** Evil miner detection only tracks missed time slots based on OutValue being null, not secret sharing participation: [6](#0-5) 

The missed time slots counter is only incremented when OutValue is null: [7](#0-6) 

**Attack Execution Path:**
1. **Round N:** Malicious miner produces their block via UpdateValue, but provides incomplete EncryptedPieces (e.g., encrypting pieces for only 2/3 of miners instead of all)
2. **Round N+1:** Only miners who received encrypted pieces can successfully decrypt and submit DecryptedPieces for the malicious miner
3. **Round N+1:** When `RevealSharedInValues` executes, the malicious miner's `DecryptedPieces.Count` is only 2/3 (below `minersCount`)
4. **Round N+1:** Secret reconstruction is skipped due to the incorrect 100% threshold check, even though 2/3 is mathematically sufficient
5. **Consequence:** The malicious miner's InValue remains unrevealed, allowing them to selectively reveal or withhold it based on whether the resulting signature/mining order is favorable

## Impact Explanation

**HIGH Severity - Consensus Integrity Breach**

The vulnerability breaks the forced-reveal property of the secret sharing scheme, which is fundamental to ensuring fair and unpredictable consensus randomness.

**Concrete Harm:**

1. **Mining Order Manipulation:** The signature value determines the mining order for the next round. The signature is calculated from PreviousInValue: [8](#0-7) 

This signature then determines the mining order through modulo arithmetic: [9](#0-8) 

Without forced revelation, a malicious miner can selectively choose whether to reveal their InValue based on whether the resulting mining order benefits them, breaking the commit-reveal scheme's unpredictability guarantee.

2. **Byzantine Fault Tolerance Defeated:** Shamir's Secret Sharing is explicitly designed to tolerate up to 1/3 Byzantine (malicious) miners by requiring only a 2/3 threshold for reconstruction. The incorrect 100% check effectively reduces the Byzantine tolerance to 0%, requiring all miners to be honest.

3. **Network-Wide Impact:** All network participants suffer from compromised consensus fairness, as the malicious miner gains unfair advantages in block production scheduling and rewards distribution.

## Likelihood Explanation

**HIGH Likelihood**

**Attacker Capabilities:** Any miner in the active validator set can execute this attack. No special privileges beyond being a validator are required.

**Attack Complexity:** LOW
- The attacker simply provides incomplete EncryptedPieces in their UpdateValue transaction
- No complex cryptographic manipulation or precise timing requirements
- The attack is undetectable at validation time since EncryptedPieces completeness is not checked during processing

**Feasibility Conditions:**
1. Attacker is an active miner (realistic precondition in any DPoS system)
2. Secret sharing is enabled, which is the standard operational mode for maintaining consensus randomness

**Detection Difficulty:** The attack is extremely difficult to detect because:
- Off-chain nodes cannot distinguish between network-delayed pieces and deliberately withheld pieces
- No on-chain slashing mechanism exists for incomplete secret sharing participation
- The only on-chain penalty mechanism tracks missed time slots (when OutValue is null), not secret sharing non-participation

**Probability:** The attack is straightforward to execute, provides concrete economic benefits through mining order manipulation, and carries minimal risk of detection or punishment.

## Recommendation

Change line 36 in `AEDPoSContract_SecretSharing.cs` to use the correct 2/3 threshold instead of requiring 100%:

**Current code:**
```csharp
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**Fixed code:**
```csharp
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

This change aligns the validation logic with Shamir's Secret Sharing mathematical properties and restores the intended Byzantine fault tolerance of up to 1/3 malicious miners.

Additionally, consider adding validation during `UpdateValue` processing to ensure miners provide encrypted pieces for all other miners, and implement slashing for miners who consistently fail to provide complete encrypted pieces.

## Proof of Concept

The following test demonstrates that with only 2/3 of shares (the mathematically sufficient threshold), secret reconstruction is possible, but the current code incorrectly blocks it:

```csharp
[Fact]
public void Test_IncorrectThresholdBlocksValidReconstruction()
{
    // Setup: 5 miners, 2/3 threshold = 3
    var minersCount = 5;
    var minimumCount = minersCount * 2 / 3; // = 3
    
    // Malicious miner provides encrypted pieces to only 3 out of 5 miners
    var maliciousMiner = new MinerInRound
    {
        Pubkey = "malicious",
        DecryptedPieces = { } // Only 3 pieces collected
    };
    
    // Add 3 decrypted pieces (sufficient for reconstruction per Shamir's algorithm)
    for (int i = 0; i < minimumCount; i++)
    {
        maliciousMiner.DecryptedPieces.Add($"miner{i}", ByteString.CopyFrom(new byte[] { (byte)i }));
    }
    
    // Current buggy check: DecryptedPieces.Count < minersCount
    // 3 < 5 = true, so reconstruction is SKIPPED (WRONG!)
    maliciousMiner.DecryptedPieces.Count.ShouldBe(3);
    (maliciousMiner.DecryptedPieces.Count < minersCount).ShouldBeTrue(); // Bug: blocks reconstruction
    
    // Correct check should be: DecryptedPieces.Count < minimumCount
    // 3 < 3 = false, so reconstruction should PROCEED (CORRECT!)
    (maliciousMiner.DecryptedPieces.Count >= minimumCount).ShouldBeTrue(); // This is sufficient!
    
    // The bug allows the malicious miner to prevent forced revelation
    // by providing incomplete pieces, breaking consensus security
}
```

**Notes**

This vulnerability fundamentally undermines the security guarantees of the AEDPoS consensus mechanism. The incorrect threshold check transforms what should be a Byzantine fault-tolerant secret sharing scheme (tolerating up to 1/3 malicious actors) into one that requires 100% honest participation. A single malicious miner can exploit this to gain unfair advantages in block production scheduling without any on-chain penalty, compromising the fairness and unpredictability that are essential properties of the consensus system.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L22-23)
```csharp
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L290-290)
```csharp
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L92-93)
```csharp
            if (minerInRound.Value.OutValue == null)
                minerInRound.Value.MissedTimeSlots = minerInRound.Value.MissedTimeSlots.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
