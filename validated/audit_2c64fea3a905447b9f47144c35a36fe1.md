# Audit Report

## Title
Vote ID Collision Causing Permanent Denial of Service for Specific Candidate Vote Counts

## Summary
The Election contract's vote ID generation mechanism uses a candidate's current active vote count to create deterministic vote IDs. When votes are withdrawn, the `LockTimeMap` entries are never cleaned up, causing vote count values to become permanently "poisoned." Future votes that generate the same ID will fail the collision check, resulting in permanent denial of service for legitimate voters.

## Finding Description

The vulnerability exists in the interaction between vote ID generation, collision detection, and withdrawal cleanup in the Election contract.

**Vote ID Generation:**
When the optional `Token` field is not provided in `VoteMinerInput` (the standard usage pattern as shown in test helpers), the `GenerateVoteId()` function generates vote IDs deterministically by hashing the contract address, candidate's public key, and the candidate's current `ObtainedActiveVotedVotesAmount`. [1](#0-0) 

**Vote Collision Detection:**
The `Vote()` function generates a vote ID and asserts that no vote with this ID already exists by checking if `State.LockTimeMap[voteId] == 0`. If the check passes, it stores the lock time in the map. [2](#0-1) 

**Missing Cleanup on Withdrawal:**
The `Withdraw()` function decreases the candidate's `ObtainedActiveVotedVotesAmount`, allowing the vote count to return to previous values. [3](#0-2)  However, while `WeightsAlreadyFixedMap` is explicitly cleaned up, the `LockTimeMap` entry is never removed. [4](#0-3) 

**Root Cause:**
Vote ID generation depends on a mutable value (`ObtainedActiveVotedVotesAmount`) that can decrease through withdrawals and cycle back to previous values. However, the collision-detection map (`LockTimeMap`) persists indefinitely, creating vote ID collisions across different time periods.

**Attack Scenario:**
1. Candidate starts with 0 active votes
2. Alice votes 100 tokens → voteId generated based on count=0, stored in `LockTimeMap`
3. Candidate now has 100 active votes  
4. Lock period expires, Alice withdraws → candidate returns to 0 active votes
5. `LockTimeMap[voteId]` still contains the old lock time (never removed)
6. Bob attempts to vote for the same candidate when count=0
7. System generates the same voteId (deterministic based on count=0)
8. Vote fails at assertion: `"Vote already exists."`

## Impact Explanation

**Denial of Service Impact:**
- Legitimate users are permanently blocked from voting for a candidate whenever the candidate's active vote count returns to a previously-used value
- An attacker can deliberately "poison" sequential vote count values (0, 1, 2, ..., N) by creating and withdrawing small votes at each count level
- Capital cost is minimal since tokens are fully returned after withdrawal (only gas fees incurred)
- Once poisoned, these vote count values remain unusable forever since `LockTimeMap` entries are never cleared

**Severity Justification:**
This is a HIGH severity issue because it breaks core Election contract functionality. The voting mechanism is fundamental to AElf's governance system, and preventing legitimate users from voting constitutes a critical operational failure that undermines the democratic process and could lead to governance capture by preventing votes for specific candidates at specific thresholds.

## Likelihood Explanation

**Natural Occurrence:**
This vulnerability will manifest naturally through normal operations. As users vote and withdraw over time, vote counts naturally fluctuate. When a candidate's vote count decreases through withdrawals and later returns to a previous value through new votes, the collision will occur automatically.

**Attack Complexity:**
LOW - The attack sequence is straightforward:
1. Vote for a candidate with minimal amounts at sequential vote count values (0, 1, 2, ...)
2. Wait for minimum lock periods to expire
3. Withdraw all votes
4. All those count values are now permanently unusable

**Economic Rationality:**
Attack cost is near zero: tokens are fully returned after withdrawal, only transaction gas fees are consumed. Count value 0 is especially critical as it's the starting state for all candidates.

**Probability Assessment:**
HIGH - The vulnerability will trigger naturally through legitimate usage patterns as the system matures and users regularly vote and withdraw.

## Recommendation

Add cleanup of `LockTimeMap` entries in the `Withdraw()` function. After line 669, add:

```csharp
State.LockTimeMap.Remove(input);
```

This ensures that withdrawn vote IDs are freed for reuse, preventing permanent collision when vote counts cycle back to previous values.

## Proof of Concept

```csharp
[Fact]
public async Task Vote_ID_Collision_Causes_Permanent_DoS()
{
    // Setup: Announce a candidate
    var candidateKeyPair = ValidationDataCenterKeyPairs.First();
    await AnnounceElectionAsync(candidateKeyPair);
    
    // Alice votes when candidate has 0 votes (generates voteId based on count=0)
    var aliceKeyPair = VoterKeyPairs[0];
    const int lockTime = 7 * 60 * 60 * 24; // 7 days
    var voteResult1 = await VoteToCandidateAsync(aliceKeyPair, 
        candidateKeyPair.PublicKey.ToHex(), lockTime, 100);
    voteResult1.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var voteId1 = Hash.Parser.ParseFrom(voteResult1.ReturnValue);
    
    // Fast forward past lock time
    BlockTimeProvider.SetBlockTime(StartTimestamp.AddSeconds(lockTime + 1));
    
    // Alice withdraws - candidate returns to 0 votes but LockTimeMap[voteId1] still set
    var withdrawResult = await WithdrawVotes(aliceKeyPair, voteId1);
    withdrawResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Bob tries to vote when candidate has 0 votes again
    // This generates the SAME voteId as Alice's original vote
    var bobKeyPair = VoterKeyPairs[1];
    var voteResult2 = await VoteToCandidateAsync(bobKeyPair, 
        candidateKeyPair.PublicKey.ToHex(), lockTime, 50);
    
    // VULNERABILITY: Bob's vote fails with "Vote already exists" 
    // even though Alice's vote was withdrawn
    voteResult2.Status.ShouldBe(TransactionResultStatus.Failed);
    voteResult2.Error.ShouldContain("Vote already exists");
}
```

## Notes

The vulnerability is confirmed through code analysis showing:
1. Vote IDs are deterministically generated based on vote count when Token field is null (standard pattern per test helpers) [5](#0-4) 
2. No code exists to remove `LockTimeMap` entries (verified via grep search showing zero matches for `LockTimeMap.*Remove`)
3. The Token field in VoteMinerInput is optional and rarely used in practice [6](#0-5) 

This creates a permanent state pollution issue where historical vote IDs block future votes at the same vote count values, effectively creating a DoS condition that worsens over time as more vote count values become "poisoned."

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L402-412)
```csharp
    private Hash GenerateVoteId(VoteMinerInput voteMinerInput)
    {
        if (voteMinerInput.Token != null)
            return Context.GenerateId(Context.Self, voteMinerInput.Token);

        var candidateVotesCount =
            State.CandidateVotes[voteMinerInput.CandidatePubkey]?.ObtainedActiveVotedVotesAmount ?? 0;
        return Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(voteMinerInput.CandidatePubkey.GetBytes(),
                candidateVotesCount.ToBytes(false)));
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L432-434)
```csharp
        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L658-660)
```csharp
        candidateVotes.ObtainedActiveVotedVotesAmount =
            candidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[newestPubkey] = candidateVotes;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L665-669)
```csharp
        if (!State.WeightsAlreadyFixedMap[input])
        {
            RemoveBeneficiaryOfVoter();
            State.WeightsAlreadyFixedMap.Remove(input);
        }
```

**File:** test/AElf.Contracts.Election.Tests/ElectionContractTestHelpers.cs (L92-104)
```csharp
    private async Task<TransactionResult> VoteToCandidateAsync(ECKeyPair voterKeyPair, string candidatePublicKey,
        long lockTime, long amount)
    {
        var electionStub = GetElectionContractTester(voterKeyPair);
        var voteResult = (await electionStub.Vote.SendAsync(new VoteMinerInput
        {
            CandidatePubkey = candidatePublicKey,
            Amount = amount,
            EndTimestamp = TimestampHelper.GetUtcNow().AddSeconds(lockTime)
        })).TransactionResult;

        return voteResult;
    }
```

**File:** protobuf/election_contract.proto (L290-299)
```text
message VoteMinerInput {
    // The candidate public key.
    string candidate_pubkey = 1;
    // The amount token to vote.
    int64 amount = 2;
    // The end timestamp of this vote.
    google.protobuf.Timestamp end_timestamp = 3;
    // Used to generate vote id.
    aelf.Hash token = 4;
}
```
