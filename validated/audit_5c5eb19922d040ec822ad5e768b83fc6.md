# Audit Report

## Title
Secret Sharing Revealed In Values Discarded and Recomputed on Every Call, Wasting Gas

## Summary
The `RevealSharedInValues()` function performs expensive cryptographic secret sharing reconstruction during NextRound consensus transitions, but writes the revealed in values to a non-persisted in-memory copy of the current round. These values are completely discarded, breaking the anti-withholding protection mechanism and wasting gas on every call.

## Finding Description

During NextRound consensus transitions, the contract attempts to reconstruct miners' previous in values via Shamir's Secret Sharing to prevent withholding attacks. However, the implementation contains a critical flaw in the execution flow.

When `GetConsensusExtraDataForNextRound` is invoked [1](#0-0) , it first retrieves `currentRound` from state as a deserialized copy [2](#0-1) . The method then creates `nextRound` at line 176, and subsequently calls `RevealSharedInValues(currentRound, pubkey)` at line 189.

The `RevealSharedInValues` function performs expensive cryptographic operations using `SecretSharingHelper.DecodeSecret` and writes the revealed in values to `currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue` [3](#0-2) .

However, these modifications are never persisted because:
1. `currentRound` is a local deserialized copy retrieved from state, not a reference to the state object
2. The method returns `nextRound` (created at line 176, before `RevealSharedInValues` was called), not `currentRound`
3. `nextRound` is generated by creating new `MinerInRound` objects that do NOT copy `PreviousInValue` fields [4](#0-3) 

The returned `nextRound` is converted to `NextRoundInput` [5](#0-4)  and eventually persisted via `AddRoundInformation` [6](#0-5) , but it does not contain the revealed in values.

Both public entry points `GetConsensusExtraData` and `GenerateConsensusTransactions` [7](#0-6)  call the same internal method, causing the computation to be repeated with each invocation.

## Impact Explanation

**Consensus Security Impact**: The secret sharing mechanism is a critical security feature designed to prevent miners from withholding their in values, which are essential for consensus randomness generation. When the revealed in values are discarded, miners who don't reveal their in values during the current round cannot be held accountable through secret sharing reconstruction during the NextRound transition. This completely breaks the anti-withholding protection for NextRound scenarios.

**Gas Waste Impact**: Every NextRound transition wastes significant gas performing secret sharing reconstruction. The computation involves iterating through all miners, reconstructing orders from decrypted pieces, and performing expensive cryptographic operations via `SecretSharingHelper.DecodeSecret`, all of which produces no useful result since the output is immediately discarded.

**Repeated Call Impact**: Since `GetConsensusExtraData` and `GenerateConsensusTransactions` are public view and transaction methods respectively, they can be called multiple times for the same round during normal consensus operation (e.g., retries, different code paths). Each invocation retrieves a fresh copy of `currentRound` from state and recomputes the entire secret sharing reconstruction from scratch, multiplying the gas waste.

## Likelihood Explanation

**Reachability**: The issue is triggered on every NextRound consensus transition through the public ACS4 methods `GetConsensusExtraData` and `GenerateConsensusTransactions`, which are standard entry points called by the consensus system during normal block production flow.

**Frequency**: NextRound transitions occur regularly at the end of each consensus round when the extra block producer generates the transition block. With secret sharing enabled (controlled by configuration), every such transition wastes gas on this broken computation.

**Preconditions**: The only precondition is that secret sharing must be enabled via the configuration contract, which is the intended production mode for preventing in value withholding attacks. No special attacker capabilities or privileges are required—this is a design flaw that manifests during normal consensus operation.

## Recommendation

The revealed in values should either be:
1. **Option A**: Written to `nextRound` instead of `currentRound`, ensuring they are included in the persisted round information
2. **Option B**: Persisted to the current round state before returning, then properly carried forward
3. **Option C**: Passed through trigger information similar to how the UpdateValue behavior handles revealed in values via the off-chain service

The most consistent fix would be to ensure `RevealSharedInValues` writes to the `nextRound` object that will actually be persisted, or to persist the modifications to `currentRound` before completing the transition.

Additionally, consider implementing caching or memoization to prevent redundant computation when methods are called multiple times for the same round.

## Proof of Concept

The vulnerability can be demonstrated by examining the code flow during a NextRound transition:

```
1. Miner calls GenerateConsensusTransactions with NextRound behavior
2. GetConsensusBlockExtraData retrieves currentRound from State.Rounds[n]
3. GenerateNextRoundInformation creates nextRound (without PreviousInValue)
4. RevealSharedInValues performs expensive crypto and modifies currentRound
5. Method returns nextRound (not currentRound)
6. NextRound transaction persists nextRound via AddRoundInformation
7. currentRound modifications are lost
8. Multiple calls repeat steps 2-7, wasting gas each time
```

The execution trace shows that `currentRound` retrieved from state is modified but never written back, while the returned and persisted `nextRound` was created before the modifications occurred and does not contain the revealed in values. This can be verified by examining the state before and after a NextRound transition—the revealed in values will not be present in the persisted round data.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-75)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }

    public override TransactionList GenerateConsensusTransactions(BytesValue input)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);
        // Some basic checks.
        Assert(triggerInformation.Pubkey.Any(),
            "Data to request consensus information should contain pubkey.");

        var pubkey = triggerInformation.Pubkey;
        var randomNumber = triggerInformation.RandomNumber;
        var consensusInformation = new AElfConsensusHeaderInformation();
        consensusInformation.MergeFrom(GetConsensusBlockExtraData(input, true).Value);
        var transactionList = GenerateTransactionListByExtraData(consensusInformation, pubkey, randomNumber);
        return transactionList;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L164-171)
```csharp
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```
