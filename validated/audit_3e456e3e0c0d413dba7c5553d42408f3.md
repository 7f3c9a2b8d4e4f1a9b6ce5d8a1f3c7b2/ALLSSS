# Audit Report

## Title
Withdrawal Function Corrupts Historical Snapshots and Current Aggregate Vote Counts

## Summary
The `Withdraw()` function in the Vote contract modifies finalized snapshot data and causes current snapshots to retain stale aggregate vote counts. When a user withdraws a vote after `TakeSnapshot()` has been called, the withdrawal only updates the historical snapshot where the vote originated, but the current snapshot (which copied forward those aggregate counts) retains the inflated values. This breaks snapshot immutability guarantees and causes governance decisions to be based on incorrect vote data.

## Finding Description

The vulnerability exists in how the Vote contract handles withdrawals across multiple snapshots. The issue arises from a fundamental mismatch between how votes are recorded and how snapshot data is propagated:

**When voting occurs**, the voting record stores the current snapshot number at the time of the vote: [1](#0-0) 

**When TakeSnapshot is called**, it finalizes the previous snapshot by setting `SnapshotEndTimestamp`, then creates a new `VotingResult` for the next snapshot and **copies forward** the aggregate counts (`VotersCount` and `VotesAmount`) from the previous snapshot: [2](#0-1) 

**When Withdraw is called**, it retrieves the `VotingResult` using the snapshot number stored in the original voting record and modifies **only that specific snapshot's data**, without any mechanism to update subsequent snapshots that inherited those counts: [3](#0-2) 

**Root Cause**: The withdrawal logic assumes each vote exists only in its original snapshot, but `TakeSnapshot` copies aggregate counts forward to new snapshots. When a withdrawal modifies the original snapshot, subsequent snapshots retain stale copied counts that no longer reflect the actual vote state.

The security guarantee being broken is **snapshot immutability** - once a snapshot is finalized with `SnapshotEndTimestamp`, its data should not be modified. Additionally, the **current snapshot accuracy** guarantee is violated because aggregate counts include votes that have been withdrawn and tokens that have been unlocked.

## Impact Explanation

**Impact: HIGH**

1. **Historical Data Corruption**: Finalized snapshots with `SnapshotEndTimestamp` set are retroactively modified, violating the fundamental immutability guarantee of snapshot data. This is demonstrated in the existing test suite, which shows historical snapshot modification after finalization: [4](#0-3) 

2. **Incorrect Current Snapshot Counts**: The current snapshot's `VotesAmount` and `VotersCount` become inflated because they include withdrawn votes that were copied forward during `TakeSnapshot` but were never decremented when those votes were withdrawn.

3. **Governance Decision Corruption**: The Election contract relies on these values for critical governance operations. The `GetVotesAmount` and `GetVotersCount` methods query the latest voting result, which will return incorrect inflated values: [5](#0-4) 

These methods use `GetLatestVotingResult`, which returns the current snapshot's data: [6](#0-5) 

The Election contract's `GetVictories` method uses vote counts to determine miner selection, meaning inflated counts will lead to incorrect governance decisions: [7](#0-6) 

4. **Token Double-Use**: Users can withdraw tokens that were locked in previous snapshots and use them for other purposes, while the current snapshot still counts those votes in its aggregate totals, allowing effective double-counting of voting power.

**Quantified Impact**: For a voting item with N snapshots:
- If users withdraw votes after snapshot advancement, all historical snapshots 1 to N-1 get modified post-finalization
- Current snapshot N shows `VotesAmount = (actual votes in N) + (sum of withdrawn votes from snapshots 1 to N-1)`
- Election governance decisions based on these inflated counts will be systematically incorrect

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Capabilities**: Any user who can vote and withdraw their own votes. No special privileges are required - these are standard public methods available to all users.

**Attack Complexity**: LOW
1. Vote with any amount in snapshot N
2. Wait for `TakeSnapshot(N)` to be called by the sponsor (normal governance flow)
3. Call `Withdraw()` to remove the vote from snapshot N
4. Snapshot N+1 automatically retains the inflated counts that were copied during `TakeSnapshot`

**Feasibility Conditions**:
- Voting items with multiple snapshots (the standard configuration for governance scenarios - elections use multiple term snapshots)
- `Vote` and `Withdraw` are public methods with only basic permission checks (voter can withdraw their own votes)
- No time locks or restrictions prevent withdrawal after snapshot advancement
- No validation checks the integrity of subsequent snapshots when withdrawals occur

**Detection Constraints**: The issue manifests as state data inconsistencies that are not immediately visible. The current test suite actually demonstrates this behavior but treats it as expected functionality, confirming the vulnerability exists in production code.

**Probability**: This will occur naturally in any multi-snapshot voting scenario where users exercise their legitimate right to withdraw votes. It does not require malicious intent - it happens as a side effect of normal operations.

## Recommendation

Implement one of the following solutions:

**Option 1: Prevent withdrawals after snapshot advancement**
Add a check in the `Withdraw` function to ensure withdrawals can only occur in the current active snapshot:

```csharp
public override Empty Withdraw(WithdrawInput input)
{
    var votingRecord = State.VotingRecords[input.VoteId];
    if (votingRecord == null) throw new AssertionException("Voting record not found.");
    var votingItem = State.VotingItems[votingRecord.VotingItemId];
    
    // NEW: Prevent withdrawal from finalized snapshots
    Assert(votingRecord.SnapshotNumber == votingItem.CurrentSnapshotNumber,
        "Cannot withdraw from finalized snapshot. Withdrawals only allowed in current snapshot.");
    
    // ... rest of withdrawal logic
}
```

**Option 2: Propagate withdrawal effects to all subsequent snapshots**
When a withdrawal occurs, update all subsequent snapshots that inherited the vote counts:

```csharp
public override Empty Withdraw(WithdrawInput input)
{
    var votingRecord = State.VotingRecords[input.VoteId];
    var votingItem = State.VotingItems[votingRecord.VotingItemId];
    
    // ... existing withdrawal logic for original snapshot ...
    
    // NEW: Update all subsequent snapshots
    for (long i = votingRecord.SnapshotNumber + 1; i <= votingItem.CurrentSnapshotNumber; i++)
    {
        var subsequentResultHash = GetVotingResultHash(votingRecord.VotingItemId, i);
        var subsequentResult = State.VotingResults[subsequentResultHash];
        if (subsequentResult != null)
        {
            subsequentResult.VotesAmount = subsequentResult.VotesAmount.Sub(votingRecord.Amount);
            if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
                subsequentResult.VotersCount = subsequentResult.VotersCount.Sub(1);
            State.VotingResults[subsequentResultHash] = subsequentResult;
        }
    }
    
    return new Empty();
}
```

**Option 3: Change TakeSnapshot to not copy forward aggregate counts**
Instead of copying counts, calculate them fresh for each snapshot based on active votes. This requires tracking which votes are active in each snapshot.

**Recommendation**: Option 1 is the simplest and maintains snapshot immutability by preventing the problematic scenario entirely. It aligns with the principle that finalized snapshots should be immutable.

## Proof of Concept

```csharp
[Fact]
public async Task ProofOfConcept_Withdrawal_Corrupts_Snapshot_Counts()
{
    // Setup: Register voting item with 3 snapshots
    var votingItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 3);
    var voter = Accounts[1].KeyPair;
    var voteAmount = 1000L;
    
    // Step 1: User votes in snapshot 1
    await Vote(voter, votingItem.VotingItemId, votingItem.Options[0], voteAmount);
    
    var snapshot1Before = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 1
    });
    snapshot1Before.VotesAmount.ShouldBe(voteAmount);
    snapshot1Before.VotersCount.ShouldBe(1);
    
    // Step 2: Take snapshot to advance to snapshot 2 (copies counts forward)
    await TakeSnapshot(votingItem.VotingItemId, 1);
    
    var snapshot2After = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 2
    });
    // Snapshot 2 should have copied counts from snapshot 1
    snapshot2After.VotesAmount.ShouldBe(voteAmount);
    snapshot2After.VotersCount.ShouldBe(1);
    
    // Step 3: Withdraw the vote (this modifies snapshot 1 only)
    var voteIds = await GetVoteIds(voter, votingItem.VotingItemId);
    await Withdraw(voter, voteIds.ActiveVotes.First());
    
    // Step 4: Verify the vulnerability
    // Snapshot 1 is corrupted (modified after finalization)
    var snapshot1After = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 1
    });
    snapshot1After.VotesAmount.ShouldBe(0); // Historical snapshot modified!
    snapshot1After.VotersCount.ShouldBe(0);
    snapshot1After.SnapshotEndTimestamp.ShouldNotBeNull(); // But it was finalized!
    
    // Snapshot 2 retains stale inflated counts
    var snapshot2Final = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 2
    });
    snapshot2Final.VotesAmount.ShouldBe(voteAmount); // Still shows 1000 despite withdrawal!
    snapshot2Final.VotersCount.ShouldBe(1); // Still shows 1 voter despite withdrawal!
    
    // GetLatestVotingResult returns the corrupted data
    var latestResult = await VoteContractStub.GetLatestVotingResult.CallAsync(votingItem.VotingItemId);
    latestResult.VotesAmount.ShouldBe(voteAmount); // Governance decisions will use this incorrect value
    
    // Tokens have been unlocked (user can use them elsewhere)
    var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = TestTokenSymbol,
        Owner = Address.FromPublicKey(voter.PublicKey)
    });
    // User has their tokens back but snapshot 2 still counts them as voted!
}
```

## Notes

This vulnerability is particularly severe because:

1. **It affects the Election contract**, which is a critical governance component for miner selection in AElf's AEDPoS consensus
2. **The existing test suite demonstrates the issue** but treats it as expected behavior, indicating this is an unrecognized design flaw rather than a known limitation
3. **It violates fundamental data integrity principles** - snapshot finalization should guarantee immutability
4. **The impact compounds over time** - each additional snapshot inherits and preserves the incorrect aggregate counts from all previous withdrawals

The root cause is an architectural mismatch: the snapshot model assumes immutability and forward propagation of state, while the withdrawal model allows retroactive modification of historical data. These two design patterns are fundamentally incompatible without additional synchronization logic.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-117)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L207-222)
```csharp
        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L251-271)
```csharp
        var previousVotingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
        var previousVotingResult = State.VotingResults[previousVotingResultHash];
        previousVotingResult.SnapshotEndTimestamp = Context.CurrentBlockTime;
        State.VotingResults[previousVotingResultHash] = previousVotingResult;

        Assert(votingItem.CurrentSnapshotNumber == input.SnapshotNumber,
            $"Can only take snapshot of current snapshot number: {votingItem.CurrentSnapshotNumber}, but {input.SnapshotNumber}");
        var nextSnapshotNumber = input.SnapshotNumber.Add(1);
        votingItem.CurrentSnapshotNumber = nextSnapshotNumber;
        State.VotingItems[votingItem.VotingItemId] = votingItem;

        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L259-278)
```csharp
        await TakeSnapshot(voteItemId, 1);


        var beforeBalance = GetUserBalance(voteAddress);
        var transactionResult = await Withdraw(voteUser, currentVoteId);
        transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        voteItems = await VoteContractStub.GetVotedItems.CallAsync(voteAddress);
        voteItems.VotedItemVoteIds[voteItemId.ToHex()].ActiveVotes.Count.ShouldBe(0);
        voteItems.VotedItemVoteIds[voteItemId.ToHex()].WithdrawnVotes.Count.ShouldBe(1);
        var voteRecordAfterWithdraw = await VoteContractStub.GetVotingRecord.CallAsync(currentVoteId);
        voteRecordAfterWithdraw.IsWithdrawn.ShouldBe(true);
        var voteResultAfterWithdraw = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
        {
            SnapshotNumber = 1,
            VotingItemId = voteItemId
        });
        voteResultBeforeWithdraw.VotesAmount.Sub(voteResultAfterWithdraw.VotesAmount).ShouldBe(voteAmount);
        voteResultBeforeWithdraw.Results[registerItem.Options[1]]
            .Sub(voteResultAfterWithdraw.Results[registerItem.Options[1]]).ShouldBe(voteAmount);
        voteResultBeforeWithdraw.VotersCount.Sub(1).ShouldBe(voteResultAfterWithdraw.VotersCount);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-83)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L224-238)
```csharp
    public override Int64Value GetVotersCount(Empty input)
    {
        return new Int64Value
        {
            Value = State.VoteContract.GetLatestVotingResult.Call(State.MinerElectionVotingItemId.Value).VotersCount
        };
    }

    public override Int64Value GetVotesAmount(Empty input)
    {
        return new Int64Value
        {
            Value = State.VoteContract.GetLatestVotingResult.Call(State.MinerElectionVotingItemId.Value).VotesAmount
        };
    }
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L44-53)
```csharp
    public override VotingResult GetLatestVotingResult(Hash input)
    {
        var votingItem = AssertVotingItem(input);
        var votingResultHash = new VotingResult
        {
            VotingItemId = input,
            SnapshotNumber = votingItem.CurrentSnapshotNumber
        }.GetHash();
        return State.VotingResults[votingResultHash];
    }
```
