# Audit Report

## Title
NFT Contract Fee Governance Desynchronization - SetMethodFee Silently Ignores Updates While GetMethodFee Returns Hardcoded Values

## Summary
The NFT contract implements the ACS1 Transaction Fee Standard interface with non-functional stub methods. `SetMethodFee()` accepts governance fee updates but doesn't persist changes to state, while `GetMethodFee()` returns a hardcoded 100 ELF fee instead of reading from state. This creates a governance desynchronization where Parliament believes fee updates succeed, but the runtime continues charging the original hardcoded fee indefinitely.

## Finding Description

The NFT contract's ACS1 implementation lacks the state persistence layer required for fee governance.

The `SetMethodFee()` method is a no-op stub that returns `Empty` without persisting any state changes, lacking both authorization checks and state writes. [1](#0-0) 

The `GetMethodFee()` method returns a hardcoded 100 ELF (100_00000000 base units) fee for the "Create" method, ignoring any fee configurations that might have been intended. [2](#0-1) 

The NFT contract state completely lacks the `TransactionFees` mapped state variable and `MethodFeeController` state variable that all other system contracts use to persist fee configurations. [3](#0-2) 

By contrast, the standard ACS1 implementation pattern in other system contracts properly persists fees to state. The Parliament contract's SetMethodFee performs authorization checks and persists to state [4](#0-3) , and reads from state in GetMethodFee [5](#0-4) .

The MultiToken contract similarly reads fees from state [6](#0-5)  and includes the required TransactionFees state variable [7](#0-6) .

The AElf runtime's fee charging mechanism calls `GetMethodFee()` on the target contract to determine transaction fees before execution. [8](#0-7) 

The NFT contract has a public `Create` method that would be subject to these fees. [9](#0-8) 

## Impact Explanation

**Governance Integrity Violation**: Parliament loses the ability to adjust NFT contract fees through standard governance mechanisms. Fee update proposals will execute successfully (returning `Empty`), creating a false confirmation that governance decisions have been implemented. Governance has no visibility that their decisions are being silently ignored, undermining the fundamental principle that governance should control protocol economics.

**Economic Inflexibility**: The Create method fee is permanently locked at 100 ELF regardless of economic conditions. If ELF token price increases significantly, the fixed 100 ELF fee becomes prohibitively expensive, potentially blocking NFT protocol adoption. Conversely, governance cannot increase fees for protocol revenue optimization. The protocol cannot adapt to changing market conditions or strategic needs.

**Protocol Consistency Breach**: All other AElf system contracts (MultiToken, Parliament, Treasury, Election, etc.) properly implement ACS1 with state persistence and governance control. The NFT contract breaks this standard pattern, creating operational inconsistency and governance uncertainty across the protocol.

**Affected Parties**:
- **Governance (Parliament)**: Loses fee control capability and receives false success signals
- **NFT creators**: Pay fixed fees regardless of economic conditions
- **Protocol operators**: Cannot optimize fee structure for protocol growth or revenue

## Likelihood Explanation

**Certainty**: GUARANTEED - This is a structural design flaw present in 100% of fee update attempts, not a race condition or edge case.

**Entry Point**: The `SetMethodFee` method is part of the public ACS1 interface that governance uses to update fees across all system contracts. It is a legitimate, expected governance action.

**Feasibility**: Parliament would naturally attempt to update NFT fees through standard governance proposals as they do for all other contracts. The transaction succeeds without error, providing false confirmation. Detection requires either reading the contract source code or observing over time that fees never change despite governance actions taken.

**Execution Path**:
1. Parliament creates a proposal to call `NFT.SetMethodFee` with new fee configuration
2. Proposal receives miner approval and is released
3. `SetMethodFee` executes, returning `Empty` (success signal)
4. Governance records the action as successful
5. Subsequent `Create` transactions continue charging the hardcoded 100 ELF
6. Eventually governance discovers fees are unchanged, potentially months later

**No Attack Required**: This is not an active exploit by a malicious actor but a passive governance failure that occurs through normal, legitimate protocol operations.

## Recommendation

Implement the complete ACS1 fee governance pattern in the NFT contract:

1. **Add state variables** to NFTContractState.cs:
   - `MappedState<string, MethodFees> TransactionFees`
   - `SingletonState<AuthorityInfo> MethodFeeController`

2. **Implement SetMethodFee** with proper authorization and persistence:
   - Validate input fees are for burnable tokens
   - Check sender is the MethodFeeController owner address
   - Persist fees to `State.TransactionFees[input.MethodName]`

3. **Update GetMethodFee** to read from state:
   - Return `State.TransactionFees[input.Value]` instead of hardcoded values
   - Keep special handling for size-fee-free methods if needed

4. **Implement ChangeMethodFeeController** to allow governance transfer

5. **Add RequiredMethodFeeControllerSet** helper to initialize with Parliament default organization

Follow the exact patterns used in Parliament, MultiToken, and other system contracts for consistency.

## Proof of Concept

```csharp
[Fact]
public async Task NFT_SetMethodFee_Governance_Desynchronization_Test()
{
    // Setup: Get default Parliament organization (governance authority)
    var defaultOrganization = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    
    // Step 1: Create governance proposal to set NFT Create method fee to 50 ELF
    var newFee = 50_00000000L; // 50 ELF
    var methodFees = new MethodFees
    {
        MethodName = "Create",
        Fees = {
            new MethodFee { Symbol = "ELF", BasicFee = newFee }
        }
    };
    
    var proposalId = await CreateProposalAsync(
        NFTContractAddress,
        defaultOrganization,
        "SetMethodFee",
        methodFees
    );
    
    // Step 2: Approve and release proposal (governance process succeeds)
    await ApproveWithMinersAsync(proposalId);
    var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 3: Verify governance believes the update succeeded (SetMethodFee returned Empty)
    // No error was thrown, so governance thinks fee is now 50 ELF
    
    // Step 4: Check actual fee charged - VULNERABILITY: Still returns hardcoded 100 ELF
    var actualFee = await NFTContractStub.GetMethodFee.CallAsync(new StringValue { Value = "Create" });
    
    // ASSERTION FAILURE: Expected 50 ELF (governance decision), but got 100 ELF (hardcoded)
    actualFee.Fees[0].BasicFee.ShouldBe(newFee); // This will FAIL - proves vulnerability
    // Actual value remains: 100_00000000 (100 ELF)
    
    // Governance desynchronization confirmed: 
    // - Proposal succeeded without error
    // - Fee configuration was NOT persisted
    // - GetMethodFee still returns hardcoded value
    // - Governance has no indication their decision was ignored
}
```

This test demonstrates the complete governance desynchronization: the proposal process succeeds normally, but the fee configuration is never applied because SetMethodFee doesn't persist to state and GetMethodFee returns hardcoded values.

## Notes

This vulnerability represents an incomplete implementation rather than a malicious exploit. The NFT contract was deployed with stub ACS1 methods that do not fulfill the interface's governance contract. All 15 other system contracts in the AElf protocol properly implement ACS1 with state persistence, making the NFT contract an outlier that breaks protocol-wide governance consistency.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-11)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-34)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L6-46)
```csharp
public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L34-44)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(ApproveMultiProposals))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };

        return State.TransactionFees[input.Value];
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L37-52)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (new List<string>
            {
                nameof(ClaimTransactionFees), nameof(DonateResourceToken), nameof(ChargeTransactionFees),
                nameof(CheckThreshold), nameof(CheckResourceToken), nameof(ChargeResourceToken),
                nameof(CrossChainReceiveToken)
            }.Contains(input.Value))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        var fees = State.TransactionFees[input.Value];
        return fees;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L10-10)
```csharp
    internal MappedState<string, MethodFees> TransactionFees { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-39)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-14)
```csharp
    public override StringValue Create(CreateInput input)
```
