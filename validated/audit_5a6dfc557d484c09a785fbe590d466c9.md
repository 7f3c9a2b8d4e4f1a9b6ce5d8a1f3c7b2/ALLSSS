# Audit Report

## Title
Sponsor Can Manipulate Voting Timing Through Unrestricted Snapshot Control

## Summary
The `TakeSnapshot()` function in the Vote contract allows sponsors to take snapshots at arbitrary times without enforcing the declared `StartTimestamp` and `EndTimestamp` parameters. This enables sponsors to close all voting snapshots immediately after registration or strategically manipulate snapshot timing, effectively denying voters their expected voting period and undermining governance fairness.

## Finding Description

The Vote contract's `TakeSnapshot()` function enforces only authorization and snapshot count limits, but completely lacks temporal validation. [1](#0-0) 

The function performs three checks:
1. **Sponsor authorization check** - Validates only that the caller is the sponsor
2. **Snapshot count check** - Ensures total snapshots haven't been exceeded  
3. **Snapshot sequence check** - Validates snapshot number ordering

Critically missing are any time-based validations:
- No verification that `Context.CurrentBlockTime` falls within the voting period `[StartTimestamp, EndTimestamp]`
- No minimum duration requirement between snapshots
- No fair distribution of snapshots across the total voting period

During registration, the contract stores and validates that `EndTimestamp > StartTimestamp`: [2](#0-1) [3](#0-2) 

However, these timestamps are never enforced during voting operations. The `AssertValidVoteInput` validation function checks snapshot numbers but not time constraints: [4](#0-3) 

This creates a false expectation: voters see a 30-day voting period declared in registration, but the sponsor can close all snapshots within seconds by repeatedly calling `TakeSnapshot()`. Test evidence confirms snapshots can be taken in rapid succession with no delay: [5](#0-4) 

## Impact Explanation

**Severity: MEDIUM-HIGH** - Governance manipulation affecting voting fairness without direct fund loss.

The vulnerability enables concrete governance attacks:

1. **Immediate Closure Attack**: A sponsor registers a voting item indicating a 30-day period with 10 snapshots (implying ~3 days per snapshot), then immediately calls `TakeSnapshot()` nine times. All snapshots close before any voter can participate, creating a dead voting item that denies all voting rights.

2. **Strategic Timing Manipulation**: The sponsor can monitor real-time voting results and close snapshots at opportune moments - when favorable results are achieved or to front-run unfavorable votes.

3. **Voter Expectation Violation**: The declared `StartTimestamp` and `EndTimestamp` create legitimate expectations about voting duration. Voters planning participation based on these parameters are denied their rights when sponsors arbitrarily manipulate timing.

While this doesn't directly cause fund loss or supply inflation, it fundamentally breaks governance fairness guarantees. The Election contract (the most critical use case) manages its own voting timing through consensus mechanisms, providing some mitigation. However, standalone Vote contract usage remains vulnerable to this manipulation.

## Likelihood Explanation

**Likelihood: HIGH** - Trivially executable attack with strong incentives.

**Attacker Capabilities**: 
- Requires only legitimate sponsor role (anyone can register voting items)
- No special privileges needed beyond standard sponsor rights
- Direct access to public `TakeSnapshot()` method

**Attack Complexity**: Extremely low - a simple loop calling `TakeSnapshot()` with sequential snapshot numbers. No complex preconditions, race conditions, or cryptographic challenges.

**Economic Rationality**: 
- Cost: Only gas fees for transactions
- Benefit: Complete control over voting timeline and potential outcome manipulation
- Strong incentive for sponsors with conflicts of interest in voting results

Any sponsor with a vested interest in voting outcomes has both the means and motive to exploit this vulnerability.

## Recommendation

Add temporal validation to the `TakeSnapshot()` function to enforce declared timestamps:

```csharp
public override Empty TakeSnapshot(TakeSnapshotInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");
    
    // NEW: Enforce voting period constraints
    Assert(Context.CurrentBlockTime >= votingItem.StartTimestamp, 
        "Cannot take snapshot before voting period starts.");
    Assert(Context.CurrentBlockTime <= votingItem.EndTimestamp, 
        "Cannot take snapshot after voting period ends.");
    
    // NEW: Enforce minimum snapshot duration
    var currentSnapshotHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
    var currentSnapshot = State.VotingResults[currentSnapshotHash];
    var minSnapshotDuration = (votingItem.EndTimestamp.Seconds - votingItem.StartTimestamp.Seconds) 
        / votingItem.TotalSnapshotNumber / 2; // At least half the expected duration per snapshot
    Assert(Context.CurrentBlockTime.Seconds >= currentSnapshot.SnapshotStartTimestamp.Seconds + minSnapshotDuration,
        "Minimum snapshot duration not met.");
    
    Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
        "Current voting item already ended.");
    
    // ... rest of existing logic
}
```

Additionally, add time validation to `AssertValidVoteInput` to prevent voting outside the declared period.

## Proof of Concept

```csharp
[Fact]
public async Task VoteContract_Sponsor_Can_Close_All_Snapshots_Immediately()
{
    // Register voting item with 30-day period and 10 snapshots
    var votingItem = await RegisterVotingItemAsync(30, 4, true, DefaultSender, 10);
    
    // Verify declared timeframe
    (votingItem.EndTimestamp.ToDateTime() - votingItem.StartTimestamp.ToDateTime())
        .TotalDays.ShouldBe(30);
    votingItem.TotalSnapshotNumber.ShouldBe(10);
    
    // Attack: Sponsor immediately closes all 9 remaining snapshots in rapid succession
    for (var i = 1; i < 10; i++)
    {
        var result = await VoteContractStub.TakeSnapshot.SendAsync(
            new TakeSnapshotInput
            {
                VotingItemId = votingItem.VotingItemId,
                SnapshotNumber = i
            });
        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    }
    
    // Verify all snapshots closed immediately - voting item now ended
    var updatedItem = await GetVoteItem(votingItem.VotingItemId);
    updatedItem.CurrentSnapshotNumber.ShouldBe(11); // Beyond total snapshots
    
    // Voters can no longer vote despite being within the declared 30-day period
    var voter = Accounts[11].KeyPair;
    var voteResult = await VoteWithException(voter, votingItem.VotingItemId, 
        votingItem.Options[0], 100);
    voteResult.Status.ShouldBe(TransactionResultStatus.Failed);
    voteResult.Error.ShouldContain("Current voting item already ended");
    
    // All snapshots closed within seconds, denying the declared 30-day voting period
}
```

## Notes

The vulnerability is valid but has nuanced impact:
- The critical Election contract usage is protected through its own consensus-based snapshot management
- Standalone Vote contract deployments and non-Election use cases remain vulnerable
- While there's no direct fund loss, the governance fairness violation is significant
- The declared timestamps serve no enforcement purpose, creating false expectations for voters

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L46-47)
```csharp
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L241-273)
```csharp
    public override Empty TakeSnapshot(TakeSnapshotInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);

        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");

        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");

        // Update previous voting going information.
        var previousVotingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
        var previousVotingResult = State.VotingResults[previousVotingResultHash];
        previousVotingResult.SnapshotEndTimestamp = Context.CurrentBlockTime;
        State.VotingResults[previousVotingResultHash] = previousVotingResult;

        Assert(votingItem.CurrentSnapshotNumber == input.SnapshotNumber,
            $"Can only take snapshot of current snapshot number: {votingItem.CurrentSnapshotNumber}, but {input.SnapshotNumber}");
        var nextSnapshotNumber = input.SnapshotNumber.Add(1);
        votingItem.CurrentSnapshotNumber = nextSnapshotNumber;
        State.VotingItems[votingItem.VotingItemId] = votingItem;

        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L361-361)
```csharp
        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/SnapshotTests.cs (L78-101)
```csharp
    public async Task VoteContract_TakeSnapshot_Success_Test()
    {
        var registerItem = await RegisterVotingItemAsync(10, 4, true, DefaultSender, 3);
        for (var i = 0; i < 3; i++)
        {
            var transactionResult = (await VoteContractStub.TakeSnapshot.SendAsync(
                new TakeSnapshotInput
                {
                    VotingItemId = registerItem.VotingItemId,
                    SnapshotNumber = i + 1
                })).TransactionResult;

            transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            var votingItem = await GetVoteItem(registerItem.VotingItemId);
            votingItem.CurrentSnapshotNumber.ShouldBe(i + 2);
            var voteResult = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
            {
                VotingItemId = registerItem.VotingItemId,
                SnapshotNumber = i + 2
            });
            voteResult.SnapshotNumber.ShouldBe(i + 2);
        }
    }
```
