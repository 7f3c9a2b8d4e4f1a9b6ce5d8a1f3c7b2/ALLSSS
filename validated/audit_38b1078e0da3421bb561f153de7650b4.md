# Audit Report

## Title
Mining Order Manipulation via Unvalidated Secret Sharing Data in Consensus Transactions

## Summary
A malicious miner can manipulate the mining order of offline miners by providing crafted `RevealedInValues` in their consensus trigger information. These unvalidated values are used to set `PreviousInValue` for other miners, which subsequently affects signature calculation and mining order determination in future rounds, compromising the fairness of the consensus mechanism.

## Finding Description

The vulnerability exists in the AEDPoS consensus secret sharing mechanism. When a miner produces a block, they provide off-chain trigger information that includes `RevealedInValues` - a map of miner public keys to their revealed in-values. [1](#0-0) 

In the `UpdateLatestSecretPieces` method, these `RevealedInValues` are applied to set `PreviousInValue` for OTHER miners without cryptographic validation: [2](#0-1) 

The manipulated `PreviousInValue` values are then propagated through multiple paths:
1. They are included in the block header via `GetUpdateValueRound` [3](#0-2) 
2. They are included in the transaction via `MinersPreviousInValues` [4](#0-3) 
3. They are applied during transaction execution in `PerformSecretSharing` [5](#0-4) 

The validation provider only checks the current miner's own `PreviousInValue`, not values they set for others: [6](#0-5) 

When `SupplyCurrentRoundInformation` fills missing data for absent miners, it retrieves the manipulated `PreviousInValue` and uses it to calculate their signature: [7](#0-6) 

The signature directly determines mining order through modulo arithmetic: [8](#0-7) 

When the next round is generated, miners are ordered by their `FinalOrderOfNextRound` values, which are derived from the manipulated signatures: [9](#0-8) 

## Impact Explanation

This vulnerability compromises a critical consensus invariant: the fairness and unpredictability of mining order. A malicious miner can:

1. **Manipulate Mining Positions**: By providing incorrect `PreviousInValue` entries for offline miners, the attacker influences the signature calculation, which determines `SupposedOrderOfNextRound` through deterministic but signature-dependent modulo arithmetic.

2. **Target Specific Miners**: The attack specifically affects miners who are temporarily offline or slow to produce blocks, as the manipulated values are used when their data is filled by `SupplyCurrentRoundInformation`.

3. **Bias Consensus Outcomes**: Repeatedly pushing certain miners to unfavorable time slots or advantaging colluding miners disrupts the intended randomness and fairness of the round-robin scheduling.

4. **Indirect Economic Impact**: While not directly stealing funds, biased mining schedules affect block production opportunities and can indirectly influence mining reward distribution over time.

The severity is Medium because it compromises consensus integrity without enabling direct fund theft, but it has measurable impact on the protocol's fairness guarantees.

## Likelihood Explanation

The attack is highly feasible:

1. **Low Attacker Requirements**: Any active consensus miner can execute this attack by simply providing crafted `RevealedInValues` in their off-chain trigger information.

2. **Common Attack Window**: Miner downtime/delays are regular occurrences in distributed systems due to network issues, maintenance, or temporary node failures, providing frequent opportunities for exploitation.

3. **Low Detection Probability**: The manipulation is difficult to detect because:
   - The malicious data originates from off-chain trigger information
   - Validation only checks the current miner's values
   - Mining order has natural variance, masking manipulation
   - No alerts are raised for incorrect revealed values

4. **No Cryptographic Protection**: The protocol accepts the revealed in-values without verifying they are correct decryptions or match expected cryptographic commitments.

5. **Economic Incentive**: Miners seeking competitive advantage have economic motivation to manipulate mining schedules in their favor.

The likelihood is Medium given the regular occurrence of miner absences and the low cost/difficulty of exploitation.

## Recommendation

Add cryptographic validation for `RevealedInValues` before applying them to other miners' `PreviousInValue` fields. The validation should verify that:

1. The revealed in-value correctly decrypts the encrypted piece that was previously shared
2. The hash of the revealed in-value matches the expected out-value from the previous round
3. Only the miner who encrypted the piece can reveal it, preventing arbitrary value injection

Example fix in `UpdateLatestSecretPieces`:

```csharp
foreach (var revealedInValue in triggerInformation.RevealedInValues)
{
    if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
    {
        var targetMiner = updatedRound.RealTimeMinersInformation[revealedInValue.Key];
        
        // Only set if currently empty/null
        if (targetMiner.PreviousInValue == Hash.Empty || targetMiner.PreviousInValue == null)
        {
            // ADD VALIDATION: Verify the revealed value matches expected hash
            // from previous round's OutValue for this miner
            if (TryToGetPreviousRoundInformation(out var previousRound) &&
                previousRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
            {
                var expectedOutValue = previousRound.RealTimeMinersInformation[revealedInValue.Key].OutValue;
                var computedOutValue = HashHelper.ComputeFrom(revealedInValue.Value);
                
                if (computedOutValue != expectedOutValue)
                {
                    Context.LogDebug(() => $"Invalid revealed in value for {revealedInValue.Key}");
                    continue; // Skip invalid values
                }
            }
            
            targetMiner.PreviousInValue = revealedInValue.Value;
        }
    }
}
```

Additionally, consider requiring cryptographic proofs that the revealed values are correct decryptions of the encrypted pieces that were shared in previous rounds.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a consensus environment with multiple miners
2. Having Miner A go offline temporarily
3. Miner B produces a block with crafted `RevealedInValues` containing an incorrect `PreviousInValue` for Miner A
4. When `SupplyCurrentRoundInformation` is called before the next round, it uses the manipulated value
5. The signature calculated for Miner A is incorrect, affecting their `SupposedOrderOfNextRound`
6. Observing that Miner A's position in the next round differs from what it would be with the correct `PreviousInValue`

A complete test would require the full AElf test environment with multiple miner nodes, consensus round simulation, and the ability to inject custom trigger information during block production. The test would verify that the mining order for absent miners can be influenced by the values provided in `RevealedInValues` without triggering validation failures.

### Citations

**File:** protobuf/aedpos_contract.proto (L342-343)
```text
    // The revealed InValues.
    map<string, aelf.Hash> revealed_in_values = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L44-52)
```csharp
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
