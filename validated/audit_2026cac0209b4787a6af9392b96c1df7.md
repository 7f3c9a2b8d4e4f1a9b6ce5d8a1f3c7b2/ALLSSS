# Audit Report

## Title
Secret Sharing Threshold Validation Requires 100% Participation Instead of Configured 2/3 Threshold

## Summary
The AEDPoS consensus contract implements Shamir's t-of-n secret sharing with a 2/3 threshold but incorrectly validates that 100% of miners must participate before attempting secret reconstruction. This defeats the fault-tolerance purpose of threshold cryptography and enables any single miner to prevent all other miners from having their `PreviousInValue` revealed through a zero-cost griefing attack.

## Finding Description

The vulnerability stems from a mismatch between the cryptographic threshold configuration and the validation logic used before secret reconstruction.

**Threshold Configuration (2/3):**
The system correctly calculates the threshold as two-thirds of miners: [1](#0-0) 

**Incorrect Validation (100%):**
However, the validation logic requires 100% of miners to have submitted their decrypted pieces before attempting reconstruction: [2](#0-1) 

This check requires `DecryptedPieces.Count >= minersCount` (100%) even though `minimumCount` (2/3) was calculated on line 22.

**Cryptographic Function Uses Correct Threshold:**
The actual secret reconstruction correctly uses the 2/3 threshold: [3](#0-2) 

This proves the cryptographic scheme only needs `minimumCount` shares, not `minersCount` shares.

**Attack Execution:**
When miners submit their consensus data via `UpdateValue`, the `PerformSecretSharing` method stores `DecryptedPieces` without validation: [4](#0-3) 

A malicious miner can simply omit their `DecryptedPieces` for target miners. When `RevealSharedInValues` later attempts to reconstruct secrets, it will skip any miner whose `DecryptedPieces.Count < minersCount`, even though reconstruction would succeed with `minimumCount` pieces.

**Data Collection Without Validation:**
The `ExtractInformationToUpdateConsensus` function collects decrypted pieces but performs no threshold validation: [5](#0-4) 

**Fallback Mechanism:**
When `PreviousInValue` cannot be revealed, the system falls back to a deterministic value: [6](#0-5) 

This deterministic fallback is predictable and allows selective revelation manipulation.

**No Punishment Mechanism:**
Evil miner detection only checks `MissedTimeSlots`, not failure to submit `DecryptedPieces`: [7](#0-6) 

**Optional But Critical:**
The validation explicitly allows empty/null `PreviousInValue`: [8](#0-7) 

While this allows the system to continue operating, it undermines the commit-reveal randomness scheme's integrity.

## Impact Explanation

**1. Defeats Threshold Cryptography Design:**
Shamir's Secret Sharing is specifically designed to provide fault tolerance - secrets can be reconstructed with only t-of-n shares. By requiring n-of-n participation, the implementation completely defeats this core property.

**2. Griefing Attack:**
Any single malicious miner can prevent ALL other miners from having their `PreviousInValue` revealed by simply not submitting their `DecryptedPiece` during their `UpdateValue` transaction. This is a powerful griefing vector with zero economic cost to the attacker.

**3. Consensus Randomness Manipulation:**
The commit-reveal scheme relies on miners committing to secret values (`InValue`) and later revealing them. When revelation fails, the system uses deterministic fallback values that are predictable and manipulable, weakening the randomness guarantees that secure block producer selection and mining order.

**4. No Detection or Punishment:**
Unlike missed time slots which trigger evil miner detection, failure to submit decrypted pieces goes undetected and unpunished, making this a risk-free attack.

**Severity: HIGH** - Breaks fundamental cryptographic assumptions, enables zero-cost griefing affecting entire miner set, and undermines consensus randomness security.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an active miner in the consensus set (reachable privilege)
- No special permissions beyond standard block production rights

**Attack Complexity:**
- Trivial - attacker simply omits `DecryptedPieces` from their `UpdateValue` input
- Passive attack (omission) rather than active manipulation
- No special timing or coordination required

**Feasibility:**
- Attack succeeds with just one malicious miner out of the entire set
- Works even if 99% of miners are honest (requires only n-1 pieces to fail the >= minersCount check)
- No economic cost or on-chain evidence of malicious intent

**Detection:**
- Indistinguishable from network issues or temporary unavailability
- No mechanism to prove deliberate withholding versus technical difficulties

**Incentive Compatibility:**
Miners are incentivized to execute this attack to:
- Prevent competitors from proper `PreviousInValue` verification
- Create consensus instability for their benefit
- Manipulate randomness for favorable mining order

**Probability: HIGH** - Any rational adversarial miner can and would exploit this to gain competitive advantage with zero risk.

## Recommendation

Replace the incorrect 100% validation check with the correct 2/3 threshold check:

**Fix in `AEDPoSContract_SecretSharing.cs` line 36:**
```csharp
// CURRENT (INCORRECT):
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

// FIXED:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

This change ensures the validation matches the cryptographic threshold, allowing secret reconstruction to proceed when t-of-n (2/3) shares are available, as designed by Shamir's Secret Sharing scheme.

Additional improvements:
1. Add validation in `PerformSecretSharing` to warn/log when insufficient decrypted pieces are submitted
2. Consider adding detection logic for miners who consistently fail to submit decrypted pieces
3. Update the application layer `SecretSharingService` with the same fix for consistency

## Proof of Concept

The existing test demonstrates that reconstruction works with only `MinimumCount` (2/3) pieces: [9](#0-8) 

This test shows that when `decryptedValues.Count >= MinimumCount`, the `DecodeSecret` function successfully reconstructs the original message. The contract validation incorrectly rejects this valid case by requiring `minersCount` instead of `MinimumCount`.

**Attack Demonstration:**
In a live system with N miners where minimumCount = 2N/3:
1. Honest miners submit all their DecryptedPieces (N-1 pieces for each target miner)
2. Attacker (1 malicious miner) omits their DecryptedPieces
3. Each honest miner now has only N-1 decrypted pieces
4. Line 36 check fails: `(N-1) < N` is true
5. `RevealSharedInValues` skips all miners, even though `(N-1) >= 2N/3` for N >= 3
6. All `PreviousInValue` revelations fail despite having sufficient shares for reconstruction

This proves the validation is overly restrictive and defeats the threshold scheme's fault tolerance.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L22-23)
```csharp
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L26-28)
```csharp
        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L96-96)
```csharp
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L42-46)
```csharp
        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/InValueRecoveryTest.cs (L52-58)
```csharp
            if (decryptedValues.Count >= MinimumCount)
            {
                decryptResult = SecretSharingHelper.DecodeSecret(
                    decryptedValues.Values.ToList(),
                    Enumerable.Range(1, MinimumCount).ToList(), MinimumCount);
                break;
            }
```
