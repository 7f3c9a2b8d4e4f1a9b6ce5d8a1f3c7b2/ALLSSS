# Audit Report

## Title
Missing Dictionary Key Validation in CrossChainCreate Causes KeyNotFoundException and DoS

## Summary
The `CrossChainCreate` function in the NFT contract directly accesses `ExternalInfo.Value` dictionary keys without validation, causing unhandled `KeyNotFoundException` when tokens lack required NFT metadata. This enables permanent DoS of cross-chain NFT protocol creation through pre-creation of malformed tokens.

## Finding Description

The vulnerability exists in the `CrossChainCreate` method where dictionary keys are accessed without checking if they exist: [1](#0-0) 

The method is publicly accessible with no authorization checks beyond basic contract address initialization: [2](#0-1) 

**Root Cause:**

The legitimate NFT creation flow through `NFTContract.Create()` guarantees these keys are added to ExternalInfo: [3](#0-2) 

However, the `MultiToken.Create` method accepts arbitrary `ExternalInfo` without validating NFT-specific metadata requirements: [4](#0-3) 

An attacker with seed NFT ownership can create tokens with NFT collection symbol formats. The symbol type is determined by format, where "PREFIX-0" identifies NFT collections: [5](#0-4) 

NFT collection symbols route through `CreateNFTCollection` which calls the same `CreateToken` method, subject to seed NFT authorization: [6](#0-5) 

When tokens are synced cross-chain via `CrossChainCreateToken`, the incomplete `ExternalInfo` is preserved exactly: [7](#0-6) 

**Why Existing Protections Fail:**

The `MultiToken` contract uses defensive patterns with `TryGetValue` for dictionary access as evidenced in CheckSeedNFT: [8](#0-7) 

But the NFT contract does not follow this pattern, directly accessing dictionary keys that may not exist. The required metadata keys are defined as constants: [9](#0-8) 

## Impact Explanation

**Concrete Harm:**
- **Permanent DoS**: Attackers can irreversibly block legitimate NFT protocols from being created on sidechains by pre-creating tokens with matching symbols but incomplete metadata
- **Cross-Chain Disruption**: All calls to `CrossChainCreate` for affected symbols throw unhandled `KeyNotFoundException`, completely breaking cross-chain NFT synchronization
- **No Recovery**: Once a malformed token exists, there is no mechanism to fix or override it. The only methods that modify ExternalInfo are `UpdateSeedExpirationTime` and `SetSymbolAlias`, neither of which can add the missing NFT-specific keys
- **Ecosystem Impact**: Affects NFT protocol creators, sidechain users, and the broader AElf cross-chain NFT functionality

**Severity Justification:**
High severity due to permanent, irrecoverable DoS with low attack complexity and broad ecosystem impact. The vulnerability breaks the core cross-chain NFT protocol creation functionality.

## Likelihood Explanation

**Attacker Requirements:**
- Seed NFT ownership (obtainable through normal protocol mechanisms such as purchasing or transferring existing seed NFTs) OR whitelist access for token creation

**Attack Complexity:**
Low - requires only:
1. One `MultiToken.Create()` call with NFT collection symbol format (e.g., "ABART-0") and empty/incomplete `ExternalInfo`
2. Automatic cross-chain synchronization propagates the malformed token via `CrossChainCreateToken`
3. Any user calling `CrossChainCreate()` triggers the `KeyNotFoundException`

**Probability:**
Medium-High because seed NFTs are obtainable through normal protocol operations (market purchase, transfers), the attack is straightforward with clear griefing motivation, and no technical sophistication is required. The attack permanently blocks NFT protocol creation for specific symbols on sidechains.

## Recommendation

Add defensive key existence checks before accessing dictionary values in `CrossChainCreate`:

```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    MakeSureTokenContractAddressSet();
    InitialNFTTypeNameMap();
    Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
    {
        Symbol = input.Symbol
    });
    if (string.IsNullOrEmpty(tokenInfo.Symbol))
        throw new AssertionException($"Token info {input.Symbol} not exists.");

    // Add defensive checks
    Assert(tokenInfo.ExternalInfo != null && 
           tokenInfo.ExternalInfo.Value.TryGetValue(NftBaseUriMetadataKey, out var baseUri),
           "NFT base URI metadata not found.");
    Assert(tokenInfo.ExternalInfo.Value.TryGetValue(NftTokenIdReuseMetadataKey, out var tokenIdReuseStr) &&
           bool.TryParse(tokenIdReuseStr, out var isTokenIdReuse),
           "NFT token ID reuse metadata not found or invalid.");
    
    // Continue with existing logic...
}
```

Additionally, consider adding validation in `MultiToken.Create` to prevent creation of NFT collection symbols without required metadata, or route NFT collection creation exclusively through the NFT contract.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreate_WithMissingMetadata_ShouldThrowKeyNotFoundException()
{
    // Setup: Create a seed NFT for the target symbol
    const string targetSymbol = "MALICIOUS-0"; // NFT collection format
    await CreateAndIssueSeedNFT(targetSymbol);
    
    // Attack Step 1: Create token with NFT collection symbol but empty ExternalInfo
    var createInput = new CreateInput
    {
        Symbol = targetSymbol,
        TokenName = "Malicious Token",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = DefaultSender,
        IsBurnable = true,
        ExternalInfo = new ExternalInfo() // Empty - missing required NFT metadata
    };
    
    await TokenContractStub.Create.SendAsync(createInput);
    
    // Attack Step 2: Sync to sidechain via CrossChainCreateToken
    await SyncTokenToSideChain(targetSymbol);
    
    // Attack Step 3: Attempt CrossChainCreate on sidechain
    var crossChainInput = new CrossChainCreateInput { Symbol = targetSymbol };
    
    // This should throw KeyNotFoundException due to missing metadata keys
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await SideChainNFTContractStub.CrossChainCreate.SendAsync(crossChainInput);
    });
    
    Assert.Contains("KeyNotFoundException", exception.Message);
    
    // Verify protocol was not created (permanent DoS)
    var protocolInfo = await SideChainNFTContractStub.GetNFTProtocolInfo.CallAsync(
        new StringValue { Value = targetSymbol });
    Assert.Null(protocolInfo.Symbol);
}
```

## Notes

The vulnerability specifically affects cross-chain NFT protocol synchronization from mainchain to sidechains. The attack vector leverages the fact that:

1. `MultiToken.Create` allows creation of NFT collection symbols (format "PREFIX-0") with arbitrary `ExternalInfo`
2. Seed NFT authorization only validates ownership and expiration, not metadata completeness
3. `CrossChainCreateToken` preserves `ExternalInfo` exactly as stored on source chain
4. `CrossChainCreate` assumes required metadata keys exist without validation

This creates an asymmetry where mainchain creation via `NFT.Create` guarantees metadata completeness, but direct `MultiToken.Create` bypasses this guarantee, allowing malformed tokens to propagate cross-chain and permanently DoS NFT protocol creation on sidechains.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-79)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L87-88)
```csharp
        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L196-199)
```csharp
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L51-66)
```csharp
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L124-130)
```csharp
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L492-503)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L8-9)
```csharp
    private const string NftBaseUriMetadataKey = "aelf_nft_base_uri";
    private const string NftTokenIdReuseMetadataKey = "aelf_nft_token_id_reuse";
```
