# Audit Report

## Title
Association Organization DOS Attack via Unbounded Member List Size

## Summary
The Association contract allows creation of organizations with arbitrarily large member lists (up to 128KB state size limit), enabling approximately 3,000-3,700 members per organization. This causes O(n) and O(m×n) complexity in voting authorization checks and proposal threshold validation operations, resulting in execution observer branch count violations that render the organization completely unusable for governance operations.

## Finding Description

The vulnerability stems from missing upper bound validation on organization member list size. The `OrganizationMemberList` structure uses a protobuf repeated field that performs linear search operations via the `Contains()` method. [1](#0-0) 

This O(n) operation is invoked in multiple critical execution paths:

**Voting Authorization Path**: Every vote operation (Approve/Reject/Abstain) checks membership by calling `AssertIsAuthorizedOrganizationMember()`, which performs a linear search through all organization members. [2](#0-1)  This is invoked during each voting transaction. [3](#0-2) 

**Proposal Threshold Validation Path (O(m×n) complexity)**: The threshold checking logic uses LINQ `Count()` with the `Contains()` predicate, creating nested loops. For rejections: [4](#0-3) 

For abstentions: [5](#0-4) 

For approvals: [6](#0-5) 

Each `Count(organization.OrganizationMemberList.Contains)` operation iterates through all votes (m) and performs an O(n) member lookup for each vote, resulting in O(m×n) total complexity.

**Root Cause**: The validation function checks for empty lists and duplicates but imposes NO maximum size constraint. [7](#0-6) 

Organizations can be created by anyone via the public `CreateOrganization()` method with arbitrary member counts up to the state size limit. [8](#0-7) 

**Size Constraints**: The only limiting factor is the 128KB state size constraint [9](#0-8) , allowing approximately 3,000-3,700 members per organization (given ~35 bytes per address including protobuf overhead).

## Impact Explanation

AElf enforces a 15,000 branch count limit per transaction to prevent infinite loops. [10](#0-9) 

With an organization containing 3,000 members:
- A single `Approve()` call performs ~3,000 comparisons in `Contains()`, approaching the branch limit
- `IsReleaseThresholdReached()` with just 10 votes performs 30,000 iterations (10 votes × 3,000 members), exceeding the branch limit
- Transactions fail with `RuntimeBranchThresholdExceededException`

**Complete Governance DOS**: Once an attacker creates such an organization:
1. Legitimate members **cannot vote** - all Approve/Reject/Abstain transactions fail due to branch limit violations
2. **Cannot check proposal status** - GetProposal() fails when computing ToBeReleased due to O(m×n) complexity
3. **Cannot modify membership** - AddMember/RemoveMember operations using `AnyDuplicate()` [11](#0-10)  become computationally prohibitive
4. **Organization becomes permanently unusable** for all governance purposes

All legitimate members of the attacked organization lose their governance rights, and proposals cannot be executed even if logically approved.

## Likelihood Explanation

**Attack Feasibility: HIGH**

1. **Entry Point**: The `CreateOrganization()` method is public and accessible to any caller with no authorization checks
2. **Attack Cost**: One-time transaction to create an organization with maximum members. While storing 3,000+ addresses incurs state write fees, this is a single upfront cost that permanently disables the organization
3. **No Preconditions**: Attacker needs no special permissions or existing state
4. **Execution Simplicity**: Single transaction with a large `OrganizationMemberList` in `CreateOrganizationInput`
5. **Detection Difficulty**: No validation prevents this during organization creation. The DOS only manifests when legitimate users attempt to interact with the organization

The attacker pays once to create the organization, but all subsequent users either pay excessive costs or fail entirely. This is a classic griefing attack with asymmetric cost structure favoring the attacker.

## Recommendation

Implement a maximum member list size constraint in the `Validate()` method:

```csharp
private bool Validate(Organization organization)
{
    const int MaxOrganizationMembers = 100; // Or appropriate limit based on gas costs
    
    if (organization.ProposerWhiteList.Empty() ||
        organization.ProposerWhiteList.AnyDuplicate() ||
        organization.OrganizationMemberList.Empty() ||
        organization.OrganizationMemberList.AnyDuplicate() ||
        organization.OrganizationMemberList.Count() > MaxOrganizationMembers) // Add maximum size check
        return false;
    
    // ... rest of validation
}
```

Additionally, consider using a more efficient data structure (e.g., HashSet) for member lookups if protobuf schema can be updated, or implement caching mechanisms to avoid repeated O(n) searches during threshold validation.

## Proof of Concept

```csharp
[Fact]
public async Task DOS_Attack_Via_Large_Member_List()
{
    // Create an organization with 3000 members (approaching state size limit)
    var memberList = new OrganizationMemberList();
    for (int i = 0; i < 3000; i++)
    {
        memberList.OrganizationMembers.Add(SampleAddress.AddressList[i % 10]); // Reuse addresses for testing
    }
    
    var createInput = new CreateOrganizationInput
    {
        OrganizationMemberList = memberList,
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1,
            MinimalVoteThreshold = 1,
            MaximalRejectionThreshold = 3000,
            MaximalAbstentionThreshold = 3000
        },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { DefaultSender } }
    };
    
    // Organization creation succeeds (no size validation)
    var organizationAddress = await AssociationContractStub.CreateOrganization.SendAsync(createInput);
    organizationAddress.Output.ShouldNotBeNull();
    
    // Create a proposal
    var proposalId = await CreateProposalAsync(organizationAddress.Output);
    
    // Attempt to vote - should fail with branch threshold exceeded
    var approveResult = await AssociationContractStub.Approve.SendWithExceptionAsync(proposalId);
    approveResult.TransactionResult.Error.ShouldContain("RuntimeBranchThresholdExceededException");
    
    // Attempt to check proposal status - should also fail
    var getProposalResult = await AssociationContractStub.GetProposal.CallWithExceptionAsync(proposalId);
    getProposalResult.ShouldContain("RuntimeBranchThresholdExceededException");
}
```

### Citations

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** contract/AElf.Contracts.Association/Association_Extensions.cs (L24-27)
```csharp
    public static bool AnyDuplicate(this OrganizationMemberList organizationMemberList)
    {
        return organizationMemberList.OrganizationMembers.GroupBy(m => m).Any(g => g.Count() > 1);
    }
```
