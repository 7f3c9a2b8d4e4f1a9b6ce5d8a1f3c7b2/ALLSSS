# Audit Report

## Title
Missing Miner List Validation in NextTerm Allows Consensus Breakdown via Empty RealTimeMinersInformation

## Summary
The `NextTerm` method in the AEDPoS consensus contract accepts externally-provided `NextTermInput` without validating that `RealTimeMinersInformation` contains any miners. A malicious current miner can submit a transaction with an empty miner map that passes all validation checks, resulting in zero authorized block producers for the next term and permanent blockchain halt.

## Finding Description

The vulnerability exists in the term transition flow where the consensus contract processes `NextTermInput` from transaction data without validating the integrity of the miner list field.

**Entry Point**: The public `NextTerm` method accepts input directly from transaction protobuf deserialization. [1](#0-0) 

**Root Cause**: In `ProcessNextTerm`, the miner list is constructed directly from the input's `RealTimeMinersInformation.Keys` without any validation that this map contains entries. [2](#0-1) 

The protobuf schema permits an empty map for `real_time_miners_information`. [3](#0-2) 

**Insufficient Validation**: The validation layer only verifies sequential term and round number increments, with no check for miner list content. [4](#0-3) 

**Authorization Bypass**: `PreCheck` only validates that the transaction sender is in the current or previous miner list, not the validity of the input data. [5](#0-4) 

**State Corruption Path**: `SetMinerList` stores the provided list without validating it is non-empty, only checking if the term was already initialized. [6](#0-5) 

The corrupted round state is persisted via `AddRoundInformation`. [7](#0-6) 

**Consensus Breakdown**: After the malicious transaction executes, `MiningPermissionValidationProvider` will reject all future block production attempts because no public key exists in the empty `RealTimeMinersInformation.Keys` set. [8](#0-7) 

## Impact Explanation

**Severity: CRITICAL**

This vulnerability breaks the fundamental consensus invariant that there must always be authorized miners capable of producing blocks. Once exploited:

1. **Complete Blockchain Halt**: Zero miners are authorized to produce blocks for the corrupted term. All block production attempts fail validation.

2. **Permanent Damage**: No recovery mechanism exists within the protocol. Previous round miners cannot produce blocks because `MiningPermissionValidationProvider` validates against the current round's (now empty) miner list. No `NextRound`, `UpdateValue`, or `TinyBlock` transactions can be processed. A subsequent `NextTerm` cannot be submitted because it requires passing `MiningPermissionValidationProvider`.

3. **Total Service Disruption**: No transactions can be processed, no cross-chain operations execute, all dApps become unavailable, miners lose rewards, users cannot transact.

4. **Hard Fork Required**: Recovery requires off-chain coordination and a hard fork to restore consensus state.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Prerequisites**:
- Must be a current active miner (passes `PreCheck` authorization)
- Can generate valid VRF proof for `random_number` field (standard miner capability)

**Attack Complexity: LOW**
1. Construct `NextTermInput` with correct `term_number` (current + 1) and `round_number` (current + 1)
2. Set `real_time_miners_information` to empty map `{}`
3. Generate valid VRF proof using standard miner cryptographic capabilities
4. Submit as a regular transaction during any block before natural term transition

**Feasibility Assessment**:
- No special conditions or timing requirements beyond current miner status
- Transaction appears valid to all nodes and passes all validation providers
- No detection mechanisms exist to identify the malicious payload
- If included in a block before the legitimate term transition, it executes first and corrupts state
- Attack cost is only transaction fees (minimal economic barrier)

**Economic Rationality**: A malicious, compromised, or disgruntled miner can execute this attack to halt the blockchain for griefing, extortion, or competitive advantage scenarios.

## Recommendation

Add explicit validation in `ProcessNextTerm` to ensure the miner list is non-empty:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // Add validation: miner list must not be empty
    Assert(nextRound.RealTimeMinersInformation.Count > 0, 
           "Miner list cannot be empty for term transition.");
    
    RecordMinedMinerListOfCurrentRound();
    // ... rest of method
}
```

Additionally, consider adding validation in `RoundTerminateValidationProvider.ValidationForNextTerm`:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Validate term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // Add validation: miner list must not be empty
    if (extraData.Round.RealTimeMinersInformation.Count == 0)
        return new ValidationResult { Message = "Miner list cannot be empty for term transition." };

    return new ValidationResult { Success = true };
}
```

## Proof of Concept

```csharp
[Fact]
public async Task NextTerm_WithEmptyMinerList_CausesConsensusBreakdown()
{
    // Setup: Initialize consensus with normal miner list
    var normalMiners = await InitializeConsensusWithMiners(5);
    var currentRound = await GetCurrentRoundInformation();
    var currentTermNumber = await GetCurrentTermNumber();
    
    // Attack: Malicious miner crafts NextTermInput with empty miner list
    var maliciousInput = new NextTermInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentTermNumber + 1,
        RealTimeMinersInformation = {}, // Empty map
        RandomNumber = GenerateValidVRFProof(), // Valid VRF proof
        // ... other required fields with valid values
    };
    
    // Execute malicious transaction (as current miner)
    var result = await AEDPoSContractStub.NextTerm.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Transaction succeeds
    
    // Verify: Next term has zero miners
    var newRound = await GetCurrentRoundInformation();
    newRound.RealTimeMinersInformation.Count.ShouldBe(0); // Miner list is empty
    
    // Verify: Blockchain is halted - no miner can produce blocks
    foreach (var miner in normalMiners)
    {
        var updateValueResult = await miner.UpdateValue.SendAsync(CreateValidUpdateValueInput());
        updateValueResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        updateValueResult.TransactionResult.Error.ShouldContain("is not a miner"); // MiningPermissionValidationProvider rejects
    }
    
    // Consensus is permanently broken - no recovery possible
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** protobuf/aedpos_contract.proto (L484-490)
```text
message NextTermInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
