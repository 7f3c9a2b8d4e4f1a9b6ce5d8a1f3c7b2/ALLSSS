# Audit Report

## Title
Insufficient Address Validation in Governance Contracts Enables Griefing Attack via Unexecutable Proposals

## Summary
The Association, Parliament, and Referendum governance contracts validate only that `ToAddress` is not null, failing to check if the internal `Value` byte array is empty or valid. This allows whitelisted proposers to create proposals with invalid addresses that pass validation but fail during inline transaction execution, leaving approved proposals permanently stuck in state until expiry.

## Finding Description

All three governance contracts implement insufficient address validation that only checks for null object references rather than validating the internal byte array content:

**Association Contract Validation:**
The `Validate(ProposalInfo proposal)` method only checks if the ToAddress object is null, not if its internal Value is empty. [1](#0-0) 

**Parliament Contract Validation:**
Parliament uses the same insufficient null-only check pattern. [2](#0-1) 

**Referendum Contract Validation:**
Referendum also only validates null references without checking the Value field. [3](#0-2) 

**Proper Validation Pattern:**
The codebase contains the correct validation pattern in TokenContract that checks both the object reference AND the internal Value field. [4](#0-3) 

**Address Protobuf Structure:**
The Address type is defined as a simple wrapper around a bytes field, which can be empty in protobuf. [5](#0-4) 

**Attack Flow:**

1. A whitelisted proposer creates a proposal with `new Address() { Value = ByteString.Empty }`
2. Validation passes during CreateProposal in all three contracts since they only check `!= null` [6](#0-5) 
3. Organization members vote and approve the proposal normally
4. When Release is called, validation passes again [7](#0-6) 
5. SendVirtualInlineBySystemContract creates an inline transaction with the invalid address [8](#0-7) 
6. During execution, GetExecutiveAsync attempts to get the executive for the invalid address and throws SmartContractFindRegistrationException [9](#0-8) [10](#0-9) 
7. The inline trace is marked unsuccessful, breaking execution [11](#0-10) 
8. Failed traces only have pre/post plugin state changes applied, not the main transaction's state changes [12](#0-11) 
9. The parent trace is marked as unsuccessful [13](#0-12) 
10. The `State.Proposals.Remove(input)` never persists, leaving the proposal in an approved but permanently unexecutable state until expiry

## Impact Explanation

**Governance Denial of Service**: Organizations lose the ability to execute approved proposals, disrupting critical governance operations including protocol upgrades, treasury management, and parameter changes. Members waste significant time and effort reviewing, voting on, and attempting to execute proposals that can never succeed.

**Resource Waste**: Approved proposals remain stuck in contract state consuming storage until their expiration time (potentially days or weeks later), preventing efficient governance operations and creating confusion about which proposals are actually executable.

**Repeated Griefing**: Any whitelisted proposer can create multiple such proposals simultaneously, overwhelming the organization with unexecutable proposals and forcing them to wait for each to expire naturally.

**Trust Erosion**: Repeated failures to execute approved proposals damage member confidence in the governance system, potentially causing members to disengage from governance activities.

The severity is **Medium** because while it does not directly steal funds or compromise token supplies, it significantly disrupts critical governance infrastructure that controls protocol upgrades, treasury management, and other essential operations.

## Likelihood Explanation

**Attacker Requirements**: The attacker must be in the organization's proposer whitelist. While this is a barrier, it is realistic in multi-organization ecosystems where various parties participate in governance (DAOs, protocol partners, delegates, etc.).

**Attack Complexity**: The attack is trivial to executeâ€”simply instantiate an Address with `Value = ByteString.Empty` when creating a proposal. No complex state manipulation, precise timing, or special conditions are required.

**Detection Difficulty**: The issue is difficult to detect before Release execution because the validation consistently passes at both creation and release time. Organization members have no way to identify such proposals before voting.

**Economic Feasibility**: The attack costs only standard transaction fees, making sustained griefing campaigns economically viable.

**Reproducibility**: The attack works consistently under normal operational conditions with no special preconditions needed.

The likelihood is **Medium** due to the low technical barrier and the realistic attacker profile of a malicious whitelisted proposer.

## Recommendation

Update the `Validate(ProposalInfo proposal)` method in all three governance contracts to use the same validation pattern as TokenContract:

```csharp
private bool Validate(ProposalInfo proposal)
{
    // Check both null reference AND empty Value
    if (proposal.ToAddress == null || proposal.ToAddress.Value.IsNullOrEmpty() || 
        string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
        !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
        return false;

    return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
}
```

This change should be applied to:
- `contract/AElf.Contracts.Association/Association_Helper.cs`
- `contract/AElf.Contracts.Parliament/Parliament_Helper.cs`
- `contract/AElf.Contracts.Referendum/Referendum_Helper.cs`

## Proof of Concept

```csharp
[Fact]
public async Task CreateProposal_WithEmptyAddressValue_ShouldFail()
{
    // Create organization
    var organizationAddress = await CreateOrganizationAsync();
    
    // Create proposal with Address that has empty Value
    var invalidAddress = new Address { Value = ByteString.Empty };
    
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress,
        ToAddress = invalidAddress, // Non-null but invalid
        ContractMethodName = "TestMethod",
        Params = ByteString.Empty,
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
    };
    
    // This SHOULD fail but currently PASSES validation
    var proposalId = await AssociationContractStub.CreateProposal.SendAsync(proposalInput);
    proposalId.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Approve the proposal
    await ApproveProposalAsync(proposalId.Output);
    
    // Attempt to release - this will FAIL during inline execution
    var releaseResult = await AssociationContractStub.Release.SendAsync(proposalId.Output);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    
    // Proposal remains in state (not removed)
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId.Output);
    proposal.ProposalId.ShouldBe(proposalId.Output); // Still exists!
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L145-172)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId,
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L157-166)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = CheckProposalNotExpired(proposal);
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L110-119)
```csharp
        if (!trace.IsSuccessful())
        {
            var transactionExecutingStateSets = new List<TransactionExecutingStateSet>();

            AddToTransactionStateSets(transactionExecutingStateSets, trace.PreTraces);
            AddToTransactionStateSets(transactionExecutingStateSets, trace.PostTraces);

            groupStateCache.Update(transactionExecutingStateSets);
            trace.SurfaceUpError();
        }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L149-161)
```csharp
        IExecutive executive;
        try
        {
            executive = await _smartContractExecutiveService.GetExecutiveAsync(
                internalChainContext,
                singleTxExecutingDto.Transaction.To);
        }
        catch (SmartContractFindRegistrationException)
        {
            txContext.Trace.ExecutionStatus = ExecutionStatus.ContractError;
            txContext.Trace.Error += "Invalid contract address.\n";
            return trace;
        }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L241-243)
```csharp
            if (!inlineTrace.IsSuccessful())
                // Already failed, no need to execute remaining inline transactions
                break;
```

**File:** src/AElf.Kernel.SmartContract/Application/SmartContractExecutiveService.cs (L196-197)
```csharp
        throw new SmartContractFindRegistrationException(
            $"failed to find registration from zero contract {txContext.Trace.Error}");
```

**File:** src/AElf.Kernel.Core/Extensions/TransactionTraceExtensions.cs (L8-19)
```csharp
    public static bool IsSuccessful(this TransactionTrace txTrace)
    {
        if (txTrace.ExecutionStatus != ExecutionStatus.Executed) return false;

        if (txTrace.PreTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.InlineTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.PostTraces.Any(trace => !trace.IsSuccessful())) return false;

        return true;
    }
```
