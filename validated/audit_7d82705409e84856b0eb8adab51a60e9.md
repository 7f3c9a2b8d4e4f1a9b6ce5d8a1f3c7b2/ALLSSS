# Audit Report

## Title 
Blockchain Start Timestamp Manipulation via Unvalidated ActualMiningTime in Round 1

## Summary
The first miner in round 1 can provide an arbitrary future timestamp as `ActualMiningTime` in their `UpdateValue` transaction without validation, which becomes the permanent blockchain start timestamp. This corrupts all subsequent term transition calculations, affecting critical governance operations including treasury releases and election snapshots.

## Finding Description

The vulnerability exists in the consensus timestamp initialization flow during round 1, where a malicious validator can manipulate the blockchain start timestamp through unvalidated transaction input.

**Root Cause:** The `ProcessUpdateValue` method directly stores the user-provided `ActualMiningTime` from `UpdateValueInput` without validating it matches `Context.CurrentBlockTime`. [1](#0-0) 

**Validation Bypass:** During round 1, `TimeSlotValidationProvider.CheckMinerTimeSlot` returns `true` immediately via `IsFirstRoundOfCurrentTerm` check without performing any timestamp validation, allowing arbitrary timestamps to pass through. [2](#0-1)  The condition `validationContext.CurrentRoundNumber == 1` causes early return. [3](#0-2) 

**Missing Validation:** The validation pipeline for `UpdateValue` behavior includes `UpdateValueValidationProvider`, which validates `OutValue`, `Signature`, and `PreviousInValue` fields but never checks `ActualMiningTime`. [4](#0-3) 

**Hash Verification Bypass:** The round hash verification in `ValidateConsensusAfterExecution` uses `GetCheckableRound`, which explicitly clears `ActualMiningTimes` before computing the hash. [5](#0-4)  This means manipulated timestamps in the transaction parameter won't be detected by hash comparison with the consensus extra data.

**Permanent Impact:** During the round 1 to round 2 transition, `ProcessNextRound` permanently sets the blockchain start timestamp using the first miner's first `ActualMiningTime` value. [6](#0-5)  This stored value is then used by `NeedToChangeTerm` for all future term transition calculations. [7](#0-6) 

**Attack Vector:** A malicious first-round validator can modify their consensus node software to intercept the `UpdateValue` transaction generation (which extracts `ActualMiningTime` from round data [8](#0-7) ), modify the `ActualMiningTime` field to a future date, and include the modified transaction in their block. The consensus extra data generation correctly uses `Context.CurrentBlockTime` [9](#0-8) , but the state update uses the transaction parameter value, creating an exploitable discrepancy.

## Impact Explanation

**Term Transition Disruption:** The `IsTimeToChangeTerm` function calculates whether to change terms using: `(blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1`. [10](#0-9)  With a future blockchain start timestamp, this subtraction produces negative values for an extended period, breaking term boundary detection and causing either premature or indefinitely delayed term transitions.

**Governance Impact:** Term transitions trigger critical governance operations. During `ProcessNextTerm`, the system releases treasury funds and takes election snapshots. [11](#0-10)  Disrupted term timing affects:
- Treasury fund release schedules (funds trapped or released at wrong times)
- Election snapshot timing (incorrect vote weight calculations)
- Miner reward distribution cycles

**Consensus Behavior:** The blockchain start timestamp is used by `MainChainConsensusBehaviourProvider` to determine whether to return `NextRound` or `NextTerm` behavior. [12](#0-11)  A manipulated timestamp disrupts this decision logic for the entire blockchain lifecycle.

## Likelihood Explanation

**Attacker Profile:** Any validator scheduled as the first block producer in round 1 can execute this attack. This represents a realistic mis-scoped privilege scenario where a validator (trusted to produce blocks) should not be able to manipulate the blockchain start timestamp, a critical system parameter.

**Attack Complexity:** The attack requires modifying the consensus node software to intercept transaction generation and modify the `ActualMiningTime` field. While this requires technical capability, it is straightforward for a validator with access to their node software and requires no cryptographic operations or multi-step coordination.

**Execution Barriers:** The attack has minimal barriers because:
- No existing validator checks `ActualMiningTime` against `Context.CurrentBlockTime`
- Round 1 exemption bypasses time slot validation
- Hash verification explicitly excludes `ActualMiningTimes` from comparison
- Single transaction achieves permanent impact

**Detection Difficulty:** The manipulated timestamp is only visible in stored contract state and has no mechanism for verification against real-world time or `Context.CurrentBlockTime`, making detection extremely difficult until term transition issues manifest.

## Recommendation

Add explicit validation in `ProcessUpdateValue` to ensure the provided `ActualMiningTime` matches `Context.CurrentBlockTime`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // Add validation: ActualMiningTime must match CurrentBlockTime
    Assert(updateValueInput.ActualMiningTime == Context.CurrentBlockTime,
        "ActualMiningTime must match Context.CurrentBlockTime");
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
    // ... rest of method
}
```

Alternatively, ignore the user-provided value entirely and use `Context.CurrentBlockTime` directly:

```csharp
minerInRound.ActualMiningTimes.Add(Context.CurrentBlockTime);
```

## Proof of Concept

A test demonstrating this vulnerability would:
1. Initialize a blockchain with round 1
2. Have the first miner submit an `UpdateValue` transaction with `ActualMiningTime` set to a future date (e.g., current time + 1 year)
3. Verify the transaction succeeds (no validation failure)
4. Transition to round 2 via `NextRound`
5. Verify `State.BlockchainStartTimestamp.Value` equals the manipulated future timestamp
6. Demonstrate that `NeedToChangeTerm` produces incorrect results due to negative time calculations

The core vulnerability is that step 3 succeeds when it should fail, and step 5 shows the permanent corruption of the blockchain start timestamp.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L117-123)
```csharp
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-218)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L53-58)
```csharp
    private bool IsFirstRoundOfCurrentTerm(out long termNumber, ConsensusValidationContext validationContext)
    {
        termNumber = validationContext.CurrentTermNumber;
        return validationContext.PreviousRound.TermNumber != termNumber ||
               validationContext.CurrentRoundNumber == 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L239-243)
```csharp
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L42-42)
```csharp
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```
