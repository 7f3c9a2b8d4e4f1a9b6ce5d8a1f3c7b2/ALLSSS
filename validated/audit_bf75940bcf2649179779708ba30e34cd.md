# Audit Report

## Title
Missing On-Chain Validation of SupposedOrderOfNextRound Allows Miners to Manipulate Next Round Position

## Summary
The `SupposedOrderOfNextRound` field in `UpdateValueInput` is not validated on-chain against its deterministic calculation formula. Miners can submit arbitrary order values that are accepted without verification, allowing manipulation of their position in the next mining round and breaking the fairness of the AEDPoS consensus ordering mechanism.

## Finding Description

The AEDPoS consensus protocol is designed to deterministically calculate each miner's position in the next round based on their signature hash. The calculation formula is defined as `GetAbsModulus(sigNum, minersCount) + 1` where `sigNum` is derived from the miner's signature hash. [1](#0-0) 

This calculation is performed off-chain during block generation in the `GetConsensusExtraData` view method, which calls `ApplyNormalConsensusData`. [2](#0-1)  However, this calculation is never validated on-chain when miners submit their consensus data.

**Root Cause:**

When miners submit consensus data via `UpdateValue`, the validation provider only checks that `OutValue` and `Signature` are present, and that `PreviousInValue` is correct. [3](#0-2)  It does not recalculate or verify `SupposedOrderOfNextRound` against the signature.

**Why Protections Fail:**

1. **Direct assignment without validation**: The `ProcessUpdateValue` method directly assigns the provided `SupposedOrderOfNextRound` value to state without any verification. [4](#0-3) 

2. **Circular validation**: The `RecoverFromUpdateValue` method simply copies the order values from the provided round during validation, creating circular logic where the system validates that state matches the header, but both were derived from the same unvalidated input. [5](#0-4) 

3. **Inadequate order validation**: The `NextRoundMiningOrderValidationProvider` only validates the COUNT of miners with orders matches those who mined blocks, not the correctness of the actual order values. [6](#0-5) 

4. **Next round uses manipulated values**: The next round mining order is determined using `FinalOrderOfNextRound` values (which are initialized from the unvalidated `SupposedOrderOfNextRound`), directly affecting miner scheduling. [7](#0-6) 

## Impact Explanation

This vulnerability directly violates the consensus integrity invariant by allowing miners to arbitrarily choose their position in the next mining round. A malicious miner can:

1. **Always position themselves first (order = 1)** to maximize MEV extraction opportunities
2. **Coordinate with other malicious miners** to arrange favorable consecutive positions
3. **Manipulate transaction ordering** for censorship or front-running
4. **Gain unfair advantages** in block production timing and rewards

The deterministic ordering mechanism, which should derive unpredictability from miners' signatures, becomes meaningless when miners can simply submit any order value they desire. This breaks the fundamental fairness guarantee of the AEDPoS consensus.

Additionally, miners can manipulate not just their own order but also other miners' orders through the `TuneOrderInformation` field. [8](#0-7)  The last miner(s) in each round have maximum control to set the order for the entire next round.

**Impact: HIGH** - Consensus integrity violation with systemic fairness implications.

## Likelihood Explanation

Any active miner can exploit this vulnerability with minimal effort:

**Attack Steps:**
1. Run standard miner infrastructure (already possessed)
2. Modify off-chain consensus data generation (after `ExtractInformationToUpdateConsensus` is called) to set `SupposedOrderOfNextRound` to desired value (e.g., always 1). [9](#0-8) 
3. Generate valid signature for the block (normal mining operation)
4. Submit `UpdateValue` transaction with manipulated order value
5. Validation passes because it only checks signature/OutValue, not order calculation

**Feasibility:**
- No special privileges required beyond being an active miner
- Simple code modification in off-chain data generation
- No detection mechanism exists to identify manipulation
- The validation logic uses circular recovery that doesn't recalculate the formula [10](#0-9) 

**Economic Rationality:**
- Attack cost: Negligible (standard block production cost)
- Benefits: MEV extraction, censorship power, competitive advantages
- Risk: None (no on-chain detection or penalty mechanism)

**Likelihood: HIGH** - Trivial to execute for any miner with clear economic incentives.

## Recommendation

Add validation in `UpdateValueValidationProvider` to recalculate and verify `SupposedOrderOfNextRound`:

```csharp
private bool ValidateSupposedOrderOfNextRound(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var minersCount = validationContext.BaseRound.RealTimeMinersInformation.Count;
    var sigNum = minerInRound.Signature.ToInt64();
    var expectedOrder = GetAbsModulus(sigNum, minersCount) + 1;
    
    return minerInRound.SupposedOrderOfNextRound == expectedOrder;
}

private static int GetAbsModulus(long longValue, int intValue)
{
    return (int)Math.Abs(longValue % intValue);
}
```

Then add this check in `ValidateHeaderInformation` method before returning success.

## Proof of Concept

```csharp
[Fact]
public async Task MinerCanManipulateNextRoundOrder_Vulnerability()
{
    // Initialize consensus and get first round
    await InitializeContracts();
    await InitializeCandidates();
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Get first miner info
    var firstMiner = firstRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order).First();
    var minerKeyPair = InitialCoreDataCenterKeyPairs.First(p => p.PublicKey.ToHex() == firstMiner.Pubkey);
    
    // Generate legitimate consensus data
    var triggerInfo = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(minerKeyPair.PublicKey),
        InValue = HashHelper.ComputeFrom("test")
    };
    
    var extraData = await AEDPoSContractStub.GetConsensusExtraData.CallAsync(triggerInfo.ToBytesValue());
    var headerInfo = extraData.ToConsensusHeaderInformation();
    
    // Extract update value input
    var updateInput = headerInfo.Round.ExtractInformationToUpdateConsensus(firstMiner.Pubkey, ByteString.Empty);
    
    // Calculate what the order SHOULD be based on signature
    var sigNum = updateInput.Signature.ToInt64();
    var minersCount = firstRound.RealTimeMinersInformation.Count;
    var expectedOrder = Math.Abs((int)(sigNum % minersCount)) + 1;
    
    // ATTACK: Manipulate the order to always be 1 (or any desired position)
    updateInput.SupposedOrderOfNextRound = 1; // Malicious value, not calculated from signature
    
    // Set block time and submit manipulated update
    BlockTimeProvider.SetBlockTime(firstMiner.ExpectedMiningTime);
    var minerStub = GetAEDPoSContractStub(minerKeyPair);
    
    // This should fail validation but DOESN'T - the vulnerability
    var result = await minerStub.UpdateValue.SendAsync(updateInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Passes when it shouldn't
    
    // Verify the manipulated order was accepted
    var updatedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var updatedMiner = updatedRound.RealTimeMinersInformation[firstMiner.Pubkey];
    
    // The manipulated order (1) is stored instead of the calculated order
    updatedMiner.SupposedOrderOfNextRound.ShouldBe(1); // Manipulated value accepted
    updatedMiner.SupposedOrderOfNextRound.ShouldNotBe(expectedOrder); // Not the legitimate calculated value
    
    // This proves miners can manipulate their position in next round
}
```

## Notes

The vulnerability exists because the consensus contract trusts the `SupposedOrderOfNextRound` value provided by miners without verifying it against the deterministic formula. The formula itself is correctly implemented in `Round.ApplyNormalConsensusData` and used during off-chain block generation, but this calculation is never re-performed during on-chain validation. This creates a trust-but-don't-verify scenario where the security property depends on miners being honest, which violates the fundamental principle of consensus protocols.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L24-27)
```csharp
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-20)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L43-43)
```csharp
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```
