# Audit Report

## Title
ProposerWhiteList Validation Bypass Allows Creation of Permanently Bricked Referendum Organizations

## Summary
The Referendum contract fails to validate that addresses in the ProposerWhiteList contain non-empty value fields, allowing attackers to create organizations with malformed addresses that permanently prevent proposal creation, resulting in complete denial-of-service of governance functionality.

## Finding Description

The vulnerability exists in the organization validation logic that only performs a count-based check on the ProposerWhiteList without validating individual address values. [1](#0-0) 

The validation uses the `Empty()` extension method which only checks if the list count is zero. [2](#0-1) 

The Address protobuf message structure allows empty bytes values since proto3 does not enforce non-empty constraints on bytes fields. [3](#0-2) 

The correct validation pattern exists in the TokenContract, which checks both that the Address object is not null AND that its Value field is not empty. [4](#0-3) 

**Attack Execution:**

1. Attacker crafts a CreateOrganizationInput with ProposerWhiteList containing Address objects with empty value fields
2. The organization is created via the public CreateOrganization() method [5](#0-4) 
3. When legitimate users attempt to create proposals, AssertIsAuthorizedProposer() is invoked [6](#0-5) 
4. The authorization check uses Contains() to verify the proposer is in the whitelist [7](#0-6) 
5. The Contains() method relies on protobuf equality comparison [8](#0-7) 
6. Valid addresses (with 32-byte values) never equal addresses with empty byte values, causing all proposal creation attempts to fail permanently

## Impact Explanation

This vulnerability enables complete and permanent denial-of-service of governance functionality for affected Referendum organizations. Once an organization is created with malformed addresses in the ProposerWhiteList, no legitimate user can ever create proposals for that organization since the authorization check will always fail when comparing valid addresses against empty-valued addresses.

While this attack does not result in direct fund loss, governance functionality is critical for protocol operations. Organizations relying on Referendum-based governance for parameter updates, upgrades, or treasury management would lose this capability entirely. The impact is permanent unless the contract is upgraded, as there is no mechanism to fix already-created organizations with invalid whitelists.

## Likelihood Explanation

The likelihood is medium-to-high based on the following factors:

**Attacker Capabilities:** Any user can call the public CreateOrganization() method without special permissions. The attacker must understand protobuf message structure to craft Address objects with empty value fields, which requires medium technical knowledge but is achievable with standard protobuf libraries.

**Attack Complexity:** The malformed input passes through contract validation because the Empty() check only verifies count > 0, not individual address validity. No transaction-level validation prevents addresses with empty value fields from being accepted.

**Economic Rationality:** The attack cost is minimal (only transaction gas fees). While there is no direct economic benefit to the attacker, this enables griefing attacks against specific governance organizations or prevents legitimate governance operations from functioning.

**Detection:** Bricked organizations would only be discovered when the first proposal creation attempt fails. There is no proactive detection mechanism to identify organizations with invalid whitelists before they are used.

## Recommendation

Add individual address validation in the organization validation logic. The fix should check each address in the ProposerWhiteList to ensure it contains a non-empty value field:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    // Add validation for each address in the whitelist
    foreach (var proposer in organization.ProposerWhiteList.Proposers)
    {
        if (proposer == null || proposer.Value.IsNullOrEmpty())
            return false;
    }
    
    Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");
    
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

Alternatively, create a helper method similar to TokenContract's `AssertValidInputAddress` and use it consistently throughout the codebase.

## Proof of Concept

```csharp
[Fact]
public async Task ProposerWhiteList_EmptyAddressValue_DoS_Test()
{
    // Create an organization with an empty Address value in ProposerWhiteList
    var createOrganizationInput = new CreateOrganizationInput
    {
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1,
            MinimalVoteThreshold = 1,
            MaximalAbstentionThreshold = 1000,
            MaximalRejectionThreshold = 1000
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { new Address() } // Empty Address with no value set
        },
        TokenSymbol = "ELF"
    };
    
    // Organization creation succeeds (validation only checks count > 0)
    var result = await ReferendumContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    var organizationAddress = result.Output;
    organizationAddress.ShouldNotBeNull();
    
    // Attempt to create a proposal with a valid proposer address
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress,
        ContractMethodName = "Transfer",
        ToAddress = TokenContractAddress,
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(1),
        Params = new TransferInput { To = DefaultSender, Symbol = "ELF", Amount = 100 }.ToByteString()
    };
    
    // Proposal creation fails because valid address doesn't match empty address
    var exception = await Assert.ThrowsAsync<Exception>(() => 
        ReferendumContractStub.CreateProposal.SendAsync(proposalInput));
    exception.Message.ShouldContain("Unauthorized to propose");
    
    // Organization is permanently bricked - no one can ever create proposals
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L18-21)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-40)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");

        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;

        State.Organizations[organizationAddress] = organization;
        Context.Fire(new OrganizationCreated
        {
            OrganizationAddress = organizationAddress
        });

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```
