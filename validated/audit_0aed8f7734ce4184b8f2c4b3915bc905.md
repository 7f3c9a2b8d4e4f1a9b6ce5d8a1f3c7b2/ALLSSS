# Audit Report

## Title
Proposer Whitelist Bypass - Removed Proposers Can Execute Approved Proposals

## Summary
The `Release` method in Association, Parliament, and Referendum contracts only validates that the caller is the original proposer without re-checking if the proposer is still in the organization's whitelist. This allows proposers who have been removed from the whitelist to retain execution authority for previously approved proposals, completely bypassing the whitelist authorization mechanism.

## Finding Description

The vulnerability exists in the authorization logic across all three governance contracts. When a proposal is created, the system validates that the proposer is in the whitelist by calling `AssertIsAuthorizedProposer` [1](#0-0)  which checks if the proposer is in the organization's `ProposerWhiteList` [2](#0-1) .

However, when releasing an approved proposal, the authorization check is insufficient. The `Release` method only verifies that the caller is the original proposer [3](#0-2)  without re-validating whether the proposer is still in the current whitelist.

Organizations can update their proposer whitelist at any time through `ChangeOrganizationProposerWhiteList` [4](#0-3) . This creates a critical authorization gap: once a proposer creates and gets approval for a proposal, they retain the ability to execute it even after being explicitly removed from the whitelist.

The same vulnerability pattern exists in Parliament [5](#0-4)  and Referendum [6](#0-5)  contracts, where the `Release` methods similarly check only the proposer identity without whitelist revalidation.

## Impact Explanation

**Authorization Bypass - HIGH Severity**: Organizations use the proposer whitelist as a critical security control to manage who can interact with their governance. Removing a proposer from the whitelist via `ChangeOrganizationProposerWhiteList` is an explicit revocation of trust and authority. However, this control is completely ineffective for existing proposals - removed proposers retain full execution rights.

**Real-World Harm Scenarios**:

1. **Compromised Account**: When a legitimate proposer's account is compromised, the organization removes them from the whitelist immediately. However, the attacker can still execute any approved proposals, potentially draining funds or changing critical configurations.

2. **Malicious Proposer Discovery**: If a proposer's malicious intent is discovered after their proposal was approved (through social engineering, parameter obfuscation, or deceptive descriptions), removing them from the whitelist does not prevent execution.

3. **Changed Circumstances**: A previously-approved proposal becomes harmful due to changed conditions. The organization removes the proposer to prevent new harm, but cannot stop execution of the old proposal.

**Concrete Damage**: Approved proposals can execute arbitrary contract methods on behalf of the organization using `SendVirtualInlineBySystemContract`, including fund transfers, contract upgrades, permission changes, and other privileged operations. Organizations have no mechanism to revoke release rights for approved but not-yet-expired proposals, as `ClearProposal` only works after expiration [7](#0-6) .

## Likelihood Explanation

**HIGH Likelihood**: The exploit requires no special technical capabilities:

**Attacker Requirements**:
- Must initially be in the proposer whitelist (normal operational state)
- Must create a proposal that gets approved by organization members
- No special exploits or economic resources required

**Attack Complexity - LOW**:
1. Create proposal while whitelisted (validated via `AssertIsAuthorizedProposer`)
2. Wait for member approval through normal voting process
3. After being removed from whitelist via `ChangeOrganizationProposerWhiteList`, call `Release` method
4. The method executes because it only checks `Context.Sender == proposalInfo.Proposer`, not the current whitelist

**Feasibility**: The scenarios triggering this (account compromise, discovered malicious intent, organizational changes) are realistic operational events that organizations must handle. The attack window extends from approval until expiration (typically days), with no race conditions needed. Organizations cannot defend against this as there is no proposal cancellation mechanism before expiration.

## Recommendation

Add whitelist revalidation in the `Release` method before executing the proposal. The fix should be applied to all three governance contracts:

**For Association Contract:**
In the `Release` method, add a call to `AssertIsAuthorizedProposer` before executing the proposal to verify the proposer is still in the current whitelist.

**For Parliament Contract:**
Similarly, add whitelist validation in the `Release` method to ensure the proposer still has authorization.

**For Referendum Contract:**
Add the same whitelist check in the `Release` method to maintain consistent authorization semantics.

This ensures that whitelist removal immediately revokes all execution privileges, including for previously approved proposals, aligning the implementation with the security model's intent.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task RemovedProposerCanStillReleaseApprovedProposal()
{
    // 1. Create organization with proposer in whitelist
    var proposer = SampleAccount.Accounts[0].Address;
    var organization = await CreateOrganizationWithProposer(proposer);
    
    // 2. Proposer creates a proposal
    var proposalId = await CreateProposalAsProposer(proposer, organization);
    
    // 3. Organization members approve the proposal
    await ApproveProposalByMembers(proposalId);
    
    // 4. Organization removes proposer from whitelist
    await RemoveProposerFromWhitelist(organization, proposer);
    
    // 5. Removed proposer can still release the approved proposal
    // This should fail but currently succeeds
    var result = await ReleaseProposalAsProposer(proposer, proposalId);
    
    // Vulnerability: Release succeeds even though proposer is no longer in whitelist
    result.Status.ShouldBe(TransactionResultStatus.Mined); // Currently passes - VULNERABILITY
}
```

**Notes**

This vulnerability breaks the fundamental security guarantee that whitelist removal should revoke all proposer authority. The issue affects all three governance contracts (Association, Parliament, Referendum) identically, as they share the same flawed authorization pattern in their `Release` methods. While the whitelist check is properly enforced at proposal creation time, the lack of revalidation at execution time creates a persistent authorization that survives explicit trust revocations.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```
