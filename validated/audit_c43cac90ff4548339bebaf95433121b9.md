# Audit Report

## Title
Missing Validation of Other Miners' PreviousInValue Allows Mining Order Manipulation

## Summary
The AEDPoS consensus contract fails to validate `PreviousInValue` entries for other miners submitted via the `miners_previous_in_values` field in `UpdateValueInput`. A malicious miner can inject fake `PreviousInValue` for other miners, which corrupts signature calculations and mining order determination when those miners miss time slots and the secret sharing recovery mechanism fails.

## Finding Description

The vulnerability exists in a critical validation gap in the consensus update flow. When a miner submits `UpdateValueInput` during block production, they can include `PreviousInValue` entries for all miners via the `miners_previous_in_values` map field. While the legitimate design intent is to synchronize values across miners, there is no validation that these provided values match the actual cryptographic commitments of those miners.

**Validation Gap**: The `ValidatePreviousInValue` method only validates the **sender's own** `PreviousInValue` by verifying that the hash of their previous in value matches their previous out value. [1](#0-0) 

It does NOT validate entries in the `miners_previous_in_values` map for other miners. The method operates exclusively on `validationContext.SenderPubkey` and never iterates over or checks the map entries.

**Unconditional State Write**: These unvalidated values are unconditionally written to state in the `PerformSecretSharing` method without any cryptographic verification: [2](#0-1) 

The legitimate usage populates this field from current state values, but there's no enforcement that submitted values match state or the miners' actual previous outputs. [3](#0-2) 

**Exploitation Path**: When miners miss their time slots, `SupplyCurrentRoundInformation` is called during the NextRound transition to fill in missing consensus data. It retrieves the `PreviousInValue` from state for miners who didn't produce blocks: [4](#0-3) 

This potentially corrupted value is used to calculate the miner's signature: [5](#0-4) 

The signature calculation uses XOR operations over the in value and all previous signatures: [6](#0-5) 

Finally, the corrupted signature determines the mining order for the next round through a modulo operation: [7](#0-6) 

**Mitigating Factor with Gap**: While the `RevealSharedInValues` method can recover legitimate values through Shamir's Secret Sharing, it only succeeds if sufficient encrypted and decrypted pieces exist: [8](#0-7) 

When these checks fail (new miners, inconsistent participation, or insufficient piece accumulation), the fake values persist and are used in mining order calculations.

**Attack Scenario**:
1. Secret sharing is enabled on the network
2. Victim miner (B) misses their time slot in round R
3. Malicious miner (A) produces their block with a crafted `UpdateValueInput` containing fake `PreviousInValue` for B
4. Validation passes because only A's own value is checked
5. The fake value is written to state via `PerformSecretSharing`
6. Recovery via `RevealSharedInValues` fails due to insufficient encrypted/decrypted pieces
7. During NextRound transition, `SupplyCurrentRoundInformation` uses the corrupted value
8. Signature is calculated with the fake value, determining B's manipulated position in the next round

## Impact Explanation

**HIGH Impact** - This vulnerability violates fundamental consensus security guarantees:

**Consensus Determinism Violation**: Mining order should be deterministically derived from each miner's actual cryptographic commitments (InValue/OutValue chains). By allowing unvalidated manipulation of `PreviousInValue`, attackers can break this cryptographic binding and inject arbitrary values into the consensus calculation.

**Mining Order Manipulation**: The attacker can influence victim miners' positions in the next round's mining schedule. Since mining order is calculated via `GetAbsModulus(signature.ToInt64(), minersCount) + 1`, different signature values produce different mining slots, potentially giving attackers or their allies advantageous positions for extra block production or strategic timing.

**Reward Distribution Impact**: Mining order directly affects block production opportunities and thus reward distribution. Manipulating when miners produce blocks can influence who becomes the extra block producer or affect the overall fairness of block production opportunities across the consensus set.

**Protocol Security Model Compromise**: The secret sharing mechanism in AEDPoS exists specifically to provide verifiable randomness and prevent mining order manipulation. Allowing bypasses of this mechanism through unvalidated inputs undermines the protocol's core security assumptions.

While the attack requires the recovery mechanism to fail (limiting immediate exploitability), the conditions for failure are realistic: new miners lack historical encrypted pieces, miners with inconsistent uptime may not have accumulated sufficient pieces, and if many miners are offline, the 2/3 threshold for recovery cannot be met.

## Likelihood Explanation

**MODERATE Likelihood**

**Attacker Prerequisites**:
- Must be an active miner in the current consensus set (achievable through legitimate election process)
- Secret sharing must be enabled (standard production configuration)
- No additional cryptographic attacks or compromised keys required

**Attack Complexity**: LOW
- Simply submit `UpdateValueInput` with modified `miners_previous_in_values` entries
- Wait for victim to miss their time slot (natural occurrence)
- No complex timing coordination or multiple transaction sequences needed

**Realistic Preconditions**:
- Missed time slots occur naturally due to network latency, node failures, maintenance, or high load
- The recovery mechanism fails when victims lack sufficient encrypted/decrypted pieces:
  - New miners joining the consensus set have no prior pieces
  - Miners with inconsistent uptime accumulate fewer pieces
  - Network-wide issues reduce overall piece availability
  - The 2/3 threshold for decrypted pieces may not be met in degraded conditions

**Detection Difficulty**:
- No on-chain validation catches the manipulation
- Victim miners must actively monitor state and compare with their expected values
- No automatic alerts or protection mechanisms exist
- The corrupted values appear identical to legitimate synchronized values

The combination of low attack complexity, realistic preconditions (missed slots are inevitable in any distributed network), and the absence of detection mechanisms results in moderate likelihood despite the recovery mechanism's presence.

## Recommendation

Add validation for all entries in the `miners_previous_in_values` map within the `ValidatePreviousInValue` method or create a separate validation provider:

```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;

    // Validate sender's own PreviousInValue (existing logic)
    if (validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey))
    {
        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue != null &&
            extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue != Hash.Empty)
        {
            var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
            var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
            if (HashHelper.ComputeFrom(previousInValue) != previousOutValue)
                return false;
        }
    }

    // NEW: Validate all entries in MinersPreviousInValues
    if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
    {
        var updateValueInput = /* extract from extraData */;
        foreach (var entry in updateValueInput.MinersPreviousInValues)
        {
            var minerPubkey = entry.Key;
            var providedPreviousInValue = entry.Value;
            
            // Skip if empty/null (legitimate case)
            if (providedPreviousInValue == null || providedPreviousInValue == Hash.Empty)
                continue;
                
            // Verify it matches the miner's previous OutValue
            if (validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(minerPubkey))
            {
                var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[minerPubkey].OutValue;
                if (HashHelper.ComputeFrom(providedPreviousInValue) != previousOutValue)
                    return false; // Fake value detected
            }
        }
    }

    return true;
}
```

Alternatively, modify `PerformSecretSharing` to validate before writing:

```csharp
private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
    string publicKey, Round previousRound) // Add previousRound parameter
{
    minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
    foreach (var decryptedPreviousInValue in input.DecryptedPieces)
        round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
            .Add(publicKey, decryptedPreviousInValue.Value);

    // MODIFIED: Validate before writing
    foreach (var previousInValue in input.MinersPreviousInValues)
    {
        if (previousInValue.Value == null || previousInValue.Value == Hash.Empty)
            continue;
            
        // Only accept if it matches the miner's actual previous OutValue
        if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(previousInValue.Key))
        {
            var expectedHash = HashHelper.ComputeFrom(previousInValue.Value);
            var actualOutValue = previousRound.RealTimeMinersInformation[previousInValue.Key].OutValue;
            if (expectedHash == actualOutValue)
            {
                round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
            }
            // Silently skip invalid values instead of writing them
        }
    }
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanCorruptOtherMinersPreviousInValue_Test()
{
    // Setup: Initialize consensus with secret sharing enabled and multiple miners
    const int minersCount = 5;
    var initialMiners = await GenerateMinersAsync(minersCount);
    await InitializeConsensusAsync(initialMiners, isSecretSharingEnabled: true);
    
    var maliciousMinerId = 0; // First miner is attacker
    var victimMinerId = 1;    // Second miner is victim
    var maliciousMiner = initialMiners[maliciousMinerId];
    var victimMiner = initialMiners[victimMinerId];
    
    // Round 1: All miners produce blocks normally
    await ProduceNormalRoundAsync(initialMiners);
    var round1 = await GetCurrentRoundAsync();
    var victimPreviousOutValue = round1.RealTimeMinersInformation[victimMiner].OutValue;
    
    // Round 2: Victim misses their slot, malicious miner injects fake PreviousInValue
    var round2 = await StartNewRoundAsync();
    
    // Victim doesn't produce block (simulating missed slot)
    // Malicious miner produces block with fake PreviousInValue for victim
    var fakeVictimPreviousInValue = HashHelper.ComputeFrom("fake_value_controlled_by_attacker");
    
    // Create malicious UpdateValueInput
    var maliciousUpdateInput = await CreateUpdateValueInputAsync(maliciousMiner);
    
    // ATTACK: Inject fake PreviousInValue for victim
    maliciousUpdateInput.MinersPreviousInValues[victimMiner] = fakeVictimPreviousInValue;
    
    // Submit the malicious update - it should pass validation
    await SubmitUpdateValueAsync(maliciousMiner, maliciousUpdateInput);
    
    // Verify: The fake value was written to state
    var round2After = await GetCurrentRoundAsync();
    var storedVictimPreviousInValue = round2After.RealTimeMinersInformation[victimMiner].PreviousInValue;
    Assert.Equal(fakeVictimPreviousInValue, storedVictimPreviousInValue); // Fake value accepted!
    
    // Round 2 -> Round 3 transition: SupplyCurrentRoundInformation uses fake value
    await TransitionToNextRoundAsync();
    
    // Verify: The victim's signature was calculated with the fake value
    var round3 = await GetCurrentRoundAsync();
    var victimSignature = round2After.RealTimeMinersInformation[victimMiner].Signature;
    
    // Calculate what signature SHOULD be with real previous in value
    var realPreviousInValue = GetRealPreviousInValueForMiner(victimMiner, round1);
    var expectedSignature = round1.CalculateSignature(realPreviousInValue);
    
    // Calculate what signature WAS with fake value
    var corruptedSignature = round1.CalculateSignature(fakeVictimPreviousInValue);
    
    Assert.NotEqual(expectedSignature, victimSignature); // Signature was corrupted!
    Assert.Equal(corruptedSignature, victimSignature);   // Used fake value!
    
    // Verify: Mining order was manipulated
    var expectedOrder = GetAbsModulus(expectedSignature.ToInt64(), minersCount) + 1;
    var actualOrder = round3.RealTimeMinersInformation[victimMiner].Order;
    
    Assert.NotEqual(expectedOrder, actualOrder); // Order manipulation successful!
    
    // This breaks consensus determinism - the victim's order should be based on 
    // their actual cryptographic commitments, not attacker-controlled fake values
}
```

## Notes

This vulnerability represents a fundamental flaw in the validation logic of the secret sharing mechanism. While the recovery mechanism (`RevealSharedInValues`) provides a defense layer, it cannot be relied upon as the sole protection because:

1. It only runs during NextRound generation, creating a window where fake values exist in state
2. It fails silently when insufficient pieces exist, leaving fake values in place
3. New miners and miners with inconsistent participation are systematically vulnerable

The root cause is the mismatch between the design intent (allowing miners to synchronize known values) and the lack of cryptographic verification (ensuring provided values match the miners' actual commitments). The fix must add explicit validation that any `PreviousInValue` provided for another miner can be verified against that miner's previous `OutValue` from the last round they participated in.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-193)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L199-199)
```csharp
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```
