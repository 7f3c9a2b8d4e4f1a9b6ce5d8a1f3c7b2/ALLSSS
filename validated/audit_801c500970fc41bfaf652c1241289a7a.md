# Audit Report

## Title
Integer Overflow in TokenHolder Withdraw Function Enables Permanent Token Lock via Malicious MinimumLockMinutes

## Summary
The TokenHolderContract allows any address to create profit-sharing schemes without validating the `MinimumLockMinutes` parameter. When set to extremely large values (≥153,722,867,280,912,931), the time calculation in the `Withdraw` function triggers a checked arithmetic overflow exception, permanently preventing users from unlocking their tokens with no recovery mechanism.

## Finding Description

The vulnerability exists across three key components that interact to create a permanent denial-of-service condition on user funds:

**1. Unvalidated Scheme Creation**

The `CreateScheme` function accepts arbitrary `MinimumLockMinutes` values without any bounds checking. [1](#0-0) 

The protobuf definition confirms `MinimumLockMinutes` is a standard `int64` with no constraints: [2](#0-1) 

**2. Overflow in Time Validation**

When users attempt to withdraw, the contract validates the lock duration using `AddMinutes(scheme.MinimumLockMinutes)`: [3](#0-2) 

The `AddMinutes` extension method multiplies minutes by 60 to convert to seconds: [4](#0-3) 

The `Mul` operation uses checked arithmetic that throws `OverflowException` instead of silently wrapping: [5](#0-4) 

For `MinimumLockMinutes ≥ 153,722,867,280,912,931`, the calculation `minutes * 60` exceeds `Int64.MaxValue` (9,223,372,036,854,775,807), triggering the overflow exception and reverting the entire withdraw transaction.

**3. No Alternative Recovery Path**

Users cannot unlock tokens through alternative mechanisms:

- Direct calls to `Token.Unlock` fail authorization checks requiring the caller to be in the symbol's LockWhiteList or be a system contract: [6](#0-5) 

- The whitelist validation enforces that only system contracts or explicitly whitelisted addresses can unlock: [7](#0-6) 

- The `RemoveBeneficiary` function only removes users from the profit scheme but does not unlock tokens: [8](#0-7) 

**Attack Flow:**
1. Attacker calls `CreateScheme` with `MinimumLockMinutes = Int64.MaxValue`
2. Victim calls `RegisterForProfits`, locking tokens via the Token contract
3. Victim attempts `Withdraw` → `AddMinutes` overflows → transaction reverts
4. Tokens remain permanently locked with no recovery mechanism

## Impact Explanation

**Severity: HIGH**

This vulnerability enables permanent, irrecoverable loss of user funds:

- **Direct Financial Loss**: Users lose 100% of tokens locked in malicious schemes with no time-based or governance recovery mechanism
- **Fund Accessibility**: Tokens are locked in the MultiToken contract's virtual address system with the only unlock path permanently disabled
- **Scope**: Any user who registers for profits in a malicious scheme is affected
- **Permanence**: The scheme parameters cannot be modified after creation, making the lock condition permanent

The attacker does not gain direct access to locked funds, but achieves complete denial-of-service, effectively destroying user assets.

## Likelihood Explanation

**Probability: HIGH**

The attack is straightforward to execute with minimal barriers:

**Attacker Requirements:**
- No special privileges or governance approval needed
- Any address can call `CreateScheme` (no authorization checks)
- Single parameter manipulation: set `MinimumLockMinutes` to malicious value

**User Vulnerability:**
- Users may be attracted by profit-sharing opportunities without scrutinizing all parameters
- The `MinimumLockMinutes` value is visible but requires users to query scheme data and calculate overflow thresholds
- No warnings or validation errors occur during scheme creation
- Schemes could appear legitimate with attractive profit distribution terms

**Attack Simplicity:**
- One-transaction setup (`CreateScheme`)
- No complex preconditions or state manipulation required
- Exploit triggers automatically when victims attempt withdrawal

## Recommendation

Add validation in the `CreateScheme` function to enforce reasonable bounds on `MinimumLockMinutes`:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add validation to prevent overflow in AddMinutes
    const long MaxSafeMinutes = long.MaxValue / 60; // 153,722,867,280,912,930
    Assert(input.MinimumLockMinutes >= 0 && input.MinimumLockMinutes <= MaxSafeMinutes, 
        "MinimumLockMinutes exceeds safe bounds.");
    
    // Existing code continues...
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
    
    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, implement a reasonable business logic maximum (e.g., 10 years = 5,256,000 minutes) that serves legitimate use cases while preventing overflow attacks.

## Proof of Concept

```csharp
[Fact]
public async Task Withdraw_WithOverflowMinimumLockMinutes_PermanentlyLocksTokens()
{
    const long maliciousLockMinutes = long.MaxValue; // Causes overflow in AddMinutes
    const long lockAmount = 1000L;
    var nativeTokenSymbol = TokenHolderContractTestConstants.NativeTokenSymbol;
    
    // Attacker creates malicious scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = nativeTokenSymbol,
        MinimumLockMinutes = maliciousLockMinutes
    });
    
    // Victim registers and locks tokens
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = lockAmount,
        SchemeManager = Starter
    });
    
    // Verify tokens are locked
    var lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = Starter,
        Symbol = nativeTokenSymbol,
        LockId = Context.GenerateId(Context.Self, 
            ByteArrayHelper.ConcatArrays(Starter.ToByteArray(), Starter.ToByteArray()))
    });
    lockedAmount.Amount.ShouldBe(lockAmount);
    
    // Attempt withdrawal fails with overflow exception
    var withdrawResult = await TokenHolderContractStub.Withdraw.SendWithExceptionAsync(Starter);
    withdrawResult.TransactionResult.Error.ShouldContain("Overflow");
    
    // Tokens remain permanently locked - no recovery mechanism exists
}
```

## Notes

The vulnerability is particularly severe because:

1. **Checked arithmetic paradox**: The SafeMath protection designed to prevent silent overflow actually enables the DoS attack by throwing exceptions instead of clamping values

2. **Lock/Unlock authorization model**: The MultiToken contract's security model correctly restricts unlock operations to whitelisted contracts (like TokenHolder), but this creates a single point of failure when the TokenHolder contract's withdrawal logic is broken

3. **No scheme modification**: Once created, scheme parameters including `MinimumLockMinutes` cannot be updated, making the lock condition permanent

4. **User trust assumption**: The design assumes users will create legitimate schemes, but provides no validation to enforce reasonable parameter bounds

This is a valid HIGH severity vulnerability requiring immediate remediation through input validation in the `CreateScheme` function.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** protobuf/token_holder_contract.proto (L63-70)
```text
message CreateTokenHolderProfitSchemeInput {
    // The token symbol.
    string symbol = 1;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 3;
}
```

**File:** src/AElf.CSharp.Core/Extension/TimestampExtensions.cs (L39-42)
```csharp
    public static Timestamp AddMinutes(this Timestamp timestamp, long minutes)
    {
        return timestamp + new Duration { Seconds = minutes.Mul(60) };
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L79-85)
```csharp
    public static long Mul(this long a, long b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L224-231)
```csharp
    public override Empty Unlock(UnlockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L196-203)
```csharp
    private void AssertSystemContractOrLockWhiteListAddress(string symbol)
    {
        var symbolState = State.LockWhiteLists[symbol];
        var isInWhiteList = symbolState != null && symbolState[Context.Sender];
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Values;
        var isSystemContractAddress = systemContractAddresses.Contains(Context.Sender);
        Assert(isInWhiteList || isSystemContractAddress, "No Permission.");
    }
```
