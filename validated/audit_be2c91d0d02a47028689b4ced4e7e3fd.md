# Audit Report

## Title
Case-Sensitive Pubkey Comparison Allows Banned Initial Miners to Bypass Ban and Replace Their Public Key

## Summary
The Election contract's ban system can be bypassed by banned initial miners using case-variant hex strings. The `IsPubkeyBanned()` function performs case-sensitive dictionary lookups, but the consensus contract stores banned pubkeys in lowercase format using `ToHex()`. This allows a banned initial miner to use uppercase hex variants of their pubkey to pass ban checks in `SetCandidateAdmin` and `ReplaceCandidatePubkey`, enabling them to replace their banned pubkey with a new one and continue participating in consensus.

## Finding Description

The root cause is a case-sensitivity mismatch in pubkey handling across the Election and Consensus contracts.

The `IsPubkeyBanned()` helper performs direct case-sensitive dictionary lookups on `BannedPubkeyMap`: [1](#0-0) 

However, when the consensus contract bans evil miners, it uses pubkeys generated by `ToHex()`, which produces lowercase hex strings. The implementation adds `0x20` (32 in decimal) to convert uppercase hex characters to lowercase: [2](#0-1) 

The same lowercase conversion occurs in `ByteStringExtensions`: [3](#0-2) 

Evil miners are detected and banned with lowercase pubkeys. The detection extracts pubkeys from `MinerInRound.Pubkey` fields: [4](#0-3) 

These pubkeys are assigned using `ToHex()` during round generation: [5](#0-4) 

The consensus contract sends these lowercase pubkeys to the Election contract: [6](#0-5) 

The ban is stored in lowercase: [7](#0-6) 

**Why protections fail:**

`SetCandidateAdmin` checks the ban without normalizing the input: [8](#0-7) 

The permission check uses `HexStringToByteArray`, which is **case-insensitive** because `Convert.ToByte(string, 16)` in C# accepts both uppercase and lowercase hex strings: [9](#0-8) 

`IsCurrentCandidateOrInitialMiner` also uses case-insensitive byte conversion: [10](#0-9) 

`ReplaceCandidatePubkey` has the same case-sensitivity issues: [11](#0-10) 

The replacement proceeds successfully, removing the old pubkey from InitialMiners and adding the new one: [12](#0-11) 

## Impact Explanation

This vulnerability directly compromises **consensus integrity**, which is a critical security boundary in the blockchain system.

**Attack Scenario:**
1. Initial miner with pubkey bytes is banned by consensus as lowercase "abc123..." in `BannedPubkeyMap`
2. Attacker calls `SetCandidateAdmin(Pubkey="ABC123...", Admin=AttackerAddress)` - bypasses ban check due to case difference
3. Attacker calls `ReplaceCandidatePubkey(OldPubkey="ABC123...", NewPubkey="newkey...")` - replacement succeeds
4. Banned evil miner is now participating in consensus with a new identity

**Consequences:**
- **Consensus security violation**: Evil miners can evade permanent exclusion
- **Critical invariant broken**: The system's guarantee that detected evil miners are permanently banned is violated
- **No economic cost**: Attacker only needs transaction fees, no tokens at risk
- **Privilege escalation**: Initial miners (highest consensus privilege) can bypass punishment

**Severity Assessment: HIGH** - This breaks a fundamental consensus security guarantee. Initial miners are the most trusted consensus participants, and allowing them to bypass bans undermines the entire evil node detection and punishment mechanism.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be an initial miner (set during chain initialization)
- Must control the private key of a banned pubkey
- Must be detected as evil and banned by the consensus contract

**Attack Complexity: LOW**
- Requires only two simple contract calls: `SetCandidateAdmin` then `ReplaceCandidatePubkey`
- No timing constraints or race conditions
- No need for collusion or compromised trusted roles
- The uppercase transformation is trivial

**Feasibility: HIGH**
- Initial miners exist in every AElf chain deployment
- Evil node detection is an active, documented feature in the consensus contract
- Banned miners have strong incentives (rewards, influence) to return to consensus
- The attack is deterministic and easily reproducible

**Detection Difficulty: HIGH**
- The lowercase ban remains in `BannedPubkeyMap`, appearing legitimate
- State changes (admin updates, pubkey replacements) look normal
- Only careful case-by-case analysis would reveal the bypass

**Overall Likelihood: HIGH** - Given the low complexity and high feasibility, this is highly likely to be exploited by any banned initial miner.

## Recommendation

Normalize all pubkey strings to lowercase before performing ban checks. Modify `IsPubkeyBanned()` to:

```csharp
private bool IsPubkeyBanned(string pubkey)
{
    return State.BannedPubkeyMap[pubkey.ToLower()];
}
```

Alternatively, normalize pubkeys at storage time in `UpdateCandidateInformation` and throughout the Election contract to ensure consistency.

## Proof of Concept

```csharp
[Fact]
public async Task BannedInitialMinerBypassesWithUppercase()
{
    // Setup: Initial miner is banned with lowercase pubkey
    var initialMinerKey = SampleAccount.Accounts[0].KeyPair;
    var lowercasePubkey = initialMinerKey.PublicKey.ToHex(); // lowercase
    var uppercasePubkey = initialMinerKey.PublicKey.ToHex().ToUpper();
    
    // Simulate consensus banning the miner (stores lowercase)
    await ElectionContractStub.UpdateCandidateInformation.SendAsync(
        new UpdateCandidateInformationInput {
            Pubkey = lowercasePubkey,
            IsEvilNode = true
        });
    
    // Verify ban with lowercase
    var isBannedLower = await ElectionContractStub.IsPubkeyBanned.CallAsync(
        new StringValue { Value = lowercasePubkey });
    Assert.True(isBannedLower); // Banned correctly
    
    // Attack: Use uppercase variant to bypass ban
    var result = await ElectionContractStub.SetCandidateAdmin.SendAsync(
        new SetCandidateAdminInput {
            Pubkey = uppercasePubkey,
            Admin = DefaultSender
        });
    Assert.True(result.TransactionResult.Status == TransactionResultStatus.Mined); // BYPASSED!
    
    // Complete attack: Replace pubkey
    var newPubkey = SampleAccount.Accounts[1].KeyPair.PublicKey.ToHex();
    var replaceResult = await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(
        new ReplaceCandidatePubkeyInput {
            OldPubkey = uppercasePubkey,
            NewPubkey = newPubkey
        });
    Assert.True(replaceResult.TransactionResult.Status == TransactionResultStatus.Mined); // SUCCESS!
    
    // Banned miner now has new pubkey and can participate in consensus
}
```

## Notes

This vulnerability affects the core consensus security mechanism. The case-sensitivity mismatch creates a critical bypass that allows permanently banned validators to re-enter the consensus set, violating fundamental blockchain security guarantees.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-23)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L61-64)
```csharp
    private bool IsPubkeyBanned(string pubkey)
    {
        return State.BannedPubkeyMap[pubkey];
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L75-82)
```csharp
    private bool IsCurrentCandidateOrInitialMiner(string pubkey)
    {
        var isCurrentCandidate = State.CandidateInformationMap[pubkey] != null &&
                                 State.CandidateInformationMap[pubkey].IsCurrentCandidate;
        var isInitialMiner = State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey)));
        return isCurrentCandidate || isInitialMiner;
    }
```

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L35-42)
```csharp
            for (int bx = 0, cx = offset; bx < bytes.Length; ++bx, ++cx)
            {
                b = (byte)(bytes[bx] >> 4);
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
            }
```

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L22-29)
```csharp
            for (int bx = 0, cx = offset; bx < bytes.Length; ++bx, ++cx)
            {
                b = (byte)(bytes[bx] >> 4);
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-30)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-181)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-19)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
        }
```
