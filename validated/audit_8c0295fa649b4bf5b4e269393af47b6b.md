# Audit Report

## Title
ActualMiningTime Manipulation via Hash Exclusion Allows Consensus Timing Fraud

## Summary
The AEDPoS consensus system fails to validate that `ActualMiningTime` values in consensus extra data match the block's actual timestamp. Because `ActualMiningTimes` are excluded from round hash validation, malicious miners can manipulate these timestamps to affect term transitions and bypass time slot restrictions while passing all validation checks.

## Finding Description

The vulnerability exists across three interconnected failures in the consensus validation flow:

**Root Cause 1 - Hash Exclusion:**
The `GetCheckableRound()` method explicitly clears `ActualMiningTimes` before computing the consensus round hash. [1](#0-0) 

This hash is used by `ValidateConsensusAfterExecution` to verify consensus data integrity, meaning ActualMiningTimes are never cryptographically validated. [2](#0-1) 

**Root Cause 2 - Missing Timestamp Validation:**
During consensus extra data generation, `ActualMiningTime` is correctly set to `Context.CurrentBlockTime`, which comes from the block header's `Time` field. [3](#0-2) [4](#0-3) 

The `Context.CurrentBlockTime` is populated from `BlockHeader.Time` during transaction execution: [5](#0-4) 

However, when transactions are generated from consensus extra data, `ActualMiningTime` is extracted from the provided round data: [6](#0-5) [7](#0-6) 

During execution, this `ActualMiningTime` is stored **directly from the transaction input without any validation** that it equals `Context.CurrentBlockTime`: [8](#0-7) [9](#0-8) 

**Root Cause 3 - Insufficient Time Slot Validation:**
The `TimeSlotValidationProvider` only verifies that `ActualMiningTime` falls within the miner's assigned time slot range, but does NOT validate it matches the block's actual timestamp: [10](#0-9) 

**Attack Execution Path:**
1. Malicious miner generates valid consensus extra data with `ActualMiningTime = T1 = BlockHeader.Time`
2. Miner modifies the serialized protobuf consensus extra data, changing `ActualMiningTime` to `T2` (where `T2` is within their time slot but `T2 â‰  T1`)
3. During `ValidateBeforeExecution`, the modified `T2` is recovered into the base round [11](#0-10) [12](#0-11) 
4. Time slot validation passes because `T2` is within the allowed range
5. During `ValidateAfterExecution`, hash comparison succeeds because `ActualMiningTimes` are excluded
6. Transaction execution stores the false `T2` value in consensus state without validation

## Impact Explanation

**Critical Consensus Integrity Violation:**

1. **Term Manipulation:** The `NeedToChangeTerm` function determines when to transition between consensus terms by checking if two-thirds of miners have `ActualMiningTimes` meeting the term threshold. Manipulated timestamps enable miners to delay or accelerate term changes, directly affecting validator set rotation and network governance. [13](#0-12) 

2. **Time Slot Validation Bypass:** Future blocks validate time slots by checking the miner's latest `ActualMiningTime` from state. False historical timestamps allow miners to systematically bypass time slot restrictions in subsequent rounds. [14](#0-13) 

3. **Consensus Command Manipulation:** Block production logic relies on `ActualMiningTimes` counts and ordering. Manipulated data affects whether miners produce tiny blocks or transition rounds, enabling control over block production patterns.

**Severity Assessment:** CRITICAL - This breaks the fundamental timing integrity guarantees of the consensus layer, enabling manipulation of governance transitions and systematic evasion of consensus constraints.

## Likelihood Explanation

**Highly Feasible Attack:**

**Attacker Capabilities:**
- Must be an elected miner in the current round (realistic - any validator can execute this)
- Must modify serialized protobuf data (trivial - standard manipulation)
- Must choose `T2` within their time slot (easy - wide acceptable range)

**Attack Complexity:** LOW
- Single-step modification of consensus extra data between generation and block submission
- No coordination with other miners required
- No complex transaction sequences or timing dependencies

**Feasibility Conditions:**
- Attacker produces blocks during normal operation
- Manipulated `ActualMiningTime` passes time slot range check (constraint easily satisfied)
- No cryptographic signatures protect `ActualMiningTime` integrity

**Detection Difficulty:** EXTREME
- All validation checks pass (hash excludes the manipulated field)
- No on-chain evidence of manipulation
- Requires off-chain comparison of `BlockHeader.Time` with stored `ActualMiningTimes`

**Probability:** HIGH - Any elected miner can execute this on every block with zero detection risk.

## Recommendation

Add explicit validation in `ProcessUpdateValue` and `ProcessTinyBlock` to ensure `ActualMiningTime` matches the block's actual timestamp:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // ADD VALIDATION: ActualMiningTime must equal Context.CurrentBlockTime
    Assert(updateValueInput.ActualMiningTime == Context.CurrentBlockTime,
        "ActualMiningTime must equal block timestamp");
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
    // ... rest of method
}

private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // ADD VALIDATION: ActualMiningTime must equal Context.CurrentBlockTime
    Assert(tinyBlockInput.ActualMiningTime == Context.CurrentBlockTime,
        "ActualMiningTime must equal block timestamp");
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
    // ... rest of method
}
```

This ensures that any manipulation of `ActualMiningTime` in the consensus extra data will be detected and rejected during transaction execution, as the stored value must match the block's immutable timestamp.

## Proof of Concept

```csharp
[Fact]
public async Task ActualMiningTime_Manipulation_Attack()
{
    // Setup: Initialize consensus with valid miner
    var miner = SampleAccount.Accounts.First();
    var round = await InitializeConsensusRound(miner);
    
    // Step 1: Generate valid consensus extra data
    var blockTime = TimestampHelper.GetUtcNow();
    var validExtraData = await GenerateConsensusExtraData(miner, blockTime);
    
    // Step 2: Deserialize and manipulate ActualMiningTime
    var headerInfo = AElfConsensusHeaderInformation.Parser.ParseFrom(validExtraData.Value);
    var manipulatedTime = blockTime.AddSeconds(-100); // T2 != T1, but still in time slot
    headerInfo.Round.RealTimeMinersInformation[miner.PublicKey.ToHex()]
        .ActualMiningTimes[0] = manipulatedTime;
    
    // Step 3: Create block with manipulated data
    var block = await CreateBlock(blockTime, headerInfo.ToByteString());
    
    // Step 4: Validate - should pass all checks
    var validationResult = await ValidateBlock(block);
    validationResult.Success.ShouldBeTrue(); // Passes because ActualMiningTimes excluded from hash
    
    // Step 5: Execute block
    await ExecuteBlock(block);
    
    // Step 6: Verify false timestamp stored in state
    var storedRound = await GetCurrentRound();
    var storedTime = storedRound.RealTimeMinersInformation[miner.PublicKey.ToHex()]
        .ActualMiningTimes.Last();
    
    // VULNERABILITY: Manipulated time stored instead of actual block time
    storedTime.ShouldBe(manipulatedTime); // False T2 stored
    storedTime.ShouldNotBe(blockTime); // Real T1 not stored
    
    // Impact: Can manipulate term transitions
    var shouldChangeTerm = storedRound.NeedToChangeTerm(
        blockchainStartTime, currentTerm, periodSeconds);
    // Result depends on manipulated ActualMiningTime, not real block time
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L157-157)
```csharp
                                ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L162-163)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L66-66)
```csharp
                    CurrentBlockTime = transactionExecutingDto.BlockHeader.Time,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L42-42)
```csharp
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L304-304)
```csharp
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L20-20)
```csharp
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L44-44)
```csharp
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```
