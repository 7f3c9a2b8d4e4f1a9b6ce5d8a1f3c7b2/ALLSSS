# Audit Report

## Title
Missing Signature-to-Order Validation Allows Miners to Manipulate Next Round Mining Order

## Summary

The AEDPoS consensus mechanism fails to validate that miners' `SupposedOrderOfNextRound` values match their cryptographic signatures when processing `UpdateValue` transactions. A malicious miner producing a block can set arbitrary mining order values that pass validation and directly determine next round's mining sequence, breaking consensus fairness and enabling MEV extraction.

## Finding Description

The vulnerability exists due to a critical validation gap where the consensus contract accepts mining order values without verifying their cryptographic derivation from signatures.

**Secure Design Intent:**
During normal block production, the `ApplyNormalConsensusData` method deterministically calculates mining order from signatures: [1](#0-0) 

The order calculation uses `GetAbsModulus(sigNum, minersCount) + 1` to ensure cryptographic randomness and prevent manipulation.

**Validation Gap:**
However, when a miner produces a block containing an `UpdateValue` transaction, the validation only checks cryptographic fields but NOT the order values: [2](#0-1) 

The `UpdateValueValidationProvider` validates `OutValue`, `Signature`, and `PreviousInValue` but completely ignores `SupposedOrderOfNextRound` and `FinalOrderOfNextRound`.

**Unvalidated State Update:**
The `ProcessUpdateValue` method blindly accepts and stores the order values from input: [3](#0-2) 

Additionally, line 259-260 allows manipulation of OTHER miners' orders via `TuneOrderInformation` without validation.

**Order Enforcement Validation Missing:**
While `NextRoundMiningOrderValidationProvider` exists to validate order values, it is only applied to `NextRound` behavior: [4](#0-3) 

Line 86 shows it's added for `NextRound`, but line 80 shows `UpdateValue` only gets `UpdateValueValidationProvider`.

**Direct Impact on Next Round:**
The manipulated `FinalOrderOfNextRound` values directly determine actual mining positions: [5](#0-4) 

**Attack Execution:**
A malicious miner can modify their consensus client to:
1. Skip the normal `ApplyNormalConsensusData` calculation when calling `GetConsensusExtraDataToPublishOutValue`
2. Manually set `SupposedOrderOfNextRound = 1` (or any desired position)
3. Generate block header consensus extra data with manipulated values
4. Generate `UpdateValue` transaction via `ExtractInformationToUpdateConsensus` with same manipulated values
5. Both header and transaction contain matching manipulated values, passing validation [6](#0-5) [7](#0-6) 

## Impact Explanation

**Consensus Invariant Violation:**
The AEDPoS security model requires mining order to be deterministically derived from cryptographic signatures to ensure fairness and unpredictability. This vulnerability completely breaks that invariant, allowing arbitrary order assignment.

**MEV Extraction:**
Mining first in every round provides:
- Priority access to profitable mempool transactions
- Control over transaction ordering for front-running/sandwich attacks  
- First-mover advantage in observing other miners' consensus data
- Higher probability of producing extra blocks

The extra block producer selection is influenced by the first miner's signature: [8](#0-7) 

**Centralization & Cartel Formation:**
Multiple colluding malicious miners can claim sequential positions (1, 2, 3...), systematically pushing honest miners to later time slots and controlling block production timing across the network.

**Insufficient Mitigation:**
The `BreakContinuousMining` function only prevents the same miner from being both last in current round and first in next round: [9](#0-8) 

This does not prevent a miner from consistently claiming position 1 or 2 in every round.

## Likelihood Explanation

**Low Barrier to Entry:**
- Attacker must be an elected miner (achievable through standard governance/election processes)
- Must wait for their legitimate time slot (guaranteed for miners)
- No cryptographic breaking or network-level attacks required

**High Feasibility:**
- Requires only modifying the consensus client to bypass `ApplyNormalConsensusData`
- Manipulation appears as legitimate consensus data
- Time-slot validation passes (during attacker's slot)
- Mining permission validation passes (attacker is valid miner)

**Low Detection Risk:**
Without validators explicitly checking the signature-to-order mathematical relationship, the manipulation is indistinguishable from normal consensus data. The validation in `RecoverFromUpdateValue` and `ValidateConsensusAfterExecution` simply copies values without verification: [10](#0-9) 

**Economic Rationality:**
The cost is minimal (only transaction gas), while benefits compound over many rounds through MEV extraction, fee advantages, and increased extra block production probability.

## Recommendation

Add cryptographic validation of order values in `UpdateValueValidationProvider`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    // Existing validation...
    if (!NewConsensusInformationFilled(validationContext))
        return new ValidationResult { Message = "Incorrect new Out Value." };
    
    if (!ValidatePreviousInValue(validationContext))
        return new ValidationResult { Message = "Incorrect previous in value." };
    
    // NEW: Validate order matches signature
    if (!ValidateOrderFromSignature(validationContext))
        return new ValidationResult { Message = "Order does not match signature." };
    
    return new ValidationResult { Success = true };
}

private bool ValidateOrderFromSignature(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var signature = minerInRound.Signature;
    var minersCount = validationContext.ProvidedRound.RealTimeMinersInformation.Count;
    
    var expectedOrder = GetAbsModulus(signature.ToInt64(), minersCount) + 1;
    
    return minerInRound.SupposedOrderOfNextRound == expectedOrder;
}

private static int GetAbsModulus(long longValue, int intValue)
{
    return (int)Math.Abs(longValue % intValue);
}
```

Additionally, validate that `TuneOrderInformation` only contains legitimate conflict resolutions based on the conflict detection logic in `ApplyNormalConsensusData`.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanManipulateMiningOrder()
{
    // Setup: Initialize consensus with multiple miners
    var miners = GenerateMiners(5);
    await InitializeConsensus(miners);
    
    // Attacker is miner at position 3
    var attackerKeyPair = miners[2];
    var attackerPubkey = attackerKeyPair.PublicKey.ToHex();
    
    // Wait for attacker's time slot
    await ProduceBlocksUntilTimeSlot(attackerPubkey);
    
    // Attacker crafts UpdateValue with manipulated order
    var maliciousInput = new UpdateValueInput
    {
        OutValue = GenerateValidOutValue(),
        Signature = GenerateValidSignature(),
        PreviousInValue = GetPreviousInValue(),
        SupposedOrderOfNextRound = 1,  // MANIPULATED: Should be calculated from signature
        RoundId = GetCurrentRoundId(),
        ActualMiningTime = Context.CurrentBlockTime,
        RandomNumber = GenerateRandomNumber()
    };
    
    // Execute malicious UpdateValue
    var result = await ConsensusContract.UpdateValue.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Should FAIL but PASSES
    
    // Trigger NextRound to apply the manipulated order
    await ProduceNextRound();
    
    // Verify: Attacker now has order 1 in next round (VULNERABILITY CONFIRMED)
    var nextRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    var attackerInNextRound = nextRound.RealTimeMinersInformation[attackerPubkey];
    
    attackerInNextRound.Order.ShouldBe(1); // Attacker successfully manipulated their position
    
    // The order should have been calculated from signature, not from input
    var expectedOrder = CalculateOrderFromSignature(maliciousInput.Signature, nextRound.RealTimeMinersInformation.Count);
    attackerInNextRound.Order.ShouldNotBe(expectedOrder); // Proves manipulation succeeded
}
```

## Notes

This vulnerability represents a fundamental break in the AEDPoS consensus security model. The deterministic calculation of mining order from cryptographic signatures is essential for preventing miner manipulation and ensuring fair block production. The validation gap allows malicious miners to bypass this core security property, enabling consensus-level attacks that were specifically designed to be prevented by the signature-based ordering mechanism.

The issue affects the public `UpdateValue` method exposed at: [11](#0-10)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-48)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-260)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L43-44)
```csharp
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
