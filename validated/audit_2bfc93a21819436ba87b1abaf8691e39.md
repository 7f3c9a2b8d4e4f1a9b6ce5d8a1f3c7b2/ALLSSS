# Audit Report

## Title
Missing Minimum Bound Check in SetMinerIncreaseInterval Enables Consensus DoS via Rapid Miner Count Inflation

## Summary
The `SetMinerIncreaseInterval` function lacks a minimum bound check, allowing the miner increase interval to be reduced to dangerously small values (e.g., 1 second) through Parliament governance. This causes the automatic miner count calculation to inflate at 2 miners per second, overwhelming the consensus mechanism and causing complete network paralysis within hours.

## Finding Description

The vulnerability exists in the `SetMinerIncreaseInterval` method, which only validates that the new interval value does not exceed the current value, but imposes no minimum bound: [1](#0-0) 

The validation at line 61 prevents *increasing* the interval but allows unlimited *decreasing*. Starting from the default value of 31,536,000 seconds (1 year), the interval can be reduced to 1 second through a single governance proposal.

The `GetAutoIncreasedMinersCount` function calculates the effective miner count using the formula: `17 + (elapsed_seconds / MinerIncreaseInterval) * 2` [2](#0-1) 

When `MinerIncreaseInterval = 1`, this becomes `17 + elapsed_seconds * 2`, adding 2 miners per second continuously.

This inflated count propagates to the Election contract during term transitions: [3](#0-2) 

The Election contract then attempts to select this many validators: [4](#0-3) 

The theoretical cap `MaximumMinersCount` is set to `int.MaxValue` during initialization, providing no practical protection: [5](#0-4) 

The consensus round generation must process all miners, causing computational overload: [6](#0-5) 

## Impact Explanation

**Consensus Breakdown Timeline:**
- After 1 hour: 17 + (3,600 × 2) = 7,217 miners
- After 1 day: 17 + (86,400 × 2) = 172,817 miners
- After 1 week: 17 + (604,800 × 2) = 1,209,617 miners

**Concrete Harm:**

1. **Round Duration Explosion:** With 7,217 miners and 4-second time slots, a single consensus round would take approximately 8 hours instead of minutes, making the network completely unusable for block production.

2. **Computational Overload:** The `GenerateNextRoundInformation` method must iterate through all miners, creating miner information entries and calculating orders. With thousands of miners, this causes memory exhaustion and CPU overload on all nodes.

3. **Network Paralysis:** Consensus nodes cannot keep up with the processing requirements, leading to massive missed blocks, stalled chain progression, and complete network freeze.

4. **Election System Failure:** The `GetVictories` method attempting to select 100,000+ validators from a limited candidate pool (line 81) breaks the election mechanism, as it tries to fill the list with backups and initial miners that don't exist in sufficient numbers.

**Severity: HIGH** - Complete consensus failure affecting all network participants. Validators cannot produce blocks, users cannot submit transactions, and the entire blockchain halts. The damage accumulates continuously every second after the interval is reduced, making recovery increasingly difficult.

## Likelihood Explanation

**Governance Attack Vector:**

The attack requires Parliament organization approval, which is the default governance mechanism defined in the controller initialization: [7](#0-6) 

This is NOT a "compromised trusted role" scenario but rather a parameter validation vulnerability exploitable through legitimate governance.

**Attack Execution:**
1. Attacker submits Parliament proposal to reduce `MinerIncreaseInterval` to 1 or 10 seconds
2. Proposal framed as "improving miner growth responsiveness" or "optimizing consensus parameters"
3. Parliament approves through normal voting (feasible with social engineering or legitimate misunderstanding)
4. Change takes effect immediately upon execution
5. Miner count automatically inflates based on elapsed blockchain time
6. Consensus degradation manifests within hours

**Feasibility:**
- No technical barriers—uses standard governance flow
- The validation only prevents increasing the interval, explicitly allowing any decrease
- Attack is irreversible (cannot increase interval back, per line 61 constraint)
- Damage is cumulative and permanent

Existing tests verify this behavior allows decreasing without minimum bounds: [8](#0-7) 

**Likelihood: MEDIUM-HIGH** - While requiring governance approval, the lack of input validation means any approved value causes harm. The proposal could pass legitimately without full understanding of consequences.

## Recommendation

Add a minimum bound check to `SetMinerIncreaseInterval`:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    
    // Add minimum bound check (e.g., 1 day minimum)
    const long MINIMUM_INTERVAL = 86400; // 1 day in seconds
    Assert(input.Value >= MINIMUM_INTERVAL, 
        $"Miner increase interval must be at least {MINIMUM_INTERVAL} seconds");
    
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

The minimum should be set to a reasonable value that prevents rapid miner inflation while allowing governance flexibility (e.g., 1 day = 86,400 seconds, or 1 week = 604,800 seconds).

## Proof of Concept

The existing test demonstrates that any value can be set as long as it's less than or equal to the current value, with no minimum validation: [9](#0-8) 

To demonstrate the vulnerability:
1. Deploy contracts with default `MinerIncreaseInterval = 31536000`
2. Submit Parliament proposal: `SetMinerIncreaseInterval(1)`
3. Proposal executes successfully (passes validation at line 61)
4. Query `GetAutoIncreasedMinersCount()` after time advances
5. Observe miner count increasing by 2 per second
6. Consensus operations become computationally infeasible within hours

The test shows the interval can be reduced to `minerIncreaseInterval.Value - 1`, and by induction can be reduced all the way to 1 through repeated proposals or a single proposal with value 1.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L31-43)
```csharp
    private void RequiredMaximumMinersCountControllerSet()
    {
        if (State.MaximumMinersCountController.Value != null) return;
        EnsureParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MaximumMinersCountController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L52-52)
```csharp
        State.MaximumMinersCount.Value = int.MaxValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L108-147)
```csharp
    [Fact]
    public async Task SetMinerIncreaseIntervalTest()
    {
        InitialContracts();
        await BlockMiningService.MineBlockToNextTermAsync();

        InitialAcs3Stubs();
        await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput());
        var minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        
        var defaultOrganizationAddress =
            await ParliamentStubs.First().GetDefaultOrganizationAddress.CallAsync(new Empty());

        var transactionResult = await ParliamentReachAnAgreementWithExceptionAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = minerIncreaseInterval.Value + 1
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        transactionResult.Error.ShouldContain("Invalid interval");
        var newMinerIncreaseInterval = minerIncreaseInterval.Value - 1;
        await ParliamentReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = newMinerIncreaseInterval
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        minerIncreaseInterval.Value.ShouldBe(newMinerIncreaseInterval);
    }
```
