# Audit Report

## Title
NFT Protocol Creation Accepts Empty Address Values Leading to Permanent Protocol Bricking

## Summary
The NFT contract's `Create` method fails to validate that `input.Creator` has a non-empty `Address.Value` field before using it as the token issuer. Combined with insufficient validation in the MultiToken contract's `RegisterTokenInfo` method, this allows creation of NFT protocols with invalid issuer addresses (empty byte values), permanently bricking the protocol as no one can mint NFTs or manage the minter list.

## Finding Description

The vulnerability exists in the NFT creation flow across two contracts:

**NFT Contract - Insufficient Creator Validation:**

The `Create` method uses a null-coalescing operator to set the creator without validating the `Address.Value` field. [1](#0-0)  This only checks if `input.Creator` is null, but does not validate whether the Address object has an empty `Value` field (ByteString). If a caller passes `new Address()` or `new Address { Value = ByteString.Empty }`, this is a non-null Address object that bypasses the null check, resulting in `creator` being set to an invalid empty-value address.

This invalid creator is then passed to the MultiToken contract as the `Issuer`. [2](#0-1) 

**MultiToken Contract - Incomplete RegisterTokenInfo Validation:**

The `RegisterTokenInfo` method only validates that the issuer is not null, [3](#0-2)  but does not check if the `Address.Value` field is empty. This is inconsistent with the proper validation pattern used elsewhere in the same contract, such as in `ModifyTokenIssuerAndOwner` which correctly validates both conditions. [4](#0-3) 

**Protocol Becomes Permanently Unusable:**

Once created with an empty-value issuer, the protocol cannot be used:

1. **Minting Fails**: The `GetMinterList` helper adds the empty-value issuer to the minter list, [5](#0-4)  but the minting permission check fails because `Context.Sender` (a valid address) will never equal the empty-value address. [6](#0-5) 

2. **Minter Management Fails**: The `AddMinters` and `RemoveMinters` methods require the caller to equal the protocol creator, [7](#0-6) [8](#0-7)  which will always fail for any real sender when the creator has an empty value.

## Impact Explanation

**Severity: High/Critical**

This vulnerability enables permanent denial-of-service attacks against NFT protocol functionality:

1. **Complete Protocol Bricking**: Any NFT protocol created with an empty-value creator becomes permanently unusable - no NFTs can ever be minted, and the minter list cannot be modified.

2. **Economic Damage**: 
   - Attackers can intentionally brick protocols, wasting the creation fees/costs paid by legitimate users
   - If the attacker front-runs a legitimate NFT protocol creation, the intended creator loses their fees and must create under a different symbol

3. **Griefing Attack Vector**: Malicious actors can systematically brick popular NFT symbol names or types, causing operational disruption and user frustration.

4. **No Recovery Mechanism**: The `ModifyTokenIssuerAndOwner` method requires the current issuer to call it, [9](#0-8)  which is impossible when the issuer has an empty `Value` field since no valid `Context.Sender` can ever equal an address with empty bytes.

## Likelihood Explanation

**Probability: High**

This vulnerability is highly exploitable:

1. **Reachable Entry Point**: The `Create` method is a public function callable by any user who can pay the creation fee or hold a seed NFT.

2. **Low Attack Complexity**: Exploitation requires only sending a `CreateInput` message with `Creator = new Address { Value = ByteString.Empty }` (an Address object with empty Value). This is trivial to construct in any AElf transaction.

3. **No Special Permissions Required**: Any user can call the Create method - the only barrier is passing the seed NFT check or being in the create whitelist, which is necessary for any protocol creation anyway.

4. **Low Attack Cost**: The cost is merely the NFT creation fee/seed NFT, making griefing attacks economically viable.

5. **Undetectable Until Too Late**: The protocol appears to be created successfully - the vulnerability only manifests when users attempt to mint or manage minters, at which point the damage is already done.

## Recommendation

Add validation to check that the `Address.Value` field is not empty in both locations:

**In NFTContract_Create.cs:**
```csharp
var creator = input.Creator ?? Context.Sender;
Assert(creator != null && !creator.Value.IsNullOrEmpty(), "Invalid creator address.");
```

**In TokenContract_Helper.cs RegisterTokenInfo method:**
```csharp
Assert(tokenInfo.Issuer != null && !tokenInfo.Issuer.Value.IsNullOrEmpty(), "Invalid issuer address.");
Assert(tokenInfo.Owner != null && !tokenInfo.Owner.Value.IsNullOrEmpty(), "Invalid owner address.");
```

This follows the proper validation pattern already used in `ModifyTokenIssuerAndOwner`.

## Proof of Concept

```csharp
[Fact]
public async Task CreateNFTWithEmptyCreatorAddress_ShouldBrickProtocol()
{
    // Issue ELF tokens for gas fees
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "ELF",
        Amount = 1_00000000_00000000,
        To = DefaultAddress
    });

    // Create NFT protocol with empty creator address
    var executionResult = await NFTContractStub.Create.SendAsync(new CreateInput
    {
        BaseUri = "ipfs://aelf/",
        Creator = new Address { Value = ByteString.Empty }, // Empty address!
        IsBurnable = true,
        Metadata = new Metadata
        {
            Value = { { "Description", "Test NFT" } }
        },
        NftType = NFTType.Art.ToString(),
        ProtocolName = "BRICKED",
        TotalSupply = 1000
    });

    var symbol = executionResult.Output.Value;
    
    // Protocol appears created
    var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = symbol });
    protocolInfo.Symbol.ShouldBe(symbol);
    protocolInfo.Creator.Value.IsEmpty.ShouldBeTrue(); // Creator has empty value!

    // Attempt to mint - this will FAIL because Context.Sender can never equal empty address
    var mintException = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await NFTContractStub.Mint.SendAsync(new MintInput
        {
            Symbol = symbol,
            Uri = "ipfs://aelf/test"
        });
    });
    mintException.Message.ShouldContain("No permission"); // Fails because sender != empty address

    // Attempt to add minters - this will also FAIL
    var addMinterException = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await NFTContractStub.AddMinters.SendAsync(new AddMintersInput
        {
            Symbol = symbol,
            MinterList = new MinterList { Value = { DefaultAddress } }
        });
    });
    addMinterException.Message.ShouldContain("No permission"); // Fails because sender != empty creator
    
    // Protocol is permanently bricked - no recovery possible
}
```

## Notes

The vulnerability requires that both the NFT contract and MultiToken contract have insufficient validation. The Address type in protobuf allows construction with empty `Value` field, and the current validation only checks for null object references, not empty byte values. This creates a permanent DoS condition with no recovery path since all permission checks compare `Context.Sender` against the empty-value address, which can never succeed.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L22-22)
```csharp
        var creator = input.Creator ?? Context.Sender;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L23-34)
```csharp
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L230-230)
```csharp
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L642-659)
```csharp
    public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
    {
        Assert(!State.TokenIssuerAndOwnerModificationDisabled.Value, "Set token issuer and owner disabled.");
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
        Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");

        var tokenInfo = GetTokenInfo(input.Symbol);

        Assert(tokenInfo != null, "Token is not found.");
        Assert(tokenInfo.Issuer == Context.Sender, "Only token issuer can set token issuer and owner.");
        Assert(tokenInfo.Owner == null, "Can only set token which does not have owner.");
        
        tokenInfo.Issuer = input.Issuer;
        tokenInfo.Owner = input.Owner;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-338)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L355-358)
```csharp
    public override Empty RemoveMinters(RemoveMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L375-381)
```csharp
    private MinterList GetMinterList(TokenInfo tokenInfo)
    {
        var minterList = State.MinterListMap[tokenInfo.Symbol] ?? new MinterList();
        if (!minterList.Value.Contains(tokenInfo.Issuer)) minterList.Value.Add(tokenInfo.Issuer);

        return minterList;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-399)
```csharp
        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
```
