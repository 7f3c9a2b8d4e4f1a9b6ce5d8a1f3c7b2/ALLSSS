# Audit Report

## Title
Consensus Signature Manipulation via Unvalidated PreviousInValue Input

## Summary
The AEDPoS consensus contract contains a critical vulnerability where miners can manipulate their signature values by providing arbitrary `PreviousInValue` inputs. The signature calculation unconditionally uses miner-controlled input even when validation fails, allowing miners to bias their mining order in subsequent rounds and violate consensus fairness guarantees.

## Finding Description

The vulnerability exists in the `GetConsensusExtraDataToPublishOutValue` function where signature calculation logic is inconsistent with the validation logic. [1](#0-0) 

The code performs a validation check at lines 80-86 to verify if the provided `PreviousInValue` hashes to the expected previous round `OutValue`. When validation fails, it sets `previousInValue = Hash.Empty`. However, the critical bug is at line 92: the signature is **always** calculated using `triggerInformation.PreviousInValue` (the unvalidated, miner-controlled input), regardless of whether validation passed or failed.

This calculated signature directly determines the miner's position in the next round: [2](#0-1) 

The signature is stored and propagates to next round order determination: [3](#0-2) 

The `UpdateValueValidationProvider` fails to detect this manipulation because it only validates that the signature is non-null/non-empty and that the **stored** `previousInValue` (which could be `Hash.Empty`) hashes correctly: [4](#0-3) 

Line 46 explicitly allows `Hash.Empty` as a valid `previousInValue`, and there is no check verifying that `signature == CalculateSignature(previousInValue)`.

The signature calculation itself uses XOR operations with previous round signatures: [5](#0-4) 

**Attack Scenario:**
1. Miner wants to produce a block in round N
2. Offline, miner tries many arbitrary `PreviousInValue` candidates
3. For each candidate, computes `signature = previousRound.CalculateSignature(candidate)`
4. Calculates resulting mining order: `GetAbsModulus(signature.ToInt64(), minersCount) + 1`
5. Selects the candidate that gives the most favorable position
6. Submits block with this manipulated `PreviousInValue`
7. Validation fails (lines 80-86), sets stored `previousInValue = Hash.Empty`
8. But signature was already calculated using manipulated value (line 92)
9. Block passes validation because `Hash.Empty` is allowed (line 46) and signature is non-null
10. Manipulated signature is stored and determines miner's next round position

## Impact Explanation

**Severity: High**

This vulnerability directly compromises a critical consensus invariant: the fairness and unpredictability of miner scheduling. The `SupposedOrderOfNextRound` determines when each miner can produce blocks in subsequent rounds. By manipulating their signature, miners can:

- Secure earlier positions in the mining schedule, giving more frequent block production opportunities
- Gain advantages in transaction ordering and inclusion decisions
- Potentially exploit timing-sensitive operations like cross-chain transactions or MEV opportunities
- Systematically bias the consensus mechanism in their favor over honest participants

While this does not lead to direct fund theft, it fundamentally undermines the consensus mechanism's integrity by breaking the randomness and fairness properties that AEDPoS is designed to guarantee. The mining schedule should be unpredictable and fair based on cryptographically-committed random values, not manipulable by individual miners.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly practical to exploit:

**Attacker Profile:** Any authorized miner in the consensus network. No special privileges beyond normal mining rights are required.

**Attack Complexity:** Low
- Miners control their node software and can modify the `AEDPoSTriggerInformationProvider` to provide arbitrary `PreviousInValue` values
- Offline computation is inexpensive: try different values, compute signatures, calculate resulting orders
- Select the most favorable value before submitting the block
- No economic cost beyond normal block production

**Success Rate:** 100% - The miner has full control over the input, and the validation logic allows the attack to succeed. The manipulated block will be accepted by the network as valid consensus data.

**Detection Difficulty:** Very difficult - The manipulated values appear as valid consensus data. Other validators see `previousInValue = Hash.Empty` and a signature value, but have no mechanism to detect that the signature was calculated using an invalid input rather than the legitimate value.

## Recommendation

**Fix:** Modify line 92 to use the validated `previousInValue` variable instead of the raw `triggerInformation.PreviousInValue`:

```csharp
// Move line 92 outside and below the if-else block (after line 90)
// So it uses the validated previousInValue variable:

if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
    previousRound.RealTimeMinersInformation[pubkey].OutValue)
{
    previousInValue = Hash.Empty;
}
else
{
    previousInValue = triggerInformation.PreviousInValue;
}

// Fixed: Calculate signature using the validated previousInValue
signature = previousRound.CalculateSignature(previousInValue);
```

This ensures that:
- If validation passes, the signature uses the legitimate `PreviousInValue`
- If validation fails, the signature uses `Hash.Empty` or falls back to the logic at lines 94-108
- The signature is always consistent with the stored `previousInValue`
- Miners cannot manipulate their signature by providing invalid inputs

## Proof of Concept

A complete proof of concept would require:

1. Setting up an AElf test network with multiple miners
2. Modifying one miner's node to provide arbitrary `PreviousInValue` values
3. Demonstrating that blocks with invalid `PreviousInValue` are accepted
4. Showing that the manipulated signature affects the miner's position in subsequent rounds
5. Comparing mining order distribution between honest and manipulating miners

The test would demonstrate that a malicious miner can consistently achieve favorable positions (e.g., earlier slots) compared to the expected uniform random distribution, proving that consensus fairness is violated.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L74-93)
```csharp
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-22)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-49)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
