# Audit Report

## Title
Validation Bypass via Data Contamination Enables Last Irreversible Block (LIB) Manipulation

## Summary
The AEDPoS consensus validation logic contaminates trusted round state with untrusted block header data before performing validation checks. This causes the `LibInformationValidationProvider` to compare a value against itself, always passing validation. Malicious miners can exploit this to submit arbitrary `ImpliedIrreversibleBlockHeight` values, enabling LIB manipulation with control of ⅓+ miners.

## Finding Description

The vulnerability exists in the validation flow for `UpdateValue` consensus behavior. The contract retrieves trusted round state from storage, but then modifies this trusted data with untrusted input BEFORE running validation checks.

**Data Contamination Flow:**

The `ValidateBeforeExecution` method retrieves trusted state [1](#0-0) , then immediately contaminates it by calling `RecoverFromUpdateValue` [2](#0-1) .

The `RecoverFromUpdateValue` method directly overwrites the trusted `ImpliedIrreversibleBlockHeight` with the untrusted value [3](#0-2) .

After contamination, the validation context is created with the now-modified baseRound [4](#0-3) .

**Validation Bypass:**

The `LibInformationValidationProvider` attempts to validate that the height hasn't regressed [5](#0-4) . However, since `baseRound` was just contaminated with the same value from `providedRound` [6](#0-5) , this check becomes `X > X`, which always evaluates to false, causing validation to always pass.

**Intended Behavior vs Exploit:**

The contract sets `ImpliedIrreversibleBlockHeight` to the current block height when generating consensus data [7](#0-6) . However, a malicious miner can modify this value in the block header before submission. The validation should reject values below the stored height, but fails due to the contamination bug.

**State Persistence:**

After bypassing validation, the malicious value is persisted to state [8](#0-7) .

**LIB Calculation:**

The persisted malicious values are used in LIB calculation [9](#0-8) . The `LastIrreversibleBlockHeightCalculator` collects sorted heights and selects the value at position `(count-1)/3` [10](#0-9) .

## Impact Explanation

**Critical Severity - Consensus Integrity Breach**

With control of ⅓+ miners (the threshold needed to influence LIB consensus), attackers can:

1. **Force LIB Regression**: Submit `ImpliedIrreversibleBlockHeight = 0` or values below current LIB. Example with 21 miners: 7 malicious miners submit height=0, 14 honest miners submit height=10000. Sorted array: [0,0,0,0,0,0,0,10000,...]. Position (21-1)/3=6 yields LIB=0, causing finality to regress.

2. **Finality DoS**: Consistently report low values to prevent LIB from advancing, blocking transaction finality indefinitely.

3. **Break Irreversibility Guarantees**: The core consensus invariant that LIB heights must be monotonically increasing is violated, undermining the fundamental security property of the blockchain.

**Affected Parties:**
- All network participants relying on block finality
- Cross-chain bridges and external systems using LIB for confirmation  
- Applications depending on irreversible transaction guarantees

## Likelihood Explanation

**High Probability**

**Attacker Capabilities:** Any authorized miner in the current round can exploit this vulnerability through normal block production flow.

**Attack Complexity:** Low - The exploit requires only:
1. Being an active miner (by design, not a privilege escalation)
2. Producing a block with `UpdateValue` behavior
3. Modifying `ImpliedIrreversibleBlockHeight` in consensus extra data before block submission
4. No complex state setup or preconditions required

**Feasibility:** The attack is deterministic and repeatable. The validation is called via the standard ACS4 interface [11](#0-10)  during block validation before execution, meaning every UpdateValue block goes through the vulnerable code path.

**Detection:** The bypassed validation means no error or event is raised, making detection difficult without external monitoring.

## Recommendation

**Fix: Perform validation BEFORE contaminating trusted state**

The validation context should be created with the original, unmodified `baseRound`, while keeping a separate copy for post-validation recovery. The fix should:

1. Create validation context with original `baseRound` before any modifications
2. Only apply `RecoverFromUpdateValue`/`RecoverFromTinyBlock` after successful validation
3. Or create a deep copy of `baseRound` before contamination for validation purposes

**Suggested Code Fix:**

```csharp
private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
{
    if (!TryToGetCurrentRoundInformation(out var baseRound))
        return new ValidationResult { Success = false, Message = "Failed to get current round information." };

    // [Rest of initial checks...]

    // Create validation context with UNMODIFIED baseRound
    var validationContext = new ConsensusValidationContext
    {
        BaseRound = baseRound,  // Use original trusted state
        CurrentTermNumber = State.CurrentTermNumber.Value,
        CurrentRoundNumber = State.CurrentRoundNumber.Value,
        PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
        LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
        ExtraData = extraData
    };

    // Add validators and run validation...
    var validationResult = service.ValidateInformation(validationContext);
    
    // Only after successful validation, recover/update the round
    if (validationResult.Success)
    {
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
    }
    
    return validationResult;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task LIB_Manipulation_Via_Validation_Bypass()
{
    // Setup: Initialize consensus with 21 miners
    var miners = GenerateMiners(21);
    await InitializeConsensus(miners);
    await ProduceNormalBlocks(100); // LIB should be around block 95-97
    
    var currentLIB = await GetCurrentLIB();
    Assert.True(currentLIB > 90); // Verify LIB progressed normally
    
    // Attack: 7 malicious miners (1/3) submit blocks with ImpliedIrreversibleBlockHeight = 0
    var maliciousMinerCount = 7;
    for (int i = 0; i < maliciousMinerCount; i++)
    {
        var maliciousMiner = miners[i];
        
        // Create UpdateValue block but manually override ImpliedIrreversibleBlockHeight
        var consensusExtraData = await GenerateConsensusExtraData(maliciousMiner);
        consensusExtraData.Round.RealTimeMinersInformation[maliciousMiner.PublicKey.ToHex()]
            .ImpliedIrreversibleBlockHeight = 0; // Malicious value
        
        // Submit block - validation should reject but actually passes due to contamination
        var result = await SubmitBlock(maliciousMiner, consensusExtraData);
        Assert.True(result.Success); // Validation bypassed
    }
    
    // Verify Impact: LIB has regressed to 0 or very low value
    var manipulatedLIB = await GetCurrentLIB();
    Assert.True(manipulatedLIB < 10); // LIB has been manipulated to near-zero
    Assert.True(manipulatedLIB < currentLIB); // LIB regression occurred - CRITICAL INVARIANT BROKEN
}
```

## Notes

**Important Clarifications:**

1. **TinyBlock Behavior:** While the claim mentions both UpdateValue and TinyBlock, the vulnerability is only exploitable for `UpdateValue` behavior. For TinyBlock, `LibInformationValidationProvider` is not added to the validator list, and `ProcessTinyBlock` does not persist `ImpliedIrreversibleBlockHeight` from input. The contamination occurs but has no security impact for TinyBlock.

2. **Attack Threshold:** The attack requires control of ⅓+ miners because the LIB calculation takes the value at position `(count-1)/3` from the sorted array of heights. With N miners, controlling floor(N/3)+1 miners guarantees the malicious value will be selected.

3. **Validation Entry Point:** The vulnerability is triggered through the standard ACS4 consensus validation interface during block validation before execution, meaning it affects all UpdateValue blocks in the normal consensus flow.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L19-19)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-282)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L32-32)
```csharp
            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```
