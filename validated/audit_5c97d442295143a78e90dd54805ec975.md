# Audit Report

## Title
VoteId Collision Causing Permanent Token Lock Due to Insufficient Uniqueness in ID Generation

## Summary
The Vote contract generates VoteId using only the current voting result's VotesAmount, omitting the VotingItemId from the hash. When a contract calls Vote twice in one transaction on different voting items with identical VotesAmount values (commonly 0 for newly created items), the collision causes the second VotingRecord to overwrite the first while both Lock operations succeed and accumulate tokens at the same virtual address. This results in permanent loss of the overwritten vote's locked tokens.

## Finding Description

**Root Cause - Insufficient VoteId Uniqueness:**

The Vote contract generates VoteId using an incomplete formula that excludes the VotingItemId: [1](#0-0) 

The underlying `GenerateId` implementation uses OriginTransactionId, which remains constant across inline calls within the same transaction: [2](#0-1) 

This generates: `Hash(OriginTransactionId + VoteContractAddress + VotesAmount)`. Since VotesAmount is independent per voting item, two different voting items can have identical VotesAmount values (commonly 0 for newly registered items), resulting in VoteId collision when voted within the same transaction.

Newly registered voting items initialize with VotesAmount=0: [3](#0-2) 

**Missing Collision Protection:**

The Vote contract directly overwrites VotingRecords without checking for existing entries: [4](#0-3) 

In contrast, the Election contract implements explicit collision protection: [5](#0-4) 

**Token Lock Accumulation:**

When Lock is called multiple times with the same LockId, tokens accumulate at the same virtual address. The virtual address is deterministically computed from `Context.Sender + input.Address + input.LockId`: [6](#0-5) 

Identical LockIds (VoteIds) result in the same destination where tokens accumulate through successive transfers to the same virtual address.

**Unlock Limited by Overwritten Record:**

During withdrawal, the Unlock operation retrieves the amount from the VotingRecord, which reflects only the last vote after overwrite: [7](#0-6) 

**System Contract Authorization:**

The Vote contract is a registered system contract, allowing it to bypass Lock whitelist restrictions: [8](#0-7) 

System contracts automatically pass the Lock authorization check: [9](#0-8) 

**Attack Execution Path:**

1. Attacker contract calls `VoteContract.Vote(votingItemId1, amount=100)` where votingResult1.VotesAmount=0
   - VoteId = Hash(OriginTxId + VoteContract + 0)
   - Lock transfers 100 tokens to virtualAddress = Hash(VoteContract + voter + VoteId)
   - VotingRecords[VoteId] = {amount: 100, itemId: item1}

2. Same contract calls `VoteContract.Vote(votingItemId2, amount=200)` where votingResult2.VotesAmount=0
   - VoteId = Hash(OriginTxId + VoteContract + 0) — **COLLISION**
   - Lock transfers 200 tokens to **same virtualAddress** (now holds 300 total)
   - VotingRecords[VoteId] = {amount: 200, itemId: item2} — **OVERWRITES**

3. Withdrawal attempt:
   - Withdraw(VoteId) retrieves overwritten record showing amount=200
   - Unlock returns only 200 tokens
   - **100 tokens remain permanently locked** in virtual address

## Impact Explanation

**Direct Fund Loss:**
- Permanent, irreversible token lock in virtual address with no recovery mechanism
- Example: Vote1 locks 100 tokens, Vote2 locks 200 tokens with colliding VoteId → Virtual address contains 300 tokens but only 200 withdrawable → 100 tokens permanently lost

**Affected Parties:**
- Batch voting contracts (governance automation, voting aggregators)
- Users depositing tokens into such contracts
- Protocol token supply integrity (accumulation of permanently locked tokens)

**Invariant Violation:**
- Breaks critical locking invariant: `sum(Lock amounts) == sum(Unlock amounts)`
- Violates assumption that every Lock has corresponding recoverable Unlock
- Corrupts VotingRecord integrity (one record representing multiple locks)

**Severity Justification:**
HIGH severity because:
1. Permanent, irreversible fund loss
2. No privileged role requirements
3. Violation of core token locking mechanism
4. Realistic attack vector affecting legitimate use cases

## Likelihood Explanation

**Attack Complexity: MEDIUM**

Prerequisites:
1. Deploy contract with inline call capability (standard AElf functionality)
2. Identify two voting items with matching VotesAmount (trivial: new items start at 0)
3. Execute both votes in single transaction

**Feasible Preconditions:**
- Vote contract is system contract (default configuration), enabling Lock whitelist bypass
- Voting items configured with `IsLockToken=true` (standard governance configuration)
- No special timing or race conditions required

**Execution Practicality:**
- Standard contract deployment and execution
- Newly registered voting items guarantee VotesAmount=0, ensuring collision
- Attack succeeds deterministically without external dependencies

**Real-World Scenarios:**
- Governance bots voting on multiple proposals simultaneously
- Voting aggregator services batching votes for efficiency
- Multi-signature contracts executing batch governance operations
- Any legitimate contract implementing parallel voting functionality

**Detection Difficulty:**
- Collision not visible in transaction logs (appears as normal voting)
- Discovered only during withdrawal attempts or forensic balance analysis
- No alerts or events indicate the state corruption

## Recommendation

Implement VoteId generation that includes both VotingItemId and a unique sequence identifier to prevent collisions:

```csharp
// Option 1: Include VotingItemId in the hash
input.VoteId = Context.GenerateId(Context.Self, 
    ByteArrayHelper.ConcatArrays(
        votingItem.VotingItemId.Value.ToByteArray(),
        votingResult.VotesAmount.ToBytes(false)
    ));

// Option 2: Add collision detection similar to Election contract
var voteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
Assert(State.VotingRecords[voteId] == null, "Vote already exists.");
State.VotingRecords[voteId] = votingRecord;
```

Additionally, consider allowing callers to provide optional tokens for uniqueness (as Election contract does) when voting from contracts that need to manage multiple votes in the same transaction.

## Proof of Concept

```csharp
// Test demonstrating VoteId collision
[Fact]
public async Task VoteId_Collision_Causes_Token_Loss()
{
    // Setup: Register two voting items with IsLockToken=true
    var votingItem1 = await RegisterVotingItem("Item1");
    var votingItem2 = await RegisterVotingItem("Item2");
    
    // Deploy attacker contract that votes twice in same transaction
    var attackerContract = await DeployBatchVoterContract();
    
    // Transfer 300 tokens to attacker contract
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = attackerContract,
        Symbol = "ELF",
        Amount = 300
    });
    
    // Execute batch vote: votes on both items in single transaction
    await attackerContract.BatchVote.SendAsync(new BatchVoteInput
    {
        VotingItems = { votingItem1, votingItem2 },
        Amounts = { 100, 200 }
    });
    
    // Verify collision: both votes generate same VoteId
    var voteId = GetGeneratedVoteId(); // Both calls generate same ID
    var votingRecord = await VoteContractStub.GetVotingRecord.CallAsync(voteId);
    
    // Verify overwrite: record shows only second vote
    votingRecord.VotingItemId.ShouldBe(votingItem2);
    votingRecord.Amount.ShouldBe(200); // Only last vote amount
    
    // Verify token accumulation in virtual address
    var virtualAddress = ComputeVirtualAddress(voteId);
    var virtualBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = virtualAddress,
        Symbol = "ELF"
    });
    virtualBalance.Balance.ShouldBe(300); // Both locks accumulated
    
    // Attempt withdrawal
    await VoteContractStub.Withdraw.SendAsync(new WithdrawInput { VoteId = voteId });
    
    // Verify permanent loss: only 200 tokens recovered
    var attackerBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = attackerContract,
        Symbol = "ELF"
    });
    attackerBalance.Balance.ShouldBe(200); // Lost 100 tokens
    
    // Verify tokens remain locked
    virtualBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = virtualAddress,
        Symbol = "ELF"
    });
    virtualBalance.Balance.ShouldBe(100); // 100 tokens permanently locked
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L56-63)
```csharp
        // Initialize first voting going information of registered voting event.
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-117)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L193-231)
```csharp
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;

        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L390-398)
```csharp
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L139-146)
```csharp
    public Hash GenerateId(Address contractAddress, IEnumerable<byte> bytes)
    {
        var contactedBytes = OriginTransactionId.Value.Concat(contractAddress.Value);
        var enumerable = bytes as byte[] ?? bytes?.ToArray();
        if (enumerable != null)
            contactedBytes = contactedBytes.Concat(enumerable);
        return HashHelper.ComputeFrom(contactedBytes.ToArray());
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L432-434)
```csharp
        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-212)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```

**File:** src/AElf.Sdk.CSharp/SmartContractConstants.cs (L21-21)
```csharp
    public static readonly Hash VoteContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Vote");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L196-203)
```csharp
    private void AssertSystemContractOrLockWhiteListAddress(string symbol)
    {
        var symbolState = State.LockWhiteLists[symbol];
        var isInWhiteList = symbolState != null && symbolState[Context.Sender];
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Values;
        var isSystemContractAddress = systemContractAddresses.Contains(Context.Sender);
        Assert(isInWhiteList || isSystemContractAddress, "No Permission.");
    }
```
