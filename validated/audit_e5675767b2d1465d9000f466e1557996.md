# Audit Report

## Title
Missed Time Slots Reset Without Evil Miner Detection at Term Boundaries

## Summary
The `ProcessNextTerm()` function resets `MissedTimeSlots` counters to zero for all miners when transitioning to a new term, but critically fails to check if any miner exceeded the evil threshold (4320 missed slots) before the reset. This allows miners with poor performance to avoid punishment by having their counters cleared at term boundaries without triggering the evil miner detection mechanism that only executes during round transitions.

## Finding Description

The AEDPoS consensus system has two distinct transition paths with asymmetric security controls:

**During Round Transitions (Normal Operation):**

The `ProcessNextRound()` function correctly implements evil miner detection [1](#0-0) 

This detection uses the `TryToDetectEvilMiners()` method which checks if any miner's `MissedTimeSlots` exceeds the tolerable threshold [2](#0-1) 

The threshold is defined as 4320 slots (3 days at 1-minute intervals) [3](#0-2) 

**During Term Transitions (Vulnerability):**

However, the `ProcessNextTerm()` function follows a different code path that bypasses this check. It calls `CountMissedTimeSlots()` to increment the counter one final time [4](#0-3) 

But then immediately resets all counters to zero without any evil detection check [5](#0-4) 

**Why Existing Protections Fail:**

Missed time slots accumulate during normal round generation for miners who fail to produce blocks [6](#0-5) 

While historical data is sent to the Election contract via `UpdateCurrentMinerInformationToElectionContract()` [7](#0-6) 

The Election contract only accumulates this data for tracking purposes and does NOT trigger any automatic ban [8](#0-7) 

The only banning mechanism requires explicit `IsEvilNode = true` flag [9](#0-8) 

Term transition conditions are triggered automatically based on elapsed time [10](#0-9) 

**Attack Execution Path:**

1. Attacker (current miner) strategically misses time slots during a term, accumulating up to ~4,319 missed slots
2. Term transition condition is triggered based on elapsed time (typically 7 days)
3. `ProcessNextTerm()` is called instead of `ProcessNextRound()`
4. `CountMissedTimeSlots()` may push the counter to 4,320+
5. Counter is immediately reset to 0 without `TryToDetectEvilMiners()` being invoked
6. Attacker continues in new term with clean slate (if re-elected)
7. Process repeats indefinitely across multiple terms

## Impact Explanation

This vulnerability breaks a **critical consensus integrity invariant**: miners must be held accountable for persistent poor performance through the evil node detection and banning mechanism.

**Direct Protocol Impact:**
- Miners can systematically underperform by missing ~4,300 slots per term across unlimited terms without facing the intended punishment
- With 1-minute time slots, this represents ~72 hours of continuous downtime per term
- In a typical 7-day term, this allows 43% downtime (72/168 hours) without consequences
- The consensus mechanism's reliability is directly undermined as unreliable miners remain in the active set

**Affected Parties:**
- **Honest miners**: Disadvantaged as they maintain high availability while malicious miners reduce operational costs without consequence
- **Network users**: Experience degraded service quality with inconsistent block production  
- **Economic model**: The entire reward and election system based on miner performance metrics is compromised

**Severity: HIGH** because:
- Completely bypasses an intended security mechanism (not a partial weakening)
- Allows indefinite exploitation across all future terms
- No automatic remediation - the punishment system is entirely circumvented
- Fundamentally undermines validator set trustworthiness and consensus reliability

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a current miner in the active set (standard prerequisite for any consensus-level exploit)
- No additional privileges, tokens, or governance control required

**Attack Complexity: LOW**
1. Monitor own `MissedTimeSlots` counter via public round information queries
2. Intentionally miss time slots while staying just under 4,320 per term
3. Let natural term transitions reset the counter
4. Repeat indefinitely

**Feasibility: HIGH**
- **No timing precision required**: The vulnerability exists passively at every term boundary
- **No coordination needed**: Single miner acting alone can exploit
- **Strong economic incentive**: Reduce infrastructure/operational costs by running unreliable nodes
- **Detection difficult**: Requires manual cross-term historical analysis of accumulated missed slots

**Operational Constraints:**

Manual intervention is technically possible via the emergency response organization [11](#0-10) 

However, this is reactive and requires:
- Continuous manual monitoring across term boundaries
- Governance process to identify and remove offenders
- Cannot prevent the underlying vulnerability from being exploited

**Probability: HIGH** - The combination of low complexity, passive exploitation at natural term boundaries, and strong economic incentive makes this highly likely to be exploited in a live environment.

## Recommendation

Insert evil miner detection before resetting counters in `ProcessNextTerm()`. The fix should check for evil miners using the same logic as `ProcessNextRound()` before clearing the `MissedTimeSlots` counters:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    RecordMinedMinerListOfCurrentRound();

    // Count missed time slot of current round.
    CountMissedTimeSlots();

    // FIX: Add evil miner detection BEFORE resetting counters
    if (State.IsMainChain.Value && 
        TryToGetCurrentRoundInformation(out var currentRound) &&
        currentRound.TryToDetectEvilMiners(out var evilMiners))
    {
        foreach (var evilMiner in evilMiners)
        {
            State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
            {
                Pubkey = evilMiner,
                IsEvilNode = true
            });
        }
    }

    Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");
    
    // Continue with rest of term transition logic...
}
```

This ensures that miners who exceed the evil threshold during a term are properly flagged and banned before their counters are reset, maintaining the consensus integrity invariant across both round and term transitions.

## Proof of Concept

A proof of concept would involve:

1. Setting up a test environment with the AEDPoS consensus contract
2. Simulating a miner missing 4,319 time slots during a term
3. Triggering a term transition via `NextTerm()` 
4. Verifying that:
   - The miner's `MissedTimeSlots` counter is reset to 0
   - No evil miner detection occurs
   - The miner is NOT banned in the Election contract
5. Demonstrating the miner can repeat this pattern across multiple terms

The test would prove that the evil miner detection mechanism is completely bypassed during term transitions, allowing miners to systematically underperform without automatic punishment.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L168-168)
```csharp
        CountMissedTimeSlots();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L179-183)
```csharp
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L201-201)
```csharp
        UpdateCurrentMinerInformationToElectionContract(previousRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L87-96)
```csharp
    private void CountMissedTimeSlots()
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return;

        foreach (var minerInRound in currentRound.RealTimeMinersInformation)
            if (minerInRound.Value.OutValue == null)
                minerInRound.Value.MissedTimeSlots = minerInRound.Value.MissedTimeSlots.Add(1);

        TryToUpdateRoundInformation(currentRound);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L115-119)
```csharp
        candidateInformation.ProducedBlocks = candidateInformation.ProducedBlocks.Add(input.RecentlyProducedBlocks);
        candidateInformation.MissedTimeSlots =
            candidateInformation.MissedTimeSlots.Add(input.RecentlyMissedTimeSlots);
        State.CandidateInformationMap[input.Pubkey] = candidateInformation;
        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-350)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
```
