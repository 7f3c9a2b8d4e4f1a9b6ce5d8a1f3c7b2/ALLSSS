# Audit Report

## Title
Missing Minimum Miner Participation Check in NextRound Validation Allows Premature Round Transitions Without Byzantine Fault Tolerance Consensus

## Summary
The AEDPoS consensus contract's `ValidationForNextRound()` method lacks validation to ensure that at least `MinersCountOfConsent` (2/3 + 1 threshold) miners participated in the current round before allowing transition to the next round. This creates a critical architectural inconsistency that allows minority miners to force round transitions, and if sustained for over 3 days, leads to honest majority miners being marked as evil and replacedâ€”effectively enabling consensus takeover.

## Finding Description

The AEDPoS consensus system enforces a Byzantine Fault Tolerance threshold defined as `MinersCountOfConsent = RealTimeMinersInformation.Count * 2 / 3 + 1` for critical consensus operations. [1](#0-0) 

However, the `ValidationForNextRound()` method only validates that the round number increments by exactly 1 and that all `InValue` fields in the next round are null, without checking minimum miner participation: [2](#0-1) 

The validation providers added for `NextRound` behavior include `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider`: [3](#0-2) 

The `NextRoundMiningOrderValidationProvider` only validates that miners with `FinalOrderOfNextRound > 0` match those with `OutValue != null`, ensuring consistency but NOT a minimum count threshold: [4](#0-3) 

In stark contrast, the system correctly enforces `MinersCountOfConsent` for **LIB Calculation**: [5](#0-4) 

And for **Term Changes**: [6](#0-5) 

**The Attack Flow:**

1. Any miner can call the public `NextRound()` method: [7](#0-6) 

2. In a network with 7 miners (MinersCountOfConsent = 5), if only 2 miners participate in round N, they can call `NextRound()` and pass all validations because no check enforces minimum participation.

3. The next round is generated including all miners, with non-participants getting their `MissedTimeSlots` incremented: [8](#0-7) 

4. After sustained minority operation exceeding `TolerableMissedTimeSlotsCount`: [9](#0-8) 

5. The honest majority miners are marked as evil: [10](#0-9) 

6. These "evil" miners are then reported and replaced: [11](#0-10) [12](#0-11) 

## Impact Explanation

**Critical Consensus Integrity Violation:**

This vulnerability breaks fundamental BFT consensus guarantees through two mechanisms:

**Immediate Impact:**
- Round transitions occur with minority participation (e.g., 2 out of 7 miners = 28%), violating the 2/3 threshold
- While LIB advancement correctly requires MinersCountOfConsent (creating a "safety net"), the network operates in a degraded state without finality
- Creates an architectural inconsistency where round progression doesn't respect the same consensus threshold as LIB and term changes

**Delayed Critical Impact (after 3+ days):**
- Honest majority miners accumulate `MissedTimeSlots` and eventually exceed `TolerableMissedTimeSlotsCount` (4,320 slots = 3 days)
- The system incorrectly identifies the HONEST MAJORITY as "evil miners"
- These honest miners are marked as evil and replaced with alternates
- The minority miners (potentially malicious) remain in control and avoid punishment
- This inverts the security model: attackers remain, honest nodes are ejected
- Enables permanent consensus takeover even after network partition heals

**Affected Parties:**
- Network integrity: BFT consensus guarantees violated
- Honest validators: Incorrectly penalized and removed after sustained adverse conditions  
- Users: Loss of finality guarantees during attack, potential for malicious minority control after 3 days

## Likelihood Explanation

**Likelihood Assessment: MEDIUM**

The critical impact (honest majority removal) requires specific sustained conditions:

**Prerequisites:**
- Network partition OR targeted DoS separating minority from majority miners
- Adverse conditions lasting >3 days (4,320 consecutive time slots)
- Minority miners (2+) continue functioning normally while majority (5+) cannot participate

**Feasibility:**
- Natural network partitions: Possible but rarely last 3+ days
- Targeted DoS: Requires resources and coordination but is realistic for motivated attackers
- The attack is technically straightforward once conditions exist

**Attack Complexity:**
- LOW technical complexity: Simply call `NextRound()` method
- HIGH operational complexity: Maintaining adverse conditions for 3+ days
- No special privileges required beyond being in the miner list

**Detection:**
- Gradual degradation makes early detection difficult
- No immediate alerts for insufficient round participation
- LIB halting would be visible but might be attributed to normal network issues

## Recommendation

Add a minimum participation check in `ValidationForNextRound()` to enforce the same 2/3 threshold used by LIB and term changes:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Check round number
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // Check InValues are null
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Check minimum participation threshold
    var participatedMinersCount = validationContext.BaseRound.RealTimeMinersInformation.Values
        .Count(m => m.OutValue != null);
    var minersCountOfConsent = validationContext.BaseRound.MinersCountOfConsent;
    
    if (participatedMinersCount < minersCountOfConsent)
        return new ValidationResult 
        { 
            Message = $"Insufficient miner participation: {participatedMinersCount}/{minersCountOfConsent} required for round transition." 
        };
    
    return new ValidationResult { Success = true };
}
```

This ensures architectural consistency across all consensus operations and prevents minority miners from forcing round transitions.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Initialize a network with 7 miners (MinersCountOfConsent = 5)
2. Have only 2 miners produce blocks in the current round
3. Call `NextRound()` with the 2 miners' consensus data
4. Verify the transaction succeeds and round increments (demonstrating missing validation)
5. Verify that after 4,320 rounds, the 5 non-participating miners are marked as evil
6. Confirm the 5 honest miners are removed and replaced

The core vulnerability can be proven by showing that `NextRound()` succeeds with only 2 out of 7 miners participating, when it should require 5 (MinersCountOfConsent).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-30)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L39-56)
```csharp
        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-342)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```
