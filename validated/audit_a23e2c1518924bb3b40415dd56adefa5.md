# Audit Report

## Title
Incomplete Auto-Distribution Logic Causes Profit Misallocation Across Multiple Token Types

## Summary
The `RegisterForProfits()` method in the TokenHolder contract contains a premature `break` statement that exits the auto-distribution loop after processing only the first qualifying token. This causes tokens contributed in the same timeframe to be distributed across different periods with different beneficiary sets, resulting in unfair profit allocation where early registrants receive disproportionately higher rewards than later participants with equal stakes.

## Finding Description

The auto-distribution logic in `RegisterForProfits()` iterates through all tokens configured in `AutoDistributeThreshold`, but terminates prematurely after finding the first token that meets its threshold. [1](#0-0) 

The problematic flow occurs when:

1. A beneficiary is added with `StartPeriod` set to the scheme's current period [2](#0-1) 

2. The auto-distribution check runs, but only the FIRST qualifying token gets added to `distributedInput.AmountsMap` before the loop breaks at line 199

3. `DistributeProfits()` processes only tokens present in the input's `AmountsMap` [3](#0-2) 

4. The period increments after distribution [4](#0-3) 

5. Remaining qualifying tokens stay in the general ledger until the next registration event triggers their distribution to a different period with a different beneficiary set

This breaks the core invariant that beneficiaries with equal shares should receive proportionally equal rewards from tokens contributed in the same timeframe.

## Impact Explanation

**Direct Fund Impact - Reward Misallocation:**

Consider this concrete scenario:
- Scheme created with `AutoDistributeThreshold = {ELF: 1000, JUN: 1000}`
- Both ELF (1000) and JUN (1000) are contributed to the general ledger in Period 1
- User A registers with 100 shares:
  - Added as beneficiary for Period 1
  - Auto-distribution triggers: only ELF is distributed to Period 1 (loop breaks after first match)
  - Period increments to 2
  - JUN remains in general ledger
- User B registers with 100 shares:
  - Added as beneficiary for Period 2 (cannot claim Period 1 profits)
  - Auto-distribution triggers: JUN is distributed to Period 2
  - Period increments to 3

**Financial Result:**
- User A claims: 100% of ELF (sole beneficiary in Period 1) + 50% of JUN (100/200 shares in Period 2)
- User B claims: 0% of ELF (not eligible for Period 1) + 50% of JUN (100/200 shares in Period 2)

Despite making equal 100-share contributions, User A receives significantly more value due to timing rather than merit. This violates the fundamental fairness guarantee of proportional profit distribution.

**Affected Parties:** All TokenHolder schemes using multi-token auto-distribution, which is a common pattern for dividend-paying DApps handling multiple reward tokens.

## Likelihood Explanation

**Occurrence Probability:** HIGH

The vulnerability triggers deterministically whenever:
1. A scheme configures multiple tokens in `AutoDistributeThreshold` (common for multi-reward systems)
2. Multiple tokens simultaneously meet their respective thresholds (realistic when contributions arrive in batches)
3. Users register sequentially (normal operation)

**Attack Complexity:** TRIVIAL
- No special permissions required - `RegisterForProfits()` is a public method
- Attacker simply monitors when multiple thresholds are met
- First registration captures exclusive access to the first token's period
- Later registrants are automatically disadvantaged

**Detection Difficulty:** The vulnerability manifests as normal contract behavior. Victims only discover the misallocation when claiming profits and comparing actual vs. expected rewards.

## Recommendation

Remove the `break` statement at line 199 in `RegisterForProfits()` to allow the loop to process all qualifying tokens. The corrected logic should continue iterating and add ALL tokens that meet their thresholds to `distributedInput.AmountsMap` before calling `DistributeProfits()`.

The fix should change the loop logic from:
```csharp
foreach (var threshold in scheme.AutoDistributeThreshold)
{
    // ... balance check ...
    if (balance < threshold.Value) continue;
    // ... create distributedInput ...
    distributedInput.AmountsMap[threshold.Key] = 0;
    break; // REMOVE THIS
}
```

To:
```csharp
foreach (var threshold in scheme.AutoDistributeThreshold)
{
    // ... balance check ...
    if (balance < threshold.Value) continue;
    // ... create distributedInput ...
    distributedInput.AmountsMap[threshold.Key] = 0;
    // Continue to next token (no break)
}
```

This ensures all qualifying tokens are distributed to the same period with the same beneficiary set.

## Proof of Concept

```csharp
[Fact]
public async Task MultiTokenAutoDistribution_UnfairAllocation_Test()
{
    // Setup: Create scheme with multi-token auto-distribution
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        AutoDistributeThreshold = 
        {
            {"ELF", 1000},
            {"JUN", 1000}
        }
    });

    // Contribute both ELF and JUN to general ledger
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 1000
    });
    
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "JUN",
        Amount = 1000
    });

    // User A registers with 100 shares (triggers auto-distribution)
    var userAStub = GetTokenHolderContractTester(UserKeyPairs[0]);
    await userAStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = Starter,
        Amount = 100
    });

    // User B registers with 100 shares (triggers auto-distribution again)
    var userBStub = GetTokenHolderContractTester(UserKeyPairs[1]);
    await userBStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = Starter,
        Amount = 100
    });

    // Claim profits
    await userAStub.ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeManager = Starter });
    await userBStub.ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeManager = Starter });

    // Check balances - User A should have more than User B despite equal shares
    var userAElfBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddresses[0],
        Symbol = "ELF"
    });
    
    var userBElfBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddresses[1],
        Symbol = "ELF"
    });

    // BUG: User A gets 100% of ELF, User B gets 0%
    userAElfBalance.Balance.ShouldBe(1000); // Full ELF amount
    userBElfBalance.Balance.ShouldBe(0);    // No ELF
    
    // This demonstrates unfair allocation: equal shares should get equal rewards
}
```

**Notes:**
- The vulnerability is located in the auto-distribution loop that processes `AutoDistributeThreshold` tokens
- The premature `break` statement prevents subsequent qualifying tokens from being distributed in the same period
- This creates a timing-dependent advantage for early registrants over later registrants with equal stakes
- The fix is straightforward: remove the `break` statement to allow complete iteration through all qualifying tokens

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L184-200)
```csharp
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L203-205)
```csharp
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L433-445)
```csharp
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
```
