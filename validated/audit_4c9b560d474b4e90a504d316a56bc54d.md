# Audit Report

## Title
NFT Contract Spam Prevention Failure - Broken ACS1 Implementation Allows Near-Zero-Cost State Bloat Attack

## Summary
The NFT contract's ACS1 (transaction fee standard) implementation is fundamentally broken, with `SetMethodFee()` and `ChangeMethodFeeController()` being non-functional no-op stubs. Only the `Create` method enforces a meaningful fee (100 ELF), while `Mint`, `Transfer`, and `TransferFrom` operations charge only negligible transaction size fees (~0.0000000063 ELF per operation). This allows an attacker to spam millions of permanent state-bloating operations for minimal cost, violating AElf's core economic security model.

## Finding Description

The NFT contract implements the ACS1 transaction fee standard incompletely and incorrectly. The fee configuration methods are non-functional stubs that perform no storage operations: [1](#0-0) 

The `GetMethodFee()` method only returns a hardcoded 100 ELF fee for the `Create` method, while all other methods receive empty `MethodFees`: [2](#0-1) 

The contract state confirms there are no state variables for storing method fees or fee controllers: [3](#0-2) 

The MultiToken contract's fee charging mechanism calls `GetMethodFee()` to determine charges: [4](#0-3) 

When empty `MethodFees` are returned, only transaction size fees apply. The size fee formula for transactions under 1MB is defined as: [5](#0-4) 

For a typical 500-byte mint transaction: 500/800 + 1/10000 = 0.6251 base units ≈ 0.0000000063 ELF.

Each mint operation creates permanent state entries in `NftInfoMap` and `BalanceMap`: [6](#0-5) 

The protocol creator is automatically added as a minter with full minting privileges: [7](#0-6) 

The minting operation verifies minter authorization but this does not prevent the attack: [8](#0-7) 

## Impact Explanation

**State Bloat and DoS Risk:**
An attacker can create catastrophic permanent state bloat with minimal investment:
- **Initial cost:** 100 ELF to call `Create()` and become protocol creator/minter
- **Spam cost:** 1 million mints × 0.6251 base units = 625,100 base units = 0.00625 ELF
- **Total attack cost:** ~100.01 ELF to create 1+ million permanent state entries

Each mint creates entries in `NftInfoMap` (NFT metadata) and `BalanceMap` (ownership records), consuming blockchain storage permanently. The attacker can specify an arbitrarily large `total_supply` when creating the protocol (up to int64.MaxValue), enabling spam of billions of NFTs.

**Chain-Level Impact:**
- Permanent storage bloat affecting all full nodes
- Degraded node performance and increased synchronization times
- Higher infrastructure costs for all node operators
- Potential chain-level DoS if storage/memory limits are reached
- No economic deterrent mechanism after the minimal 100 ELF initial investment

**Protocol Integrity Violation:**
This fundamentally breaks AElf's economic security model where resource-intensive state operations must have proportional fees. The ratio of storage cost to fee paid is several orders of magnitude out of balance compared to the 100 ELF fee for a single `Create` operation.

## Likelihood Explanation

**Attack Feasibility: HIGH**

**Attacker Requirements:**
1. 100 ELF to call `Create()` - a readily obtainable amount
2. Automatic authorization as minter upon protocol creation - no additional permissions needed

**Attack Complexity:** Very Low
The attack involves straightforward method calls with minimal preconditions:
1. Call `NFTContract.Create()` with large `total_supply` → pay 100 ELF, automatically become minter
2. Call `NFTContract.Mint()` repeatedly → spam millions of calls at ~0.0000000063 ELF each
3. Optionally call `NFTContract.Transfer()` → additional spam at same marginal cost

**Permanence:** The broken `SetMethodFee()` stub means fees can NEVER be configured through normal contract methods without a complete contract upgrade, making this a permanent vulnerability in the current deployment.

**Detection Difficulty:** The attack generates legitimate-looking transactions that pass all authorization checks and validation logic. Distinguishing malicious high-volume minting from legitimate NFT collection launches is difficult without out-of-band analysis.

**Economic Rationality:** Extremely favorable attack economics - after the 100 ELF initial cost, the marginal cost per state-bloating operation is effectively zero (~0.0000000063 ELF), while the permanent storage burden on the network is substantial.

## Recommendation

**Immediate Fix:**
Implement proper ACS1 fee configuration with persistent state storage:

1. Add state variables to `NFTContractState`:
   - `MappedState<string, MethodFees> MethodFeeMap` for storing fees per method
   - `SingletonState<AuthorityInfo> MethodFeeController` for fee governance

2. Implement `SetMethodFee()` to persist fee configuration:
   ```csharp
   public override Empty SetMethodFee(MethodFees input)
   {
       AssertMethodFeeControllerPermission();
       State.MethodFeeMap[input.MethodName] = input;
       return new Empty();
   }
   ```

3. Implement `GetMethodFee()` to read from state:
   ```csharp
   public override MethodFees GetMethodFee(StringValue input)
   {
       if (input.Value == nameof(Create))
           return new MethodFees { /* hardcoded 100 ELF */ };
       
       return State.MethodFeeMap[input.Value] ?? new MethodFees();
   }
   ```

4. Set appropriate base fees for `Mint`, `Transfer`, and `TransferFrom` operations through governance (e.g., 0.1-1 ELF per mint to reflect permanent storage cost).

**Long-term Solution:**
Consider implementing rate-limiting mechanisms or supply caps per protocol creator to prevent mass minting regardless of fee levels.

## Proof of Concept

```csharp
[Fact]
public async Task StateBlomatAttack_MinimalCost()
{
    // Step 1: Create NFT protocol (100 ELF)
    var createResult = await NFTContractStub.Create.SendAsync(new CreateInput
    {
        NftType = "TestNFT",
        ProtocolName = "Spam Protocol",
        TotalSupply = 10_000_000, // 10 million supply
        IsBurnable = false,
        IssueChainId = ChainId,
        BaseUri = "https://spam.nft/",
        IsTokenIdReuse = false
    });
    var symbol = createResult.Output.Value;
    
    // Step 2: Mint 1000 NFTs (proof of concept - real attack would mint millions)
    var totalCost = 0L;
    for (int i = 0; i < 1000; i++)
    {
        var balanceBefore = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = DefaultSender,
            Symbol = "ELF"
        });
        
        await NFTContractStub.Mint.SendAsync(new MintInput
        {
            Symbol = symbol,
            Quantity = 1,
            TokenId = i + 1
        });
        
        var balanceAfter = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = DefaultSender,
            Symbol = "ELF"
        });
        
        totalCost += balanceBefore.Balance - balanceAfter.Balance;
    }
    
    // Verify negligible cost: 1000 mints should cost < 0.01 ELF (excluding Create fee)
    Assert.True(totalCost < 1_000_000); // Less than 0.01 ELF in base units
    
    // Verify permanent state bloat: 1000 NFT entries created
    for (int i = 1; i <= 1000; i++)
    {
        var nftInfo = await NFTContractStub.GetNFTInfo.CallAsync(new GetNFTInfoInput
        {
            Symbol = symbol,
            TokenId = i
        });
        Assert.Equal(symbol, nftInfo.Symbol);
    }
}
```

## Notes

This vulnerability represents a critical breakdown in the NFT contract's economic security model. The broken ACS1 implementation is not merely a configuration oversight but a fundamental architectural flaw where fee-setting methods are completely non-functional. The extreme cost imbalance (100 ELF for protocol creation vs. ~0.000006 ELF per permanent state entry) makes this attack highly practical and economically rational for malicious actors seeking to degrade network performance or increase operational costs for honest node operators.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-16)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }

    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L6-46)
```csharp
public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-52)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L283-289)
```csharp
                    // Interval [0, 1000000]: x / 800 + 1 / 10000
                    Value =
                    {
                        1000000,
                        1, 1, 800,
                        0, 1, 10000
                    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-400)
```csharp
        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Incorrect chain.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L439-441)
```csharp
        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L36-38)
```csharp
        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;
```
