# Audit Report

## Title
Quadratic Voting Accounting Mismatch Allows Vote Count Manipulation Through Persistent Counter and VoteId Reuse

## Summary
The Vote contract contains a critical accounting vulnerability in quadratic voting where the `QuadraticVotesCountMap` counter persists across withdrawals and is never reset. Combined with an accounting mismatch where votes add 1 to results but withdrawals subtract the full token amount, this allows sponsors of delegated voting items to repeatedly vote and withdraw with the same `VoteId`, driving voting results to arbitrary negative values and breaking fundamental accounting invariants.

## Finding Description

The vulnerability stems from three interconnected flaws in the quadratic voting implementation:

**Issue 1: Persistent Vote Counter**

When voting with quadratic voting enabled, the contract increments `QuadraticVotesCountMap[input.VoteId]` by 1 and stores it persistently. [1](#0-0) 

This counter is defined in the contract state and persists indefinitely. [2](#0-1) 

However, the `Withdraw()` method never resets or decrements this counter - it only marks the record as withdrawn and updates voting results, but leaves `QuadraticVotesCountMap` unchanged. [3](#0-2) 

**Issue 2: Accounting Mismatch**

When voting in quadratic mode, the contract passes only `1` (not the token amount) to `UpdateVotingResult()`. [4](#0-3) 

The `UpdateVotingResult()` method then adds this value to both `Results[option]` and `VotesAmount`. [5](#0-4) 

However, when withdrawing, the full `votingRecord.Amount` (which equals `ticketCost * count`) is subtracted from both the results and votes amount. [6](#0-5) 

**Issue 3: VoteId Reuse Without Validation**

For delegated voting (`IsLockToken = false`), the sponsor must provide the `VoteId` and only the sponsor can call `Vote()`. [7](#0-6) 

The `Vote()` method simply overwrites any existing `VotingRecord` at that `VoteId` without checking if one already exists or has been withdrawn. [8](#0-7) 

When overwriting, `IsWithdrawn` is reset to `false`, effectively allowing the same `VoteId` to be reused after withdrawal.

**Exploitation Mechanics:**

The voting results use signed `int64` which can represent negative values. [9](#0-8) 

An attacker can exploit this by:
1. Creating a delegated quadratic voting item with `IsLockToken = false` and any `ticketCost > 1`
2. Voting with VoteId X → QuadraticVotesCountMap[X] = 1, amount = ticketCost × 1, Results += 1, VotesAmount += 1
3. Withdrawing VoteId X → Results -= ticketCost, VotesAmount -= ticketCost, QuadraticVotesCountMap[X] still = 1
4. Voting again with same VoteId X → QuadraticVotesCountMap[X] = 2, amount = ticketCost × 2, Results += 1, VotesAmount += 1
5. Withdrawing VoteId X → Results -= ticketCost × 2, VotesAmount -= ticketCost × 2

After first cycle: Net = +1 - ticketCost (negative if ticketCost > 1)
After n cycles: Net = n - ticketCost × n(n+1)/2, which becomes increasingly negative.

## Impact Explanation

This vulnerability has **CRITICAL** impact because:

1. **Breaks Fundamental Invariants**: Vote counts (`Results[option]`) and `VotesAmount` should never be negative, as they represent counts of votes. This breaks the basic accounting rule that vote totals must be non-negative, creating mathematically inconsistent state.

2. **State Integrity Violation**: The contract allows persistent state corruption where voting results no longer reflect actual voting activity. This undermines the entire purpose of the voting mechanism.

3. **Downstream System Risk**: Any system that queries voting results and expects non-negative values could malfunction. Systems might use these values for:
   - Governance decisions based on vote thresholds
   - Reward distributions proportional to votes
   - Eligibility checks based on minimum vote counts
   - Statistical analysis or reporting

4. **Affects All Delegated Quadratic Voting**: Any voting item with `IsQuadratic = true` and `IsLockToken = false` is vulnerable. While the sponsor controls their own item, if downstream systems trust these results without validation, they could be manipulated.

5. **No Capital Requirements**: The attack requires no token holdings since delegated voting doesn't lock tokens, only transaction fees.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood because:

**Attacker Requirements:**
- Only needs to call the public `Register()` method to create a voting item (requires only that the token is whitelisted). [10](#0-9) 
- As the sponsor, automatically has permission to call `Vote()` for delegated voting
- As the sponsor, automatically has permission to call `Withdraw()` for delegated voting. [11](#0-10) 

**Attack Complexity:**
- Simple sequence of public method calls: Register → Vote → Withdraw → Vote → Withdraw...
- Fully deterministic and reproducible
- No timing constraints, race conditions, or complex preconditions
- No special knowledge required beyond reading the contract code

**Detection Difficulty:**
- Individual transactions appear legitimate
- `QuadraticVotesCountMap` is internal state not commonly monitored
- Only aggregate analysis would reveal the manipulation

**Economic Feasibility:**
- Only gas fees required, no capital lock-up
- Attack is reversible (can create new voting items if needed)

## Recommendation

Implement one or more of the following fixes:

1. **Reset Counter on Withdrawal**: In the `Withdraw()` method, reset `QuadraticVotesCountMap[input.VoteId]` to 0 when a vote is withdrawn.

2. **Prevent VoteId Reuse**: Add validation in the `Vote()` method to check if a `VotingRecord` already exists for the given `VoteId` and revert if it does (or if it exists and `IsWithdrawn == true`).

3. **Fix Accounting Mismatch**: When withdrawing quadratic votes, subtract 1 from results (not the full amount), to match what was added during voting. However, this would require tracking whether each record was quadratic separately.

4. **Add Non-Negative Validation**: Add assertions to prevent `Results[option]` and `VotesAmount` from becoming negative, though this is a defensive measure rather than fixing the root cause.

The recommended fix combines approaches 1 and 2:

```csharp
// In Vote() method, add validation before line 117:
var existingRecord = State.VotingRecords[input.VoteId];
Assert(existingRecord == null || !existingRecord.IsWithdrawn, 
    "VoteId already used and withdrawn. Cannot reuse VoteId.");

// In Withdraw() method, add after line 205:
if (votingItem.IsQuadratic)
{
    State.QuadraticVotesCountMap[input.VoteId] = 0;
}
```

## Proof of Concept

The following test demonstrates the vulnerability:

```csharp
[Fact]
public async Task QuadraticVoting_AccountingMismatch_NegativeResults()
{
    // Setup: Create a delegated quadratic voting item with ticketCost = 10
    var votingItemId = await RegisterDelegatedQuadraticVotingItem(ticketCost: 10);
    var voteId = HashHelper.ComputeFrom("test_vote_1");
    
    // Cycle 1: Vote and Withdraw
    await VoteAsSync(votingItemId, voteId, "Option1", voter: UserAddress);
    await WithdrawAsync(voteId);
    
    // Cycle 2: Vote and Withdraw with same VoteId
    await VoteAsSync(votingItemId, voteId, "Option1", voter: UserAddress);
    await WithdrawAsync(voteId);
    
    // Verify: Results should be negative
    var result = await GetVotingResult(votingItemId, 1);
    Assert.True(result.Results["Option1"] < 0, "Results should be negative");
    Assert.True(result.VotesAmount < 0, "VotesAmount should be negative");
}
```

The test shows that after two vote-withdraw cycles, both `Results["Option1"]` and `VotesAmount` become negative, violating the fundamental invariant that vote counts must be non-negative.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-82)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
        };

        State.VotingItems[votingItemId] = votingItem;

        // Initialize first voting going information of registered voting event.
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };

        Context.Fire(new VotingItemRegistered
        {
            Sponsor = votingItem.Sponsor,
            VotingItemId = votingItemId,
            AcceptedCurrency = votingItem.AcceptedCurrency,
            IsLockToken = votingItem.IsLockToken,
            TotalSnapshotNumber = votingItem.TotalSnapshotNumber,
            CurrentSnapshotNumber = votingItem.CurrentSnapshotNumber,
            CurrentSnapshotStartTimestamp = votingItem.StartTimestamp,
            StartTimestamp = votingItem.StartTimestamp,
            EndTimestamp = votingItem.EndTimestamp,
            RegisterTimestamp = votingItem.RegisterTimestamp,
            IsQuadratic = votingItem.IsQuadratic,
            TicketCost = votingItem.TicketCost
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L100-103)
```csharp
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-117)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L119-119)
```csharp
        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-239)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;

        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });

        Context.Fire(new Withdrawn
        {
            VoteId = input.VoteId
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L30-33)
```csharp
    /// <summary>
    ///     Vote Id -> Votes Count
    /// </summary>
    public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```

**File:** protobuf/vote_contract.proto (L162-177)
```text
message VotingResult {
    // The voting activity id.
    aelf.Hash voting_item_id = 1;
    // The voting result, option -> amount of votes,
    map<string, int64> results = 2;
    // The snapshot number.
    int64 snapshot_number = 3;
    // The total number of voters.
    int64 voters_count = 4;
    // The start time of this snapshot.
    google.protobuf.Timestamp snapshot_start_timestamp = 5;
    // The end time of this snapshot.
    google.protobuf.Timestamp snapshot_end_timestamp = 6;
    // Total votes received during the process of this snapshot.
    int64 votes_amount = 7;
}
```
