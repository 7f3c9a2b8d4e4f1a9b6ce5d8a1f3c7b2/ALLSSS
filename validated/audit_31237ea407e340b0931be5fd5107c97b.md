# Audit Report

## Title
Missing Input Size Validation in SetTransactionFeeDelegations Enables Resource Exhaustion Attack

## Summary
The `SetTransactionFeeDelegations()` function in the MultiToken contract lacks validation on the number of token symbols in the input delegations map. This allows attackers to submit transactions with thousands of entries, causing excessive state reads and potential state size limit violations that result in transaction failures after fees are charged.

## Finding Description

The `SetTransactionFeeDelegations()` method accepts unbounded delegation maps without validating the entry count. [1](#0-0) 

The function performs O(n) iterations over delegation entries, calling `AssertValidToken()` for each token symbol: [2](#0-1) [3](#0-2) 

Each `AssertValidToken()` call triggers a state read via `GetTokenInfo()`: [4](#0-3) 

The final state write stores the `TransactionFeeDelegatees` object which can exceed the enforced 128KB state size limit: [5](#0-4) [6](#0-5) 

**Pattern Violation**: The codebase establishes a validation pattern in `BatchApprove` which checks input collection size: [7](#0-6) 

However, `SetTransactionFeeDelegations()` lacks this validation. The existing `DELEGATEE_MAX_COUNT` constant only limits delegatees per delegator (24), not token symbols per delegation: [8](#0-7) [9](#0-8) 

The protobuf definition shows the delegations field is an unbounded map: [10](#0-9) 

## Impact Explanation

**Resource Exhaustion**: An attacker can construct transactions with 5,000-10,000+ token symbols, each triggering a `GetTokenInfo()` state read. Multiple O(n) iterations compound computational costs, causing block processing delays.

**Financial Loss**: When the serialized `TransactionFeeDelegatees` object exceeds 128KB, `StateOverSizeException` is thrown. Critically, transaction fees are charged via pre-execution plugin **before** the main transaction executes. When the main transaction fails, the system commits successful PreTraces while rolling back the main transaction: [11](#0-10) 

This means fees are NOT refunded when the transaction fails due to state size violations, resulting in financial loss for users.

**DoS Impact**: Spam attacks with oversized delegation transactions can congest the network, as transaction fees do not scale proportionally with delegation map size.

## Likelihood Explanation

**Public Access**: The function is a public RPC method accessible to any address without permission requirements: [12](#0-11) 

**Low Attack Complexity**: Attackers only need to construct a `SetTransactionFeeDelegationsInput` with thousands of token symbols (publicly queryable on-chain) and submit the transaction. No special permissions, governance approval, or privileged roles are required.

**High Feasibility**: Active blockchains typically have hundreds to thousands of tokens, making this attack practical on any network configuration without requiring special preconditions.

## Recommendation

Add input size validation similar to `BatchApprove`:

```csharp
public override SetTransactionFeeDelegationsOutput SetTransactionFeeDelegations(
    SetTransactionFeeDelegationsInput input)
{
    AssertValidInputAddress(input.DelegatorAddress);
    Assert(input.Delegations != null, "Delegations cannot be null!");
    
    // Add validation for delegation map size
    const int MaxDelegationSymbolsCount = 100; // Or make it configurable like BatchApprove
    Assert(input.Delegations.Count <= MaxDelegationSymbolsCount, 
        "Delegation symbols count exceeds the maximum limit.");
    
    // ... rest of implementation
}
```

Consider making the limit configurable via Parliament governance similar to `MaxBatchApproveCount`.

## Proof of Concept

```csharp
[Fact]
public async Task SetTransactionFeeDelegations_ExcessiveTokenSymbols_CausesResourceExhaustion()
{
    // Create a delegation input with 6000 token symbols
    var input = new SetTransactionFeeDelegationsInput
    {
        DelegatorAddress = DefaultAddress,
        Delegations = { }
    };
    
    // Add 6000 token symbols (assuming they exist)
    for (int i = 0; i < 6000; i++)
    {
        input.Delegations.Add($"TOKEN{i}", 100);
    }
    
    // This transaction will cause:
    // 1. 6000 GetTokenInfo() state reads
    // 2. Potential StateOverSizeException when writing TransactionFeeDelegatees
    // 3. Fees charged but transaction fails
    var result = await TokenContractStub.SetTransactionFeeDelegations.SendAsync(input);
    
    // Transaction should fail due to state size limits or be prevented by input validation
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
}
```

**Notes**

This vulnerability represents a clear pattern violation where similar functionality (`BatchApprove`) implements proper input size validation, but `SetTransactionFeeDelegations` does not. The financial impact is particularly severe because AElf's pre-execution plugin architecture commits fee charges even when the main transaction fails, as evidenced by the `TryUpdateStateCache` logic that preserves successful PreTraces regardless of main transaction status.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L12-16)
```csharp
    public override SetTransactionFeeDelegationsOutput SetTransactionFeeDelegations(
        SetTransactionFeeDelegationsInput input)
    {
        AssertValidInputAddress(input.DelegatorAddress);
        Assert(input.Delegations != null, "Delegations cannot be null!");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L31-31)
```csharp
            if (allDelegateesMap.Count() >= TokenContractConstants.DELEGATEE_MAX_COUNT)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L45-52)
```csharp
                foreach (var (key, value) in delegationsToInput)
                {
                    if (value > 0)
                    {
                        AssertValidToken(key, value);
                        allDelegateesMap[delegateeAddress].Delegations.Add(key, value);
                    }
                }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L57-57)
```csharp
                State.TransactionFeeDelegateesMap[input.DelegatorAddress] = allDelegatees;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L69-80)
```csharp
            foreach (var (key, value) in delegationsToInput)
            {
                if (value <= 0 && delegationsMap.ContainsKey(key))
                {
                    delegationsMap.Remove(key);
                }
                else if (value > 0)
                {
                    AssertValidToken(key, value);
                    delegationsMap[key] = value;
                }
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L33-39)
```csharp
    private TokenInfo AssertValidToken(string symbol, long amount)
    {
        AssertValidSymbolAndAmount(symbol, amount);
        var tokenInfo = GetTokenInfo(symbol);
        Assert(tokenInfo != null && !string.IsNullOrEmpty(tokenInfo.Symbol), $"Token is not found. {symbol}");
        return tokenInfo;
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L283-286)
```csharp
    public override Empty BatchApprove(BatchApproveInput input)
    {
        Assert(input != null && input.Value != null && input.Value.Count > 0, "Invalid input .");
        Assert(input.Value.Count <= GetMaxBatchApproveCount(), "Exceeds the max batch approve count.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L18-18)
```csharp
    public const int DELEGATEE_MAX_COUNT = 24;
```

**File:** protobuf/token_contract.proto (L138-139)
```text
    rpc SetTransactionFeeDelegations (SetTransactionFeeDelegationsInput) returns (SetTransactionFeeDelegationsOutput){
    }
```

**File:** protobuf/token_contract.proto (L674-679)
```text
message SetTransactionFeeDelegationsInput {
    // the delegator address
    aelf.Address delegator_address = 1;
    // delegation, symbols and its' amount
    map<string, int64> delegations = 2;
}
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L110-117)
```csharp
        if (!trace.IsSuccessful())
        {
            var transactionExecutingStateSets = new List<TransactionExecutingStateSet>();

            AddToTransactionStateSets(transactionExecutingStateSets, trace.PreTraces);
            AddToTransactionStateSets(transactionExecutingStateSets, trace.PostTraces);

            groupStateCache.Update(transactionExecutingStateSets);
```
