# Audit Report

## Title
Case-Insensitive Token Duplicate Registration via CrossChainCreateToken Bypass

## Summary
The `CrossChainCreateToken` method fails to enforce case-insensitive token uniqueness, allowing attackers to register duplicate tokens with different casing (e.g., "ABC" and "abc") as separate entities. This violates the protocol's fundamental invariant that token symbols must be case-insensitively unique.

## Finding Description

The vulnerability exists in how `CrossChainCreateToken` validates token existence before registration. The method only performs a case-sensitive check using `State.TokenInfos[tokenInfo.Symbol] == null` [1](#0-0) , bypassing the case-insensitive duplicate protection that should be enforced.

In contrast, the normal token creation path properly prevents case-variant duplicates by calling `CheckTokenExists` before registration [2](#0-1) .

The `CheckTokenExists` method enforces case-insensitive uniqueness by checking the `InsensitiveTokenExisting` state map with uppercased symbols [3](#0-2) .

The `RegisterTokenInfo` method performs no duplicate checking—it only validates symbol format and unconditionally sets the insensitive existence flag [4](#0-3) .

Since `CrossChainCreateToken` skips `CheckTokenExists` [5](#0-4) , an attacker can register case variants (e.g., "ABC" after "abc" already exists) by providing valid cross-chain proofs, resulting in:
- Multiple entries in `State.TokenInfos` ("abc" and "ABC")
- Both mapping to the same `State.InsensitiveTokenExisting["ABC"]` key
- Broken case-insensitive uniqueness invariant

## Impact Explanation

**Protocol Integrity Violation:**
The fundamental invariant that token symbols must be case-insensitively unique is broken. The `InsensitiveTokenExisting` state map [6](#0-5)  exists specifically to enforce this invariant, but it becomes unreliable when multiple case-variant tokens can be registered.

**User Confusion & Phishing Risk:**
Users cannot visually distinguish between "ABC" and "abc" tokens. Attackers can create malicious lookalike tokens to deceive users into transferring funds, granting approvals, or interacting with the wrong token. Token operations use case-sensitive lookups [7](#0-6) , meaning users may target unintended tokens.

**Operational Impact:**
Future legitimate token creators may be incorrectly blocked if attempting to register a symbol whose case-variant was maliciously registered. Token metadata queries become unreliable when multiple case-variants exist in the system.

**Severity: High** - Violates a core security invariant with a concrete exploitation path, though requires cross-chain infrastructure access.

## Likelihood Explanation

**Reachable Entry Point:**
`CrossChainCreateToken` is a public RPC method [8](#0-7)  callable by any address with valid cross-chain proofs.

**Preconditions:**
1. Source chain must be registered in `State.CrossChainTransferWhiteList` [9](#0-8)  (requires one-time governance approval, but once set up for legitimate cross-chain operations, remains persistently accessible)
2. Attacker must provide valid merkle proof of a `ValidateTokenInfoExists` transaction from the source chain
3. Target symbol must not already exist with exact case in `State.TokenInfos`

**Attack Complexity:**
Moderate—requires cross-chain infrastructure setup but no special privileges beyond standard cross-chain operations. An attacker can create token "XYZ" on the source chain, then register "xyz" on the target chain via `CrossChainCreateToken`. No rate limiting or cooldown mechanisms prevent repeated exploitation.

**Detection Difficulty:**
The attack blends with legitimate cross-chain token registrations. No events or logs distinguish malicious from benign case-variant registrations.

**Economic Rationality:**
Cost is limited to cross-chain transaction fees plus token creation costs on the source chain. High payoff potential if attacker creates phishing tokens mimicking high-value assets.

**Likelihood: Medium** - Requires cross-chain access but is otherwise straightforward to execute once infrastructure is available.

## Recommendation

Add a call to `CheckTokenExists` before registering the token in `CrossChainCreateToken`:

```csharp
var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
if (State.TokenInfos[tokenInfo.Symbol] == null)
{
    CheckTokenExists(tokenInfo.Symbol);  // Add this line
    RegisterTokenInfo(tokenInfo);
    Context.Fire(new TokenCreated { ... });
}
```

This ensures cross-chain token creation follows the same case-insensitive uniqueness validation as normal token creation.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreateToken_CaseInsensitiveDuplicate_Test()
{
    await GenerateSideChainAsync();
    await RegisterSideChainContractAddressOnMainChainAsync();
    
    // Step 1: Create token "abc" on main chain (lowercase)
    await BootMinerChangeRoundAsync(AEDPoSContractStub, true);
    var createTransaction = await CreateTransactionForTokenCreation(
        TokenContractStub, DefaultAccount.Address, "abc", TokenContractAddress);
    var blockExecutedSet = await MineAsync(new List<Transaction> { createTransaction });
    blockExecutedSet.TransactionResultMap[createTransaction.GetHash()]
        .Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 2: Create token "ABC" on side chain (uppercase)
    var sideCreateTx = await CreateTransactionForTokenCreation(
        SideChainTokenContractStub, SideChainTestKit.DefaultAccount.Address, 
        "ABC", SideTokenContractAddress);
    var sideBlock = await SideChainTestKit.MineAsync(new List<Transaction> { sideCreateTx });
    sideBlock.TransactionResultMap[sideCreateTx.GetHash()]
        .Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 3: Validate "ABC" token on side chain
    var tokenInfo = await SideChainTokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = "ABC" });
    var validationTx = CreateTokenInfoValidationTransaction(tokenInfo, SideChainTokenContractStub);
    var validationBlock = await SideChainTestKit.MineAsync(new List<Transaction> { validationTx });
    
    // Step 4: Cross-chain create "ABC" on main chain (where "abc" exists)
    var merklePath = GetTransactionMerklePathAndRoot(validationTx, out var blockRoot);
    await MainAndSideIndexAsync(sideChainId, validationBlock.Height, blockRoot);
    var boundHeight = await GetBoundParentChainHeightAndMerklePathByHeight(validationBlock.Height);
    
    var crossChainInput = new CrossChainCreateTokenInput
    {
        FromChainId = sideChainId,
        ParentChainHeight = boundHeight.BoundParentChainHeight,
        TransactionBytes = validationTx.ToByteString(),
        MerklePath = merklePath
    };
    crossChainInput.MerklePath.MerklePathNodes.AddRange(
        boundHeight.MerklePathFromParentChain.MerklePathNodes);
    
    // This should fail but succeeds, creating duplicate case-variant token
    var result = await TokenContractStub.CrossChainCreateToken.SendAsync(crossChainInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify both "abc" and "ABC" exist
    var abcInfo = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = "abc" });
    var ABCInfo = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = "ABC" });
    
    abcInfo.Symbol.ShouldBe("abc");
    ABCInfo.Symbol.ShouldBe("ABC");
    // Both should be non-null, proving the invariant is violated
    abcInfo.ShouldNotBeNull();
    ABCInfo.ShouldNotBeNull();
}
```

## Notes

The vulnerability stems from an inconsistency between the normal token creation path and the cross-chain creation path. The fix is straightforward: enforce the same case-insensitive validation in both paths by calling `CheckTokenExists` before `RegisterTokenInfo` in the `CrossChainCreateToken` method.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L87-87)
```csharp
        CheckTokenExists(tokenInfo.Symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-523)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-414)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L17-17)
```csharp
    public MappedState<string, bool> InsensitiveTokenExisting { get; set; }
```
