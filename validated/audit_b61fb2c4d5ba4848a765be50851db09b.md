# Audit Report

## Title
Unvalidated Revealed PreviousInValues Allow Malicious Miners to Cause Consensus DoS

## Summary
A Byzantine miner can inject incorrect `PreviousInValue` data for other miners through the secret sharing mechanism without cryptographic validation. These unvalidated values persist in consensus state and prevent targeted miners from producing valid blocks, causing denial-of-service.

## Finding Description

The AEDPoS consensus protocol uses a commit-reveal scheme where miners publish `OutValue = Hash(InValue)` in round N, then reveal `InValue` as `PreviousInValue` in round N+1 for validation. The secret sharing mechanism allows miners to reconstruct other miners' InValues when they fail to reveal them.

**Unvalidated Write Path:**

When a miner produces a block, the `UpdateLatestSecretPieces` method writes `RevealedInValues` from off-chain trigger information directly to the round state for other miners [1](#0-0) . These values have no cryptographic validation that `Hash(revealedInValue) == previousOutValue`.

During transaction generation, these potentially malicious values are extracted into `MinersPreviousInValues` [2](#0-1) .

**Insufficient Validation:**

The `UpdateValueValidationProvider` only validates the block producer's own `PreviousInValue`, not other miners' values [3](#0-2) . Specifically, it checks only `validationContext.SenderPubkey`, allowing malicious values for other miners to pass validation unchecked.

**State Persistence Without Validation:**

During block execution, `PerformSecretSharing` writes `MinersPreviousInValues` directly to state [4](#0-3)  without any validation, poisoning the consensus state.

**Cannot Overwrite Once Set:**

Both `ApplyNormalConsensusData` [5](#0-4)  and `UpdateLatestSecretPieces` have "only if empty" guards, preventing victims from correcting malicious values once written.

**Attack Execution:**

1. Byzantine miner B modifies off-chain trigger provider to include `RevealedInValues["A"] = WrongValue`
2. B's block writes WrongValue to miner A's PreviousInValue in state
3. When A produces a block, `ApplyNormalConsensusData` does not overwrite (not empty)
4. A's block includes WrongValue, which fails validation: `Hash(WrongValue) ≠ A.OutValue` from previous round
5. A's block is rejected by the network

## Impact Explanation

**Consensus Integrity Violation:** This breaks the fundamental security property that miners control only their own consensus data. A Byzantine miner can corrupt other miners' state, violating consensus isolation guarantees.

**Targeted Denial-of-Service:** The attacker can selectively prevent specific miners from producing valid blocks, causing:
- Direct loss of mining rewards for targeted miners
- Reduced network liveness if multiple miners are targeted
- Potential consensus degradation if a threshold of miners is affected

**Severity: Medium** - While this requires a Byzantine miner (elevated attacker capability), it directly impacts consensus integrity (critical system component). The attack causes DoS rather than fund theft, is recoverable through round transitions, and the attacker must repeat the attack each round to maintain the effect.

## Likelihood Explanation

**Attacker Profile:** Requires being an elected/appointed miner with ability to modify local node's off-chain trigger information provider. This represents a Byzantine miner scenario - the attacker uses legitimate cryptographic credentials but provides malicious data.

**Attack Complexity: Low** - Once in the miner set, the attack is straightforward: modify the `RevealedInValues` dictionary in `AElfConsensusTriggerInformation` before block production.

**Feasibility: High** - The attack path is direct with no cryptographic barriers. The vulnerability exists because validation is asymmetric: only the sender's values are checked, not other miners' revealed values.

**Detection:** Observable through monitoring discrepancies between expected and actual PreviousInValues, but no on-chain validation prevents the attack.

**Probability: Medium** - Requires Byzantine miner capability but trivial execution once achieved.

## Recommendation

Add cryptographic validation for all miners' revealed values, not just the sender's:

```csharp
// In UpdateLatestSecretPieces
foreach (var revealedInValue in triggerInformation.RevealedInValues)
{
    if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
    {
        var minerInfo = updatedRound.RealTimeMinersInformation[revealedInValue.Key];
        
        // Validate revealed value against previous OutValue
        if (TryToGetPreviousRoundInformation(out var previousRound) &&
            previousRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
        {
            var previousOutValue = previousRound.RealTimeMinersInformation[revealedInValue.Key].OutValue;
            if (HashHelper.ComputeFrom(revealedInValue.Value) != previousOutValue)
            {
                // Skip invalid revealed value
                continue;
            }
        }
        
        if (minerInfo.PreviousInValue == Hash.Empty || minerInfo.PreviousInValue == null)
            minerInfo.PreviousInValue = revealedInValue.Value;
    }
}
```

Similarly, add validation in `PerformSecretSharing` before writing `MinersPreviousInValues` to state.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up a round with miners A and B
2. Have miner A produce a block with OutValue_A = Hash(InValue_A)
3. In the next round, have miner B produce a block with `RevealedInValues["A"] = WrongValue` where Hash(WrongValue) ≠ OutValue_A
4. Verify B's block is accepted and state is updated with A's PreviousInValue = WrongValue
5. When A attempts to produce a block, verify it is rejected due to invalid PreviousInValue validation

The core issue is at lines 148-152 and 295-296 in the cited files, where unvalidated external data writes to consensus-critical state without cryptographic verification.

## Notes

This vulnerability exploits the trust asymmetry in the secret sharing mechanism: the protocol validates that miners correctly reveal their own values, but trusts that revealed values for OTHER miners (reconstructed via secret sharing) are correct. A Byzantine miner can abuse this by providing fake reconstructions that pass validation (since only the sender's value is checked) but corrupt other miners' state.

The attack is limited to the current round and requires repetition, but represents a fundamental breach of consensus isolation where one miner should not be able to corrupt another miner's consensus data.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```
