# Audit Report

## Title
Minter List State Pollution via Reference Mutation in GetMinterList

## Summary
The private `GetMinterList` method in the NFT contract mutates the cached state object by automatically adding the issuer to the minter list without using `.Clone()`, causing unintended persistent state changes. This creates an access control bypass where protocol creators cannot permanently revoke the issuer's minting permission via `RemoveMinters`.

## Finding Description

The vulnerability exists in the private `GetMinterList` helper function that retrieves and automatically modifies the minter list state without proper cloning. [1](#0-0) 

When this function accesses `State.MinterListMap[tokenInfo.Symbol]`, AElf's MappedState implementation returns a direct reference to the cached protobuf object stored in the internal cache. [2](#0-1) 

The critical issue is that modifying this cached object in-place causes the changes to be persisted to state during transaction finalization. The `GetChanges()` method detects modifications by comparing the cached `Value` against the `OriginalValue` using content-based equality. [3](#0-2) 

This function is called during minting operations through `PerformMint`. [4](#0-3) 

The `PerformMint` method is invoked by the public `Mint` method. [5](#0-4) 

And by the `Assemble` method. [6](#0-5) 

The contract demonstrates the correct pattern elsewhere by using `.Clone()` when reading from state to prevent unintended mutations, such as in the `Disassemble` function for assembled NFTs. [7](#0-6) 

And for assembled FTs. [8](#0-7) 

And in the `Recast` function for metadata. [9](#0-8) 

## Impact Explanation

This vulnerability creates an **access control bypass** in the NFT minting authorization system:

1. The protocol creator calls `RemoveMinters` to revoke the issuer's minting authorization. [10](#0-9) 

2. The next `Mint` or `Assemble` operation automatically re-adds the issuer to the persistent minter list through the `GetMinterList` mutation, bypassing the intended access control.

3. The issuer regains permanent minting permission, defeating the intended access control provided by `RemoveMinters`.

The impact is **LIMITED** because:
- No direct fund theft occurs
- Supply manipulation is still constrained by normal minting rules and total supply limits
- The issuer is typically the protocol creator (a trusted role established during protocol creation)
- The authorization check still prevents unauthorized users from minting

However, it violates the expected behavior of the access control system and prevents proper enforcement of minting authorization policies. This breaks the security invariant that a protocol creator should be able to permanently revoke any minter's permissions, including the issuer's.

## Likelihood Explanation

This vulnerability triggers **automatically** with 100% likelihood:

- **Entry points**: The public `Mint` and `Assemble` functions are accessible to any authorized minter
- **Preconditions**: Only requires that a minter list exists in state (initialized during protocol creation)
- **Trigger mechanism**: No attacker action needed - the bug manifests through normal contract operation
- **Determinism**: The behavior occurs on every mint transaction after an attempt to remove the issuer from the minter list
- **Detection difficulty**: The mutation appears as a normal state update without error events

The MappedState reference behavior ensures this happens on every execution of the code path.

## Recommendation

Modify the `GetMinterList` method to use `.Clone()` when retrieving the minter list from state, following the same defensive pattern used elsewhere in the contract:

```csharp
private MinterList GetMinterList(TokenInfo tokenInfo)
{
    var minterList = (State.MinterListMap[tokenInfo.Symbol] ?? new MinterList()).Clone();
    if (!minterList.Value.Contains(tokenInfo.Issuer)) 
        minterList.Value.Add(tokenInfo.Issuer);
    return minterList;
}
```

This ensures that the modification only affects the returned local copy and does not mutate the cached state object.

## Proof of Concept

```csharp
[Fact]
public async Task MinterListStatePollutionTest()
{
    // Create NFT protocol
    var symbol = await CreateTest();
    
    // Get issuer (DefaultAddress) from token info
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = symbol });
    var issuer = tokenInfo.Issuer;
    
    // Add a different minter
    await NFTContractStub.AddMinters.SendAsync(new AddMintersInput
    {
        Symbol = symbol,
        MinterList = new MinterList { Value = { MinterAddress } }
    });
    
    // Verify issuer is in minter list initially
    var minterListBefore = await NFTContractStub.GetMinterList.CallAsync(new StringValue { Value = symbol });
    minterListBefore.Value.ShouldContain(issuer);
    
    // Remove issuer from minter list
    await NFTContractStub.RemoveMinters.SendAsync(new RemoveMintersInput
    {
        Symbol = symbol,
        MinterList = new MinterList { Value = { issuer } }
    });
    
    // Verify issuer was removed
    var minterListAfterRemoval = await NFTContractStub.GetMinterList.CallAsync(new StringValue { Value = symbol });
    minterListAfterRemoval.Value.ShouldNotContain(issuer);
    
    // Perform a mint operation with the other minter
    await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        Alias = "test",
        Owner = DefaultAddress
    });
    
    // VULNERABILITY: Issuer is automatically re-added to the minter list
    var minterListAfterMint = await NFTContractStub.GetMinterList.CallAsync(new StringValue { Value = symbol });
    minterListAfterMint.Value.ShouldContain(issuer); // This demonstrates the bug
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L12-19)
```csharp
    public override Hash Mint(MintInput input)
    {
        if (input.Metadata != null && input.Metadata.Value.Any())
            AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var nftMinted = PerformMint(input);
        return nftMinted.TokenHash;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L175-175)
```csharp
        var nftMinted = PerformMint(mingInput, true);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L203-203)
```csharp
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L212-212)
```csharp
        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L268-268)
```csharp
        var oldMetadata = nftInfo.Metadata.Clone();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L355-373)
```csharp
    public override Empty RemoveMinters(RemoveMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol];

        foreach (var minter in input.MinterList.Value)
            if (minterList.Value.Contains(minter))
                minterList.Value.Remove(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListRemoved
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L375-381)
```csharp
    private MinterList GetMinterList(TokenInfo tokenInfo)
    {
        var minterList = State.MinterListMap[tokenInfo.Symbol] ?? new MinterList();
        if (!minterList.Value.Contains(tokenInfo.Issuer)) minterList.Value.Add(tokenInfo.Issuer);

        return minterList;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-399)
```csharp
        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L26-37)
```csharp
    public TEntity this[TKey key]
    {
        get
        {
            if (!Cache.TryGetValue(key, out var valuePair))
            {
                valuePair = LoadKey(key);
                Cache[key] = valuePair;
            }

            return valuePair.IsDeleted ? SerializationHelper.Deserialize<TEntity>(null) : valuePair.Value;
        }
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L78-93)
```csharp
    internal override TransactionExecutingStateSet GetChanges()
    {
        var stateSet = new TransactionExecutingStateSet();
        foreach (var kv in Cache)
        {
            var key = GetSubStatePath(kv.Key.ToString()).ToStateKey(Context.Self);
            if (kv.Value.IsDeleted)
                stateSet.Deletes[key] = true;
            else if (!Equals(kv.Value.OriginalValue, kv.Value.Value))
                stateSet.Writes[key] = ByteString.CopyFrom(SerializationHelper.Serialize(kv.Value.Value));

            stateSet.Reads[key] = true;
        }

        return stateSet;
    }
```
