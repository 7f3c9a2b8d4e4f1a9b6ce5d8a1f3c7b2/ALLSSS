# Audit Report

## Title
Term Boundary Violation in NextRound Consensus Command Generation Leading to Mining Reward Misallocation

## Summary
The AEDPoS consensus contract allows blocks to be mined with timestamps beyond the current term's end time while maintaining the previous term's number. This occurs when mining time calculation lacks term boundary validation and fewer than 2/3 of miners have crossed the term boundary, causing mining rewards for blocks produced in Term N+1's time period to be incorrectly allocated to Term N.

## Finding Description

The vulnerability stems from a critical disconnect between mining time calculation and term transition logic in the consensus mechanism.

When a miner needs to terminate the current round near a term boundary, the system determines whether to use `NextRound` or `NextTerm` behavior based on how many miners have already crossed the boundary. [1](#0-0)  The decision requires that at least `MinersCountOfConsent` miners (defined as `RealTimeMinersInformation.Count * 2 / 3 + 1`) have mined blocks past the term boundary. [2](#0-1) 

The system checks this via `NeedToChangeTerm()`, which counts miners whose `ActualMiningTimes` exceed the term boundary. [3](#0-2)  If this threshold is not met, the system generates a `NextRound` command instead of `NextTerm`.

When `TerminateRoundCommandStrategy` operates with `_isNewTerm=false`, it invokes `ArrangeExtraBlockMiningTime`, which delegates to `Round.ArrangeAbnormalMiningTime`. [4](#0-3) [5](#0-4) 

The `ArrangeAbnormalMiningTime` method calculates future mining times based purely on round duration mechanics without any term boundary validation. [6](#0-5)  It projects forward using `(missedRoundsCount + 1) * totalMilliseconds`, which can extend well past the term end time.

The validation layer fails to prevent this temporal misalignment. `RoundTerminateValidationProvider` only verifies that round numbers increment correctly and that InValues are null for NextRound operations. [7](#0-6)  Similarly, `TimeSlotValidationProvider` validates time slot correctness within round structure but not term boundary alignment. [8](#0-7) 

When `ProcessNextRound` executes, it does not update the term number—only `ProcessNextTerm` performs this critical update. [9](#0-8) [10](#0-9)  Therefore, rounds created via NextRound behavior maintain the previous term's number even when scheduled for mining beyond the term boundary.

## Impact Explanation

The impact manifests through direct mining reward misallocation affecting the protocol's economic model.

During round generation, `GenerateNextRoundInformation` copies each miner's `ProducedBlocks` counter from the previous round, creating a cumulative counter that accumulates across all rounds within a term. [11](#0-10)  Each block produced increments this counter. [12](#0-11) 

When `ProcessNextTerm` finally executes the term transition, it calls `DonateMiningReward(previousRound)` to calculate rewards. [13](#0-12)  This method uses `previousRound.GetMinedBlocks()` which sums all `ProducedBlocks` counters. [14](#0-13) 

**Concrete Scenario:**
If rounds 101-104 are created with `TermNumber=1` but blocks are mined after Term 1's designated end time (because fewer than 2/3 of miners had crossed when these rounds were created), all blocks from these rounds increment `ProducedBlocks` counters associated with `TermNumber=1`. When round 105 finally triggers `NextTerm`, the `previousRound` (104) still carries `TermNumber=1` with inflated block counts. The reward donation for Term 1 thus includes blocks actually mined during Term 2's time period, causing Term 1 to receive excess rewards while Term 2 receives correspondingly fewer rewards.

This breaks the fundamental economic invariant that term-based rewards correspond to their designated time periods, affecting Treasury distributions, election incentives, and governance timing assumptions.

## Likelihood Explanation

This vulnerability occurs deterministically during every term transition as part of normal consensus operation—no attacker action is required.

The preconditions are guaranteed at each term boundary:
1. Blockchain time reaches or exceeds the term end boundary
2. Fewer than `MinersCountOfConsent` (2/3 + 1) miners have produced blocks past the boundary
3. A miner generates a round-terminating command
4. The system creates NextRound commands with mining times extending past the term boundary

The 2/3 threshold creates an inherent race condition. When blockchain time first crosses a term boundary, it's mathematically certain that fewer than 2/3 of miners have crossed yet (since time progresses continuously but miner actions are discrete). During this window, the system continues generating NextRound commands while blockchain time is already in the next term's period.

Given that term transitions occur regularly (typically every 7 days based on `PeriodSeconds`), and this timing window exists at every transition, the probability of occurrence is **HIGH** with repeated impact over time.

## Recommendation

Implement term boundary validation in mining time calculation. When `ArrangeAbnormalMiningTime` calculates future mining times, verify that the resulting timestamp does not exceed the current term's end time. If it would, force a `NextTerm` behavior regardless of the 2/3 threshold.

Alternative approach: Add validation in `RoundTerminateValidationProvider` to reject NextRound commands when the calculated mining time would exceed the term boundary based on `blockchainStartTimestamp` and `periodSeconds`.

Additionally, consider implementing a hard cutoff where NextRound commands are forbidden once blockchain time passes the term boundary, ensuring immediate term transition once the time threshold is crossed.

## Proof of Concept

Due to the complexity of the AEDPoS consensus mechanism requiring full blockchain state, miner lists, and time progression, a complete proof of concept would require extensive test infrastructure setup. However, the vulnerability can be demonstrated by:

1. Setting up a test chain with 7 miners (MinersCountOfConsent = 5)
2. Advancing blockchain time to just past a term boundary (e.g., 604801 seconds with periodSeconds=604800)
3. Having only 4 miners produce blocks past the boundary
4. Observing that the 5th miner's NextRound command generates mining times past the term boundary while maintaining `TermNumber` from the previous term
5. Verifying that blocks mined in these rounds increment `ProducedBlocks` for the old term number
6. Confirming that `DonateMiningReward` uses these inflated counts when NextTerm finally occurs

The core issue is observable in the code flow: `NeedToChangeTerm` returns false → `NextRound` behavior → `ArrangeAbnormalMiningTime` without term validation → rounds created with old `TermNumber` but future timestamps → reward misallocation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-35)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L124-127)
```csharp
    public long GetMinedBlocks()
    {
        return RealTimeMinersInformation.Values.Sum(minerInRound => minerInRound.ProducedBlocks);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-38)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L22-25)
```csharp
        public static Timestamp ArrangeExtraBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return round.ArrangeAbnormalMiningTime(pubkey, currentBlockTime);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L19-37)
```csharp
    public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
        bool mustExceededCurrentRound = false)
    {
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }

        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-175)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L250-252)
```csharp
        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-56)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
