# Audit Report

## Title
NextRoundMiningOrderValidationProvider Fails to Detect Duplicate Mining Orders Due to Incorrect Round Validation and Ineffective Distinct() Call

## Summary
The `NextRoundMiningOrderValidationProvider` contains two critical bugs that completely disable validation of duplicate `FinalOrderOfNextRound` values. First, it validates the next round structure (where `FinalOrderOfNextRound` is always 0) instead of the current round. Second, calling `Distinct()` on `MinerInRound` objects fails to detect miners with duplicate order values. This allows malicious miners to inject duplicate mining orders via `TuneOrderInformation`, causing non-deterministic round generation and consensus failures.

## Finding Description

The validation is supposed to ensure each miner has a unique `FinalOrderOfNextRound` value before transitioning to the next round. However, two bugs render this validation ineffective:

**Bug #1: Validates Wrong Round**

The validator checks `validationContext.ProvidedRound`, which contains the NEXT round's structure: [1](#0-0) 

For `NextRound` behavior, `ProvidedRound` is populated by `GetConsensusExtraDataForNextRound`: [2](#0-1) 

This calls `GenerateNextRoundInformation`, which creates NEW `MinerInRound` objects that do NOT copy `FinalOrderOfNextRound` values: [3](#0-2) 

In the next round structure, all miners have `FinalOrderOfNextRound = 0` (default) and `OutValue = null`. The validation checks `0 == 0` and always passes. The validator should check `BaseRound` (current round in state) instead of `ProvidedRound`.

**Bug #2: Distinct() on Wrong Type**

Even if Bug #1 were fixed, the validation calls `.Distinct()` on `MinerInRound` objects. Protobuf-generated classes use value-based equality comparing ALL fields. Two miners with identical `FinalOrderOfNextRound` but different `Pubkey` are NOT considered duplicates by `Distinct()`. The code should call `.Select(m => m.FinalOrderOfNextRound).Distinct()`.

**Attack Vector**

During `UpdateValue`, miners provide `TuneOrderInformation` that is applied without duplicate validation: [4](#0-3) 

The `UpdateValueValidationProvider` does not validate `TuneOrderInformation` for duplicates: [5](#0-4) 

While `ApplyNormalConsensusData` has conflict resolution logic, it only applies when miners initially set their own orders. The `TuneOrderInformation` bypass occurs after this: [6](#0-5) 

When `GenerateNextRoundInformation` orders miners by the corrupted `FinalOrderOfNextRound` values, `OrderBy()` has undefined behavior for duplicates: [7](#0-6) 

## Impact Explanation

This vulnerability breaks the fundamental consensus invariant that each miner must have a unique mining order. The impact is **Critical** because:

1. **Non-Deterministic Round Generation**: When `OrderBy()` encounters duplicate `FinalOrderOfNextRound` values, the ordering is unstable. Different nodes may generate different next round structures, leading to consensus failures where nodes disagree on which miner should produce blocks at which time.

2. **Invalid Time Slot Assignment**: Miners may be assigned incorrect or overlapping time slots, causing the round to fail to produce blocks correctly.

3. **DoS Potential**: An attacker can repeatedly inject duplicate orders in every round, preventing proper block production and halting the chain.

4. **Unfair Block Production**: Malicious miners can manipulate the mining order to give themselves or confederates unfair advantages in block production, potentially monopolizing block rewards.

The attack affects ALL miners in the network and completely undermines the reliability of the AEDPoS consensus mechanism.

## Likelihood Explanation

The likelihood is **High** because:

1. **Reachable Entry Point**: Any current miner can call `UpdateValue` with crafted `TuneOrderInformation`. The method is publicly accessible: [8](#0-7) 

2. **Minimal Preconditions**: The attacker only needs to be a current miner producing blocks - a realistic precondition for consensus-level attacks.

3. **Zero Detection**: Both bugs ensure duplicate orders go completely undetected. The validation is added to the pipeline for `NextRound` behavior: [9](#0-8) 

But provides zero protection due to both bugs.

4. **Repeatable**: The attack can be executed in every round indefinitely.

5. **Low Cost**: The cost is negligible (normal block production cost), while the benefit is manipulating consensus.

## Recommendation

Fix both bugs in `NextRoundMiningOrderValidationProvider`:

1. **Fix Bug #1**: Change the validation to check `BaseRound` instead of `ProvidedRound`:
   ```csharp
   var baseRound = validationContext.BaseRound; // Use current round, not next round
   var distinctCount = baseRound.RealTimeMinersInformation.Values
       .Where(m => m.FinalOrderOfNextRound > 0)
       .Select(m => m.FinalOrderOfNextRound) // Fix Bug #2: Select order values
       .Distinct().Count();
   if (distinctCount != baseRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
   ```

2. **Additional Protection**: Add duplicate validation in `ProcessUpdateValue` before applying `TuneOrderInformation`:
   ```csharp
   // Validate no duplicates in TuneOrderInformation
   var existingOrders = currentRound.RealTimeMinersInformation.Values
       .Select(m => m.FinalOrderOfNextRound).Where(o => o > 0).ToHashSet();
   
   foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
   {
       if (existingOrders.Contains(tuneOrder.Value))
           Assert(false, $"Duplicate FinalOrderOfNextRound: {tuneOrder.Value}");
       existingOrders.Add(tuneOrder.Value);
       currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
   }
   ```

## Proof of Concept

```csharp
[Fact]
public async Task DuplicateMiningOrderAttack_ShouldBeDetected_ButIsNot()
{
    // Setup: Initialize consensus with 3 miners
    var miners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusWithMiners(miners);
    
    // Miner1 produces block with UpdateValue and sets their FinalOrderOfNextRound to 1
    await ProduceBlockWithUpdateValue("miner1", supposedOrder: 1);
    
    // Miner2 produces block and MALICIOUSLY sets Miner3's FinalOrderOfNextRound to 1 (duplicate!)
    var maliciousTuneOrder = new Dictionary<string, int> { ["miner3"] = 1 };
    await ProduceBlockWithUpdateValue("miner2", supposedOrder: 2, tuneOrderInformation: maliciousTuneOrder);
    
    // Get current round state
    var currentRound = await GetCurrentRound();
    
    // Verify duplicate exists in current round
    var order1Count = currentRound.RealTimeMinersInformation.Values
        .Count(m => m.FinalOrderOfNextRound == 1);
    Assert.Equal(2, order1Count); // Both miner1 and miner3 have order 1
    
    // Attempt NextRound transition - validation should reject but DOESN'T
    var nextRoundResult = await ExecuteNextRound("miner3");
    
    // BUG: NextRound succeeds despite duplicate orders!
    Assert.True(nextRoundResult.Success); // This assertion PASSES, proving the bug
    
    // Result: Next round generated with undefined ordering for duplicate values
    var nextRound = await GetCurrentRound();
    // OrderBy() with duplicates produces non-deterministic results
    // Different nodes may generate different next round structures -> consensus failure
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-16)
```csharp
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-203)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-27)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-44)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** protobuf/aedpos_contract.proto (L30-31)
```text
    rpc UpdateValue (UpdateValueInput) returns (google.protobuf.Empty) {
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```
