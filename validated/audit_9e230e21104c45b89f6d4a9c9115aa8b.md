# Audit Report

## Title
State Update Pattern Violation in SetTransactionFeeDelegations Causes Empty Delegatee Entries to Persist

## Summary
The `SetTransactionFeeDelegations` function in `TokenContract_Delegation.cs` contains a critical state consistency bug where empty delegatees (delegatees with zero delegations) are not properly removed from storage. The function attempts removal using direct state modification without the required read-modify-write-back pattern, violating AElf's state management semantics. This causes empty delegatee entries to accumulate, eventually blocking users from adding new legitimate delegatees when the hard limit of 24 is reached.

## Finding Description

In AElf's state management system, `MappedState<TKey, TEntity>` getters return deserialized value copies, not references. [1](#0-0)  Modifications to these copies do not persist unless explicitly written back via the setter. [2](#0-1) 

The `SetTransactionFeeDelegations` function violates this pattern when removing empty delegatees. The problematic sequence occurs in the update branch: [3](#0-2) 

**Critical Bug Flow:**
1. Lines 68-80: Delegations are modified, potentially removing all tokens for a delegatee
2. Line 83: State is written with `allDelegatees` containing the delegatee entry (even if now empty)
3. Line 86: Checks if delegation count is non-zero; if zero, continues to line 91
4. Line 91: Attempts removal via `State.TransactionFeeDelegateesMap[input.DelegatorAddress].Delegatees.Remove(delegateeAddress)`

Line 91 performs direct state access that returns a value copy, modifies that copy's `Delegatees` map, but never writes it back. The removal does NOT persist.

**Proof of Correct Pattern:**
Both `RemoveTransactionFeeDelegator` [4](#0-3)  and `RemoveTransactionFeeDelegatee` [5](#0-4)  follow the mandatory pattern: read state into variable → modify variable → write back.

This is the **only location in the entire codebase** using the direct state modification antipattern `State.Map[key].Property.Remove()`, strongly indicating it's a bug.

## Impact Explanation

**1. Delegatee Limit DoS**  
The contract enforces a hard limit: [6](#0-5)  This limit is checked when adding new delegatees: [7](#0-6) 

Users accumulating 24 empty delegatees cannot add new legitimate ones, despite having zero active delegations. This is a concrete availability DoS.

**2. Gas Inefficiency**  
During fee charging, the system iterates through all delegatees including empty ones: [8](#0-7)  Empty delegatees waste gas on every transaction despite having no delegations to charge.

**3. Storage Pollution**  
Empty entries consume state storage permanently without cleanup mechanism.

**4. Test Gap Masking**  
The existing test verifies delegation count reaches zero but doesn't check if the delegatee entry was removed: [9](#0-8) 

The query function returns empty objects for both non-existent and empty delegatees: [10](#0-9)  This masks the bug during testing.

## Likelihood Explanation

**Reachability:** Public method `SetTransactionFeeDelegations` callable by any user. [11](#0-10) 

**Trigger:** Normal delegation management when users set all delegation amounts to 0 or negative to remove a delegatee. [12](#0-11) 

**Frequency:** Every time a user cleans up delegations by setting them to zero. Over protocol lifetime, users will repeatedly add/remove delegations, accumulating up to 24 ghost entries per user.

**No Attack Required:** Pure logic bug in normal operations. No special privileges, economic cost, or attack sophistication needed.

## Recommendation

Apply the read-modify-write-back pattern consistently. Replace line 91 with the correct sequence:

```csharp
// BEFORE line 91, after the Count check:
var delegateesToUpdate = State.TransactionFeeDelegateesMap[input.DelegatorAddress];
delegateesToUpdate.Delegatees.Remove(delegateeAddress);
State.TransactionFeeDelegateesMap[input.DelegatorAddress] = delegateesToUpdate;
```

This matches the pattern used in `RemoveTransactionFeeDelegator` and `RemoveTransactionFeeDelegatee`.

Additionally, reorder the logic: check if removal is needed BEFORE writing state at line 83, preventing the intermediate inconsistent state.

## Proof of Concept

```csharp
[Fact]
public async Task SetTokenDelegation_EmptyDelegateeNotRemoved_AccumulatesUntilDoS()
{
    await Initialize();
    
    // Add delegations for delegatee 1
    var delegations = new Dictionary<string, long> { [NativeToken] = 100 };
    await TokenContractStub.SetTransactionFeeDelegations.SendAsync(
        new SetTransactionFeeDelegationsInput()
        {
            DelegatorAddress = User1Address,
            Delegations = { delegations }
        });
    
    // Verify delegatee count is 1
    var delegateesBefore = await TokenContractStub.GetTransactionFeeDelegatees.CallAsync(
        new GetTransactionFeeDelegateesInput { DelegatorAddress = User1Address });
    delegateesBefore.DelegateeAddresses.Count.ShouldBe(1);
    
    // Remove all delegations (set to 0)
    var emptyDelegations = new Dictionary<string, long> { [NativeToken] = 0 };
    await TokenContractStub.SetTransactionFeeDelegations.SendAsync(
        new SetTransactionFeeDelegationsInput()
        {
            DelegatorAddress = User1Address,
            Delegations = { emptyDelegations }
        });
    
    // Query shows empty delegations
    var queryResult = await TokenContractStub.GetTransactionFeeDelegationsOfADelegatee.CallAsync(
        new GetTransactionFeeDelegationsOfADelegateeInput
        {
            DelegatorAddress = User1Address,
            DelegateeAddress = DefaultAddress
        });
    queryResult.Delegations.Count.ShouldBe(0); // Passes - looks removed
    
    // BUG: But delegatee entry still exists in state!
    var delegateesAfter = await TokenContractStub.GetTransactionFeeDelegatees.CallAsync(
        new GetTransactionFeeDelegateesInput { DelegatorAddress = User1Address });
    delegateesAfter.DelegateeAddresses.Count.ShouldBe(1); // FAILS - ghost entry remains!
    
    // This proves empty delegatee was NOT removed from the map
    delegateesAfter.DelegateeAddresses[0].ShouldBe(DefaultAddress);
}
```

This test demonstrates that after setting delegations to 0, the query returns empty delegations (masking the bug), but `GetTransactionFeeDelegatees` reveals the delegatee entry still exists in the map. With 24 such ghost entries, users hit the DoS limit.

**Notes:**
This is a valid state consistency vulnerability stemming from incorrect application of AElf's state management patterns. The impact is concrete (DoS at delegatee limit), the likelihood is high (normal operations), and the fix is straightforward (apply correct pattern). The bug has existed undetected due to insufficient test coverage that doesn't verify actual state structure beyond query results.

### Citations

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L26-37)
```csharp
    public TEntity this[TKey key]
    {
        get
        {
            if (!Cache.TryGetValue(key, out var valuePair))
            {
                valuePair = LoadKey(key);
                Cache[key] = valuePair;
            }

            return valuePair.IsDeleted ? SerializationHelper.Deserialize<TEntity>(null) : valuePair.Value;
        }
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L38-48)
```csharp
        set
        {
            if (!Cache.TryGetValue(key, out var valuePair))
            {
                valuePair = LoadKey(key);
                Cache[key] = valuePair;
            }

            valuePair.IsDeleted = false;
            valuePair.Value = value;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L12-13)
```csharp
    public override SetTransactionFeeDelegationsOutput SetTransactionFeeDelegations(
        SetTransactionFeeDelegationsInput input)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L30-37)
```csharp
            // If there has been already DELEGATEE_MAX_COUNT delegatees, and still try to add，fail.
            if (allDelegateesMap.Count() >= TokenContractConstants.DELEGATEE_MAX_COUNT)
            {
                return new SetTransactionFeeDelegationsOutput()
                {
                    Success = false
                };
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L66-98)
```csharp
        else // This delegatee exists, so update
        {
            var delegationsMap = allDelegateesMap[delegateeAddress].Delegations;
            foreach (var (key, value) in delegationsToInput)
            {
                if (value <= 0 && delegationsMap.ContainsKey(key))
                {
                    delegationsMap.Remove(key);
                }
                else if (value > 0)
                {
                    AssertValidToken(key, value);
                    delegationsMap[key] = value;
                }
            }

            // Set and Fire logEvent
            State.TransactionFeeDelegateesMap[input.DelegatorAddress] = allDelegatees;

            // If a delegatee has no delegations, remove it!
            if (allDelegateesMap[delegateeAddress].Delegations.Count != 0)
                return new SetTransactionFeeDelegationsOutput()
                {
                    Success = true
                };
            State.TransactionFeeDelegateesMap[input.DelegatorAddress].Delegatees.Remove(delegateeAddress);
            Context.Fire(new TransactionFeeDelegationCancelled()
            {
                Caller = Context.Sender,
                Delegatee = Context.Sender,
                Delegator = input.DelegatorAddress
            });
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L122-124)
```csharp
        var delegatees = State.TransactionFeeDelegateesMap[input.DelegatorAddress];
        delegatees.Delegatees.Remove(Context.Sender.ToBase58());
        State.TransactionFeeDelegateesMap[input.DelegatorAddress] = delegatees;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L151-153)
```csharp
        var delegatees = State.TransactionFeeDelegateesMap[Context.Sender];
        delegatees.Delegatees.Remove(input.DelegateeAddress.ToBase58());
        State.TransactionFeeDelegateesMap[Context.Sender] = delegatees;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L164-179)
```csharp
    public override TransactionFeeDelegations GetTransactionFeeDelegationsOfADelegatee(
        GetTransactionFeeDelegationsOfADelegateeInput input)
    {
        var allDelegatees = State.TransactionFeeDelegateesMap[input.DelegatorAddress];
        var delegateeAddress = input.DelegateeAddress.ToBase58();
        // According to protoBuf, return an empty object, but null.
        if (allDelegatees == null)
        {
            return new TransactionFeeDelegations();
        }

        var allDelegateesMap = allDelegatees.Delegatees;
        return allDelegateesMap.ContainsKey(delegateeAddress)
            ? allDelegateesMap[delegateeAddress]
            : new TransactionFeeDelegations();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L18-18)
```csharp
    public const int DELEGATEE_MAX_COUNT = 24;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L183-199)
```csharp
        foreach (var (delegatee, delegations) in delegationInfo)
        {
            // compare current block height with the block height when the delegatee added
            if (Context.Transaction.RefBlockNumber < delegations.BlockHeight) continue;

            var delegateeBill = new TransactionFeeBill();
            var delegateeAllowanceBill = new TransactionFreeFeeAllowanceBill();
            var delegateeAddress = Address.FromBase58(delegatee);
            var delegateeChargingResult = ChargeTransactionFeesToBill(input, delegateeAddress,
                ref delegateeBill, ref delegateeAllowanceBill, fee, isSizeFeeFree, delegations);

            if (!delegateeChargingResult) continue;

            bill = delegateeBill;
            allowanceBill = delegateeAllowanceBill;
            fromAddress = delegateeAddress;
            chargingResult = true;
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenDelegationTest.cs (L51-76)
```csharp
    public async Task SetTokenDelegation_removeDelegatee_Test()
    {
        await SetTokenDelegation_Test();
        var delegations = new Dictionary<string, long>
        {
            [NativeToken] = 0,
            [BasicFeeSymbol] = 0,
            [SizeFeeSymbol] = 0
        };
        await TokenContractStub.SetTransactionFeeDelegations.SendAsync(new SetTransactionFeeDelegationsInput()
        {
            DelegatorAddress = User1Address,
            Delegations =
            {
                delegations
            }
        });

        var delegateAllowance = await TokenContractStub.GetTransactionFeeDelegationsOfADelegatee.CallAsync(
            new GetTransactionFeeDelegationsOfADelegateeInput()
            {
                DelegateeAddress = DefaultAddress,
                DelegatorAddress = User1Address
            });
        delegateAllowance.Delegations.Count().ShouldBe(0);
    }
```
