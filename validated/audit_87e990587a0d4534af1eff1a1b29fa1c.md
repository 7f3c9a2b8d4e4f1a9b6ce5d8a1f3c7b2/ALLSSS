# Audit Report

## Title
Miners Can Manipulate Mining Order by Providing Arbitrary SupposedOrderOfNextRound Values

## Summary
The AEDPoS consensus contract accepts `SupposedOrderOfNextRound` values from miners without validating they match the signature-based calculation, allowing miners to arbitrarily choose their mining position in subsequent rounds and breaking consensus fairness guarantees.

## Finding Description

The AEDPoS consensus mechanism is designed to calculate each miner's position in the next round based on their cryptographic signature to ensure unpredictability and fairness. The calculation formula uses `GetAbsModulus(signature.ToInt64(), minersCount) + 1` to deterministically derive the supposed order from the signature hash. [1](#0-0) 

This calculation occurs when `GetConsensusBlockExtraData` internally calls `ApplyNormalConsensusData` to prepare consensus data: [2](#0-1) 

However, the critical vulnerability exists in `ProcessUpdateValue`, which directly assigns the `SupposedOrderOfNextRound` value from the transaction input without any recalculation or validation against the signature: [3](#0-2) 

The validation phase only checks that `OutValue` and `Signature` are non-null/non-empty, and validates the `PreviousInValue` hash relationship, but completely omits any validation of the `SupposedOrderOfNextRound` field: [4](#0-3) 

The `NextRoundMiningOrderValidationProvider` that could potentially validate mining orders is only applied for `NextRound` behavior, not for `UpdateValue`: [5](#0-4) 

Furthermore, this validator only checks that the count of miners with `FinalOrderOfNextRound > 0` matches the count of miners who mined, but does not verify individual order value correctness: [6](#0-5) 

The manipulated `FinalOrderOfNextRound` is then used by `GenerateNextRoundInformation` to determine actual mining positions in the next round: [7](#0-6) 

## Impact Explanation

This vulnerability fundamentally breaks the fairness and unpredictability guarantees of the AEDPoS consensus mechanism:

1. **Consensus Manipulation**: A malicious miner can consistently position themselves at favorable mining orders (e.g., first position), giving them priority access to block production and associated rewards.

2. **Economic Advantage**: The first miner in a round has the opportunity to produce extra blocks if subsequent miners are offline or late, earning disproportionate mining rewards. They also gain priority in transaction inclusion which could enable MEV extraction.

3. **Random Number Influence**: Mining order affects the sequence of consensus operations and random number generation, potentially enabling manipulation of consensus randomness used by other protocol operations.

4. **Systemic Risk**: If multiple colluding miners exploit this vulnerability, they could coordinate their positions to dominate consensus, destabilize round transitions, or create predictable mining patterns that fundamentally undermine the security model.

The impact is **CRITICAL** because it violates a core protocol invariant: mining order must be cryptographically unpredictable and derived from signatures, not arbitrarily chosen by miners.

## Likelihood Explanation

The attack is **HIGHLY LIKELY** with minimal technical complexity:

**Attacker Capabilities**: Any active miner in the consensus set can execute this attack. No special privileges are required beyond normal miner participation.

**Attack Steps**:
1. Miner queries `GetConsensusBlockExtraData` (view function) to obtain their valid `OutValue` and `Signature` values
2. Miner constructs a modified `UpdateValueInput` with the valid cryptographic values but replaces `SupposedOrderOfNextRound` with their desired position (e.g., 1 for first position)
3. Miner submits this modified transaction via the public `UpdateValue` method
4. The contract accepts the arbitrary order value as all validation checks only verify `OutValue`, `Signature`, and `PreviousInValue` relationships

**Feasibility**: The attack requires no special preconditionsâ€”only normal participation in consensus. The cost is negligible (standard transaction gas), while the benefit is continuous preferential mining positions and increased block rewards. Miners are economically incentivized to exploit this vulnerability.

**Detection Difficulty**: While theoretically detectable by comparing submitted values against signature-calculated values off-chain, there is no automatic on-chain enforcement, making exploitation practical and profitable.

## Recommendation

Add validation in `UpdateValueValidationProvider` to verify that the provided `SupposedOrderOfNextRound` matches the signature-based calculation:

```csharp
private bool ValidateSupposedOrderOfNextRound(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var signature = minerInRound.Signature;
    var minersCount = validationContext.ProvidedRound.RealTimeMinersInformation.Count;
    
    var expectedOrder = GetAbsModulus(signature.ToInt64(), minersCount) + 1;
    
    return minerInRound.SupposedOrderOfNextRound == expectedOrder;
}
```

And call this validation in `UpdateValueValidationProvider.ValidateHeaderInformation()`.

Alternatively, recalculate `SupposedOrderOfNextRound` in `ProcessUpdateValue` rather than accepting it from user input, similar to how `ApplyNormalConsensusData` works.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task Miner_Can_Manipulate_SupposedOrderOfNextRound()
{
    // Setup: Initialize consensus with multiple miners
    var miners = GenerateMiners(5);
    await InitializeConsensus(miners);
    
    // Miner A mines a block and gets their signature
    var minerA = miners[0];
    var consensusData = await GetConsensusBlockExtraData(minerA);
    var legitimateOrder = consensusData.Round.RealTimeMinersInformation[minerA.PublicKey].SupposedOrderOfNextRound;
    
    // Attack: Miner A constructs UpdateValueInput with manipulated order
    var maliciousInput = new UpdateValueInput
    {
        OutValue = consensusData.Round.RealTimeMinersInformation[minerA.PublicKey].OutValue,
        Signature = consensusData.Round.RealTimeMinersInformation[minerA.PublicKey].Signature,
        PreviousInValue = GetPreviousInValue(minerA),
        SupposedOrderOfNextRound = 1, // Miner chooses first position instead of legitimateOrder
        // ... other required fields
    };
    
    // Execute attack
    await AEDPoSContractStub.UpdateValue(maliciousInput);
    
    // Verify: Check that manipulated order was accepted
    var currentRound = await GetCurrentRound();
    var finalOrder = currentRound.RealTimeMinersInformation[minerA.PublicKey].FinalOrderOfNextRound;
    
    Assert.Equal(1, finalOrder); // Miner successfully set themselves as first
    Assert.NotEqual(legitimateOrder, finalOrder); // Different from signature-calculated order
}
```

## Notes

The vulnerability exists because `UpdateValue` accepts user-provided `SupposedOrderOfNextRound` without validation. While `GetConsensusBlockExtraData` correctly calculates this value using `ApplyNormalConsensusData`, miners can bypass this calculation by directly constructing `UpdateValueInput` with arbitrary values. The contract trusts the miner-provided value despite it being a security-critical field that should be deterministically derived from the cryptographic signature.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-49)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-86)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
