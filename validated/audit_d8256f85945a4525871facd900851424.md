# Audit Report

## Title
Permanent Loss of Fungible Tokens When Assembled NFTs Are Burned Directly

## Summary
The NFT contract's `Burn` method allows destruction of assembled NFTs without cleaning up the `AssembledFtsMap` state or returning locked fungible tokens to their owners. This results in permanent and irreversible loss of the FTs that were locked during assembly, as no recovery mechanism exists in the contract.

## Finding Description

The root cause lies in the `Burn` method's lack of validation and cleanup for assembled NFTs. [1](#0-0) 

The method only validates three conditions: whether the NFT protocol is burnable, whether the caller is in the minter list, and whether the caller has sufficient balance. Critically, it does NOT check whether the NFT has associated fungible tokens stored in `AssembledFtsMap`, nor does it clean up or return these locked tokens.

When an NFT is assembled with fungible tokens, the `Assemble` method transfers FTs from the user to the contract address (Context.Self) and stores the mapping. [2](#0-1) 

The mapping is then persisted in state: [3](#0-2) 

The state variable is defined as: [4](#0-3) 

The correct flow to retrieve these FTs is through the `Disassemble` method, which burns the NFT, retrieves the locked FTs, transfers them back to the receiver, and removes the mapping entry. [5](#0-4) 

However, if a minter directly calls `Burn` on an assembled NFT, the NFT is destroyed but the `AssembledFtsMap` entry persists orphaned. Since `Disassemble` requires the NFT to exist (it calls `Burn` internally which checks balance at line 91), and the contract provides no admin recovery functions (grep search confirms `AssembledFtsMap` is only accessed in Assemble and Disassemble), the locked FTs become permanently inaccessible.

## Impact Explanation

**High Severity - Direct Fund Loss**

The impact is severe and irreversible:

1. **Permanent Fund Lock**: When an assembled NFT is burned directly, fungible tokens transferred during assembly remain locked in the contract address forever. For example, if 100 ELF tokens are assembled into an NFT and the NFT is subsequently burned via `Burn()`, those 100 ELF are permanently lost.

2. **No Recovery Path**: 
   - The `AssembledFtsMap` entry persists but becomes inaccessible since the tokenHash no longer corresponds to an existing NFT
   - `Disassemble` cannot be called because it requires NFT ownership (balance check fails at line 91)
   - Code analysis confirms no emergency withdrawal or admin recovery methods exist in the contract
   - The tokens are effectively removed from circulation without proper accounting

3. **Protocol-Level Impact**: 
   - Unexpected reduction in circulating token supply
   - Breaks the invariant that assembled tokens should always be retrievable
   - Affects protocol integrity and user trust

4. **Affected Parties**: NFT holders who accidentally burn assembled NFTs lose all locked FTs. Given that minters typically have elevated privileges and may assemble high-value NFTs, potential losses could be substantial.

## Likelihood Explanation

**Medium-High Likelihood**

The vulnerability has realistic preconditions and low execution complexity:

**Preconditions** (all realistic):
1. Caller must be a minter (authorized but trusted roles can err or be compromised)
2. Caller must own the assembled NFT (normal operational state)
3. The NFT protocol must have `IsBurnable` set to true (common configuration)

**Attack Complexity**: LOW
- Single direct function call with no complex setup
- Can occur accidentally (user error selecting wrong method)
- Can occur intentionally (malicious or compromised minter)
- No cryptographic or timing requirements

**Feasibility**: HIGH
- No protective logic exists in the code to prevent this scenario
- The contract interface provides both `Burn` and `Disassemble` methods, creating confusion
- Minters are trusted but human error is inevitable, especially in complex operations

**Detection**: Post-incident only. The loss is only discovered when attempting to retrieve the FTs, by which time recovery is impossible.

## Recommendation

Add validation in the `Burn` method to check for assembled tokens and either:

**Option 1 (Recommended)**: Prevent burning of assembled NFTs
```csharp
public override Empty Burn(BurnInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    
    // Add check for assembled FTs
    var assembledFts = State.AssembledFtsMap[tokenHash];
    Assert(assembledFts == null || !assembledFts.Value.Any(), 
        "Cannot burn assembled NFT directly. Use Disassemble method instead.");
    
    // Existing burn logic...
}
```

**Option 2**: Automatically disassemble when burning
```csharp
public override Empty Burn(BurnInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    
    // Check for assembled FTs and return them
    var assembledFts = State.AssembledFtsMap[tokenHash];
    if (assembledFts != null && assembledFts.Value.Any())
    {
        foreach (var pair in assembledFts.Value)
        {
            State.TokenContract.Transfer.Send(new MultiToken.TransferInput
            {
                Symbol = pair.Key,
                Amount = pair.Value,
                To = Context.Sender
            });
        }
        State.AssembledFtsMap.Remove(tokenHash);
    }
    
    // Existing burn logic...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task Burn_AssembledNFT_LosesFTsPermanently()
{
    // Setup: Create NFT protocol and add minter
    var symbol = await CreateTest(); // Creates burnable NFT protocol
    await AddMinterAsync(symbol);
    
    // Mint an NFT
    var tokenHash = (await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        Owner = MinterAddress,
        Uri = "ipfs://test"
    })).Output;
    
    // Approve NFT contract to spend ELF
    await MinterTokenContractStub.Approve.SendAsync(new MultiToken.ApproveInput
    {
        Spender = NFTContractAddress,
        Symbol = "ELF",
        Amount = 1000_00000000 // 1000 ELF
    });
    
    // Record initial ELF balance of contract
    var contractBalanceBefore = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = NFTContractAddress, Symbol = "ELF" })).Balance;
    
    // Assemble NFT with 1000 ELF
    var assembledTokenHash = (await MinterNFTContractStub.Assemble.SendAsync(new AssembleInput
    {
        Symbol = symbol,
        AssembledFts = new AssembledFts { Value = { ["ELF"] = 1000_00000000 } }
    })).Output;
    
    // Verify ELF was locked in contract
    var contractBalanceAfter = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = NFTContractAddress, Symbol = "ELF" })).Balance;
    contractBalanceAfter.ShouldBe(contractBalanceBefore + 1000_00000000);
    
    // Vulnerability: Directly burn the assembled NFT instead of disassembling
    await MinterNFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        TokenId = 2, // The assembled NFT's token ID
        Amount = 1
    });
    
    // NFT is destroyed - balance is now 0
    var nftBalance = (await MinterNFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = MinterAddress,
        Symbol = symbol,
        TokenId = 2
    })).Balance;
    nftBalance.ShouldBe(0);
    
    // ELF is still locked in contract (not returned to owner)
    var contractBalanceFinal = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = NFTContractAddress, Symbol = "ELF" })).Balance;
    contractBalanceFinal.ShouldBe(contractBalanceAfter); // ELF still locked!
    
    // Attempting to Disassemble now fails because NFT no longer exists
    var disassembleResult = await MinterNFTContractStub.Disassemble.SendWithExceptionAsync(
        new DisassembleInput { Symbol = symbol, TokenId = 2 });
    disassembleResult.TransactionResult.Error.ShouldContain("No permission"); // Fails on balance check
    
    // Result: 1000 ELF permanently locked in contract with no recovery method
}
```

## Notes

This vulnerability represents a critical design flaw where two methods (`Burn` and `Disassemble`) operate on the same state but with incomplete state management. The `Burn` method was designed without considering the assembly feature, creating a bypass that leads to permanent fund loss. The issue is compounded by the lack of any admin recovery mechanism that could retrieve orphaned funds from the contract.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L134-162)
```csharp
        if (input.AssembledFts.Value.Any())
        {
            metadata.Value[AssembledFtsKey] = input.AssembledFts.ToString();
            // Check balance and allowance.
            foreach (var pair in input.AssembledFts.Value)
            {
                var symbol = pair.Key;
                var amount = pair.Value;
                var balance = State.TokenContract.GetBalance.Call(new MultiToken.GetBalanceInput
                {
                    Owner = Context.Sender,
                    Symbol = symbol
                }).Balance;
                Assert(balance >= amount, $"Insufficient balance of {symbol}");
                var allowance = State.TokenContract.GetAllowance.Call(new MultiToken.GetAllowanceInput
                {
                    Owner = Context.Sender,
                    Spender = Context.Self,
                    Symbol = symbol
                }).Allowance;
                Assert(allowance >= amount, $"Insufficient allowance of {symbol}");
                State.TokenContract.TransferFrom.Send(new MultiToken.TransferFromInput
                {
                    From = Context.Sender,
                    To = Context.Self,
                    Symbol = symbol,
                    Amount = amount
                });
            }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L178-178)
```csharp
        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-236)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }

        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
        }

        Context.Fire(new Disassembled
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            DisassembledNfts = assembledNfts ?? new AssembledNfts(),
            DisassembledFts = assembledFts ?? new AssembledFts()
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L33-33)
```csharp
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```
