# Audit Report

## Title
Term Transition Bypass via Behavior Selection Manipulation

## Summary
The AEDPoS consensus contract fails to enforce on-chain that the correct consensus behavior (NextRound vs NextTerm) is used when terminating rounds. Miners can bypass term transitions by submitting NextRound transactions instead of NextTerm, permanently blocking treasury profit releases, election snapshots, and miner list rotations.

## Finding Description

The vulnerability stems from a critical gap between client-side decision logic and on-chain validation. While the protocol has logic to determine when term transitions should occur, this logic is not enforced on-chain.

**Client-Side Decision Logic (Not Enforced):**
The `MainChainConsensusBehaviourProvider` determines which behavior to use when terminating rounds by calling `NeedToChangeTerm()`, which checks if two-thirds of miners have reached the term change threshold. [1](#0-0) [2](#0-1) 

However, this logic exists purely in the `ConsensusCommandGeneration` folder, which is client-side code used by nodes to decide what transaction to submit. There is no corresponding on-chain validation.

**On-Chain Validation (Insufficient):**
Both `NextRound` and `NextTerm` are public methods callable by any miner: [3](#0-2) [4](#0-3) 

The only access control is `PreCheck()`, which merely validates the sender is in the current or previous round's miner list: [5](#0-4) 

The validation system adds `RoundTerminateValidationProvider` for both NextRound and NextTerm behaviors: [6](#0-5) 

However, this provider only validates data consistency (round/term numbers increment correctly), not behavior appropriateness: [7](#0-6) 

**Exploitation Path:**
When a miner submits `NextRound` instead of `NextTerm`, `ProcessNextRound` is executed, which only updates the round number: [8](#0-7) [9](#0-8) 

This completely bypasses `ProcessNextTerm` logic, which includes critical protocol functions: [10](#0-9) 

## Impact Explanation

**Critical Economic Impact:**

1. **Treasury Profit Releases Blocked:** The treasury release mechanism at term boundaries is permanently disabled. This breaks the protocol's core economic distribution mechanism that funds ecosystem development and rewards participants. [11](#0-10) 

2. **Election Snapshots Never Taken:** Election snapshots that determine reward distribution are never captured, breaking delegation and staking rewards. [12](#0-11) 

3. **Miner Statistics Accumulate Indefinitely:** Missed time slots and produced blocks counters are never reset, causing incorrect statistics that affect miner rankings and rewards. [13](#0-12) 

**Consensus Governance Impact:**

4. **Miner List Rotation Blocked:** New term miner lists are never applied, preventing validator set updates and maintaining incumbent miners indefinitely. [14](#0-13) 

5. **Term Number Frozen:** The term number remains frozen while rounds continue incrementing, breaking the consensus governance cycle that depends on term transitions for protocol upgrades and validator rotations.

This permanently breaks core protocol functions affecting all stakeholders: token holders lose treasury distributions, delegators lose staking rewards, and governance mechanisms freeze.

## Likelihood Explanation

**Attacker Requirements:**
- Must be a miner in the current or previous round's miner list
- This is a privileged but attainable position through the election process (typically 1 out of ~17 miners)

**Attack Complexity:**
LOW - The attack is trivial to execute:
1. Wait for a round where term transition should occur (when `NeedToChangeTerm()` would return true)
2. Submit a `NextRound()` transaction instead of `NextTerm()`
3. The transaction passes all validations and executes successfully

**Feasibility:**
- Both methods are public and directly callable without any authorization beyond miner list membership
- No on-chain mechanism exists to detect or prevent this behavior
- The validation only checks data consistency, not appropriateness

**Detection & Recovery:**
- Observable: Term number stops incrementing while rounds continue
- Not preventable: No on-chain enforcement mechanism exists
- No automatic recovery: Would require governance intervention or protocol upgrade

**Incentives:**
- Malicious miners could maintain their position by preventing validator set rotation
- Disrupting governance to prevent unfavorable protocol changes
- Economic advantage by freezing the current mining reward distribution

The probability is HIGH given the straightforward attack path, low complexity, and potential incentives for execution.

## Recommendation

Add on-chain enforcement of behavior appropriateness in the validation logic. The `RoundTerminateValidationProvider` should check whether a term transition is required based on consensus state:

1. **Add NeedToChangeTerm validation:** Incorporate the term change threshold logic into on-chain validation
2. **Enforce behavior selection:** When `NeedToChangeTerm()` conditions are met, reject NextRound transactions and require NextTerm
3. **Validate in RoundTerminateValidationProvider:**

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing checks
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Check if term should change
    if (validationContext.BaseRound.NeedToChangeTerm(
        validationContext.BlockchainStartTimestamp,
        validationContext.CurrentTermNumber, 
        validationContext.PeriodSeconds))
    {
        return new ValidationResult { Message = "Term transition required - must use NextTerm behavior." };
    }
    
    return new ValidationResult { Success = true };
}
```

4. **Pass additional context:** Ensure `ConsensusValidationContext` includes blockchain start timestamp and period seconds needed for the check

## Proof of Concept

```csharp
[Fact]
public async Task TermTransitionBypass_MinerCanCallNextRoundInsteadOfNextTerm()
{
    // Setup: Initialize consensus with first round
    var initialMiners = GenerateInitialMiners(5);
    await InitializeConsensus(initialMiners);
    
    // Advance blockchain time past the term change threshold
    var periodSeconds = await GetPeriodSeconds();
    var currentTermNumber = await GetCurrentTermNumber();
    var blockchainStartTime = await GetBlockchainStartTimestamp();
    
    // Calculate time when term should change
    var termChangeTime = blockchainStartTime.AddSeconds(periodSeconds * currentTermNumber);
    AdvanceBlockTimeTo(termChangeTime.AddSeconds(1));
    
    // Produce blocks with 2/3 of miners to meet term change threshold
    var minersToMine = (int)Math.Ceiling(initialMiners.Count * 2.0 / 3.0);
    for (int i = 0; i < minersToMine; i++)
    {
        await ProduceBlockWithMiner(initialMiners[i]);
    }
    
    // Verify term change threshold is met
    var currentRound = await GetCurrentRoundInformation();
    var needToChangeTerm = currentRound.NeedToChangeTerm(
        blockchainStartTime, currentTermNumber, periodSeconds);
    Assert.True(needToChangeTerm); // Should return true
    
    // Attack: Miner calls NextRound instead of NextTerm
    var maliciousMiner = initialMiners[0];
    var nextRoundInput = GenerateNextRoundInput(currentRound);
    
    var result = await ExecuteConsensusTransaction(
        maliciousMiner, 
        nameof(AEDPoSContract.NextRound), 
        nextRoundInput);
    
    // Verify attack succeeds
    Assert.True(result.Status == TransactionResultStatus.Mined);
    
    // Verify term transition was bypassed
    var newTermNumber = await GetCurrentTermNumber();
    Assert.Equal(currentTermNumber, newTermNumber); // Term number unchanged
    
    var newRoundNumber = await GetCurrentRoundNumber();
    Assert.Equal(currentRound.RoundNumber + 1, newRoundNumber); // Round incremented
    
    // Verify critical functions were skipped
    Assert.Empty(await GetTreasuryReleaseEvents()); // No treasury release
    Assert.Empty(await GetElectionSnapshotEvents()); // No election snapshot
    
    // Verify miner list was not updated
    var minerList = await GetCurrentMinerList();
    Assert.Equal(initialMiners, minerList); // Same miners
    
    // Protocol is now in broken state: rounds continue but term never changes
}
```

**Notes:**

This vulnerability represents a fundamental flaw in the separation between client-side decision logic and on-chain enforcement. While the protocol correctly implements the logic to determine when term transitions should occur (`NeedToChangeTerm`), this logic exists only in the `ConsensusCommandGeneration` folder, which is off-chain client-side code. Miners are trusted to follow this logic voluntarily, but nothing prevents a malicious miner from ignoring it.

The impact is severe because term transitions are not just administrative state updatesâ€”they are critical checkpoints where:
1. Economic distributions occur (treasury releases)
2. Governance snapshots are taken (election state)
3. Validator sets rotate (miner list updates)
4. Performance metrics reset (miner statistics)

By bypassing term transitions, an attacker can permanently freeze these mechanisms while the blockchain continues operating with incrementing round numbers. This creates a degraded state where consensus continues but governance and economic distribution mechanisms are broken.

The likelihood is high because:
- The attack requires only miner privileges, which are attainable through the election process
- The execution is trivial (calling one method instead of another)
- There are clear incentive structures (maintaining validator position, disrupting governance)
- No recovery mechanism exists without governance intervention

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-223)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L91-97)
```csharp
    private bool TryToUpdateRoundNumber(long roundNumber)
    {
        var oldRoundNumber = State.CurrentRoundNumber.Value;
        if (roundNumber != 1 && oldRoundNumber + 1 != roundNumber) return false;
        State.CurrentRoundNumber.Value = roundNumber;
        return true;
    }
```
