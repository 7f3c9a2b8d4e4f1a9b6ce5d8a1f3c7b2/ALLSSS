# Audit Report

## Title
Consensus DoS via Malicious ConfirmedIrreversibleBlockHeight in NextRound Transaction

## Summary
An authorized miner can cause their consensus transaction to fail by providing a malicious `ConfirmedIrreversibleBlockHeight` value greater than the current block height in a `NextRound` transaction. The value bypasses validation due to a systematic validation gap, gets stored in state, and triggers an `OverflowException` when `GetMaximumBlocksCount()` attempts checked arithmetic, causing the miner's block to fail and disrupting consensus availability during their production turn.

## Finding Description

The vulnerability exists due to a validation gap in the consensus round transition logic. The `LibInformationValidationProvider`, which validates Last Irreversible Block (LIB) information bounds, is selectively applied only to `UpdateValue` behavior but not to `NextRound` or `NextTerm` behaviors. [1](#0-0) 

When a miner calls `NextRound`, the validation phase only applies `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider`, neither of which validates the bounds of `ConfirmedIrreversibleBlockHeight` or `ConfirmedIrreversibleBlockRoundNumber` fields. [2](#0-1) [3](#0-2) 

The `LibInformationValidationProvider` would prevent LIB values from exceeding reasonable bounds by checking that they don't decrease from the base round, but it's never invoked for `NextRound` transactions. [4](#0-3) 

The malicious `NextRoundInput` is converted to a `Round` object with the attacker-controlled values preserved without validation: [5](#0-4) 

During `ProcessNextRound`, the malicious round is stored in state: [6](#0-5) [7](#0-6) 

The comment at line 67 explicitly states "Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is", ensuring `GetMaximumBlocksCount()` is called after processing: [8](#0-7) 

Inside `GetMaximumBlocksCount()`, when the blockchain enters "Severe" status (which the attacker can trigger by setting low `ConfirmedIrreversibleBlockRoundNumber`), the code attempts to subtract `libBlockHeight` from `currentHeight`: [9](#0-8) 

The `.Sub()` method uses checked arithmetic and will throw `OverflowException` when attempting to subtract a larger value from a smaller value: [10](#0-9) 

This behavior is confirmed by the SafeMath test suite: [11](#0-10) 

## Impact Explanation

**Operational Impact - Consensus DoS:**
- The consensus transaction fails with an unhandled `OverflowException` during the attacker's block production turn
- Due to transaction rollback on exception, the malicious state is not persisted, preventing corruption of subsequent miners' operations
- The attacker's block becomes invalid as the critical consensus operation cannot complete
- Other nodes will reject the malicious miner's block during validation
- Consensus availability is disrupted during the attacker's production turn
- The attack is repeatable by any malicious miner in subsequent rounds when it's their turn

**Affected Parties:**
- Network availability and liveness are temporarily compromised during the attack
- Normal transaction processing is blocked for the duration of the attacker's failed block attempt
- Trust in consensus reliability is undermined

**Severity:** Medium - While this requires the attacker to be an authorized miner (limiting the attack surface), the impact disrupts consensus availability. The attack is low-cost (single malicious transaction) and repeatable, but the scope is limited to the attacker's own block production turn due to state rollback.

## Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an authorized miner in the current consensus round
- This is a realistic assumption in a DPoS system where miners are elected through the Election contract
- No additional privileges beyond normal miner authority are required

**Attack Complexity:**
- Low complexity - attacker crafts a `NextRoundInput` with `ConfirmedIrreversibleBlockHeight` set to a value greater than `Context.CurrentHeight`
- Can set `ConfirmedIrreversibleBlockRoundNumber` to a low value to immediately trigger Severe status
- The malicious input passes all validation checks due to the systematic validation gap
- Single transaction execution causes the DoS

**Feasibility:**
- The validation gap is systematic and present in the codebase
- `GetMaximumBlocksCount()` is called on every consensus behavior as enforced by the code comment
- Severe status calculation uses the attacker-controlled values without bounds checking

**Probability:** High - Any authorized miner can exploit this validation gap during their turn to produce blocks.

## Recommendation

Apply `LibInformationValidationProvider` to `NextRound` and `NextTerm` behaviors in addition to `UpdateValue`. Modify the validation logic to include LIB bounds checking for all consensus behaviors that can modify these fields:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // Add this
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // Add this
        break;
}
```

This ensures that `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` values cannot exceed reasonable bounds regardless of which consensus behavior is being processed.

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_MaliciousLIBHeight_ShouldCauseOverflow()
{
    // Setup: Initialize consensus with miners
    await InitializeConsensus();
    
    // Generate legitimate round to get current state
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var currentHeight = await BlockchainService.GetBestChainHeight();
    
    // Craft malicious NextRoundInput with LIB height > current height
    var maliciousInput = currentRound.GenerateNextRoundInformation(
        currentHeight,
        BlockTime,
        MinerKeyPairs[0].PublicKey.ToHex()
    );
    maliciousInput.ConfirmedIrreversibleBlockHeight = currentHeight + 1000; // Malicious!
    maliciousInput.ConfirmedIrreversibleBlockRoundNumber = 1; // Low value triggers Severe
    
    // Execute NextRound with malicious input
    var result = await ConsensusStub.NextRound.SendAsync(maliciousInput);
    
    // Verify transaction fails with overflow
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("OverflowException");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L67-69)
```csharp
        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-67)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L58-61)
```csharp
        number1.Sub(5).ShouldBe(1UL);
        number2.Sub(5).ShouldBe(1L);
        Should.Throw<OverflowException>(() => { long.MaxValue.Sub(-5); });
        Should.Throw<OverflowException>(() => { ulong.MinValue.Sub(5); });
```
