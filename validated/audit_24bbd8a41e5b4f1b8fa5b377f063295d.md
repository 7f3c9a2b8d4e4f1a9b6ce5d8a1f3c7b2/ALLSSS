# Audit Report

## Title
TokenHolder Scheme Configuration Overwrite Allows Violation of Lock Agreements

## Summary
The `CreateScheme` function in TokenHolderContract lacks protection against being called multiple times by the same scheme manager. This allows a malicious scheme manager to arbitrarily change the `Symbol` or `MinimumLockMinutes` parameters after users have already locked their tokens, breaking the lock agreement and causing permanent fund loss or enabling unintended early withdrawals.

## Finding Description

The TokenHolderContract's `CreateScheme` function has a critical flaw: it contains no validation to prevent a scheme manager from calling it multiple times. [1](#0-0) 

Each invocation unconditionally overwrites the `State.TokenHolderProfitSchemes[Context.Sender]` mapping with new values for `Symbol`, `MinimumLockMinutes`, and `AutoDistributeThreshold`. [2](#0-1) 

While each call to `CreateScheme` creates a new profit scheme in the underlying Profit contract [3](#0-2) , the Profit contract allows the same manager to create multiple schemes by appending each new scheme ID to a list. [4](#0-3) 

The `GetValidScheme` function always retrieves the first scheme ID via `FirstOrDefault()` [5](#0-4) , but uses the **overwritten** `Symbol` and `MinimumLockMinutes` values from TokenHolder's state.

When users register for profits, they lock tokens using the current `scheme.Symbol` value [6](#0-5) , and the lock timestamp is recorded [7](#0-6) .

However, when users attempt to withdraw, the `Withdraw` function queries locked amounts using the **current** `scheme.Symbol` from the overwritten state [8](#0-7) , and checks the time lock using the **current** `scheme.MinimumLockMinutes` [9](#0-8) .

The `GetLockedAmount` implementation queries the balance of the virtual address for the specified symbol [10](#0-9) . If tokens were locked as "ELF" but the query uses "USDT", it returns 0 because the virtual address contains ELF tokens, not USDT.

The test suite demonstrates protection against repeated `RegisterForProfits` calls [11](#0-10) , but no equivalent test exists for repeated `CreateScheme` calls.

## Impact Explanation

**Attack Scenario 1 - Symbol Change (Permanent Fund Loss):**
1. Users lock ELF tokens under a scheme with `Symbol="ELF"`
2. Scheme manager calls `CreateScheme` again with `Symbol="USDT"`
3. When users attempt withdrawal, `GetLockedAmount` queries for USDT locks instead of ELF
4. The query returns 0 (tokens were locked as ELF, not USDT)
5. Users cannot unlock their ELF tokens - **permanent fund loss**

**Attack Scenario 2 - MinimumLockMinutes Reduction (Early Withdrawal):**
1. Scheme manager creates scheme with `MinimumLockMinutes=10000` (≈7 days)
2. Users lock tokens expecting a 10000-minute minimum lock period
3. Scheme manager calls `CreateScheme` with `MinimumLockMinutes=1`
4. Users (or the scheme manager as a beneficiary) can withdraw after 1 minute instead of 10000 minutes
5. Violates profit distribution timeframe expectations

**Attack Scenario 3 - MinimumLockMinutes Increase (Extended Lock):**
1. Users lock tokens with `MinimumLockMinutes=100`
2. Scheme manager calls `CreateScheme` with `MinimumLockMinutes=1000000`
3. Users cannot withdraw for 1000000 minutes (≈694 days) instead of expected 100 minutes
4. Funds locked far beyond user consent

**Severity Justification: HIGH**
- Direct fund impact: Complete loss of access to locked funds or unintended early access
- Breaks critical invariant: lock/unlock correctness
- Violates user expectations and lock agreements
- No recovery mechanism exists for affected users

## Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be the scheme manager (original creator of the scheme)
- No additional authorization or governance approval required
- Can be executed by any address that previously called `CreateScheme`

**Attack Complexity:**
- Extremely simple: Single transaction calling `CreateScheme` with modified parameters
- No complex state manipulation required
- No timing constraints or dependencies

**Feasibility Conditions:**
- Scheme manager role is not a privileged trusted role - any address can create schemes
- Economic cost is minimal (just transaction fees)

**Economic Rationality:**
- Malicious scheme manager could benefit by reducing `MinimumLockMinutes` to withdraw their own profits early
- Could change `Symbol` to DoS competitors' locked funds
- Could create griefing attacks at minimal cost

**Probability Assessment: HIGH**
- Public function with no access controls beyond being the original creator
- Simple to execute, whether maliciously or accidentally
- No disincentive mechanism to prevent this behavior

## Recommendation

Add a validation check in the `CreateScheme` function to prevent duplicate scheme creation:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add duplicate check
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this manager.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, if scheme updates are intended functionality, implement a separate `UpdateScheme` function with proper validation to ensure no users have active locks before allowing parameter changes.

## Proof of Concept

```csharp
[Fact]
public async Task CreateScheme_Repeatedly_Causes_Withdrawal_Failure_Test()
{
    // Step 1: Scheme manager creates initial scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 10000
    });
    
    // Step 2: User registers and locks 100 ELF tokens
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = 100,
        SchemeManager = Starter
    });
    
    // Step 3: Scheme manager calls CreateScheme again with different Symbol
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",
        MinimumLockMinutes = 1
    });
    
    // Step 4: Advance time past minimum lock period
    BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddMinutes(10001));
    
    // Step 5: User attempts to withdraw - this will fail or return 0 amount
    // because GetLockedAmount queries for USDT but tokens are locked as ELF
    var withdrawResult = await TokenHolderContractStub.Withdraw.SendAsync(Starter);
    
    // Verification: User's ELF tokens remain locked and inaccessible
    var lockId = await GetLockId(Starter, Starter);
    var lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = Starter,
        LockId = lockId,
        Symbol = "ELF"  // Original locked symbol
    });
    
    lockedAmount.Amount.ShouldBe(100); // Tokens still locked
    
    // Querying with wrong symbol returns 0
    var wrongSymbolAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = Starter,
        LockId = lockId,
        Symbol = "USDT"  // Overwritten symbol in scheme
    });
    
    wrongSymbolAmount.Amount.ShouldBe(0); // Returns 0, causing withdrawal failure
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-165)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L167-167)
```csharp
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L220-225)
```csharp
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L290-293)
```csharp
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L44-84)
```csharp
    public override Hash CreateScheme(CreateSchemeInput input)
    {
        ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);

        if (input.ProfitReceivingDuePeriodCount == 0)
            input.ProfitReceivingDuePeriodCount = ProfitContractConstants.DefaultProfitReceivingDuePeriodCount;
        else
            Assert(
                input.ProfitReceivingDuePeriodCount > 0 &&
                input.ProfitReceivingDuePeriodCount <= ProfitContractConstants.MaximumProfitReceivingDuePeriodCount,
                "Invalid profit receiving due period count.");

        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;

        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;

        Context.LogDebug(() => $"Created scheme {State.SchemeInfos[schemeId]}");

        Context.Fire(new SchemeCreated
        {
            SchemeId = scheme.SchemeId,
            Manager = scheme.Manager,
            IsReleaseAllBalanceEveryTimeByDefault = scheme.IsReleaseAllBalanceEveryTimeByDefault,
            ProfitReceivingDuePeriodCount = scheme.ProfitReceivingDuePeriodCount,
            VirtualAddress = scheme.VirtualAddress
        });
        return schemeId;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-116)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
    }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L306-325)
```csharp
    public async Task RegisterForProfits_Repeatedly_Test()
    {
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF",
            AutoDistributeThreshold = { { "ELF", 1000 } }
        });
        await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
        {
            Amount = 10,
            SchemeManager = Starter
        });
        var repeatRegisterRet = await TokenHolderContractStub.RegisterForProfits.SendWithExceptionAsync(
            new RegisterForProfitsInput
            {
                Amount = 10,
                SchemeManager = Starter
            });
        repeatRegisterRet.TransactionResult.Error.ShouldContain("Already registered.");
    }
```
