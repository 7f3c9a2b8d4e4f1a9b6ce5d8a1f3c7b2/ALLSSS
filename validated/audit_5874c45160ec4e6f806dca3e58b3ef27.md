# Audit Report

## Title
Missing ActualMiningTime Validation Enables Consensus Timestamp Manipulation

## Summary
The AEDPoS consensus contract allows malicious miners to inject arbitrary timestamps into persistent consensus state by exploiting a validation gap between block header verification and transaction parameter processing. The `ProcessUpdateValue` method stores `ActualMiningTime` from transaction input without validating it matches the block header or `Context.CurrentBlockTime`, while post-execution validation explicitly excludes `ActualMiningTimes` from hash comparison, enabling undetectable timestamp manipulation.

## Finding Description

The vulnerability stems from a critical decoupling between header validation and transaction parameter validation in the consensus update flow:

**Root Cause - Unvalidated State Update:**

The `ProcessUpdateValue` method directly adds the transaction parameter's `ActualMiningTime` to persistent state without any validation: [1](#0-0) 

**Validation Gap Analysis:**

1. **Header Validation Uses Different Data Source**: When `ValidateBeforeExecution` is called, it recovers round information from the block header's consensus extra data: [2](#0-1) 

The `RecoverFromUpdateValue` method adds the header's `ActualMiningTimes` to the validation round: [3](#0-2) 

The `TimeSlotValidationProvider` validates using this recovered header data: [4](#0-3) 

2. **Transaction Validation Ignores ActualMiningTime**: The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`, completely ignoring `ActualMiningTime`: [5](#0-4) [6](#0-5) 

3. **Post-Execution Validation Excludes ActualMiningTimes**: The `GetCheckableRound` method explicitly clears `ActualMiningTimes` before computing the hash: [7](#0-6) 

This means the post-execution hash comparison cannot detect timestamp discrepancies: [8](#0-7) 

**Normal vs Malicious Flow:**

In normal operation, `GetConsensusExtraData` correctly sets `ActualMiningTime` using `Context.CurrentBlockTime`: [9](#0-8) 

And `GenerateConsensusTransactions` creates the `UpdateValueInput` from this correct data: [10](#0-9) [11](#0-10) 

However, since `UpdateValue` is a public method: [12](#0-11) 

A malicious miner can:
1. Generate a valid block header with correct `Context.CurrentBlockTime` in consensus extra data (passes header validation)
2. Create a custom `UpdateValue` transaction with manipulated `ActualMiningTime`
3. Include this custom transaction instead of the auto-generated one
4. The manipulated timestamp is stored to state without any validation catching the discrepancy

The only permission check is `PreCheck`, which merely verifies the sender is in the current or previous miner list: [13](#0-12) 

## Impact Explanation

The manipulated `ActualMiningTimes` values corrupt critical consensus mechanisms:

**1. Term Transition Manipulation:**

The `NeedToChangeTerm` function uses `ActualMiningTimes.Last()` to determine when term transitions should occur: [14](#0-13) 

A miner injecting far-future timestamps can prematurely trigger term changes, while far-past timestamps can prevent legitimate term transitions, disrupting the election cycle, miner rotation, and reward distribution.

**2. Tiny Block Production Bypass:**

The `TinyBlockCommandStrategy` uses `ActualMiningTimes` to calculate time slot boundaries: [15](#0-14) [16](#0-15) 

By manipulating timestamps to appear before the round start time, miners can bypass the `_maximumBlocksCount` limit and produce more blocks than allowed.

**3. Consensus Timing Corruption:**

Multiple consensus view methods rely on `ActualMiningTimes` for time-based calculations. The `IsTimeSlotPassed` method uses `ActualMiningTimes` to determine mining order: [17](#0-16) 

This breaks critical consensus invariants around timing, term transitions, and fair block production.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be an elected miner (validated by `PreCheck`)
- Must have normal block production capabilities

**Attack Complexity:**
Low - The attack requires only:
1. Generating a valid block header with correct consensus extra data (standard block production)
2. Crafting a custom `UpdateValue` transaction with manipulated `ActualMiningTime`
3. Including the custom transaction in the block instead of the auto-generated one

Miners have full control over block content and transaction inclusion, making this trivially exploitable for any elected miner.

**Detection Difficulty:**
The manipulated value is stored to state and used for subsequent consensus decisions. Since validation checks the header (not the transaction parameter) and `ActualMiningTimes` is explicitly excluded from hash comparison, the manipulation occurs silently without validation failures or events.

## Recommendation

Add explicit validation in `ProcessUpdateValue` to ensure the transaction parameter's `ActualMiningTime` matches `Context.CurrentBlockTime`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // CRITICAL FIX: Validate ActualMiningTime matches current block time
    Assert(updateValueInput.ActualMiningTime == Context.CurrentBlockTime, 
        "ActualMiningTime must equal Context.CurrentBlockTime");
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
    // ... rest of method
}
```

Alternatively, replace the transaction parameter with the trusted block time:

```csharp
minerInRound.ActualMiningTimes.Add(Context.CurrentBlockTime);
```

## Proof of Concept

A PoC would demonstrate:
1. A miner creating a valid block header with correct `ActualMiningTime` in consensus extra data
2. Creating a custom `UpdateValue` transaction with `ActualMiningTime` set to a far-future timestamp (e.g., 1 year ahead)
3. Including this transaction in the block
4. Verifying the manipulated timestamp is stored in `State.Rounds[roundNumber].RealTimeMinersInformation[pubkey].ActualMiningTimes`
5. Showing `NeedToChangeTerm` prematurely returns `true`, triggering an unauthorized term transition

The test would verify that header validation passes (using correct header data) while the transaction stores incorrect data to state, demonstrating the validation gap.

---

**Notes:**

This vulnerability breaks the fundamental consensus invariant that `ActualMiningTimes` represents the true block production timestamps. The separation between header validation and transaction execution, combined with the explicit exclusion of `ActualMiningTimes` from post-execution validation, creates an exploitable gap. Any elected miner can manipulate consensus timing mechanisms to their advantage.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L47-47)
```csharp
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L20-20)
```csharp
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L41-41)
```csharp
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L44-48)
```csharp
        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L92-98)
```csharp
        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L193-193)
```csharp
            checkableMinerInRound.ActualMiningTimes.Clear();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L218-223)
```csharp
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L144-145)
```csharp
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L42-42)
```csharp
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L36-36)
```csharp
                    ? MinerInRound.ActualMiningTimes.First()
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L61-61)
```csharp
            var blocksBeforeCurrentRound = MinerInRound.ActualMiningTimes.Count(t => t < roundStartTime);
```
