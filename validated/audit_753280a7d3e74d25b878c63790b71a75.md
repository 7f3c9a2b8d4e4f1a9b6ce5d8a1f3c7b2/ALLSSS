# Audit Report

## Title
Permanent Asset Lock in NFT Contract Due to Disassemble Function Failure Without Recovery Mechanism

## Summary
The NFT contract's `Assemble` function transfers user assets (NFTs and FTs) to the contract address (`Context.Self`), but the only recovery mechanism through `Disassemble` can be permanently blocked due to burn permission checks. This results in irreversible asset loss for legitimate users.

## Finding Description

The vulnerability exists in the coupling of the asset recovery mechanism with restrictive burn permission checks.

**Asset Transfer Flow:**
When users call `Assemble`, their NFTs are transferred to the contract address via `DoTransfer` [1](#0-0) , and fungible tokens are transferred via the MultiToken contract [2](#0-1) . These assets are stored in state maps for later retrieval [3](#0-2) .

**Critical Design Flaw:**
The `Disassemble` function is the ONLY method to recover these locked assets. However, it first calls `Burn` unconditionally [4](#0-3) . The `Burn` function enforces two critical assertion checks that can permanently block asset recovery:

1. **Protocol Burnability Check:** [5](#0-4)  - The protocol must have `IsBurnable = true`.

2. **Minter Permission Check:** [6](#0-5)  - The caller must be in the minter list.

If either check fails, the entire `Disassemble` transaction reverts, and asset recovery at lines 207 and 217-222 never executes.

**No Alternative Recovery Path:**
Review of all NFT contract files confirms there is no admin withdrawal function, no governance override, and no emergency recovery mechanism. Assets in `Context.Self` can only be retrieved through `Disassemble`.

**Failure Scenarios:**
- Protocols created with `IsBurnable = false` [7](#0-6)  result in ALL assembled NFTs being permanently locked
- Non-minter users cannot disassemble their own assembled NFTs
- Secondary market buyers cannot recover underlying assets since they typically aren't minters

## Impact Explanation

**Critical Financial Loss:**
Users suffer 100% loss of assets locked in assembled tokens, including:
- High-value or unique NFTs
- Any amount of fungible tokens
- All utility and transferability of these assets

**Affected Users:**
- Anyone assembling NFTs from non-burnable protocols
- NFT holders who are not protocol minters
- All secondary market participants
- Users affected by protocol creator configuration mistakes

**Severity Justification:**
This is CRITICAL because it violates the fundamental token lock/unlock invariant. Assets become permanently inaccessible through normal, legitimate user operations without any malicious intent or attack required. The design flaw creates a systemic risk affecting protocol integrity.

## Likelihood Explanation

**High Probability:**
This vulnerability triggers through standard contract usage:
1. User calls `Assemble` with legitimate assets (normal operation)
2. Protocol has `IsBurnable = false` OR user is not a minter (common scenarios)
3. User calls `Disassemble` to recover assets
4. Transaction reverts due to burn permission checks
5. No recovery possible

**No Attack Complexity:**
- No malicious intent required
- No privilege escalation needed
- Occurs during normal user operations
- Protocol creators may legitimately choose `IsBurnable = false`
- Most NFT holders are not minters by design
- Secondary market transfers create non-minter owners

## Recommendation

**Immediate Fix:**
Decouple asset recovery from burn permission checks. The `Disassemble` function should:

1. Verify the caller owns the assembled NFT (balance check)
2. Transfer underlying assets back to the caller
3. THEN burn the assembled NFT using `Context.Self` as the burner, OR
4. Skip the burn entirely and mark the assembled NFT as "disassembled" in state

**Code Fix Approach:**
```
public override Empty Disassemble(DisassembleInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    
    // Check ownership first
    Assert(State.BalanceMap[tokenHash][Context.Sender] >= 1, "Not owner.");
    
    var receiver = input.Owner ?? Context.Sender;
    
    // Recover assets FIRST
    var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
    if (assembledNfts != null) {
        foreach (var pair in assembledNfts.Value) 
            DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);
        State.AssembledNftsMap.Remove(tokenHash);
    }
    
    var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
    if (assembledFts != null) {
        foreach (var pair in assembledFts.Value)
            State.TokenContract.Transfer.Send(new TransferInput {
                Symbol = pair.Key, Amount = pair.Value, To = receiver
            });
        State.AssembledFtsMap.Remove(tokenHash);
    }
    
    // Then handle the assembled NFT - either burn as contract or mark as disassembled
    State.BalanceMap[tokenHash][Context.Sender] = 
        State.BalanceMap[tokenHash][Context.Sender].Sub(1);
    // Update supply tracking...
    
    Context.Fire(new Disassembled { ... });
    return new Empty();
}
```

## Proof of Concept

A test demonstrating this vulnerability would:

1. Create an NFT protocol with `IsBurnable = false`
2. User assembles NFTs with FTs into an assembled NFT
3. Verify assets are in contract address (`Context.Self`)
4. User attempts to call `Disassemble`
5. Transaction reverts with "NFT Protocol ... is not burnable" error
6. Assets remain permanently locked in contract with no recovery path

The test would confirm that legitimate users cannot recover their own assets due to the restrictive burn checks in the recovery path.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L87-88)
```csharp
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L90-93)
```csharp
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L130-130)
```csharp
                DoTransfer(nftHash, Context.Sender, Context.Self, pair.Value);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L155-161)
```csharp
                State.TokenContract.TransferFrom.Send(new MultiToken.TransferFromInput
                {
                    From = Context.Sender,
                    To = Context.Self,
                    Symbol = symbol,
                    Amount = amount
                });
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L176-178)
```csharp
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;

        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L193-198)
```csharp
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L28-28)
```csharp
            IsBurnable = input.IsBurnable,
```
